import { isIE } from '../core/utils';
import { DatePart } from '../directives/date-time-editor/date-time-editor.common';
import { formatDate, FormatWidth, getLocaleDateFormat } from '@angular/common';
const DATE_CHARS = ['h', 'H', 'm', 's', 'S', 't', 'T'];
const TIME_CHARS = ['d', 'D', 'M', 'y', 'Y'];
/** @hidden */
export class DatePickerUtil {
    /**
     *  TODO: (in issue #6483) Unit tests and docs for all public methods.
     */
    /**
     * Parse a Date value from masked string input based on determined date parts
     *
     * @param inputData masked value to parse
     * @param dateTimeParts Date parts array for the mask
     */
    static parseValueFromMask(inputData, dateTimeParts, promptChar) {
        const parts = {};
        dateTimeParts.forEach(dp => {
            let value = parseInt(DatePickerUtil.getCleanVal(inputData, dp, promptChar), 10);
            if (!value) {
                value = dp.type === DatePart.Date || dp.type === DatePart.Month ? 1 : 0;
            }
            parts[dp.type] = value;
        });
        parts[DatePart.Month] -= 1;
        if (parts[DatePart.Month] < 0 || 11 < parts[DatePart.Month]) {
            return null;
        }
        // TODO: Century threshold
        if (parts[DatePart.Year] < 50) {
            parts[DatePart.Year] += 2000;
        }
        if (parts[DatePart.Date] > DatePickerUtil.daysInMonth(parts[DatePart.Year], parts[DatePart.Month])) {
            return null;
        }
        if (parts[DatePart.Hours] > 23 || parts[DatePart.Minutes] > 59 || parts[DatePart.Seconds] > 59) {
            return null;
        }
        return new Date(parts[DatePart.Year] || 2000, parts[DatePart.Month] || 0, parts[DatePart.Date] || 1, parts[DatePart.Hours] || 0, parts[DatePart.Minutes] || 0, parts[DatePart.Seconds] || 0);
    }
    /**
     * Parse the mask into date/time and literal parts
     */
    static parseDateTimeFormat(mask, locale = DatePickerUtil.DEFAULT_LOCALE) {
        const format = mask || DatePickerUtil.getDefaultInputFormat(locale);
        const dateTimeParts = [];
        const formatArray = Array.from(format);
        let currentPart = null;
        let position = 0;
        for (let i = 0; i < formatArray.length; i++, position++) {
            const type = DatePickerUtil.determineDatePart(formatArray[i]);
            if (currentPart) {
                if (currentPart.type === type) {
                    currentPart.format += formatArray[i];
                    if (i < formatArray.length - 1) {
                        continue;
                    }
                }
                DatePickerUtil.ensureLeadingZero(currentPart);
                currentPart.end = currentPart.start + currentPart.format.length;
                position = currentPart.end;
                dateTimeParts.push(currentPart);
            }
            currentPart = {
                start: position,
                end: position + formatArray[i].length,
                type,
                format: formatArray[i]
            };
        }
        return dateTimeParts;
    }
    static getDefaultInputFormat(locale) {
        if (!Intl || !Intl.DateTimeFormat || !Intl.DateTimeFormat.prototype.formatToParts) {
            // TODO: fallback with Intl.format for IE?
            return DatePickerUtil.SHORT_DATE_MASK;
        }
        const parts = DatePickerUtil.getDefaultLocaleMask(locale);
        parts.forEach(p => {
            if (p.type !== DatePart.Year && p.type !== DatePickerUtil.SEPARATOR) {
                p.formatType = "2-digit" /* TwoDigits */;
            }
        });
        return DatePickerUtil.getMask(parts);
    }
    static formatDate(value, format, locale, timezone) {
        let formattedDate;
        try {
            formattedDate = formatDate(value, format, locale, timezone);
        }
        catch (_a) {
            DatePickerUtil.logMissingLocaleSettings(locale);
            const formatter = new Intl.DateTimeFormat(locale);
            formattedDate = formatter.format(value);
        }
        return formattedDate;
    }
    static getLocaleDateFormat(locale, displayFormat) {
        const formatKeys = Object.keys(FormatWidth);
        const targetKey = formatKeys.find(k => k.toLowerCase() === (displayFormat === null || displayFormat === void 0 ? void 0 : displayFormat.toLowerCase().replace('date', '')));
        if (!targetKey) {
            // if displayFormat is not shortDate, longDate, etc.
            // or if it is not set by the user
            return displayFormat;
        }
        let format;
        try {
            format = getLocaleDateFormat(locale, FormatWidth[targetKey]);
        }
        catch (_a) {
            DatePickerUtil.logMissingLocaleSettings(locale);
            format = DatePickerUtil.getDefaultInputFormat(locale);
        }
        return format;
    }
    static isDateOrTimeChar(char) {
        return DATE_CHARS.indexOf(char) !== -1 || TIME_CHARS.indexOf(char) !== -1;
    }
    static spinDate(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth());
        let date = newDate.getDate() + delta;
        if (date > maxDate) {
            date = isSpinLoop ? date % maxDate : maxDate;
        }
        else if (date < 1) {
            date = isSpinLoop ? maxDate + (date % maxDate) : 1;
        }
        newDate.setDate(date);
    }
    static spinMonth(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth() + delta);
        if (newDate.getDate() > maxDate) {
            newDate.setDate(maxDate);
        }
        const maxMonth = 11;
        const minMonth = 0;
        let month = newDate.getMonth() + delta;
        if (month > maxMonth) {
            month = isSpinLoop ? (month % maxMonth) - 1 : maxMonth;
        }
        else if (month < minMonth) {
            month = isSpinLoop ? maxMonth + (month % maxMonth) + 1 : minMonth;
        }
        newDate.setMonth(month);
    }
    static spinYear(delta, newDate) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear() + delta, newDate.getMonth());
        if (newDate.getDate() > maxDate) {
            // clip to max to avoid leap year change shifting the entire value
            newDate.setDate(maxDate);
        }
        newDate.setFullYear(newDate.getFullYear() + delta);
    }
    static spinHours(delta, newDate, isSpinLoop) {
        const maxHour = 23;
        const minHour = 0;
        let hours = newDate.getHours() + delta;
        if (hours > maxHour) {
            hours = isSpinLoop ? hours % maxHour - 1 : maxHour;
        }
        else if (hours < minHour) {
            hours = isSpinLoop ? maxHour + (hours % maxHour) + 1 : minHour;
        }
        newDate.setHours(hours);
    }
    static spinMinutes(delta, newDate, isSpinLoop) {
        const maxMinutes = 59;
        const minMinutes = 0;
        let minutes = newDate.getMinutes() + delta;
        if (minutes > maxMinutes) {
            minutes = isSpinLoop ? minutes % maxMinutes - 1 : maxMinutes;
        }
        else if (minutes < minMinutes) {
            minutes = isSpinLoop ? maxMinutes + (minutes % maxMinutes) + 1 : minMinutes;
        }
        newDate.setMinutes(minutes);
    }
    static spinSeconds(delta, newDate, isSpinLoop) {
        const maxSeconds = 59;
        const minSeconds = 0;
        let seconds = newDate.getSeconds() + delta;
        if (seconds > maxSeconds) {
            seconds = isSpinLoop ? seconds % maxSeconds - 1 : maxSeconds;
        }
        else if (seconds < minSeconds) {
            seconds = isSpinLoop ? maxSeconds + (seconds % maxSeconds) + 1 : minSeconds;
        }
        newDate.setSeconds(seconds);
    }
    static spinAmPm(newDate, currentDate, amPmFromMask) {
        switch (amPmFromMask) {
            case 'AM':
                newDate = new Date(newDate.setHours(newDate.getHours() + 12));
                break;
            case 'PM':
                newDate = new Date(newDate.setHours(newDate.getHours() - 12));
                break;
        }
        if (newDate.getDate() !== currentDate.getDate()) {
            return currentDate;
        }
        return newDate;
    }
    /**
     * Determines whether the provided value is greater than the provided max value.
     *
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is greater than provided maxValue
     */
    static greaterThanMaxValue(value, maxValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if maxValue is Invalid Date and value is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() > maxValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _maxValue = new Date(maxValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _maxValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _maxValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() > _maxValue.getTime();
    }
    /**
     * Determines whether the provided value is less than the provided min value.
     *
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is less than provided minValue
     */
    static lessThanMinValue(value, minValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if value is Invalid Date and minValue is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() < minValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _minValue = new Date(minValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _minValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _minValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() < _minValue.getTime();
    }
    /**
     * This method generates date parts structure based on editor mask and locale.
     *
     * @param maskValue: string
     * @param locale: string
     * @returns array containing information about date parts - type, position, format
     */
    static parseDateFormat(maskValue, locale = DatePickerUtil.DEFAULT_LOCALE) {
        let dateStruct = [];
        if (maskValue === undefined && !isIE()) {
            dateStruct = DatePickerUtil.getDefaultLocaleMask(locale);
        }
        else {
            const mask = (maskValue) ? maskValue : DatePickerUtil.SHORT_DATE_MASK;
            const maskArray = Array.from(mask);
            const monthInitPosition = mask.indexOf("M" /* MonthChar */);
            const dayInitPosition = mask.indexOf("d" /* DayChar */);
            const yearInitPosition = mask.indexOf("y" /* YearChar */);
            if (yearInitPosition !== -1) {
                dateStruct.push({
                    type: "year" /* Year */,
                    initialPosition: yearInitPosition,
                    formatType: DatePickerUtil.getYearFormatType(mask)
                });
            }
            if (monthInitPosition !== -1) {
                dateStruct.push({
                    type: "month" /* Month */,
                    initialPosition: monthInitPosition,
                    formatType: DatePickerUtil.getMonthFormatType(mask)
                });
            }
            if (dayInitPosition !== -1) {
                dateStruct.push({
                    type: "day" /* Day */,
                    initialPosition: dayInitPosition,
                    formatType: DatePickerUtil.getDayFormatType(mask)
                });
            }
            for (let i = 0; i < maskArray.length; i++) {
                if (!DatePickerUtil.isDateChar(maskArray[i])) {
                    dateStruct.push({
                        type: DatePickerUtil.SEPARATOR,
                        initialPosition: i,
                        value: maskArray[i]
                    });
                }
            }
            dateStruct.sort((a, b) => a.initialPosition - b.initialPosition);
            DatePickerUtil.fillDatePartsPositions(dateStruct);
        }
        return dateStruct;
    }
    /**
     * This method generates input mask based on date parts.
     *
     * @param dateStruct array
     * @returns input mask
     */
    static getInputMask(dateStruct) {
        const inputMask = [];
        for (const part of dateStruct) {
            if (part.type === DatePickerUtil.SEPARATOR) {
                inputMask.push(part.value);
            }
            else if (part.type === "day" /* Day */ || part.type === "month" /* Month */) {
                inputMask.push('00');
            }
            else if (part.type === "year" /* Year */) {
                switch (part.formatType) {
                    case "numeric" /* Numeric */: {
                        inputMask.push('0000');
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        inputMask.push('00');
                        break;
                    }
                }
            }
        }
        return inputMask.join('');
    }
    /**
     * This method generates editor mask.
     *
     * @param dateStruct
     * @returns editor mask
     */
    static getMask(dateStruct) {
        const mask = [];
        for (const part of dateStruct) {
            switch (part.formatType) {
                case "numeric" /* Numeric */: {
                    if (part.type === "day" /* Day */) {
                        mask.push('d');
                    }
                    else if (part.type === "month" /* Month */) {
                        mask.push('M');
                    }
                    else {
                        mask.push('yyyy');
                    }
                    break;
                }
                case "2-digit" /* TwoDigits */: {
                    if (part.type === "day" /* Day */) {
                        mask.push('dd');
                    }
                    else if (part.type === "month" /* Month */) {
                        mask.push('MM');
                    }
                    else {
                        mask.push('yy');
                    }
                }
            }
            if (part.type === DatePickerUtil.SEPARATOR) {
                mask.push(part.value);
            }
        }
        return mask.join('');
    }
    /**
     * This method parses an input string base on date parts and returns a date and its validation state.
     *
     * @param dateFormatParts
     * @param prevDateValue
     * @param inputValue
     * @returns object containing a date and its validation state
     */
    static parseDateArray(dateFormatParts, prevDateValue, inputValue) {
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, inputValue);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue);
        const yearStr = DatePickerUtil.getYearValueFromInput(dateFormatParts, inputValue);
        const yearFormat = DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType;
        const day = (dayStr !== '') ? parseInt(dayStr, 10) : 1;
        const month = (monthStr !== '') ? parseInt(monthStr, 10) - 1 : 0;
        let year;
        if (yearStr === '') {
            year = (yearFormat === "2-digit" /* TwoDigits */) ? '00' : '2000';
        }
        else {
            year = yearStr;
        }
        let yearPrefix;
        if (prevDateValue) {
            const originalYear = prevDateValue.getFullYear().toString();
            if (originalYear.length === 4) {
                yearPrefix = originalYear.substring(0, 2);
            }
        }
        else {
            yearPrefix = '20';
        }
        const fullYear = (yearFormat === "2-digit" /* TwoDigits */) ? yearPrefix.concat(year) : year;
        if ((month < 0) || (month > 11) || isNaN(month)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        if ((day < 1) || (day > DatePickerUtil.daysInMonth(fullYear, month)) || isNaN(day)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        return { state: "valid" /* Valid */, date: new Date(fullYear, month, day) };
    }
    static maskToPromptChars(mask) {
        const result = mask.replace(/0|L/g, DatePickerUtil.PROMPT_CHAR);
        return result;
    }
    /**
     * This method replaces prompt chars with empty string.
     *
     * @param value
     */
    static trimEmptyPlaceholders(value, promptChar) {
        const result = value.replace(new RegExp(promptChar || '_', 'g'), '');
        return result;
    }
    /**
     * This method is used for spinning date parts.
     *
     * @param dateFormatParts
     * @param inputValue
     * @param position
     * @param delta
     * @param isSpinLoop
     * @return modified text input
     */
    static getModifiedDateInput(dateFormatParts, inputValue, position, delta, isSpinLoop) {
        const datePart = DatePickerUtil.getDatePartOnPosition(dateFormatParts, position);
        const datePartType = datePart.type;
        const datePartFormatType = datePart.formatType;
        let newValue;
        const datePartValue = DatePickerUtil.getDateValueFromInput(dateFormatParts, datePartType, inputValue);
        newValue = parseInt(datePartValue, 10);
        const minMax = DatePickerUtil.getMinMaxValue(dateFormatParts, datePart, inputValue);
        const minValue = minMax.min;
        const maxValue = minMax.max;
        if (isNaN(newValue)) {
            if (minValue === 'infinite') {
                newValue = 2000;
            }
            else {
                newValue = minValue;
            }
        }
        let tempValue = newValue;
        tempValue += delta;
        // Infinite loop for full years
        if (maxValue === 'infinite' && minValue === 'infinite') {
            newValue = tempValue;
        }
        if (isSpinLoop) {
            if (tempValue > maxValue) {
                tempValue = minValue;
            }
            if (tempValue < minValue) {
                tempValue = maxValue;
            }
            newValue = tempValue;
        }
        else {
            if (tempValue <= maxValue && tempValue >= minValue) {
                newValue = tempValue;
            }
        }
        const startIdx = datePart.position[0];
        const endIdx = datePart.position[1];
        const start = inputValue.slice(0, startIdx);
        const end = inputValue.slice(endIdx, inputValue.length);
        const prefix = DatePickerUtil.getNumericFormatPrefix(datePartFormatType);
        const changedPart = (newValue < 10) ? `${prefix}${newValue}` : `${newValue}`;
        return `${start}${changedPart}${end}`;
    }
    /**
     * This method returns date input with prompt chars.
     *
     * @param dateFormatParts
     * @param date
     * @param inputValue
     * @returns date input including prompt chars
     */
    static addPromptCharsEditMode(dateFormatParts, date, inputValue) {
        const dateArray = Array.from(inputValue);
        for (const part of dateFormatParts) {
            if (part.formatType === "numeric" /* Numeric */) {
                if ((part.type === "day" /* Day */ && date.getDate() < 10)
                    || (part.type === "month" /* Month */ && date.getMonth() + 1 < 10)) {
                    dateArray.splice(part.position[0], 0, DatePickerUtil.PROMPT_CHAR);
                    dateArray.join('');
                }
            }
        }
        return dateArray.join('');
    }
    /**
     * This method checks if date input is done.
     *
     * @param dateFormatParts
     * @param input
     * @returns input completeness
     */
    static checkForCompleteDateInput(dateFormatParts, input) {
        const dayValue = DatePickerUtil.getDayValueFromInput(dateFormatParts, input);
        const monthValue = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input);
        const yearValue = DatePickerUtil.getYearValueFromInput(dateFormatParts, input);
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, input, false);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input, false);
        if (DatePickerUtil.isFullInput(dayValue, dayStr)
            && DatePickerUtil.isFullInput(monthValue, monthStr)
            && DatePickerUtil.isFullYearInput(dateFormatParts, yearValue)) {
            return 'complete';
        }
        else if (dayValue === '' && monthValue === '' && yearValue === '') {
            return 'empty';
        }
        else if (dayValue === '' || monthValue === '' || yearValue === '') {
            return 'partial';
        }
        return '';
    }
    static daysInMonth(fullYear, month) {
        return new Date(fullYear, month + 1, 0).getDate();
    }
    /**
     * Parse provided input to Date.
     *
     * @param value input to parse
     * @returns Date if parse succeed or null
     */
    static parseDate(value) {
        if (typeof value === 'number') {
            return new Date(value);
        }
        // if value is Invalid Date we should return null
        if (DatePickerUtil.isDate(value)) {
            return DatePickerUtil.isValidDate(value) ? value : null;
        }
        return value ? new Date(Date.parse(value)) : null;
    }
    /**
     * Returns whether provided input is date
     *
     * @param value input to check
     * @returns true if provided input is date
     */
    static isDate(value) {
        return Object.prototype.toString.call(value) === '[object Date]';
    }
    /**
     * Returns whether the input is valid date
     *
     * @param value input to check
     * @returns true if provided input is a valid date
     */
    static isValidDate(value) {
        if (DatePickerUtil.isDate(value)) {
            return !isNaN(value.getTime());
        }
        return false;
    }
    static logMissingLocaleSettings(locale) {
        console.warn(`Missing locale data for the locale ${locale}. Please refer to https://angular.io/guide/i18n#i18n-pipes`);
        console.warn('Using default browser locale settings.');
    }
    static ensureLeadingZero(part) {
        switch (part.type) {
            case DatePart.Date:
            case DatePart.Month:
            case DatePart.Hours:
            case DatePart.Minutes:
            case DatePart.Seconds:
                if (part.format.length === 1) {
                    part.format = part.format.repeat(2);
                }
                break;
        }
    }
    static getCleanVal(inputData, datePart, promptChar) {
        return DatePickerUtil.trimEmptyPlaceholders(inputData.substring(datePart.start, datePart.end), promptChar);
    }
    static determineDatePart(char) {
        switch (char) {
            case 'd':
            case 'D':
                return DatePart.Date;
            case 'M':
                return DatePart.Month;
            case 'y':
            case 'Y':
                return DatePart.Year;
            case 'h':
            case 'H':
                return DatePart.Hours;
            case 'm':
                return DatePart.Minutes;
            case 's':
            case 'S':
                return DatePart.Seconds;
            case 't':
            case 'T':
                return DatePart.AmPm;
            default:
                return DatePart.Literal;
        }
    }
    static getYearFormatType(format) {
        switch (format.match(new RegExp("y" /* YearChar */, 'g')).length) {
            case 1: {
                // y (2020)
                return "numeric" /* Numeric */;
            }
            case 4: {
                // yyyy (2020)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // yy (20)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getMonthFormatType(format) {
        switch (format.match(new RegExp("M" /* MonthChar */, 'g')).length) {
            case 1: {
                // M (8)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // MM (08)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDayFormatType(format) {
        switch (format.match(new RegExp("d" /* DayChar */, 'g')).length) {
            case 1: {
                // d (6)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // dd (06)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDefaultLocaleMask(locale) {
        const dateStruct = [];
        const formatter = new Intl.DateTimeFormat(locale);
        const formatToParts = formatter.formatToParts(new Date());
        for (const part of formatToParts) {
            if (part.type === DatePickerUtil.SEPARATOR) {
                dateStruct.push({
                    type: DatePickerUtil.SEPARATOR,
                    value: part.value
                });
            }
            else {
                dateStruct.push({
                    type: part.type
                });
            }
        }
        const formatterOptions = formatter.resolvedOptions();
        for (const part of dateStruct) {
            switch (part.type) {
                case "day" /* Day */: {
                    part.formatType = formatterOptions.day;
                    break;
                }
                case "month" /* Month */: {
                    part.formatType = formatterOptions.month;
                    break;
                }
                case "year" /* Year */: {
                    part.formatType = formatterOptions.year;
                    break;
                }
            }
        }
        DatePickerUtil.fillDatePartsPositions(dateStruct);
        return dateStruct;
    }
    static isDateChar(char) {
        return (char === "y" /* YearChar */ || char === "M" /* MonthChar */ || char === "d" /* DayChar */);
    }
    static getNumericFormatPrefix(formatType) {
        switch (formatType) {
            case "2-digit" /* TwoDigits */: {
                return '0';
            }
            case "numeric" /* Numeric */: {
                return DatePickerUtil.PROMPT_CHAR;
            }
        }
    }
    static getMinMaxValue(dateFormatParts, datePart, inputValue) {
        let maxValue;
        let minValue;
        switch (datePart.type) {
            case "month" /* Month */: {
                minValue = 1;
                maxValue = DatePickerUtil.NUMBER_OF_MONTHS;
                break;
            }
            case "day" /* Day */: {
                minValue = 1;
                maxValue = DatePickerUtil.daysInMonth(DatePickerUtil.getFullYearFromString(DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */), inputValue), parseInt(DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue), 10));
                break;
            }
            case "year" /* Year */: {
                if (datePart.formatType === "2-digit" /* TwoDigits */) {
                    minValue = 0;
                    maxValue = 99;
                }
                else {
                    // Infinite loop
                    minValue = 'infinite';
                    maxValue = 'infinite';
                }
                break;
            }
        }
        return { min: minValue, max: maxValue };
    }
    static getDateValueFromInput(dateFormatParts, type, inputValue, trim = true) {
        const partPosition = DatePickerUtil.getDateFormatPart(dateFormatParts, type).position;
        const result = inputValue.substring(partPosition[0], partPosition[1]);
        return (trim) ? DatePickerUtil.trimEmptyPlaceholders(result) : result;
    }
    static getDayValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "day" /* Day */, inputValue, trim);
    }
    static getMonthValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "month" /* Month */, inputValue, trim);
    }
    static getYearValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "year" /* Year */, inputValue, trim);
    }
    static getDateFormatPart(dateFormatParts, type) {
        const result = dateFormatParts.filter((datePart) => (datePart.type === type))[0];
        return result;
    }
    static isFullInput(value, input) {
        return (value !== '' && input.length === 2 && input.charAt(1) !== DatePickerUtil.PROMPT_CHAR);
    }
    static isFullYearInput(dateFormatParts, value) {
        switch (DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType) {
            case "numeric" /* Numeric */: {
                return (value !== '' && value.length === 4);
            }
            case "2-digit" /* TwoDigits */: {
                return (value !== '' && value.length === 2);
            }
            default: {
                return false;
            }
        }
    }
    static getDatePartOnPosition(dateFormatParts, position) {
        const result = dateFormatParts.filter((element) => element.position[0] <= position && position <= element.position[1] && element.type !== DatePickerUtil.SEPARATOR)[0];
        return result;
    }
    static getFullYearFromString(yearPart, inputValue) {
        return parseInt(inputValue.substring(yearPart.position[0], yearPart.position[1]), 10);
    }
    static fillDatePartsPositions(dateArray) {
        let currentPos = 0;
        for (const part of dateArray) {
            // Day|Month part positions
            if (part.type === "day" /* Day */ || part.type === "month" /* Month */) {
                // Offset 2 positions for number
                part.position = [currentPos, currentPos + 2];
                currentPos += 2;
            }
            else if (part.type === "year" /* Year */) {
                // Year part positions
                switch (part.formatType) {
                    case "numeric" /* Numeric */: {
                        // Offset 4 positions for full year
                        part.position = [currentPos, currentPos + 4];
                        currentPos += 4;
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        // Offset 2 positions for short year
                        part.position = [currentPos, currentPos + 2];
                        currentPos += 2;
                        break;
                    }
                }
            }
            else if (part.type === DatePickerUtil.SEPARATOR) {
                // Separator positions
                part.position = [currentPos, currentPos + 1];
                currentPos++;
            }
        }
    }
}
DatePickerUtil.DEFAULT_INPUT_FORMAT = 'MM/dd/yyyy';
// TODO: this is the def mask for the date-picker, should remove it during refactoring
DatePickerUtil.SHORT_DATE_MASK = 'MM/dd/yy';
DatePickerUtil.SEPARATOR = 'literal';
DatePickerUtil.NUMBER_OF_MONTHS = 12;
DatePickerUtil.PROMPT_CHAR = '_';
DatePickerUtil.DEFAULT_LOCALE = 'en';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXIudXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZGF0ZS1waWNrZXIvZGF0ZS1waWNrZXIudXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyQyxPQUFPLEVBQUUsUUFBUSxFQUFnQixNQUFNLHdEQUF3RCxDQUFDO0FBQ2hHLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLG1CQUFtQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUF5Qi9FLE1BQU0sVUFBVSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDdkQsTUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFVN0MsY0FBYztBQUNkLE1BQU0sT0FBZ0IsY0FBYztJQVNoQzs7T0FFRztJQUlIOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLGtCQUFrQixDQUFDLFNBQWlCLEVBQUUsYUFBNkIsRUFBRSxVQUFtQjtRQUNsRyxNQUFNLEtBQUssR0FBa0MsRUFBUyxDQUFDO1FBQ3ZELGFBQWEsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDdkIsSUFBSSxLQUFLLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFLEVBQUUsRUFBRSxVQUFVLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNoRixJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNSLEtBQUssR0FBRyxFQUFFLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDLElBQUksS0FBSyxR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VUFBVSxFQUFFLENBQUM7YUFDaEI7U0FDSjtJQUNMLENBQUM7O0FBcjRCc0IsbUNBQW9CLEdBQUcsWUFBWSxDQUFDO0FBQzNELHNGQUFzRjtBQUM5RCw4QkFBZSxHQUFHLFVBQVUsQ0FBQztBQUM3Qix3QkFBUyxHQUFHLFNBQVMsQ0FBQztBQUN0QiwrQkFBZ0IsR0FBRyxFQUFFLENBQUM7QUFDdEIsMEJBQVcsR0FBRyxHQUFHLENBQUM7QUFDbEIsNkJBQWMsR0FBRyxJQUFJLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0lFIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBEYXRlUGFydCwgRGF0ZVBhcnRJbmZvIH0gZnJvbSAnLi4vZGlyZWN0aXZlcy9kYXRlLXRpbWUtZWRpdG9yL2RhdGUtdGltZS1lZGl0b3IuY29tbW9uJztcbmltcG9ydCB7IGZvcm1hdERhdGUsIEZvcm1hdFdpZHRoLCBnZXRMb2NhbGVEYXRlRm9ybWF0IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBUaGlzIGVudW0gaXMgdXNlZCB0byBrZWVwIHRoZSBkYXRlIHZhbGlkYXRpb24gcmVzdWx0LlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gRGF0ZVN0YXRlIHtcbiAgICBWYWxpZCA9ICd2YWxpZCcsXG4gICAgSW52YWxpZCA9ICdpbnZhbGlkJyxcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGVudW0gRm9ybWF0RGVzYyB7XG4gICAgTnVtZXJpYyA9ICdudW1lcmljJyxcbiAgICBUd29EaWdpdHMgPSAnMi1kaWdpdCdcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGVudW0gRGF0ZUNoYXJzIHtcbiAgICBZZWFyQ2hhciA9ICd5JyxcbiAgICBNb250aENoYXIgPSAnTScsXG4gICAgRGF5Q2hhciA9ICdkJ1xufVxuXG5jb25zdCBEQVRFX0NIQVJTID0gWydoJywgJ0gnLCAnbScsICdzJywgJ1MnLCAndCcsICdUJ107XG5jb25zdCBUSU1FX0NIQVJTID0gWydkJywgJ0QnLCAnTScsICd5JywgJ1knXTtcblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGVudW0gRGF0ZVBhcnRzIHtcbiAgICBEYXkgPSAnZGF5JyxcbiAgICBNb250aCA9ICdtb250aCcsXG4gICAgWWVhciA9ICd5ZWFyJ1xufVxuXG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0ZVBpY2tlclV0aWwge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9JTlBVVF9GT1JNQVQgPSAnTU0vZGQveXl5eSc7XG4gICAgLy8gVE9ETzogdGhpcyBpcyB0aGUgZGVmIG1hc2sgZm9yIHRoZSBkYXRlLXBpY2tlciwgc2hvdWxkIHJlbW92ZSBpdCBkdXJpbmcgcmVmYWN0b3JpbmdcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTSE9SVF9EQVRFX01BU0sgPSAnTU0vZGQveXknO1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFNFUEFSQVRPUiA9ICdsaXRlcmFsJztcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBOVU1CRVJfT0ZfTU9OVEhTID0gMTI7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgUFJPTVBUX0NIQVIgPSAnXyc7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9MT0NBTEUgPSAnZW4nO1xuXG4gICAgLyoqXG4gICAgICogIFRPRE86IChpbiBpc3N1ZSAjNjQ4MykgVW5pdCB0ZXN0cyBhbmQgZG9jcyBmb3IgYWxsIHB1YmxpYyBtZXRob2RzLlxuICAgICAqL1xuXG5cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgRGF0ZSB2YWx1ZSBmcm9tIG1hc2tlZCBzdHJpbmcgaW5wdXQgYmFzZWQgb24gZGV0ZXJtaW5lZCBkYXRlIHBhcnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXREYXRhIG1hc2tlZCB2YWx1ZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSBkYXRlVGltZVBhcnRzIERhdGUgcGFydHMgYXJyYXkgZm9yIHRoZSBtYXNrXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZVZhbHVlRnJvbU1hc2soaW5wdXREYXRhOiBzdHJpbmcsIGRhdGVUaW1lUGFydHM6IERhdGVQYXJ0SW5mb1tdLCBwcm9tcHRDaGFyPzogc3RyaW5nKTogRGF0ZSB8IG51bGwge1xuICAgICAgICBjb25zdCBwYXJ0czogeyBba2V5IGluIERhdGVQYXJ0XTogbnVtYmVyIH0gPSB7fSBhcyBhbnk7XG4gICAgICAgIGRhdGVUaW1lUGFydHMuZm9yRWFjaChkcCA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUludChEYXRlUGlja2VyVXRpbC5nZXRDbGVhblZhbChpbnB1dERhdGEsIGRwLCBwcm9tcHRDaGFyKSwgMTApO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZHAudHlwZSA9PT0gRGF0ZVBhcnQuRGF0ZSB8fCBkcC50eXBlID09PSBEYXRlUGFydC5Nb250aCA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFydHNbZHAudHlwZV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcnRzW0RhdGVQYXJ0Lk1vbnRoXSAtPSAxO1xuXG4gICAgICAgIGlmIChwYXJ0c1tEYXRlUGFydC5Nb250aF0gPCAwIHx8IDExIDwgcGFydHNbRGF0ZVBhcnQuTW9udGhdKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IENlbnR1cnkgdGhyZXNob2xkXG4gICAgICAgIGlmIChwYXJ0c1tEYXRlUGFydC5ZZWFyXSA8IDUwKSB7XG4gICAgICAgICAgICBwYXJ0c1tEYXRlUGFydC5ZZWFyXSArPSAyMDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRzW0RhdGVQYXJ0LkRhdGVdID4gRGF0ZVBpY2tlclV0aWwuZGF5c0luTW9udGgocGFydHNbRGF0ZVBhcnQuWWVhcl0sIHBhcnRzW0RhdGVQYXJ0Lk1vbnRoXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRzW0RhdGVQYXJ0LkhvdXJzXSA+IDIzIHx8IHBhcnRzW0RhdGVQYXJ0Lk1pbnV0ZXNdID4gNTkgfHwgcGFydHNbRGF0ZVBhcnQuU2Vjb25kc10gPiA1OSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERhdGUoXG4gICAgICAgICAgICBwYXJ0c1tEYXRlUGFydC5ZZWFyXSB8fCAyMDAwLFxuICAgICAgICAgICAgcGFydHNbRGF0ZVBhcnQuTW9udGhdIHx8IDAsXG4gICAgICAgICAgICBwYXJ0c1tEYXRlUGFydC5EYXRlXSB8fCAxLFxuICAgICAgICAgICAgcGFydHNbRGF0ZVBhcnQuSG91cnNdIHx8IDAsXG4gICAgICAgICAgICBwYXJ0c1tEYXRlUGFydC5NaW51dGVzXSB8fCAwLFxuICAgICAgICAgICAgcGFydHNbRGF0ZVBhcnQuU2Vjb25kc10gfHwgMFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBtYXNrIGludG8gZGF0ZS90aW1lIGFuZCBsaXRlcmFsIHBhcnRzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZURhdGVUaW1lRm9ybWF0KG1hc2s6IHN0cmluZywgbG9jYWxlOiBzdHJpbmcgPSBEYXRlUGlja2VyVXRpbC5ERUZBVUxUX0xPQ0FMRSk6IERhdGVQYXJ0SW5mb1tdIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gbWFzayB8fCBEYXRlUGlja2VyVXRpbC5nZXREZWZhdWx0SW5wdXRGb3JtYXQobG9jYWxlKTtcbiAgICAgICAgY29uc3QgZGF0ZVRpbWVQYXJ0czogRGF0ZVBhcnRJbmZvW10gPSBbXTtcbiAgICAgICAgY29uc3QgZm9ybWF0QXJyYXkgPSBBcnJheS5mcm9tKGZvcm1hdCk7XG4gICAgICAgIGxldCBjdXJyZW50UGFydDogRGF0ZVBhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdEFycmF5Lmxlbmd0aDsgaSsrLCBwb3NpdGlvbisrKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gRGF0ZVBpY2tlclV0aWwuZGV0ZXJtaW5lRGF0ZVBhcnQoZm9ybWF0QXJyYXlbaV0pO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJ0LnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcnQuZm9ybWF0ICs9IGZvcm1hdEFycmF5W2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGZvcm1hdEFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgRGF0ZVBpY2tlclV0aWwuZW5zdXJlTGVhZGluZ1plcm8oY3VycmVudFBhcnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJ0LmVuZCA9IGN1cnJlbnRQYXJ0LnN0YXJ0ICsgY3VycmVudFBhcnQuZm9ybWF0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGN1cnJlbnRQYXJ0LmVuZDtcbiAgICAgICAgICAgICAgICBkYXRlVGltZVBhcnRzLnB1c2goY3VycmVudFBhcnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50UGFydCA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZW5kOiBwb3NpdGlvbiArIGZvcm1hdEFycmF5W2ldLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0QXJyYXlbaV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZVRpbWVQYXJ0cztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldERlZmF1bHRJbnB1dEZvcm1hdChsb2NhbGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmICghSW50bCB8fCAhSW50bC5EYXRlVGltZUZvcm1hdCB8fCAhSW50bC5EYXRlVGltZUZvcm1hdC5wcm90b3R5cGUuZm9ybWF0VG9QYXJ0cykge1xuICAgICAgICAgICAgLy8gVE9ETzogZmFsbGJhY2sgd2l0aCBJbnRsLmZvcm1hdCBmb3IgSUU/XG4gICAgICAgICAgICByZXR1cm4gRGF0ZVBpY2tlclV0aWwuU0hPUlRfREFURV9NQVNLO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGVmYXVsdExvY2FsZU1hc2sobG9jYWxlKTtcbiAgICAgICAgcGFydHMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgIT09IERhdGVQYXJ0LlllYXIgJiYgcC50eXBlICE9PSBEYXRlUGlja2VyVXRpbC5TRVBBUkFUT1IpIHtcbiAgICAgICAgICAgICAgICBwLmZvcm1hdFR5cGUgPSBGb3JtYXREZXNjLlR3b0RpZ2l0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLmdldE1hc2socGFydHMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZm9ybWF0RGF0ZSh2YWx1ZTogbnVtYmVyIHwgRGF0ZSwgZm9ybWF0OiBzdHJpbmcsIGxvY2FsZTogc3RyaW5nLCB0aW1lem9uZT86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGxldCBmb3JtYXR0ZWREYXRlOiBzdHJpbmc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWREYXRlID0gZm9ybWF0RGF0ZSh2YWx1ZSwgZm9ybWF0LCBsb2NhbGUsIHRpbWV6b25lKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBEYXRlUGlja2VyVXRpbC5sb2dNaXNzaW5nTG9jYWxlU2V0dGluZ3MobG9jYWxlKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSk7XG4gICAgICAgICAgICBmb3JtYXR0ZWREYXRlID0gZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkRGF0ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldExvY2FsZURhdGVGb3JtYXQobG9jYWxlOiBzdHJpbmcsIGRpc3BsYXlGb3JtYXQ/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBmb3JtYXRLZXlzID0gT2JqZWN0LmtleXMoRm9ybWF0V2lkdGgpIGFzIChrZXlvZiBGb3JtYXRXaWR0aClbXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gZm9ybWF0S2V5cy5maW5kKGsgPT4gay50b0xvd2VyQ2FzZSgpID09PSBkaXNwbGF5Rm9ybWF0Py50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ2RhdGUnLCAnJykpO1xuICAgICAgICBpZiAoIXRhcmdldEtleSkge1xuICAgICAgICAgICAgLy8gaWYgZGlzcGxheUZvcm1hdCBpcyBub3Qgc2hvcnREYXRlLCBsb25nRGF0ZSwgZXRjLlxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgaXMgbm90IHNldCBieSB0aGUgdXNlclxuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvcm1hdDogc3RyaW5nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZ2V0TG9jYWxlRGF0ZUZvcm1hdChsb2NhbGUsIEZvcm1hdFdpZHRoW3RhcmdldEtleV0pO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIERhdGVQaWNrZXJVdGlsLmxvZ01pc3NpbmdMb2NhbGVTZXR0aW5ncyhsb2NhbGUpO1xuICAgICAgICAgICAgZm9ybWF0ID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGVmYXVsdElucHV0Rm9ybWF0KGxvY2FsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaXNEYXRlT3JUaW1lQ2hhcihjaGFyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIERBVEVfQ0hBUlMuaW5kZXhPZihjaGFyKSAhPT0gLTEgfHwgVElNRV9DSEFSUy5pbmRleE9mKGNoYXIpICE9PSAtMTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHNwaW5EYXRlKGRlbHRhOiBudW1iZXIsIG5ld0RhdGU6IERhdGUsIGlzU3Bpbkxvb3A6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWF4RGF0ZSA9IERhdGVQaWNrZXJVdGlsLmRheXNJbk1vbnRoKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSwgbmV3RGF0ZS5nZXRNb250aCgpKTtcbiAgICAgICAgbGV0IGRhdGUgPSBuZXdEYXRlLmdldERhdGUoKSArIGRlbHRhO1xuICAgICAgICBpZiAoZGF0ZSA+IG1heERhdGUpIHtcbiAgICAgICAgICAgIGRhdGUgPSBpc1NwaW5Mb29wID8gZGF0ZSAlIG1heERhdGUgOiBtYXhEYXRlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGUgPCAxKSB7XG4gICAgICAgICAgICBkYXRlID0gaXNTcGluTG9vcCA/IG1heERhdGUgKyAoZGF0ZSAlIG1heERhdGUpIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0RhdGUuc2V0RGF0ZShkYXRlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHNwaW5Nb250aChkZWx0YTogbnVtYmVyLCBuZXdEYXRlOiBEYXRlLCBpc1NwaW5Mb29wOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1heERhdGUgPSBEYXRlUGlja2VyVXRpbC5kYXlzSW5Nb250aChuZXdEYXRlLmdldEZ1bGxZZWFyKCksIG5ld0RhdGUuZ2V0TW9udGgoKSArIGRlbHRhKTtcbiAgICAgICAgaWYgKG5ld0RhdGUuZ2V0RGF0ZSgpID4gbWF4RGF0ZSkge1xuICAgICAgICAgICAgbmV3RGF0ZS5zZXREYXRlKG1heERhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWF4TW9udGggPSAxMTtcbiAgICAgICAgY29uc3QgbWluTW9udGggPSAwO1xuICAgICAgICBsZXQgbW9udGggPSBuZXdEYXRlLmdldE1vbnRoKCkgKyBkZWx0YTtcbiAgICAgICAgaWYgKG1vbnRoID4gbWF4TW9udGgpIHtcbiAgICAgICAgICAgIG1vbnRoID0gaXNTcGluTG9vcCA/IChtb250aCAlIG1heE1vbnRoKSAtIDEgOiBtYXhNb250aDtcbiAgICAgICAgfSBlbHNlIGlmIChtb250aCA8IG1pbk1vbnRoKSB7XG4gICAgICAgICAgICBtb250aCA9IGlzU3Bpbkxvb3AgPyBtYXhNb250aCArIChtb250aCAlIG1heE1vbnRoKSArIDEgOiBtaW5Nb250aDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0RhdGUuc2V0TW9udGgobW9udGgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgc3BpblllYXIoZGVsdGE6IG51bWJlciwgbmV3RGF0ZTogRGF0ZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBtYXhEYXRlID0gRGF0ZVBpY2tlclV0aWwuZGF5c0luTW9udGgobmV3RGF0ZS5nZXRGdWxsWWVhcigpICsgZGVsdGEsIG5ld0RhdGUuZ2V0TW9udGgoKSk7XG4gICAgICAgIGlmIChuZXdEYXRlLmdldERhdGUoKSA+IG1heERhdGUpIHtcbiAgICAgICAgICAgIC8vIGNsaXAgdG8gbWF4IHRvIGF2b2lkIGxlYXAgeWVhciBjaGFuZ2Ugc2hpZnRpbmcgdGhlIGVudGlyZSB2YWx1ZVxuICAgICAgICAgICAgbmV3RGF0ZS5zZXREYXRlKG1heERhdGUpO1xuICAgICAgICB9XG4gICAgICAgIG5ld0RhdGUuc2V0RnVsbFllYXIobmV3RGF0ZS5nZXRGdWxsWWVhcigpICsgZGVsdGEpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgc3BpbkhvdXJzKGRlbHRhOiBudW1iZXIsIG5ld0RhdGU6IERhdGUsIGlzU3Bpbkxvb3A6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWF4SG91ciA9IDIzO1xuICAgICAgICBjb25zdCBtaW5Ib3VyID0gMDtcbiAgICAgICAgbGV0IGhvdXJzID0gbmV3RGF0ZS5nZXRIb3VycygpICsgZGVsdGE7XG4gICAgICAgIGlmIChob3VycyA+IG1heEhvdXIpIHtcbiAgICAgICAgICAgIGhvdXJzID0gaXNTcGluTG9vcCA/IGhvdXJzICUgbWF4SG91ciAtIDEgOiBtYXhIb3VyO1xuICAgICAgICB9IGVsc2UgaWYgKGhvdXJzIDwgbWluSG91cikge1xuICAgICAgICAgICAgaG91cnMgPSBpc1NwaW5Mb29wID8gbWF4SG91ciArIChob3VycyAlIG1heEhvdXIpICsgMSA6IG1pbkhvdXI7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdEYXRlLnNldEhvdXJzKGhvdXJzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHNwaW5NaW51dGVzKGRlbHRhOiBudW1iZXIsIG5ld0RhdGU6IERhdGUsIGlzU3Bpbkxvb3A6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWF4TWludXRlcyA9IDU5O1xuICAgICAgICBjb25zdCBtaW5NaW51dGVzID0gMDtcbiAgICAgICAgbGV0IG1pbnV0ZXMgPSBuZXdEYXRlLmdldE1pbnV0ZXMoKSArIGRlbHRhO1xuICAgICAgICBpZiAobWludXRlcyA+IG1heE1pbnV0ZXMpIHtcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBpc1NwaW5Mb29wID8gbWludXRlcyAlIG1heE1pbnV0ZXMgLSAxIDogbWF4TWludXRlcztcbiAgICAgICAgfSBlbHNlIGlmIChtaW51dGVzIDwgbWluTWludXRlcykge1xuICAgICAgICAgICAgbWludXRlcyA9IGlzU3Bpbkxvb3AgPyBtYXhNaW51dGVzICsgKG1pbnV0ZXMgJSBtYXhNaW51dGVzKSArIDEgOiBtaW5NaW51dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RGF0ZS5zZXRNaW51dGVzKG1pbnV0ZXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgc3BpblNlY29uZHMoZGVsdGE6IG51bWJlciwgbmV3RGF0ZTogRGF0ZSwgaXNTcGluTG9vcDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCBtYXhTZWNvbmRzID0gNTk7XG4gICAgICAgIGNvbnN0IG1pblNlY29uZHMgPSAwO1xuICAgICAgICBsZXQgc2Vjb25kcyA9IG5ld0RhdGUuZ2V0U2Vjb25kcygpICsgZGVsdGE7XG4gICAgICAgIGlmIChzZWNvbmRzID4gbWF4U2Vjb25kcykge1xuICAgICAgICAgICAgc2Vjb25kcyA9IGlzU3Bpbkxvb3AgPyBzZWNvbmRzICUgbWF4U2Vjb25kcyAtIDEgOiBtYXhTZWNvbmRzO1xuICAgICAgICB9IGVsc2UgaWYgKHNlY29uZHMgPCBtaW5TZWNvbmRzKSB7XG4gICAgICAgICAgICBzZWNvbmRzID0gaXNTcGluTG9vcCA/IG1heFNlY29uZHMgKyAoc2Vjb25kcyAlIG1heFNlY29uZHMpICsgMSA6IG1pblNlY29uZHM7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdEYXRlLnNldFNlY29uZHMoc2Vjb25kcyk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBzcGluQW1QbShuZXdEYXRlOiBEYXRlLCBjdXJyZW50RGF0ZTogRGF0ZSwgYW1QbUZyb21NYXNrOiBzdHJpbmcpOiBEYXRlIHtcbiAgICAgICAgc3dpdGNoIChhbVBtRnJvbU1hc2spIHtcbiAgICAgICAgICAgIGNhc2UgJ0FNJzpcbiAgICAgICAgICAgICAgICBuZXdEYXRlID0gbmV3IERhdGUobmV3RGF0ZS5zZXRIb3VycyhuZXdEYXRlLmdldEhvdXJzKCkgKyAxMikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUE0nOlxuICAgICAgICAgICAgICAgIG5ld0RhdGUgPSBuZXcgRGF0ZShuZXdEYXRlLnNldEhvdXJzKG5ld0RhdGUuZ2V0SG91cnMoKSAtIDEyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0RhdGUuZ2V0RGF0ZSgpICE9PSBjdXJyZW50RGF0ZS5nZXREYXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdEYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBwcm92aWRlZCBtYXggdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5jbHVkZVRpbWUgc2V0IHRvIGZhbHNlIGlmIHlvdSB3YW50IHRvIGV4Y2x1ZGUgdGltZSBwb3J0aW9uIG9mIHRoZSB0d28gZGF0ZXNcbiAgICAgKiBAcGFyYW0gaW5jbHVkZURhdGUgc2V0IHRvIGZhbHNlIGlmIHlvdSB3YW50IHRvIGV4Y2x1ZGUgdGhlIGRhdGUgcG9ydGlvbiBvZiB0aGUgdHdvIGRhdGVzXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gcHJvdmlkZWQgbWF4VmFsdWVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdyZWF0ZXJUaGFuTWF4VmFsdWUodmFsdWU6IERhdGUsIG1heFZhbHVlOiBEYXRlLCBpbmNsdWRlVGltZSA9IHRydWUsIGluY2x1ZGVEYXRlID0gdHJ1ZSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiBwcm92aWRlZCBkYXRlcyBhcmUgdmFsaWQgZGF0ZXMgYW5kIG5vdCBJbnZhbGlkIERhdGVcbiAgICAgICAgLy8gaWYgbWF4VmFsdWUgaXMgSW52YWxpZCBEYXRlIGFuZCB2YWx1ZSBpcyB2YWxpZCBkYXRlIHRoaXMgd2lsbCByZXR1cm46XG4gICAgICAgIC8vIC0gZmFsc2UgaWYgaW5jbHVkZURhdGUgaXMgdHJ1ZVxuICAgICAgICAvLyAtIHRydWUgaWYgaW5jbHVkZURhdGUgaXMgZmFsc2VcbiAgICAgICAgaWYgKGluY2x1ZGVUaW1lICYmIGluY2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpID4gbWF4VmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgX3ZhbHVlID0gbmV3IERhdGUodmFsdWUuZ2V0VGltZSgpKTtcbiAgICAgICAgY29uc3QgX21heFZhbHVlID0gbmV3IERhdGUobWF4VmFsdWUuZ2V0VGltZSgpKTtcbiAgICAgICAgaWYgKCFpbmNsdWRlVGltZSkge1xuICAgICAgICAgICAgX3ZhbHVlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgX21heFZhbHVlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5jbHVkZURhdGUpIHtcbiAgICAgICAgICAgIF92YWx1ZS5zZXRGdWxsWWVhcigwLCAwLCAwKTtcbiAgICAgICAgICAgIF9tYXhWYWx1ZS5zZXRGdWxsWWVhcigwLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdmFsdWUuZ2V0VGltZSgpID4gX21heFZhbHVlLmdldFRpbWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgcHJvdmlkZWQgbWluIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluY2x1ZGVUaW1lIHNldCB0byBmYWxzZSBpZiB5b3Ugd2FudCB0byBleGNsdWRlIHRpbWUgcG9ydGlvbiBvZiB0aGUgdHdvIGRhdGVzXG4gICAgICogQHBhcmFtIGluY2x1ZGVEYXRlIHNldCB0byBmYWxzZSBpZiB5b3Ugd2FudCB0byBleGNsdWRlIHRoZSBkYXRlIHBvcnRpb24gb2YgdGhlIHR3byBkYXRlc1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHByb3ZpZGVkIG1pblZhbHVlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBsZXNzVGhhbk1pblZhbHVlKHZhbHVlOiBEYXRlLCBtaW5WYWx1ZTogRGF0ZSwgaW5jbHVkZVRpbWUgPSB0cnVlLCBpbmNsdWRlRGF0ZSA9IHRydWUpOiBib29sZWFuIHtcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgaWYgcHJvdmlkZWQgZGF0ZXMgYXJlIHZhbGlkIGRhdGVzIGFuZCBub3QgSW52YWxpZCBEYXRlXG4gICAgICAgIC8vIGlmIHZhbHVlIGlzIEludmFsaWQgRGF0ZSBhbmQgbWluVmFsdWUgaXMgdmFsaWQgZGF0ZSB0aGlzIHdpbGwgcmV0dXJuOlxuICAgICAgICAvLyAtIGZhbHNlIGlmIGluY2x1ZGVEYXRlIGlzIHRydWVcbiAgICAgICAgLy8gLSB0cnVlIGlmIGluY2x1ZGVEYXRlIGlzIGZhbHNlXG4gICAgICAgIGlmIChpbmNsdWRlVGltZSAmJiBpbmNsdWRlRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKSA8IG1pblZhbHVlLmdldFRpbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IF92YWx1ZSA9IG5ldyBEYXRlKHZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIGNvbnN0IF9taW5WYWx1ZSA9IG5ldyBEYXRlKG1pblZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIGlmICghaW5jbHVkZVRpbWUpIHtcbiAgICAgICAgICAgIF92YWx1ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIF9taW5WYWx1ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluY2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICBfdmFsdWUuc2V0RnVsbFllYXIoMCwgMCwgMCk7XG4gICAgICAgICAgICBfbWluVmFsdWUuc2V0RnVsbFllYXIoMCwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3ZhbHVlLmdldFRpbWUoKSA8IF9taW5WYWx1ZS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGRhdGUgcGFydHMgc3RydWN0dXJlIGJhc2VkIG9uIGVkaXRvciBtYXNrIGFuZCBsb2NhbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFza1ZhbHVlOiBzdHJpbmdcbiAgICAgKiBAcGFyYW0gbG9jYWxlOiBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBhcnJheSBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGRhdGUgcGFydHMgLSB0eXBlLCBwb3NpdGlvbiwgZm9ybWF0XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZURhdGVGb3JtYXQobWFza1ZhbHVlOiBzdHJpbmcsIGxvY2FsZTogc3RyaW5nID0gRGF0ZVBpY2tlclV0aWwuREVGQVVMVF9MT0NBTEUpOiBhbnlbXSB7XG4gICAgICAgIGxldCBkYXRlU3RydWN0ID0gW107XG4gICAgICAgIGlmIChtYXNrVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhaXNJRSgpKSB7XG4gICAgICAgICAgICBkYXRlU3RydWN0ID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGVmYXVsdExvY2FsZU1hc2sobG9jYWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSAobWFza1ZhbHVlKSA/IG1hc2tWYWx1ZSA6IERhdGVQaWNrZXJVdGlsLlNIT1JUX0RBVEVfTUFTSztcbiAgICAgICAgICAgIGNvbnN0IG1hc2tBcnJheSA9IEFycmF5LmZyb20obWFzayk7XG4gICAgICAgICAgICBjb25zdCBtb250aEluaXRQb3NpdGlvbiA9IG1hc2suaW5kZXhPZihEYXRlQ2hhcnMuTW9udGhDaGFyKTtcbiAgICAgICAgICAgIGNvbnN0IGRheUluaXRQb3NpdGlvbiA9IG1hc2suaW5kZXhPZihEYXRlQ2hhcnMuRGF5Q2hhcik7XG4gICAgICAgICAgICBjb25zdCB5ZWFySW5pdFBvc2l0aW9uID0gbWFzay5pbmRleE9mKERhdGVDaGFycy5ZZWFyQ2hhcik7XG5cbiAgICAgICAgICAgIGlmICh5ZWFySW5pdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGRhdGVTdHJ1Y3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IERhdGVQYXJ0cy5ZZWFyLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsUG9zaXRpb246IHllYXJJbml0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFR5cGU6IERhdGVQaWNrZXJVdGlsLmdldFllYXJGb3JtYXRUeXBlKG1hc2spXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtb250aEluaXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkYXRlU3RydWN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRlUGFydHMuTW9udGgsXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxQb3NpdGlvbjogbW9udGhJbml0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFR5cGU6IERhdGVQaWNrZXJVdGlsLmdldE1vbnRoRm9ybWF0VHlwZShtYXNrKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF5SW5pdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGRhdGVTdHJ1Y3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IERhdGVQYXJ0cy5EYXksXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxQb3NpdGlvbjogZGF5SW5pdFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRUeXBlOiBEYXRlUGlja2VyVXRpbC5nZXREYXlGb3JtYXRUeXBlKG1hc2spXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFza0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFEYXRlUGlja2VyVXRpbC5pc0RhdGVDaGFyKG1hc2tBcnJheVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVN0cnVjdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IERhdGVQaWNrZXJVdGlsLlNFUEFSQVRPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxQb3NpdGlvbjogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXNrQXJyYXlbaV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlU3RydWN0LnNvcnQoKGEsIGIpID0+IGEuaW5pdGlhbFBvc2l0aW9uIC0gYi5pbml0aWFsUG9zaXRpb24pO1xuICAgICAgICAgICAgRGF0ZVBpY2tlclV0aWwuZmlsbERhdGVQYXJ0c1Bvc2l0aW9ucyhkYXRlU3RydWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZVN0cnVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBnZW5lcmF0ZXMgaW5wdXQgbWFzayBiYXNlZCBvbiBkYXRlIHBhcnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGVTdHJ1Y3QgYXJyYXlcbiAgICAgKiBAcmV0dXJucyBpbnB1dCBtYXNrXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRJbnB1dE1hc2soZGF0ZVN0cnVjdDogYW55W10pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBpbnB1dE1hc2sgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGRhdGVTdHJ1Y3QpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IERhdGVQaWNrZXJVdGlsLlNFUEFSQVRPUikge1xuICAgICAgICAgICAgICAgIGlucHV0TWFzay5wdXNoKHBhcnQudmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnR5cGUgPT09IERhdGVQYXJ0cy5EYXkgfHwgcGFydC50eXBlID09PSBEYXRlUGFydHMuTW9udGgpIHtcbiAgICAgICAgICAgICAgICBpbnB1dE1hc2sucHVzaCgnMDAnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBEYXRlUGFydHMuWWVhcikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocGFydC5mb3JtYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRm9ybWF0RGVzYy5OdW1lcmljOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dE1hc2sucHVzaCgnMDAwMCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLlR3b0RpZ2l0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRNYXNrLnB1c2goJzAwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRNYXNrLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGdlbmVyYXRlcyBlZGl0b3IgbWFzay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRlU3RydWN0XG4gICAgICogQHJldHVybnMgZWRpdG9yIG1hc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldE1hc2soZGF0ZVN0cnVjdDogYW55W10pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBtYXNrID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBkYXRlU3RydWN0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQuZm9ybWF0VHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgRm9ybWF0RGVzYy5OdW1lcmljOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IERhdGVQYXJ0cy5EYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sucHVzaCgnZCcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQudHlwZSA9PT0gRGF0ZVBhcnRzLk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrLnB1c2goJ00nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sucHVzaCgneXl5eScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIEZvcm1hdERlc2MuVHdvRGlnaXRzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IERhdGVQYXJ0cy5EYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sucHVzaCgnZGQnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnR5cGUgPT09IERhdGVQYXJ0cy5Nb250aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5wdXNoKCdNTScpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5wdXNoKCd5eScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBEYXRlUGlja2VyVXRpbC5TRVBBUkFUT1IpIHtcbiAgICAgICAgICAgICAgICBtYXNrLnB1c2gocGFydC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFzay5qb2luKCcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcGFyc2VzIGFuIGlucHV0IHN0cmluZyBiYXNlIG9uIGRhdGUgcGFydHMgYW5kIHJldHVybnMgYSBkYXRlIGFuZCBpdHMgdmFsaWRhdGlvbiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRlRm9ybWF0UGFydHNcbiAgICAgKiBAcGFyYW0gcHJldkRhdGVWYWx1ZVxuICAgICAqIEBwYXJhbSBpbnB1dFZhbHVlXG4gICAgICogQHJldHVybnMgb2JqZWN0IGNvbnRhaW5pbmcgYSBkYXRlIGFuZCBpdHMgdmFsaWRhdGlvbiBzdGF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VEYXRlQXJyYXkoZGF0ZUZvcm1hdFBhcnRzOiBhbnlbXSwgcHJldkRhdGVWYWx1ZTogRGF0ZSwgaW5wdXRWYWx1ZTogc3RyaW5nKTogYW55IHtcbiAgICAgICAgY29uc3QgZGF5U3RyID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGF5VmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dFZhbHVlKTtcbiAgICAgICAgY29uc3QgbW9udGhTdHIgPSBEYXRlUGlja2VyVXRpbC5nZXRNb250aFZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgaW5wdXRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHllYXJTdHIgPSBEYXRlUGlja2VyVXRpbC5nZXRZZWFyVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dFZhbHVlKTtcbiAgICAgICAgY29uc3QgeWVhckZvcm1hdCA9IERhdGVQaWNrZXJVdGlsLmdldERhdGVGb3JtYXRQYXJ0KGRhdGVGb3JtYXRQYXJ0cywgRGF0ZVBhcnRzLlllYXIpLmZvcm1hdFR5cGU7XG4gICAgICAgIGNvbnN0IGRheSA9IChkYXlTdHIgIT09ICcnKSA/IHBhcnNlSW50KGRheVN0ciwgMTApIDogMTtcbiAgICAgICAgY29uc3QgbW9udGggPSAobW9udGhTdHIgIT09ICcnKSA/IHBhcnNlSW50KG1vbnRoU3RyLCAxMCkgLSAxIDogMDtcblxuICAgICAgICBsZXQgeWVhcjtcbiAgICAgICAgaWYgKHllYXJTdHIgPT09ICcnKSB7XG4gICAgICAgICAgICB5ZWFyID0gKHllYXJGb3JtYXQgPT09IEZvcm1hdERlc2MuVHdvRGlnaXRzKSA/ICcwMCcgOiAnMjAwMCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5ZWFyID0geWVhclN0cjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeWVhclByZWZpeDtcbiAgICAgICAgaWYgKHByZXZEYXRlVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsWWVhciA9IHByZXZEYXRlVmFsdWUuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsWWVhci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICB5ZWFyUHJlZml4ID0gb3JpZ2luYWxZZWFyLnN1YnN0cmluZygwLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHllYXJQcmVmaXggPSAnMjAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bGxZZWFyID0gKHllYXJGb3JtYXQgPT09IEZvcm1hdERlc2MuVHdvRGlnaXRzKSA/IHllYXJQcmVmaXguY29uY2F0KHllYXIpIDogeWVhcjtcblxuICAgICAgICBpZiAoKG1vbnRoIDwgMCkgfHwgKG1vbnRoID4gMTEpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IERhdGVTdGF0ZS5JbnZhbGlkLCB2YWx1ZTogaW5wdXRWYWx1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChkYXkgPCAxKSB8fCAoZGF5ID4gRGF0ZVBpY2tlclV0aWwuZGF5c0luTW9udGgoZnVsbFllYXIsIG1vbnRoKSkgfHwgaXNOYU4oZGF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IERhdGVTdGF0ZS5JbnZhbGlkLCB2YWx1ZTogaW5wdXRWYWx1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IERhdGVTdGF0ZS5WYWxpZCwgZGF0ZTogbmV3IERhdGUoZnVsbFllYXIsIG1vbnRoLCBkYXkpIH07XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBtYXNrVG9Qcm9tcHRDaGFycyhtYXNrOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBtYXNrLnJlcGxhY2UoLzB8TC9nLCBEYXRlUGlja2VyVXRpbC5QUk9NUFRfQ0hBUik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmVwbGFjZXMgcHJvbXB0IGNoYXJzIHdpdGggZW1wdHkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyB0cmltRW1wdHlQbGFjZWhvbGRlcnModmFsdWU6IHN0cmluZywgcHJvbXB0Q2hhcj86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnJlcGxhY2UobmV3IFJlZ0V4cChwcm9tcHRDaGFyIHx8ICdfJywgJ2cnKSwgJycpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHNwaW5uaW5nIGRhdGUgcGFydHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0ZUZvcm1hdFBhcnRzXG4gICAgICogQHBhcmFtIGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gZGVsdGFcbiAgICAgKiBAcGFyYW0gaXNTcGluTG9vcFxuICAgICAqIEByZXR1cm4gbW9kaWZpZWQgdGV4dCBpbnB1dFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0TW9kaWZpZWREYXRlSW5wdXQoZGF0ZUZvcm1hdFBhcnRzOiBhbnlbXSxcbiAgICAgICAgaW5wdXRWYWx1ZTogc3RyaW5nLFxuICAgICAgICBwb3NpdGlvbjogbnVtYmVyLFxuICAgICAgICBkZWx0YTogbnVtYmVyLFxuICAgICAgICBpc1NwaW5Mb29wOiBib29sZWFuKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZGF0ZVBhcnQgPSBEYXRlUGlja2VyVXRpbC5nZXREYXRlUGFydE9uUG9zaXRpb24oZGF0ZUZvcm1hdFBhcnRzLCBwb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGRhdGVQYXJ0VHlwZSA9IGRhdGVQYXJ0LnR5cGU7XG4gICAgICAgIGNvbnN0IGRhdGVQYXJ0Rm9ybWF0VHlwZSA9IGRhdGVQYXJ0LmZvcm1hdFR5cGU7XG4gICAgICAgIGxldCBuZXdWYWx1ZTtcblxuICAgICAgICBjb25zdCBkYXRlUGFydFZhbHVlID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgZGF0ZVBhcnRUeXBlLCBpbnB1dFZhbHVlKTtcbiAgICAgICAgbmV3VmFsdWUgPSBwYXJzZUludChkYXRlUGFydFZhbHVlLCAxMCk7XG5cbiAgICAgICAgY29uc3QgbWluTWF4ID0gRGF0ZVBpY2tlclV0aWwuZ2V0TWluTWF4VmFsdWUoZGF0ZUZvcm1hdFBhcnRzLCBkYXRlUGFydCwgaW5wdXRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IG1pblZhbHVlID0gbWluTWF4Lm1pbjtcbiAgICAgICAgY29uc3QgbWF4VmFsdWUgPSBtaW5NYXgubWF4O1xuXG4gICAgICAgIGlmIChpc05hTihuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChtaW5WYWx1ZSA9PT0gJ2luZmluaXRlJykge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gMjAwMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBtaW5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdGVtcFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIHRlbXBWYWx1ZSArPSBkZWx0YTtcblxuICAgICAgICAvLyBJbmZpbml0ZSBsb29wIGZvciBmdWxsIHllYXJzXG4gICAgICAgIGlmIChtYXhWYWx1ZSA9PT0gJ2luZmluaXRlJyAmJiBtaW5WYWx1ZSA9PT0gJ2luZmluaXRlJykge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB0ZW1wVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNTcGluTG9vcCkge1xuICAgICAgICAgICAgaWYgKHRlbXBWYWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGVtcFZhbHVlID0gbWluVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVtcFZhbHVlIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0ZW1wVmFsdWUgPSBtYXhWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdGVtcFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRlbXBWYWx1ZSA8PSBtYXhWYWx1ZSAmJiB0ZW1wVmFsdWUgPj0gbWluVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHRlbXBWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0SWR4ID0gZGF0ZVBhcnQucG9zaXRpb25bMF07XG4gICAgICAgIGNvbnN0IGVuZElkeCA9IGRhdGVQYXJ0LnBvc2l0aW9uWzFdO1xuICAgICAgICBjb25zdCBzdGFydCA9IGlucHV0VmFsdWUuc2xpY2UoMCwgc3RhcnRJZHgpO1xuICAgICAgICBjb25zdCBlbmQgPSBpbnB1dFZhbHVlLnNsaWNlKGVuZElkeCwgaW5wdXRWYWx1ZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBEYXRlUGlja2VyVXRpbC5nZXROdW1lcmljRm9ybWF0UHJlZml4KGRhdGVQYXJ0Rm9ybWF0VHlwZSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRQYXJ0ID0gKG5ld1ZhbHVlIDwgMTApID8gYCR7cHJlZml4fSR7bmV3VmFsdWV9YCA6IGAke25ld1ZhbHVlfWA7XG5cbiAgICAgICAgcmV0dXJuIGAke3N0YXJ0fSR7Y2hhbmdlZFBhcnR9JHtlbmR9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGRhdGUgaW5wdXQgd2l0aCBwcm9tcHQgY2hhcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0ZUZvcm1hdFBhcnRzXG4gICAgICogQHBhcmFtIGRhdGVcbiAgICAgKiBAcGFyYW0gaW5wdXRWYWx1ZVxuICAgICAqIEByZXR1cm5zIGRhdGUgaW5wdXQgaW5jbHVkaW5nIHByb21wdCBjaGFyc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYWRkUHJvbXB0Q2hhcnNFZGl0TW9kZShkYXRlRm9ybWF0UGFydHM6IGFueVtdLCBkYXRlOiBEYXRlLCBpbnB1dFZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBkYXRlQXJyYXkgPSBBcnJheS5mcm9tKGlucHV0VmFsdWUpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgZGF0ZUZvcm1hdFBhcnRzKSB7XG4gICAgICAgICAgICBpZiAocGFydC5mb3JtYXRUeXBlID09PSBGb3JtYXREZXNjLk51bWVyaWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHBhcnQudHlwZSA9PT0gRGF0ZVBhcnRzLkRheSAmJiBkYXRlLmdldERhdGUoKSA8IDEwKVxuICAgICAgICAgICAgICAgICAgICB8fCAocGFydC50eXBlID09PSBEYXRlUGFydHMuTW9udGggJiYgZGF0ZS5nZXRNb250aCgpICsgMSA8IDEwKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQXJyYXkuc3BsaWNlKHBhcnQucG9zaXRpb25bMF0sIDAsIERhdGVQaWNrZXJVdGlsLlBST01QVF9DSEFSKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUFycmF5LmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUFycmF5LmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBkYXRlIGlucHV0IGlzIGRvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0ZUZvcm1hdFBhcnRzXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICogQHJldHVybnMgaW5wdXQgY29tcGxldGVuZXNzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBjaGVja0ZvckNvbXBsZXRlRGF0ZUlucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBkYXlWYWx1ZSA9IERhdGVQaWNrZXJVdGlsLmdldERheVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgaW5wdXQpO1xuICAgICAgICBjb25zdCBtb250aFZhbHVlID0gRGF0ZVBpY2tlclV0aWwuZ2V0TW9udGhWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIGlucHV0KTtcbiAgICAgICAgY29uc3QgeWVhclZhbHVlID0gRGF0ZVBpY2tlclV0aWwuZ2V0WWVhclZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXlTdHIgPSBEYXRlUGlja2VyVXRpbC5nZXREYXlWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIGlucHV0LCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IG1vbnRoU3RyID0gRGF0ZVBpY2tlclV0aWwuZ2V0TW9udGhWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIGlucHV0LCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKERhdGVQaWNrZXJVdGlsLmlzRnVsbElucHV0KGRheVZhbHVlLCBkYXlTdHIpXG4gICAgICAgICAgICAmJiBEYXRlUGlja2VyVXRpbC5pc0Z1bGxJbnB1dChtb250aFZhbHVlLCBtb250aFN0cilcbiAgICAgICAgICAgICYmIERhdGVQaWNrZXJVdGlsLmlzRnVsbFllYXJJbnB1dChkYXRlRm9ybWF0UGFydHMsIHllYXJWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnY29tcGxldGUnO1xuICAgICAgICB9IGVsc2UgaWYgKGRheVZhbHVlID09PSAnJyAmJiBtb250aFZhbHVlID09PSAnJyAmJiB5ZWFyVmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2VtcHR5JztcbiAgICAgICAgfSBlbHNlIGlmIChkYXlWYWx1ZSA9PT0gJycgfHwgbW9udGhWYWx1ZSA9PT0gJycgfHwgeWVhclZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuICdwYXJ0aWFsJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBkYXlzSW5Nb250aChmdWxsWWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGZ1bGxZZWFyLCBtb250aCArIDEsIDApLmdldERhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBwcm92aWRlZCBpbnB1dCB0byBEYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIGlucHV0IHRvIHBhcnNlXG4gICAgICogQHJldHVybnMgRGF0ZSBpZiBwYXJzZSBzdWNjZWVkIG9yIG51bGxcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHBhcnNlRGF0ZSh2YWx1ZTogYW55KTogRGF0ZSB8IG51bGwge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHZhbHVlIGlzIEludmFsaWQgRGF0ZSB3ZSBzaG91bGQgcmV0dXJuIG51bGxcbiAgICAgICAgaWYgKERhdGVQaWNrZXJVdGlsLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlUGlja2VyVXRpbC5pc1ZhbGlkRGF0ZSh2YWx1ZSkgPyB2YWx1ZSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUgPyBuZXcgRGF0ZShEYXRlLnBhcnNlKHZhbHVlKSkgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBwcm92aWRlZCBpbnB1dCBpcyBkYXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgaW5wdXQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIGlucHV0IGlzIGRhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGlzRGF0ZSh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpbnB1dCBpcyB2YWxpZCBkYXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgaW5wdXQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIGlucHV0IGlzIGEgdmFsaWQgZGF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgaXNWYWxpZERhdGUodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoRGF0ZVBpY2tlclV0aWwuaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGxvZ01pc3NpbmdMb2NhbGVTZXR0aW5ncyhsb2NhbGU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zb2xlLndhcm4oYE1pc3NpbmcgbG9jYWxlIGRhdGEgZm9yIHRoZSBsb2NhbGUgJHtsb2NhbGV9LiBQbGVhc2UgcmVmZXIgdG8gaHR0cHM6Ly9hbmd1bGFyLmlvL2d1aWRlL2kxOG4jaTE4bi1waXBlc2ApO1xuICAgICAgICBjb25zb2xlLndhcm4oJ1VzaW5nIGRlZmF1bHQgYnJvd3NlciBsb2NhbGUgc2V0dGluZ3MuJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZW5zdXJlTGVhZGluZ1plcm8ocGFydDogRGF0ZVBhcnRJbmZvKSB7XG4gICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0LkRhdGU6XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0Lk1vbnRoOlxuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5Ib3VyczpcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuTWludXRlczpcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuU2Vjb25kczpcbiAgICAgICAgICAgICAgICBpZiAocGFydC5mb3JtYXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQuZm9ybWF0ID0gcGFydC5mb3JtYXQucmVwZWF0KDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldENsZWFuVmFsKGlucHV0RGF0YTogc3RyaW5nLCBkYXRlUGFydDogRGF0ZVBhcnRJbmZvLCBwcm9tcHRDaGFyPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLnRyaW1FbXB0eVBsYWNlaG9sZGVycyhpbnB1dERhdGEuc3Vic3RyaW5nKGRhdGVQYXJ0LnN0YXJ0LCBkYXRlUGFydC5lbmQpLCBwcm9tcHRDaGFyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBkZXRlcm1pbmVEYXRlUGFydChjaGFyOiBzdHJpbmcpOiBEYXRlUGFydCB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZVBhcnQuRGF0ZTtcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5Nb250aDtcbiAgICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0LlllYXI7XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5Ib3VycztcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5NaW51dGVzO1xuICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZVBhcnQuU2Vjb25kcztcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0LkFtUG07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5MaXRlcmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0WWVhckZvcm1hdFR5cGUoZm9ybWF0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdC5tYXRjaChuZXcgUmVnRXhwKERhdGVDaGFycy5ZZWFyQ2hhciwgJ2cnKSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAvLyB5ICgyMDIwKVxuICAgICAgICAgICAgICAgIHJldHVybiBGb3JtYXREZXNjLk51bWVyaWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICAvLyB5eXl5ICgyMDIwKVxuICAgICAgICAgICAgICAgIHJldHVybiBGb3JtYXREZXNjLk51bWVyaWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAvLyB5eSAoMjApXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZvcm1hdERlc2MuVHdvRGlnaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0TW9udGhGb3JtYXRUeXBlKGZvcm1hdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQubWF0Y2gobmV3IFJlZ0V4cChEYXRlQ2hhcnMuTW9udGhDaGFyLCAnZycpKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIC8vIE0gKDgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZvcm1hdERlc2MuTnVtZXJpYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIC8vIE1NICgwOClcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9ybWF0RGVzYy5Ud29EaWdpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXREYXlGb3JtYXRUeXBlKGZvcm1hdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQubWF0Y2gobmV3IFJlZ0V4cChEYXRlQ2hhcnMuRGF5Q2hhciwgJ2cnKSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAvLyBkICg2KVxuICAgICAgICAgICAgICAgIHJldHVybiBGb3JtYXREZXNjLk51bWVyaWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAvLyBkZCAoMDYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZvcm1hdERlc2MuVHdvRGlnaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RGVmYXVsdExvY2FsZU1hc2sobG9jYWxlOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgZGF0ZVN0cnVjdCA9IFtdO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUpO1xuICAgICAgICBjb25zdCBmb3JtYXRUb1BhcnRzID0gZm9ybWF0dGVyLmZvcm1hdFRvUGFydHMobmV3IERhdGUoKSk7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBmb3JtYXRUb1BhcnRzKSB7XG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBEYXRlUGlja2VyVXRpbC5TRVBBUkFUT1IpIHtcbiAgICAgICAgICAgICAgICBkYXRlU3RydWN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRlUGlja2VyVXRpbC5TRVBBUkFUT1IsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJ0LnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGVTdHJ1Y3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHBhcnQudHlwZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlck9wdGlvbnMgPSBmb3JtYXR0ZXIucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBkYXRlU3RydWN0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnRzLkRheToge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0LmZvcm1hdFR5cGUgPSBmb3JtYXR0ZXJPcHRpb25zLmRheTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnRzLk1vbnRoOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQuZm9ybWF0VHlwZSA9IGZvcm1hdHRlck9wdGlvbnMubW9udGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIERhdGVQYXJ0cy5ZZWFyOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQuZm9ybWF0VHlwZSA9IGZvcm1hdHRlck9wdGlvbnMueWVhcjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIERhdGVQaWNrZXJVdGlsLmZpbGxEYXRlUGFydHNQb3NpdGlvbnMoZGF0ZVN0cnVjdCk7XG4gICAgICAgIHJldHVybiBkYXRlU3RydWN0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGlzRGF0ZUNoYXIoY2hhcjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoY2hhciA9PT0gRGF0ZUNoYXJzLlllYXJDaGFyIHx8IGNoYXIgPT09IERhdGVDaGFycy5Nb250aENoYXIgfHwgY2hhciA9PT0gRGF0ZUNoYXJzLkRheUNoYXIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldE51bWVyaWNGb3JtYXRQcmVmaXgoZm9ybWF0VHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoIChmb3JtYXRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEZvcm1hdERlc2MuVHdvRGlnaXRzOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRm9ybWF0RGVzYy5OdW1lcmljOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLlBST01QVF9DSEFSO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0TWluTWF4VmFsdWUoZGF0ZUZvcm1hdFBhcnRzOiBhbnlbXSwgZGF0ZVBhcnQsIGlucHV0VmFsdWU6IHN0cmluZyk6IGFueSB7XG4gICAgICAgIGxldCBtYXhWYWx1ZTsgbGV0IG1pblZhbHVlO1xuICAgICAgICBzd2l0Y2ggKGRhdGVQYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnRzLk1vbnRoOiB7XG4gICAgICAgICAgICAgICAgbWluVmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gRGF0ZVBpY2tlclV0aWwuTlVNQkVSX09GX01PTlRIUztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnRzLkRheToge1xuICAgICAgICAgICAgICAgIG1pblZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IERhdGVQaWNrZXJVdGlsLmRheXNJbk1vbnRoKFxuICAgICAgICAgICAgICAgICAgICBEYXRlUGlja2VyVXRpbC5nZXRGdWxsWWVhckZyb21TdHJpbmcoRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZUZvcm1hdFBhcnQoZGF0ZUZvcm1hdFBhcnRzLCBEYXRlUGFydHMuWWVhciksIGlucHV0VmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChEYXRlUGlja2VyVXRpbC5nZXRNb250aFZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgaW5wdXRWYWx1ZSksIDEwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0cy5ZZWFyOiB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVQYXJ0LmZvcm1hdFR5cGUgPT09IEZvcm1hdERlc2MuVHdvRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSA5OTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgICAgIG1pblZhbHVlID0gJ2luZmluaXRlJztcbiAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSAnaW5maW5pdGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtaW46IG1pblZhbHVlLCBtYXg6IG1heFZhbHVlIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RGF0ZVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIHR5cGU6IERhdGVQYXJ0cywgaW5wdXRWYWx1ZTogc3RyaW5nLCB0cmltOiBib29sZWFuID0gdHJ1ZSk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHBhcnRQb3NpdGlvbiA9IERhdGVQaWNrZXJVdGlsLmdldERhdGVGb3JtYXRQYXJ0KGRhdGVGb3JtYXRQYXJ0cywgdHlwZSkucG9zaXRpb247XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGlucHV0VmFsdWUuc3Vic3RyaW5nKHBhcnRQb3NpdGlvblswXSwgcGFydFBvc2l0aW9uWzFdKTtcbiAgICAgICAgcmV0dXJuICh0cmltKSA/IERhdGVQaWNrZXJVdGlsLnRyaW1FbXB0eVBsYWNlaG9sZGVycyhyZXN1bHQpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldERheVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIGlucHV0VmFsdWU6IHN0cmluZywgdHJpbTogYm9vbGVhbiA9IHRydWUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgRGF0ZVBhcnRzLkRheSwgaW5wdXRWYWx1ZSwgdHJpbSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0TW9udGhWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHM6IGFueVtdLCBpbnB1dFZhbHVlOiBzdHJpbmcsIHRyaW06IGJvb2xlYW4gPSB0cnVlKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLmdldERhdGVWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIERhdGVQYXJ0cy5Nb250aCwgaW5wdXRWYWx1ZSwgdHJpbSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0WWVhclZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIGlucHV0VmFsdWU6IHN0cmluZywgdHJpbTogYm9vbGVhbiA9IHRydWUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgRGF0ZVBhcnRzLlllYXIsIGlucHV0VmFsdWUsIHRyaW0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldERhdGVGb3JtYXRQYXJ0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIHR5cGU6IERhdGVQYXJ0cyk6IGFueSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRhdGVGb3JtYXRQYXJ0cy5maWx0ZXIoKGRhdGVQYXJ0KSA9PiAoZGF0ZVBhcnQudHlwZSA9PT0gdHlwZSkpWzBdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGlzRnVsbElucHV0KHZhbHVlOiBhbnksIGlucHV0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAhPT0gJycgJiYgaW5wdXQubGVuZ3RoID09PSAyICYmIGlucHV0LmNoYXJBdCgxKSAhPT0gRGF0ZVBpY2tlclV0aWwuUFJPTVBUX0NIQVIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGlzRnVsbFllYXJJbnB1dChkYXRlRm9ybWF0UGFydHM6IGFueVtdLCB2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIHN3aXRjaCAoRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZUZvcm1hdFBhcnQoZGF0ZUZvcm1hdFBhcnRzLCBEYXRlUGFydHMuWWVhcikuZm9ybWF0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLk51bWVyaWM6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlICE9PSAnJyAmJiB2YWx1ZS5sZW5ndGggPT09IDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLlR3b0RpZ2l0czoge1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgIT09ICcnICYmIHZhbHVlLmxlbmd0aCA9PT0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RGF0ZVBhcnRPblBvc2l0aW9uKGRhdGVGb3JtYXRQYXJ0czogYW55W10sIHBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGF0ZUZvcm1hdFBhcnRzLmZpbHRlcigoZWxlbWVudCkgPT5cbiAgICAgICAgICAgIGVsZW1lbnQucG9zaXRpb25bMF0gPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPD0gZWxlbWVudC5wb3NpdGlvblsxXSAmJiBlbGVtZW50LnR5cGUgIT09IERhdGVQaWNrZXJVdGlsLlNFUEFSQVRPUilbMF07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RnVsbFllYXJGcm9tU3RyaW5nKHllYXJQYXJ0LCBpbnB1dFZhbHVlKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0VmFsdWUuc3Vic3RyaW5nKHllYXJQYXJ0LnBvc2l0aW9uWzBdLCB5ZWFyUGFydC5wb3NpdGlvblsxXSksIDEwKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBmaWxsRGF0ZVBhcnRzUG9zaXRpb25zKGRhdGVBcnJheTogYW55W10pOiB2b2lkIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQb3MgPSAwO1xuXG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBkYXRlQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIERheXxNb250aCBwYXJ0IHBvc2l0aW9uc1xuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gRGF0ZVBhcnRzLkRheSB8fCBwYXJ0LnR5cGUgPT09IERhdGVQYXJ0cy5Nb250aCkge1xuICAgICAgICAgICAgICAgIC8vIE9mZnNldCAyIHBvc2l0aW9ucyBmb3IgbnVtYmVyXG4gICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbiA9IFtjdXJyZW50UG9zLCBjdXJyZW50UG9zICsgMl07XG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnR5cGUgPT09IERhdGVQYXJ0cy5ZZWFyKSB7XG4gICAgICAgICAgICAgICAgLy8gWWVhciBwYXJ0IHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocGFydC5mb3JtYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRm9ybWF0RGVzYy5OdW1lcmljOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPZmZzZXQgNCBwb3NpdGlvbnMgZm9yIGZ1bGwgeWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbiA9IFtjdXJyZW50UG9zLCBjdXJyZW50UG9zICsgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIEZvcm1hdERlc2MuVHdvRGlnaXRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPZmZzZXQgMiBwb3NpdGlvbnMgZm9yIHNob3J0IHllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24gPSBbY3VycmVudFBvcywgY3VycmVudFBvcyArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQudHlwZSA9PT0gRGF0ZVBpY2tlclV0aWwuU0VQQVJBVE9SKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VwYXJhdG9yIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24gPSBbY3VycmVudFBvcywgY3VycmVudFBvcyArIDFdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuIl19