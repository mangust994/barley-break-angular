import { Directive, HostBinding, NgModule, Input } from '@angular/core';
import { mkenum } from '../../core/utils';
export const IgxDividerType = mkenum({
    SOLID: 'solid',
    DASHED: 'dashed'
});
let NEXT_ID = 0;
export class IgxDividerDirective {
    constructor() {
        /**
         * Sets/gets the `id` of the divider.
         * If not set, `id` will have value `"igx-divider-0"`;
         * ```html
         * <igx-divider id="my-divider"></igx-divider>
         * ```
         * ```typescript
         * let dividerId =  this.divider.id;
         * ```
         */
        this.id = `igx-divider-${NEXT_ID++}`;
        /**
         * An @Input property that sets the value of `role` attribute.
         * If not the default value of `separator` will be used.
         */
        this.role = 'separator';
        /**
         * Sets the type of the divider. The default value
         * is `default`. The divider can also be `dashed`;
         * ```html
         * <igx-divider type="dashed"></igx-divider>
         * ```
         */
        this.type = IgxDividerType.SOLID;
        /**
         * An @Input that sets the `middle` attribute of the divider.
         * If set to `true` and an `inset` value has been provided,
         * the divider will start shrinking from both ends.
         * ```html
         * <igx-divider [middle]="true"></igx-divider>
         * ```
         */
        this.middle = false;
        /**
         * An @Input that sets the vertical attribute of the divider.
         * ```html
         * <igx-divider [vertical]="true"></igx-divider>
         * ```
         */
        this.vertical = false;
        /**
         * An @Input property that sets the value of the `inset` attribute.
         * If not provided it will be set to `'0'`.
         * ```html
         * <igx-divider inset="16px"></igx-divider>
         * ```
         */
        this._inset = '0';
    }
    get isDashed() {
        return this.type === IgxDividerType.DASHED;
    }
    /**
     * Sets the inset of the divider from the side(s).
     * If the divider attribute `middle` is set to `true`,
     * it will inset the divider on both sides.
     * ```typescript
     * this.divider.inset = '32px';
     * ```
     */
    set inset(value) {
        this._inset = value;
    }
    /**
     * Gets the current divider inset in terms of
     * margin representation as applied to the divider.
     * ```typescript
     * const inset = this.divider.inset;
     * ```
     */
    get inset() {
        const baseMargin = '0';
        if (this.middle) {
            if (this.vertical) {
                return `${this._inset} ${baseMargin}`;
            }
            return `${baseMargin} ${this._inset}`;
        }
        else {
            if (this.vertical) {
                return `${this._inset} ${baseMargin} 0 ${baseMargin}`;
            }
            return `${baseMargin} 0 ${baseMargin} ${this._inset}`;
        }
    }
    /**
     * A getter that returns `true` if the type of the divider is `default`;
     * ```typescript
     * const isDefault = this.divider.isDefault;
     * ```
     */
    get isSolid() {
        return this.type === IgxDividerType.SOLID;
    }
}
IgxDividerDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: 'igx-divider'
            },] }
];
IgxDividerDirective.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    type: [{ type: HostBinding, args: ['class.igx-divider',] }, { type: Input }],
    isDashed: [{ type: HostBinding, args: ['class.igx-divider--dashed',] }],
    middle: [{ type: HostBinding, args: ['class.igx-divider--inset',] }, { type: Input }],
    vertical: [{ type: HostBinding, args: ['class.igx-divider--vertical',] }, { type: Input }],
    inset: [{ type: HostBinding, args: ['style.margin',] }],
    _inset: [{ type: Input, args: ['inset',] }]
};
export class IgxDividerModule {
}
IgxDividerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxDividerDirective],
                exports: [IgxDividerDirective]
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGl2aWRlci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZGlyZWN0aXZlcy9kaXZpZGVyL2RpdmlkZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRTFDLE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUM7SUFDakMsS0FBSyxFQUFFLE9BQU87SUFDZCxNQUFNLEVBQUUsUUFBUTtDQUNuQixDQUFDLENBQUM7QUFHSCxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7QUFNaEIsTUFBTSxPQUFPLG1CQUFtQjtJQUpoQztRQUtJOzs7Ozs7Ozs7V0FTRztRQUdJLE9BQUUsR0FBRyxlQUFlLE9BQU8sRUFBRSxFQUFFLENBQUM7UUFFdkM7OztXQUdHO1FBR0ksU0FBSSxHQUFHLFdBQVcsQ0FBQztRQUUxQjs7Ozs7O1dBTUc7UUFHSSxTQUFJLEdBQTRCLGNBQWMsQ0FBQyxLQUFLLENBQUM7UUFPNUQ7Ozs7Ozs7V0FPRztRQUdJLFdBQU0sR0FBRyxLQUFLLENBQUM7UUFFdEI7Ozs7O1dBS0c7UUFHSSxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBdUN4Qjs7Ozs7O1dBTUc7UUFFSyxXQUFNLEdBQUcsR0FBRyxDQUFDO0lBV3pCLENBQUM7SUFuRkcsSUFDSSxRQUFRO1FBQ1IsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLGNBQWMsQ0FBQyxNQUFNLENBQUM7SUFDL0MsQ0FBQztJQXdCRDs7Ozs7OztPQU9HO0lBQ0gsSUFDSSxLQUFLLENBQUMsS0FBYTtRQUNuQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUN4QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsSUFBSSxLQUFLO1FBQ0wsTUFBTSxVQUFVLEdBQUcsR0FBRyxDQUFDO1FBRXZCLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNiLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDZixPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxVQUFVLEVBQUUsQ0FBQzthQUN6QztZQUNELE9BQU8sR0FBRyxVQUFVLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ3pDO2FBQU07WUFDSCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2YsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLElBQUksVUFBVSxNQUFNLFVBQVUsRUFBRSxDQUFDO2FBQ3pEO1lBQ0QsT0FBTyxHQUFHLFVBQVUsTUFBTSxVQUFVLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ3pEO0lBQ0wsQ0FBQztJQWFEOzs7OztPQUtHO0lBQ0gsSUFBSSxPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDOUMsQ0FBQzs7O1lBeEhKLFNBQVMsU0FBQztnQkFDUCw4REFBOEQ7Z0JBQzlELFFBQVEsRUFBRSxhQUFhO2FBQzFCOzs7aUJBWUksV0FBVyxTQUFDLFNBQVMsY0FDckIsS0FBSzttQkFPTCxXQUFXLFNBQUMsV0FBVyxjQUN2QixLQUFLO21CQVVMLFdBQVcsU0FBQyxtQkFBbUIsY0FDL0IsS0FBSzt1QkFHTCxXQUFXLFNBQUMsMkJBQTJCO3FCQWF2QyxXQUFXLFNBQUMsMEJBQTBCLGNBQ3RDLEtBQUs7dUJBU0wsV0FBVyxTQUFDLDZCQUE2QixjQUN6QyxLQUFLO29CQVdMLFdBQVcsU0FBQyxjQUFjO3FCQW9DMUIsS0FBSyxTQUFDLE9BQU87O0FBa0JsQixNQUFNLE9BQU8sZ0JBQWdCOzs7WUFKNUIsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRSxDQUFDLG1CQUFtQixDQUFDO2dCQUNuQyxPQUFPLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQzthQUNqQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdEJpbmRpbmcsIE5nTW9kdWxlLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgbWtlbnVtIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5cbmV4cG9ydCBjb25zdCBJZ3hEaXZpZGVyVHlwZSA9IG1rZW51bSh7XG4gICAgU09MSUQ6ICdzb2xpZCcsXG4gICAgREFTSEVEOiAnZGFzaGVkJ1xufSk7XG5leHBvcnQgdHlwZSBJZ3hEaXZpZGVyVHlwZSA9ICh0eXBlb2YgSWd4RGl2aWRlclR5cGUpW2tleW9mIHR5cGVvZiBJZ3hEaXZpZGVyVHlwZV07XG5cbmxldCBORVhUX0lEID0gMDtcblxuQERpcmVjdGl2ZSh7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9kaXJlY3RpdmUtc2VsZWN0b3JcbiAgICBzZWxlY3RvcjogJ2lneC1kaXZpZGVyJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hEaXZpZGVyRGlyZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGBpZGAgb2YgdGhlIGRpdmlkZXIuXG4gICAgICogSWYgbm90IHNldCwgYGlkYCB3aWxsIGhhdmUgdmFsdWUgYFwiaWd4LWRpdmlkZXItMFwiYDtcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kaXZpZGVyIGlkPVwibXktZGl2aWRlclwiPjwvaWd4LWRpdmlkZXI+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBkaXZpZGVySWQgPSAgdGhpcy5kaXZpZGVyLmlkO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWQgPSBgaWd4LWRpdmlkZXItJHtORVhUX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIGByb2xlYCBhdHRyaWJ1dGUuXG4gICAgICogSWYgbm90IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGBzZXBhcmF0b3JgIHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgcm9sZSA9ICdzZXBhcmF0b3InO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdHlwZSBvZiB0aGUgZGl2aWRlci4gVGhlIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBpcyBgZGVmYXVsdGAuIFRoZSBkaXZpZGVyIGNhbiBhbHNvIGJlIGBkYXNoZWRgO1xuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWRpdmlkZXIgdHlwZT1cImRhc2hlZFwiPjwvaWd4LWRpdmlkZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZGl2aWRlcicpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdHlwZTogSWd4RGl2aWRlclR5cGUgfCBzdHJpbmcgPSBJZ3hEaXZpZGVyVHlwZS5TT0xJRDtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWRpdmlkZXItLWRhc2hlZCcpXG4gICAgZ2V0IGlzRGFzaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBJZ3hEaXZpZGVyVHlwZS5EQVNIRUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHRoYXQgc2V0cyB0aGUgYG1pZGRsZWAgYXR0cmlidXRlIG9mIHRoZSBkaXZpZGVyLlxuICAgICAqIElmIHNldCB0byBgdHJ1ZWAgYW5kIGFuIGBpbnNldGAgdmFsdWUgaGFzIGJlZW4gcHJvdmlkZWQsXG4gICAgICogdGhlIGRpdmlkZXIgd2lsbCBzdGFydCBzaHJpbmtpbmcgZnJvbSBib3RoIGVuZHMuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZGl2aWRlciBbbWlkZGxlXT1cInRydWVcIj48L2lneC1kaXZpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWRpdmlkZXItLWluc2V0JylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBtaWRkbGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCB0aGF0IHNldHMgdGhlIHZlcnRpY2FsIGF0dHJpYnV0ZSBvZiB0aGUgZGl2aWRlci5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kaXZpZGVyIFt2ZXJ0aWNhbF09XCJ0cnVlXCI+PC9pZ3gtZGl2aWRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kaXZpZGVyLS12ZXJ0aWNhbCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdmVydGljYWwgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluc2V0IG9mIHRoZSBkaXZpZGVyIGZyb20gdGhlIHNpZGUocykuXG4gICAgICogSWYgdGhlIGRpdmlkZXIgYXR0cmlidXRlIGBtaWRkbGVgIGlzIHNldCB0byBgdHJ1ZWAsXG4gICAgICogaXQgd2lsbCBpbnNldCB0aGUgZGl2aWRlciBvbiBib3RoIHNpZGVzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmRpdmlkZXIuaW5zZXQgPSAnMzJweCc7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5tYXJnaW4nKVxuICAgIHNldCBpbnNldCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2luc2V0ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBkaXZpZGVyIGluc2V0IGluIHRlcm1zIG9mXG4gICAgICogbWFyZ2luIHJlcHJlc2VudGF0aW9uIGFzIGFwcGxpZWQgdG8gdGhlIGRpdmlkZXIuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGluc2V0ID0gdGhpcy5kaXZpZGVyLmluc2V0O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBpbnNldCgpIHtcbiAgICAgICAgY29uc3QgYmFzZU1hcmdpbiA9ICcwJztcblxuICAgICAgICBpZiAodGhpcy5taWRkbGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuX2luc2V0fSAke2Jhc2VNYXJnaW59YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgJHtiYXNlTWFyZ2lufSAke3RoaXMuX2luc2V0fWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLl9pbnNldH0gJHtiYXNlTWFyZ2lufSAwICR7YmFzZU1hcmdpbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VNYXJnaW59IDAgJHtiYXNlTWFyZ2lufSAke3RoaXMuX2luc2V0fWA7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaW5zZXRgIGF0dHJpYnV0ZS5cbiAgICAgKiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBzZXQgdG8gYCcwJ2AuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZGl2aWRlciBpbnNldD1cIjE2cHhcIj48L2lneC1kaXZpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgnaW5zZXQnKVxuICAgIHByaXZhdGUgX2luc2V0ID0gJzAnO1xuXG4gICAgLyoqXG4gICAgICogQSBnZXR0ZXIgdGhhdCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHlwZSBvZiB0aGUgZGl2aWRlciBpcyBgZGVmYXVsdGA7XG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGlzRGVmYXVsdCA9IHRoaXMuZGl2aWRlci5pc0RlZmF1bHQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGlzU29saWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneERpdmlkZXJUeXBlLlNPTElEO1xuICAgIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hEaXZpZGVyRGlyZWN0aXZlXSxcbiAgICBleHBvcnRzOiBbSWd4RGl2aWRlckRpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4RGl2aWRlck1vZHVsZSB7IH1cbiJdfQ==