import { __decorate } from "tslib";
import { Component, HostBinding, Input, ElementRef, Output, EventEmitter } from '@angular/core';
import { DeprecateProperty } from '../../core/deprecateDecorators';
/**
 * Represents individual resizable/collapsible panes.
 *
 * @igxModule IgxSplitterModule
 *
 * @igxParent IgxSplitterComponent
 *
 * @igxKeywords pane
 *
 * @igxGroup presentation
 *
 * @remarks
 *  Users can control the resize behavior via the min and max size properties.
 */
export class IgxSplitterPaneComponent {
    constructor(el) {
        this.el = el;
        /**
         * @hidden @internal
         * Gets/Sets the 'display' property of the current pane.
         */
        this.display = 'flex';
        /**
         * Gets/Sets whether pane is resizable.
         *
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane [resizable]='false'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         * @remarks
         * If pane is not resizable its related splitter bar cannot be dragged.
         */
        this.resizable = true;
        /**
         * Event fired when collapsed state of pane is changed.
         *
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane (onToggle)='onPaneToggle($event)'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.onToggle = new EventEmitter();
        /**
         * Event fired when collapsed state of pane is changed.
         *
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane (collapsedChange)='paneCollapsedChange($event)'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.collapsedChange = new EventEmitter();
        /**
         * @hidden @internal
         * Gets/Sets the `overflow`.
         */
        this.overflow = 'auto';
        /**
         * @hidden @internal
         * Gets/Sets the `minHeight` and `minWidth` properties of the current pane.
         */
        this.minHeight = 0;
        /**
         * @hidden @internal
         * Gets/Sets the `maxHeight` and `maxWidth` properties of the current `IgxSplitterPaneComponent`.
         */
        this.maxHeight = '100%';
        this._size = 'auto';
        this._collapsed = false;
    }
    /**
     * Gets/Sets the size of the current pane.
     *  * @example
     * ```html
     * <igx-splitter>
     *  <igx-splitter-pane [size]='size'>...</igx-splitter-pane>
     * </igx-splitter>
     * ```
     */
    get size() {
        return this._size;
    }
    set size(value) {
        this._size = value;
        this.el.nativeElement.style.flex = this.flex;
    }
    /** @hidden @internal */
    get isPercentageSize() {
        return this.size === 'auto' || this.size.indexOf('%') !== -1;
    }
    /** @hidden @internal */
    get dragSize() {
        return this._dragSize;
    }
    set dragSize(val) {
        this._dragSize = val;
        this.el.nativeElement.style.flex = this.flex;
    }
    /**
     *
     * @hidden @internal
     * Gets the host native element.
     */
    get element() {
        return this.el.nativeElement;
    }
    /**
     * @hidden @internal
     * Gets the `flex` property of the current `IgxSplitterPaneComponent`.
     */
    get flex() {
        const isAuto = this.size === 'auto' && !this.dragSize;
        const grow = !isAuto ? 0 : 1;
        const size = this.dragSize || this.size;
        return `${grow} ${grow} ${size}`;
    }
    /**
     * Gets/Sets whether current pane is collapsed.
     *
     * @example
     * ```typescript
     * const isCollapsed = pane.collapsed;
     * ```
     */
    set collapsed(value) {
        this._collapsed = value;
        this.display = this._collapsed ? 'none' : 'flex';
    }
    get collapsed() {
        return this._collapsed;
    }
    /**
     * Toggles the collapsed state of the pane.
     *
     * @example
     * ```typescript
     * pane.toggle();
     * ```
     */
    toggle() {
        // reset sibling sizes when pane collapse state changes.
        this._getSiblings().forEach(sibling => sibling.size = 'auto');
        this.collapsed = !this.collapsed;
        this.onToggle.emit(this);
        this.collapsedChange.emit(this.collapsed);
    }
    /** @hidden @internal */
    _getSiblings() {
        const panes = this.owner.panes.toArray();
        const index = panes.indexOf(this);
        const siblings = [];
        if (index !== 0) {
            siblings.push(panes[index - 1]);
        }
        if (index !== panes.length - 1) {
            siblings.push(panes[index + 1]);
        }
        return siblings;
    }
}
IgxSplitterPaneComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-splitter-pane',
                template: "<ng-content></ng-content>"
            },] }
];
IgxSplitterPaneComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxSplitterPaneComponent.propDecorators = {
    display: [{ type: HostBinding, args: ['style.display',] }],
    minSize: [{ type: Input }],
    maxSize: [{ type: Input }],
    resizable: [{ type: Input }],
    onToggle: [{ type: Output }],
    collapsedChange: [{ type: Output }],
    order: [{ type: HostBinding, args: ['style.order',] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }],
    minHeight: [{ type: HostBinding, args: ['style.min-height',] }, { type: HostBinding, args: ['style.min-width',] }],
    maxHeight: [{ type: HostBinding, args: ['style.max-height',] }, { type: HostBinding, args: ['style.max-width',] }],
    size: [{ type: Input }],
    flex: [{ type: HostBinding, args: ['style.flex',] }],
    collapsed: [{ type: Input }]
};
__decorate([
    DeprecateProperty(`Deprecated. Subscribe to the 'collapsedChange' output instead.`)
], IgxSplitterPaneComponent.prototype, "onToggle", void 0);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXR0ZXItcGFuZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvc3BsaXR0ZXIvc3BsaXR0ZXItcGFuZS9zcGxpdHRlci1wYW5lLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hHLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRW5FOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFLSCxNQUFNLE9BQU8sd0JBQXdCO0lBdUxqQyxZQUFvQixFQUFjO1FBQWQsT0FBRSxHQUFGLEVBQUUsQ0FBWTtRQXRMbEM7OztXQUdHO1FBRUksWUFBTyxHQUFHLE1BQU0sQ0FBQztRQTRCeEI7Ozs7Ozs7Ozs7O1dBV0c7UUFFSSxjQUFTLEdBQUcsSUFBSSxDQUFDO1FBRXhCOzs7Ozs7Ozs7V0FTRztRQUdJLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBNEIsQ0FBQztRQUUvRDs7Ozs7Ozs7O1dBU0c7UUFFSSxvQkFBZSxHQUFHLElBQUksWUFBWSxFQUFXLENBQUM7UUFNckQ7OztXQUdHO1FBRUksYUFBUSxHQUFHLE1BQU0sQ0FBQztRQUV6Qjs7O1dBR0c7UUFHSSxjQUFTLEdBQUcsQ0FBQyxDQUFDO1FBRXJCOzs7V0FHRztRQUdJLGNBQVMsR0FBRyxNQUFNLENBQUM7UUE2RWxCLFVBQUssR0FBRyxNQUFNLENBQUM7UUFFZixlQUFVLEdBQUcsS0FBSyxDQUFDO0lBR1csQ0FBQztJQTdFdkM7Ozs7Ozs7O09BUUc7SUFDSCxJQUNXLElBQUk7UUFDWCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDdEIsQ0FBQztJQUVELElBQVcsSUFBSSxDQUFDLEtBQUs7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O1FBQ0QsT0FBTyxRQUFRLENBQUM7SUFDcEIsQ0FBQzs7O1lBek5KLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsbUJBQW1CO2dCQUM3QixxQ0FBNkM7YUFDaEQ7OztZQXBCdUMsVUFBVTs7O3NCQTBCN0MsV0FBVyxTQUFDLGVBQWU7c0JBYTNCLEtBQUs7c0JBYUwsS0FBSzt3QkFlTCxLQUFLO3VCQWNMLE1BQU07OEJBYU4sTUFBTTtvQkFJTixXQUFXLFNBQUMsYUFBYTt1QkFPekIsV0FBVyxTQUFDLGdCQUFnQjt3QkFPNUIsV0FBVyxTQUFDLGtCQUFrQixjQUM5QixXQUFXLFNBQUMsaUJBQWlCO3dCQU83QixXQUFXLFNBQUMsa0JBQWtCLGNBQzlCLFdBQVcsU0FBQyxpQkFBaUI7bUJBZTdCLEtBQUs7bUJBcUNMLFdBQVcsU0FBQyxZQUFZO3dCQWdCeEIsS0FBSzs7QUEzR047SUFGQyxpQkFBaUIsQ0FBQyxnRUFBZ0UsQ0FBQzswREFFckIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEhvc3RCaW5kaW5nLCBJbnB1dCwgRWxlbWVudFJlZiwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERlcHJlY2F0ZVByb3BlcnR5IH0gZnJvbSAnLi4vLi4vY29yZS9kZXByZWNhdGVEZWNvcmF0b3JzJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGluZGl2aWR1YWwgcmVzaXphYmxlL2NvbGxhcHNpYmxlIHBhbmVzLlxuICpcbiAqIEBpZ3hNb2R1bGUgSWd4U3BsaXR0ZXJNb2R1bGVcbiAqXG4gKiBAaWd4UGFyZW50IElneFNwbGl0dGVyQ29tcG9uZW50XG4gKlxuICogQGlneEtleXdvcmRzIHBhbmVcbiAqXG4gKiBAaWd4R3JvdXAgcHJlc2VudGF0aW9uXG4gKlxuICogQHJlbWFya3NcbiAqICBVc2VycyBjYW4gY29udHJvbCB0aGUgcmVzaXplIGJlaGF2aW9yIHZpYSB0aGUgbWluIGFuZCBtYXggc2l6ZSBwcm9wZXJ0aWVzLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1zcGxpdHRlci1wYW5lJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc3BsaXR0ZXItcGFuZS5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMvU2V0cyB0aGUgJ2Rpc3BsYXknIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IHBhbmUuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5kaXNwbGF5JylcbiAgICBwdWJsaWMgZGlzcGxheSA9ICdmbGV4JztcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgbWluaW11bSBhbGxvd2VkIHNpemUgb2YgdGhlIGN1cnJlbnQgcGFuZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXI+XG4gICAgICogIDxpZ3gtc3BsaXR0ZXItcGFuZSBbbWluU2l6ZV09J21pblNpemUnPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgbWluU2l6ZSE6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0IHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBvZiB0aGUgY3VycmVudCBwYW5lLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlcj5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lIFttYXhTaXplXT0nbWF4U2l6ZSc+Li4uPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAgICAgKiA8L2lneC1zcGxpdHRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBtYXhTaXplITogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHdoZXRoZXIgcGFuZSBpcyByZXNpemFibGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNwbGl0dGVyPlxuICAgICAqICA8aWd4LXNwbGl0dGVyLXBhbmUgW3Jlc2l6YWJsZV09J2ZhbHNlJz4uLi48L2lneC1zcGxpdHRlci1wYW5lPlxuICAgICAqIDwvaWd4LXNwbGl0dGVyPlxuICAgICAqIGBgYFxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgcGFuZSBpcyBub3QgcmVzaXphYmxlIGl0cyByZWxhdGVkIHNwbGl0dGVyIGJhciBjYW5ub3QgYmUgZHJhZ2dlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByZXNpemFibGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiBjb2xsYXBzZWQgc3RhdGUgb2YgcGFuZSBpcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlcj5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lIChvblRvZ2dsZSk9J29uUGFuZVRvZ2dsZSgkZXZlbnQpJz4uLi48L2lneC1zcGxpdHRlci1wYW5lPlxuICAgICAqIDwvaWd4LXNwbGl0dGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBEZXByZWNhdGVQcm9wZXJ0eShgRGVwcmVjYXRlZC4gU3Vic2NyaWJlIHRvIHRoZSAnY29sbGFwc2VkQ2hhbmdlJyBvdXRwdXQgaW5zdGVhZC5gKVxuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvblRvZ2dsZSA9IG5ldyBFdmVudEVtaXR0ZXI8SWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiBjb2xsYXBzZWQgc3RhdGUgb2YgcGFuZSBpcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlcj5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lIChjb2xsYXBzZWRDaGFuZ2UpPSdwYW5lQ29sbGFwc2VkQ2hhbmdlKCRldmVudCknPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGNvbGxhcHNlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUub3JkZXInKVxuICAgIHB1YmxpYyBvcmRlciE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0cy9TZXRzIHRoZSBgb3ZlcmZsb3dgLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUub3ZlcmZsb3cnKVxuICAgIHB1YmxpYyBvdmVyZmxvdyA9ICdhdXRvJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0cy9TZXRzIHRoZSBgbWluSGVpZ2h0YCBhbmQgYG1pbldpZHRoYCBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhbmUuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5taW4taGVpZ2h0JylcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLm1pbi13aWR0aCcpXG4gICAgcHVibGljIG1pbkhlaWdodCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMvU2V0cyB0aGUgYG1heEhlaWdodGAgYW5kIGBtYXhXaWR0aGAgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBgSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50YC5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLm1heC1oZWlnaHQnKVxuICAgIEBIb3N0QmluZGluZygnc3R5bGUubWF4LXdpZHRoJylcbiAgICBwdWJsaWMgbWF4SGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG93bmVyO1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IHBhbmUuXG4gICAgICogICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlcj5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lIFtzaXplXT0nc2l6ZSc+Li4uPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAgICAgKiA8L2lneC1zcGxpdHRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBzaXplKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LnN0eWxlLmZsZXggPSB0aGlzLmZsZXg7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCBpc1BlcmNlbnRhZ2VTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnYXV0bycgfHwgdGhpcy5zaXplLmluZGV4T2YoJyUnKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCBkcmFnU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyYWdTaXplO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGRyYWdTaXplKHZhbCkge1xuICAgICAgICB0aGlzLl9kcmFnU2l6ZSA9IHZhbDtcbiAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LnN0eWxlLmZsZXggPSB0aGlzLmZsZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMgdGhlIGhvc3QgbmF0aXZlIGVsZW1lbnQuXG4gICAgICovXG4gICAgcHVibGljIGdldCBlbGVtZW50KCk6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzIHRoZSBgZmxleGAgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgYElneFNwbGl0dGVyUGFuZUNvbXBvbmVudGAuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5mbGV4JylcbiAgICBwdWJsaWMgZ2V0IGZsZXgoKSB7XG4gICAgICAgIGNvbnN0IGlzQXV0byA9IHRoaXMuc2l6ZSA9PT0gJ2F1dG8nICYmICF0aGlzLmRyYWdTaXplO1xuICAgICAgICBjb25zdCBncm93ID0gIWlzQXV0byA/IDAgOiAxO1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5kcmFnU2l6ZSB8fCB0aGlzLnNpemU7XG4gICAgICAgIHJldHVybiBgJHtncm93fSAke2dyb3d9ICR7c2l6ZX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB3aGV0aGVyIGN1cnJlbnQgcGFuZSBpcyBjb2xsYXBzZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBpc0NvbGxhcHNlZCA9IHBhbmUuY29sbGFwc2VkO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBjb2xsYXBzZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29sbGFwc2VkID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZGlzcGxheSA9IHRoaXMuX2NvbGxhcHNlZCA/ICdub25lJyA6ICdmbGV4JyA7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBjb2xsYXBzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc2l6ZSA9ICdhdXRvJztcbiAgICBwcml2YXRlIF9kcmFnU2l6ZTtcbiAgICBwcml2YXRlIF9jb2xsYXBzZWQgPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlbDogRWxlbWVudFJlZikgeyB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBjb2xsYXBzZWQgc3RhdGUgb2YgdGhlIHBhbmUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwYW5lLnRvZ2dsZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgICAgIC8vIHJlc2V0IHNpYmxpbmcgc2l6ZXMgd2hlbiBwYW5lIGNvbGxhcHNlIHN0YXRlIGNoYW5nZXMuXG4gICAgICAgIHRoaXMuX2dldFNpYmxpbmdzKCkuZm9yRWFjaChzaWJsaW5nID0+IHNpYmxpbmcuc2l6ZSA9ICdhdXRvJyk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gIXRoaXMuY29sbGFwc2VkO1xuICAgICAgICB0aGlzLm9uVG9nZ2xlLmVtaXQodGhpcyk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkQ2hhbmdlLmVtaXQodGhpcy5jb2xsYXBzZWQpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHByaXZhdGUgX2dldFNpYmxpbmdzKCkge1xuICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMub3duZXIucGFuZXMudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHBhbmVzLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gW107XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgc2libGluZ3MucHVzaChwYW5lc1tpbmRleCAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggIT09IHBhbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNpYmxpbmdzLnB1c2gocGFuZXNbaW5kZXggKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdzO1xuICAgIH1cbn1cbiJdfQ==