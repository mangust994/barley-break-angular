import { Component, Input, ContentChildren, HostBinding, Inject, ElementRef, Output, EventEmitter } from '@angular/core';
import { IgxSplitterPaneComponent } from './splitter-pane/splitter-pane.component';
import { DOCUMENT } from '@angular/common';
/**
 * An enumeration that defines the `SplitterComponent` panes orientation.
 */
export var SplitterType;
(function (SplitterType) {
    SplitterType[SplitterType["Horizontal"] = 0] = "Horizontal";
    SplitterType[SplitterType["Vertical"] = 1] = "Vertical";
})(SplitterType || (SplitterType = {}));
/**
 * Provides a framework for a simple layout, splitting the view horizontally or vertically
 * into multiple smaller resizable and collapsible areas.
 *
 * @igxModule IgxSplitterModule
 *
 * @igxParent Layouts
 *
 * @igxTheme igx-splitter-theme
 *
 * @igxKeywords splitter panes layout
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <igx-splitter>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 * </igx-splitter>
 * ```
 */
export class IgxSplitterComponent {
    constructor(document, elementRef) {
        this.document = document;
        this.elementRef = elementRef;
        /**
         * @hidden @internal
         * Gets/Sets the `overflow` property of the current splitter.
         */
        this.overflow = 'hidden';
        /**
         * @hidden @internal
         * Sets/Gets the `display` property of the current splitter.
         */
        this.display = 'flex';
        /**
         * Event fired when resizing of panes starts.
         *
         * @example
         * ```html
         * <igx-splitter (resizeStart)='resizeStart($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizeStart = new EventEmitter();
        /**
         * Event fired when resizing of panes is in progress.
         *
         * @example
         * ```html
         * <igx-splitter (resizing)='resizing($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizing = new EventEmitter();
        /**
         * Event fired when resizing of panes ends.
         *
         * @example
         * ```html
         * <igx-splitter (resizeEnd)='resizeEnd($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizeEnd = new EventEmitter();
        this._type = SplitterType.Horizontal;
    }
    /**
     * Gets/Sets the splitter orientation.
     *
     * @example
     * ```html
     * <igx-splitter [type]="type">...</igx-splitter>
     * ```
     */
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
        if (this.panes) {
            // if type is changed runtime, should reset sizes.
            this.panes.forEach(x => x.size = 'auto');
        }
    }
    /**
     * @hidden @internal
     * Gets the `flex-direction` property of the current `SplitterComponent`.
     */
    get direction() {
        return this.type === SplitterType.Horizontal ? 'row' : 'column';
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this.panes.forEach(pane => pane.owner = this);
        this.assignFlexOrder();
        this.panes.changes.subscribe(() => {
            this.panes.forEach(pane => pane.owner = this);
            this.assignFlexOrder();
        });
    }
    /**
     * @hidden @internal
     * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.
     * @param pane - the main pane associated with the currently dragged bar.
     */
    onMoveStart(pane) {
        const panes = this.panes.toArray();
        this.pane = pane;
        this.sibling = panes[panes.indexOf(this.pane) + 1];
        const paneRect = this.pane.element.getBoundingClientRect();
        this.initialPaneSize = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        const siblingRect = this.sibling.element.getBoundingClientRect();
        this.initialSiblingSize = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizeStart.emit(args);
    }
    /**
     * @hidden @internal
     * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.
     * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.
     */
    onMoving(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        this.pane.dragSize = paneSize + 'px';
        this.sibling.dragSize = siblingSize + 'px';
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizing.emit(args);
    }
    onMoveEnd(delta) {
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (this.pane.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentPaneSize = (paneSize / totalSize) * 100;
            this.pane.size = percentPaneSize + '%';
        }
        else {
            // px resize
            this.pane.size = paneSize + 'px';
        }
        if (this.sibling.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentSiblingPaneSize = (siblingSize / totalSize) * 100;
            this.sibling.size = percentSiblingPaneSize + '%';
        }
        else {
            // px resize
            this.sibling.size = siblingSize + 'px';
        }
        this.pane.dragSize = null;
        this.sibling.dragSize = null;
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizeEnd.emit(args);
    }
    /** @hidden @internal */
    getPaneSiblingsByOrder(order, barIndex) {
        const panes = this.panes.toArray();
        const prevPane = panes[order - barIndex - 1];
        const nextPane = panes[order - barIndex];
        const siblings = [prevPane, nextPane];
        return siblings;
    }
    getTotalSize() {
        const computed = this.document.defaultView.getComputedStyle(this.elementRef.nativeElement);
        const totalSize = this.type === SplitterType.Horizontal ? computed.getPropertyValue('width') : computed.getPropertyValue('height');
        return parseFloat(totalSize);
    }
    /**
     * @hidden @internal
     * This method assigns the order of each pane.
     */
    assignFlexOrder() {
        let k = 0;
        this.panes.forEach((pane) => {
            pane.order = k;
            k += 2;
        });
    }
}
IgxSplitterComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-splitter',
                template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\"\n                    (movingEnd)='onMoveEnd($event)'>\n    </igx-splitter-bar>\n</ng-container>\n"
            },] }
];
IgxSplitterComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ElementRef }
];
IgxSplitterComponent.propDecorators = {
    panes: [{ type: ContentChildren, args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent },] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }],
    display: [{ type: HostBinding, args: ['style.display',] }],
    resizeStart: [{ type: Output }],
    resizing: [{ type: Output }],
    resizeEnd: [{ type: Output }],
    type: [{ type: Input }],
    direction: [{ type: HostBinding, args: ['style.flex-direction',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXR0ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3NwbGl0dGVyL3NwbGl0dGVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFhLEtBQUssRUFBRSxlQUFlLEVBQW9CLFdBQVcsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUNuRyxNQUFNLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2pELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHlDQUF5QyxDQUFDO0FBQ25GLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUUzQzs7R0FFRztBQUNILE1BQU0sQ0FBTixJQUFZLFlBR1g7QUFIRCxXQUFZLFlBQVk7SUFDcEIsMkRBQVUsQ0FBQTtJQUNWLHVEQUFRLENBQUE7QUFDWixDQUFDLEVBSFcsWUFBWSxLQUFaLFlBQVksUUFHdkI7QUFPRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlCRztBQUtILE1BQU0sT0FBTyxvQkFBb0I7SUE0RjdCLFlBQXFDLFFBQVEsRUFBVSxVQUFzQjtRQUF4QyxhQUFRLEdBQVIsUUFBUSxDQUFBO1FBQVUsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQWhGN0U7OztXQUdHO1FBRUksYUFBUSxHQUFHLFFBQVEsQ0FBQztRQUUzQjs7O1dBR0c7UUFFSSxZQUFPLEdBQUcsTUFBTSxDQUFDO1FBRXhCOzs7Ozs7Ozs7V0FTRztRQUVJLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQStCLENBQUM7UUFFckU7Ozs7Ozs7OztXQVNHO1FBRUksYUFBUSxHQUFHLElBQUksWUFBWSxFQUErQixDQUFDO1FBR2xFOzs7Ozs7Ozs7V0FTRztRQUVJLGNBQVMsR0FBRyxJQUFJLFlBQVksRUFBK0IsQ0FBQztRQUUzRCxVQUFLLEdBQWlCLFlBQVks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LE1BQU07bUJBc0NOLEtBQUs7d0JBZ0JMLFdBQVcsU0FBQyxzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIFF1ZXJ5TGlzdCwgSW5wdXQsIENvbnRlbnRDaGlsZHJlbiwgQWZ0ZXJDb250ZW50SW5pdCwgSG9zdEJpbmRpbmcsIEluamVjdCwgRWxlbWVudFJlZixcbiAgICAgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCB9IGZyb20gJy4vc3BsaXR0ZXItcGFuZS9zcGxpdHRlci1wYW5lLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gdGhhdCBkZWZpbmVzIHRoZSBgU3BsaXR0ZXJDb21wb25lbnRgIHBhbmVzIG9yaWVudGF0aW9uLlxuICovXG5leHBvcnQgZW51bSBTcGxpdHRlclR5cGUge1xuICAgIEhvcml6b250YWwsXG4gICAgVmVydGljYWxcbn1cblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIElTcGxpdHRlckJhclJlc2l6ZUV2ZW50QXJncyB7XG4gICAgcGFuZTogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50O1xuICAgIHNpYmxpbmc6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudDtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhIGZyYW1ld29yayBmb3IgYSBzaW1wbGUgbGF5b3V0LCBzcGxpdHRpbmcgdGhlIHZpZXcgaG9yaXpvbnRhbGx5IG9yIHZlcnRpY2FsbHlcbiAqIGludG8gbXVsdGlwbGUgc21hbGxlciByZXNpemFibGUgYW5kIGNvbGxhcHNpYmxlIGFyZWFzLlxuICpcbiAqIEBpZ3hNb2R1bGUgSWd4U3BsaXR0ZXJNb2R1bGVcbiAqXG4gKiBAaWd4UGFyZW50IExheW91dHNcbiAqXG4gKiBAaWd4VGhlbWUgaWd4LXNwbGl0dGVyLXRoZW1lXG4gKlxuICogQGlneEtleXdvcmRzIHNwbGl0dGVyIHBhbmVzIGxheW91dFxuICpcbiAqIEBpZ3hHcm91cCBwcmVzZW50YXRpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC1zcGxpdHRlcj5cbiAqICA8aWd4LXNwbGl0dGVyLXBhbmU+XG4gKiAgICAgIC4uLlxuICogIDwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gKiAgPGlneC1zcGxpdHRlci1wYW5lPlxuICogICAgICAuLi5cbiAqICA8L2lneC1zcGxpdHRlci1wYW5lPlxuICogPC9pZ3gtc3BsaXR0ZXI+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtc3BsaXR0ZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zcGxpdHRlci5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSWd4U3BsaXR0ZXJDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IG9mIHNwbGl0dGVyIHBhbmVzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcGFuZXMgPSB0aGlzLnNwbGl0dGVyLnBhbmVzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50LCB7IHJlYWQ6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCB9KVxuICAgIHB1YmxpYyBwYW5lcyE6IFF1ZXJ5TGlzdDxJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzL1NldHMgdGhlIGBvdmVyZmxvd2AgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgc3BsaXR0ZXIuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5vdmVyZmxvdycpXG4gICAgcHVibGljIG92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFNldHMvR2V0cyB0aGUgYGRpc3BsYXlgIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IHNwbGl0dGVyLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuZGlzcGxheScpXG4gICAgcHVibGljIGRpc3BsYXkgPSAnZmxleCc7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHJlc2l6aW5nIG9mIHBhbmVzIHN0YXJ0cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXIgKHJlc2l6ZVN0YXJ0KT0ncmVzaXplU3RhcnQoJGV2ZW50KSc+XG4gICAgICogIDxpZ3gtc3BsaXR0ZXItcGFuZT4uLi48L2lneC1zcGxpdHRlci1wYW5lPlxuICAgICAqIDwvaWd4LXNwbGl0dGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZXNpemVTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXI8SVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiByZXNpemluZyBvZiBwYW5lcyBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXIgKHJlc2l6aW5nKT0ncmVzaXppbmcoJGV2ZW50KSc+XG4gICAgICogIDxpZ3gtc3BsaXR0ZXItcGFuZT4uLi48L2lneC1zcGxpdHRlci1wYW5lPlxuICAgICAqIDwvaWd4LXNwbGl0dGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZXNpemluZyA9IG5ldyBFdmVudEVtaXR0ZXI8SVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzPigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHJlc2l6aW5nIG9mIHBhbmVzIGVuZHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNwbGl0dGVyIChyZXNpemVFbmQpPSdyZXNpemVFbmQoJGV2ZW50KSc+XG4gICAgICogIDxpZ3gtc3BsaXR0ZXItcGFuZT4uLi48L2lneC1zcGxpdHRlci1wYW5lPlxuICAgICAqIDwvaWd4LXNwbGl0dGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZXNpemVFbmQgPSBuZXcgRXZlbnRFbWl0dGVyPElTcGxpdHRlckJhclJlc2l6ZUV2ZW50QXJncz4oKTtcblxuICAgIHByaXZhdGUgX3R5cGU6IFNwbGl0dGVyVHlwZSA9IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBBIGZpZWxkIHRoYXQgaG9sZHMgdGhlIGluaXRpYWwgc2l6ZSBvZiB0aGUgbWFpbiBgSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50YCBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIHNwbGl0dGVyIGJhci5cbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRpYWxQYW5lU2l6ZSE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogQSBmaWVsZCB0aGF0IGhvbGRzIHRoZSBpbml0aWFsIHNpemUgb2YgdGhlIHNpYmxpbmcgcGFuZSBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIGdyaXBwZXIuXG4gICAgICogQG1lbWJlcm9mIFNwbGl0dGVyQ29tcG9uZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0aWFsU2libGluZ1NpemUhOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoZSBtYWluIHBhbmUgaW4gZWFjaCBwYWlyIG9mIHBhbmVzIGRpdmlkZWQgYnkgYSBncmlwcGVyLlxuICAgICAqL1xuICAgIHByaXZhdGUgcGFuZSE6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaWJsaW5nIHBhbmUgaW4gZWFjaCBwYWlyIG9mIHBhbmVzIGRpdmlkZWQgYnkgYSBzcGxpdHRlciBiYXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzaWJsaW5nITogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50O1xuXG4gICAgY29uc3RydWN0b3IoQEluamVjdChET0NVTUVOVCkgcHVibGljIGRvY3VtZW50LCBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHt9XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBzcGxpdHRlciBvcmllbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXIgW3R5cGVdPVwidHlwZVwiPi4uLjwvaWd4LXNwbGl0dGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG4gICAgcHVibGljIHNldCB0eXBlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMucGFuZXMpIHtcbiAgICAgICAgICAgIC8vIGlmIHR5cGUgaXMgY2hhbmdlZCBydW50aW1lLCBzaG91bGQgcmVzZXQgc2l6ZXMuXG4gICAgICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2goeCA9PiB4LnNpemUgPSAnYXV0bycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzIHRoZSBgZmxleC1kaXJlY3Rpb25gIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IGBTcGxpdHRlckNvbXBvbmVudGAuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5mbGV4LWRpcmVjdGlvbicpXG4gICAgcHVibGljIGdldCBkaXJlY3Rpb24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyAncm93JyA6ICdjb2x1bW4nO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGFuZXMuZm9yRWFjaChwYW5lID0+IHBhbmUub3duZXIgPSB0aGlzKTtcbiAgICAgICAgdGhpcy5hc3NpZ25GbGV4T3JkZXIoKTtcbiAgICAgICAgdGhpcy5wYW5lcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2gocGFuZSA9PiBwYW5lLm93bmVyID0gdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmFzc2lnbkZsZXhPcmRlcigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zICBpbml0aWFsaXphdGlvbiBsb2dpYyB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgc3BsaXR0ZXIgYmFyIGJldHdlZW4gZWFjaCBwYWlyIG9mIHBhbmVzLlxuICAgICAqIEBwYXJhbSBwYW5lIC0gdGhlIG1haW4gcGFuZSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnRseSBkcmFnZ2VkIGJhci5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25Nb3ZlU3RhcnQocGFuZTogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHBhbmVzID0gdGhpcy5wYW5lcy50b0FycmF5KCk7XG4gICAgICAgIHRoaXMucGFuZSA9IHBhbmU7XG4gICAgICAgIHRoaXMuc2libGluZyA9IHBhbmVzW3BhbmVzLmluZGV4T2YodGhpcy5wYW5lKSArIDFdO1xuXG4gICAgICAgIGNvbnN0IHBhbmVSZWN0ID0gdGhpcy5wYW5lLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFBhbmVTaXplID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IHBhbmVSZWN0LndpZHRoIDogcGFuZVJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIGNvbnN0IHNpYmxpbmdSZWN0ID0gdGhpcy5zaWJsaW5nLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IHNpYmxpbmdSZWN0LndpZHRoIDogc2libGluZ1JlY3QuaGVpZ2h0O1xuICAgICAgICBjb25zdCBhcmdzOiBJU3BsaXR0ZXJCYXJSZXNpemVFdmVudEFyZ3MgPSB7cGFuZTogdGhpcy5wYW5lLCBzaWJsaW5nOiB0aGlzLnNpYmxpbmd9O1xuICAgICAgICB0aGlzLnJlc2l6ZVN0YXJ0LmVtaXQoYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyBjYWxjdWxhdGlvbnMgY29uY2VybmluZyB0aGUgc2l6ZXMgb2YgZWFjaCBwYWlyIG9mIHBhbmVzIHdoZW4gdGhlIGJhciBiZXR3ZWVuIHRoZW0gaXMgZHJhZ2dlZC5cbiAgICAgKiBAcGFyYW0gZGVsdGEgLSBUaGUgZGlmZmVyZW5jZSBhbG9uZyB0aGUgWCAob3IgWSkgYXhpcyBiZXR3ZWVuIHRoZSBpbml0aWFsIGFuZCB0aGUgY3VycmVudCBwb2ludCB3aGVuIGRyYWdnaW5nIHRoZSBiYXIuXG4gICAgICovXG4gICAgcHVibGljIG9uTW92aW5nKGRlbHRhOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgbWluID0gcGFyc2VJbnQodGhpcy5wYW5lLm1pblNpemUsIDEwKSB8fCAwO1xuICAgICAgICBjb25zdCBtYXggPSBwYXJzZUludCh0aGlzLnBhbmUubWF4U2l6ZSwgMTApIHx8IHRoaXMuaW5pdGlhbFBhbmVTaXplICsgdGhpcy5pbml0aWFsU2libGluZ1NpemU7XG4gICAgICAgIGNvbnN0IG1pblNpYmxpbmcgPSBwYXJzZUludCh0aGlzLnNpYmxpbmcubWluU2l6ZSwgMTApIHx8IDA7XG4gICAgICAgIGNvbnN0IG1heFNpYmxpbmcgPSBwYXJzZUludCh0aGlzLnNpYmxpbmcubWF4U2l6ZSwgMTApIHx8IHRoaXMuaW5pdGlhbFBhbmVTaXplICsgdGhpcy5pbml0aWFsU2libGluZ1NpemU7XG5cbiAgICAgICAgY29uc3QgcGFuZVNpemUgPSB0aGlzLmluaXRpYWxQYW5lU2l6ZSAtIGRlbHRhO1xuICAgICAgICBjb25zdCBzaWJsaW5nU2l6ZSA9IHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplICsgZGVsdGE7XG4gICAgICAgIGlmIChwYW5lU2l6ZSA8IG1pbiB8fCBwYW5lU2l6ZSA+IG1heCB8fCBzaWJsaW5nU2l6ZSA8IG1pblNpYmxpbmcgfHwgc2libGluZ1NpemUgPiBtYXhTaWJsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYW5lLmRyYWdTaXplID0gcGFuZVNpemUgKyAncHgnO1xuICAgICAgICB0aGlzLnNpYmxpbmcuZHJhZ1NpemUgPSBzaWJsaW5nU2l6ZSArICdweCc7XG5cbiAgICAgICAgY29uc3QgYXJnczogSVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzID0geyBwYW5lOiB0aGlzLnBhbmUsIHNpYmxpbmc6IHRoaXMuc2libGluZyB9O1xuICAgICAgICB0aGlzLnJlc2l6aW5nLmVtaXQoYXJncyk7XG4gICAgfVxuXG4gICAgcHVibGljIG9uTW92ZUVuZChkZWx0YTogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHBhbmVTaXplID0gdGhpcy5pbml0aWFsUGFuZVNpemUgLSBkZWx0YTtcbiAgICAgICAgY29uc3Qgc2libGluZ1NpemUgPSB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZSArIGRlbHRhO1xuICAgICAgICBpZiAodGhpcy5wYW5lLmlzUGVyY2VudGFnZVNpemUpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSAlIHJlc2l6ZXNcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IHRoaXMuZ2V0VG90YWxTaXplKCk7XG4gICAgICAgICAgICBjb25zdCBwZXJjZW50UGFuZVNpemUgPSAocGFuZVNpemUgLyB0b3RhbFNpemUpICogMTAwO1xuICAgICAgICAgICAgdGhpcy5wYW5lLnNpemUgPSBwZXJjZW50UGFuZVNpemUgKyAnJSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBweCByZXNpemVcbiAgICAgICAgICAgIHRoaXMucGFuZS5zaXplID0gcGFuZVNpemUgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2libGluZy5pc1BlcmNlbnRhZ2VTaXplKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgJSByZXNpemVzXG4gICAgICAgICAgICBjb25zdCB0b3RhbFNpemUgPSB0aGlzLmdldFRvdGFsU2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudFNpYmxpbmdQYW5lU2l6ZSA9ICAoc2libGluZ1NpemUgLyB0b3RhbFNpemUpICogMTAwO1xuICAgICAgICAgICAgdGhpcy5zaWJsaW5nLnNpemUgPSBwZXJjZW50U2libGluZ1BhbmVTaXplICsgJyUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcHggcmVzaXplXG4gICAgICAgICAgICB0aGlzLnNpYmxpbmcuc2l6ZSA9IHNpYmxpbmdTaXplICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhbmUuZHJhZ1NpemUgPSBudWxsO1xuICAgICAgICB0aGlzLnNpYmxpbmcuZHJhZ1NpemUgPSBudWxsO1xuXG4gICAgICAgIGNvbnN0IGFyZ3M6IElTcGxpdHRlckJhclJlc2l6ZUV2ZW50QXJncyA9IHsgcGFuZTogdGhpcy5wYW5lLCBzaWJsaW5nOiB0aGlzLnNpYmxpbmcgfTtcbiAgICAgICAgdGhpcy5yZXNpemVFbmQuZW1pdChhcmdzKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgZ2V0UGFuZVNpYmxpbmdzQnlPcmRlcihvcmRlcjogbnVtYmVyLCBiYXJJbmRleDogbnVtYmVyKTogQXJyYXk8SWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50PiB7XG4gICAgICAgIGNvbnN0IHBhbmVzID0gdGhpcy5wYW5lcy50b0FycmF5KCk7XG4gICAgICAgIGNvbnN0IHByZXZQYW5lID0gcGFuZXNbb3JkZXIgLSBiYXJJbmRleCAtIDFdO1xuICAgICAgICBjb25zdCBuZXh0UGFuZSA9IHBhbmVzW29yZGVyIC0gYmFySW5kZXhdO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IFtwcmV2UGFuZSwgbmV4dFBhbmVdO1xuICAgICAgICByZXR1cm4gc2libGluZ3M7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUb3RhbFNpemUoKSB7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gdGhpcy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgY29uc3QgdG90YWxTaXplID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJykgOiBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodG90YWxTaXplKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyB0aGUgb3JkZXIgb2YgZWFjaCBwYW5lLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXNzaWduRmxleE9yZGVyKCkge1xuICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgIHRoaXMucGFuZXMuZm9yRWFjaCgocGFuZTogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICBwYW5lLm9yZGVyID0gaztcbiAgICAgICAgICAgIGsgKz0gMjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19