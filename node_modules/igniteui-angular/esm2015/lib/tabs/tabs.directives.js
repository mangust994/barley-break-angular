import { Directive, HostBinding, TemplateRef } from '@angular/core';
import { IgxTabsBase } from './tabs.common';
var TabScrollButtonStyle;
(function (TabScrollButtonStyle) {
    TabScrollButtonStyle["Visible"] = "visible";
    TabScrollButtonStyle["Hidden"] = "hidden";
    TabScrollButtonStyle["NotDisplayed"] = "not_displayed";
})(TabScrollButtonStyle || (TabScrollButtonStyle = {}));
export class IgxRightButtonStyleDirective {
    constructor(tabs) {
        this.tabs = tabs;
    }
    get visibleCSS() {
        return (this.getRightButtonStyle() === TabScrollButtonStyle.Visible) ? true : false;
    }
    get hiddenCSS() {
        return (this.getRightButtonStyle() === TabScrollButtonStyle.Hidden) ? true : false;
    }
    get notDisplayedCSS() {
        return (this.getRightButtonStyle() === TabScrollButtonStyle.NotDisplayed) ? true : false;
    }
    getRightButtonStyle() {
        const viewPortWidth = this.tabs.viewPort.nativeElement.offsetWidth;
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
        }
        const headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
        const offset = this.tabs.offset;
        const total = offset + viewPortWidth;
        // Fix for IE 11, a difference is accumulated from the widths calculations.
        if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
            return TabScrollButtonStyle.NotDisplayed;
        }
        if (itemsContainerWidth > total) {
            return TabScrollButtonStyle.Visible;
        }
        else {
            return TabScrollButtonStyle.Hidden;
        }
    }
}
IgxRightButtonStyleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxRightButtonStyle]'
            },] }
];
IgxRightButtonStyleDirective.ctorParameters = () => [
    { type: IgxTabsBase }
];
IgxRightButtonStyleDirective.propDecorators = {
    visibleCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button',] }],
    hiddenCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--hidden',] }],
    notDisplayedCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--none',] }]
};
export class IgxLeftButtonStyleDirective {
    constructor(tabs) {
        this.tabs = tabs;
    }
    get visibleCSS() {
        return (this.getLeftButtonStyle() === TabScrollButtonStyle.Visible) ? true : false;
    }
    get hiddenCSS() {
        return (this.getLeftButtonStyle() === TabScrollButtonStyle.Hidden) ? true : false;
    }
    get notDisplayedCSS() {
        return (this.getLeftButtonStyle() === TabScrollButtonStyle.NotDisplayed) ? true : false;
    }
    getLeftButtonStyle() {
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
        }
        const headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
        const offset = this.tabs.offset;
        if (offset === 0) {
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1) {
                return TabScrollButtonStyle.NotDisplayed;
            }
            return TabScrollButtonStyle.Hidden;
        }
        else {
            return TabScrollButtonStyle.Visible;
        }
    }
}
IgxLeftButtonStyleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxLeftButtonStyle]'
            },] }
];
IgxLeftButtonStyleDirective.ctorParameters = () => [
    { type: IgxTabsBase }
];
IgxLeftButtonStyleDirective.propDecorators = {
    visibleCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button',] }],
    hiddenCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--hidden',] }],
    notDisplayedCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--none',] }]
};
export class IgxTabItemTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxTabItemTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxTab]'
            },] }
];
IgxTabItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5kaXJlY3RpdmVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3RhYnMvdGFicy5kaXJlY3RpdmVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCxTQUFTLEVBQ1QsV0FBVyxFQUNYLFdBQVcsRUFDZCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTVDLElBQUssb0JBSUo7QUFKRCxXQUFLLG9CQUFvQjtJQUNyQiwyQ0FBbUIsQ0FBQTtJQUNuQix5Q0FBaUIsQ0FBQTtJQUNqQixzREFBOEIsQ0FBQTtBQUNsQyxDQUFDLEVBSkksb0JBQW9CLEtBQXBCLG9CQUFvQixRQUl4QjtBQU1ELE1BQU0sT0FBTyw0QkFBNEI7SUFDckMsWUFBbUIsSUFBaUI7UUFBakIsU0FBSSxHQUFKLElBQUksQ0FBYTtJQUNwQyxDQUFDO0lBRUQsSUFDVyxVQUFVO1FBQ2pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsS0FBSyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDeEYsQ0FBQztJQUVELElBQ1csU0FBUztRQUNoQixPQUFPLENBQUMsSUFBSSxDQUFDLG1CQUFtQixFQUFFLEtBQUssb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQ3ZGLENBQUM7SUFFRCxJQUNXLGVBQWU7UUFDdEIsT0FBTyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxLQUFLLG9CQUFvQixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztJQUM3RixDQUFDO0lBRU8sbUJBQW1CO1FBQ3ZCLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUM7UUFFbkUsZ0VBQWdFO1FBQ2hFLGtGQUFrRjtRQUNsRixNQUFNLDJCQUEyQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDO1FBQzNGLElBQUksbUJBQW1CLEdBQUcsQ0FBQyxDQUFDO1FBQzVCLElBQUksMkJBQTJCLEdBQUcsQ0FBQyxFQUFFO1lBQ2pDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsMkJBQTJCLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDakcsbUJBQW1CLEdBQUcsT0FBTyxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDO1NBQ2xFO1FBQ0QsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDO1FBQ2pGLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ2hDLE1BQU0sS0FBSyxHQUFHLE1BQU0sR0FBRyxhQUFhLENBQUM7UUFFckMsMkVBQTJFO1FBQzNFLElBQUksbUJBQW1CLEdBQUcsb0JBQW9CLElBQUksQ0FBQyxJQUFJLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDakUsT0FBTyxvQkFBb0IsQ0FBQyxZQUFZLENBQUM7U0FDNUM7UUFFRCxJQUFJLG1CQUFtQixHQUFHLEtBQUssRUFBRTtZQUM3QixPQUFPLG9CQUFvQixDQUFDLE9BQU8sQ0FBQztTQUN2QzthQUFNO1lBQ0gsT0FBTyxvQkFBb0IsQ0FBQyxNQUFNLENBQUM7U0FDdEM7SUFDTCxDQUFDOzs7WUFoREosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSx1QkFBdUI7YUFDcEM7OztZQVZRLFdBQVc7Ozt5QkFnQmYsV0FBVyxTQUFDLCtCQUErQjt3QkFLM0MsV0FBVyxTQUFDLHVDQUF1Qzs4QkFLbkQsV0FBVyxTQUFDLHFDQUFxQzs7QUFxQ3RELE1BQU0sT0FBTywyQkFBMkI7SUFDcEMsWUFBbUIsSUFBaUI7UUFBakIsU0FBSSxHQUFKLElBQUksQ0FBYTtJQUNwQyxDQUFDO0lBRUQsSUFDVyxVQUFVO1FBQ2pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsS0FBSyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDdkYsQ0FBQztJQUVELElBQ1csU0FBUztRQUNoQixPQUFPLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLEtBQUssb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQ3RGLENBQUM7SUFFRCxJQUNXLGVBQWU7UUFDdEIsT0FBTyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxLQUFLLG9CQUFvQixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztJQUM1RixDQUFDO0lBRU8sa0JBQWtCO1FBQ3RCLGdFQUFnRTtRQUNoRSxrRkFBa0Y7UUFDbEYsTUFBTSwyQkFBMkIsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztRQUMzRixJQUFJLG1CQUFtQixHQUFHLENBQUMsQ0FBQztRQUM1QixJQUFJLDJCQUEyQixHQUFHLENBQUMsRUFBRTtZQUNqQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLDJCQUEyQixHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ2pHLG1CQUFtQixHQUFHLE9BQU8sQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQztTQUNsRTtRQUNELE1BQU0sb0JBQW9CLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQztRQUNqRixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNoQyxJQUFJLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDZCwyRUFBMkU7WUFDM0UsSUFBSSxtQkFBbUIsR0FBRyxvQkFBb0IsSUFBSSxDQUFDLEVBQUU7Z0JBQ2pELE9BQU8sb0JBQW9CLENBQUMsWUFBWSxDQUFDO2FBQzVDO1lBQ0QsT0FBTyxvQkFBb0IsQ0FBQyxNQUFNLENBQUM7U0FDdEM7YUFBTTtZQUNILE9BQU8sb0JBQW9CLENBQUMsT0FBTyxDQUFDO1NBQ3ZDO0lBQ0wsQ0FBQzs7O1lBM0NKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsc0JBQXNCO2FBQ25DOzs7WUE3RFEsV0FBVzs7O3lCQW1FZixXQUFXLFNBQUMsK0JBQStCO3dCQUszQyxXQUFXLFNBQUMsdUNBQXVDOzhCQUtuRCxXQUFXLFNBQUMscUNBQXFDOztBQStCdEQsTUFBTSxPQUFPLDJCQUEyQjtJQUVwQyxZQUFtQixRQUEwQjtRQUExQixhQUFRLEdBQVIsUUFBUSxDQUFrQjtJQUM3QyxDQUFDOzs7WUFOSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLFVBQVU7YUFDdkI7OztZQTdHRyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgVGVtcGxhdGVSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hUYWJzQmFzZSB9IGZyb20gJy4vdGFicy5jb21tb24nO1xuXG5lbnVtIFRhYlNjcm9sbEJ1dHRvblN0eWxlIHtcbiAgICBWaXNpYmxlID0gJ3Zpc2libGUnLFxuICAgIEhpZGRlbiA9ICdoaWRkZW4nLFxuICAgIE5vdERpc3BsYXllZCA9ICdub3RfZGlzcGxheWVkJ1xufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hSaWdodEJ1dHRvblN0eWxlXSdcbn0pXG5cbmV4cG9ydCBjbGFzcyBJZ3hSaWdodEJ1dHRvblN0eWxlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdGFiczogSWd4VGFic0Jhc2UpIHtcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC10YWJzX19oZWFkZXItYnV0dG9uJylcbiAgICBwdWJsaWMgZ2V0IHZpc2libGVDU1MoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZXRSaWdodEJ1dHRvblN0eWxlKCkgPT09IFRhYlNjcm9sbEJ1dHRvblN0eWxlLlZpc2libGUpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRhYnNfX2hlYWRlci1idXR0b24tLWhpZGRlbicpXG4gICAgcHVibGljIGdldCBoaWRkZW5DU1MoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZXRSaWdodEJ1dHRvblN0eWxlKCkgPT09IFRhYlNjcm9sbEJ1dHRvblN0eWxlLkhpZGRlbikgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtdGFic19faGVhZGVyLWJ1dHRvbi0tbm9uZScpXG4gICAgcHVibGljIGdldCBub3REaXNwbGF5ZWRDU1MoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZXRSaWdodEJ1dHRvblN0eWxlKCkgPT09IFRhYlNjcm9sbEJ1dHRvblN0eWxlLk5vdERpc3BsYXllZCkgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRSaWdodEJ1dHRvblN0eWxlKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHZpZXdQb3J0V2lkdGggPSB0aGlzLnRhYnMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgICAvLyBXZSB1c2UgdGhpcyBoYWNreSB3YXkgdG8gZ2V0IHRoZSB3aWR0aCBvZiB0aGUgaXRlbXNDb250YWluZXIsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgaW5jb25zaXN0ZW5jeSBpbiBJRSB3ZSBjYW5ub3QgdXNlIG9mZnNldFdpZHRoIG9yIHNjcm9sbE9mZnNldC5cbiAgICAgICAgY29uc3QgaXRlbXNDb250YWluZXJDaGlsZHJlbkNvdW50ID0gdGhpcy50YWJzLml0ZW1zQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBsZXQgaXRlbXNDb250YWluZXJXaWR0aCA9IDA7XG4gICAgICAgIGlmIChpdGVtc0NvbnRhaW5lckNoaWxkcmVuQ291bnQgPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0VGFiID0gdGhpcy50YWJzLml0ZW1zQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5baXRlbXNDb250YWluZXJDaGlsZHJlbkNvdW50IC0gMl07XG4gICAgICAgICAgICBpdGVtc0NvbnRhaW5lcldpZHRoID0gbGFzdFRhYi5vZmZzZXRMZWZ0ICsgbGFzdFRhYi5vZmZzZXRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJDb250YWluZXJXaWR0aCA9IHRoaXMudGFicy5oZWFkZXJDb250YWluZXIubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy50YWJzLm9mZnNldDtcbiAgICAgICAgY29uc3QgdG90YWwgPSBvZmZzZXQgKyB2aWV3UG9ydFdpZHRoO1xuXG4gICAgICAgIC8vIEZpeCBmb3IgSUUgMTEsIGEgZGlmZmVyZW5jZSBpcyBhY2N1bXVsYXRlZCBmcm9tIHRoZSB3aWR0aHMgY2FsY3VsYXRpb25zLlxuICAgICAgICBpZiAoaXRlbXNDb250YWluZXJXaWR0aCAtIGhlYWRlckNvbnRhaW5lcldpZHRoIDw9IDEgJiYgb2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuTm90RGlzcGxheWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1zQ29udGFpbmVyV2lkdGggPiB0b3RhbCkge1xuICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLlZpc2libGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuSGlkZGVuO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hMZWZ0QnV0dG9uU3R5bGVdJ1xufSlcblxuZXhwb3J0IGNsYXNzIElneExlZnRCdXR0b25TdHlsZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IocHVibGljIHRhYnM6IElneFRhYnNCYXNlKSB7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtdGFic19faGVhZGVyLWJ1dHRvbicpXG4gICAgcHVibGljIGdldCB2aXNpYmxlQ1NTKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0TGVmdEJ1dHRvblN0eWxlKCkgPT09IFRhYlNjcm9sbEJ1dHRvblN0eWxlLlZpc2libGUpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRhYnNfX2hlYWRlci1idXR0b24tLWhpZGRlbicpXG4gICAgcHVibGljIGdldCBoaWRkZW5DU1MoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZXRMZWZ0QnV0dG9uU3R5bGUoKSA9PT0gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuSGlkZGVuKSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC10YWJzX19oZWFkZXItYnV0dG9uLS1ub25lJylcbiAgICBwdWJsaWMgZ2V0IG5vdERpc3BsYXllZENTUygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdldExlZnRCdXR0b25TdHlsZSgpID09PSBUYWJTY3JvbGxCdXR0b25TdHlsZS5Ob3REaXNwbGF5ZWQpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0TGVmdEJ1dHRvblN0eWxlKCk6IHN0cmluZyB7XG4gICAgICAgIC8vIFdlIHVzZSB0aGlzIGhhY2t5IHdheSB0byBnZXQgdGhlIHdpZHRoIG9mIHRoZSBpdGVtc0NvbnRhaW5lcixcbiAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBpbmNvbnNpc3RlbmN5IGluIElFIHdlIGNhbm5vdCB1c2Ugb2Zmc2V0V2lkdGggb3Igc2Nyb2xsT2Zmc2V0LlxuICAgICAgICBjb25zdCBpdGVtc0NvbnRhaW5lckNoaWxkcmVuQ291bnQgPSB0aGlzLnRhYnMuaXRlbXNDb250YWluZXIubmF0aXZlRWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGxldCBpdGVtc0NvbnRhaW5lcldpZHRoID0gMDtcbiAgICAgICAgaWYgKGl0ZW1zQ29udGFpbmVyQ2hpbGRyZW5Db3VudCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RUYWIgPSB0aGlzLnRhYnMuaXRlbXNDb250YWluZXIubmF0aXZlRWxlbWVudC5jaGlsZHJlbltpdGVtc0NvbnRhaW5lckNoaWxkcmVuQ291bnQgLSAyXTtcbiAgICAgICAgICAgIGl0ZW1zQ29udGFpbmVyV2lkdGggPSBsYXN0VGFiLm9mZnNldExlZnQgKyBsYXN0VGFiLm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlckNvbnRhaW5lcldpZHRoID0gdGhpcy50YWJzLmhlYWRlckNvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnRhYnMub2Zmc2V0O1xuICAgICAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBGaXggZm9yIElFIDExLCBhIGRpZmZlcmVuY2UgaXMgYWNjdW11bGF0ZWQgZnJvbSB0aGUgd2lkdGhzIGNhbGN1bGF0aW9ucy5cbiAgICAgICAgICAgIGlmIChpdGVtc0NvbnRhaW5lcldpZHRoIC0gaGVhZGVyQ29udGFpbmVyV2lkdGggPD0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5Ob3REaXNwbGF5ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuSGlkZGVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLlZpc2libGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneFRhYl0nXG59KVxuZXhwb3J0IGNsYXNzIElneFRhYkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICB9XG59XG4iXX0=