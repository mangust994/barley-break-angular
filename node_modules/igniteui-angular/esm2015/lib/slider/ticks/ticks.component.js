import { Component, Input, HostBinding } from '@angular/core';
import { TicksOrientation, TickLabelsOrientation } from '../slider.common';
/**
 * @hidden
 */
export class IgxTicksComponent {
    constructor() {
        /**
         * @hidden
         */
        this.ticksClass = true;
    }
    /**
     * @hidden
     */
    get ticksTopClass() {
        return this.ticksOrientation === TicksOrientation.Top;
    }
    /**
     * @hidden
     */
    get hasPrimaryClass() {
        return this.primaryTicks > 0;
    }
    /**
     * @hidden
     */
    get labelsTopToBottomClass() {
        return this.tickLabelsOrientation === TickLabelsOrientation.TopToBottom;
    }
    /**
     * @hidden
     */
    get labelsBottomToTopClass() {
        return this.tickLabelsOrientation === TickLabelsOrientation.BottomToTop;
    }
    /**
     * Returns the template context corresponding to
     * {@link IgxTickLabelTemplateDirective}
     *
     * ```typescript
     * return {
     *  $implicit //returns the value per each tick label.
     *  isPrimery //returns if the tick is primary.
     *  labels // returns the {@link labels} collection.
     *  index // returns the index per each tick of the whole sequence.
     * }
     * ```
     *
     * @param idx the index per each tick label.
     */
    context(idx) {
        return {
            $implicit: this.tickLabel(idx),
            isPrimary: this.isPrimary(idx),
            labels: this.labels,
            index: idx
        };
    }
    /**
     * @hidden
     */
    get ticksLength() {
        return this.primaryTicks > 0 ?
            ((this.primaryTicks - 1) * this.secondaryTicks) + this.primaryTicks :
            this.secondaryTicks > 0 ? this.secondaryTicks : 0;
    }
    hiddenTickLabels(idx) {
        return this.isPrimary(idx) ? this.primaryTickLabels : this.secondaryTickLabels;
    }
    /**
     * @hidden
     */
    isPrimary(idx) {
        return this.primaryTicks <= 0 ? false :
            idx % (this.secondaryTicks + 1) === 0;
    }
    /**
     * @hidden
     */
    tickLabel(idx) {
        if (this.labelsViewEnabled) {
            return this.labels[idx];
        }
        const labelStep = (Math.max(this.minValue, this.maxValue) - Math.min(this.minValue, this.maxValue)) / (this.ticksLength - 1);
        const labelVal = labelStep * idx;
        return (this.minValue + labelVal).toFixed(2);
    }
}
IgxTicksComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-ticks',
                template: "<div class=\"igx-slider__ticks-group\" *ngFor=\"let n of [].constructor(ticksLength); let idx=index\" [ngClass]=\"{ 'igx-slider__ticks-group--tall': isPrimary(idx)}\">\n    <div class=\"igx-slider__ticks-tick\">\n        <span class=\"igx-slider__ticks-label\" [ngClass]=\"{ 'igx-slider__tick-label--hidden': !hiddenTickLabels(idx)}\">\n            <ng-container *ngTemplateOutlet=\"tickLabelTemplateRef ? tickLabelTemplateRef : tickLabelDefaultTemplate; context: context(idx)\"></ng-container>\n        </span>\n    </div>\n</div>\n\n<ng-template #tickLabelDefaultTemplate let-value>\n    {{ value }}\n</ng-template>\n"
            },] }
];
IgxTicksComponent.propDecorators = {
    primaryTicks: [{ type: Input }],
    secondaryTicks: [{ type: Input }],
    primaryTickLabels: [{ type: Input }],
    secondaryTickLabels: [{ type: Input }],
    ticksOrientation: [{ type: Input }],
    tickLabelsOrientation: [{ type: Input }],
    maxValue: [{ type: Input }],
    minValue: [{ type: Input }],
    labelsViewEnabled: [{ type: Input }],
    labels: [{ type: Input }],
    tickLabelTemplateRef: [{ type: Input }],
    ticksClass: [{ type: HostBinding, args: ['class.igx-slider__ticks',] }],
    ticksTopClass: [{ type: HostBinding, args: ['class.igx-slider__ticks--top',] }],
    hasPrimaryClass: [{ type: HostBinding, args: ['class.igx-slider__ticks--tall',] }],
    labelsTopToBottomClass: [{ type: HostBinding, args: ['class.igx-slider__tick-labels--top-bottom',] }],
    labelsBottomToTopClass: [{ type: HostBinding, args: ['class.igx-slider__tick-labels--bottom-top',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGlja3MuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3NsaWRlci90aWNrcy90aWNrcy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQWUsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRTNFOztHQUVHO0FBS0gsTUFBTSxPQUFPLGlCQUFpQjtJQUo5QjtRQXNDSTs7V0FFRztRQUVJLGVBQVUsR0FBRyxJQUFJLENBQUM7SUE0RjdCLENBQUM7SUExRkc7O09BRUc7SUFDSCxJQUNXLGFBQWE7UUFDcEIsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLEtBQUssZ0JBQWdCLENBQUMsR0FBRyxDQUFDO0lBQzFELENBQUM7SUFFRDs7T0FFRztJQUNILElBQ1csZUFBZTtRQUN0QixPQUFPLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQ1csc0JBQXNCO1FBQzdCLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixLQUFLLHFCQUFxQixDQUFDLFdBQVcsQ0FBQztJQUM1RSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUNXLHNCQUFzQjtRQUM3QixPQUFPLElBQUksQ0FBQyxxQkFBcUIsS0FBSyxxQkFBcUIsQ0FBQyxXQUFXLENBQUM7SUFDNUUsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBQ0ksT0FBTyxDQUFDLEdBQVc7UUFDdEIsT0FBTztZQUNILFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQztZQUM5QixTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUM7WUFDOUIsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1lBQ25CLEtBQUssRUFBRSxHQUFHO1NBQ2IsQ0FBQztJQUNOLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsV0FBVztRQUNsQixPQUFPLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDdEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUNyRSxJQUFJLENBQUMsY0FBYyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFTSxnQkFBZ0IsQ0FBQyxHQUFXO1FBQy9CLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUM7SUFDbkYsQ0FBQztJQUVEOztPQUVHO0lBQ0ksU0FBUyxDQUFDLEdBQVc7UUFDeEIsT0FBTyxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDbkMsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLGNBQWMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksU0FBUyxDQUFDLEdBQVc7UUFDeEIsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDeEIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNCO1FBRUQsTUFBTSxTQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDN0gsTUFBTSxRQUFRLEdBQUcsU0FBUyxHQUFHLEdBQUcsQ0FBQztRQUVqQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakQsQ0FBQzs7O1lBcklKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsV0FBVztnQkFDckIsdW5CQUFtQzthQUN0Qzs7OzJCQUVJLEtBQUs7NkJBR0wsS0FBSztnQ0FHTCxLQUFLO2tDQUdMLEtBQUs7K0JBR0wsS0FBSztvQ0FHTCxLQUFLO3VCQUdMLEtBQUs7dUJBR0wsS0FBSztnQ0FHTCxLQUFLO3FCQUdMLEtBQUs7bUNBR0wsS0FBSzt5QkFNTCxXQUFXLFNBQUMseUJBQXlCOzRCQU1yQyxXQUFXLFNBQUMsOEJBQThCOzhCQVExQyxXQUFXLFNBQUMsK0JBQStCO3FDQVEzQyxXQUFXLFNBQUMsMkNBQTJDO3FDQVF2RCxXQUFXLFNBQUMsMkNBQTJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgVGVtcGxhdGVSZWYsIEhvc3RCaW5kaW5nIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUaWNrc09yaWVudGF0aW9uLCBUaWNrTGFiZWxzT3JpZW50YXRpb24gfSBmcm9tICcuLi9zbGlkZXIuY29tbW9uJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LXRpY2tzJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RpY2tzLmNvbXBvbmVudC5odG1sJyxcbn0pXG5leHBvcnQgY2xhc3MgSWd4VGlja3NDb21wb25lbnQge1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHByaW1hcnlUaWNrczogbnVtYmVyO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2Vjb25kYXJ5VGlja3M6IG51bWJlcjtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHByaW1hcnlUaWNrTGFiZWxzOiBib29sZWFuO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2Vjb25kYXJ5VGlja0xhYmVsczogYm9vbGVhbjtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRpY2tzT3JpZW50YXRpb246IFRpY2tzT3JpZW50YXRpb247XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0aWNrTGFiZWxzT3JpZW50YXRpb246IFRpY2tMYWJlbHNPcmllbnRhdGlvbjtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIG1heFZhbHVlOiBudW1iZXI7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBtaW5WYWx1ZTogbnVtYmVyO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgbGFiZWxzVmlld0VuYWJsZWQ6IGJvb2xlYW47XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBsYWJlbHM6IEFycmF5PG51bWJlciB8IHN0cmluZyB8IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkPjtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRpY2tMYWJlbFRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXNsaWRlcl9fdGlja3MnKVxuICAgIHB1YmxpYyB0aWNrc0NsYXNzID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1zbGlkZXJfX3RpY2tzLS10b3AnKVxuICAgIHB1YmxpYyBnZXQgdGlja3NUb3BDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlja3NPcmllbnRhdGlvbiA9PT0gVGlja3NPcmllbnRhdGlvbi5Ub3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXNsaWRlcl9fdGlja3MtLXRhbGwnKVxuICAgIHB1YmxpYyBnZXQgaGFzUHJpbWFyeUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmltYXJ5VGlja3MgPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1zbGlkZXJfX3RpY2stbGFiZWxzLS10b3AtYm90dG9tJylcbiAgICBwdWJsaWMgZ2V0IGxhYmVsc1RvcFRvQm90dG9tQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpY2tMYWJlbHNPcmllbnRhdGlvbiA9PT0gVGlja0xhYmVsc09yaWVudGF0aW9uLlRvcFRvQm90dG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1zbGlkZXJfX3RpY2stbGFiZWxzLS1ib3R0b20tdG9wJylcbiAgICBwdWJsaWMgZ2V0IGxhYmVsc0JvdHRvbVRvVG9wQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpY2tMYWJlbHNPcmllbnRhdGlvbiA9PT0gVGlja0xhYmVsc09yaWVudGF0aW9uLkJvdHRvbVRvVG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIGNvbnRleHQgY29ycmVzcG9uZGluZyB0b1xuICAgICAqIHtAbGluayBJZ3hUaWNrTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZX1cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiByZXR1cm4ge1xuICAgICAqICAkaW1wbGljaXQgLy9yZXR1cm5zIHRoZSB2YWx1ZSBwZXIgZWFjaCB0aWNrIGxhYmVsLlxuICAgICAqICBpc1ByaW1lcnkgLy9yZXR1cm5zIGlmIHRoZSB0aWNrIGlzIHByaW1hcnkuXG4gICAgICogIGxhYmVscyAvLyByZXR1cm5zIHRoZSB7QGxpbmsgbGFiZWxzfSBjb2xsZWN0aW9uLlxuICAgICAqICBpbmRleCAvLyByZXR1cm5zIHRoZSBpbmRleCBwZXIgZWFjaCB0aWNrIG9mIHRoZSB3aG9sZSBzZXF1ZW5jZS5cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWR4IHRoZSBpbmRleCBwZXIgZWFjaCB0aWNrIGxhYmVsLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb250ZXh0KGlkeDogbnVtYmVyKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRpbXBsaWNpdDogdGhpcy50aWNrTGFiZWwoaWR4KSxcbiAgICAgICAgICAgIGlzUHJpbWFyeTogdGhpcy5pc1ByaW1hcnkoaWR4KSxcbiAgICAgICAgICAgIGxhYmVsczogdGhpcy5sYWJlbHMsXG4gICAgICAgICAgICBpbmRleDogaWR4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdGlja3NMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaW1hcnlUaWNrcyA+IDAgP1xuICAgICAgICAgICAgICAgICgodGhpcy5wcmltYXJ5VGlja3MgLSAxKSAqIHRoaXMuc2Vjb25kYXJ5VGlja3MpICsgdGhpcy5wcmltYXJ5VGlja3MgOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5VGlja3MgPiAwID8gdGhpcy5zZWNvbmRhcnlUaWNrcyA6IDA7XG4gICAgfVxuXG4gICAgcHVibGljIGhpZGRlblRpY2tMYWJlbHMoaWR4OiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNQcmltYXJ5KGlkeCkgPyB0aGlzLnByaW1hcnlUaWNrTGFiZWxzIDogdGhpcy5zZWNvbmRhcnlUaWNrTGFiZWxzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgaXNQcmltYXJ5KGlkeDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaW1hcnlUaWNrcyA8PSAwID8gZmFsc2UgOlxuICAgICAgICAgICAgaWR4ICUgKHRoaXMuc2Vjb25kYXJ5VGlja3MgKyAxKSA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHRpY2tMYWJlbChpZHg6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5sYWJlbHNWaWV3RW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxzW2lkeF07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsYWJlbFN0ZXAgPSAoTWF0aC5tYXgodGhpcy5taW5WYWx1ZSwgdGhpcy5tYXhWYWx1ZSkgLSBNYXRoLm1pbih0aGlzLm1pblZhbHVlLCB0aGlzLm1heFZhbHVlKSkgLyAodGhpcy50aWNrc0xlbmd0aCAtIDEpO1xuICAgICAgICBjb25zdCBsYWJlbFZhbCA9IGxhYmVsU3RlcCAqIGlkeDtcblxuICAgICAgICByZXR1cm4gKHRoaXMubWluVmFsdWUgKyBsYWJlbFZhbCkudG9GaXhlZCgyKTtcbiAgICB9XG59XG4iXX0=