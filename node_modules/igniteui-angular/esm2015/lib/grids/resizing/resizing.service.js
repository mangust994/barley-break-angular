import { Injectable, NgZone } from '@angular/core';
/**
 * @hidden
 * @internal
 */
export class IgxColumnResizingService {
    constructor(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = null;
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    /**
     * @hidden
     */
    get resizerHeight() {
        let height = this.column.grid.getVisibleContentHeight();
        // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
        let columnHeightMultiplier = 1;
        if (this.column.columnLayoutChild) {
            columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
        }
        if (this.column.level !== 0) {
            height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
        }
        return height;
    }
    /**
     * Returns the minimal possible width to which the column can be resized.
     */
    get restrictResizeMin() {
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const minWidth = this.column.minWidthPx < actualWidth ? this.column.minWidthPx : actualWidth;
        return actualWidth - minWidth;
    }
    /**
     * Returns the maximal possible width to which the column can be resized.
     */
    get restrictResizeMax() {
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const maxWidth = this.column.maxWidthPx;
        if (this.column.maxWidth) {
            return maxWidth - actualWidth;
        }
        else {
            return Number.MAX_SAFE_INTEGER;
        }
    }
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     */
    autosizeColumnOnDblClick() {
        const currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const isPercentageWidth = this.column.width && typeof this.column.width === 'string' && this.column.width.indexOf('%') !== -1;
        let size = this.column.getAutoSize();
        const maxWidth = isPercentageWidth ? this.column.maxWidthPercent : this.column.maxWidthPx;
        const minWidth = isPercentageWidth ? this.column.minWidthPercent : this.column.minWidthPx;
        if (this.column.maxWidth && (parseFloat(size) > maxWidth)) {
            size = isPercentageWidth ? maxWidth + '%' : maxWidth + 'px';
        }
        else if (parseFloat(size) < minWidth) {
            size = isPercentageWidth ? minWidth + '%' : minWidth + 'px';
        }
        this.column.width = size;
        this.zone.run(() => { });
        this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    }
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     */
    resizeColumn(event) {
        this.showResizer = false;
        const diff = event.clientX - this.startResizePos;
        const colWidth = this.column.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        let currentColWidth = parseFloat(colWidth);
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) ? parseFloat(actualWidth) : currentColWidth;
        if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
        }
        else if (isPercentageWidth) {
            this._handlePercentageResize(diff, this.column);
        }
        else {
            this._handlePixelResize(diff, this.column);
        }
        this.zone.run(() => { });
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: isPercentageWidth ? currentColWidth + '%' : currentColWidth + 'px',
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    }
    _handlePixelResize(diff, column) {
        const currentColWidth = parseFloat(column.width);
        const colMinWidth = column.minWidthPx;
        const colMaxWidth = column.maxWidthPx;
        if (currentColWidth + diff < colMinWidth) {
            column.width = colMinWidth + 'px';
        }
        else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
            column.width = colMaxWidth + 'px';
        }
        else {
            column.width = (currentColWidth + diff) + 'px';
        }
    }
    _handlePercentageResize(diff, column) {
        const currentPercentWidth = parseFloat(column.width);
        const gridAvailableSize = column.grid.calcWidth;
        const diffPercentage = (diff / gridAvailableSize) * 100;
        const colMinWidth = column.minWidthPercent;
        const colMaxWidth = column.maxWidthPercent;
        if (currentPercentWidth + diffPercentage < colMinWidth) {
            column.width = colMinWidth + '%';
        }
        else if (colMaxWidth && (currentPercentWidth + diffPercentage > colMaxWidth)) {
            column.width = colMaxWidth + '%';
        }
        else {
            column.width = (currentPercentWidth + diffPercentage) + '%';
        }
    }
    getColMinWidth(column) {
        let currentColWidth = parseFloat(column.width);
        const actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        const actualMinWidth = parseFloat(column.minWidth);
        return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;
    }
    resizeColumnLayoutFor(column, diff) {
        const relativeColumns = column.getResizableColUnderEnd();
        const combinedSpan = relativeColumns.reduce((acc, col) => acc + col.spanUsed, 0);
        // Resize first those who might reach min/max width
        let columnsToResize = [...relativeColumns];
        let updatedDiff = diff;
        let updatedCombinedSpan = combinedSpan;
        let setMinMaxCols = false;
        do {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            let newCombinedSpan = updatedCombinedSpan;
            const newColsToResize = [];
            columnsToResize.forEach((col) => {
                const currentResizeWidth = parseFloat(col.target.calcWidth);
                const resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                const colWidth = col.target.width;
                const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
                const minWidth = col.target.minWidthPx;
                const maxWidth = col.target.maxWidthPx;
                if (currentResizeWidth + resizeScaled < minWidth) {
                    col.target.width = isPercentageWidth ? col.target.minWidthPercent + '%' : minWidth + 'px';
                    updatedDiff += (currentResizeWidth - minWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                    col.target.width = isPercentageWidth ? col.target.maxWidthPercent + '%' : col.target.maxWidthPx + 'px';
                    updatedDiff -= (maxWidth - currentResizeWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else {
                    // Save new ones that can be resized
                    newColsToResize.push(col);
                }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
        } while (setMinMaxCols);
        // Those left that don't reach min/max size resize them normally.
        columnsToResize.forEach((col) => {
            const resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
            const colWidth = col.target.width;
            const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
            if (isPercentageWidth) {
                this._handlePercentageResize(resizeScaled, col.target);
            }
            else {
                this._handlePixelResize(resizeScaled, col.target);
            }
        });
    }
}
IgxColumnResizingService.decorators = [
    { type: Injectable }
];
IgxColumnResizingService.ctorParameters = () => [
    { type: NgZone }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXppbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9yZXNpemluZy9yZXNpemluZy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBR25EOzs7R0FHRztBQUVILE1BQU0sT0FBTyx3QkFBd0I7SUF1QmpDLFlBQW9CLElBQVk7UUFBWixTQUFJLEdBQUosSUFBSSxDQUFRO1FBYmhDOztXQUVHO1FBQ0ksaUJBQVksR0FBVyxJQUFJLENBQUM7UUFDbkM7O1dBRUc7UUFDSSxnQkFBVyxHQUFHLEtBQUssQ0FBQztJQU1TLENBQUM7SUFFckM7O09BRUc7SUFDSCxJQUFJLGFBQWE7UUFDYixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO1FBRXhELG9IQUFvSDtRQUNwSCxJQUFJLHNCQUFzQixHQUFHLENBQUMsQ0FBQztRQUMvQixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUU7WUFDL0Isc0JBQXNCLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1NBQzlGO1FBRUQsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssS0FBSyxDQUFDLEVBQUU7WUFDekIsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLHNCQUFzQixDQUFDO1NBQ3JIO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQUVEOztPQUVH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LE1BQU0sWUFBWSxHQUFHLENBQUMsV0FBVyxHQUFHLG1CQUFtQixDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUM7WUFDckYsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7WUFDbEMsTUFBTSxpQkFBaUIsR0FBRyxRQUFRLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDbkcsSUFBSSxpQkFBaUIsRUFBRTtnQkFDbkIsSUFBSSxDQUFDLHVCQUF1QixDQUFDLFlBQVksRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDMUQ7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFlBQVksRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDckQ7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7OztZQWhPSixVQUFVOzs7WUFQVSxNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hDb2x1bW5Db21wb25lbnQgfSBmcm9tICcuLi9jb2x1bW5zL2NvbHVtbi5jb21wb25lbnQnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqIEBpbnRlcm5hbFxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSWd4Q29sdW1uUmVzaXppbmdTZXJ2aWNlIHtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhcnRSZXNpemVQb3M6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIGNvbHVtbiBpcyBjdXJyZW50bHkgYmVpbmcgcmVzaXplZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgaXNDb2x1bW5SZXNpemluZzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHJlc2l6ZUN1cnNvcjogc3RyaW5nID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHNob3dSZXNpemVyID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbHVtbiBiZWluZyByZXNpemVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb2x1bW46IElneENvbHVtbkNvbXBvbmVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgem9uZTogTmdab25lKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgcmVzaXplckhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5jb2x1bW4uZ3JpZC5nZXRWaXNpYmxlQ29udGVudEhlaWdodCgpO1xuXG4gICAgICAgIC8vIENvbHVtbiBoZWlnaHQgbXVsdGlwbGllciBpbiBjYXNlIHRoZXJlIGFyZSBDb2x1bW4gTGF5b3V0cy4gVGhlIHJlc2l6ZXIgaGVpZ2h0IG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgcm93U3RhcnQuXG4gICAgICAgIGxldCBjb2x1bW5IZWlnaHRNdWx0aXBsaWVyID0gMTtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLmNvbHVtbkxheW91dENoaWxkKSB7XG4gICAgICAgICAgICBjb2x1bW5IZWlnaHRNdWx0aXBsaWVyID0gdGhpcy5jb2x1bW4uZ3JpZC5tdWx0aVJvd0xheW91dFJvd1NpemUgLSB0aGlzLmNvbHVtbi5yb3dTdGFydCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb2x1bW4ubGV2ZWwgIT09IDApIHtcbiAgICAgICAgICAgIGhlaWdodCAtPSB0aGlzLmNvbHVtbi50b3BMZXZlbFBhcmVudC5oZWFkZXJHcm91cC5oZWlnaHQgLSB0aGlzLmNvbHVtbi5oZWFkZXJHcm91cC5oZWlnaHQgKiBjb2x1bW5IZWlnaHRNdWx0aXBsaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtaW5pbWFsIHBvc3NpYmxlIHdpZHRoIHRvIHdoaWNoIHRoZSBjb2x1bW4gY2FuIGJlIHJlc2l6ZWQuXG4gICAgICovXG4gICAgZ2V0IHJlc3RyaWN0UmVzaXplTWluKCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gdGhpcy5jb2x1bW4uaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIGNvbnN0IG1pbldpZHRoID0gdGhpcy5jb2x1bW4ubWluV2lkdGhQeCA8IGFjdHVhbFdpZHRoID8gdGhpcy5jb2x1bW4ubWluV2lkdGhQeCA6IGFjdHVhbFdpZHRoO1xuXG4gICAgICAgIHJldHVybiBhY3R1YWxXaWR0aCAtIG1pbldpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1heGltYWwgcG9zc2libGUgd2lkdGggdG8gd2hpY2ggdGhlIGNvbHVtbiBjYW4gYmUgcmVzaXplZC5cbiAgICAgKi9cbiAgICBnZXQgcmVzdHJpY3RSZXNpemVNYXgoKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgYWN0dWFsV2lkdGggPSB0aGlzLmNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSB0aGlzLmNvbHVtbi5tYXhXaWR0aFB4O1xuICAgICAgICBpZiAodGhpcy5jb2x1bW4ubWF4V2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXhXaWR0aCAtIGFjdHVhbFdpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXV0b3NpemVzIHRoZSBjb2x1bW4gdG8gdGhlIGxvbmdlc3QgY3VycmVudGx5IHZpc2libGUgY2VsbCB2YWx1ZSwgaW5jbHVkaW5nIHRoZSBoZWFkZXIgY2VsbC5cbiAgICAgKiBJZiB0aGUgY29sdW1uIGhhcyBhIHByZWRpZmluZWQgbWF4V2lkdGggYW5kIHRoZSBhdXRvc2l6ZWQgY29sdW1uIHdpZHRoIHdpbGwgYmVjb21lIGJpZ2dlciB0aGFuIGl0LFxuICAgICAqIHRoZW4gdGhlIGNvbHVtbiBpcyBzaXplZCB0byBpdHMgbWF4V2lkdGguXG4gICAgICovXG4gICAgcHVibGljIGF1dG9zaXplQ29sdW1uT25EYmxDbGljaygpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENvbFdpZHRoID0gdGhpcy5jb2x1bW4uaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gdGhpcy5jb2x1bW4ud2lkdGggJiYgdHlwZW9mIHRoaXMuY29sdW1uLndpZHRoID09PSAnc3RyaW5nJyAmJiB0aGlzLmNvbHVtbi53aWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuY29sdW1uLmdldEF1dG9TaXplKCk7XG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gaXNQZXJjZW50YWdlV2lkdGggPyB0aGlzLmNvbHVtbi5tYXhXaWR0aFBlcmNlbnQgOiB0aGlzLmNvbHVtbi5tYXhXaWR0aFB4O1xuICAgICAgICBjb25zdCBtaW5XaWR0aCA9IGlzUGVyY2VudGFnZVdpZHRoID8gdGhpcy5jb2x1bW4ubWluV2lkdGhQZXJjZW50IDogdGhpcy5jb2x1bW4ubWluV2lkdGhQeDtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLm1heFdpZHRoICYmIChwYXJzZUZsb2F0KHNpemUpID4gbWF4V2lkdGgpKSB7XG4gICAgICAgICAgICBzaXplID0gaXNQZXJjZW50YWdlV2lkdGggPyBtYXhXaWR0aCArICclJyA6IG1heFdpZHRoICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIGlmIChwYXJzZUZsb2F0KHNpemUpIDwgbWluV2lkdGgpIHtcbiAgICAgICAgICAgIHNpemUgPSBpc1BlcmNlbnRhZ2VXaWR0aCA/IG1pbldpZHRoICsgJyUnIDogbWluV2lkdGggKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sdW1uLndpZHRoID0gc2l6ZTtcblxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHt9KTtcblxuICAgICAgICB0aGlzLmNvbHVtbi5ncmlkLm9uQ29sdW1uUmVzaXplZC5lbWl0KHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICBwcmV2V2lkdGg6IGN1cnJlbnRDb2xXaWR0aC50b1N0cmluZygpLFxuICAgICAgICAgICAgbmV3V2lkdGg6IHRoaXMuY29sdW1uLndpZHRoXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGNvbHVtbiByZWdhcmlkbmcgdG8gdGhlIGNvbHVtbiBtaW5XaWR0aCBhbmQgbWF4V2lkdGguXG4gICAgICovXG4gICAgcHVibGljIHJlc2l6ZUNvbHVtbihldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLnNob3dSZXNpemVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBldmVudC5jbGllbnRYIC0gdGhpcy5zdGFydFJlc2l6ZVBvcztcblxuICAgICAgICBjb25zdCBjb2xXaWR0aCA9IHRoaXMuY29sdW1uLndpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IGNvbFdpZHRoICYmIHR5cGVvZiBjb2xXaWR0aCA9PT0gJ3N0cmluZycgJiYgY29sV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IHBhcnNlRmxvYXQoY29sV2lkdGgpO1xuICAgICAgICBjb25zdCBhY3R1YWxXaWR0aCA9IHRoaXMuY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBOdW1iZXIuaXNOYU4oY3VycmVudENvbFdpZHRoKSA/IHBhcnNlRmxvYXQoYWN0dWFsV2lkdGgpIDogY3VycmVudENvbFdpZHRoO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5ncmlkLmhhc0NvbHVtbkxheW91dHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplQ29sdW1uTGF5b3V0Rm9yKHRoaXMuY29sdW1uLCBkaWZmKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BlcmNlbnRhZ2VXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlUGVyY2VudGFnZVJlc2l6ZShkaWZmLCB0aGlzLmNvbHVtbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVQaXhlbFJlc2l6ZShkaWZmLCB0aGlzLmNvbHVtbik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge30pO1xuXG4gICAgICAgIGlmIChjdXJyZW50Q29sV2lkdGggIT09IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ud2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi5ncmlkLm9uQ29sdW1uUmVzaXplZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgIHByZXZXaWR0aDogaXNQZXJjZW50YWdlV2lkdGggPyBjdXJyZW50Q29sV2lkdGggKyAnJScgOiBjdXJyZW50Q29sV2lkdGggKyAncHgnLFxuICAgICAgICAgICAgICAgIG5ld1dpZHRoOiB0aGlzLmNvbHVtbi53aWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzQ29sdW1uUmVzaXppbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2hhbmRsZVBpeGVsUmVzaXplKGRpZmY6IG51bWJlciwgY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENvbFdpZHRoID0gcGFyc2VGbG9hdChjb2x1bW4ud2lkdGgpO1xuICAgICAgICBjb25zdCBjb2xNaW5XaWR0aCA9IGNvbHVtbi5taW5XaWR0aFB4O1xuICAgICAgICBjb25zdCBjb2xNYXhXaWR0aCA9IGNvbHVtbi5tYXhXaWR0aFB4O1xuICAgICAgICBpZiAoY3VycmVudENvbFdpZHRoICsgZGlmZiA8IGNvbE1pbldpZHRoKSB7XG4gICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBjb2xNaW5XaWR0aCArICdweCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29sTWF4V2lkdGggJiYgKGN1cnJlbnRDb2xXaWR0aCArIGRpZmYgPiBjb2xNYXhXaWR0aCkpIHtcbiAgICAgICAgICAgIGNvbHVtbi53aWR0aCA9IGNvbE1heFdpZHRoICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHVtbi53aWR0aCA9IChjdXJyZW50Q29sV2lkdGggKyBkaWZmKSArICdweCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2hhbmRsZVBlcmNlbnRhZ2VSZXNpemUoZGlmZjogbnVtYmVyLCBjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBjdXJyZW50UGVyY2VudFdpZHRoID0gcGFyc2VGbG9hdChjb2x1bW4ud2lkdGgpO1xuICAgICAgICBjb25zdCBncmlkQXZhaWxhYmxlU2l6ZSA9IGNvbHVtbi5ncmlkLmNhbGNXaWR0aDtcblxuICAgICAgICBjb25zdCBkaWZmUGVyY2VudGFnZSA9IChkaWZmIC8gZ3JpZEF2YWlsYWJsZVNpemUpICogMTAwO1xuICAgICAgICBjb25zdCBjb2xNaW5XaWR0aCA9IGNvbHVtbi5taW5XaWR0aFBlcmNlbnQ7XG4gICAgICAgIGNvbnN0IGNvbE1heFdpZHRoID0gIGNvbHVtbi5tYXhXaWR0aFBlcmNlbnQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQZXJjZW50V2lkdGggKyBkaWZmUGVyY2VudGFnZSA8IGNvbE1pbldpZHRoKSB7XG4gICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBjb2xNaW5XaWR0aCArICclJztcbiAgICAgICAgfSBlbHNlIGlmIChjb2xNYXhXaWR0aCAmJiAoY3VycmVudFBlcmNlbnRXaWR0aCArIGRpZmZQZXJjZW50YWdlID4gY29sTWF4V2lkdGgpKSB7XG4gICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBjb2xNYXhXaWR0aCArICclJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHVtbi53aWR0aCA9IChjdXJyZW50UGVyY2VudFdpZHRoICsgZGlmZlBlcmNlbnRhZ2UpICsgJyUnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldENvbE1pbldpZHRoKGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50KSB7XG4gICAgICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSBwYXJzZUZsb2F0KGNvbHVtbi53aWR0aCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBOdW1iZXIuaXNOYU4oY3VycmVudENvbFdpZHRoKSB8fCAoY3VycmVudENvbFdpZHRoIDwgYWN0dWFsV2lkdGgpID8gYWN0dWFsV2lkdGggOiBjdXJyZW50Q29sV2lkdGg7XG5cbiAgICAgICAgY29uc3QgYWN0dWFsTWluV2lkdGggPSBwYXJzZUZsb2F0KGNvbHVtbi5taW5XaWR0aCk7XG4gICAgICAgIHJldHVybiBhY3R1YWxNaW5XaWR0aCA8IGN1cnJlbnRDb2xXaWR0aCA/IGFjdHVhbE1pbldpZHRoIDogY3VycmVudENvbFdpZHRoO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCByZXNpemVDb2x1bW5MYXlvdXRGb3IoY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQsIGRpZmY6IG51bWJlcikge1xuICAgICAgICBjb25zdCByZWxhdGl2ZUNvbHVtbnMgPSBjb2x1bW4uZ2V0UmVzaXphYmxlQ29sVW5kZXJFbmQoKTtcbiAgICAgICAgY29uc3QgY29tYmluZWRTcGFuID0gcmVsYXRpdmVDb2x1bW5zLnJlZHVjZSgoYWNjLCBjb2wpID0+ICBhY2MgKyBjb2wuc3BhblVzZWQsIDApO1xuXG4gICAgICAgIC8vIFJlc2l6ZSBmaXJzdCB0aG9zZSB3aG8gbWlnaHQgcmVhY2ggbWluL21heCB3aWR0aFxuICAgICAgICBsZXQgY29sdW1uc1RvUmVzaXplID0gWy4uLnJlbGF0aXZlQ29sdW1uc107XG4gICAgICAgIGxldCB1cGRhdGVkRGlmZiA9IGRpZmY7XG4gICAgICAgIGxldCB1cGRhdGVkQ29tYmluZWRTcGFuID0gY29tYmluZWRTcGFuO1xuICAgICAgICBsZXQgc2V0TWluTWF4Q29scyA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBDeWNsZSB0aGVtIHVudGlsIHRoZXJlIGFyZSBub3Qgb25lcyB0aGF0IHJlYWNoIG1pbi9tYXggc2l6ZSwgYmVjYXVzZSB0aGUgZGlmZiBhY2N1bXVsYXRlcyBhZnRlciBlYWNoIGN5Y2xlLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHdlIGNhbiBoYXZlIGF0IGZpcnN0IDIgY29scyByZWFjaGluZyBtaW4gd2lkdGggYW5kIHRoZW4gYWZ0ZXJcbiAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRpbmcgdGhlIGRpZmYgdGhlcmUgbWlnaHQgYmUgMSBtb3JlIHRoYXQgcmVhY2hlcyBtaW4gd2lkdGguXG4gICAgICAgICAgICBzZXRNaW5NYXhDb2xzID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbmV3Q29tYmluZWRTcGFuID0gdXBkYXRlZENvbWJpbmVkU3BhbjtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbHNUb1Jlc2l6ZSA9IFtdO1xuICAgICAgICAgICAgY29sdW1uc1RvUmVzaXplLmZvckVhY2goKGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSZXNpemVXaWR0aCA9IHBhcnNlRmxvYXQoY29sLnRhcmdldC5jYWxjV2lkdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc2l6ZVNjYWxlZCA9IChkaWZmIC8gdXBkYXRlZENvbWJpbmVkU3BhbikgKiBjb2wudGFyZ2V0LmdyaWRDb2x1bW5TcGFuO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbFdpZHRoID0gY29sLnRhcmdldC53aWR0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IGNvbFdpZHRoICYmIHR5cGVvZiBjb2xXaWR0aCA9PT0gJ3N0cmluZycgJiYgY29sV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1pbldpZHRoID0gY29sLnRhcmdldC5taW5XaWR0aFB4O1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFdpZHRoID0gY29sLnRhcmdldC5tYXhXaWR0aFB4O1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmVzaXplV2lkdGggKyByZXNpemVTY2FsZWQgPCBtaW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2wudGFyZ2V0LndpZHRoID0gaXNQZXJjZW50YWdlV2lkdGggPyBjb2wudGFyZ2V0Lm1pbldpZHRoUGVyY2VudCArICclJyA6IG1pbldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZERpZmYgKz0gKGN1cnJlbnRSZXNpemVXaWR0aCAtIG1pbldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29tYmluZWRTcGFuIC09IGNvbC5zcGFuVXNlZDtcbiAgICAgICAgICAgICAgICAgICAgc2V0TWluTWF4Q29scyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXhXaWR0aCAmJiAoY3VycmVudFJlc2l6ZVdpZHRoICsgcmVzaXplU2NhbGVkID4gbWF4V2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbC50YXJnZXQud2lkdGggPSBpc1BlcmNlbnRhZ2VXaWR0aCA/IGNvbC50YXJnZXQubWF4V2lkdGhQZXJjZW50ICsgJyUnIDogY29sLnRhcmdldC5tYXhXaWR0aFB4ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZERpZmYgLT0gKG1heFdpZHRoIC0gY3VycmVudFJlc2l6ZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29tYmluZWRTcGFuIC09IGNvbC5zcGFuVXNlZDtcbiAgICAgICAgICAgICAgICAgICAgc2V0TWluTWF4Q29scyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBuZXcgb25lcyB0aGF0IGNhbiBiZSByZXNpemVkXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbHNUb1Jlc2l6ZS5wdXNoKGNvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHVwZGF0ZWRDb21iaW5lZFNwYW4gPSBuZXdDb21iaW5lZFNwYW47XG4gICAgICAgICAgICBjb2x1bW5zVG9SZXNpemUgPSBuZXdDb2xzVG9SZXNpemU7XG4gICAgICAgIH0gd2hpbGUgKHNldE1pbk1heENvbHMpO1xuXG4gICAgICAgIC8vIFRob3NlIGxlZnQgdGhhdCBkb24ndCByZWFjaCBtaW4vbWF4IHNpemUgcmVzaXplIHRoZW0gbm9ybWFsbHkuXG4gICAgICAgIGNvbHVtbnNUb1Jlc2l6ZS5mb3JFYWNoKChjb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZVNjYWxlZCA9ICh1cGRhdGVkRGlmZiAvIHVwZGF0ZWRDb21iaW5lZFNwYW4pICogY29sLnRhcmdldC5ncmlkQ29sdW1uU3BhbjtcbiAgICAgICAgICAgIGNvbnN0IGNvbFdpZHRoID0gY29sLnRhcmdldC53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gY29sV2lkdGggJiYgdHlwZW9mIGNvbFdpZHRoID09PSAnc3RyaW5nJyAmJiBjb2xXaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuICAgICAgICAgICAgaWYgKGlzUGVyY2VudGFnZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlUGVyY2VudGFnZVJlc2l6ZShyZXNpemVTY2FsZWQsIGNvbC50YXJnZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVQaXhlbFJlc2l6ZShyZXNpemVTY2FsZWQsIGNvbC50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=