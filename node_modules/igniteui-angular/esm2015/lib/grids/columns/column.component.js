import { __decorate } from "tslib";
import { Subject } from 'rxjs';
import { ChangeDetectorRef, ChangeDetectionStrategy, Component, ContentChild, ContentChildren, Input, Output, EventEmitter, } from '@angular/core';
import { notifyChanges } from '../watch-changes';
import { WatchColumnChanges } from '../watch-changes';
import { DataType } from '../../data-operations/data-util';
import { IgxBooleanFilteringOperand, IgxNumberFilteringOperand, IgxDateFilteringOperand, IgxStringFilteringOperand } from '../../data-operations/filtering-condition';
import { DefaultSortingStrategy } from '../../data-operations/sorting-strategy';
import { DisplayDensity } from '../../core/displayDensity';
import { IgxRowDirective } from '../row.directive';
import { GridBaseAPIService } from '../api.service';
import { getNodeSizeViaRange } from '../../core/utils';
import { IgxSummaryOperand, IgxNumberSummaryOperand, IgxDateSummaryOperand, IgxCurrencySummaryOperand, IgxPercentSummaryOperand } from '../summaries/grid-summary';
import { IgxCellTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellEditorTemplateDirective, IgxCollapsibleIndicatorTemplateDirective, IgxFilterCellTemplateDirective } from './templates.directive';
import { DropPosition } from '../moving/moving.service';
const DEFAULT_DATE_FORMAT = 'mediumDate';
const DEFAULT_DIGITS_INFO = '1.0-3';
/**
 * **Ignite UI for Angular Column** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid#columns-configuration)
 *
 * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
 * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
 * the column using `ng-template` which will be used for all cells within the column.
 */
export class IgxColumnComponent {
    constructor(gridAPI, cdr) {
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        /**
         * Sets/gets the `header` value.
         * ```typescript
         * let columnHeader = this.column.header;
         * ```
         * ```html
         * <igx-column [header] = "'ID'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.header = '';
        /**
         * Sets/gets the `title` value.
         * ```typescript
         * let title = this.column.title;
         * ```
         * ```html
         * <igx-column [title] = "'Some column tooltip'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.title = '';
        /**
         * Sets/gets whether the column is sortable.
         * Default value is `false`.
         * ```typescript
         * let isSortable = this.column.sortable;
         * ```
         * ```html
         * <igx-column [sortable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.sortable = false;
        /**
         * Sets/gets whether the column is groupable.
         * Default value is `false`.
         * ```typescript
         * let isGroupable = this.column.groupable;
         * ```
         * ```html
         * <igx-column [groupable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.groupable = false;
        /**
         * Sets/gets whether the column is filterable.
         * Default value is `true`.
         * ```typescript
         * let isFilterable = this.column.filterable;
         * ```
         * ```html
         * <igx-column [filterable] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.filterable = true;
        /**
         * Sets/gets whether the column is resizable.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.resizable = false;
        /**
         * @hidden
         */
        this.hiddenChange = new EventEmitter();
        /** @hidden */
        this.expandedChange = new EventEmitter();
        /** @hidden */
        this.collapsibleChange = new EventEmitter();
        /** @hidden */
        this.visibleWhenCollapsedChange = new EventEmitter();
        /** @hidden */
        this.onColumnChange = new EventEmitter();
        /**
         * Gets whether the hiding is disabled.
         * ```typescript
         * let isHidingDisabled =  this.column.disableHiding;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.disableHiding = false;
        /**
         * Gets whether the pinning is disabled.
         * ```typescript
         * let isPinningDisabled =  this.column.disablePinning;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.disablePinning = false;
        /**
         * Sets/gets whether the column is movable.
         * Default value is `false`.
         * ```typescript
         * let isMovable = this.column.movable;
         * ```
         * ```html
         * <igx-column [movable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.movable = false;
        /**
         * Sets/gets the class selector of the column header.
         * ```typescript
         * let columnHeaderClass = this.column.headerClasses;
         * ```
         * ```html
         * <igx-column [headerClasses] = "'column-header'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerClasses = '';
        /**
         * Sets/gets the class selector of the column group header.
         * ```typescript
         * let columnHeaderClass = this.column.headerGroupClasses;
         * ```
         * ```html
         * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerGroupClasses = '';
        /**
         * Sets conditional style properties on the column cells.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * As with `cellClasses` it accepts a callback function.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') : 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [cellStyles]="styles"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.cellStyles = null;
        /**
         * Sets/gets whether the column filtering should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let filteringIgnoreCase = this.column.filteringIgnoreCase;
         * ```
         * ```html
         * <igx-column [filteringIgnoreCase] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.filteringIgnoreCase = true;
        /**
         * Sets/gets whether the column sorting should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let sortingIgnoreCase = this.column.sortingIgnoreCase;
         * ```
         * ```html
         * <igx-column [sortingIgnoreCase] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.sortingIgnoreCase = true;
        /**
         * Sets/gets whether the column is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.column.searchable';
         * ```
         * ```html
         *  <igx-column [searchable] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.searchable = true;
        /**
         * Sets/gets the data type of the column values.
         * Default value is `string`.
         * ```typescript
         * let columnDataType = this.column.dataType;
         * ```
         * ```html
         * <igx-column [dataType] = "'number'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.dataType = DataType.String;
        /**
         * @hidden
         */
        this.widthChange = new EventEmitter();
        /**
         * @hidden
         */
        this.pinnedChange = new EventEmitter();
        /**
         * Sets/gets the parent column.
         * ```typescript
         * let parentColumn = this.column.parent;
         * ```
         * ```typescript
         * this.column.parent = higherLevelColumn;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.parent = null;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        /**
         * @hidden
         */
        this._applySelectableClass = false;
        this._vIndex = NaN;
        /**
         * @hidden
         */
        this._pinned = false;
        /**
         * @hidden
         */
        this._summaries = null;
        /**
         * @hidden
         */
        this._filters = null;
        /**
         * @hidden
         */
        this._sortStrategy = DefaultSortingStrategy.instance();
        /**
         * @hidden
         */
        this._hidden = false;
        /**
         * @hidden
         */
        this._disablePinning = false;
        /**
         * @hidden
         */
        this._defaultMinWidth = '';
        /**
         * @hidden
         */
        this._hasSummary = false;
        /**
         * @hidden
         */
        this._collapsible = false;
        /**
         * @hidden
         */
        this._expanded = true;
        /**
         * @hidden
         */
        this._selectable = true;
        this._calcWidth = null;
        this._columnPipeArgs = { format: DEFAULT_DATE_FORMAT, digitsInfo: DEFAULT_DIGITS_INFO };
    }
    /**
     * Sets/gets the `field` value.
     * ```typescript
     * let columnField = this.column.field;
     * ```
     * ```html
     * <igx-column [field] = "'ID'"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set field(value) {
        this._field = value;
        this.hasNestedPath = value === null || value === void 0 ? void 0 : value.includes('.');
    }
    get field() {
        return this._field;
    }
    /**
     * Returns if the column is selectable.
     * ```typescript
     * let columnSelectable = this.column.selectable;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get selectable() {
        return this._selectable;
    }
    /**
     * Sets if the column is selectable.
     * Default value is `true`.
     * ```html
     * <igx-column [selectable] = "false"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set selectable(value) {
        this._selectable = value;
    }
    /**
     * Gets whether the column is editable.
     * Default value is `false`.
     * ```typescript
     * let isEditable = this.column.editable;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get editable() {
        // Updating the primary key when grid has transactions (incl. row edit)
        // should not be allowed, as that can corrupt transaction state.
        const rowEditable = this.grid && this.grid.rowEditable;
        const hasTransactions = this.grid && this.grid.transactions.enabled;
        if (this.isPrimaryColumn && (rowEditable || hasTransactions)) {
            return false;
        }
        if (this._editable !== undefined) {
            return this._editable;
        }
        else {
            return rowEditable;
        }
    }
    /**
     * Sets whether the column is editable.
     * ```typescript
     * this.column.editable = true;
     * ```
     * ```html
     * <igx-column [editable] = "true"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set editable(editable) {
        this._editable = editable;
    }
    /**
     * Gets a value indicating whether the summary for the column is enabled.
     * ```typescript
     * let hasSummary = this.column.hasSummary;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get hasSummary() {
        return this._hasSummary;
    }
    /**
     * Sets a value indicating whether the summary for the column is enabled.
     * Default value is `false`.
     * ```html
     * <igx-column [hasSummary] = "true"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set hasSummary(value) {
        this._hasSummary = value;
        if (this.grid) {
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets whether the column is hidden.
     * ```typescript
     * let isHidden = this.column.hidden;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column hidden property.
     * Default value is `false`.
     * ```html
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(hidden)] = "model.isHidden"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set hidden(value) {
        if (this._hidden !== value) {
            this._hidden = value;
            this.hiddenChange.emit(this._hidden);
            if (this.columnLayoutChild && this.parent.hidden !== value) {
                this.parent.hidden = value;
                return;
            }
            if (this.grid) {
                this.grid.endEdit(false);
                this.grid.summaryService.resetSummaryHeight();
                this.grid.filteringService.refreshExpressions();
                this.grid.filteringService.hideFilteringRowOnColumnVisibilityChange(this);
                this.grid.notifyChanges();
            }
        }
    }
    /**
     * Returns if the column is selected.
     * ```typescript
     * let isSelected = this.column.selected;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get selected() {
        return this.grid.selectionService.isColumnSelected(this.field);
    }
    /**
     * Select/deselect a column.
     * Default value is `false`.
     * ```typescript
     * this.column.selected = true;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set selected(value) {
        if (this.selectable && value !== this.selected) {
            if (value) {
                this.grid.selectionService.selectColumnsWithNoEvent([this.field]);
            }
            else {
                this.grid.selectionService.deselectColumnsWithNoEvent([this.field]);
            }
            this.grid.notifyChanges();
        }
    }
    /**
     * Gets the `width` of the column.
     * ```typescript
     * let columnWidth = this.column.width;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get width() {
        return this.widthSetByUser ? this._width : this.defaultWidth;
    }
    /**
     * Sets the `width` of the column.
     * ```html
     * <igx-column [width] = "'25%'"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(width)]="model.columns[0].width"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set width(value) {
        if (value) {
            this._calcWidth = null;
            this.calcPixelWidth = NaN;
            this.widthSetByUser = true;
            // width could be passed as number from the template
            // host bindings are not px affixed so we need to ensure we affix simple number strings
            if (typeof (value) === 'number' || value.match(/^[0-9]*$/)) {
                value = value + 'px';
            }
            this._width = value;
            if (this.grid) {
                this.cacheCalcWidth();
            }
            this.widthChange.emit(this._width);
        }
    }
    /**
     * @hidden
     */
    get calcWidth() {
        return this.getCalcWidth();
    }
    /**
     * @hidden
     */
    get maxWidthPx() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.maxWidth) / 100 * gridAvailableSize : parseFloat(this.maxWidth);
    }
    /**
     * @hidden
     */
    get maxWidthPercent() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.maxWidth) : parseFloat(this.maxWidth) / gridAvailableSize * 100;
    }
    /**
     * @hidden
     */
    get minWidthPx() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.minWidth) / 100 * gridAvailableSize : parseFloat(this.minWidth);
    }
    /**
     * @hidden
     */
    get minWidthPercent() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.minWidth) : parseFloat(this.minWidth) / gridAvailableSize * 100;
    }
    /**
     * Sets/gets the minimum `width` of the column.
     * Default value is `88`;
     * ```typescript
     * let columnMinWidth = this.column.minWidth;
     * ```
     * ```html
     * <igx-column [minWidth] = "'100px'"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set minWidth(value) {
        const minVal = parseFloat(value);
        if (Number.isNaN(minVal)) {
            return;
        }
        this._defaultMinWidth = value;
    }
    get minWidth() {
        return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;
    }
    /**
     * Gets the column index.
     * ```typescript
     * let columnIndex = this.column.index;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get index() {
        return this.grid.columns.indexOf(this);
    }
    /**
     * Gets whether the column is `pinned`.
     * ```typescript
     * let isPinned = this.column.pinned;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get pinned() {
        return this._pinned;
    }
    /**
     * Sets whether the column is pinned.
     * Default value is `false`.
     * ```html
     * <igx-column [pinned] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(pinned)] = "model.columns[0].isPinned"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set pinned(value) {
        if (this._pinned !== value) {
            if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {
                if (value) {
                    this.pin();
                }
                else {
                    this.unpin();
                }
                return;
            }
            /* No grid/width available at initialization. `initPinning` in the grid
               will re-init the group (if present)
            */
            this._pinned = value;
            this.pinnedChange.emit(this._pinned);
        }
    }
    /**
     * Gets the column `summaries`.
     * ```typescript
     * let columnSummaries = this.column.summaries;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column `summaries`.
     * ```typescript
     * this.column.summaries = IgxNumberSummaryOperand;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set summaries(classRef) {
        this._summaries = new classRef();
        if (this.grid) {
            this.grid.summaryService.removeSummariesCachePerColumn(this.field);
            this.grid._summaryPipeTrigger++;
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets the column `filters`.
     * ```typescript
     * let columnFilters = this.column.filters'
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column `filters`.
     * ```typescript
     * this.column.filters = IgxBooleanFilteringOperand.instance().
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set filters(instance) {
        this._filters = instance;
    }
    /**
     * Gets the column `sortStrategy`.
     * ```typescript
     * let sortStrategy = this.column.sortStrategy
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get sortStrategy() {
        return this._sortStrategy;
    }
    /**
     * Sets the column `sortStrategy`.
     * ```typescript
     * this.column.sortStrategy = new CustomSortingStrategy().
     * class CustomSortingStrategy extends SortingStrategy {...}
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set sortStrategy(classRef) {
        this._sortStrategy = classRef;
    }
    /**
     * Gets the function that compares values for grouping.
     * ```typescript
     * let groupingComparer = this.column.groupingComparer'
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get groupingComparer() {
        return this._groupingComparer;
    }
    /**
     * Sets a custom function to compare values for grouping.
     * Subsequent values in the sorted data that the function returns 0 for are grouped.
     * ```typescript
     * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set groupingComparer(funcRef) {
        this._groupingComparer = funcRef;
    }
    /**
     * Gets the default minimum `width` of the column.
     * ```typescript
     * let defaultMinWidth =  this.column.defaultMinWidth;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get defaultMinWidth() {
        if (!this.grid) {
            return '80';
        }
        switch (this.grid.displayDensity) {
            case DisplayDensity.cosy:
                return '64';
            case DisplayDensity.compact:
                return '56';
            default:
                return '80';
        }
    }
    /**
     * The reference to the `igx-grid` owner.
     * ```typescript
     * let gridComponent = this.column.grid;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Returns a reference to the `bodyTemplate`.
     * ```typescript
     * let bodyTemplate = this.column.bodyTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * Sets the body template.
     * ```html
     * <ng-template #bodyTemplate igxCell let-val>
     *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
     *       <span> {{val}} </span>
     *    </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'bodyTemplate'", {read: TemplateRef })
     * public bodyTemplate: TemplateRef<any>;
     * this.column.bodyTemplate = this.bodyTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set bodyTemplate(template) {
        this._bodyTemplate = template;
    }
    /**
     * Returns a reference to the header template.
     * ```typescript
     * let headerTemplate = this.column.headerTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get headerTemplate() {
        return this._headerTemplate;
    }
    /**
     * Sets the header template.
     * Note that the column header height is fixed and any content bigger than it will be cut off.
     * ```html
     * <ng-template #headerTemplate>
     *   <div style = "background-color:black" (click) = "changeColor(val)">
     *       <span style="color:red" >{{column.field}}</span>
     *   </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'headerTemplate'", {read: TemplateRef })
     * public headerTemplate: TemplateRef<any>;
     * this.column.headerTemplate = this.headerTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set headerTemplate(template) {
        this._headerTemplate = template;
    }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.column.inlineEditorTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * Sets the inline editor template.
     * ```html
     * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
     *     <input type="string" [(ngModel)]="cell.value"/>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
     * public inlineEditorTemplate: TemplateRef<any>;
     * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set inlineEditorTemplate(template) {
        this._inlineEditorTemplate = template;
    }
    /**
     * Returns a reference to the `filterCellTemplate`.
     * ```typescript
     * let filterCellTemplate = this.column.filterCellTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filterCellTemplate() {
        return this._filterCellTemplate;
    }
    /**
     * Sets the quick filter template.
     * ```html
     * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
     *    <input (input)="onInput()">
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'filterCellTemplate'", {read: TemplateRef })
     * public filterCellTemplate: TemplateRef<any>;
     * this.column.filterCellTemplate = this.filterCellTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set filterCellTemplate(template) {
        this._filterCellTemplate = template;
    }
    /**
     * Gets the cells of the column.
     * ```typescript
     * let columnCells =  this.column.cells;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get cells() {
        return this.grid.rowList.filter((row) => row instanceof IgxRowDirective)
            .map((row) => {
            if (row.cells) {
                return row.cells.filter((cell) => cell.columnIndex === this.index);
            }
        }).reduce((a, b) => a.concat(b), []);
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => !c.columnGroup);
        const pinnedColumns = this.grid.pinnedColumns.filter(c => !c.columnGroup);
        let col = this;
        let vIndex = -1;
        if (this.columnGroup) {
            col = this.allChildren.filter(c => !c.columnGroup && !c.hidden)[0];
        }
        if (this.columnLayoutChild) {
            return this.parent.childrenVisibleIndexes.find(x => x.column === this).index;
        }
        if (!this.pinned) {
            const indexInCollection = unpinnedColumns.indexOf(col);
            vIndex = indexInCollection === -1 ?
                -1 :
                (this.grid.isPinningToStart ?
                    pinnedColumns.length + indexInCollection :
                    indexInCollection);
        }
        else {
            const indexInCollection = pinnedColumns.indexOf(col);
            vIndex = this.grid.isPinningToStart ?
                indexInCollection :
                unpinnedColumns.length + indexInCollection;
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnGroup() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnLayout() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnLayoutChild =  this.column.columnLayoutChild;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnLayoutChild() {
        return this.parent && this.parent.columnLayout;
    }
    /**
     * Returns the children columns collection.
     * Returns an empty array if the column does not contain children columns.
     * ```typescript
     * let childrenColumns =  this.column.allChildren;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get allChildren() {
        return [];
    }
    /**
     * Returns the level of the column in a column group.
     * Returns `0` if the column doesn't have a `parent`.
     * ```typescript
     * let columnLevel =  this.column.level;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get level() {
        let ptr = this.parent;
        let lvl = 0;
        while (ptr) {
            lvl++;
            ptr = ptr.parent;
        }
        return lvl;
    }
    get isLastPinned() {
        return this.grid.isPinningToStart &&
            this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
    }
    get isFirstPinned() {
        const pinnedCols = this.grid.pinnedColumns.filter(x => !x.columnGroup);
        return !this.grid.isPinningToStart && pinnedCols[0] === this;
    }
    get rightPinnedOffset() {
        return this.pinned && !this.grid.isPinningToStart ?
            -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' :
            null;
    }
    get gridRowSpan() {
        return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
    }
    get gridColumnSpan() {
        return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
    }
    /**
     * Indicates whether the column will be visible when its parent is collapsed.
     * ```html
     * <igx-column-group>
     *   <igx-column [visibleWhenCollapsed]="true"></igx-column>
     * </igx-column-group>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set visibleWhenCollapsed(value) {
        this._visibleWhenCollapsed = value;
        this.visibleWhenCollapsedChange.emit(this._visibleWhenCollapsed);
        if (this.parent) {
            this.parent.setExpandCollapseState();
        }
    }
    get visibleWhenCollapsed() {
        return this._visibleWhenCollapsed;
    }
    /**
     * @remarks
     * Pass optional parameters for DatePipe and/or DecimalPipe to format the display value for date and numeric columns.
     * Accepts an `IColumnPipeArgs` object with any of the `format`, `timezone` and `digitsInfo` properties.
     * For more details see https://angular.io/api/common/DatePipe and https://angular.io/api/common/DecimalPipe
     * @example
     * ```typescript
     * const pipeArgs: IColumnPipeArgs = {
     *      format: 'longDate',
     *      timezone: 'UTC',
     *      digitsInfo: '1.1-2'
     * }
     * ```
     * ```html
     * <igx-column dataType="date" [pipeArgs]="pipeArgs"></igx-column>
     * <igx-column dataType="number" [pipeArgs]="pipeArgs"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set pipeArgs(value) {
        this._columnPipeArgs = Object.assign(this._columnPipeArgs, value);
        this.grid.summaryService.clearSummaryCache();
        this.grid._pipeTrigger++;
        this.grid.notifyChanges();
    }
    get pipeArgs() {
        return this._columnPipeArgs;
    }
    /**
     * @hidden
     * @internal
     */
    get collapsible() {
        return false;
    }
    set collapsible(_value) { }
    /**
     * @hidden
     * @internal
     */
    get expanded() {
        return true;
    }
    set expanded(_value) { }
    /**
     * Returns the filteringExpressionsTree of the column.
     * ```typescript
     * let tree =  this.column.filteringExpressionsTree;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filteringExpressionsTree() {
        return this.grid.filteringExpressionsTree.find(this.field);
    }
    /**
     * @hidden
     */
    get isPrimaryColumn() {
        return this.field !== undefined && this.grid !== undefined && this.field === this.grid.primaryKey;
    }
    /**
     * @hidden
     * @internal
     */
    resetCaches() {
        this._vIndex = NaN;
        if (this.grid) {
            this.cacheCalcWidth();
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.cellTemplate) {
            this._bodyTemplate = this.cellTemplate.template;
        }
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        if (this.editorTemplate) {
            this._inlineEditorTemplate = this.editorTemplate.template;
        }
        if (this.filterCellTemplateDirective) {
            this._filterCellTemplate = this.filterCellTemplateDirective.template;
        }
        if (!this.summaries) {
            switch (this.dataType) {
                case DataType.String:
                case DataType.Boolean:
                    this.summaries = IgxSummaryOperand;
                    break;
                case DataType.Number:
                    this.summaries = IgxNumberSummaryOperand;
                    break;
                case DataType.Date:
                    this.summaries = IgxDateSummaryOperand;
                    break;
                case DataType.Currency:
                    this.summaries = IgxCurrencySummaryOperand;
                    break;
                case DataType.Percent:
                    this.summaries = IgxPercentSummaryOperand;
                    break;
                default:
                    this.summaries = IgxSummaryOperand;
                    break;
            }
        }
        if (!this.filters) {
            switch (this.dataType) {
                case DataType.Boolean:
                    this.filters = IgxBooleanFilteringOperand.instance();
                    break;
                case DataType.Number:
                case DataType.Currency:
                case DataType.Percent:
                    this.filters = IgxNumberFilteringOperand.instance();
                    break;
                case DataType.Date:
                    this.filters = IgxDateFilteringOperand.instance();
                    break;
                case DataType.String:
                default:
                    this.filters = IgxStringFilteringOperand.instance();
                    break;
            }
        }
    }
    /**
     * @hidden
     */
    getGridTemplate(isRow, isIE) {
        if (isRow) {
            const rowsCount = this.grid.multiRowLayoutRowSize;
            return isIE ?
                `(1fr)[${rowsCount}]` :
                `repeat(${rowsCount},1fr)`;
        }
        else {
            return this.getColumnSizesString(this.children);
        }
    }
    getInitialChildColumnSizes(children) {
        const columnSizes = [];
        // find the smallest col spans
        children.forEach(col => {
            if (!col.colStart) {
                return;
            }
            const newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            const newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
            const bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
            const bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            if (columnSizes[col.colStart - 1] === undefined) {
                // If nothing is defined yet take any column at first
                // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (newWidthSet || (newSpanSmaller && ((bothWidthsSet) || (bothWidthsNotSet)))) {
                // If a column is set already it should either not have width defined or have width with bigger span than the new one.
                /**
                 *  If replaced column has bigger span, we want to fill the remaining columns
                 *  that the replacing column does not fill with the old one.
                 */
                if (bothWidthsSet && newSpanSmaller) {
                    // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                    // We have not yet replaced it so we can use it directly from the columnSizes collection.
                    // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                    for (let i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                        if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                            columnSizes[i] = columnSizes[col.colStart - 1];
                        }
                        else {
                            break;
                        }
                    }
                }
                // Replace the old column with the new one.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
                // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
                // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
                // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
                for (let i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {
                    if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                        columnSizes[i] = {
                            ref: col,
                            width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                            colSpan: col.gridColumnSpan,
                            colEnd: col.colStart + col.gridColumnSpan,
                            widthSetByUser: col.widthSetByUser
                        };
                    }
                    else {
                        break;
                    }
                }
            }
        });
        // Flatten columnSizes so there are not columns with colSpan > 1
        for (let i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && columnSizes[i].colSpan > 1) {
                let j = 1;
                // Replace all empty places depending on how much the current column spans starting from next col.
                for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                    if (columnSizes[i + j] &&
                        ((!columnSizes[i].width && columnSizes[i + j].width) ||
                            (!columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan) ||
                            (!!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan))) {
                        // If we reach an already defined column that has width and the current doesn't have or
                        // if the reached column has bigger colSpan we stop.
                        break;
                    }
                    else {
                        const width = columnSizes[i].widthSetByUser ?
                            columnSizes[i].width / columnSizes[i].colSpan :
                            columnSizes[i].width;
                        columnSizes[i + j] = {
                            ref: columnSizes[i].ref,
                            width,
                            colSpan: 1,
                            colEnd: columnSizes[i].colEnd,
                            widthSetByUser: columnSizes[i].widthSetByUser
                        };
                    }
                }
                // Update the current column width so it is divided between all columns it spans and set it to 1.
                columnSizes[i].width = columnSizes[i].widthSetByUser ?
                    columnSizes[i].width / columnSizes[i].colSpan :
                    columnSizes[i].width;
                columnSizes[i].colSpan = 1;
                // Update the index based on how much we have replaced. Subtract 1 because we started from 1.
                i += j - 1;
            }
        }
        return columnSizes;
    }
    getFilledChildColumnSizes(children) {
        const columnSizes = this.getInitialChildColumnSizes(children);
        // fill the gaps if there are any
        const result = [];
        for (const size of columnSizes) {
            if (size && !!size.width) {
                result.push(size.width + 'px');
            }
            else {
                result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
            }
        }
        return result;
    }
    getResizableColUnderEnd() {
        if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {
            return [{ target: this, spanUsed: 1 }];
        }
        const columnSized = this.getInitialChildColumnSizes(this.parent.children);
        const targets = [];
        const colEnd = this.colEnd ? this.colEnd : this.colStart + 1;
        for (let i = 0; i < columnSized.length; i++) {
            if (this.colStart <= i + 1 && i + 1 < colEnd) {
                targets.push({ target: columnSized[i].ref, spanUsed: 1 });
            }
        }
        const targetsSquashed = [];
        for (const target of targets) {
            if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === target.target.field) {
                targetsSquashed[targetsSquashed.length - 1].spanUsed++;
            }
            else {
                targetsSquashed.push(target);
            }
        }
        return targetsSquashed;
    }
    /**
     * Pins the column at the provided index in the pinned area.
     * Defaults to index `0` if not provided, or to the initial index in the pinned area.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     *
     * @memberof IgxColumnComponent
     */
    pin(index) {
        // TODO: Probably should the return type of the old functions
        // should be moved as a event parameter.
        const grid = this.grid;
        if (this._pinned) {
            return false;
        }
        if (this.parent && !this.parent.pinned) {
            return this.topLevelParent.pin(index);
        }
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index > grid.pinnedColumns.length)) {
            return false;
        }
        if (!this.parent && !this.pinnable) {
            return false;
        }
        const rootPinnedCols = grid._pinnedColumns.filter((c) => c.level === 0);
        index = hasIndex ? index : rootPinnedCols.length;
        const args = { column: this, insertAtIndex: index, isPinned: false, cancel: false };
        this.grid.onColumnPinning.emit(args);
        if (args.cancel) {
            return;
        }
        grid.endEdit(false);
        this._pinned = true;
        this.pinnedChange.emit(this._pinned);
        // it is possible that index is the last position, so will need to find target column by [index-1]
        const targetColumn = args.insertAtIndex === grid._pinnedColumns.length ?
            grid._pinnedColumns[args.insertAtIndex - 1] : grid._pinnedColumns[args.insertAtIndex];
        if (grid._pinnedColumns.indexOf(this) === -1) {
            if (!grid.hasColumnGroups) {
                grid._pinnedColumns.splice(args.insertAtIndex, 0, this);
            }
            else {
                // insert based only on root collection
                rootPinnedCols.splice(args.insertAtIndex, 0, this);
                let allPinned = [];
                // re-create hierarchy
                rootPinnedCols.forEach(group => {
                    allPinned.push(group);
                    allPinned = allPinned.concat(group.allChildren);
                });
                grid._pinnedColumns = allPinned;
            }
            if (grid._unpinnedColumns.indexOf(this) !== -1) {
                const childrenCount = this.allChildren.length;
                grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1 + childrenCount);
            }
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.pin());
            grid.reinitPinStates();
        }
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        const eventArgs = { column: this, insertAtIndex: index, isPinned: true };
        this.grid.columnPinned.emit(eventArgs);
        return true;
    }
    /**
     * Unpins the column and place it at the provided index in the unpinned area.
     * Defaults to index `0` if not provided, or to the initial index in the unpinned area.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     *
     * @memberof IgxColumnComponent
     */
    unpin(index) {
        const grid = this.grid;
        if (!this._pinned) {
            return false;
        }
        if (this.parent && this.parent.pinned) {
            return this.topLevelParent.unpin(index);
        }
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index > grid._unpinnedColumns.length)) {
            return false;
        }
        // estimate the exact index at which column will be inserted
        // takes into account initial unpinned index of the column
        if (!hasIndex) {
            const indices = grid.unpinnedColumns.map(col => col.index);
            indices.push(this.index);
            indices.sort((a, b) => a - b);
            index = indices.indexOf(this.index);
        }
        const args = { column: this, insertAtIndex: index, isPinned: true, cancel: false };
        this.grid.onColumnPinning.emit(args);
        if (args.cancel) {
            return;
        }
        this.grid.endEdit(false);
        this._pinned = false;
        this.pinnedChange.emit(this._pinned);
        // it is possible that index is the last position, so will need to find target column by [index-1]
        const targetColumn = args.insertAtIndex === grid._unpinnedColumns.length ?
            grid._unpinnedColumns[args.insertAtIndex - 1] : grid._unpinnedColumns[args.insertAtIndex];
        if (!hasIndex) {
            grid._unpinnedColumns.splice(index, 0, this);
            if (grid._pinnedColumns.indexOf(this) !== -1) {
                grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
            }
        }
        if (hasIndex) {
            grid.moveColumn(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.unpin());
        }
        grid.reinitPinStates();
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        this.grid.columnPinned.emit({ column: this, insertAtIndex: index, isPinned: false });
        return true;
    }
    /**
     * Moves a column to the specified visible index.
     * If passed index is invalid, or if column would receive a different visible index after moving, moving is not performed.
     * If passed index would move the column to a different column group. moving is not performed.
     *
     * @example
     * ```typescript
     * column.move(index);
     * ```
     * @memberof IgxColumnComponent
     */
    move(index) {
        let target;
        const grid = this.grid;
        let columns = grid.columnList.filter(c => c.visibleIndex > -1);
        // grid last visible index
        const li = columns.map(c => c.visibleIndex).reduce((a, b) => Math.max(a, b));
        const parent = this.parent;
        const isPreceding = this.visibleIndex < index;
        if (index === this.visibleIndex || index < 0 || index > li) {
            return;
        }
        if (parent) {
            columns = columns.filter(c => c.level >= this.level && c !== this && c.parent !== this &&
                c.topLevelParent === this.topLevelParent);
        }
        /* eslint-disable max-len */
        // If isPreceding, find a target such that when the current column is placed after it, current colummn will receive a visibleIndex === index. This takes into account visible children of the columns.
        // If !isPreceding, finds a column of the same level and visible index that equals the passed index agument (c.visibleIndex === index). No need to consider the children here.
        /* eslint-enable max-len */
        if (isPreceding) {
            columns = columns.filter(c => c.visibleIndex > this.visibleIndex);
            target = columns.find(c => c.level === this.level && c.visibleIndex + c.calcChildren() - this.calcChildren() === index);
        }
        else {
            columns = columns.filter(c => c.visibleIndex < this.visibleIndex);
            target = columns.find(c => c.level === this.level && c.visibleIndex === index);
        }
        if (!target || (target.pinned && this.disablePinning)) {
            return;
        }
        const pos = isPreceding ? DropPosition.AfterDropTarget : DropPosition.BeforeDropTarget;
        grid.moveColumn(this, target, pos);
    }
    /**
     * No children for the column, so will returns 1 or 0, if the column is hidden.
     *
     * @hidden
     */
    calcChildren() {
        const children = this.hidden ? 0 : 1;
        return children;
    }
    /**
     * Toggles column vibisility and emits the respective event.
     *
     * @hidden
     */
    toggleVisibility(value) {
        const newValue = value !== null && value !== void 0 ? value : !this.hidden;
        const eventArgs = { column: this, newValue, cancel: false };
        this.grid.columnVisibilityChanging.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        this.hidden = newValue;
        this.grid.onColumnVisibilityChanged.emit({ column: this, newValue });
    }
    /**
     * Returns a reference to the top level parent column.
     * ```typescript
     * let topLevelParent =  this.column.topLevelParent;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get topLevelParent() {
        let parent = this.parent;
        while (parent && parent.parent) {
            parent = parent.parent;
        }
        return parent;
    }
    /**
     * Returns a reference to the header of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let headerCell = column.headerCell;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get headerCell() {
        return this.grid.headerCellList.find((header) => header.column === this);
    }
    /**
     * Returns a reference to the filter cell of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let filterell = column.filterell;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filterCell() {
        return this.grid.filterCellList.find((filterCell) => filterCell.column === this);
    }
    /**
     * Returns a reference to the header group of the column.
     *
     * @memberof IgxColumnComponent
     */
    get headerGroup() {
        return this.grid.headerGroupsList.find((headerGroup) => headerGroup.column === this);
    }
    /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     *
     * @memberof IgxColumnComponent
     * @param byHeader Set if column should be autized based only on the header content
     */
    autosize(byHeader = false) {
        if (!this.columnGroup) {
            const size = this.getAutoSize(byHeader);
            this.width = size;
            this.grid.reflow();
        }
    }
    /**
     * @hidden
     */
    getAutoSize(byHeader = false) {
        const size = !byHeader ? this.getLargestCellWidth() :
            (Object.values(this.getHeaderCellWidths()).reduce((a, b) => a + b) + 'px');
        const gridAvailableSize = this.grid.calcWidth;
        let newWidth;
        const isPercentageWidth = this.width && typeof this.width === 'string' && this.width.indexOf('%') !== -1;
        if (isPercentageWidth) {
            const percentageSize = parseFloat(size) / gridAvailableSize * 100;
            newWidth = percentageSize + '%';
        }
        else {
            newWidth = size;
        }
        return newWidth;
    }
    /**
     * @hidden
     */
    getCalcWidth() {
        if (this._calcWidth && !isNaN(this.calcPixelWidth)) {
            return this._calcWidth;
        }
        this.cacheCalcWidth();
        return this._calcWidth;
    }
    /**
     * @hidden
     * Returns the width and padding of a header cell.
     */
    getHeaderCellWidths() {
        const range = this.grid.document.createRange();
        let headerWidth;
        if (this.headerTemplate && this.headerCell.elementRef.nativeElement.children[0].children.length > 0) {
            headerWidth = Math.max(...Array.from(this.headerCell.elementRef.nativeElement.children[0].children)
                .map((child) => getNodeSizeViaRange(range, child)));
        }
        else {
            headerWidth = getNodeSizeViaRange(range, this.headerCell.elementRef.nativeElement.children[0]);
        }
        if (this.sortable || this.filterable) {
            headerWidth += this.headerCell.elementRef.nativeElement.children[1].getBoundingClientRect().width;
        }
        const headerStyle = this.grid.document.defaultView.getComputedStyle(this.headerCell.elementRef.nativeElement);
        const headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) +
            parseFloat(headerStyle.borderRightWidth);
        // Take into consideration the header group element, since column pinning applies borders to it if its not a columnGroup.
        const headerGroupStyle = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement);
        const borderSize = !this.parent ? parseFloat(headerGroupStyle.borderRightWidth) + parseFloat(headerGroupStyle.borderLeftWidth) : 0;
        return { width: Math.ceil(headerWidth), padding: Math.ceil(headerPadding + borderSize) };
    }
    /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * @memberof IgxColumnComponent
     */
    getLargestCellWidth() {
        const range = this.grid.document.createRange();
        const largest = new Map();
        if (this.cells.length > 0) {
            let cellsContentWidths = [];
            if (this.cells[0].nativeElement.children.length > 0) {
                this.cells.forEach((cell) => cellsContentWidths.push(cell.calculateSizeToFit(range)));
            }
            else {
                cellsContentWidths = this.cells.map((cell) => getNodeSizeViaRange(range, cell.nativeElement));
            }
            const index = cellsContentWidths.indexOf(Math.max(...cellsContentWidths));
            const cellStyle = this.grid.document.defaultView.getComputedStyle(this.cells[index].nativeElement);
            const cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) +
                parseFloat(cellStyle.borderLeftWidth) + parseFloat(cellStyle.borderRightWidth);
            largest.set(Math.max(...cellsContentWidths), cellPadding);
        }
        if (this.headerCell) {
            const headerCellWidths = this.getHeaderCellWidths();
            largest.set(headerCellWidths.width, headerCellWidths.padding);
        }
        const largestCell = Math.max(...Array.from(largest.keys()));
        const width = Math.ceil(largestCell + largest.get(largestCell));
        if (Number.isNaN(width)) {
            return this.width;
        }
        else {
            return width + 'px';
        }
    }
    /**
     * @hidden
     */
    getCellWidth() {
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (this.columnLayoutChild) {
            return '';
        }
        if (colWidth && !isPercentageWidth) {
            let cellWidth = colWidth;
            if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
                cellWidth += 'px';
            }
            return cellWidth;
        }
        else {
            return colWidth;
        }
    }
    /**
     * @hidden
     */
    populateVisibleIndexes() { }
    getColumnSizesString(children) {
        const res = this.getFilledChildColumnSizes(children);
        return res.join(' ');
    }
    /**
     * @hidden
     * @internal
     */
    cacheCalcWidth() {
        const grid = this.gridAPI.grid;
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (isPercentageWidth) {
            this._calcWidth = parseFloat(colWidth) / 100 * grid.calcWidth;
        }
        else if (!colWidth) {
            // no width
            this._calcWidth = this.defaultWidth || grid.getPossibleColumnWidth();
        }
        else {
            this._calcWidth = this.width;
        }
        this.calcPixelWidth = parseFloat(this._calcWidth);
    }
    /**
     * @hidden
     * @internal
     */
    setExpandCollapseState() {
        this.children.filter(col => (col.visibleWhenCollapsed !== undefined)).forEach(c => {
            if (!this.collapsible) {
                c.hidden = this.hidden;
                return;
            }
            c.hidden = this._expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
        });
    }
    /**
     * @hidden
     * @internal
     */
    checkCollapsibleState() {
        if (!this.children) {
            return false;
        }
        const cols = this.children.map(child => child.visibleWhenCollapsed);
        return (cols.some(c => c === true) && cols.some(c => c === false));
    }
    /**
     * @hidden
     */
    get pinnable() {
        return this.grid._init || !this.pinned;
    }
    /**
     * @hidden
     */
    get applySelectableClass() {
        return this._applySelectableClass;
    }
    /**
     * @hidden
     */
    set applySelectableClass(value) {
        if (this.selectable) {
            this._applySelectableClass = value;
        }
    }
}
IgxColumnComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-column',
                template: ``
            },] }
];
IgxColumnComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef }
];
IgxColumnComponent.propDecorators = {
    field: [{ type: Input }],
    header: [{ type: Input }],
    title: [{ type: Input }],
    sortable: [{ type: Input }],
    selectable: [{ type: Input }],
    groupable: [{ type: Input }],
    editable: [{ type: Input }],
    filterable: [{ type: Input }],
    resizable: [{ type: Input }],
    hasSummary: [{ type: Input }],
    hidden: [{ type: Input }],
    hiddenChange: [{ type: Output }],
    expandedChange: [{ type: Output }],
    collapsibleChange: [{ type: Output }],
    visibleWhenCollapsedChange: [{ type: Output }],
    onColumnChange: [{ type: Output }],
    disableHiding: [{ type: Input }],
    disablePinning: [{ type: Input }],
    movable: [{ type: Input }],
    width: [{ type: Input }],
    maxWidth: [{ type: Input }],
    headerClasses: [{ type: Input }],
    headerGroupClasses: [{ type: Input }],
    cellClasses: [{ type: Input }],
    cellStyles: [{ type: Input }],
    formatter: [{ type: Input }],
    filteringIgnoreCase: [{ type: Input }],
    sortingIgnoreCase: [{ type: Input }],
    searchable: [{ type: Input }],
    dataType: [{ type: Input }],
    collapsibleIndicatorTemplate: [{ type: Input }],
    rowEnd: [{ type: Input }],
    colEnd: [{ type: Input }],
    rowStart: [{ type: Input }],
    colStart: [{ type: Input }],
    widthChange: [{ type: Output }],
    pinnedChange: [{ type: Output }],
    filterCellTemplateDirective: [{ type: ContentChild, args: [IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective },] }],
    cellTemplate: [{ type: ContentChild, args: [IgxCellTemplateDirective, { read: IgxCellTemplateDirective },] }],
    headTemplate: [{ type: ContentChildren, args: [IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective, descendants: false },] }],
    editorTemplate: [{ type: ContentChild, args: [IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective },] }],
    collapseIndicatorTemplate: [{ type: ContentChild, args: [IgxCollapsibleIndicatorTemplateDirective, { read: IgxCollapsibleIndicatorTemplateDirective, static: false },] }],
    minWidth: [{ type: Input }],
    pinned: [{ type: Input }],
    summaries: [{ type: Input }],
    filters: [{ type: Input }],
    sortStrategy: [{ type: Input }],
    groupingComparer: [{ type: Input }],
    bodyTemplate: [{ type: Input, args: ['cellTemplate',] }],
    headerTemplate: [{ type: Input }],
    inlineEditorTemplate: [{ type: Input, args: ['cellEditorTemplate',] }],
    filterCellTemplate: [{ type: Input, args: ['filterCellTemplate',] }],
    visibleWhenCollapsed: [{ type: Input }],
    pipeArgs: [{ type: Input }]
};
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "header", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "title", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "sortable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "selectable", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "groupable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "editable", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filterable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "resizable", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "hasSummary", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "hidden", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "disableHiding", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "disablePinning", void 0);
__decorate([
    WatchColumnChanges(),
    notifyChanges()
], IgxColumnComponent.prototype, "movable", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "width", null);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "maxWidth", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerGroupClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "cellClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "cellStyles", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "formatter", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filteringIgnoreCase", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "sortingIgnoreCase", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "searchable", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "minWidth", null);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "pinned", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "summaries", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "bodyTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "inlineEditorTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filterCellTemplate", null);
__decorate([
    notifyChanges(true)
], IgxColumnComponent.prototype, "visibleWhenCollapsed", null);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1uLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9jb2x1bW5zL2NvbHVtbi5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUVILGlCQUFpQixFQUNqQix1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFlBQVksRUFDWixlQUFlLEVBQ2YsS0FBSyxFQUdMLE1BQU0sRUFDTixZQUFZLEdBRWYsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUMzRCxPQUFPLEVBRUgsMEJBQTBCLEVBQzFCLHlCQUF5QixFQUN6Qix1QkFBdUIsRUFDdkIseUJBQXlCLEVBQzVCLE1BQU0sMkNBQTJDLENBQUM7QUFDbkQsT0FBTyxFQUFvQixzQkFBc0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQ2xHLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUczRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFbkQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFLcEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDdkQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLHVCQUF1QixFQUFFLHFCQUFxQixFQUN0RSx5QkFBeUIsRUFBRSx3QkFBd0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzNGLE9BQU8sRUFDSCx3QkFBd0IsRUFDeEIs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a0JBQWtCLEVBQUU7b0RBRUc7QUFnQnhCO0lBSEMsYUFBYSxFQUFFO0lBQ2Ysa0JBQWtCLEVBQUU7eURBRUs7QUFnQjFCO0lBSEMsYUFBYSxFQUFFO0lBQ2Ysa0JBQWtCLEVBQUU7OERBRVU7QUFxQi9CO0lBSEMsYUFBYSxFQUFFO0lBQ2Ysa0JBQWtCLEVBQUU7dURBRUc7QUFzQnhCO0lBSEMsYUFBYSxFQUFFO0lBQ2Ysa0JBQWtCLEVBQUU7c0RBRUg7QUF5QmxCO0lBSEMsYUFBYSxFQUFFO0lBQ2Ysa0JBQWtCLEVBQUU7cURBRVU7QUFlL0I7SUFGQyxrQkFBa0IsRUFBRTsrREFFYTtBQWVsQztJQUZDLGtCQUFrQixFQUFFOzZEQUVXO0FBZ0JoQztJQUhDLGFBQWEsRUFBRTtJQUNmLGtCQUFrQixFQUFFO3NEQUVJO0FBMEt6QjtJQUhDLGFBQWEsRUFBRTtJQUNmLGtCQUFrQixFQUFFO2tEQVNwQjtBQTJCRDtJQUZDLGtCQUFrQixFQUFFO2dEQUlwQjtBQTRDRDtJQUhDLGFBQWEsQ0FBQyxJQUFJLENBQUM7SUFDbkIsa0JBQWtCLEVBQUU7bURBSXBCO0FBb0lEO0lBSEMsYUFBYSxFQUFFO0lBQ2Ysa0JBQWtCLEVBQUU7c0RBSXBCO0FBZ0NEO0lBSEMsYUFBYSxFQUFFO0lBQ2Ysa0JBQWtCLEVBQUU7d0RBSXBCO0FBaUNEO0lBSEMsYUFBYSxFQUFFO0lBQ2Ysa0JBQWtCLEVBQUU7OERBSXBCO0FBOEJEO0lBSEMsYUFBYSxFQUFFO0lBQ2Ysa0JBQWtCLEVBQUU7NERBSXBCO0FBbUxEO0lBRkMsYUFBYSxDQUFDLElBQUksQ0FBQzs4REFRbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBDb250ZW50Q2hpbGRyZW4sXG4gICAgSW5wdXQsXG4gICAgUXVlcnlMaXN0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIE91dHB1dCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgT25EZXN0cm95LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG5vdGlmeUNoYW5nZXMgfSBmcm9tICcuLi93YXRjaC1jaGFuZ2VzJztcbmltcG9ydCB7IFdhdGNoQ29sdW1uQ2hhbmdlcyB9IGZyb20gJy4uL3dhdGNoLWNoYW5nZXMnO1xuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZGF0YS11dGlsJztcbmltcG9ydCB7XG4gICAgSWd4RmlsdGVyaW5nT3BlcmFuZCxcbiAgICBJZ3hCb29sZWFuRmlsdGVyaW5nT3BlcmFuZCxcbiAgICBJZ3hOdW1iZXJGaWx0ZXJpbmdPcGVyYW5kLFxuICAgIElneERhdGVGaWx0ZXJpbmdPcGVyYW5kLFxuICAgIElneFN0cmluZ0ZpbHRlcmluZ09wZXJhbmRcbn0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2ZpbHRlcmluZy1jb25kaXRpb24nO1xuaW1wb3J0IHsgSVNvcnRpbmdTdHJhdGVneSwgRGVmYXVsdFNvcnRpbmdTdHJhdGVneSB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9zb3J0aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IERpc3BsYXlEZW5zaXR5IH0gZnJvbSAnLi4vLi4vY29yZS9kaXNwbGF5RGVuc2l0eSc7XG5pbXBvcnQgeyBJZ3hHcmlkQmFzZURpcmVjdGl2ZSB9IGZyb20gJy4uL2dyaWQtYmFzZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4R3JpZENlbGxDb21wb25lbnQgfSBmcm9tICcuLi9jZWxsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hSb3dEaXJlY3RpdmUgfSBmcm9tICcuLi9yb3cuZGlyZWN0aXZlJztcbmltcG9ydCB7IEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9maWx0ZXJpbmctZXhwcmVzc2lvbnMtdHJlZSc7XG5pbXBvcnQgeyBHcmlkQmFzZUFQSVNlcnZpY2UgfSBmcm9tICcuLi9hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBHcmlkVHlwZSB9IGZyb20gJy4uL2NvbW1vbi9ncmlkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJZ3hHcmlkSGVhZGVyQ29tcG9uZW50IH0gZnJvbSAnLi4vaGVhZGVycy9ncmlkLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZEZpbHRlcmluZ0NlbGxDb21wb25lbnQgfSBmcm9tICcuLi9maWx0ZXJpbmcvYmFzZS9ncmlkLWZpbHRlcmluZy1jZWxsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hHcmlkSGVhZGVyR3JvdXBDb21wb25lbnQgfSBmcm9tICcuLi9oZWFkZXJzL2dyaWQtaGVhZGVyLWdyb3VwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBnZXROb2RlU2l6ZVZpYVJhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJZ3hTdW1tYXJ5T3BlcmFuZCwgSWd4TnVtYmVyU3VtbWFyeU9wZXJhbmQsIElneERhdGVTdW1tYXJ5T3BlcmFuZCxcbiAgICBJZ3hDdXJyZW5jeVN1bW1hcnlPcGVyYW5kLCBJZ3hQZXJjZW50U3VtbWFyeU9wZXJhbmQgfSBmcm9tICcuLi9zdW1tYXJpZXMvZ3JpZC1zdW1tYXJ5JztcbmltcG9ydCB7XG4gICAgSWd4Q2VsbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIElneENlbGxIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJZ3hDZWxsRWRpdG9yVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgSWd4Q29sbGFwc2libGVJbmRpY2F0b3JUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJZ3hGaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmVcbn0gZnJvbSAnLi90ZW1wbGF0ZXMuZGlyZWN0aXZlJztcbmltcG9ydCB7IE1STFJlc2l6ZUNvbHVtbkluZm8sIE1STENvbHVtblNpemVJbmZvLCBJQ29sdW1uUGlwZUFyZ3MgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgRHJvcFBvc2l0aW9uIH0gZnJvbSAnLi4vbW92aW5nL21vdmluZy5zZXJ2aWNlJztcbmltcG9ydCB7IElneENvbHVtbkdyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi9jb2x1bW4tZ3JvdXAuY29tcG9uZW50JztcbmltcG9ydCB7IElDb2x1bW5WaXNpYmlsaXR5Q2hhbmdpbmdFdmVudEFyZ3MsIElQaW5Db2x1bW5DYW5jZWxsYWJsZUV2ZW50QXJncywgSVBpbkNvbHVtbkV2ZW50QXJncyB9IGZyb20gJy4uL2NvbW1vbi9ldmVudHMnO1xuXG5jb25zdCBERUZBVUxUX0RBVEVfRk9STUFUID0gJ21lZGl1bURhdGUnO1xuY29uc3QgREVGQVVMVF9ESUdJVFNfSU5GTyA9ICcxLjAtMyc7XG5cbi8qKlxuICogKipJZ25pdGUgVUkgZm9yIEFuZ3VsYXIgQ29sdW1uKiogLVxuICogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LmluZnJhZ2lzdGljcy5jb20vcHJvZHVjdHMvaWduaXRlLXVpLWFuZ3VsYXIvYW5ndWxhci9jb21wb25lbnRzL2dyaWQvZ3JpZCNjb2x1bW5zLWNvbmZpZ3VyYXRpb24pXG4gKlxuICogVGhlIElnbml0ZSBVSSBDb2x1bW4gaXMgdXNlZCB3aXRoaW4gYW4gYGlneC1ncmlkYCBlbGVtZW50IHRvIGRlZmluZSB3aGF0IGRhdGEgdGhlIGNvbHVtbiB3aWxsIHNob3cuIEZlYXR1cmVzIHN1Y2ggYXMgc29ydGluZyxcbiAqIGZpbHRlcmluZyAmIGVkaXRpbmcgYXJlIGVuYWJsZWQgYXQgdGhlIGNvbHVtbiBsZXZlbC4gIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgdGVtcGxhdGUgY29udGFpbmluZyBjdXN0b20gY29udGVudCBpbnNpZGVcbiAqIHRoZSBjb2x1bW4gdXNpbmcgYG5nLXRlbXBsYXRlYCB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIGFsbCBjZWxscyB3aXRoaW4gdGhlIGNvbHVtbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gICAgc2VsZWN0b3I6ICdpZ3gtY29sdW1uJyxcbiAgICB0ZW1wbGF0ZTogYGBcbn0pXG5leHBvcnQgY2xhc3MgSWd4Q29sdW1uQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGBmaWVsZGAgdmFsdWUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5GaWVsZCA9IHRoaXMuY29sdW1uLmZpZWxkO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbZmllbGRdID0gXCInSUQnXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IGZpZWxkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fZmllbGQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNOZXN0ZWRQYXRoID0gdmFsdWU/LmluY2x1ZGVzKCcuJyk7XG4gICAgfVxuICAgIGdldCBmaWVsZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmllbGQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBgaGVhZGVyYCB2YWx1ZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkhlYWRlciA9IHRoaXMuY29sdW1uLmhlYWRlcjtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2hlYWRlcl0gPSBcIidJRCdcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGhlYWRlciA9ICcnO1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgYHRpdGxlYCB2YWx1ZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHRpdGxlID0gdGhpcy5jb2x1bW4udGl0bGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFt0aXRsZV0gPSBcIidTb21lIGNvbHVtbiB0b29sdGlwJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGl0bGUgPSAnJztcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIHNvcnRhYmxlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzU29ydGFibGUgPSB0aGlzLmNvbHVtbi5zb3J0YWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3NvcnRhYmxlXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzb3J0YWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGNvbHVtbiBpcyBzZWxlY3RhYmxlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uU2VsZWN0YWJsZSA9IHRoaXMuY29sdW1uLnNlbGVjdGFibGU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBnZXQgc2VsZWN0YWJsZSgpOiBib29sZWFuICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RhYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgaWYgdGhlIGNvbHVtbiBpcyBzZWxlY3RhYmxlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbc2VsZWN0YWJsZV0gPSBcImZhbHNlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBzZWxlY3RhYmxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGFibGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGdyb3VwYWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0dyb3VwYWJsZSA9IHRoaXMuY29sdW1uLmdyb3VwYWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2dyb3VwYWJsZV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXModHJ1ZSlcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIGdyb3VwYWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGVkaXRhYmxlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzRWRpdGFibGUgPSB0aGlzLmNvbHVtbi5lZGl0YWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIGdldCBlZGl0YWJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgLy8gVXBkYXRpbmcgdGhlIHByaW1hcnkga2V5IHdoZW4gZ3JpZCBoYXMgdHJhbnNhY3Rpb25zIChpbmNsLiByb3cgZWRpdClcbiAgICAgICAgLy8gc2hvdWxkIG5vdCBiZSBhbGxvd2VkLCBhcyB0aGF0IGNhbiBjb3JydXB0IHRyYW5zYWN0aW9uIHN0YXRlLlxuICAgICAgICBjb25zdCByb3dFZGl0YWJsZSA9IHRoaXMuZ3JpZCAmJiB0aGlzLmdyaWQucm93RWRpdGFibGU7XG4gICAgICAgIGNvbnN0IGhhc1RyYW5zYWN0aW9ucyA9IHRoaXMuZ3JpZCAmJiB0aGlzLmdyaWQudHJhbnNhY3Rpb25zLmVuYWJsZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5Q29sdW1uICYmIChyb3dFZGl0YWJsZSB8fCBoYXNUcmFuc2FjdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZWRpdGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRhYmxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJvd0VkaXRhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGVkaXRhYmxlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5lZGl0YWJsZSA9IHRydWU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtlZGl0YWJsZV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGVkaXRhYmxlKGVkaXRhYmxlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2VkaXRhYmxlID0gZWRpdGFibGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgZmlsdGVyYWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzRmlsdGVyYWJsZSA9IHRoaXMuY29sdW1uLmZpbHRlcmFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtmaWx0ZXJhYmxlXSA9IFwiZmFsc2VcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGZpbHRlcmFibGUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgcmVzaXphYmxlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzUmVzaXphYmxlID0gdGhpcy5jb2x1bW4ucmVzaXphYmxlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbcmVzaXphYmxlXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByZXNpemFibGUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzdW1tYXJ5IGZvciB0aGUgY29sdW1uIGlzIGVuYWJsZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBoYXNTdW1tYXJ5ID0gdGhpcy5jb2x1bW4uaGFzU3VtbWFyeTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcyh0cnVlKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGhhc1N1bW1hcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNTdW1tYXJ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzdW1tYXJ5IGZvciB0aGUgY29sdW1uIGlzIGVuYWJsZWQuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGFzU3VtbWFyeV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGhhc1N1bW1hcnkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGFzU3VtbWFyeSA9IHZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5U2VydmljZS5yZXNldFN1bW1hcnlIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBoaWRkZW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0hpZGRlbiA9IHRoaXMuY29sdW1uLmhpZGRlbjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcyh0cnVlKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGhpZGRlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGRlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29sdW1uIGhpZGRlbiBwcm9wZXJ0eS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtoaWRkZW5dID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVHdvLXdheSBkYXRhIGJpbmRpbmcuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFsoaGlkZGVuKV0gPSBcIm1vZGVsLmlzSGlkZGVuXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBoaWRkZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2hpZGRlbiAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZGRlbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oaWRkZW5DaGFuZ2UuZW1pdCh0aGlzLl9oaWRkZW4pO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0Q2hpbGQgJiYgdGhpcy5wYXJlbnQuaGlkZGVuICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmhpZGRlbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuZW5kRWRpdChmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLnN1bW1hcnlTZXJ2aWNlLnJlc2V0U3VtbWFyeUhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5maWx0ZXJpbmdTZXJ2aWNlLnJlZnJlc2hFeHByZXNzaW9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5maWx0ZXJpbmdTZXJ2aWNlLmhpZGVGaWx0ZXJpbmdSb3dPbkNvbHVtblZpc2liaWxpdHlDaGFuZ2UodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGNvbHVtbiBpcyBzZWxlY3RlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzU2VsZWN0ZWQgPSB0aGlzLmNvbHVtbi5zZWxlY3RlZDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuc2VsZWN0aW9uU2VydmljZS5pc0NvbHVtblNlbGVjdGVkKHRoaXMuZmllbGQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdC9kZXNlbGVjdCBhIGNvbHVtbi5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgc2VsZWN0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0YWJsZSAmJiB2YWx1ZSAhPT0gdGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0Q29sdW1uc1dpdGhOb0V2ZW50KFt0aGlzLmZpZWxkXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5zZWxlY3Rpb25TZXJ2aWNlLmRlc2VsZWN0Q29sdW1uc1dpdGhOb0V2ZW50KFt0aGlzLmZpZWxkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdyaWQubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBoaWRkZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBleHBhbmRlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGNvbGxhcHNpYmxlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHZpc2libGVXaGVuQ29sbGFwc2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25Db2x1bW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGhpZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzSGlkaW5nRGlzYWJsZWQgPSAgdGhpcy5jb2x1bW4uZGlzYWJsZUhpZGluZztcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBkaXNhYmxlSGlkaW5nID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwaW5uaW5nIGlzIGRpc2FibGVkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNQaW5uaW5nRGlzYWJsZWQgPSAgdGhpcy5jb2x1bW4uZGlzYWJsZVBpbm5pbmc7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZVBpbm5pbmcgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIG1vdmFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNNb3ZhYmxlID0gdGhpcy5jb2x1bW4ubW92YWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW21vdmFibGVdID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBtb3ZhYmxlID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYHdpZHRoYCBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uV2lkdGggPSB0aGlzLmNvbHVtbi53aWR0aDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcyh0cnVlKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCB3aWR0aCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aFNldEJ5VXNlciA/IHRoaXMuX3dpZHRoIDogdGhpcy5kZWZhdWx0V2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHdpZHRoYCBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbd2lkdGhdID0gXCInMjUlJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFR3by13YXkgZGF0YSBiaW5kaW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbKHdpZHRoKV09XCJtb2RlbC5jb2x1bW5zWzBdLndpZHRoXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgd2lkdGgodmFsdWU6IHN0cmluZykge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGNXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNhbGNQaXhlbFdpZHRoID0gTmFOO1xuICAgICAgICAgICAgdGhpcy53aWR0aFNldEJ5VXNlciA9IHRydWU7XG4gICAgICAgICAgICAvLyB3aWR0aCBjb3VsZCBiZSBwYXNzZWQgYXMgbnVtYmVyIGZyb20gdGhlIHRlbXBsYXRlXG4gICAgICAgICAgICAvLyBob3N0IGJpbmRpbmdzIGFyZSBub3QgcHggYWZmaXhlZCBzbyB3ZSBuZWVkIHRvIGVuc3VyZSB3ZSBhZmZpeCBzaW1wbGUgbnVtYmVyIHN0cmluZ3NcbiAgICAgICAgICAgIGlmICh0eXBlb2YodmFsdWUpID09PSAnbnVtYmVyJyB8fCB2YWx1ZS5tYXRjaCgvXlswLTldKiQvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlQ2FsY1dpZHRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndpZHRoQ2hhbmdlLmVtaXQodGhpcy5fd2lkdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBtYXhpbXVtIGB3aWR0aGAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbk1heFdpZHRoID0gdGhpcy5jb2x1bW4ud2lkdGg7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFttYXhXaWR0aF0gPSBcIicxNTBweCdcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgbWF4V2lkdGg6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgY2xhc3Mgc2VsZWN0b3Igb2YgdGhlIGNvbHVtbiBoZWFkZXIuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5IZWFkZXJDbGFzcyA9IHRoaXMuY29sdW1uLmhlYWRlckNsYXNzZXM7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtoZWFkZXJDbGFzc2VzXSA9IFwiJ2NvbHVtbi1oZWFkZXInXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoZWFkZXJDbGFzc2VzID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGNsYXNzIHNlbGVjdG9yIG9mIHRoZSBjb2x1bW4gZ3JvdXAgaGVhZGVyLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uSGVhZGVyQ2xhc3MgPSB0aGlzLmNvbHVtbi5oZWFkZXJHcm91cENsYXNzZXM7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtoZWFkZXJHcm91cENsYXNzZXNdID0gXCInY29sdW1uLWdyb3VwLWhlYWRlcidcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGhlYWRlckdyb3VwQ2xhc3NlcyA9ICcnO1xuICAgIC8qKlxuICAgICAqIFNldHMgYSBjb25kaXRpb25hbCBjbGFzcyBzZWxlY3RvciBvZiB0aGUgY29sdW1uIGNlbGxzLlxuICAgICAqIEFjY2VwdHMgYW4gb2JqZWN0IGxpdGVyYWwsIGNvbnRhaW5pbmcga2V5LXZhbHVlIHBhaXJzLFxuICAgICAqIHdoZXJlIHRoZSBrZXkgaXMgdGhlIG5hbWUgb2YgdGhlIENTUyBjbGFzcywgd2hpbGUgdGhlXG4gICAgICogdmFsdWUgaXMgZWl0aGVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYm9vbGVhbixcbiAgICAgKiBvciBib29sZWFuLCBsaWtlIHNvOlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjYWxsYmFjayA9IChyb3dEYXRhLCBjb2x1bW5LZXksIGNlbGxWYWx1ZSwgcm93SW5kZXgpID0+IHsgcmV0dXJuIHJvd0RhdGFbY29sdW1uS2V5XSA+IDY7IH1cbiAgICAgKiBjZWxsQ2xhc3NlcyA9IHsgJ2NsYXNzTmFtZScgOiB0aGlzLmNhbGxiYWNrIH07XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtjZWxsQ2xhc3Nlc10gPSBcImNlbGxDbGFzc2VzXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDxpZ3gtY29sdW1uIFtjZWxsQ2xhc3Nlc10gPSBcInsnY2xhc3MxJyA6IHRydWUgfVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2VsbENsYXNzZXM6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29uZGl0aW9uYWwgc3R5bGUgcHJvcGVydGllcyBvbiB0aGUgY29sdW1uIGNlbGxzLlxuICAgICAqIFNpbWlsYXIgdG8gYG5nU3R5bGVgIGl0IGFjY2VwdHMgYW4gb2JqZWN0IGxpdGVyYWwgd2hlcmUgdGhlIGtleXMgYXJlXG4gICAgICogdGhlIHN0eWxlIHByb3BlcnRpZXMgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgZXhwcmVzc2lvbiB0byBiZSBldmFsdWF0ZWQuXG4gICAgICogQXMgd2l0aCBgY2VsbENsYXNzZXNgIGl0IGFjY2VwdHMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogc3R5bGVzID0ge1xuICAgICAqICBiYWNrZ3JvdW5kOiAncm95YWxibHVlJyxcbiAgICAgKiAgY29sb3I6IChyb3dEYXRhLCBjb2x1bW5LZXksIGNlbGxWYWx1ZSwgcm93SW5kZXgpID0+IHZhbHVlLnN0YXJ0c1dpdGgoJ0ltcG9ydGFudCcpIDogJ3JlZCc6ICdpbmhlcml0J1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2NlbGxTdHlsZXNdPVwic3R5bGVzXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIGNlbGxTdHlsZXMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFdoZW4gYXV0b2dlbmVyYXRpbmcgY29sdW1ucywgdGhlIGZvcm1hdHRlciBpcyB1c2VkIHRvIGZvcm1hdCB0aGUgZGlzcGxheSBvZiB0aGUgY29sdW1uIGRhdGFcbiAgICAgKiB3aXRob3V0IG1vZGlmeWluZyB0aGUgdW5kZXJseWluZyBib3VuZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGV4YW1wbGUsIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgY29sdW1uIG5hbWUgaXMgU2FsYXJ5LCBhbmQgdGhlbiBwcm92aWRlIGEgbWV0aG9kIGFzIHRoZSBjb2x1bW4gZm9ybWF0dGVyXG4gICAgICogdG8gZm9ybWF0IHRoZSB2YWx1ZSBpbnRvIGEgY3VycmVuY3kgc3RyaW5nLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uQ29sdW1uSW5pdChjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCkge1xuICAgICAqICAgaWYgKGNvbHVtbi5maWVsZCA9PSBcIlNhbGFyeVwiKSB7XG4gICAgICogICAgIGNvbHVtbi5mb3JtYXR0ZXIgPSAoc2FsYXJ5ID0+IHRoaXMuZm9ybWF0KHNhbGFyeSkpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZvcm1hdCh2YWx1ZTogbnVtYmVyKSA6IHN0cmluZyB7XG4gICAgICogICByZXR1cm4gZm9ybWF0Q3VycmVuY3kodmFsdWUsIFwiZW4tdXNcIiwgXCIkXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBmb3JtYXR0ZXI6ICh2YWx1ZTogYW55KSA9PiBhbnk7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBmaWx0ZXJpbmcgc2hvdWxkIGJlIGNhc2Ugc2Vuc2l0aXZlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZmlsdGVyaW5nSWdub3JlQ2FzZSA9IHRoaXMuY29sdW1uLmZpbHRlcmluZ0lnbm9yZUNhc2U7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtmaWx0ZXJpbmdJZ25vcmVDYXNlXSA9IFwiZmFsc2VcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZmlsdGVyaW5nSWdub3JlQ2FzZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBzb3J0aW5nIHNob3VsZCBiZSBjYXNlIHNlbnNpdGl2ZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHNvcnRpbmdJZ25vcmVDYXNlID0gdGhpcy5jb2x1bW4uc29ydGluZ0lnbm9yZUNhc2U7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtzb3J0aW5nSWdub3JlQ2FzZV0gPSBcImZhbHNlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNvcnRpbmdJZ25vcmVDYXNlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGBzZWFyY2hhYmxlYC5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzU2VhcmNoYWJsZSA9ICB0aGlzLmNvbHVtbi5zZWFyY2hhYmxlJztcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogIDxpZ3gtY29sdW1uIFtzZWFyY2hhYmxlXSA9IFwiZmFsc2VcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNlYXJjaGFibGUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgZGF0YSB0eXBlIG9mIHRoZSBjb2x1bW4gdmFsdWVzLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYHN0cmluZ2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5EYXRhVHlwZSA9IHRoaXMuY29sdW1uLmRhdGFUeXBlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbZGF0YVR5cGVdID0gXCInbnVtYmVyJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkYXRhVHlwZTogRGF0YVR5cGUgPSBEYXRhVHlwZS5TdHJpbmc7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNvbGxhcHNpYmxlSW5kaWNhdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBSb3cgaW5kZXggd2hlcmUgdGhlIGN1cnJlbnQgZmllbGQgc2hvdWxkIGVuZC5cbiAgICAgKiBUaGUgYW1vdW50IG9mIHJvd3MgYmV0d2VlbiByb3dTdGFydCBhbmQgcm93RW5kIHdpbGwgZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2Ygc3Bhbm5pbmcgcm93cyB0byB0aGF0IGZpZWxkXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiAgIDxpZ3gtY29sdW1uIFtyb3dFbmRdPVwiMlwiIFtyb3dTdGFydF09XCIxXCIgW2NvbFN0YXJ0XT1cIjFcIj48L2lneC1jb2x1bW4+XG4gICAgICogPC9pZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByb3dFbmQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIENvbHVtbiBpbmRleCB3aGVyZSB0aGUgY3VycmVudCBmaWVsZCBzaG91bGQgZW5kLlxuICAgICAqIFRoZSBhbW91bnQgb2YgY29sdW1ucyBiZXR3ZWVuIGNvbFN0YXJ0IGFuZCBjb2xFbmQgd2lsbCBkZXRlcm1pbmUgdGhlIGFtb3VudCBvZiBzcGFubmluZyBjb2x1bW5zIHRvIHRoYXQgZmllbGRcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqICAgPGlneC1jb2x1bW4gW2NvbEVuZF09XCIzXCIgW3Jvd1N0YXJ0XT1cIjFcIiBbY29sU3RhcnRdPVwiMVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8L2lneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNvbEVuZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogUm93IGluZGV4IGZyb20gd2hpY2ggdGhlIGZpZWxkIGlzIHN0YXJ0aW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogICA8aWd4LWNvbHVtbiBbcm93U3RhcnRdPVwiMVwiIFtjb2xTdGFydF09XCIxXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDwvaWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KCkgcm93U3RhcnQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIENvbHVtbiBpbmRleCBmcm9tIHdoaWNoIHRoZSBmaWVsZCBpcyBzdGFydGluZy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqICAgPGlneC1jb2x1bW4gW2NvbFN0YXJ0XT1cIjFcIiBbcm93U3RhcnRdPVwiMVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8L2lneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpIGNvbFN0YXJ0OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHdpZHRoQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHBpbm5lZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hGaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4RmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlIH0pXG4gICAgcHVibGljIGZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZTogSWd4RmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneENlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hDZWxsVGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwcm90ZWN0ZWQgY2VsbFRlbXBsYXRlOiBJZ3hDZWxsVGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSWd4Q2VsbEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneENlbGxIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgZGVzY2VuZGFudHM6IGZhbHNlIH0pXG4gICAgcHJvdGVjdGVkIGhlYWRUZW1wbGF0ZTogUXVlcnlMaXN0PElneENlbGxIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4Q2VsbEVkaXRvclRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneENlbGxFZGl0b3JUZW1wbGF0ZURpcmVjdGl2ZSB9KVxuICAgIHByb3RlY3RlZCBlZGl0b3JUZW1wbGF0ZTogSWd4Q2VsbEVkaXRvclRlbXBsYXRlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneENvbGxhcHNpYmxlSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4Q29sbGFwc2libGVJbmRpY2F0b3JUZW1wbGF0ZURpcmVjdGl2ZSwgc3RhdGljOiBmYWxzZSB9KVxuICAgIHByb3RlY3RlZCBjb2xsYXBzZUluZGljYXRvclRlbXBsYXRlOiAgSWd4Q29sbGFwc2libGVJbmRpY2F0b3JUZW1wbGF0ZURpcmVjdGl2ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNhbGNXaWR0aCgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYWxjV2lkdGgoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY2FsY1BpeGVsV2lkdGg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1heFdpZHRoUHgoKSB7XG4gICAgICAgIGNvbnN0IGdyaWRBdmFpbGFibGVTaXplID0gdGhpcy5ncmlkLmNhbGNXaWR0aDtcbiAgICAgICAgY29uc3QgaXNQZXJjZW50YWdlV2lkdGggPSB0aGlzLm1heFdpZHRoICYmIHR5cGVvZiB0aGlzLm1heFdpZHRoID09PSAnc3RyaW5nJyAmJiB0aGlzLm1heFdpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTE7XG4gICAgICAgIHJldHVybiBpc1BlcmNlbnRhZ2VXaWR0aCA/ICBwYXJzZUZsb2F0KHRoaXMubWF4V2lkdGgpIC8gMTAwICogZ3JpZEF2YWlsYWJsZVNpemUgOiBwYXJzZUZsb2F0KHRoaXMubWF4V2lkdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1heFdpZHRoUGVyY2VudCgpIHtcbiAgICAgICAgY29uc3QgZ3JpZEF2YWlsYWJsZVNpemUgPSB0aGlzLmdyaWQuY2FsY1dpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IHRoaXMubWF4V2lkdGggJiYgdHlwZW9mIHRoaXMubWF4V2lkdGggPT09ICdzdHJpbmcnICYmIHRoaXMubWF4V2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgcmV0dXJuIGlzUGVyY2VudGFnZVdpZHRoID8gIHBhcnNlRmxvYXQodGhpcy5tYXhXaWR0aCkgOiBwYXJzZUZsb2F0KHRoaXMubWF4V2lkdGgpIC8gZ3JpZEF2YWlsYWJsZVNpemUgKiAxMDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWluV2lkdGhQeCgpIHtcbiAgICAgICAgY29uc3QgZ3JpZEF2YWlsYWJsZVNpemUgPSB0aGlzLmdyaWQuY2FsY1dpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IHRoaXMubWluV2lkdGggJiYgdHlwZW9mIHRoaXMubWluV2lkdGggPT09ICdzdHJpbmcnICYmIHRoaXMubWluV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgcmV0dXJuIGlzUGVyY2VudGFnZVdpZHRoID8gIHBhcnNlRmxvYXQodGhpcy5taW5XaWR0aCkgLyAxMDAgKiBncmlkQXZhaWxhYmxlU2l6ZSA6IHBhcnNlRmxvYXQodGhpcy5taW5XaWR0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWluV2lkdGhQZXJjZW50KCkge1xuICAgICAgICBjb25zdCBncmlkQXZhaWxhYmxlU2l6ZSA9IHRoaXMuZ3JpZC5jYWxjV2lkdGg7XG4gICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gdGhpcy5taW5XaWR0aCAmJiB0eXBlb2YgdGhpcy5taW5XaWR0aCA9PT0gJ3N0cmluZycgJiYgdGhpcy5taW5XaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuICAgICAgICByZXR1cm4gaXNQZXJjZW50YWdlV2lkdGggPyAgcGFyc2VGbG9hdCh0aGlzLm1pbldpZHRoKSA6IHBhcnNlRmxvYXQodGhpcy5taW5XaWR0aCkgLyBncmlkQXZhaWxhYmxlU2l6ZSAqIDEwMDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgbWluaW11bSBgd2lkdGhgIG9mIHRoZSBjb2x1bW4uXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgODhgO1xuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uTWluV2lkdGggPSB0aGlzLmNvbHVtbi5taW5XaWR0aDtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW21pbldpZHRoXSA9IFwiJzEwMHB4J1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IG1pbldpZHRoKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgbWluVmFsID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4obWluVmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlZmF1bHRNaW5XaWR0aCA9IHZhbHVlO1xuXG4gICAgfVxuICAgIHB1YmxpYyBnZXQgbWluV2lkdGgoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9kZWZhdWx0TWluV2lkdGggPyB0aGlzLmRlZmF1bHRNaW5XaWR0aCA6IHRoaXMuX2RlZmF1bHRNaW5XaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gaW5kZXguXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5JbmRleCA9IHRoaXMuY29sdW1uLmluZGV4O1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5jb2x1bW5zLmluZGV4T2YodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgYHBpbm5lZGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc1Bpbm5lZCA9IHRoaXMuY29sdW1uLnBpbm5lZDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgcGlubmVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGlubmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBwaW5uZWQuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbcGlubmVkXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFR3by13YXkgZGF0YSBiaW5kaW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbKHBpbm5lZCldID0gXCJtb2RlbC5jb2x1bW5zWzBdLmlzUGlubmVkXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgcGlubmVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh0aGlzLl9waW5uZWQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ncmlkICYmIHRoaXMud2lkdGggJiYgIWlzTmFOKHBhcnNlSW50KHRoaXMud2lkdGgsIDEwKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waW4oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVucGluKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIE5vIGdyaWQvd2lkdGggYXZhaWxhYmxlIGF0IGluaXRpYWxpemF0aW9uLiBgaW5pdFBpbm5pbmdgIGluIHRoZSBncmlkXG4gICAgICAgICAgICAgICB3aWxsIHJlLWluaXQgdGhlIGdyb3VwIChpZiBwcmVzZW50KVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3Bpbm5lZCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5waW5uZWRDaGFuZ2UuZW1pdCh0aGlzLl9waW5uZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sdW1uIGBzdW1tYXJpZXNgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uU3VtbWFyaWVzID0gdGhpcy5jb2x1bW4uc3VtbWFyaWVzO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKHRydWUpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHN1bW1hcmllcygpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VtbWFyaWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gYHN1bW1hcmllc2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLnN1bW1hcmllcyA9IElneE51bWJlclN1bW1hcnlPcGVyYW5kO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgc3VtbWFyaWVzKGNsYXNzUmVmOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fc3VtbWFyaWVzID0gbmV3IGNsYXNzUmVmKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLnN1bW1hcnlTZXJ2aWNlLnJlbW92ZVN1bW1hcmllc0NhY2hlUGVyQ29sdW1uKHRoaXMuZmllbGQpO1xuICAgICAgICAgICAgKHRoaXMuZ3JpZCBhcyBhbnkpLl9zdW1tYXJ5UGlwZVRyaWdnZXIrKztcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5U2VydmljZS5yZXNldFN1bW1hcnlIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gYGZpbHRlcnNgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uRmlsdGVycyA9IHRoaXMuY29sdW1uLmZpbHRlcnMnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGZpbHRlcnMoKTogSWd4RmlsdGVyaW5nT3BlcmFuZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gYGZpbHRlcnNgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5maWx0ZXJzID0gSWd4Qm9vbGVhbkZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKS5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGZpbHRlcnMoaW5zdGFuY2U6IElneEZpbHRlcmluZ09wZXJhbmQpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVycyA9IGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gYHNvcnRTdHJhdGVneWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzb3J0U3RyYXRlZ3kgPSB0aGlzLmNvbHVtbi5zb3J0U3RyYXRlZ3lcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgc29ydFN0cmF0ZWd5KCk6IElTb3J0aW5nU3RyYXRlZ3kge1xuICAgICAgICByZXR1cm4gdGhpcy5fc29ydFN0cmF0ZWd5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gYHNvcnRTdHJhdGVneWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLnNvcnRTdHJhdGVneSA9IG5ldyBDdXN0b21Tb3J0aW5nU3RyYXRlZ3koKS5cbiAgICAgKiBjbGFzcyBDdXN0b21Tb3J0aW5nU3RyYXRlZ3kgZXh0ZW5kcyBTb3J0aW5nU3RyYXRlZ3kgey4uLn1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHNvcnRTdHJhdGVneShjbGFzc1JlZjogSVNvcnRpbmdTdHJhdGVneSkge1xuICAgICAgICB0aGlzLl9zb3J0U3RyYXRlZ3kgPSBjbGFzc1JlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZnVuY3Rpb24gdGhhdCBjb21wYXJlcyB2YWx1ZXMgZm9yIGdyb3VwaW5nLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZ3JvdXBpbmdDb21wYXJlciA9IHRoaXMuY29sdW1uLmdyb3VwaW5nQ29tcGFyZXInXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGdyb3VwaW5nQ29tcGFyZXIoKTogKGE6IGFueSwgYjogYW55KSA9PiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBpbmdDb21wYXJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIGN1c3RvbSBmdW5jdGlvbiB0byBjb21wYXJlIHZhbHVlcyBmb3IgZ3JvdXBpbmcuXG4gICAgICogU3Vic2VxdWVudCB2YWx1ZXMgaW4gdGhlIHNvcnRlZCBkYXRhIHRoYXQgdGhlIGZ1bmN0aW9uIHJldHVybnMgMCBmb3IgYXJlIGdyb3VwZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLmdyb3VwaW5nQ29tcGFyZXIgPSAoYTogYW55LCBiOiBhbnkpID0+IHsgcmV0dXJuIGEgPT09IGIgPyAwIDogLTE7IH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGdyb3VwaW5nQ29tcGFyZXIoZnVuY1JlZjogKGE6IGFueSwgYjogYW55KSA9PiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBpbmdDb21wYXJlciA9IGZ1bmNSZWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRlZmF1bHQgbWluaW11bSBgd2lkdGhgIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBkZWZhdWx0TWluV2lkdGggPSAgdGhpcy5jb2x1bW4uZGVmYXVsdE1pbldpZHRoO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZGVmYXVsdE1pbldpZHRoKCk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdGhpcy5ncmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJzgwJztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuZ3JpZC5kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb3N5OlxuICAgICAgICAgICAgICAgIHJldHVybiAnNjQnO1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnNTYnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJzgwJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVmZXJlbmNlIHRvIHRoZSBgaWd4LWdyaWRgIG93bmVyLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZ3JpZENvbXBvbmVudCA9IHRoaXMuY29sdW1uLmdyaWQ7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBncmlkKCk6IElneEdyaWRCYXNlRGlyZWN0aXZlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZEFQSS5ncmlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgYm9keVRlbXBsYXRlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGJvZHlUZW1wbGF0ZSA9IHRoaXMuY29sdW1uLmJvZHlUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KCdjZWxsVGVtcGxhdGUnKVxuICAgIGdldCBib2R5VGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib2R5VGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvZHkgdGVtcGxhdGUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSAjYm9keVRlbXBsYXRlIGlneENlbGwgbGV0LXZhbD5cbiAgICAgKiAgICA8ZGl2IHN0eWxlID0gXCJiYWNrZ3JvdW5kLWNvbG9yOiB5ZWxsb3dncmVlblwiIChjbGljaykgPSBcImNoYW5nZUNvbG9yKHZhbClcIj5cbiAgICAgKiAgICAgICA8c3Bhbj4ge3t2YWx9fSA8L3NwYW4+XG4gICAgICogICAgPC9kaXY+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIidib2R5VGVtcGxhdGUnXCIsIHtyZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgICAqIHB1YmxpYyBib2R5VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgICogdGhpcy5jb2x1bW4uYm9keVRlbXBsYXRlID0gdGhpcy5ib2R5VGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGJvZHlUZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pikge1xuICAgICAgICB0aGlzLl9ib2R5VGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgaGVhZGVyIHRlbXBsYXRlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaGVhZGVyVGVtcGxhdGUgPSB0aGlzLmNvbHVtbi5oZWFkZXJUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBnZXQgaGVhZGVyVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVhZGVyIHRlbXBsYXRlLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgY29sdW1uIGhlYWRlciBoZWlnaHQgaXMgZml4ZWQgYW5kIGFueSBjb250ZW50IGJpZ2dlciB0aGFuIGl0IHdpbGwgYmUgY3V0IG9mZi5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNoZWFkZXJUZW1wbGF0ZT5cbiAgICAgKiAgIDxkaXYgc3R5bGUgPSBcImJhY2tncm91bmQtY29sb3I6YmxhY2tcIiAoY2xpY2spID0gXCJjaGFuZ2VDb2xvcih2YWwpXCI+XG4gICAgICogICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWRcIiA+e3tjb2x1bW4uZmllbGR9fTwvc3Bhbj5cbiAgICAgKiAgIDwvZGl2PlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCInaGVhZGVyVGVtcGxhdGUnXCIsIHtyZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgICAqIHB1YmxpYyBoZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAgKiB0aGlzLmNvbHVtbi5oZWFkZXJUZW1wbGF0ZSA9IHRoaXMuaGVhZGVyVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGhlYWRlclRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2hlYWRlclRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGlubGluZSBlZGl0b3IgdGVtcGxhdGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpbmxpbmVFZGl0b3JUZW1wbGF0ZSA9IHRoaXMuY29sdW1uLmlubGluZUVkaXRvclRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoJ2NlbGxFZGl0b3JUZW1wbGF0ZScpXG4gICAgZ2V0IGlubGluZUVkaXRvclRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5saW5lRWRpdG9yVGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGlubGluZSBlZGl0b3IgdGVtcGxhdGUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSAjaW5saW5lRWRpdG9yVGVtcGxhdGUgaWd4Q2VsbEVkaXRvciBsZXQtY2VsbD1cImNlbGxcIj5cbiAgICAgKiAgICAgPGlucHV0IHR5cGU9XCJzdHJpbmdcIiBbKG5nTW9kZWwpXT1cImNlbGwudmFsdWVcIi8+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIidpbmxpbmVFZGl0b3JUZW1wbGF0ZSdcIiwge3JlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgICogcHVibGljIGlubGluZUVkaXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgICAqIHRoaXMuY29sdW1uLmlubGluZUVkaXRvclRlbXBsYXRlID0gdGhpcy5pbmxpbmVFZGl0b3JUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgaW5saW5lRWRpdG9yVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICAgICAgdGhpcy5faW5saW5lRWRpdG9yVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYGZpbHRlckNlbGxUZW1wbGF0ZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBmaWx0ZXJDZWxsVGVtcGxhdGUgPSB0aGlzLmNvbHVtbi5maWx0ZXJDZWxsVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgnZmlsdGVyQ2VsbFRlbXBsYXRlJylcbiAgICBnZXQgZmlsdGVyQ2VsbFRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyQ2VsbFRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBxdWljayBmaWx0ZXIgdGVtcGxhdGUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSAjZmlsdGVyQ2VsbFRlbXBsYXRlIElneEZpbHRlckNlbGxUZW1wbGF0ZSBsZXQtY29sdW1uPVwiY29sdW1uXCI+XG4gICAgICogICAgPGlucHV0IChpbnB1dCk9XCJvbklucHV0KClcIj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiJ2ZpbHRlckNlbGxUZW1wbGF0ZSdcIiwge3JlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgICogcHVibGljIGZpbHRlckNlbGxUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAgKiB0aGlzLmNvbHVtbi5maWx0ZXJDZWxsVGVtcGxhdGUgPSB0aGlzLmZpbHRlckNlbGxUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgZmlsdGVyQ2VsbFRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlckNlbGxUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNlbGxzIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5DZWxscyA9ICB0aGlzLmNvbHVtbi5jZWxscztcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgY2VsbHMoKTogSWd4R3JpZENlbGxDb21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucm93TGlzdC5maWx0ZXIoKHJvdykgPT4gcm93IGluc3RhbmNlb2YgSWd4Um93RGlyZWN0aXZlKVxuICAgICAgICAgICAgLm1hcCgocm93KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5jZWxscykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93LmNlbGxzLmZpbHRlcigoY2VsbCkgPT4gY2VsbC5jb2x1bW5JbmRleCA9PT0gdGhpcy5pbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gdmlzaWJsZSBpbmRleC5cbiAgICAgKiBJZiB0aGUgY29sdW1uIGlzIG5vdCB2aXNpYmxlLCByZXR1cm5zIGAtMWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCB2aXNpYmxlQ29sdW1uSW5kZXggPSAgdGhpcy5jb2x1bW4udmlzaWJsZUluZGV4O1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCB2aXNpYmxlSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCFpc05hTih0aGlzLl92SW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdkluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVucGlubmVkQ29sdW1ucyA9IHRoaXMuZ3JpZC51bnBpbm5lZENvbHVtbnMuZmlsdGVyKGMgPT4gIWMuY29sdW1uR3JvdXApO1xuICAgICAgICBjb25zdCBwaW5uZWRDb2x1bW5zID0gdGhpcy5ncmlkLnBpbm5lZENvbHVtbnMuZmlsdGVyKGMgPT4gIWMuY29sdW1uR3JvdXApO1xuICAgICAgICBsZXQgY29sID0gdGhpcztcbiAgICAgICAgbGV0IHZJbmRleCA9IC0xO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICBjb2wgPSB0aGlzLmFsbENoaWxkcmVuLmZpbHRlcihjID0+ICFjLmNvbHVtbkdyb3VwICYmICFjLmhpZGRlbilbMF0gYXMgYW55O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxheW91dENoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGRyZW5WaXNpYmxlSW5kZXhlcy5maW5kKHggPT4geC5jb2x1bW4gPT09IHRoaXMpLmluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnBpbm5lZCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhJbkNvbGxlY3Rpb24gPSB1bnBpbm5lZENvbHVtbnMuaW5kZXhPZihjb2wpO1xuICAgICAgICAgICAgdkluZGV4ID0gaW5kZXhJbkNvbGxlY3Rpb24gPT09IC0xID9cbiAgICAgICAgICAgICAgICAtMSA6XG4gICAgICAgICAgICAgICAgKHRoaXMuZ3JpZC5pc1Bpbm5pbmdUb1N0YXJ0ID9cbiAgICAgICAgICAgICAgICAgICAgcGlubmVkQ29sdW1ucy5sZW5ndGggKyBpbmRleEluQ29sbGVjdGlvbiA6XG4gICAgICAgICAgICAgICAgICAgIGluZGV4SW5Db2xsZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4SW5Db2xsZWN0aW9uID0gcGlubmVkQ29sdW1ucy5pbmRleE9mKGNvbCk7XG4gICAgICAgICAgICB2SW5kZXggPSB0aGlzLmdyaWQuaXNQaW5uaW5nVG9TdGFydCA/XG4gICAgICAgICAgICAgICAgaW5kZXhJbkNvbGxlY3Rpb24gOlxuICAgICAgICAgICAgICAgIHVucGlubmVkQ29sdW1ucy5sZW5ndGggKyBpbmRleEluQ29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92SW5kZXggPSB2SW5kZXg7XG4gICAgICAgIHJldHVybiB2SW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGNvbHVtbiBpcyBhIGBDb2x1bW5Hcm91cGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5Hcm91cCA9ICB0aGlzLmNvbHVtbi5jb2x1bW5Hcm91cDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgY29sdW1uR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgY29sdW1uIGlzIGEgYENvbHVtbkxheW91dGAgZm9yIG11bHRpLXJvdyBsYXlvdXQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5Hcm91cCA9ICB0aGlzLmNvbHVtbi5jb2x1bW5Hcm91cDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgY29sdW1uTGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgY29sdW1uIGlzIGEgY2hpbGQgb2YgYSBgQ29sdW1uTGF5b3V0YCBmb3IgbXVsdGktcm93IGxheW91dC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkxheW91dENoaWxkID0gIHRoaXMuY29sdW1uLmNvbHVtbkxheW91dENoaWxkO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBjb2x1bW5MYXlvdXRDaGlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNvbHVtbkxheW91dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjaGlsZHJlbiBjb2x1bW5zIGNvbGxlY3Rpb24uXG4gICAgICogUmV0dXJucyBhbiBlbXB0eSBhcnJheSBpZiB0aGUgY29sdW1uIGRvZXMgbm90IGNvbnRhaW4gY2hpbGRyZW4gY29sdW1ucy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNoaWxkcmVuQ29sdW1ucyA9ICB0aGlzLmNvbHVtbi5hbGxDaGlsZHJlbjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgYWxsQ2hpbGRyZW4oKTogSWd4Q29sdW1uQ29tcG9uZW50W10ge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxldmVsIG9mIHRoZSBjb2x1bW4gaW4gYSBjb2x1bW4gZ3JvdXAuXG4gICAgICogUmV0dXJucyBgMGAgaWYgdGhlIGNvbHVtbiBkb2Vzbid0IGhhdmUgYSBgcGFyZW50YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkxldmVsID0gIHRoaXMuY29sdW1uLmxldmVsO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBsZXZlbCgpIHtcbiAgICAgICAgbGV0IHB0ciA9IHRoaXMucGFyZW50O1xuICAgICAgICBsZXQgbHZsID0gMDtcblxuICAgICAgICB3aGlsZSAocHRyKSB7XG4gICAgICAgICAgICBsdmwrKztcbiAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGx2bDtcbiAgICB9XG5cbiAgICBnZXQgaXNMYXN0UGlubmVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmlzUGlubmluZ1RvU3RhcnQgJiZcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5waW5uZWRDb2x1bW5zW3RoaXMuZ3JpZC5waW5uZWRDb2x1bW5zLmxlbmd0aCAtIDFdID09PSB0aGlzO1xuICAgIH1cblxuICAgIGdldCBpc0ZpcnN0UGlubmVkKCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBwaW5uZWRDb2xzID0gdGhpcy5ncmlkLnBpbm5lZENvbHVtbnMuZmlsdGVyKHggPT4gIXguY29sdW1uR3JvdXApO1xuICAgICAgICByZXR1cm4gIXRoaXMuZ3JpZC5pc1Bpbm5pbmdUb1N0YXJ0ICYmIHBpbm5lZENvbHNbMF0gPT09IHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0IHJpZ2h0UGlubmVkT2Zmc2V0KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpbm5lZCAmJiAhdGhpcy5ncmlkLmlzUGlubmluZ1RvU3RhcnQgP1xuICAgICAgICAgICAgLSB0aGlzLmdyaWQucGlubmVkV2lkdGggLSB0aGlzLmdyaWQuaGVhZGVyRmVhdHVyZXNXaWR0aCArICdweCcgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgZ3JpZFJvd1NwYW4oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93RW5kICYmIHRoaXMucm93U3RhcnQgPyB0aGlzLnJvd0VuZCAtIHRoaXMucm93U3RhcnQgOiAxO1xuICAgIH1cbiAgICBnZXQgZ3JpZENvbHVtblNwYW4oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sRW5kICYmIHRoaXMuY29sU3RhcnQgPyB0aGlzLmNvbEVuZCAtIHRoaXMuY29sU3RhcnQgOiAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjb2x1bW4gd2lsbCBiZSB2aXNpYmxlIHdoZW4gaXRzIHBhcmVudCBpcyBjb2xsYXBzZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uLWdyb3VwPlxuICAgICAqICAgPGlneC1jb2x1bW4gW3Zpc2libGVXaGVuQ29sbGFwc2VkXT1cInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogPC9pZ3gtY29sdW1uLWdyb3VwPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKHRydWUpXG4gICAgQElucHV0KClcbiAgICBzZXQgdmlzaWJsZVdoZW5Db2xsYXBzZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fdmlzaWJsZVdoZW5Db2xsYXBzZWQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy52aXNpYmxlV2hlbkNvbGxhcHNlZENoYW5nZS5lbWl0KHRoaXMuX3Zpc2libGVXaGVuQ29sbGFwc2VkKTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5zZXRFeHBhbmRDb2xsYXBzZVN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdmlzaWJsZVdoZW5Db2xsYXBzZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlV2hlbkNvbGxhcHNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFBhc3Mgb3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgRGF0ZVBpcGUgYW5kL29yIERlY2ltYWxQaXBlIHRvIGZvcm1hdCB0aGUgZGlzcGxheSB2YWx1ZSBmb3IgZGF0ZSBhbmQgbnVtZXJpYyBjb2x1bW5zLlxuICAgICAqIEFjY2VwdHMgYW4gYElDb2x1bW5QaXBlQXJnc2Agb2JqZWN0IHdpdGggYW55IG9mIHRoZSBgZm9ybWF0YCwgYHRpbWV6b25lYCBhbmQgYGRpZ2l0c0luZm9gIHByb3BlcnRpZXMuXG4gICAgICogRm9yIG1vcmUgZGV0YWlscyBzZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9jb21tb24vRGF0ZVBpcGUgYW5kIGh0dHBzOi8vYW5ndWxhci5pby9hcGkvY29tbW9uL0RlY2ltYWxQaXBlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcGlwZUFyZ3M6IElDb2x1bW5QaXBlQXJncyA9IHtcbiAgICAgKiAgICAgIGZvcm1hdDogJ2xvbmdEYXRlJyxcbiAgICAgKiAgICAgIHRpbWV6b25lOiAnVVRDJyxcbiAgICAgKiAgICAgIGRpZ2l0c0luZm86ICcxLjEtMidcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIGRhdGFUeXBlPVwiZGF0ZVwiIFtwaXBlQXJnc109XCJwaXBlQXJnc1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8aWd4LWNvbHVtbiBkYXRhVHlwZT1cIm51bWJlclwiIFtwaXBlQXJnc109XCJwaXBlQXJnc1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZXQgcGlwZUFyZ3ModmFsdWU6IElDb2x1bW5QaXBlQXJncykge1xuICAgICAgICB0aGlzLl9jb2x1bW5QaXBlQXJncyA9IE9iamVjdC5hc3NpZ24odGhpcy5fY29sdW1uUGlwZUFyZ3MsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5ncmlkLnN1bW1hcnlTZXJ2aWNlLmNsZWFyU3VtbWFyeUNhY2hlKCk7XG4gICAgICAgICh0aGlzLmdyaWQgYXMgYW55KS5fcGlwZVRyaWdnZXIrKztcbiAgICAgICAgdGhpcy5ncmlkLm5vdGlmeUNoYW5nZXMoKTtcbiAgICB9XG4gICAgZ2V0IHBpcGVBcmdzKCk6IElDb2x1bW5QaXBlQXJncyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5QaXBlQXJncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBjb2xsYXBzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGNvbGxhcHNpYmxlKF92YWx1ZTogYm9vbGVhbikge31cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGV4cGFuZGVkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcHVibGljIHNldCBleHBhbmRlZChfdmFsdWU6IGJvb2xlYW4pIHt9XG5cbiAgICAvKipcbiAgICAgKiBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZGVmYXVsdFdpZHRoOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgd2lkdGhTZXRCeVVzZXI6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGhhc05lc3RlZFBhdGg6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHRyZWUgPSAgdGhpcy5jb2x1bW4uZmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBmaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUoKTogRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5maWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUuZmluZCh0aGlzLmZpZWxkKSBhcyBGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgcGFyZW50IGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHBhcmVudENvbHVtbiA9IHRoaXMuY29sdW1uLnBhcmVudDtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW4ucGFyZW50ID0gaGlnaGVyTGV2ZWxDb2x1bW47XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHBhcmVudCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBjaGlsZHJlbiBjb2x1bW5zLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uQ2hpbGRyZW4gPSB0aGlzLmNvbHVtbi5jaGlsZHJlbjtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW4uY2hpbGRyZW4gPSBjaGlsZHJlbkNvbHVtbnM7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGNoaWxkcmVuOiBRdWVyeUxpc3Q8SWd4Q29sdW1uQ29tcG9uZW50PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfYXBwbHlTZWxlY3RhYmxlQ2xhc3MgPSBmYWxzZTtcblxuICAgIHByb3RlY3RlZCBfdkluZGV4ID0gTmFOO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3Bpbm5lZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2JvZHlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9oZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9pbmxpbmVFZGl0b3JUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9maWx0ZXJDZWxsVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfc3VtbWFyaWVzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9maWx0ZXJzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zb3J0U3RyYXRlZ3k6IElTb3J0aW5nU3RyYXRlZ3kgPSBEZWZhdWx0U29ydGluZ1N0cmF0ZWd5Lmluc3RhbmNlKCk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ3JvdXBpbmdDb21wYXJlcjogKGE6IGFueSwgYjogYW55KSA9PiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaGlkZGVuID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaW5kZXg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kaXNhYmxlUGlubmluZyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3dpZHRoOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZGVmYXVsdE1pbldpZHRoID0gJyc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaGFzU3VtbWFyeSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2VkaXRhYmxlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqICBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF92aXNpYmxlV2hlbkNvbGxhcHNlZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jb2xsYXBzaWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2V4cGFuZGVkID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zZWxlY3RhYmxlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldCBpc1ByaW1hcnlDb2x1bW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ncmlkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWVsZCA9PT0gdGhpcy5ncmlkLnByaW1hcnlLZXk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZmllbGQ6IHN0cmluZztcbiAgICBwcml2YXRlIF9jYWxjV2lkdGggPSBudWxsO1xuICAgIHByaXZhdGUgX2NvbHVtblBpcGVBcmdzOiBJQ29sdW1uUGlwZUFyZ3MgPSB7IGZvcm1hdDogREVGQVVMVF9EQVRFX0ZPUk1BVCwgZGlnaXRzSW5mbzogREVGQVVMVF9ESUdJVFNfSU5GTyB9O1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZSAmIEdyaWRUeXBlPiwgcHVibGljIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHsgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyByZXNldENhY2hlcygpIHtcbiAgICAgICAgdGhpcy5fdkluZGV4ID0gTmFOO1xuICAgICAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlQ2FsY1dpZHRoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fYm9keVRlbXBsYXRlID0gdGhpcy5jZWxsVGVtcGxhdGUudGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGVhZFRlbXBsYXRlICYmIHRoaXMuaGVhZFRlbXBsYXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyVGVtcGxhdGUgPSB0aGlzLmhlYWRUZW1wbGF0ZS50b0FycmF5KClbMF0udGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lubGluZUVkaXRvclRlbXBsYXRlID0gdGhpcy5lZGl0b3JUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlckNlbGxUZW1wbGF0ZSA9IHRoaXMuZmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdW1tYXJpZXMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXRhVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuU3RyaW5nOlxuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuQm9vbGVhbjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJpZXMgPSBJZ3hTdW1tYXJ5T3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyaWVzID0gSWd4TnVtYmVyU3VtbWFyeU9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuRGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJpZXMgPSBJZ3hEYXRlU3VtbWFyeU9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuQ3VycmVuY3k6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyaWVzID0gSWd4Q3VycmVuY3lTdW1tYXJ5T3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5QZXJjZW50OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcmllcyA9IElneFBlcmNlbnRTdW1tYXJ5T3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJpZXMgPSBJZ3hTdW1tYXJ5T3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlcnMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXRhVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuQm9vbGVhbjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gSWd4Qm9vbGVhbkZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5DdXJyZW5jeTpcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFUeXBlLlBlcmNlbnQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVycyA9IElneE51bWJlckZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5EYXRlOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnMgPSBJZ3hEYXRlRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFUeXBlLlN0cmluZzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnMgPSBJZ3hTdHJpbmdGaWx0ZXJpbmdPcGVyYW5kLmluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldEdyaWRUZW1wbGF0ZShpc1JvdzogYm9vbGVhbiwgaXNJRTogYm9vbGVhbik6IHN0cmluZyB7XG4gICAgICAgIGlmIChpc1Jvdykge1xuICAgICAgICAgICAgY29uc3Qgcm93c0NvdW50ID0gdGhpcy5ncmlkLm11bHRpUm93TGF5b3V0Um93U2l6ZTtcbiAgICAgICAgICAgIHJldHVybiBpc0lFID9cbiAgICAgICAgICAgICAgICBgKDFmcilbJHtyb3dzQ291bnR9XWAgOlxuICAgICAgICAgICAgICAgIGByZXBlYXQoJHtyb3dzQ291bnR9LDFmcilgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uU2l6ZXNTdHJpbmcodGhpcy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0SW5pdGlhbENoaWxkQ29sdW1uU2l6ZXMoY2hpbGRyZW46IFF1ZXJ5TGlzdDxJZ3hDb2x1bW5Db21wb25lbnQ+KTogQXJyYXk8TVJMQ29sdW1uU2l6ZUluZm8+IHtcbiAgICAgICAgY29uc3QgY29sdW1uU2l6ZXM6IE1STENvbHVtblNpemVJbmZvW10gPSBbXTtcbiAgICAgICAgLy8gZmluZCB0aGUgc21hbGxlc3QgY29sIHNwYW5zXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY29sID0+IHtcbiAgICAgICAgICAgIGlmICghY29sLmNvbFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3V2lkdGhTZXQgPSBjb2wud2lkdGhTZXRCeVVzZXIgJiYgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gJiYgIWNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLndpZHRoU2V0QnlVc2VyO1xuICAgICAgICAgICAgY29uc3QgbmV3U3BhblNtYWxsZXIgPSBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSAmJiBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXS5jb2xTcGFuID4gY29sLmdyaWRDb2x1bW5TcGFuO1xuICAgICAgICAgICAgY29uc3QgYm90aFdpZHRoc1NldCA9IGNvbC53aWR0aFNldEJ5VXNlciAmJiBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSAmJiBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXS53aWR0aFNldEJ5VXNlcjtcbiAgICAgICAgICAgIGNvbnN0IGJvdGhXaWR0aHNOb3RTZXQgPSAhY29sLndpZHRoU2V0QnlVc2VyICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdICYmICFjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXS53aWR0aFNldEJ5VXNlcjtcblxuICAgICAgICAgICAgaWYgKGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBub3RoaW5nIGlzIGRlZmluZWQgeWV0IHRha2UgYW55IGNvbHVtbiBhdCBmaXJzdFxuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBjb2xFbmQgdG8ga25vdyB3aGVyZSB0aGUgY29sdW1uIGFjdHVhbGx5IGVuZHMsIGJlY2F1c2Ugbm90IGFsd2F5cyBpdCBzdGFydHMgd2hlcmUgd2UgaGF2ZSBpdCBzZXQgaW4gY29sdW1uU2l6ZXMuXG4gICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogY29sLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sLndpZHRoU2V0QnlVc2VyIHx8IHRoaXMuZ3JpZC5jb2x1bW5XaWR0aFNldEJ5VXNlciA/IHBhcnNlSW50KGNvbC5jYWxjV2lkdGgsIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNvbFNwYW46IGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgY29sRW5kOiBjb2wuY29sU3RhcnQgKyBjb2wuZ3JpZENvbHVtblNwYW4sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoU2V0QnlVc2VyOiBjb2wud2lkdGhTZXRCeVVzZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdXaWR0aFNldCB8fCAobmV3U3BhblNtYWxsZXIgJiYgKChib3RoV2lkdGhzU2V0KSB8fCAoYm90aFdpZHRoc05vdFNldCkpKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgY29sdW1uIGlzIHNldCBhbHJlYWR5IGl0IHNob3VsZCBlaXRoZXIgbm90IGhhdmUgd2lkdGggZGVmaW5lZCBvciBoYXZlIHdpZHRoIHdpdGggYmlnZ2VyIHNwYW4gdGhhbiB0aGUgbmV3IG9uZS5cblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqICBJZiByZXBsYWNlZCBjb2x1bW4gaGFzIGJpZ2dlciBzcGFuLCB3ZSB3YW50IHRvIGZpbGwgdGhlIHJlbWFpbmluZyBjb2x1bW5zXG4gICAgICAgICAgICAgICAgICogIHRoYXQgdGhlIHJlcGxhY2luZyBjb2x1bW4gZG9lcyBub3QgZmlsbCB3aXRoIHRoZSBvbGQgb25lLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChib3RoV2lkdGhzU2V0ICYmIG5ld1NwYW5TbWFsbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZyb20gd2hlcmUgdGhlIG5ldyBjb2x1bW4gc2V0IHdvdWxkIGVuZCBhbmQgYXBwbHkgdGhlIG9sZCBjb2x1bW4gdG8gdGhlIHJlc3QgZGVwZW5kaW5nIG9uIGhvdyBtdWNoIGl0IHNwYW5zLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIG5vdCB5ZXQgcmVwbGFjZWQgaXQgc28gd2UgY2FuIHVzZSBpdCBkaXJlY3RseSBmcm9tIHRoZSBjb2x1bW5TaXplcyBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHdoZXJlIGNvbEVuZCBpcyB1c2VkIGJlY2F1c2UgdGhlIGNvbFN0YXJ0IG9mIHRoZSBvbGQgY29sdW1uIGlzIG5vdCBhY3R1YWxseSBpICsgMS5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbC5jb2xTdGFydCAtIDEgKyBjb2wuZ3JpZENvbHVtblNwYW47IGkgPCBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXS5jb2xFbmQgLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sdW1uU2l6ZXNbaV0gfHwgIWNvbHVtblNpemVzW2ldLndpZHRoU2V0QnlVc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbaV0gPSBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBvbGQgY29sdW1uIHdpdGggdGhlIG5ldyBvbmUuXG4gICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogY29sLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sLndpZHRoU2V0QnlVc2VyIHx8IHRoaXMuZ3JpZC5jb2x1bW5XaWR0aFNldEJ5VXNlciA/IHBhcnNlSW50KGNvbC5jYWxjV2lkdGgsIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNvbFNwYW46IGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgY29sRW5kOiBjb2wuY29sU3RhcnQgKyBjb2wuZ3JpZENvbHVtblNwYW4sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoU2V0QnlVc2VyOiBjb2wud2lkdGhTZXRCeVVzZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChib3RoV2lkdGhzU2V0ICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLmNvbFNwYW4gPCBjb2wuZ3JpZENvbHVtblNwYW4pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29sdW1uIGFscmVhZHkgaW4gdGhlIGNvbHVtblNpemVzIGhhcyBzbWFsbGVyIHNwYW4sIHdlIHN0aWxsIG5lZWQgdG8gZmlsbCBhbnkgZW1wdHkgcGxhY2VzIHdpdGggdGhlIGN1cnJlbnQgY29sLlxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZyb20gd2hlcmUgdGhlIHNtYWxsZXIgY29sdW1uIHNldCB3b3VsZCBlbmQgYW5kIGFwcGx5IHRoZSBiaWdnZXIgY29sdW1uIHRvIHRoZSByZXN0IGRlcGVuZGluZyBvbiBob3cgbXVjaCBpdCBzcGFucy5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBoZXJlIHdlIGRvIG5vdCBoYXZlIGl0IGluIGNvbHVtblNpemVzIHdlIHNldCBpdCBhcyBhIG5ldyBjb2x1bW4ga2VlcGluZyB0aGUgc2FtZSBjb2xTcGFuLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjb2wuY29sU3RhcnQgLSAxICsgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0uY29sU3BhbjsgaSA8IGNvbC5jb2xTdGFydCAtIDEgKyBjb2wuZ3JpZENvbHVtblNwYW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbHVtblNpemVzW2ldIHx8ICFjb2x1bW5TaXplc1tpXS53aWR0aFNldEJ5VXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbC53aWR0aFNldEJ5VXNlciB8fCB0aGlzLmdyaWQuY29sdW1uV2lkdGhTZXRCeVVzZXIgPyBwYXJzZUludChjb2wuY2FsY1dpZHRoLCAxMCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbFNwYW46IGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xFbmQ6IGNvbC5jb2xTdGFydCArIGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aFNldEJ5VXNlcjogY29sLndpZHRoU2V0QnlVc2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZsYXR0ZW4gY29sdW1uU2l6ZXMgc28gdGhlcmUgYXJlIG5vdCBjb2x1bW5zIHdpdGggY29sU3BhbiA+IDFcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5TaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbHVtblNpemVzW2ldICYmIGNvbHVtblNpemVzW2ldLmNvbFNwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IGogPSAxO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBhbGwgZW1wdHkgcGxhY2VzIGRlcGVuZGluZyBvbiBob3cgbXVjaCB0aGUgY3VycmVudCBjb2x1bW4gc3BhbnMgc3RhcnRpbmcgZnJvbSBuZXh0IGNvbC5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaiA8IGNvbHVtblNpemVzW2ldLmNvbFNwYW4gJiYgaSArIGogKyAxIDwgY29sdW1uU2l6ZXNbaV0uY29sRW5kOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtblNpemVzW2kgKyBqXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCghY29sdW1uU2l6ZXNbaV0ud2lkdGggJiYgY29sdW1uU2l6ZXNbaSArIGpdLndpZHRoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghY29sdW1uU2l6ZXNbaV0ud2lkdGggJiYgIWNvbHVtblNpemVzW2kgKyBqXS53aWR0aCAmJiBjb2x1bW5TaXplc1tpICsgal0uY29sU3BhbiA8PSBjb2x1bW5TaXplc1tpXS5jb2xTcGFuKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghIWNvbHVtblNpemVzW2kgKyBqXS53aWR0aCAmJiBjb2x1bW5TaXplc1tpICsgal0uY29sU3BhbiA8PSBjb2x1bW5TaXplc1tpXS5jb2xTcGFuKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoIGFuIGFscmVhZHkgZGVmaW5lZCBjb2x1bW4gdGhhdCBoYXMgd2lkdGggYW5kIHRoZSBjdXJyZW50IGRvZXNuJ3QgaGF2ZSBvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHJlYWNoZWQgY29sdW1uIGhhcyBiaWdnZXIgY29sU3BhbiB3ZSBzdG9wLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IGNvbHVtblNpemVzW2ldLndpZHRoU2V0QnlVc2VyID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS53aWR0aCAvIGNvbHVtblNpemVzW2ldLmNvbFNwYW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbaSArIGpdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogY29sdW1uU2l6ZXNbaV0ucmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbFNwYW46IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sRW5kOiBjb2x1bW5TaXplc1tpXS5jb2xFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhTZXRCeVVzZXI6IGNvbHVtblNpemVzW2ldLndpZHRoU2V0QnlVc2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGNvbHVtbiB3aWR0aCBzbyBpdCBpcyBkaXZpZGVkIGJldHdlZW4gYWxsIGNvbHVtbnMgaXQgc3BhbnMgYW5kIHNldCBpdCB0byAxLlxuICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoID0gY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXIgP1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS53aWR0aCAvIGNvbHVtblNpemVzW2ldLmNvbFNwYW4gOlxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS53aWR0aDtcbiAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS5jb2xTcGFuID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5kZXggYmFzZWQgb24gaG93IG11Y2ggd2UgaGF2ZSByZXBsYWNlZC4gU3VidHJhY3QgMSBiZWNhdXNlIHdlIHN0YXJ0ZWQgZnJvbSAxLlxuICAgICAgICAgICAgICAgIGkgKz0gaiAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sdW1uU2l6ZXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEZpbGxlZENoaWxkQ29sdW1uU2l6ZXMoY2hpbGRyZW46IFF1ZXJ5TGlzdDxJZ3hDb2x1bW5Db21wb25lbnQ+KTogQXJyYXk8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGNvbHVtblNpemVzID0gdGhpcy5nZXRJbml0aWFsQ2hpbGRDb2x1bW5TaXplcyhjaGlsZHJlbik7XG5cbiAgICAgICAgLy8gZmlsbCB0aGUgZ2FwcyBpZiB0aGVyZSBhcmUgYW55XG4gICAgICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzaXplIG9mIGNvbHVtblNpemVzKSB7XG4gICAgICAgICAgICBpZiAoc2l6ZSAmJiAhIXNpemUud2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzaXplLndpZHRoICsgJ3B4Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHRoaXMuZ3JpZC5nZXRQb3NzaWJsZUNvbHVtbldpZHRoKCksIDEwKSArICdweCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFJlc2l6YWJsZUNvbFVuZGVyRW5kKCk6IE1STFJlc2l6ZUNvbHVtbkluZm9bXSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxheW91dCB8fCAhdGhpcy5jb2x1bW5MYXlvdXRDaGlsZCB8fCB0aGlzLmNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gW3sgdGFyZ2V0OiB0aGlzLCBzcGFuVXNlZDogMSB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbHVtblNpemVkID0gdGhpcy5nZXRJbml0aWFsQ2hpbGRDb2x1bW5TaXplcyh0aGlzLnBhcmVudC5jaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IHRhcmdldHM6IE1STFJlc2l6ZUNvbHVtbkluZm9bXSA9IFtdO1xuICAgICAgICBjb25zdCBjb2xFbmQgPSB0aGlzLmNvbEVuZCA/IHRoaXMuY29sRW5kIDogdGhpcy5jb2xTdGFydCArIDE7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5TaXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sU3RhcnQgPD0gaSArIDEgJiYgaSArIDEgPCBjb2xFbmQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzLnB1c2goeyB0YXJnZXQ6IGNvbHVtblNpemVkW2ldLnJlZiwgc3BhblVzZWQ6IDEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXRzU3F1YXNoZWQ6IE1STFJlc2l6ZUNvbHVtbkluZm9bXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0c1NxdWFzaGVkLmxlbmd0aCAmJiB0YXJnZXRzU3F1YXNoZWRbdGFyZ2V0c1NxdWFzaGVkLmxlbmd0aCAtIDFdLnRhcmdldC5maWVsZCA9PT0gdGFyZ2V0LnRhcmdldC5maWVsZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldHNTcXVhc2hlZFt0YXJnZXRzU3F1YXNoZWQubGVuZ3RoIC0gMV0uc3BhblVzZWQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0c1NxdWFzaGVkLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRzU3F1YXNoZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGlucyB0aGUgY29sdW1uIGF0IHRoZSBwcm92aWRlZCBpbmRleCBpbiB0aGUgcGlubmVkIGFyZWEuXG4gICAgICogRGVmYXVsdHMgdG8gaW5kZXggYDBgIGlmIG5vdCBwcm92aWRlZCwgb3IgdG8gdGhlIGluaXRpYWwgaW5kZXggaW4gdGhlIHBpbm5lZCBhcmVhLlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBjb2x1bW4gaXMgc3VjY2Vzc2Z1bGx5IHBpbm5lZC4gUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBjb2x1bW4gY2Fubm90IGJlIHBpbm5lZC5cbiAgICAgKiBDb2x1bW4gY2Fubm90IGJlIHBpbm5lZCBpZjpcbiAgICAgKiAtIElzIGFscmVhZHkgcGlubmVkXG4gICAgICogLSBpbmRleCBhcmd1bWVudCBpcyBvdXQgb2YgcmFuZ2VcbiAgICAgKiAtIFRoZSBwaW5uZWQgYXJlYSBleGNlZWRzIDgwJSBvZiB0aGUgZ3JpZCB3aWR0aFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgc3VjY2VzcyA9IHRoaXMuY29sdW1uLnBpbigpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBwaW4oaW5kZXg/OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgLy8gVE9ETzogUHJvYmFibHkgc2hvdWxkIHRoZSByZXR1cm4gdHlwZSBvZiB0aGUgb2xkIGZ1bmN0aW9uc1xuICAgICAgICAvLyBzaG91bGQgYmUgbW92ZWQgYXMgYSBldmVudCBwYXJhbWV0ZXIuXG4gICAgICAgIGNvbnN0IGdyaWQgPSAodGhpcy5ncmlkIGFzIGFueSk7XG4gICAgICAgIGlmICh0aGlzLl9waW5uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAhdGhpcy5wYXJlbnQucGlubmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3BMZXZlbFBhcmVudC5waW4oaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGFzSW5kZXggPSBpbmRleCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaGFzSW5kZXggJiYgKGluZGV4IDwgMCB8fCBpbmRleCA+IGdyaWQucGlubmVkQ29sdW1ucy5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucGFyZW50ICYmICF0aGlzLnBpbm5hYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb290UGlubmVkQ29scyA9IGdyaWQuX3Bpbm5lZENvbHVtbnMuZmlsdGVyKChjKSA9PiBjLmxldmVsID09PSAwKTtcbiAgICAgICAgaW5kZXggPSBoYXNJbmRleCA/IGluZGV4IDogcm9vdFBpbm5lZENvbHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBhcmdzOiBJUGluQ29sdW1uQ2FuY2VsbGFibGVFdmVudEFyZ3MgPSB7IGNvbHVtbjogdGhpcywgaW5zZXJ0QXRJbmRleDogaW5kZXgsIGlzUGlubmVkOiBmYWxzZSwgY2FuY2VsOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLmdyaWQub25Db2x1bW5QaW5uaW5nLmVtaXQoYXJncyk7XG5cbiAgICAgICAgaWYgKGFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLmVuZEVkaXQoZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuX3Bpbm5lZCA9IHRydWU7XG4gICAgICAgIHRoaXMucGlubmVkQ2hhbmdlLmVtaXQodGhpcy5fcGlubmVkKTtcbiAgICAgICAgLy8gaXQgaXMgcG9zc2libGUgdGhhdCBpbmRleCBpcyB0aGUgbGFzdCBwb3NpdGlvbiwgc28gd2lsbCBuZWVkIHRvIGZpbmQgdGFyZ2V0IGNvbHVtbiBieSBbaW5kZXgtMV1cbiAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gYXJncy5pbnNlcnRBdEluZGV4ID09PSBncmlkLl9waW5uZWRDb2x1bW5zLmxlbmd0aCA/XG4gICAgICAgICAgICBncmlkLl9waW5uZWRDb2x1bW5zW2FyZ3MuaW5zZXJ0QXRJbmRleCAtIDFdIDogZ3JpZC5fcGlubmVkQ29sdW1uc1thcmdzLmluc2VydEF0SW5kZXhdO1xuXG4gICAgICAgIGlmIChncmlkLl9waW5uZWRDb2x1bW5zLmluZGV4T2YodGhpcykgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoIWdyaWQuaGFzQ29sdW1uR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5fcGlubmVkQ29sdW1ucy5zcGxpY2UoYXJncy5pbnNlcnRBdEluZGV4LCAwLCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGJhc2VkIG9ubHkgb24gcm9vdCBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgcm9vdFBpbm5lZENvbHMuc3BsaWNlKGFyZ3MuaW5zZXJ0QXRJbmRleCwgMCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgbGV0IGFsbFBpbm5lZCA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIHJlLWNyZWF0ZSBoaWVyYXJjaHlcbiAgICAgICAgICAgICAgICByb290UGlubmVkQ29scy5mb3JFYWNoKGdyb3VwID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWxsUGlubmVkLnB1c2goZ3JvdXApO1xuICAgICAgICAgICAgICAgICAgICBhbGxQaW5uZWQgPSBhbGxQaW5uZWQuY29uY2F0KGdyb3VwLmFsbENoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBncmlkLl9waW5uZWRDb2x1bW5zID0gYWxsUGlubmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JpZC5fdW5waW5uZWRDb2x1bW5zLmluZGV4T2YodGhpcykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5Db3VudCA9IHRoaXMuYWxsQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGdyaWQuX3VucGlubmVkQ29sdW1ucy5zcGxpY2UoZ3JpZC5fdW5waW5uZWRDb2x1bW5zLmluZGV4T2YodGhpcyksIDEgKyBjaGlsZHJlbkNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNJbmRleCkge1xuICAgICAgICAgICAgZ3JpZC5fbW92ZUNvbHVtbnModGhpcywgdGFyZ2V0Q29sdW1uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLmFsbENoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQucGluKCkpO1xuICAgICAgICAgICAgZ3JpZC5yZWluaXRQaW5TdGF0ZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQucmVzZXRDYWNoZXMoKTtcbiAgICAgICAgZ3JpZC5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxheW91dENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuY29sdW1ucy5maWx0ZXIoeCA9PiB4LmNvbHVtbkxheW91dCkuZm9yRWFjaCh4ID0+IHgucG9wdWxhdGVWaXNpYmxlSW5kZXhlcygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyaWQuZmlsdGVyaW5nU2VydmljZS5yZWZyZXNoRXhwcmVzc2lvbnMoKTtcbiAgICAgICAgY29uc3QgZXZlbnRBcmdzOiBJUGluQ29sdW1uRXZlbnRBcmdzID0geyBjb2x1bW46IHRoaXMsIGluc2VydEF0SW5kZXg6IGluZGV4LCBpc1Bpbm5lZDogdHJ1ZSB9O1xuICAgICAgICB0aGlzLmdyaWQuY29sdW1uUGlubmVkLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucGlucyB0aGUgY29sdW1uIGFuZCBwbGFjZSBpdCBhdCB0aGUgcHJvdmlkZWQgaW5kZXggaW4gdGhlIHVucGlubmVkIGFyZWEuXG4gICAgICogRGVmYXVsdHMgdG8gaW5kZXggYDBgIGlmIG5vdCBwcm92aWRlZCwgb3IgdG8gdGhlIGluaXRpYWwgaW5kZXggaW4gdGhlIHVucGlubmVkIGFyZWEuXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbHVtbiBpcyBzdWNjZXNzZnVsbHkgdW5waW5uZWQuIFJldHVybnMgYGZhbHNlYCBpZiB0aGUgY29sdW1uIGNhbm5vdCBiZSB1bnBpbm5lZC5cbiAgICAgKiBDb2x1bW4gY2Fubm90IGJlIHVucGlubmVkIGlmOlxuICAgICAqIC0gSXMgYWxyZWFkeSB1bnBpbm5lZFxuICAgICAqIC0gaW5kZXggYXJndW1lbnQgaXMgb3V0IG9mIHJhbmdlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzdWNjZXNzID0gdGhpcy5jb2x1bW4udW5waW4oKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgdW5waW4oaW5kZXg/OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZ3JpZCA9ICh0aGlzLmdyaWQgYXMgYW55KTtcbiAgICAgICAgaWYgKCF0aGlzLl9waW5uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5waW5uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcExldmVsUGFyZW50LnVucGluKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNJbmRleCA9IGluZGV4ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChoYXNJbmRleCAmJiAoaW5kZXggPCAwIHx8IGluZGV4ID4gZ3JpZC5fdW5waW5uZWRDb2x1bW5zLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVzdGltYXRlIHRoZSBleGFjdCBpbmRleCBhdCB3aGljaCBjb2x1bW4gd2lsbCBiZSBpbnNlcnRlZFxuICAgICAgICAvLyB0YWtlcyBpbnRvIGFjY291bnQgaW5pdGlhbCB1bnBpbm5lZCBpbmRleCBvZiB0aGUgY29sdW1uXG4gICAgICAgIGlmICghaGFzSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBncmlkLnVucGlubmVkQ29sdW1ucy5tYXAoY29sID0+IGNvbC5pbmRleCk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godGhpcy5pbmRleCk7XG4gICAgICAgICAgICBpbmRpY2VzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kaWNlcy5pbmRleE9mKHRoaXMuaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXJnczogSVBpbkNvbHVtbkNhbmNlbGxhYmxlRXZlbnRBcmdzID0geyBjb2x1bW46IHRoaXMsIGluc2VydEF0SW5kZXg6IGluZGV4LCBpc1Bpbm5lZDogdHJ1ZSwgY2FuY2VsOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLmdyaWQub25Db2x1bW5QaW5uaW5nLmVtaXQoYXJncyk7XG5cbiAgICAgICAgaWYgKGFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdyaWQuZW5kRWRpdChmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5fcGlubmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGlubmVkQ2hhbmdlLmVtaXQodGhpcy5fcGlubmVkKTtcblxuICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGF0IGluZGV4IGlzIHRoZSBsYXN0IHBvc2l0aW9uLCBzbyB3aWxsIG5lZWQgdG8gZmluZCB0YXJnZXQgY29sdW1uIGJ5IFtpbmRleC0xXVxuICAgICAgICBjb25zdCB0YXJnZXRDb2x1bW4gPSBhcmdzLmluc2VydEF0SW5kZXggPT09IGdyaWQuX3VucGlubmVkQ29sdW1ucy5sZW5ndGggP1xuICAgICAgICAgICAgZ3JpZC5fdW5waW5uZWRDb2x1bW5zW2FyZ3MuaW5zZXJ0QXRJbmRleCAtIDFdIDogZ3JpZC5fdW5waW5uZWRDb2x1bW5zW2FyZ3MuaW5zZXJ0QXRJbmRleF07XG5cbiAgICAgICAgaWYgKCFoYXNJbmRleCkge1xuICAgICAgICAgICAgZ3JpZC5fdW5waW5uZWRDb2x1bW5zLnNwbGljZShpbmRleCwgMCwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoZ3JpZC5fcGlubmVkQ29sdW1ucy5pbmRleE9mKHRoaXMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGdyaWQuX3Bpbm5lZENvbHVtbnMuc3BsaWNlKGdyaWQuX3Bpbm5lZENvbHVtbnMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzSW5kZXgpIHtcbiAgICAgICAgICAgIGdyaWQubW92ZUNvbHVtbih0aGlzLCB0YXJnZXRDb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuYWxsQ2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC51bnBpbigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQucmVpbml0UGluU3RhdGVzKCk7XG4gICAgICAgIGdyaWQucmVzZXRDYWNoZXMoKTtcblxuICAgICAgICBncmlkLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5jb2x1bW5zLmZpbHRlcih4ID0+IHguY29sdW1uTGF5b3V0KS5mb3JFYWNoKHggPT4geC5wb3B1bGF0ZVZpc2libGVJbmRleGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JpZC5maWx0ZXJpbmdTZXJ2aWNlLnJlZnJlc2hFeHByZXNzaW9ucygpO1xuXG4gICAgICAgIHRoaXMuZ3JpZC5jb2x1bW5QaW5uZWQuZW1pdCh7IGNvbHVtbjogdGhpcywgaW5zZXJ0QXRJbmRleDogaW5kZXgsIGlzUGlubmVkOiBmYWxzZSB9KTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGNvbHVtbiB0byB0aGUgc3BlY2lmaWVkIHZpc2libGUgaW5kZXguXG4gICAgICogSWYgcGFzc2VkIGluZGV4IGlzIGludmFsaWQsIG9yIGlmIGNvbHVtbiB3b3VsZCByZWNlaXZlIGEgZGlmZmVyZW50IHZpc2libGUgaW5kZXggYWZ0ZXIgbW92aW5nLCBtb3ZpbmcgaXMgbm90IHBlcmZvcm1lZC5cbiAgICAgKiBJZiBwYXNzZWQgaW5kZXggd291bGQgbW92ZSB0aGUgY29sdW1uIHRvIGEgZGlmZmVyZW50IGNvbHVtbiBncm91cC4gbW92aW5nIGlzIG5vdCBwZXJmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb2x1bW4ubW92ZShpbmRleCk7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBtb3ZlKGluZGV4OiBudW1iZXIpIHtcbiAgICAgICAgbGV0IHRhcmdldDtcbiAgICAgICAgY29uc3QgZ3JpZCA9ICh0aGlzLmdyaWQgYXMgSWd4R3JpZEJhc2VEaXJlY3RpdmUpO1xuICAgICAgICBsZXQgY29sdW1uczogQXJyYXk8SWd4Q29sdW1uQ29tcG9uZW50IHwgSWd4Q29sdW1uR3JvdXBDb21wb25lbnQ+ID0gZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjID0+IGMudmlzaWJsZUluZGV4ID4gLTEpO1xuICAgICAgICAvLyBncmlkIGxhc3QgdmlzaWJsZSBpbmRleFxuICAgICAgICBjb25zdCBsaSA9IGNvbHVtbnMubWFwKGMgPT4gYy52aXNpYmxlSW5kZXgpLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5tYXgoYSwgYikpO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgY29uc3QgaXNQcmVjZWRpbmcgPSB0aGlzLnZpc2libGVJbmRleCA8IGluZGV4O1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy52aXNpYmxlSW5kZXggfHwgaW5kZXggPCAwIHx8IGluZGV4ID4gbGkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSBjb2x1bW5zLmZpbHRlcihjID0+IGMubGV2ZWwgPj0gdGhpcy5sZXZlbCAmJiBjICE9PSB0aGlzICYmIGMucGFyZW50ICE9PSB0aGlzICYmXG4gICAgICAgICAgICAgICAgYy50b3BMZXZlbFBhcmVudCA9PT0gdGhpcy50b3BMZXZlbFBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgICAvLyBJZiBpc1ByZWNlZGluZywgZmluZCBhIHRhcmdldCBzdWNoIHRoYXQgd2hlbiB0aGUgY3VycmVudCBjb2x1bW4gaXMgcGxhY2VkIGFmdGVyIGl0LCBjdXJyZW50IGNvbHVtbW4gd2lsbCByZWNlaXZlIGEgdmlzaWJsZUluZGV4ID09PSBpbmRleC4gVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgdmlzaWJsZSBjaGlsZHJlbiBvZiB0aGUgY29sdW1ucy5cbiAgICAgICAgLy8gSWYgIWlzUHJlY2VkaW5nLCBmaW5kcyBhIGNvbHVtbiBvZiB0aGUgc2FtZSBsZXZlbCBhbmQgdmlzaWJsZSBpbmRleCB0aGF0IGVxdWFscyB0aGUgcGFzc2VkIGluZGV4IGFndW1lbnQgKGMudmlzaWJsZUluZGV4ID09PSBpbmRleCkuIE5vIG5lZWQgdG8gY29uc2lkZXIgdGhlIGNoaWxkcmVuIGhlcmUuXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICAgICAgICBpZiAoaXNQcmVjZWRpbmcpIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSBjb2x1bW5zLmZpbHRlcihjID0+IGMudmlzaWJsZUluZGV4ID4gdGhpcy52aXNpYmxlSW5kZXgpO1xuICAgICAgICAgICAgdGFyZ2V0ID0gY29sdW1ucy5maW5kKGMgPT4gYy5sZXZlbCA9PT0gdGhpcy5sZXZlbCAmJiBjLnZpc2libGVJbmRleCArIGMuY2FsY0NoaWxkcmVuKCkgLSB0aGlzLmNhbGNDaGlsZHJlbigpID09PSBpbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoYyA9PiBjLnZpc2libGVJbmRleCA8IHRoaXMudmlzaWJsZUluZGV4KTtcbiAgICAgICAgICAgIHRhcmdldCA9IGNvbHVtbnMuZmluZChjID0+IGMubGV2ZWwgPT09IHRoaXMubGV2ZWwgJiYgYy52aXNpYmxlSW5kZXggPT09IGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICh0YXJnZXQucGlubmVkICYmIHRoaXMuZGlzYWJsZVBpbm5pbmcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwb3MgPSBpc1ByZWNlZGluZyA/IERyb3BQb3NpdGlvbi5BZnRlckRyb3BUYXJnZXQgOiBEcm9wUG9zaXRpb24uQmVmb3JlRHJvcFRhcmdldDtcbiAgICAgICAgZ3JpZC5tb3ZlQ29sdW1uKHRoaXMsIHRhcmdldCBhcyBJZ3hDb2x1bW5Db21wb25lbnQsIHBvcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm8gY2hpbGRyZW4gZm9yIHRoZSBjb2x1bW4sIHNvIHdpbGwgcmV0dXJucyAxIG9yIDAsIGlmIHRoZSBjb2x1bW4gaXMgaGlkZGVuLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBjYWxjQ2hpbGRyZW4oKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmhpZGRlbiA/IDAgOiAxO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBjb2x1bW4gdmliaXNpbGl0eSBhbmQgZW1pdHMgdGhlIHJlc3BlY3RpdmUgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZVZpc2liaWxpdHkodmFsdWU/OiBib29sZWFuKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPz8gIXRoaXMuaGlkZGVuO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElDb2x1bW5WaXNpYmlsaXR5Q2hhbmdpbmdFdmVudEFyZ3MgPSB7IGNvbHVtbjogdGhpcywgbmV3VmFsdWUsIGNhbmNlbDogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5ncmlkLmNvbHVtblZpc2liaWxpdHlDaGFuZ2luZy5lbWl0KGV2ZW50QXJncyk7XG5cbiAgICAgICAgaWYgKGV2ZW50QXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpZGRlbiA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLmdyaWQub25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlZC5lbWl0KHsgY29sdW1uOiB0aGlzLCBuZXdWYWx1ZSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AgbGV2ZWwgcGFyZW50IGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHRvcExldmVsUGFyZW50ID0gIHRoaXMuY29sdW1uLnRvcExldmVsUGFyZW50O1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCB0b3BMZXZlbFBhcmVudCgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBoZWFkZXIgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbiA9IHRoaXMuZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjID0+IGMuZmllbGQgPT09ICdJRCcpWzBdO1xuICAgICAqIGxldCBoZWFkZXJDZWxsID0gY29sdW1uLmhlYWRlckNlbGw7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGhlYWRlckNlbGwoKTogSWd4R3JpZEhlYWRlckNvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuaGVhZGVyQ2VsbExpc3QuZmluZCgoaGVhZGVyKSA9PiBoZWFkZXIuY29sdW1uID09PSB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBmaWx0ZXIgY2VsbCBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4gICAgICogbGV0IGZpbHRlcmVsbCA9IGNvbHVtbi5maWx0ZXJlbGw7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGZpbHRlckNlbGwoKTogSWd4R3JpZEZpbHRlcmluZ0NlbGxDb21wb25lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmZpbHRlckNlbGxMaXN0LmZpbmQoKGZpbHRlckNlbGwpID0+IGZpbHRlckNlbGwuY29sdW1uID09PSB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBoZWFkZXIgZ3JvdXAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgaGVhZGVyR3JvdXAoKTogSWd4R3JpZEhlYWRlckdyb3VwQ29tcG9uZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5oZWFkZXJHcm91cHNMaXN0LmZpbmQoKGhlYWRlckdyb3VwKSA9PiBoZWFkZXJHcm91cC5jb2x1bW4gPT09IHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF1dG9zaXplIHRoZSBjb2x1bW4gdG8gdGhlIGxvbmdlc3QgY3VycmVudGx5IHZpc2libGUgY2VsbCB2YWx1ZSwgaW5jbHVkaW5nIHRoZSBoZWFkZXIgY2VsbC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZCgnZ3JpZCcpIGdyaWQ6IElneEdyaWRDb21wb25lbnQ7XG4gICAgICogbGV0IGNvbHVtbiA9IHRoaXMuZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjID0+IGMuZmllbGQgPT09ICdJRCcpWzBdO1xuICAgICAqIGNvbHVtbi5hdXRvc2l6ZSgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqIEBwYXJhbSBieUhlYWRlciBTZXQgaWYgY29sdW1uIHNob3VsZCBiZSBhdXRpemVkIGJhc2VkIG9ubHkgb24gdGhlIGhlYWRlciBjb250ZW50XG4gICAgICovXG4gICAgcHVibGljIGF1dG9zaXplKGJ5SGVhZGVyID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRBdXRvU2l6ZShieUhlYWRlcik7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5yZWZsb3coKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0QXV0b1NpemUoYnlIZWFkZXIgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzaXplID0gIWJ5SGVhZGVyID8gdGhpcy5nZXRMYXJnZXN0Q2VsbFdpZHRoKCkgOlxuICAgICAgICAgICAgKE9iamVjdC52YWx1ZXModGhpcy5nZXRIZWFkZXJDZWxsV2lkdGhzKCkpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpICsgJ3B4Jyk7XG4gICAgICAgIGNvbnN0IGdyaWRBdmFpbGFibGVTaXplID0gdGhpcy5ncmlkLmNhbGNXaWR0aDtcbiAgICAgICAgbGV0IG5ld1dpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IHRoaXMud2lkdGggJiYgdHlwZW9mIHRoaXMud2lkdGggPT09ICdzdHJpbmcnICYmIHRoaXMud2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgaWYgKGlzUGVyY2VudGFnZVdpZHRoKSB7XG4gICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlU2l6ZSA9ICBwYXJzZUZsb2F0KHNpemUpIC8gZ3JpZEF2YWlsYWJsZVNpemUgKiAxMDA7XG4gICAgICAgICAgICBuZXdXaWR0aCA9IHBlcmNlbnRhZ2VTaXplICsgJyUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3V2lkdGggPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdXaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldENhbGNXaWR0aCgpOiBhbnkge1xuICAgICAgICBpZiAodGhpcy5fY2FsY1dpZHRoICYmICFpc05hTih0aGlzLmNhbGNQaXhlbFdpZHRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGNXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlQ2FsY1dpZHRoKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjV2lkdGg7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggYW5kIHBhZGRpbmcgb2YgYSBoZWFkZXIgY2VsbC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0SGVhZGVyQ2VsbFdpZHRocygpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLmdyaWQuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgbGV0IGhlYWRlcldpZHRoO1xuICAgICAgICBpZiAodGhpcy5oZWFkZXJUZW1wbGF0ZSAmJiB0aGlzLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGhlYWRlcldpZHRoID0gTWF0aC5tYXgoLi4uQXJyYXkuZnJvbSh0aGlzLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIC5tYXAoKGNoaWxkKSA9PiBnZXROb2RlU2l6ZVZpYVJhbmdlKHJhbmdlLCBjaGlsZCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRlcldpZHRoID0gZ2V0Tm9kZVNpemVWaWFSYW5nZShyYW5nZSwgdGhpcy5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zb3J0YWJsZSB8fCB0aGlzLmZpbHRlcmFibGUpIHtcbiAgICAgICAgICAgIGhlYWRlcldpZHRoICs9IHRoaXMuaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoZWFkZXJTdHlsZSA9IHRoaXMuZ3JpZC5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBjb25zdCBoZWFkZXJQYWRkaW5nID0gcGFyc2VGbG9hdChoZWFkZXJTdHlsZS5wYWRkaW5nTGVmdCkgKyBwYXJzZUZsb2F0KGhlYWRlclN0eWxlLnBhZGRpbmdSaWdodCkgK1xuICAgICAgICAgICAgcGFyc2VGbG9hdChoZWFkZXJTdHlsZS5ib3JkZXJSaWdodFdpZHRoKTtcblxuICAgICAgICAvLyBUYWtlIGludG8gY29uc2lkZXJhdGlvbiB0aGUgaGVhZGVyIGdyb3VwIGVsZW1lbnQsIHNpbmNlIGNvbHVtbiBwaW5uaW5nIGFwcGxpZXMgYm9yZGVycyB0byBpdCBpZiBpdHMgbm90IGEgY29sdW1uR3JvdXAuXG4gICAgICAgIGNvbnN0IGhlYWRlckdyb3VwU3R5bGUgPSB0aGlzLmdyaWQuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmhlYWRlckdyb3VwLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGJvcmRlclNpemUgPSAhdGhpcy5wYXJlbnQgPyBwYXJzZUZsb2F0KGhlYWRlckdyb3VwU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCkgKyBwYXJzZUZsb2F0KGhlYWRlckdyb3VwU3R5bGUuYm9yZGVyTGVmdFdpZHRoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IE1hdGguY2VpbChoZWFkZXJXaWR0aCksIHBhZGRpbmc6IE1hdGguY2VpbChoZWFkZXJQYWRkaW5nICsgYm9yZGVyU2l6ZSl9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIChpbiBwaXhlbHMpIG9mIHRoZSBsb25nZXN0IGN1cnJlbnRseSB2aXNpYmxlIGNlbGwsIGluY2x1ZGluZyB0aGUgaGVhZGVyIGNlbGwuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoJ2dyaWQnKSBncmlkOiBJZ3hHcmlkQ29tcG9uZW50O1xuICAgICAqXG4gICAgICogbGV0IGNvbHVtbiA9IHRoaXMuZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjID0+IGMuZmllbGQgPT09ICdJRCcpWzBdO1xuICAgICAqIGxldCBzaXplID0gY29sdW1uLmdldExhcmdlc3RDZWxsV2lkdGgoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldExhcmdlc3RDZWxsV2lkdGgoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLmdyaWQuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdCA9IG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2VsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGNlbGxzQ29udGVudFdpZHRocyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2VsbHNbMF0ubmF0aXZlRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxscy5mb3JFYWNoKChjZWxsKSA9PiBjZWxsc0NvbnRlbnRXaWR0aHMucHVzaChjZWxsLmNhbGN1bGF0ZVNpemVUb0ZpdChyYW5nZSkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbHNDb250ZW50V2lkdGhzID0gdGhpcy5jZWxscy5tYXAoKGNlbGwpID0+IGdldE5vZGVTaXplVmlhUmFuZ2UocmFuZ2UsIGNlbGwubmF0aXZlRWxlbWVudCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNlbGxzQ29udGVudFdpZHRocy5pbmRleE9mKE1hdGgubWF4KC4uLmNlbGxzQ29udGVudFdpZHRocykpO1xuICAgICAgICAgICAgY29uc3QgY2VsbFN0eWxlID0gdGhpcy5ncmlkLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5jZWxsc1tpbmRleF0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBjZWxsUGFkZGluZyA9IHBhcnNlRmxvYXQoY2VsbFN0eWxlLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQoY2VsbFN0eWxlLnBhZGRpbmdSaWdodCkgK1xuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoY2VsbFN0eWxlLmJvcmRlckxlZnRXaWR0aCkgKyBwYXJzZUZsb2F0KGNlbGxTdHlsZS5ib3JkZXJSaWdodFdpZHRoKTtcblxuICAgICAgICAgICAgbGFyZ2VzdC5zZXQoTWF0aC5tYXgoLi4uY2VsbHNDb250ZW50V2lkdGhzKSwgY2VsbFBhZGRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyQ2VsbCkge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyQ2VsbFdpZHRocyA9IHRoaXMuZ2V0SGVhZGVyQ2VsbFdpZHRocygpO1xuICAgICAgICAgICAgbGFyZ2VzdC5zZXQoaGVhZGVyQ2VsbFdpZHRocy53aWR0aCwgaGVhZGVyQ2VsbFdpZHRocy5wYWRkaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhcmdlc3RDZWxsID0gTWF0aC5tYXgoLi4uQXJyYXkuZnJvbShsYXJnZXN0LmtleXMoKSkpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChsYXJnZXN0Q2VsbCArIGxhcmdlc3QuZ2V0KGxhcmdlc3RDZWxsKSk7XG5cbiAgICAgICAgaWYgKE51bWJlci5pc05hTih3aWR0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdpZHRoICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q2VsbFdpZHRoKCkge1xuICAgICAgICBjb25zdCBjb2xXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gY29sV2lkdGggJiYgdHlwZW9mIGNvbFdpZHRoID09PSAnc3RyaW5nJyAmJiBjb2xXaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxheW91dENoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sV2lkdGggJiYgIWlzUGVyY2VudGFnZVdpZHRoKSB7XG5cbiAgICAgICAgICAgIGxldCBjZWxsV2lkdGggPSBjb2xXaWR0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2VsbFdpZHRoICE9PSAnc3RyaW5nJyB8fCBjZWxsV2lkdGguZW5kc1dpdGgoJ3B4JykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoICs9ICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjZWxsV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29sV2lkdGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHBvcHVsYXRlVmlzaWJsZUluZGV4ZXMoKSB7IH1cblxuICAgIHByb3RlY3RlZCBnZXRDb2x1bW5TaXplc1N0cmluZyhjaGlsZHJlbjogUXVlcnlMaXN0PElneENvbHVtbkNvbXBvbmVudD4pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmdldEZpbGxlZENoaWxkQ29sdW1uU2l6ZXMoY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gcmVzLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNhY2hlQ2FsY1dpZHRoKCk6IGFueSB7XG4gICAgICAgIGNvbnN0IGdyaWQgPSB0aGlzLmdyaWRBUEkuZ3JpZDtcbiAgICAgICAgY29uc3QgY29sV2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IGNvbFdpZHRoICYmIHR5cGVvZiBjb2xXaWR0aCA9PT0gJ3N0cmluZycgJiYgY29sV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgaWYgKGlzUGVyY2VudGFnZVdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjV2lkdGggPSBwYXJzZUZsb2F0KGNvbFdpZHRoKSAvIDEwMCAqIGdyaWQuY2FsY1dpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKCFjb2xXaWR0aCkge1xuICAgICAgICAgICAgLy8gbm8gd2lkdGhcbiAgICAgICAgICAgIHRoaXMuX2NhbGNXaWR0aCA9IHRoaXMuZGVmYXVsdFdpZHRoIHx8IGdyaWQuZ2V0UG9zc2libGVDb2x1bW5XaWR0aCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2FsY1dpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGNQaXhlbFdpZHRoID0gcGFyc2VGbG9hdCh0aGlzLl9jYWxjV2lkdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2V0RXhwYW5kQ29sbGFwc2VTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5maWx0ZXIoY29sID0+IChjb2wudmlzaWJsZVdoZW5Db2xsYXBzZWQgIT09IHVuZGVmaW5lZCkpLmZvckVhY2goYyA9PiAge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbGxhcHNpYmxlKSB7XG4gICAgICAgICAgICAgICAgYy5oaWRkZW4gPSB0aGlzLmhpZGRlbjsgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYy5oaWRkZW4gPSB0aGlzLl9leHBhbmRlZCA/IGMudmlzaWJsZVdoZW5Db2xsYXBzZWQgOiAhYy52aXNpYmxlV2hlbkNvbGxhcHNlZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2hlY2tDb2xsYXBzaWJsZVN0YXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudmlzaWJsZVdoZW5Db2xsYXBzZWQpO1xuICAgICAgICByZXR1cm4gKGNvbHMuc29tZShjID0+IGMgPT09IHRydWUpICYmIGNvbHMuc29tZShjID0+IGMgPT09IGZhbHNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcGlubmFibGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ncmlkIGFzIGFueSkuX2luaXQgfHwgIXRoaXMucGlubmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGFwcGx5U2VsZWN0YWJsZUNsYXNzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZWxlY3RhYmxlQ2xhc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgYXBwbHlTZWxlY3RhYmxlQ2xhc3ModmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlTZWxlY3RhYmxlQ2xhc3MgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==