import { style, animate, animation, keyframes, AnimationBuilder, useAnimation, trigger, transition } from '@angular/animations';
import { Injectable, Directive, Input, HostListener, NgModule, ɵɵdefineInjectable, ɵɵinject, PLATFORM_ID, Inject, EventEmitter, isDevMode, ElementRef, ComponentFactoryResolver, ApplicationRef, INJECTOR, NgZone, Injector, ChangeDetectorRef, Optional, Output, HostBinding, InjectionToken, Component, ViewContainerRef, ViewChild, TemplateRef, IterableDiffers, ContentChildren, forwardRef, ContentChild, Self, Renderer2, SecurityContext, Pipe, LOCALE_ID, QueryList, ViewChildren, Host, NgModuleRef, ChangeDetectionStrategy, SimpleChange, inject, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { NgModel, FormControlName, NG_VALUE_ACCESSOR, NG_VALIDATORS, CheckboxRequiredValidator, FormsModule, NgControl, ReactiveFormsModule } from '@angular/forms';
import { isPlatformBrowser, DatePipe, DOCUMENT, CommonModule, formatDate, FormatWidth, getLocaleDateFormat, getLocaleCurrencyCode, DecimalPipe, CurrencyPipe, PercentPipe, getCurrencySymbol, getLocaleNumberFormat, NumberFormatStyle } from '@angular/common';
import { Observable, Subject, fromEvent, interval, animationFrameScheduler, noop, merge, pipe, Subscription, timer } from 'rxjs';
import { takeUntil, filter, throttleTime, first as first$1, take, throttle, debounce, tap, switchMap, skipLast, map, shareReplay, debounceTime, pluck } from 'rxjs/operators';
import mergeWith from 'lodash.mergewith';
import ResizeObserver from 'resize-observer-polyfill';
import { __awaiter, __decorate } from 'tslib';
import JSZip from 'jszip';
import { DomSanitizer, HammerGestureConfig, HAMMER_GESTURE_CONFIG, ɵgetDOM } from '@angular/platform-browser';
import { addRow, addChild, pinLeft, unpinLeft, jumpDown, jumpUp, caseSensitive, editor } from '@igniteui/material-icons-extended';
import 'igniteui-trial-watermark';
import { v4 } from 'uuid';

var EaseIn;
(function (EaseIn) {
    EaseIn[EaseIn["Quad"] = `cubic-bezier(0.550, 0.085, 0.680, 0.530)`] = "Quad";
    EaseIn[EaseIn["Cubic"] = `cubic-bezier(0.550, 0.055, 0.675, 0.190)`] = "Cubic";
    EaseIn[EaseIn["Quart"] = `cubic-bezier(0.895, 0.030, 0.685, 0.220)`] = "Quart";
    EaseIn[EaseIn["Quint"] = `cubic-bezier(0.755, 0.050, 0.855, 0.060)`] = "Quint";
    EaseIn[EaseIn["Sine"] = `cubic-bezier(0.470, 0.000, 0.745, 0.715)`] = "Sine";
    EaseIn[EaseIn["Expo"] = `cubic-bezier(0.950, 0.050, 0.795, 0.035)`] = "Expo";
    EaseIn[EaseIn["Circ"] = `cubic-bezier(0.600, 0.040, 0.980, 0.335)`] = "Circ";
    EaseIn[EaseIn["Back"] = `cubic-bezier(0.600, -0.280, 0.735, 0.045)`] = "Back";
})(EaseIn || (EaseIn = {}));
var EaseOut;
(function (EaseOut) {
    EaseOut[EaseOut["Quad"] = `cubic-bezier(0.250, 0.460, 0.450, 0.940)`] = "Quad";
    EaseOut[EaseOut["Cubic"] = `cubic-bezier(0.215, 0.610, 0.355, 1.000)`] = "Cubic";
    EaseOut[EaseOut["Quart"] = `cubic-bezier(0.165, 0.840, 0.440, 1.000)`] = "Quart";
    EaseOut[EaseOut["Quint"] = `cubic-bezier(0.230, 1.000, 0.320, 1.000)`] = "Quint";
    EaseOut[EaseOut["Sine"] = `cubic-bezier(0.390, 0.575, 0.565, 1.000)`] = "Sine";
    EaseOut[EaseOut["Expo"] = `cubic-bezier(0.190, 1.000, 0.220, 1.000)`] = "Expo";
    EaseOut[EaseOut["Circ"] = `cubic-bezier(0.075, 0.820, 0.165, 1.000)`] = "Circ";
    EaseOut[EaseOut["Back"] = `cubic-bezier(0.175, 0.885, 0.320, 1.275)`] = "Back";
})(EaseOut || (EaseOut = {}));
var EaseInOut;
(function (EaseInOut) {
    EaseInOut[EaseInOut["Quad"] = `cubic-bezier(0.455, 0.030, 0.515, 0.955)`] = "Quad";
    EaseInOut[EaseInOut["Cubic"] = `cubic-bezier(0.645, 0.045, 0.355, 1.000)`] = "Cubic";
    EaseInOut[EaseInOut["Quart"] = `cubic-bezier(0.770, 0.000, 0.175, 1.000)`] = "Quart";
    EaseInOut[EaseInOut["Quint"] = `cubic-bezier(0.860, 0.000, 0.070, 1.000)`] = "Quint";
    EaseInOut[EaseInOut["Sine"] = `cubic-bezier(0.445, 0.050, 0.550, 0.950)`] = "Sine";
    EaseInOut[EaseInOut["Expo"] = `cubic-bezier(1.000, 0.000, 0.000, 1.000)`] = "Expo";
    EaseInOut[EaseInOut["Circ"] = `cubic-bezier(0.785, 0.135, 0.150, 0.860)`] = "Circ";
    EaseInOut[EaseInOut["Back"] = `cubic-bezier(0.680, -0.550, 0.265, 1.550)`] = "Back";
})(EaseInOut || (EaseInOut = {}));

const base = [
    style({
        opacity: `{{startOpacity}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{endOpacity}}`
    }))
];
const baseParams = {
    delay: '0s',
    duration: '350ms',
    easing: EaseOut.Sine,
    endOpacity: 1,
    startOpacity: 0
};
const fadeIn = animation(base, {
    params: baseParams
});
const fadeOut = animation(base, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.Sine,
        endOpacity: 0,
        startOpacity: 1
    }
});

const baseRecipe = [
    style({
        backfaceVisibility: 'hidden',
        transformStyle: 'preserve-3d'
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            offset: 0,
            transform: `translateZ({{startDistance}})
                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{startAngle}}deg)`
        }),
        style({
            offset: 1,
            transform: `translateZ({{endDistance}})
                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{endAngle}}deg)`
        })
    ]))
];
const baseParams$1 = {
    delay: '0s',
    duration: '600ms',
    easing: EaseOut.Quad,
    endAngle: 180,
    endDistance: '0px',
    rotateX: 1,
    rotateY: 0,
    rotateZ: 0,
    startAngle: 0,
    startDistance: '0px'
};
const flipTop = animation(baseRecipe, {
    params: Object.assign({}, baseParams$1)
});
const flipBottom = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endAngle: -180 })
});
const flipLeft = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { rotateX: 0, rotateY: 1 })
});
const flipRight = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endAngle: -180, rotateX: 0, rotateY: 1 })
});
const flipHorFwd = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '170px' })
});
const flipHorBck = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '-170px' })
});
const flipVerFwd = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '170px', rotateX: 0, rotateY: 1 })
});
const flipVerBck = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '-170px', rotateX: 0, rotateY: 1 })
});

const baseRecipe$1 = [
    style({
        opacity: `{{startOpacity}}`,
        transform: `rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{startAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        offset: 0,
        opacity: `{{endOpacity}}`,
        transform: `rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{endAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }))
];
const baseInParams = {
    delay: '0s',
    duration: '600ms',
    easing: EaseOut.Quad,
    endAngle: 0,
    endOpacity: 1,
    rotateX: 0,
    rotateY: 0,
    rotateZ: 1,
    startAngle: -360,
    startOpacity: 0,
    xPos: 'center',
    yPos: 'center'
};
const baseOutParams = Object.assign(Object.assign({}, baseInParams), { easing: EaseIn.Quad, endOpacity: 0, startOpacity: 1 });
const rotateInCenter = animation(baseRecipe$1, {
    params: Object.assign({}, baseInParams)
});
const rotateOutCenter = animation(baseRecipe$1, {
    params: Object.assign({}, baseOutParams)
});
const rotateInTop = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'top' })
});
const rotateOutTop = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'top' })
});
const rotateInRight = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'right' })
});
const rotateOutRight = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'right' })
});
const rotateInBottom = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'bottom' })
});
const rotateOutBottom = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'bottom' })
});
const rotateInLeft = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'left' })
});
const rotateOutLeft = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'left' })
});
const rotateInTr = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'right', yPos: 'top' })
});
const rotateOutTr = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'right', yPos: 'top' })
});
const rotateInBr = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'right', yPos: 'bottom' })
});
const rotateOutBr = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'right', yPos: 'bottom' })
});
const rotateInBl = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'left', yPos: 'bottom' })
});
const rotateOutBl = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'left', yPos: 'bottom' })
});
const rotateInTl = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'left', yPos: 'top' })
});
const rotateOutTl = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'left', yPos: 'top' })
});
const rotateInDiagonal1 = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { rotateX: 1, rotateY: 1, rotateZ: 0 })
});
const rotateOutDiagonal1 = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { rotateX: 1, rotateY: 1, rotateZ: 0 })
});
const rotateInDiagonal2 = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { rotateX: -1, rotateY: 1, rotateZ: 0 })
});
const rotateOutDiagonal2 = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { rotateX: -1, rotateY: 1, rotateZ: 0 })
});
const rotateInHor = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { rotateX: 0, rotateY: 1, rotateZ: 0 })
});
const rotateOutHor = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { rotateX: 0, rotateY: 1, rotateZ: 0 })
});
const rotateInVer = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { rotateX: 1, rotateY: 0, rotateZ: 0 })
});
const rotateOutVer = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { rotateX: 1, rotateY: 0, rotateZ: 0 })
});

const baseRecipe$2 = [
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            offset: 0,
            transform: `rotate(0deg) translate{{direction}}(0)`,
            transformOrigin: `{{xPos}} {{yPos}}`
        }),
        style({
            offset: 0.1,
            transform: `rotate({{endAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        style({
            offset: 0.2,
            transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`
        }),
        style({
            offset: 0.3,
            transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        style({
            offset: 0.4,
            transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`
        }),
        style({
            offset: 0.5,
            transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        style({
            offset: 0.6,
            transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`
        }),
        style({
            offset: 0.7,
            transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        style({
            offset: 0.8,
            transform: `rotate(-{{endAngle}}deg) translate{{direction}}({{endDistance}})`
        }),
        style({
            offset: 0.9,
            transform: `rotate({{endAngle}}deg) translate{{direction}}(-{{endDistance}})`
        }),
        style({
            offset: 1,
            transform: `rotate(0deg) translate{{direction}}(0)`,
            transformOrigin: `{{xPos}} {{yPos}}`
        })
    ]))
];
const baseParams$2 = {
    delay: '0s',
    direction: 'X',
    duration: '800ms',
    easing: EaseInOut.Quad,
    endAngle: 0,
    endDistance: '8px',
    startAngle: 0,
    startDistance: '10px',
    xPos: 'center',
    yPos: 'center'
};
const shakeHor = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'X' })
});
const shakeVer = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y' })
});
const shakeTop = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'top' })
});
const shakeBottom = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'bottom' })
});
const shakeRight = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'center' })
});
const shakeLeft = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'center' })
});
const shakeCenter = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 8, endDistance: '0', startAngle: 10, startDistance: '0', xPos: 'center', yPos: 'center' })
});
const shakeTr = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'top' })
});
const shakeBr = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'bottom' })
});
const shakeBl = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'bottom' })
});
const shakeTl = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'top' })
});

const heartbeatBase = [
    style({
        animationTimingFunction: `ease-out`,
        transform: `scale(1)`,
        transformOrigin: `center center`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            animationTimingFunction: `ease-in`,
            offset: 0.1,
            transform: `scale(0.91)`
        }),
        style({
            animationTimingFunction: `ease-out`,
            offset: 0.17,
            transform: `scale(0.98)`
        }),
        style({
            animationTimingFunction: `ease-in`,
            offset: 0.33,
            transform: `scale(0.87)`
        }),
        style({
            animationTimingFunction: `ease-out`,
            offset: 0.45,
            transform: `scale(1)`
        })
    ]))
];
const heartbeatParams = {
    delay: '0s',
    duration: '1.5s',
    easing: 'ease-in-out'
};
const pulsateBase = [
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            offset: 0,
            transform: `scale({{fromScale}})`
        }),
        style({
            offset: 0.5,
            transform: `scale({{toScale}})`
        }),
        style({
            offset: 1,
            transform: `scale({{fromScale}})`
        })
    ]))
];
const pulsateParams = {
    delay: '0s',
    duration: '.5s',
    easing: 'ease-in-out',
    fromScale: 1,
    toScale: 1.1
};
const blinkBase = [
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            offset: 0,
            opacity: .8,
            transform: `scale({{fromScale}})`
        }),
        style({
            offset: 0.8,
            opacity: 0,
            transform: `scale({{midScale}})`
        }),
        style({
            offset: 1,
            opacity: 0,
            transform: `scale({{toScale}})`
        })
    ]))
];
const blinkParams = {
    delay: '0s',
    duration: '.8s',
    easing: 'ease-in-out',
    fromScale: .2,
    midScale: 1.2,
    toScale: 2.2
};
const pulsateFwd = animation(pulsateBase, {
    params: Object.assign({}, pulsateParams)
});
const pulsateBck = animation(pulsateBase, {
    params: Object.assign(Object.assign({}, pulsateParams), { toScale: .9 })
});
const heartbeat = animation(heartbeatBase, {
    params: Object.assign({}, heartbeatParams)
});
const blink = animation(blinkBase, {
    params: Object.assign({}, blinkParams)
});

const base$1 = [
    style({
        opacity: `{{startOpacity}}`,
        transform: `scale{{direction}}({{fromScale}})`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{endOpacity}}`,
        transform: `scale{{direction}}({{toScale}})`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }))
];
const baseInParams$1 = {
    delay: '0s',
    direction: '',
    duration: '350ms',
    easing: EaseOut.Quad,
    endOpacity: 1,
    fromScale: .5,
    startOpacity: 0,
    toScale: 1,
    xPos: '50%',
    yPos: '50%'
};
const baseOutParams$1 = Object.assign(Object.assign({}, baseInParams$1), { easing: EaseOut.Sine, endOpacity: 0, fromScale: 1, startOpacity: 1, toScale: .5 });
const scaleInCenter = animation(base$1, { params: baseInParams$1 });
const scaleInBl = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '0', yPos: '100%' })
});
const scaleInVerCenter = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'Y', fromScale: .4 })
});
const scaleInTop = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '50%', yPos: '0' })
});
const scaleInLeft = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '0', yPos: '50%' })
});
const scaleInVerTop = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'Y', fromScale: .4, xPos: '100%', yPos: '0' })
});
const scaleInTr = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '100%', yPos: '0' })
});
const scaleInTl = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '0', yPos: '0' })
});
const scaleInVerBottom = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'Y', fromScale: .4, xPos: '0', yPos: '100%' })
});
const scaleInRight = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '100%', yPos: '50%' })
});
const scaleInHorCenter = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'X', fromScale: .4 })
});
const scaleInBr = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '100%', yPos: '100%' })
});
const scaleInHorLeft = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'X', fromScale: .4, xPos: '0', yPos: '0' })
});
const scaleInBottom = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '50%', yPos: '100%' })
});
const scaleInHorRight = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'X', fromScale: .4, xPos: '100%', yPos: '100%' })
});
const scaleOutCenter = animation(base$1, { params: baseOutParams$1 });
const scaleOutBl = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '0', yPos: '100%' })
});
const scaleOutBr = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '100%', yPos: '100%' })
});
const scaleOutVerCenter = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'Y', toScale: .3 })
});
const scaleOutVerTop = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'Y', toScale: .3, xPos: '100%', yPos: '0' })
});
const scaleOutVerBottom = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'Y', toScale: .3, xPos: '0', yPos: '100%' })
});
const scaleOutTop = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '50%', yPos: '0' })
});
const scaleOutLeft = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '0', yPos: '50%' })
});
const scaleOutTr = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '100%', yPos: '0' })
});
const scaleOutTl = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '0', yPos: '0' })
});
const scaleOutRight = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '100%', yPos: '50%' })
});
const scaleOutBottom = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '50%', yPos: '100%' })
});
const scaleOutHorCenter = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'X', toScale: .3 })
});
const scaleOutHorLeft = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'X', toScale: .3, xPos: '0', yPos: '0' })
});
const scaleOutHorRight = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'X', toScale: .3, xPos: '100%', yPos: '100%' })
});

const base$2 = [
    style({
        opacity: `{{startOpacity}}`,
        transform: `{{fromPosition}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{endOpacity}}`,
        transform: `{{toPosition}}`
    }))
];
const baseInParams$2 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseOut.Quad,
    endOpacity: 1,
    fromPosition: 'translateY(-500px)',
    startOpacity: 0,
    toPosition: 'translateY(0)'
};
const baseOutParams$2 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseIn.Quad,
    endOpacity: 0,
    fromPosition: 'translateY(0)',
    startOpacity: 1,
    toPosition: 'translateY(-500px)'
};
const slideInTop = animation(base$2, { params: baseInParams$2 });
const slideInLeft = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.Quad,
        endOpacity: 1,
        fromPosition: 'translateX(-500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
const slideInRight = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.Quad,
        endOpacity: 1,
        fromPosition: 'translateX(500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
const slideInBottom = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.Quad,
        endOpacity: 1,
        fromPosition: 'translateY(500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
const slideInTr = animation(base$2, {
    params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(-500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
});
const slideInTl = animation(base$2, {
    params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(-500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
});
const slideInBr = animation(base$2, {
    params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
});
const slideInBl = animation(base$2, {
    params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
});
const slideOutTop = animation(base$2, { params: baseOutParams$2 });
const slideOutRight = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { toPosition: 'translateX(500px)' })
});
const slideOutBottom = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseIn.Quad,
        endOpacity: 0,
        fromPosition: 'translateY(0)',
        startOpacity: 1,
        toPosition: 'translateY(500px)'
    }
});
const slideOutLeft = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { toPosition: 'translateX(-500px)' })
});
const slideOutTr = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(500px)' })
});
const slideOutBr = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(500px)' })
});
const slideOutBl = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(-500px)' })
});
const slideOutTl = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(-500px)' })
});

const swingBase = [
    style({
        opacity: `{{startOpacity}}`,
        transform: `rotate{{direction}}({{startAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{endOpacity}}`,
        transform: `rotate{{direction}}({{endAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }))
];
const swingParams = {
    delay: '0s',
    direction: 'X',
    duration: '.5s',
    easing: EaseOut.Back,
    endAngle: 0,
    endOpacity: 1,
    startAngle: -100,
    startOpacity: 0,
    xPos: 'top',
    yPos: 'center'
};
const swingOutParams = Object.assign(Object.assign({}, swingParams), { duration: '.55s', easing: EaseIn.Back, endAngle: 70, endOpacity: 0, startAngle: 0, startOpacity: 1 });
const swingInTopFwd = animation(swingBase, {
    params: Object.assign({}, swingParams)
});
const swingInRightFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', xPos: 'center', yPos: 'right' })
});
const swingInBottomFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { startAngle: 100, xPos: 'bottom' })
});
const swingInLeftFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', startAngle: 100, xPos: 'center', yPos: 'left' })
});
const swingInTopBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { duration: '.6s', startAngle: 70 })
});
const swingInRightBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', duration: '.6s', startAngle: 70, xPos: 'center', yPos: 'right' })
});
const swingInBottomBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { duration: '.6s', startAngle: -70, xPos: 'bottom' })
});
const swingInLeftBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', duration: '.6s', startAngle: -70, xPos: 'center', yPos: 'left' })
});
const swingOutTopFwd = animation(swingBase, {
    params: Object.assign({}, swingOutParams)
});
const swingOutRightFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', xPos: 'center', yPos: 'right' })
});
const swingOutBottomFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { endAngle: -70, xPos: 'bottom' })
});
const swingOutLefttFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', endAngle: -70, xPos: 'center', yPos: 'left' })
});
const swingOutTopBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { duration: '.45s', endAngle: -100 })
});
const swingOutRightBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', duration: '.45s', endAngle: -100, xPos: 'center', yPos: 'right' })
});
const swingOutBottomBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { duration: '.45s', endAngle: 100, xPos: 'bottom' })
});
const swingOutLeftBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', duration: '.45s', endAngle: 100, xPos: 'center', yPos: 'left' })
});

const base$3 = [
    style({
        opacity: `{{ startOpacity }}`,
        height: `{{ startHeight }}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{ endOpacity }}`,
        height: `{{ endHeight }}`
    }))
];
const baseParams$3 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseIn.Quad,
    startOpacity: 0,
    endOpacity: 1,
    startHeight: '',
    endHeight: ''
};
const growVerIn = animation(base$3, {
    params: Object.assign(Object.assign({}, baseParams$3), { easing: EaseOut.Quad, startOpacity: 0, endOpacity: 1, startHeight: '0px', endHeight: '*' })
});
const growVerOut = animation(base$3, {
    params: Object.assign(Object.assign({}, baseParams$3), { easing: EaseOut.Quad, startOpacity: 1, endOpacity: 0, startHeight: '*', endHeight: '0px' })
});

/**
 * Common service to be injected between components where those implementing common
 * ToggleView interface can register and toggle directives can call their methods.
 * TODO: Track currently active? Events?
 */
class IgxNavigationService {
    constructor() {
        this.navs = {};
    }
    add(id, navItem) {
        this.navs[id] = navItem;
    }
    remove(id) {
        delete this.navs[id];
    }
    get(id) {
        if (id) {
            return this.navs[id];
        }
    }
    toggle(id, ...args) {
        if (this.navs[id]) {
            return this.navs[id].toggle(...args);
        }
    }
    open(id, ...args) {
        if (this.navs[id]) {
            return this.navs[id].open(...args);
        }
    }
    close(id, ...args) {
        if (this.navs[id]) {
            return this.navs[id].close(...args);
        }
    }
}
IgxNavigationService.decorators = [
    { type: Injectable }
];
IgxNavigationService.ctorParameters = () => [];

/**
 * Directive that can toggle targets through provided NavigationService.
 *
 * Usage:
 * ```
 * <button igxNavToggle="ID"> Toggle </button>
 * ```
 * Where the `ID` matches the ID of compatible `IToggleView` component.
 */
class IgxNavigationToggleDirective {
    constructor(nav) {
        this.state = nav;
    }
    toggleNavigationDrawer() {
        this.state.toggle(this.target, true);
    }
}
IgxNavigationToggleDirective.decorators = [
    { type: Directive, args: [{ selector: '[igxNavToggle]' },] }
];
IgxNavigationToggleDirective.ctorParameters = () => [
    { type: IgxNavigationService }
];
IgxNavigationToggleDirective.propDecorators = {
    target: [{ type: Input, args: ['igxNavToggle',] }],
    toggleNavigationDrawer: [{ type: HostListener, args: ['click',] }]
};
/**
 * Directive that can close targets through provided NavigationService.
 *
 * Usage:
 * ```
 * <button igxNavClose="ID"> Close </button>
 * ```
 * Where the `ID` matches the ID of compatible `IToggleView` component.
 */
class IgxNavigationCloseDirective {
    constructor(nav) {
        this.state = nav;
    }
    closeNavigationDrawer() {
        this.state.close(this.target, true);
    }
}
IgxNavigationCloseDirective.decorators = [
    { type: Directive, args: [{ selector: '[igxNavClose]' },] }
];
IgxNavigationCloseDirective.ctorParameters = () => [
    { type: IgxNavigationService }
];
IgxNavigationCloseDirective.propDecorators = {
    target: [{ type: Input, args: ['igxNavClose',] }],
    closeNavigationDrawer: [{ type: HostListener, args: ['click',] }]
};
/**
 * @hidden
 */
class IgxNavigationModule {
}
IgxNavigationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                exports: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                providers: [IgxNavigationService]
            },] }
];

/* Copyright (c) 2014-2020 Denis Pushkarev
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE
 */
// Note: Originally copied from core-js-pure package and modified. (https://github.com/zloirock/core-js)
const queue = {};
let counter = 0;
let eventListenerAdded = false;
const run = (id) => {
    if (queue.hasOwnProperty(id)) {
        const fn = queue[id];
        delete queue[id];
        fn();
    }
};
const ɵ0 = run;
const listener = (event) => run(event.data);
const ɵ1 = listener;
// Use function instead of arrow function to workaround an issue in codesandbox
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function setImmediate(cb, ...args) {
    if (window.setImmediate) {
        return window.setImmediate(cb);
    }
    if (!eventListenerAdded) {
        eventListenerAdded = true;
        window.addEventListener('message', listener, false);
    }
    queue[++counter] = () => {
        cb.apply(undefined, args);
    };
    const windowLocation = window.location;
    window.postMessage(counter + '', windowLocation.protocol + '//' + windowLocation.host);
    return counter;
}
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function clearImmediate(id) {
    if (window.clearImmediate) {
        return window.clearImmediate(id);
    }
    delete queue[id];
}

/**
 * @hidden
 */
const cloneArray = (array, deep) => {
    const arr = [];
    if (!array) {
        return arr;
    }
    let i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
};
/**
 * Doesn't clone leaf items
 *
 * @hidden
 */
const cloneHierarchicalArray = (array, childDataKey) => {
    const result = [];
    if (!array) {
        return result;
    }
    for (const item of array) {
        const clonedItem = cloneValue(item);
        if (Array.isArray(item[childDataKey])) {
            clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
        }
        result.push(clonedItem);
    }
    return result;
};
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 *
 * @param obj1 Object to merge into
 * @param obj2 Object to merge from
 * @returns Obj1 with merged cloned keys from Obj2
 * @hidden
 */
const mergeObjects = (obj1, obj2) => mergeWith(obj1, obj2, (objValue, srcValue) => {
    if (Array.isArray(srcValue)) {
        return objValue = srcValue;
    }
});
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 *
 * @param value value to clone
 * @returns Deep copy of provided value
 * @hidden
 */
const cloneValue = (value) => {
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return [...value];
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        const result = {};
        for (const key of Object.keys(value)) {
            result[key] = cloneValue(value[key]);
        }
        return result;
    }
    return value;
};
/**
 * Parse provided input to Date.
 *
 * @param value input to parse
 * @returns Date if parse succeed or null
 * @hidden
 */
const parseDate = (value) => {
    // if value is Invalid Date return null
    if (isDate(value)) {
        return !isNaN(value.getTime()) ? value : null;
    }
    return value ? new Date(value) : null;
};
/**
 * Returns an array with unique dates only.
 *
 * @param columnValues collection of date values (might be numbers or ISO 8601 strings)
 * @returns collection of unique dates.
 * @hidden
 */
const uniqueDates = (columnValues) => columnValues.reduce((a, c) => {
    if (!a.cache[c.label]) {
        a.result.push(c);
    }
    a.cache[c.label] = true;
    return a;
}, { result: [], cache: {} }).result;
/**
 * Checks if provided variable is Object
 *
 * @param value Value to check
 * @returns true if provided variable is Object
 * @hidden
 */
const isObject = (value) => value && value.toString() === '[object Object]';
/**
 * Checks if provided variable is Date
 *
 * @param value Value to check
 * @returns true if provided variable is Date
 * @hidden
 */
const isDate = (value) => value instanceof Date;
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 *
 * @param obj1
 * @param obj2
 * @returns: `boolean`
 * @hidden
 */
const isEqual = (obj1, obj2) => {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
};
/* eslint-enable @typescript-eslint/naming-convention */
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
 * ```
 */
const getNodeSizeViaRange = (range, node) => {
    let overflow = null;
    if (!isFirefox()) {
        overflow = node.style.overflow;
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = 'visible';
    }
    range.selectNodeContents(node);
    const width = range.getBoundingClientRect().width;
    if (!isFirefox()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
    }
    return width;
};
/**
 * @hidden
 * Returns the actual size of the node content, using Canvas
 * ```typescript
 * let ctx = document.createElement('canvas').getContext('2d');
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
 * ```
 */
function getNodeSizeViaCanvas(canvas2dCtx, node) {
    const s = this.grid.document.defaultView.getComputedStyle(node);
    // need to set the font to get correct width
    canvas2dCtx.font = s.fontSize + ' ' + s.fontFamily;
    return canvas2dCtx.measureText(node.textContent).width;
}
/**
 * @hidden
 */
const isIE = () => navigator.appVersion.indexOf('Trident/') > 0;
/**
 * @hidden
 */
const isEdge = () => {
    const edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return edgeBrowser;
};
/**
 * @hidden
 */
const isFirefox = () => {
    const firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return firefoxBrowser;
};
/**
 * @hidden
 */
class PlatformUtil {
    constructor(platformId) {
        this.platformId = platformId;
        this.isBrowser = isPlatformBrowser(this.platformId);
        this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
    }
}
PlatformUtil.ɵprov = ɵɵdefineInjectable({ factory: function PlatformUtil_Factory() { return new PlatformUtil(ɵɵinject(PLATFORM_ID)); }, token: PlatformUtil, providedIn: "root" });
PlatformUtil.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
PlatformUtil.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
/**
 * @hidden
 */
const isLeftClick = (event) => event.button === 0;
/** @hidden */
const isNavigationKey = (key) => [
    'down',
    'up',
    'left',
    'right',
    'arrowdown',
    'arrowup',
    'arrowleft',
    'arrowright',
    'home',
    'end',
    'space',
    'spacebar',
    ' '
].indexOf(key) !== -1;
/**
 * @hidden
 */
const flatten = (arr) => {
    let result = [];
    arr.forEach(el => {
        result.push(el);
        if (el.children) {
            const children = Array.isArray(el.children) ? el.children : el.children.toArray();
            result = result.concat(flatten(children));
        }
    });
    return result;
};
const HORIZONTAL_NAV_KEYS = new Set(['arrowleft', 'left', 'arrowright', 'right', 'home', 'end']);
const NAVIGATION_KEYS = new Set([
    'down',
    'up',
    'left',
    'right',
    'arrowdown',
    'arrowup',
    'arrowleft',
    'arrowright',
    'home',
    'end',
    'space',
    'spacebar',
    ' '
]);
const ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
const ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
const ROW_ADD_KEYS = new Set(['+', 'add', '≠', '±', '=']);
const SUPPORTED_KEYS = new Set([...Array.from(NAVIGATION_KEYS),
    ...Array.from(ROW_ADD_KEYS), 'enter', 'f2', 'escape', 'esc', 'pagedown', 'pageup']);
const HEADER_KEYS = new Set([...Array.from(NAVIGATION_KEYS), 'escape', 'esc', 'l',
    /** This symbol corresponds to the Alt + L combination under MAC. */
    '¬']);
/**
 * @hidden
 * @internal
 *
 * Creates a new ResizeObserver on `target` and returns it as an Observable.
 * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.
 * Related issue: https://github.com/angular/angular/issues/31712
 */
const resizeObservable = (target) => new Observable((observer) => {
    const instance = new ResizeObserver((entries) => {
        observer.next(entries);
    });
    instance.observe(target);
    const unsubscribe = () => instance.disconnect();
    return unsubscribe;
});
/**
 * @hidden
 * @internal
 *
 * Compares two maps.
 */
const compareMaps = (map1, map2) => {
    if (!map2) {
        return !map1 ? true : false;
    }
    if (map1.size !== map2.size) {
        return false;
    }
    let match = true;
    const keys = Array.from(map2.keys());
    for (const key of keys) {
        if (map1.has(key)) {
            match = map1.get(key) === map2.get(key);
        }
        else {
            match = false;
        }
        if (!match) {
            break;
        }
    }
    return match;
};
/**
 *
 * Given a property access path in the format `x.y.z` resolves and returns
 * the value of the `z` property in the passed object.
 *
 * @hidden
 * @internal
 */
const resolveNestedPath = (obj, path) => {
    var _a;
    const parts = (_a = path === null || path === void 0 ? void 0 : path.split('.')) !== null && _a !== void 0 ? _a : [];
    let current = obj[parts.shift()];
    parts.forEach(prop => {
        if (current) {
            current = current[prop];
        }
    });
    return current;
};
/**
 *
 * Given a property access path in the format `x.y.z` and a value
 * this functions builds and returns an object following the access path.
 *
 * @example
 * ```typescript
 * console.log('x.y.z.', 42);
 * >> { x: { y: { z: 42 } } }
 * ```
 *
 * @hidden
 * @internal
 */
const reverseMapper = (path, value) => {
    var _a;
    const obj = {};
    const parts = (_a = path === null || path === void 0 ? void 0 : path.split('.')) !== null && _a !== void 0 ? _a : [];
    let _prop = parts.shift();
    let mapping;
    // Initial binding for first level bindings
    obj[_prop] = value;
    mapping = obj;
    parts.forEach(prop => {
        // Start building the hierarchy
        mapping[_prop] = {};
        // Go down a level
        mapping = mapping[_prop];
        // Bind the value and move the key
        mapping[prop] = value;
        _prop = prop;
    });
    return obj;
};
const yieldingLoop = (count, chunkSize, callback, done) => {
    let i = 0;
    const chunk = () => {
        const end = Math.min(i + chunkSize, count);
        for (; i < end; ++i) {
            callback(i);
        }
        if (i < count) {
            setImmediate(chunk);
        }
        else {
            done();
        }
    };
    chunk();
};
const mkenum = (x) => x;
const reverseAnimationResolver = (animation) => { var _a; return (_a = oppositeAnimation.get(animation)) !== null && _a !== void 0 ? _a : animation; };
const isHorizontalAnimation = (animation) => horizontalAnimations.includes(animation);
const isVerticalAnimation = (animation) => verticalAnimations.includes(animation);
const oppositeAnimation = new Map([
    [fadeIn, fadeIn],
    [fadeOut, fadeOut],
    [flipTop, flipBottom],
    [flipBottom, flipTop],
    [flipRight, flipLeft],
    [flipLeft, flipRight],
    [flipHorFwd, flipHorBck],
    [flipHorBck, flipHorFwd],
    [flipVerFwd, flipVerBck],
    [flipVerBck, flipVerFwd],
    [growVerIn, growVerIn],
    [growVerOut, growVerOut],
    [heartbeat, heartbeat],
    [pulsateFwd, pulsateBck],
    [pulsateBck, pulsateFwd],
    [blink, blink],
    [shakeHor, shakeHor],
    [shakeVer, shakeVer],
    [shakeTop, shakeTop],
    [shakeBottom, shakeBottom],
    [shakeRight, shakeRight],
    [shakeLeft, shakeLeft],
    [shakeCenter, shakeCenter],
    [shakeTr, shakeTr],
    [shakeBr, shakeBr],
    [shakeBl, shakeBl],
    [shakeTl, shakeTl],
    [rotateInCenter, rotateInCenter],
    [rotateOutCenter, rotateOutCenter],
    [rotateInTop, rotateInBottom],
    [rotateOutTop, rotateOutBottom],
    [rotateInRight, rotateInLeft],
    [rotateOutRight, rotateOutLeft],
    [rotateInLeft, rotateInRight],
    [rotateOutLeft, rotateOutRight],
    [rotateInBottom, rotateInTop],
    [rotateOutBottom, rotateOutTop],
    [rotateInTr, rotateInBl],
    [rotateOutTr, rotateOutBl],
    [rotateInBr, rotateInTl],
    [rotateOutBr, rotateOutTl],
    [rotateInBl, rotateInTr],
    [rotateOutBl, rotateOutTr],
    [rotateInTl, rotateInBr],
    [rotateOutTl, rotateOutBr],
    [rotateInDiagonal1, rotateInDiagonal1],
    [rotateOutDiagonal1, rotateOutDiagonal1],
    [rotateInDiagonal2, rotateInDiagonal2],
    [rotateOutDiagonal2, rotateOutDiagonal2],
    [rotateInHor, rotateInHor],
    [rotateOutHor, rotateOutHor],
    [rotateInVer, rotateInVer],
    [rotateOutVer, rotateOutVer],
    [scaleInTop, scaleInBottom],
    [scaleOutTop, scaleOutBottom],
    [scaleInRight, scaleInLeft],
    [scaleOutRight, scaleOutLeft],
    [scaleInBottom, scaleInTop],
    [scaleOutBottom, scaleOutTop],
    [scaleInLeft, scaleInRight],
    [scaleOutLeft, scaleOutRight],
    [scaleInCenter, scaleInCenter],
    [scaleOutCenter, scaleOutCenter],
    [scaleInTr, scaleInBl],
    [scaleOutTr, scaleOutBl],
    [scaleInBr, scaleInTl],
    [scaleOutBr, scaleOutTl],
    [scaleInBl, scaleInTr],
    [scaleOutBl, scaleOutTr],
    [scaleInTl, scaleInBr],
    [scaleOutTl, scaleOutBr],
    [scaleInVerTop, scaleInVerBottom],
    [scaleOutVerTop, scaleOutVerBottom],
    [scaleInVerBottom, scaleInVerTop],
    [scaleOutVerBottom, scaleOutVerTop],
    [scaleInVerCenter, scaleInVerCenter],
    [scaleOutVerCenter, scaleOutVerCenter],
    [scaleInHorCenter, scaleInHorCenter],
    [scaleOutHorCenter, scaleOutHorCenter],
    [scaleInHorLeft, scaleInHorRight],
    [scaleOutHorLeft, scaleOutHorRight],
    [scaleInHorRight, scaleInHorLeft],
    [scaleOutHorRight, scaleOutHorLeft],
    [slideInTop, slideInBottom],
    [slideOutTop, slideOutBottom],
    [slideInRight, slideInLeft],
    [slideOutRight, slideOutLeft],
    [slideInBottom, slideInTop],
    [slideOutBottom, slideOutTop],
    [slideInLeft, slideInRight],
    [slideOutLeft, slideOutRight],
    [slideInTr, slideInBl],
    [slideOutTr, slideOutBl],
    [slideInBr, slideInTl],
    [slideOutBr, slideOutTl],
    [slideInBl, slideInTr],
    [slideOutBl, slideOutTr],
    [slideInTl, slideInBr],
    [slideOutTl, slideOutBr],
    [swingInTopFwd, swingInBottomFwd],
    [swingOutTopFwd, swingOutBottomFwd],
    [swingInRightFwd, swingInLeftFwd],
    [swingOutRightFwd, swingOutLefttFwd],
    [swingInLeftFwd, swingInRightFwd],
    [swingOutLefttFwd, swingOutRightFwd],
    [swingInBottomFwd, swingInTopFwd],
    [swingOutBottomFwd, swingOutTopFwd],
    [swingInTopBck, swingInBottomBck],
    [swingOutTopBck, swingOutBottomBck],
    [swingInRightBck, swingInLeftBck],
    [swingOutRightBck, swingOutLeftBck],
    [swingInBottomBck, swingInTopBck],
    [swingOutBottomBck, swingOutTopBck],
    [swingInLeftBck, swingInRightBck],
    [swingOutLeftBck, swingOutRightBck],
]);
const horizontalAnimations = [
    flipRight,
    flipLeft,
    flipVerFwd,
    flipVerBck,
    rotateInRight,
    rotateOutRight,
    rotateInLeft,
    rotateOutLeft,
    rotateInTr,
    rotateOutTr,
    rotateInBr,
    rotateOutBr,
    rotateInBl,
    rotateOutBl,
    rotateInTl,
    rotateOutTl,
    scaleInRight,
    scaleOutRight,
    scaleInLeft,
    scaleOutLeft,
    scaleInTr,
    scaleOutTr,
    scaleInBr,
    scaleOutBr,
    scaleInBl,
    scaleOutBl,
    scaleInTl,
    scaleOutTl,
    scaleInHorLeft,
    scaleOutHorLeft,
    scaleInHorRight,
    scaleOutHorRight,
    slideInRight,
    slideOutRight,
    slideInLeft,
    slideOutLeft,
    slideInTr,
    slideOutTr,
    slideInBr,
    slideOutBr,
    slideInBl,
    slideOutBl,
    slideInTl,
    slideOutTl,
    swingInRightFwd,
    swingOutRightFwd,
    swingInLeftFwd,
    swingOutLefttFwd,
    swingInRightBck,
    swingOutRightBck,
    swingInLeftBck,
    swingOutLeftBck,
];
const verticalAnimations = [
    flipTop,
    flipBottom,
    flipHorFwd,
    flipHorBck,
    growVerIn,
    growVerOut,
    rotateInTop,
    rotateOutTop,
    rotateInBottom,
    rotateOutBottom,
    rotateInTr,
    rotateOutTr,
    rotateInBr,
    rotateOutBr,
    rotateInBl,
    rotateOutBl,
    rotateInTl,
    rotateOutTl,
    scaleInTop,
    scaleOutTop,
    scaleInBottom,
    scaleOutBottom,
    scaleInTr,
    scaleOutTr,
    scaleInBr,
    scaleOutBr,
    scaleInBl,
    scaleOutBl,
    scaleInTl,
    scaleOutTl,
    scaleInVerTop,
    scaleOutVerTop,
    scaleInVerBottom,
    scaleOutVerBottom,
    slideInTop,
    slideOutTop,
    slideInBottom,
    slideOutBottom,
    slideInTr,
    slideOutTr,
    slideInBr,
    slideOutBr,
    slideInBl,
    slideOutBl,
    slideInTl,
    slideOutTl,
    swingInTopFwd,
    swingOutTopFwd,
    swingInBottomFwd,
    swingOutBottomFwd,
    swingInTopBck,
    swingOutTopBck,
    swingInBottomBck,
    swingOutBottomBck,
];

/**
 * Represents sorting expressions.
 */
var SortingDirection;
(function (SortingDirection) {
    SortingDirection[SortingDirection["None"] = 0] = "None";
    SortingDirection[SortingDirection["Asc"] = 1] = "Asc";
    SortingDirection[SortingDirection["Desc"] = 2] = "Desc";
})(SortingDirection || (SortingDirection = {}));

const isHierarchyMatch = (h1, h2) => {
    if (h1.length !== h2.length) {
        return false;
    }
    return h1.every((level, index) => level.fieldName === h2[index].fieldName && level.value === h2[index].value);
};
const getHierarchy = (gRow) => {
    const hierarchy = [];
    if (gRow !== undefined && gRow.expression) {
        hierarchy.push({ fieldName: gRow.expression.fieldName, value: gRow.value });
        while (gRow.groupParent) {
            gRow = gRow.groupParent;
            hierarchy.unshift({ fieldName: gRow.expression.fieldName, value: gRow.value });
        }
    }
    return hierarchy;
};

const DATE_TYPE = 'date';
class DefaultSortingStrategy {
    constructor() { }
    static instance() {
        return this._instance || (this._instance = new this());
    }
    sort(data, fieldName, dir, ignoreCase, valueResolver, isDate) {
        const key = fieldName;
        const reverse = (dir === SortingDirection.Desc ? -1 : 1);
        const cmpFunc = (obj1, obj2) => this.compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver, isDate);
        return this.arraySort(data, cmpFunc);
    }
    compareValues(a, b) {
        const an = (a === null || a === undefined);
        const bn = (b === null || b === undefined);
        if (an) {
            if (bn) {
                return 0;
            }
            return -1;
        }
        else if (bn) {
            return 1;
        }
        return a > b ? 1 : a < b ? -1 : 0;
    }
    compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver, isDate) {
        let a = valueResolver(obj1, key, isDate);
        let b = valueResolver(obj2, key, isDate);
        if (ignoreCase) {
            a = a && a.toLowerCase ? a.toLowerCase() : a;
            b = b && b.toLowerCase ? b.toLowerCase() : b;
        }
        return reverse * this.compareValues(a, b);
    }
    arraySort(data, compareFn) {
        return data.sort(compareFn);
    }
}
DefaultSortingStrategy._instance = null;
class NoopSortingStrategy {
    constructor() { }
    static instance() {
        return this._instance || (this._instance = new NoopSortingStrategy());
    }
    sort(data, expressions) {
        return data;
    }
}
NoopSortingStrategy._instance = null;
class IgxSorting {
    sort(data, expressions, grid) {
        return this.sortDataRecursive(data, expressions, 0, grid);
    }
    groupDataRecursive(data, state, level, parent, metadata, grid = null, groupsRecords = [], fullResult = { data: [], metadata: [] }) {
        const expressions = state.expressions;
        const expansion = state.expansion;
        let i = 0;
        let result = [];
        while (i < data.length) {
            const column = grid ? grid.getColumnByName(expressions[level].fieldName) : null;
            const isDate = (column === null || column === void 0 ? void 0 : column.dataType) === DATE_TYPE;
            const group = this.groupedRecordsByExpression(data, i, expressions[level], isDate);
            const groupRow = {
                expression: expressions[level],
                level,
                records: cloneArray(group),
                value: this.getFieldValue(group[0], expressions[level].fieldName, isDate),
                groupParent: parent,
                groups: [],
                height: grid ? grid.renderedRowHeight : null,
                column
            };
            if (parent) {
                parent.groups.push(groupRow);
            }
            else {
                groupsRecords.push(groupRow);
            }
            const hierarchy = getHierarchy(groupRow);
            const expandState = expansion.find((s) => isHierarchyMatch(s.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy));
            const expanded = expandState ? expandState.expanded : state.defaultExpanded;
            let recursiveResult;
            result.push(groupRow);
            metadata.push(null);
            fullResult.data.push(groupRow);
            fullResult.metadata.push(null);
            if (level < expressions.length - 1) {
                recursiveResult = this.groupDataRecursive(group, state, level + 1, groupRow, expanded ? metadata : [], grid, groupsRecords, fullResult);
                if (expanded) {
                    result = result.concat(recursiveResult);
                }
            }
            else {
                for (const groupItem of group) {
                    fullResult.metadata.push(groupRow);
                    fullResult.data.push(groupItem);
                }
                if (expanded) {
                    metadata.push(...fullResult.metadata.slice(fullResult.metadata.length - group.length));
                    result.push(...fullResult.data.slice(fullResult.data.length - group.length));
                }
            }
            i += group.length;
        }
        return result;
    }
    getFieldValue(obj, key, isDate = false) {
        return isDate ? parseDate(resolveNestedPath(obj, key)) : resolveNestedPath(obj, key);
    }
    groupedRecordsByExpression(data, index, expression, isDate = false) {
        const res = [];
        const key = expression.fieldName;
        const len = data.length;
        const groupval = this.getFieldValue(data[index], key, isDate);
        res.push(data[index]);
        index++;
        const comparer = expression.groupingComparer || DefaultSortingStrategy.instance().compareValues;
        for (let i = index; i < len; i++) {
            if (comparer(this.getFieldValue(data[i], key, isDate), groupval) === 0) {
                res.push(data[i]);
            }
            else {
                break;
            }
        }
        return res;
    }
    sortDataRecursive(data, expressions, expressionIndex = 0, grid) {
        let i;
        let j;
        let gbData;
        let gbDataLen;
        const exprsLen = expressions.length;
        const dataLen = data.length;
        expressionIndex = expressionIndex || 0;
        if (expressionIndex >= exprsLen || dataLen <= 1) {
            return data;
        }
        const expr = expressions[expressionIndex];
        if (!expr.strategy) {
            expr.strategy = DefaultSortingStrategy.instance();
        }
        const isDate = grid && grid.getColumnByName(expr.fieldName) ?
            grid.getColumnByName(expr.fieldName).dataType === DATE_TYPE : false;
        data = expr.strategy.sort(data, expr.fieldName, expr.dir, expr.ignoreCase, this.getFieldValue, isDate);
        if (expressionIndex === exprsLen - 1) {
            return data;
        }
        // in case of multiple sorting
        for (i = 0; i < dataLen; i++) {
            gbData = this.groupedRecordsByExpression(data, i, expr, isDate);
            gbDataLen = gbData.length;
            if (gbDataLen > 1) {
                gbData = this.sortDataRecursive(gbData, expressions, expressionIndex + 1, grid);
            }
            for (j = 0; j < gbDataLen; j++) {
                data[i + j] = gbData[j];
            }
            i += gbDataLen - 1;
        }
        return data;
    }
}
class IgxDataRecordSorting extends IgxSorting {
    getFieldValue(obj, key, isDate = false) {
        return isDate ? parseDate(resolveNestedPath(obj.data, key)) : resolveNestedPath(obj.data, key);
    }
}

class IgxGrouping extends IgxSorting {
    groupBy(data, state, grid, groupsRecords, fullResult = { data: [], metadata: [] }) {
        const metadata = [];
        const grouping = this.groupDataRecursive(data, state, 0, null, metadata, grid, groupsRecords, fullResult);
        return {
            data: grouping,
            metadata
        };
    }
}

var PagingError;
(function (PagingError) {
    PagingError[PagingError["None"] = 0] = "None";
    PagingError[PagingError["IncorrectPageIndex"] = 1] = "IncorrectPageIndex";
    PagingError[PagingError["IncorrectRecordsPerPage"] = 2] = "IncorrectRecordsPerPage";
})(PagingError || (PagingError = {}));

var FilteringLogic;
(function (FilteringLogic) {
    FilteringLogic[FilteringLogic["And"] = 0] = "And";
    FilteringLogic[FilteringLogic["Or"] = 1] = "Or";
})(FilteringLogic || (FilteringLogic = {}));

var FilteringExpressionsTreeType;
(function (FilteringExpressionsTreeType) {
    FilteringExpressionsTreeType[FilteringExpressionsTreeType["Regular"] = 0] = "Regular";
    FilteringExpressionsTreeType[FilteringExpressionsTreeType["Advanced"] = 1] = "Advanced";
})(FilteringExpressionsTreeType || (FilteringExpressionsTreeType = {}));
class FilteringExpressionsTree {
    constructor(operator, fieldName) {
        /**
         * Sets/gets the filtering operands.
         * ```typescript
         * const gridExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
         * const expression = [
         * {
         *   condition: IgxStringFilteringOperand.instance().condition('contains'),
         *   fieldName: 'Column Field',
         *   searchVal: 'Value',
         *   ignoreCase: false
         * }];
         * gridExpressionsTree.filteringOperands.push(expression);
         * this.grid.filteringExpressionsTree = gridExpressionsTree;
         * ```
         * ```typescript
         * let filteringOperands = gridExpressionsTree.filteringOperands;
         * ```
         *
         * @memberof FilteringExpressionsTree
         */
        this.filteringOperands = [];
        this.operator = operator;
        this.fieldName = fieldName;
    }
    /**
     * Checks if filtering expressions tree is empty.
     *
     * @param expressionTree filtering expressions tree.
     */
    static empty(expressionTree) {
        return !expressionTree || !expressionTree.filteringOperands || !expressionTree.filteringOperands.length;
    }
    /**
     * Returns the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpression = gridExpressionTree.find('Column Field');
     * ```
     *
     * @memberof FilteringExpressionsTree
     */
    find(fieldName) {
        const index = this.findIndex(fieldName);
        if (index > -1) {
            return this.filteringOperands[index];
        }
        return null;
    }
    /**
     * Returns the index of the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpressionIndex = gridExpressionTree.findIndex('Column Field');
     * ```
     *
     * @memberof FilteringExpressionsTree
     */
    findIndex(fieldName) {
        let expr;
        for (let i = 0; i < this.filteringOperands.length; i++) {
            expr = this.filteringOperands[i];
            if (expr instanceof FilteringExpressionsTree) {
                if (this.isFilteringExpressionsTreeForColumn(expr, fieldName)) {
                    return i;
                }
            }
            else {
                if (expr.fieldName === fieldName) {
                    return i;
                }
            }
        }
        return -1;
    }
    isFilteringExpressionsTreeForColumn(expressionsTree, fieldName) {
        if (expressionsTree.fieldName === fieldName) {
            return true;
        }
        for (const expr of expressionsTree.filteringOperands) {
            if ((expr instanceof FilteringExpressionsTree)) {
                return this.isFilteringExpressionsTreeForColumn(expr, fieldName);
            }
            else {
                return expr.fieldName === fieldName;
            }
        }
        return false;
    }
}

const DateType = 'date';
class NoopFilteringStrategy {
    constructor() { }
    static instance() {
        return this._instance || (this._instance = new NoopFilteringStrategy());
    }
    filter(data, _, __) {
        return data;
    }
}
NoopFilteringStrategy._instance = null;
class BaseFilteringStrategy {
    findMatchByExpression(rec, expr, isDate, grid) {
        const cond = expr.condition;
        const val = this.getFieldValue(rec, expr.fieldName, isDate, grid);
        return cond.logic(val, expr.searchVal, expr.ignoreCase);
    }
    matchRecord(rec, expressions, grid) {
        if (expressions) {
            if (expressions instanceof FilteringExpressionsTree) {
                const expressionsTree = expressions;
                const operator = expressionsTree.operator;
                let matchOperand;
                if (expressionsTree.filteringOperands && expressionsTree.filteringOperands.length) {
                    for (const operand of expressionsTree.filteringOperands) {
                        matchOperand = this.matchRecord(rec, operand, grid);
                        // Return false if at least one operand does not match and the filtering logic is And
                        if (!matchOperand && operator === FilteringLogic.And) {
                            return false;
                        }
                        // Return true if at least one operand matches and the filtering logic is Or
                        if (matchOperand && operator === FilteringLogic.Or) {
                            return true;
                        }
                    }
                    return matchOperand;
                }
                return true;
            }
            else {
                const expression = expressions;
                const isDate = grid && grid.getColumnByName(expression.fieldName) ?
                    grid.getColumnByName(expression.fieldName).dataType === DateType : false;
                return this.findMatchByExpression(rec, expression, isDate, grid);
            }
        }
        return true;
    }
}
class FilteringStrategy extends BaseFilteringStrategy {
    constructor() {
        super();
    }
    static instance() {
        return this._instace || (this._instace = new this());
    }
    filter(data, expressionsTree, advancedExpressionsTree, grid) {
        let i;
        let rec;
        const len = data.length;
        const res = [];
        if ((FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree)) || !len) {
            return data;
        }
        for (i = 0; i < len; i++) {
            rec = data[i];
            if (this.matchRecord(rec, expressionsTree, grid) && this.matchRecord(rec, advancedExpressionsTree, grid)) {
                res.push(rec);
            }
        }
        return res;
    }
    getFieldValue(rec, fieldName, isDate = false) {
        let value = resolveNestedPath(rec, fieldName);
        value = value && isDate ? parseDate(value) : value;
        return value;
    }
}
FilteringStrategy._instace = null;
class FormattedValuesFilteringStrategy extends FilteringStrategy {
    /**
     * Creates a new instance of FormattedValuesFilteringStrategy.
     *
     * @param fields An array of column field names that should be formatted.
     * If omitted the values of all columns which has formatter will be formatted.
     */
    constructor(fields) {
        super();
        this.fields = fields;
    }
    /** @hidden */
    shouldApplyFormatter(fieldName) {
        return !this.fields || this.fields.length === 0 || this.fields.some(f => f === fieldName);
    }
    getFieldValue(rec, fieldName, isDate = false, grid) {
        const column = grid.getColumnByName(fieldName);
        let value = resolveNestedPath(rec, fieldName);
        value = column.formatter && this.shouldApplyFormatter(fieldName) ?
            column.formatter(value) :
            value && isDate ? parseDate(value) : value;
        return value;
    }
}

var TransactionType;
(function (TransactionType) {
    TransactionType["ADD"] = "add";
    TransactionType["DELETE"] = "delete";
    TransactionType["UPDATE"] = "update";
})(TransactionType || (TransactionType = {}));
var TransactionEventOrigin;
(function (TransactionEventOrigin) {
    TransactionEventOrigin["UNDO"] = "undo";
    TransactionEventOrigin["REDO"] = "redo";
    TransactionEventOrigin["CLEAR"] = "clear";
    TransactionEventOrigin["ADD"] = "add";
    TransactionEventOrigin["END"] = "endPending";
})(TransactionEventOrigin || (TransactionEventOrigin = {}));

/**
 * @hidden
 */
const DataType = mkenum({
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Date: 'date',
    Currency: 'currency',
    Percent: 'percent'
});
/**
 * @hidden
 */
class DataUtil {
    static sort(data, expressions, sorting = new IgxSorting(), grid) {
        return sorting.sort(data, expressions, grid);
    }
    static treeGridSort(hierarchicalData, expressions, sorting = new IgxDataRecordSorting(), parent, grid) {
        let res = [];
        hierarchicalData.forEach((hr) => {
            const rec = DataUtil.cloneTreeGridRecord(hr);
            rec.parent = parent;
            if (rec.children) {
                rec.children = DataUtil.treeGridSort(rec.children, expressions, sorting, rec, grid);
            }
            res.push(rec);
        });
        res = DataUtil.sort(res, expressions, sorting, grid);
        return res;
    }
    static cloneTreeGridRecord(hierarchicalRecord) {
        const rec = {
            rowID: hierarchicalRecord.rowID,
            data: hierarchicalRecord.data,
            children: hierarchicalRecord.children,
            isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
            level: hierarchicalRecord.level,
            expanded: hierarchicalRecord.expanded
        };
        return rec;
    }
    static group(data, state, grid = null, groupsRecords = [], fullResult = { data: [], metadata: [] }) {
        const grouping = new IgxGrouping();
        groupsRecords.splice(0, groupsRecords.length);
        return grouping.groupBy(data, state, grid, groupsRecords, fullResult);
    }
    static page(data, state, dataLength) {
        if (!state) {
            return data;
        }
        const len = dataLength !== undefined ? dataLength : data.length;
        const index = state.index;
        const res = [];
        const recordsPerPage = dataLength !== undefined && state.recordsPerPage > dataLength ? dataLength : state.recordsPerPage;
        state.metadata = {
            countPages: 0,
            countRecords: len,
            error: PagingError.None
        };
        if (index < 0 || isNaN(index)) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
            state.metadata.error = PagingError.IncorrectRecordsPerPage;
            return res;
        }
        state.metadata.countPages = Math.ceil(len / recordsPerPage);
        if (!len) {
            return data;
        }
        if (index >= state.metadata.countPages) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
    }
    static filter(data, state, grid) {
        if (!state.strategy) {
            state.strategy = new FilteringStrategy();
        }
        return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree, grid);
    }
    static correctPagingState(state, length) {
        const maxPage = Math.ceil(length / state.recordsPerPage) - 1;
        if (!isNaN(maxPage) && state.index > maxPage) {
            state.index = maxPage;
        }
    }
    static getHierarchy(gRow) {
        return getHierarchy(gRow);
    }
    static isHierarchyMatch(h1, h2) {
        return isHierarchyMatch(h1, h2);
    }
    /**
     * Merges all changes from provided transactions into provided data collection
     *
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    static mergeTransactions(data, transactions, primaryKey, deleteRows = false) {
        data.forEach((item, index) => {
            const rowId = primaryKey ? item[primaryKey] : item;
            const transaction = transactions.find(t => t.id === rowId);
            if (transaction && transaction.type === TransactionType.UPDATE) {
                data[index] = transaction.newValue;
            }
        });
        if (deleteRows) {
            transactions
                .filter(t => t.type === TransactionType.DELETE)
                .forEach(t => {
                const index = primaryKey ? data.findIndex(d => d[primaryKey] === t.id) : data.findIndex(d => d === t.id);
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
            });
        }
        data.push(...transactions
            .filter(t => t.type === TransactionType.ADD)
            .map(t => t.newValue));
        return data;
    }
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     *
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param childDataKey Data key of child collections
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    static mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey, deleteRows = false) {
        for (const transaction of transactions) {
            if (transaction.path) {
                const parent = this.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                let collection = parent ? parent[childDataKey] : data;
                switch (transaction.type) {
                    case TransactionType.ADD:
                        //  if there is no parent this is ADD row at root level
                        if (parent && !parent[childDataKey]) {
                            parent[childDataKey] = collection = [];
                        }
                        collection.push(transaction.newValue);
                        break;
                    case TransactionType.UPDATE:
                        const updateIndex = collection.findIndex(x => x[primaryKey] === transaction.id);
                        if (updateIndex !== -1) {
                            collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                        }
                        break;
                    case TransactionType.DELETE:
                        if (deleteRows) {
                            const deleteIndex = collection.findIndex(r => r[primaryKey] === transaction.id);
                            if (deleteIndex !== -1) {
                                collection.splice(deleteIndex, 1);
                            }
                        }
                        break;
                }
            }
            else {
                //  if there is no path this is ADD row in root. Push the newValue to data
                data.push(transaction.newValue);
            }
        }
        return data;
    }
    static parseValue(dataType, value) {
        if (dataType === DataType.Number || dataType === DataType.Currency || dataType === DataType.Percent) {
            value = parseFloat(value);
        }
        return value;
    }
    static findParentFromPath(data, primaryKey, childDataKey, path) {
        let collection = data;
        let result;
        for (const id of path) {
            result = collection && collection.find(x => x[primaryKey] === id);
            if (!result) {
                break;
            }
            collection = result[childDataKey];
        }
        return result;
    }
}

/**
 * @hidden
 */
class ExportUtilities {
    static getKeysFromData(data) {
        const length = data.length;
        if (length === 0) {
            return [];
        }
        const dataEntry = data[0];
        const dataEntryMiddle = data[Math.floor(length / 2)];
        const dataEntryLast = data[length - 1];
        const keys1 = Object.keys(dataEntry);
        const keys2 = Object.keys(dataEntryMiddle);
        const keys3 = Object.keys(dataEntryLast);
        const keys = new Set(keys1.concat(keys2).concat(keys3));
        return !ExportUtilities.isSpecialData(data) ? Array.from(keys) : ['Column 1'];
    }
    static saveBlobToFile(blob, fileName) {
        const a = document.createElement('a');
        if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(blob, fileName);
        }
        else {
            const url = window.URL.createObjectURL(blob);
            a.download = fileName;
            a.href = url;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
    }
    static stringToArrayBuffer(s) {
        const buf = new ArrayBuffer(s.length);
        const view = new Uint8Array(buf);
        for (let i = 0; i !== s.length; ++i) {
            /* eslint-disable  no-bitwise */
            view[i] = s.charCodeAt(i) & 0xFF;
            /* eslint-enable  no-bitwise */
        }
        return buf;
    }
    static isSpecialData(data) {
        const dataEntry = data[0];
        return (typeof dataEntry === 'string' ||
            typeof dataEntry === 'number' ||
            dataEntry instanceof Date);
    }
    static hasValue(value) {
        return value !== undefined && value !== null;
    }
    static isNullOrWhitespaces(value) {
        return value === undefined || value === null || !value.trim();
    }
}

class TreeGridFilteringStrategy extends BaseFilteringStrategy {
    filter(data, expressionsTree, advancedExpressionsTree, grid) {
        return this.filterImpl(data, expressionsTree, advancedExpressionsTree, undefined, grid);
    }
    getFieldValue(rec, fieldName, isDate = false) {
        const hierarchicalRecord = rec;
        let value = resolveNestedPath(hierarchicalRecord.data, fieldName);
        value = value && isDate ? parseDate(value) : value;
        return value;
    }
    filterImpl(data, expressionsTree, advancedExpressionsTree, parent, grid) {
        let i;
        let rec;
        const len = data.length;
        const res = [];
        if ((FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree)) || !len) {
            return data;
        }
        for (i = 0; i < len; i++) {
            rec = DataUtil.cloneTreeGridRecord(data[i]);
            rec.parent = parent;
            if (rec.children) {
                const filteredChildren = this.filterImpl(rec.children, expressionsTree, advancedExpressionsTree, rec, grid);
                rec.children = filteredChildren.length > 0 ? filteredChildren : null;
            }
            if (this.matchRecord(rec, expressionsTree, grid) && this.matchRecord(rec, advancedExpressionsTree, grid)) {
                res.push(rec);
            }
            else if (rec.children && rec.children.length > 0) {
                rec.isFilteredOutParent = true;
                res.push(rec);
            }
        }
        return res;
    }
}
class TreeGridFormattedValuesFilteringStrategy extends TreeGridFilteringStrategy {
    /**
     * Creates a new instance of FormattedValuesFilteringStrategy.
     *
     * @param fields An array of column field names that should be formatted.
     * If omitted the values of all columns which has formatter will be formatted.
     */
    constructor(fields) {
        super();
        this.fields = fields;
    }
    /** @hidden */
    shouldApplyFormatter(fieldName) {
        return !this.fields || this.fields.length === 0 || this.fields.some(f => f === fieldName);
    }
    getFieldValue(rec, fieldName, isDate = false, grid) {
        const column = grid.getColumnByName(fieldName);
        const hierarchicalRecord = rec;
        let value = resolveNestedPath(hierarchicalRecord.data, fieldName);
        value = column.formatter && this.shouldApplyFormatter(fieldName) ?
            column.formatter(value) :
            value && isDate ? parseDate(value) : value;
        return value;
    }
}

var ExportRecordType;
(function (ExportRecordType) {
    ExportRecordType[ExportRecordType["GroupedRecord"] = 1] = "GroupedRecord";
    ExportRecordType[ExportRecordType["TreeGridRecord"] = 2] = "TreeGridRecord";
    ExportRecordType[ExportRecordType["DataRecord"] = 3] = "DataRecord";
})(ExportRecordType || (ExportRecordType = {}));
const DEFAULT_COLUMN_WIDTH = 8.43;
class IgxBaseExporter {
    constructor() {
        this.exportEnded = new EventEmitter();
        /**
         * This event is emitted when a row is exported.
         * ```typescript
         * this.exporterService.rowExporting.subscribe((args: IRowExportingEventArgs) => {
         * // put event handler code here
         * });
         * ```
         *
         * @memberof IgxBaseExporter
         */
        this.rowExporting = new EventEmitter();
        /**
         * This event is emitted when a column is exported.
         * ```typescript
         * this.exporterService.columnExporting.subscribe((args: IColumnExportingEventArgs) => {
         * // put event handler code here
         * });
         * ```
         *
         * @memberof IgxBaseExporter
         */
        this.columnExporting = new EventEmitter();
        this._indexOfLastPinnedColumn = -1;
        this._sort = null;
        this.flatRecords = [];
    }
    get columnWidthList() {
        return this._columnWidthList;
    }
    /**
     * Method for exporting IgxGrid component's data.
     * ```typescript
     * this.exporterService.export(this.igxGridForExport, this.exportOptions);
     * ```
     *
     * @memberof IgxBaseExporter
     */
    export(grid, options) {
        if (options === undefined || options === null) {
            throw Error('No options provided!');
        }
        const columns = grid.columnList.toArray();
        this._columnList = new Array(columns.length);
        this._columnWidthList = new Array(columns.filter(c => !c.hidden).length);
        const hiddenColumns = [];
        let lastVisibleColumnIndex = -1;
        columns.forEach((column) => {
            const columnHeader = !ExportUtilities.isNullOrWhitespaces(column.header) ? column.header : column.field;
            const exportColumn = !column.hidden || options.ignoreColumnsVisibility;
            const index = options.ignoreColumnsOrder || options.ignoreColumnsVisibility ? column.index : column.visibleIndex;
            const columnWidth = Number(column.width.slice(0, -2));
            const columnInfo = {
                header: columnHeader,
                dataType: column.dataType,
                field: column.field,
                skip: !exportColumn,
                formatter: column.formatter,
                skipFormatter: false
            };
            if (index !== -1) {
                this._columnList[index] = columnInfo;
                this._columnWidthList[index] = columnWidth;
                lastVisibleColumnIndex = Math.max(lastVisibleColumnIndex, index);
            }
            else {
                hiddenColumns.push(columnInfo);
            }
            if (column.pinned && exportColumn) {
                this._indexOfLastPinnedColumn++;
            }
        });
        // Append the hidden columns to the end of the list
        hiddenColumns.forEach((hiddenColumn) => {
            this._columnList[++lastVisibleColumnIndex] = hiddenColumn;
        });
        this.prepareData(grid, options);
        this.exportGridRecordsData(this.flatRecords, options);
    }
    /**
     * Method for exporting any kind of array data.
     * ```typescript
     * this.exporterService.exportData(this.arrayForExport, this.exportOptions);
     * ```
     *
     * @memberof IgxBaseExporter
     */
    exportData(data, options) {
        if (options === undefined || options === null) {
            throw Error('No options provided!');
        }
        const records = data.map(d => {
            const record = {
                data: d,
                type: ExportRecordType.DataRecord,
                level: 0
            };
            return record;
        });
        this.exportGridRecordsData(records, options);
    }
    exportGridRecordsData(records, options) {
        if (options === undefined || options === null) {
            throw Error('No options provided!');
        }
        if (!this._columnList || this._columnList.length === 0) {
            const recordsData = records.map(r => r.data);
            const keys = ExportUtilities.getKeysFromData(recordsData);
            this._columnList = keys.map((k) => ({ header: k, field: k, skip: false }));
            this._columnWidthList = new Array(keys.length).fill(DEFAULT_COLUMN_WIDTH);
        }
        let skippedPinnedColumnsCount = 0;
        let columnsWithoutHeaderCount = 1;
        this._columnList.forEach((column, index) => {
            if (!column.skip) {
                const columnExportArgs = {
                    header: !ExportUtilities.isNullOrWhitespaces(column.header) ?
                        column.header :
                        'Column' + columnsWithoutHeaderCount++,
                    field: column.field,
                    columnIndex: index,
                    cancel: false,
                    skipFormatter: false
                };
                this.columnExporting.emit(columnExportArgs);
                column.header = columnExportArgs.header;
                column.skip = columnExportArgs.cancel;
                column.skipFormatter = columnExportArgs.skipFormatter;
                if (column.skip && index <= this._indexOfLastPinnedColumn) {
                    skippedPinnedColumnsCount++;
                }
                if (this._sort && this._sort.fieldName === column.field) {
                    if (column.skip) {
                        this._sort = null;
                    }
                    else {
                        this._sort.fieldName = column.header;
                    }
                }
            }
        });
        this._indexOfLastPinnedColumn -= skippedPinnedColumnsCount;
        const dataToExport = new Array();
        const actualData = records.map(r => r.data);
        const isSpecialData = ExportUtilities.isSpecialData(actualData);
        yieldingLoop(records.length, 100, (i) => {
            const row = records[i];
            this.exportRow(dataToExport, row, i, isSpecialData);
        }, () => {
            this.exportDataImplementation(dataToExport, options);
            this.resetDefaults();
        });
    }
    exportRow(data, record, index, isSpecialData) {
        if (!isSpecialData) {
            record.data = this._columnList.reduce((a, e) => {
                if (!e.skip) {
                    let rawValue = resolveNestedPath(record.data, e.field);
                    const shouldApplyFormatter = e.formatter && !e.skipFormatter && record.type !== ExportRecordType.GroupedRecord;
                    if (e.dataType === 'date' &&
                        !(rawValue instanceof Date) &&
                        !shouldApplyFormatter &&
                        rawValue !== undefined &&
                        rawValue !== null) {
                        rawValue = new Date(rawValue);
                    }
                    else if (e.dataType === 'string' && rawValue instanceof Date) {
                        rawValue = rawValue.toString();
                    }
                    a[e.header] = shouldApplyFormatter ? e.formatter(rawValue) : rawValue;
                }
                return a;
            }, {});
        }
        const rowArgs = {
            rowData: record.data,
            rowIndex: index,
            cancel: false
        };
        this.rowExporting.emit(rowArgs);
        if (!rowArgs.cancel) {
            data.push(record);
        }
    }
    prepareData(grid, options) {
        this.flatRecords = [];
        const tagName = grid.nativeElement.tagName.toLowerCase();
        const hasFiltering = (grid.filteringExpressionsTree && grid.filteringExpressionsTree.filteringOperands.length > 0) ||
            (grid.advancedFilteringExpressionsTree && grid.advancedFilteringExpressionsTree.filteringOperands.length > 0);
        const hasSorting = grid.sortingExpressions &&
            grid.sortingExpressions.length > 0;
        if (tagName === 'igx-grid') {
            this.prepareGridData(grid, options, hasFiltering, hasSorting);
        }
        if (tagName === 'igx-tree-grid') {
            this.prepareTreeGridData(grid, options, hasFiltering, hasSorting);
        }
    }
    prepareGridData(grid, options, hasFiltering, hasSorting) {
        const groupedGridGroupingState = {
            expressions: grid.groupingExpressions,
            expansion: grid.groupingExpansionState,
            defaultExpanded: grid.groupsExpanded,
        };
        const hasGrouping = grid.groupingExpressions &&
            grid.groupingExpressions.length > 0;
        const skipOperations = (!hasFiltering || !options.ignoreFiltering) &&
            (!hasSorting || !options.ignoreSorting) &&
            (!hasGrouping || !options.ignoreGrouping);
        if (skipOperations) {
            if (hasGrouping) {
                this.addGroupedData(grid, grid.groupsRecords, groupedGridGroupingState);
            }
            else {
                this.addFlatData(grid.filteredSortedData);
            }
        }
        else {
            let gridData = grid.data;
            if (hasFiltering && !options.ignoreFiltering) {
                const filteringState = {
                    expressionsTree: grid.filteringExpressionsTree,
                    advancedExpressionsTree: grid.advancedFilteringExpressionsTree,
                };
                filteringState.strategy = grid.filterStrategy;
                gridData = DataUtil.filter(gridData, filteringState, grid);
            }
            if (hasSorting && !options.ignoreSorting) {
                // TODO: We should drop support for this since in a grouped grid it doesn't make sense
                // this._sort = !isGroupedGrid ?
                //     cloneValue(grid.sortingExpressions[0]) :
                //     grid.sortingExpressions.length > 1 ?
                //         cloneValue(grid.sortingExpressions[1]) :
                //         cloneValue(grid.sortingExpressions[0]);
                gridData = DataUtil.sort(gridData, grid.sortingExpressions, grid.sortStrategy, grid);
            }
            if (hasGrouping && !options.ignoreGrouping) {
                const groupsRecords = [];
                DataUtil.group(cloneArray(gridData), groupedGridGroupingState, grid, groupsRecords);
                gridData = groupsRecords;
            }
            if (hasGrouping && !options.ignoreGrouping) {
                this.addGroupedData(grid, gridData, groupedGridGroupingState);
            }
            else {
                this.addFlatData(gridData);
            }
        }
    }
    prepareTreeGridData(grid, options, hasFiltering, hasSorting) {
        const skipOperations = (!hasFiltering || !options.ignoreFiltering) &&
            (!hasSorting || !options.ignoreSorting);
        if (skipOperations) {
            this.addTreeGridData(grid.processedRootRecords);
        }
        else {
            let gridData = grid.rootRecords;
            if (hasFiltering && !options.ignoreFiltering) {
                const filteringState = {
                    expressionsTree: grid.filteringExpressionsTree,
                    advancedExpressionsTree: grid.advancedFilteringExpressionsTree,
                };
                filteringState.strategy = (grid.filterStrategy) ? grid.filterStrategy : new TreeGridFilteringStrategy();
                gridData = filteringState.strategy
                    .filter(gridData, filteringState.expressionsTree, filteringState.advancedExpressionsTree);
            }
            if (hasSorting && !options.ignoreSorting) {
                this._sort = cloneValue(grid.sortingExpressions[0]);
                gridData = DataUtil.treeGridSort(gridData, grid.sortingExpressions, grid.sortStrategy);
            }
            this.addTreeGridData(gridData);
        }
    }
    addTreeGridData(records, parentExpanded = true) {
        if (!records) {
            return;
        }
        for (const record of records) {
            const hierarchicalRecord = {
                data: record.data,
                level: record.level,
                hidden: !parentExpanded,
                type: ExportRecordType.TreeGridRecord
            };
            this.flatRecords.push(hierarchicalRecord);
            this.addTreeGridData(record.children, parentExpanded && record.expanded);
        }
    }
    addFlatData(records) {
        if (!records) {
            return;
        }
        for (const record of records) {
            const data = {
                data: record,
                type: ExportRecordType.DataRecord,
                level: 0
            };
            this.flatRecords.push(data);
        }
    }
    addGroupedData(grid, records, groupingState, parentExpanded = true) {
        if (!records) {
            return;
        }
        const firstCol = this._columnList[0].field;
        for (const record of records) {
            let recordVal = record.value;
            const hierarchy = getHierarchy(record);
            const expandState = groupingState.expansion.find((s) => isHierarchyMatch(s.hierarchy || [{ fieldName: record.expression.fieldName, value: recordVal }], hierarchy));
            const expanded = expandState ? expandState.expanded : groupingState.defaultExpanded;
            const isDate = recordVal instanceof Date;
            if (isDate) {
                const timeZoneOffset = recordVal.getTimezoneOffset() * 60000;
                const isoString = (new Date(recordVal - timeZoneOffset)).toISOString();
                const pipe = new DatePipe(grid.locale);
                recordVal = pipe.transform(isoString);
            }
            const groupExpressionName = record.column && record.column.header ?
                record.column.header :
                record.expression.fieldName;
            recordVal = recordVal !== null ? recordVal : '';
            const groupExpression = {
                data: { [firstCol]: `${groupExpressionName}: ${recordVal} (${record.records.length})` },
                level: record.level,
                hidden: !parentExpanded,
                type: ExportRecordType.GroupedRecord,
            };
            this.flatRecords.push(groupExpression);
            if (record.groups.length > 0) {
                this.addGroupedData(grid, record.groups, groupingState, expanded && parentExpanded);
            }
            else {
                const rowRecords = record.records;
                for (const rowRecord of rowRecords) {
                    const currentRecord = {
                        data: rowRecord,
                        level: record.level + 1,
                        hidden: !(expanded && parentExpanded),
                        type: ExportRecordType.DataRecord
                    };
                    this.flatRecords.push(currentRecord);
                }
            }
        }
    }
    resetDefaults() {
        this._columnList = [];
        this._indexOfLastPinnedColumn = -1;
        this._sort = null;
        this.flatRecords = [];
    }
}

/**
 * @hidden
 */
class CharSeparatedValueData {
    constructor(_data, valueDelimiter) {
        this._data = _data;
        this._headerRecord = '';
        this._dataRecords = '';
        this._eor = '\r\n';
        this._escapeCharacters = ['\r', '\n', '\r\n'];
        this._delimiterLength = 1;
        this._isSpecialData = false;
        this.setDelimiter(valueDelimiter);
    }
    prepareData(key) {
        if (!this._data || this._data.length === 0) {
            return '';
        }
        let keys = [];
        if (key) {
            keys = key;
        }
        else {
            keys = ExportUtilities.getKeysFromData(this._data);
        }
        if (keys.length === 0) {
            return '';
        }
        this._isSpecialData = ExportUtilities.isSpecialData(this._data);
        this._escapeCharacters.push(this._delimiter);
        this._headerRecord = this.processHeaderRecord(keys);
        this._dataRecords = this.processDataRecords(this._data, keys);
        return this._headerRecord + this._dataRecords;
    }
    prepareDataAsync(done) {
        if (!this._data || this._data.length === 0) {
            done('');
        }
        const keys = ExportUtilities.getKeysFromData(this._data);
        if (keys.length === 0) {
            done('');
        }
        this._isSpecialData = ExportUtilities.isSpecialData(this._data);
        this._escapeCharacters.push(this._delimiter);
        this._headerRecord = this.processHeaderRecord(keys);
        this.processDataRecordsAsync(this._data, keys, (dr) => {
            done(this._headerRecord + dr);
        });
    }
    processField(value, escapeChars) {
        let safeValue = ExportUtilities.hasValue(value) ? String(value) : '';
        if (escapeChars.some((v) => safeValue.includes(v))) {
            safeValue = `"${safeValue}"`;
        }
        return safeValue + this._delimiter;
    }
    processHeaderRecord(keys) {
        let recordData = '';
        for (const keyName of keys) {
            recordData += this.processField(keyName, this._escapeCharacters);
        }
        return recordData.slice(0, -this._delimiterLength) + this._eor;
    }
    processRecord(record, keys) {
        const recordData = new Array(keys.length);
        for (let index = 0; index < keys.length; index++) {
            const value = (record[keys[index]] !== undefined) ? record[keys[index]] : this._isSpecialData ? record : '';
            recordData[index] = this.processField(value, this._escapeCharacters);
        }
        return recordData.join('').slice(0, -this._delimiterLength) + this._eor;
    }
    processDataRecords(currentData, keys) {
        const dataRecords = new Array(currentData.length);
        for (let i = 0; i < currentData.length; i++) {
            const row = currentData[i];
            dataRecords[i] = this.processRecord(row, keys);
        }
        return dataRecords.join('');
    }
    processDataRecordsAsync(currentData, keys, done) {
        const dataRecords = new Array(currentData.length);
        yieldingLoop(currentData.length, 1000, (i) => {
            const row = currentData[i];
            dataRecords[i] = this.processRecord(row, keys);
        }, () => {
            done(dataRecords.join(''));
        });
    }
    setDelimiter(value) {
        this._delimiter = value;
        this._delimiterLength = value.length;
    }
}

class IgxExporterOptionsBase {
    constructor(fileName, _fileExtension) {
        this._fileExtension = _fileExtension;
        /**
         * Specifies whether hidden columns should be exported.
         * ```typescript
         * let ignoreColumnsVisibility = this.exportOptions.ignoreColumnsVisibility;
         * this.exportOptions.ignoreColumnsVisibility = true;
         * ```
         *
         * @memberof IgxExporterOptionsBase
         */
        this.ignoreColumnsVisibility = false;
        /**
         * Specifies whether filtered out rows should be exported.
         * ```typescript
         * let ignoreFiltering = this.exportOptions.ignoreFiltering;
         * this.exportOptions.ignoreFiltering = true;
         * ```
         *
         * @memberof IgxExporterOptionsBase
         */
        this.ignoreFiltering = false;
        /**
         * Specifies if the exporter should ignore the current column order in the IgxGrid.
         * ```typescript
         * let ignoreColumnsOrder = this.exportOptions.ignoreColumnsOrder;
         * this.exportOptions.ignoreColumnsOrder = true;
         * ```
         *
         * @memberof IgxExporterOptionsBase
         */
        this.ignoreColumnsOrder = false;
        /**
         * Specifies whether the exported data should be sorted as in the provided IgxGrid.
         * When you export grouped data, setting ignoreSorting to true will cause
         * the grouping to fail because it relies on the sorting of the records.
         * ```typescript
         * let ignoreSorting = this.exportOptions.ignoreSorting;
         * this.exportOptions.ignoreSorting = true;
         * ```
         *
         * @memberof IgxExporterOptionsBase
         */
        this.ignoreSorting = false;
        /**
         * Specifies whether the exported data should be grouped as in the provided IgxGrid.
         * ```typescript
         * let ignoreGrouping = this.exportOptions.ignoreGrouping;
         * this.exportOptions.ignoreGrouping = true;
         * ```
         *
         * @memberof IgxExporterOptionsBase
         */
        this.ignoreGrouping = false;
        this.setFileName(fileName);
    }
    setFileName(fileName) {
        this._fileName = fileName + (fileName.endsWith(this._fileExtension) === false ? this._fileExtension : '');
    }
    /**
     * Gets the file name which will be used for the exporting operation.
     * ```typescript
     * let fileName = this.exportOptions.fileName;
     * ```
     *
     * @memberof IgxExporterOptionsBase
     */
    get fileName() {
        return this._fileName;
    }
    /**
     * Sets the file name which will be used for the exporting operation.
     * ```typescript
     * this.exportOptions.fileName = 'exportedData01';
     * ```
     *
     * @memberof IgxExporterOptionsBase
     */
    set fileName(value) {
        this.setFileName(value);
    }
}

/**
 * Objects of this class are used to configure the CSV exporting process.
 */
class IgxCsvExporterOptions extends IgxExporterOptionsBase {
    constructor(fileName, fileType) {
        super(fileName, IgxCsvExporterOptions.getExtensionFromFileType(fileType));
        this.setFileType(fileType);
        this.setDelimiter();
    }
    static getExtensionFromFileType(fType) {
        let extension = '';
        switch (fType) {
            case CsvFileTypes.CSV:
                extension = '.csv';
                break;
            case CsvFileTypes.TSV:
                extension = '.tsv';
                break;
            case CsvFileTypes.TAB:
                extension = '.tab';
                break;
            default:
                throw Error('Unsupported CSV file type!');
        }
        return extension;
    }
    /**
     * Gets the value delimiter which will be used for the exporting operation.
     * ```typescript
     * let delimiter = this.exportOptions.valueDelimiter;
     * ```
     *
     * @memberof IgxCsvExporterOptions
     */
    get valueDelimiter() {
        return this._valueDelimiter;
    }
    /**
     * Sets a value delimiter which will overwrite the default delimiter of the selected export format.
     * ```typescript
     * this.exportOptions.valueDelimiter = '|';
     * ```
     *
     * @memberof IgxCsvExporterOptions
     */
    set valueDelimiter(value) {
        this.setDelimiter(value);
    }
    /**
     * Gets the CSV export format.
     * ```typescript
     * let filetype = this.exportOptions.fileType;
     * ```
     *
     * @memberof IgxCsvExporterOptions
     */
    get fileType() {
        return this._fileType;
    }
    /**
     * Sets the CSV export format.
     * ```typescript
     * this.exportOptions.fileType = CsvFileTypes.TAB;
     * ```
     *
     * @memberof IgxCsvExporterOptions
     */
    set fileType(value) {
        this.setFileType(value);
    }
    setFileType(value) {
        if (value !== undefined && value !== null && value !== this._fileType) {
            this._fileType = value;
            const extension = IgxCsvExporterOptions.getExtensionFromFileType(value);
            if (!this.fileName.endsWith(extension)) {
                const oldExt = '.' + this.fileName.split('.').pop();
                const newName = this.fileName.replace(oldExt, extension);
                this._fileExtension = extension;
                this.fileName = newName;
            }
        }
    }
    setDelimiter(value) {
        if (value !== undefined && value !== '' && value !== null) {
            this._valueDelimiter = value;
        }
        else {
            switch (this.fileType) {
                case CsvFileTypes.CSV:
                    this._valueDelimiter = ',';
                    break;
                case CsvFileTypes.TSV:
                case CsvFileTypes.TAB:
                    this._valueDelimiter = '\t';
                    break;
            }
        }
    }
}
/**
 * This enumeration is used to configure the default value separator
 * as well as the default file extension used when performing CSV exporting.
 */
var CsvFileTypes;
(function (CsvFileTypes) {
    /**
     * Character Separated Values, default separator is "comma", default file extension is .csv
     */
    CsvFileTypes[CsvFileTypes["CSV"] = 0] = "CSV";
    /**
     * Tab Separated Values, default separator is tab, default file extension is .tsv
     */
    CsvFileTypes[CsvFileTypes["TSV"] = 1] = "TSV";
    /**
     * Tab Separated Values, default separator is tab, default file extension is .tab
     */
    CsvFileTypes[CsvFileTypes["TAB"] = 2] = "TAB";
})(CsvFileTypes || (CsvFileTypes = {}));

/**
 * **Ignite UI for Angular CSV Exporter Service** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter-csv)
 *
 * The Ignite UI for Angular CSV Exporter service can export data in a Character Separated Values format from
 * both raw data (array) or from an `IgxGrid`.
 *
 * Example:
 * ```typescript
 * public localData = [
 *   { Name: "Eric Ridley", Age: "26" },
 *   { Name: "Alanis Brook", Age: "22" },
 *   { Name: "Jonathan Morris", Age: "23" }
 * ];
 *
 * constructor(private csvExportService: IgxCsvExporterService) {
 * }
 *
 * const opt: IgxCsvExporterOptions = new IgxCsvExporterOptions("FileName", CsvFileTypes.CSV);
 * this.csvExportService.exportData(this.localData, opt);
 * ```
 */
class IgxCsvExporterService extends IgxBaseExporter {
    constructor() {
        super(...arguments);
        /**
         * This event is emitted when the export process finishes.
         * ```typescript
         * this.exporterService.exportEnded.subscribe((args: ICsvExportEndedEventArgs) => {
         * // put event handler code here
         * });
         * ```
         *
         * @memberof IgxCsvExporterService
         */
        this.exportEnded = new EventEmitter();
    }
    exportDataImplementation(data, options) {
        data = data.map((item) => item.data);
        const csvData = new CharSeparatedValueData(data, options.valueDelimiter);
        csvData.prepareDataAsync((r) => {
            this._stringData = r;
            this.saveFile(options);
            this.exportEnded.emit({ csvData: this._stringData });
        });
    }
    saveFile(options) {
        switch (options.fileType) {
            case CsvFileTypes.CSV:
                this.exportFile(this._stringData, options.fileName, 'text/csv;charset=utf-8;');
                break;
            case CsvFileTypes.TSV:
            case CsvFileTypes.TAB:
                this.exportFile(this._stringData, options.fileName, 'text/tab-separated-values;charset=utf-8;');
                break;
        }
    }
    exportFile(data, fileName, fileType) {
        const blob = new Blob(['\ufeff', data], { type: fileType });
        ExportUtilities.saveBlobToFile(blob, fileName);
    }
}
IgxCsvExporterService.decorators = [
    { type: Injectable }
];

/**
 * @hidden
 */
var ExcelFolderTypes;
(function (ExcelFolderTypes) {
    ExcelFolderTypes[ExcelFolderTypes["RootExcelFolder"] = 0] = "RootExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["RootRelsExcelFolder"] = 1] = "RootRelsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["DocPropsExcelFolder"] = 2] = "DocPropsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["XLExcelFolder"] = 3] = "XLExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["XLRelsExcelFolder"] = 4] = "XLRelsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["ThemeExcelFolder"] = 5] = "ThemeExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["WorksheetsExcelFolder"] = 6] = "WorksheetsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["WorksheetsRelsExcelFolder"] = 7] = "WorksheetsRelsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["TablesExcelFolder"] = 8] = "TablesExcelFolder";
})(ExcelFolderTypes || (ExcelFolderTypes = {}));
/**
 * @hidden
 */
var ExcelFileTypes;
(function (ExcelFileTypes) {
    ExcelFileTypes[ExcelFileTypes["RootRelsFile"] = 0] = "RootRelsFile";
    ExcelFileTypes[ExcelFileTypes["AppFile"] = 1] = "AppFile";
    ExcelFileTypes[ExcelFileTypes["CoreFile"] = 2] = "CoreFile";
    ExcelFileTypes[ExcelFileTypes["WorkbookRelsFile"] = 3] = "WorkbookRelsFile";
    ExcelFileTypes[ExcelFileTypes["ThemeFile"] = 4] = "ThemeFile";
    ExcelFileTypes[ExcelFileTypes["WorksheetFile"] = 5] = "WorksheetFile";
    ExcelFileTypes[ExcelFileTypes["StyleFile"] = 6] = "StyleFile";
    ExcelFileTypes[ExcelFileTypes["WorkbookFile"] = 7] = "WorkbookFile";
    ExcelFileTypes[ExcelFileTypes["ContentTypesFile"] = 8] = "ContentTypesFile";
    ExcelFileTypes[ExcelFileTypes["SharedStringsFile"] = 9] = "SharedStringsFile";
    ExcelFileTypes[ExcelFileTypes["WorksheetRelsFile"] = 10] = "WorksheetRelsFile";
    ExcelFileTypes[ExcelFileTypes["TablesFile"] = 11] = "TablesFile";
})(ExcelFileTypes || (ExcelFileTypes = {}));

/** @hidden */
class ExcelStrings {
    static getRels() {
        return ExcelStrings.XML_STRING + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>';
    }
    static getApp(worksheetName) {
        return ExcelStrings.XML_STRING + `<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>${worksheetName}</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>`;
    }
    static getCore() {
        return ExcelStrings.XML_STRING + '<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator></dc:creator><cp:lastModifiedBy></cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">2015-06-05T18:17:20Z</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">2015-06-05T18:17:26Z</dcterms:modified></cp:coreProperties>';
    }
    static getTheme() {
        return ExcelStrings.XML_STRING + '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="5B9BD5"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="4472C4"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック Light"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线 Light"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>';
    }
    static getStyles(hasNumberValues, hasDateValues) {
        const cellXFCount = hasDateValues ? 3 : hasNumberValues ? 2 : 1;
        let additionalCellXF = '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0" applyNumberFormat="1"/>';
        if (hasDateValues) {
            additionalCellXF = additionalCellXF + ' <xf numFmtId="14" fontId="0" fillId="0" borderId="0" xfId="0" applyNumberFormat="1"/>';
        }
        return ExcelStrings.XML_STRING + '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="' + cellXFCount + '"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/>' + additionalCellXF + '</cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles><dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>';
    }
    static getWorkbook(worksheetName) {
        return ExcelStrings.XML_STRING + `<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><fileVersion appName="xl" lastEdited="6" lowestEdited="6" rupBuild="14420"/><workbookPr filterPrivacy="1" defaultThemeVersion="164011"/><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="22260" windowHeight="12645"/></bookViews><sheets><sheet name="${worksheetName}" sheetId="1" r:id="rId1"/></sheets><calcPr calcId="162913"/><extLst><ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:workbookPr chartTrackingRefBase="1"/></ext></extLst></workbook>`;
    }
    static getWorksheetRels() {
        return ExcelStrings.XML_STRING + `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/table" Target="../tables/table1.xml"/></Relationships>`;
    }
    static getWorkbookRels(hasSharedStrings) {
        let retVal = ExcelStrings.XML_STRING + `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>`;
        if (hasSharedStrings) {
            retVal += ExcelStrings.SHARED_STRING_RELATIONSHIP;
        }
        retVal += '</Relationships>';
        return retVal;
    }
    static getSheetXML(dimension, freezePane, cols, sheetData, hasTable, outlineLevel = 0) {
        const hasOutline = outlineLevel > 0;
        const tableParts = hasTable ? '<tableParts count="1"><tablePart r:id="rId1"/></tableParts>' : '';
        const sheetOutlineProp = hasOutline ? '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>' : '';
        const sOutlineLevel = hasOutline ? `outlineLevelRow="${outlineLevel}"` : '';
        // return ExcelStrings.XML_STRING +
        //     '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"><dimension ref="' + dimension + '"/><sheetViews><sheetView tabSelected="1" workbookViewId="0">' + freezePane + '</sheetView></sheetViews><sheetFormatPr defaultRowHeight="15" x14ac:dyDescent="0.25"/>' + cols + sheetData + '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>' + tableParts + '</worksheet>';
        return `${ExcelStrings.XML_STRING}
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">
${sheetOutlineProp}
<dimension ref="${dimension}"/>
<sheetViews><sheetView tabSelected="1" workbookViewId="0">${freezePane}</sheetView></sheetViews>
<sheetFormatPr defaultRowHeight="15" ${sOutlineLevel} x14ac:dyDescent="0.25"/>
${cols}
${sheetData}
<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>
${tableParts}</worksheet>`;
    }
    static getSharedStringXML(count, uniqueCount, table) {
        return ExcelStrings.XML_STRING + '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="' + count + '" uniqueCount="' + uniqueCount + '">' + table + '</sst>';
    }
    static getContentTypesXML(hasSharedStrings, hasTable) {
        let contentTypes = ExcelStrings.XML_STRING +
            `<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types\">
            <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
            <Default Extension="xml" ContentType="application/xml"/>
            <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>
            <Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>
            <Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>
            <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>
            <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
            <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>`;
        contentTypes += hasSharedStrings ?
            `	<Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>` : '';
        contentTypes += hasTable ?
            `<Override PartName="/xl/tables/table1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"/>` : '';
        contentTypes += `</Types>`;
        return contentTypes;
    }
    static getTablesXML(dimension, tableColumns, sort) {
        return `${ExcelStrings.XML_STRING}<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" id="1" name="Table1" displayName="Table1" ref="${dimension}" totalsRowShown="0">
    <autoFilter ref="${dimension}"/>${sort}${tableColumns}<tableStyleInfo name="TableStyleMedium2" showFirstColumn="0" showLastColumn="0" showRowStripes="1" showColumnStripes="0"/>
</table>`;
    }
    /* eslint-enable  max-len */
    static getExcelColumn(index) {
        // Returns the excel column name for given 0-based index
        // For example 27 should return "AB"
        let returnString = '';
        while (index >= 0) {
            const char = index % 26;
            returnString = String.fromCharCode(65 + char) + returnString;
            index = Math.floor(index / 26) - 1;
        }
        return returnString;
    }
}
/* eslint-disable  max-len */
ExcelStrings.XML_STRING = '<?xml version="1.0" encoding="UTF-8"?>\r\n';
ExcelStrings.SHARED_STRING_RELATIONSHIP = '<Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml" />';

/**
 * @hidden
 */
class RootRelsFile {
    writeElement(folder) {
        folder.file('.rels', ExcelStrings.getRels());
    }
}
/**
 * @hidden
 */
class AppFile {
    writeElement(folder, worksheetData) {
        folder.file('app.xml', ExcelStrings.getApp(worksheetData.options.worksheetName));
    }
}
/**
 * @hidden
 */
class CoreFile {
    writeElement(folder) {
        folder.file('core.xml', ExcelStrings.getCore());
    }
}
/**
 * @hidden
 */
class WorkbookRelsFile {
    writeElement(folder, worksheetData) {
        const hasSharedStrings = worksheetData.isEmpty === false;
        folder.file('workbook.xml.rels', ExcelStrings.getWorkbookRels(hasSharedStrings));
    }
}
/**
 * @hidden
 */
class ThemeFile {
    writeElement(folder) {
        folder.file('theme1.xml', ExcelStrings.getTheme());
    }
}
/**
 * @hidden
 */
class WorksheetFile {
    constructor() {
        this.maxOutlineLevel = 0;
        this.dimension = '';
        this.freezePane = '';
        this.rowHeight = '';
        /* eslint-enable  @typescript-eslint/member-ordering */
    }
    writeElement() { }
    writeElementAsync(folder, worksheetData) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                this.prepareDataAsync(worksheetData, (cols, rows) => {
                    const hasTable = !worksheetData.isEmpty && worksheetData.options.exportAsTable;
                    folder.file('sheet1.xml', ExcelStrings.getSheetXML(this.dimension, this.freezePane, cols, rows, hasTable, this.maxOutlineLevel));
                    resolve();
                });
            });
        });
    }
    prepareDataAsync(worksheetData, done) {
        let sheetData = '';
        let cols = '';
        const dictionary = worksheetData.dataDictionary;
        if (worksheetData.isEmpty) {
            sheetData += '<sheetData/>';
            this.dimension = 'A1';
            done('', sheetData);
        }
        else {
            sheetData += '<sheetData>';
            const height = worksheetData.options.rowHeight;
            this.rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
            sheetData += `<row r="1"${this.rowHeight}>`;
            for (let i = 0; i < worksheetData.columnCount; i++) {
                const column = ExcelStrings.getExcelColumn(i) + 1;
                const value = dictionary.saveValue(worksheetData.keys[i], i, true);
                sheetData += `<c r="${column}" t="s"><v>${value}</v></c>`;
            }
            sheetData += '</row>';
            this.dimension = 'A1:' + ExcelStrings.getExcelColumn(worksheetData.columnCount - 1) + worksheetData.rowCount;
            cols += '<cols>';
            for (let i = 0; i < worksheetData.columnCount; i++) {
                const width = dictionary.columnWidths[i];
                // Use the width provided in the options if it exists
                let widthInTwips = worksheetData.options.columnWidth !== undefined ?
                    worksheetData.options.columnWidth :
                    Math.max(((width / 96) * 14.4), WorksheetFile.MIN_WIDTH);
                if (!(widthInTwips > 0)) {
                    widthInTwips = WorksheetFile.MIN_WIDTH;
                }
                cols += `<col min="${(i + 1)}" max="${(i + 1)}" width="${widthInTwips}" customWidth="1"/>`;
            }
            cols += '</cols>';
            if (worksheetData.indexOfLastPinnedColumn !== -1 &&
                !worksheetData.options.ignorePinning &&
                !worksheetData.options.ignoreColumnsOrder) {
                const frozenColumnCount = worksheetData.indexOfLastPinnedColumn + 1;
                const firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + '1';
                this.freezePane = `<pane xSplit="${frozenColumnCount}" topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
            }
            this.processDataRecordsAsync(worksheetData, (rows) => {
                sheetData += rows;
                sheetData += '</sheetData>';
                done(cols, sheetData);
            });
        }
    }
    processDataRecordsAsync(worksheetData, done) {
        const rowDataArr = new Array(worksheetData.rowCount - 1);
        const height = worksheetData.options.rowHeight;
        this.rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
        yieldingLoop(worksheetData.rowCount - 1, 1000, (i) => {
            rowDataArr[i] = this.processRow(worksheetData, i + 1);
        }, () => {
            done(rowDataArr.join(''));
        });
    }
    processRow(worksheetData, i) {
        const rowData = new Array(worksheetData.columnCount + 2);
        const record = worksheetData.data[i - 1];
        const sHidden = record.hidden ? ` hidden="1"` : '';
        const rowLevel = record.level;
        const outlineLevel = rowLevel > 0 ? ` outlineLevel="${rowLevel}"` : '';
        this.maxOutlineLevel = this.maxOutlineLevel < rowLevel ? rowLevel : this.maxOutlineLevel;
        rowData[0] = `<row r="${(i + 1)}"${this.rowHeight}${outlineLevel}${sHidden}>`;
        for (let j = 0; j < worksheetData.columnCount; j++) {
            const cellData = WorksheetFile.getCellData(worksheetData, i, j);
            rowData[j + 1] = cellData;
        }
        rowData[worksheetData.columnCount + 1] = '</row>';
        return rowData.join('');
    }
    /* eslint-disable  @typescript-eslint/member-ordering */
    static getCellData(worksheetData, row, column) {
        const dictionary = worksheetData.dataDictionary;
        const columnName = ExcelStrings.getExcelColumn(column) + (row + 1);
        const columnHeader = worksheetData.keys[column];
        const fullRow = worksheetData.data[row - 1];
        const cellValue = worksheetData.isSpecialData ?
            fullRow.data :
            fullRow.data[columnHeader];
        if (cellValue === undefined || cellValue === null) {
            return `<c r="${columnName}" s="1"/>`;
        }
        else {
            const savedValue = dictionary.saveValue(cellValue, column, false);
            const isSavedAsString = savedValue !== -1;
            const isSavedAsDate = !isSavedAsString && cellValue instanceof Date;
            let value = isSavedAsString ? savedValue : cellValue;
            if (isSavedAsDate) {
                const timeZoneOffset = value.getTimezoneOffset() * 60000;
                const isoString = (new Date(value - timeZoneOffset)).toISOString();
                value = isoString.substring(0, isoString.indexOf('.'));
            }
            const type = isSavedAsString ? ` t="s"` : isSavedAsDate ? ` t="d"` : '';
            const format = isSavedAsString ? '' : isSavedAsDate ? ` s="2"` : ` s="1"`;
            return `<c r="${columnName}"${type}${format}><v>${value}</v></c>`;
        }
    }
}
WorksheetFile.MIN_WIDTH = 8.43;
/**
 * @hidden
 */
class StyleFile {
    writeElement(folder, worksheetData) {
        const hasNumberValues = worksheetData.dataDictionary && worksheetData.dataDictionary.hasNumberValues;
        const hasDateValues = worksheetData.dataDictionary && worksheetData.dataDictionary.hasDateValues;
        folder.file('styles.xml', ExcelStrings.getStyles(hasNumberValues, hasDateValues));
    }
}
/**
 * @hidden
 */
class WorkbookFile {
    writeElement(folder, worksheetData) {
        folder.file('workbook.xml', ExcelStrings.getWorkbook(worksheetData.options.worksheetName));
    }
}
/**
 * @hidden
 */
class ContentTypesFile {
    writeElement(folder, worksheetData) {
        folder.file('[Content_Types].xml', ExcelStrings.getContentTypesXML(!worksheetData.isEmpty, worksheetData.options.exportAsTable));
    }
}
/**
 * @hidden
 */
class SharedStringsFile {
    writeElement(folder, worksheetData) {
        const dict = worksheetData.dataDictionary;
        const sortedValues = dict.getKeys();
        const sharedStrings = new Array(sortedValues.length);
        for (const value of sortedValues) {
            sharedStrings[dict.getSanitizedValue(value)] = '<si><t>' + value + '</t></si>';
        }
        folder.file('sharedStrings.xml', ExcelStrings.getSharedStringXML(dict.stringsCount, sortedValues.length, sharedStrings.join('')));
    }
}
/**
 * @hidden
 */
class TablesFile {
    writeElement(folder, worksheetData) {
        const columnCount = worksheetData.columnCount;
        const lastColumn = ExcelStrings.getExcelColumn(columnCount - 1) + worksheetData.rowCount;
        const dimension = 'A1:' + lastColumn;
        const values = worksheetData.keys;
        let sortString = '';
        let tableColumns = '<tableColumns count="' + columnCount + '">';
        for (let i = 0; i < columnCount; i++) {
            const value = values[i];
            tableColumns += '<tableColumn id="' + (i + 1) + '" name="' + value + '"/>';
        }
        tableColumns += '</tableColumns>';
        if (worksheetData.sort) {
            const sortingExpression = worksheetData.sort;
            const sc = ExcelStrings.getExcelColumn(values.indexOf(sortingExpression.fieldName));
            const dir = sortingExpression.dir - 1;
            sortString = `<sortState ref="A2:${lastColumn}"><sortCondition descending="${dir}" ref="${sc}1:${sc}15"/></sortState>`;
        }
        folder.file('table1.xml', ExcelStrings.getTablesXML(dimension, tableColumns, sortString));
    }
}
/**
 * @hidden
 */
class WorksheetRelsFile {
    writeElement(folder) {
        folder.file('sheet1.xml.rels', ExcelStrings.getWorksheetRels());
    }
}

/** @hidden */
class RootExcelFolder {
    get folderName() {
        return '';
    }
    childFiles() {
        return [ExcelFileTypes.ContentTypesFile];
    }
    childFolders() {
        return [
            ExcelFolderTypes.RootRelsExcelFolder,
            ExcelFolderTypes.DocPropsExcelFolder,
            ExcelFolderTypes.XLExcelFolder
        ];
    }
}
/** @hidden */
class RootRelsExcelFolder {
    get folderName() {
        return '_rels';
    }
    childFiles() {
        return [ExcelFileTypes.RootRelsFile];
    }
    childFolders() {
        return [];
    }
}
/** @hidden */
class DocPropsExcelFolder {
    get folderName() {
        return 'docProps';
    }
    childFiles() {
        return [
            ExcelFileTypes.AppFile,
            ExcelFileTypes.CoreFile
        ];
    }
    childFolders() {
        return [];
    }
}
/** @hidden */
class XLExcelFolder {
    get folderName() {
        return 'xl';
    }
    childFiles(data) {
        const retVal = [
            ExcelFileTypes.StyleFile,
            ExcelFileTypes.WorkbookFile
        ];
        if (!data.isEmpty) {
            retVal.push(ExcelFileTypes.SharedStringsFile);
        }
        return retVal;
    }
    childFolders(data) {
        const retVal = [
            ExcelFolderTypes.XLRelsExcelFolder,
            ExcelFolderTypes.ThemeExcelFolder,
            ExcelFolderTypes.WorksheetsExcelFolder
        ];
        if (!data.isEmpty && data.options.exportAsTable) {
            retVal.push(ExcelFolderTypes.TablesExcelFolder);
        }
        return retVal;
    }
}
/** @hidden */
class XLRelsExcelFolder {
    get folderName() {
        return '_rels';
    }
    childFiles() {
        return [ExcelFileTypes.WorkbookRelsFile];
    }
    childFolders() {
        return [];
    }
}
/** @hidden */
class ThemeExcelFolder {
    get folderName() {
        return 'theme';
    }
    childFiles() {
        return [ExcelFileTypes.ThemeFile];
    }
    childFolders() {
        return [];
    }
}
/** @hidden */
class WorksheetsExcelFolder {
    get folderName() {
        return 'worksheets';
    }
    childFiles() {
        return [ExcelFileTypes.WorksheetFile];
    }
    childFolders(data) {
        return data.isEmpty || !data.options.exportAsTable ? [] : [ExcelFolderTypes.WorksheetsRelsExcelFolder];
    }
}
/** @hidden */
class TablesExcelFolder {
    get folderName() {
        return 'tables';
    }
    childFiles() {
        return [ExcelFileTypes.TablesFile];
    }
    childFolders() {
        return [];
    }
}
/** @hidden */
class WorksheetsRelsExcelFolder {
    get folderName() {
        return '_rels';
    }
    childFiles() {
        return [ExcelFileTypes.WorksheetRelsFile];
    }
    childFolders() {
        return [];
    }
}

/** @hidden */
class ExcelElementsFactory {
    static getExcelFolder(type) {
        switch (type) {
            case ExcelFolderTypes.RootExcelFolder:
                return new RootExcelFolder();
            case ExcelFolderTypes.RootRelsExcelFolder:
                return new RootRelsExcelFolder();
            case ExcelFolderTypes.DocPropsExcelFolder:
                return new DocPropsExcelFolder();
            case ExcelFolderTypes.XLExcelFolder:
                return new XLExcelFolder();
            case ExcelFolderTypes.XLRelsExcelFolder:
                return new XLRelsExcelFolder();
            case ExcelFolderTypes.ThemeExcelFolder:
                return new ThemeExcelFolder();
            case ExcelFolderTypes.WorksheetsExcelFolder:
                return new WorksheetsExcelFolder();
            case ExcelFolderTypes.WorksheetsRelsExcelFolder:
                return new WorksheetsRelsExcelFolder();
            case ExcelFolderTypes.TablesExcelFolder:
                return new TablesExcelFolder();
            default:
                throw new Error('Unknown excel folder type!');
        }
    }
    static getExcelFile(type) {
        switch (type) {
            case ExcelFileTypes.RootRelsFile:
                return new RootRelsFile();
            case ExcelFileTypes.AppFile:
                return new AppFile();
            case ExcelFileTypes.CoreFile:
                return new CoreFile();
            case ExcelFileTypes.WorkbookRelsFile:
                return new WorkbookRelsFile();
            case ExcelFileTypes.ThemeFile:
                return new ThemeFile();
            case ExcelFileTypes.WorksheetFile:
                return new WorksheetFile();
            case ExcelFileTypes.StyleFile:
                return new StyleFile();
            case ExcelFileTypes.WorkbookFile:
                return new WorkbookFile();
            case ExcelFileTypes.ContentTypesFile:
                return new ContentTypesFile();
            case ExcelFileTypes.SharedStringsFile:
                return new SharedStringsFile();
            case ExcelFileTypes.WorksheetRelsFile:
                return new WorksheetRelsFile();
            case ExcelFileTypes.TablesFile:
                return new TablesFile();
            default:
                throw Error('Unknown excel file type!');
        }
    }
}

/** @hidden */
class WorksheetDataDictionary {
    constructor(columnCount, columnWidth, columnWidthsList) {
        this.hasNumberValues = false;
        this.hasDateValues = false;
        this._dictionary = {};
        this._widthsDictionary = {};
        this._counter = 0;
        this.dirtyKeyCollections();
        this._columnWidths = new Array(columnCount);
        this._columnTypeInfo = new Array(columnCount);
        if (columnWidth) {
            this._columnWidths.fill(columnWidth);
        }
        else {
            this._columnWidths = columnWidthsList;
        }
        this.stringsCount = 0;
    }
    get columnWidths() {
        return this._columnWidths;
    }
    saveValue(value, column, isHeader) {
        if (this._columnTypeInfo[column] === undefined && isHeader === false) {
            this._columnTypeInfo[column] = typeof value !== 'number' && value !== Number(value) && !Number.isFinite(value);
        }
        let sanitizedValue = '';
        const isDate = value instanceof Date;
        const isSavedAsString = (this._columnTypeInfo[column] || isHeader) && !isDate;
        if (isSavedAsString) {
            sanitizedValue = this.sanitizeValue(value);
            if (this._dictionary[sanitizedValue] === undefined) {
                this._dictionary[sanitizedValue] = this._counter++;
                this.dirtyKeyCollections();
            }
            this.stringsCount++;
        }
        else if (isDate) {
            this.hasDateValues = true;
        }
        else {
            this.hasNumberValues = true;
        }
        return isSavedAsString ? this.getSanitizedValue(sanitizedValue) : -1;
    }
    getValue(value) {
        return this.getSanitizedValue(this.sanitizeValue(value));
    }
    getSanitizedValue(sanitizedValue) {
        return this._dictionary[sanitizedValue];
    }
    getKeys() {
        if (!this._keysAreValid) {
            this._keys = Object.keys(this._dictionary);
            this._keysAreValid = true;
        }
        return this._keys;
    }
    getTextWidth(value) {
        if (this._widthsDictionary[value] === undefined) {
            const context = this.getContext();
            const metrics = context.measureText(value);
            this._widthsDictionary[value] = metrics.width + WorksheetDataDictionary.TEXT_PADDING;
        }
        return this._widthsDictionary[value];
    }
    getContext() {
        if (!this._context) {
            const canvas = document.createElement('canvas');
            this._context = canvas.getContext('2d');
            this._context.font = WorksheetDataDictionary.DEFAULT_FONT;
        }
        return this._context;
    }
    sanitizeValue(value) {
        if (ExportUtilities.hasValue(value) === false) {
            return '';
        }
        else {
            const stringValue = String(value);
            return stringValue.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }
    }
    dirtyKeyCollections() {
        this._keysAreValid = false;
    }
}
WorksheetDataDictionary.DEFAULT_FONT = '11pt Calibri';
WorksheetDataDictionary.TEXT_PADDING = 5;

/** @hidden */
class WorksheetData {
    constructor(_data, _columnWidths, options, indexOfLastPinnedColumn, sort) {
        this._data = _data;
        this._columnWidths = _columnWidths;
        this.options = options;
        this.indexOfLastPinnedColumn = indexOfLastPinnedColumn;
        this.sort = sort;
        this.initializeData();
    }
    get data() {
        return this._data;
    }
    get columnCount() {
        return this._columnCount;
    }
    get rowCount() {
        return this._rowCount;
    }
    get isEmpty() {
        return !this.rowCount || !this._columnCount;
    }
    get keys() {
        return this._keys;
    }
    get isSpecialData() {
        return this._isSpecialData;
    }
    get dataDictionary() {
        return this._dataDictionary;
    }
    initializeData() {
        if (!this._data || this._data.length === 0) {
            return;
        }
        const actualData = this._data.map(item => item.data);
        this._keys = ExportUtilities.getKeysFromData(actualData);
        if (this._keys.length === 0) {
            return;
        }
        this._isSpecialData = ExportUtilities.isSpecialData(actualData);
        this._columnCount = this._keys.length;
        this._rowCount = this._data.length + 1;
        this._dataDictionary = new WorksheetDataDictionary(this._columnCount, this.options.columnWidth, this._columnWidths);
    }
}

/**
 * **Ignite UI for Angular Excel Exporter Service** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_excel.html)
 *
 * The Ignite UI for Angular Excel Exporter service can export data in Microsoft® Excel® format from both raw data
 * (array) or from an `IgxGrid`.
 *
 * Example:
 * ```typescript
 * public localData = [
 *   { Name: "Eric Ridley", Age: "26" },
 *   { Name: "Alanis Brook", Age: "22" },
 *   { Name: "Jonathan Morris", Age: "23" }
 * ];
 *
 * constructor(private excelExportService: IgxExcelExporterService) {
 * }
 *
 * this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions("FileName"));
 * ```
 */
class IgxExcelExporterService extends IgxBaseExporter {
    constructor() {
        super(...arguments);
        /**
         * This event is emitted when the export process finishes.
         * ```typescript
         * this.exporterService.exportEnded.subscribe((args: IExcelExportEndedEventArgs) => {
         * // put event handler code here
         * });
         * ```
         *
         * @memberof IgxExcelExporterService
         */
        this.exportEnded = new EventEmitter();
    }
    static populateFolderAsync(folder, zip, worksheetData) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const childFolder of folder.childFolders(worksheetData)) {
                const folderInstance = ExcelElementsFactory.getExcelFolder(childFolder);
                const zipFolder = zip.folder(folderInstance.folderName);
                yield IgxExcelExporterService.populateFolderAsync(folderInstance, zipFolder, worksheetData);
            }
            for (const childFile of folder.childFiles(worksheetData)) {
                const fileInstance = ExcelElementsFactory.getExcelFile(childFile);
                if (fileInstance instanceof WorksheetFile) {
                    yield fileInstance.writeElementAsync(zip, worksheetData);
                }
                else {
                    fileInstance.writeElement(zip, worksheetData);
                }
            }
        });
    }
    exportDataImplementation(data, options) {
        var _a;
        const level = (_a = data[0]) === null || _a === void 0 ? void 0 : _a.level;
        if (typeof level !== 'undefined') {
            let maxLevel = 0;
            data.forEach((r) => {
                maxLevel = Math.max(maxLevel, r.level);
            });
            if (maxLevel > 7) {
                throw Error('Can create an outline of up to eight levels!');
            }
        }
        const worksheetData = new WorksheetData(data, this.columnWidthList, options, this._indexOfLastPinnedColumn, this._sort);
        this._xlsx = new JSZip();
        const rootFolder = ExcelElementsFactory.getExcelFolder(ExcelFolderTypes.RootExcelFolder);
        IgxExcelExporterService.populateFolderAsync(rootFolder, this._xlsx, worksheetData)
            .then(() => {
            this._xlsx.generateAsync(IgxExcelExporterService.ZIP_OPTIONS).then((result) => {
                this.saveFile(result, options.fileName);
                this.exportEnded.emit({ xlsx: this._xlsx });
            });
        });
    }
    saveFile(data, fileName) {
        const blob = new Blob([ExportUtilities.stringToArrayBuffer(atob(data))], {
            type: ''
        });
        ExportUtilities.saveBlobToFile(blob, fileName);
    }
}
IgxExcelExporterService.ZIP_OPTIONS = { compression: 'DEFLATE', type: 'base64' };
IgxExcelExporterService.decorators = [
    { type: Injectable }
];

/**
 * Objects of this class are used to configure the Excel exporting process.
 */
class IgxExcelExporterOptions extends IgxExporterOptionsBase {
    constructor(fileName) {
        super(fileName, '.xlsx');
        /**
         * Specifies if column pinning should be ignored. If ignoreColumnsOrder is set to true,
         * this option will always be considered as set to true.
         * ```typescript
         * let ignorePinning = this.exportOptions.ignorePinning;
         * this.exportOptions.ignorePinning = true;
         * ```
         *
         * @memberof IgxExcelExporterOptions
         */
        this.ignorePinning = false;
        /**
         * Specifies whether the exported data should be formatted as Excel table. (True by default)
         * ```typescript
         * let exportAsTable = this.exportOptions.exportAsTable;
         * this.exportOptions.exportAsTable = false;
         * ```
         *
         * @memberof IgxExcelExporterOptions
         */
        this.exportAsTable = true;
    }
    /**
     * Gets the width of the columns in the exported excel file.
     * ```typescript
     * let width = this.exportOptions.columnWidth;
     * ```
     *
     * @memberof IgxExcelExporterOptions
     */
    get columnWidth() {
        return this._columnWidth;
    }
    /**
     * Sets the width of the columns in the exported excel file. If left unspecified,
     * the width of the column or the default width of the excel columns will be used.
     * ```typescript
     * this.exportOptions.columnWidth = 55;
     * ```
     *
     * @memberof IgxExcelExporterOptions
     */
    set columnWidth(value) {
        if (value < 0) {
            throw Error('Invalid value for column width!');
        }
        this._columnWidth = value;
    }
    /**
     * Gets the height of the rows in the exported excel file.
     * ```typescript
     * let height = this.exportOptions.rowHeight;
     * ```
     *
     * @memberof IgxExcelExporterOptions
     */
    get rowHeight() {
        return this._rowHeight;
    }
    /**
     * Sets the height of the rows in the exported excel file. If left unspecified or 0,
     * the default height of the excel rows will be used.
     * ```typescript
     * this.exportOptions.rowHeight = 25;
     * ```
     *
     * @memberof IgxExcelExporterOptions
     */
    set rowHeight(value) {
        if (value < 0) {
            throw Error('Invalid value for row height!');
        }
        this._rowHeight = value;
    }
    /**
     * Gets the name of the worksheet in the exported excel file.
     * ```typescript
     * let worksheetName = this.exportOptions.worksheetName;
     * ```
     *
     * @memberof IgxExcelExporterOptions
     */
    get worksheetName() {
        if (this._worksheetName === undefined || this._worksheetName === null) {
            return 'Sheet1';
        }
        return this._worksheetName;
    }
    /**
     * Sets the name of the worksheet in the exported excel file.
     * ```typescript
     * this.exportOptions.worksheetName = "Worksheet";
     * ```
     *
     * @memberof IgxExcelExporterOptions
     */
    set worksheetName(value) {
        this._worksheetName = value;
    }
}

/**
 * @hidden
 */
const DeprecateClass = (message) => {
    let isMessageShown = false;
    return (originalClass) => class extends originalClass {
        constructor(...args) {
            const target = originalClass;
            const targetName = typeof target === 'function' ? target.name : target.constructor.name;
            isMessageShown = showMessage(`${targetName}: ${message}`, isMessageShown);
            super(...args);
        }
    };
};
/**
 * @hidden
 */
function DeprecateMethod(message) {
    let isMessageShown = false;
    return function (target, key, descriptor) {
        if (descriptor && descriptor.value) {
            const originalMethod = descriptor.value;
            descriptor.value = function () {
                const targetName = typeof target === 'function' ? target.name : target.constructor.name;
                isMessageShown = showMessage(`${targetName}.${key}: ${message}`, isMessageShown);
                const args = [];
                for (const x of arguments) {
                    args.push(x);
                }
                return originalMethod.call(this, args);
            };
            return descriptor;
        }
    };
}
/**
 * @hidden
 */
function DeprecateProperty(message) {
    return function (target, key) {
        let isMessageShown = false;
        const messageToDisplay = `${target.constructor.name}.${key}: ${message}`;
        // if the target already has the property defined
        const originalDescriptor = Object.getOwnPropertyDescriptor(target, key);
        if (originalDescriptor) {
            const getter = originalDescriptor.get;
            const setter = originalDescriptor.set;
            if (getter) {
                originalDescriptor.get = function () {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    return getter.call(this);
                };
            }
            if (setter) {
                originalDescriptor.set = function (value) {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    setter.call(this, value);
                };
            }
            return originalDescriptor;
        }
        // the target doesn't contain a descriptor for that property, so create one
        // use backing field to set/get the value of the property to ensure there won't be infinite recursive calls
        const newKey = generateUniqueKey(target, key);
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: true,
            set(value) {
                isMessageShown = showMessage(messageToDisplay, isMessageShown);
                this[newKey] = value;
            },
            get() {
                isMessageShown = showMessage(messageToDisplay, isMessageShown);
                return this[newKey];
            }
        });
    };
}
/**
 * @hidden
 */
const generateUniqueKey = (target, key) => {
    let newKey = '_' + key;
    while (target.hasOwnProperty(newKey)) {
        newKey = '_' + newKey;
    }
    return newKey;
};
const ɵ0$1 = generateUniqueKey;
/**
 * @hidden
 */
const showMessage = (message, isMessageShown) => {
    if (!isMessageShown && isDevMode()) {
        console.warn(message);
    }
    return true;
};

var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment[HorizontalAlignment["Left"] = -1] = "Left";
    HorizontalAlignment[HorizontalAlignment["Center"] = -0.5] = "Center";
    HorizontalAlignment[HorizontalAlignment["Right"] = 0] = "Right";
})(HorizontalAlignment || (HorizontalAlignment = {}));
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Top"] = -1] = "Top";
    VerticalAlignment[VerticalAlignment["Middle"] = -0.5] = "Middle";
    VerticalAlignment[VerticalAlignment["Bottom"] = 0] = "Bottom";
})(VerticalAlignment || (VerticalAlignment = {}));
/**
 * Defines the possible values of the overlays' position strategy.
 */
var RelativePositionStrategy;
(function (RelativePositionStrategy) {
    RelativePositionStrategy["Connected"] = "connected";
    RelativePositionStrategy["Auto"] = "auto";
    RelativePositionStrategy["Elastic"] = "elastic";
})(RelativePositionStrategy || (RelativePositionStrategy = {}));
/**
 * Defines the possible positions for the relative overlay settings presets.
 */
var RelativePosition;
(function (RelativePosition) {
    RelativePosition["Above"] = "above";
    RelativePosition["Below"] = "below";
    RelativePosition["Before"] = "before";
    RelativePosition["After"] = "after";
    RelativePosition["Default"] = "default";
})(RelativePosition || (RelativePosition = {}));
/**
 * Defines the possible positions for the absolute overlay settings presets.
 */
var AbsolutePosition;
(function (AbsolutePosition) {
    AbsolutePosition["Bottom"] = "bottom";
    AbsolutePosition["Top"] = "top";
    AbsolutePosition["Center"] = "center";
})(AbsolutePosition || (AbsolutePosition = {}));
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}
/** @hidden */
class Util {
    /**
     * @hidden
     * Calculates the rectangle of target for provided overlay settings. Defaults to 0,0,0,0,0,0 rectangle
     * if no target is provided
     * @param settings Overlay settings for which to calculate target rectangle
     */
    static getTargetRect(target) {
        let targetRect = {
            bottom: 0,
            height: 0,
            left: 0,
            right: 0,
            top: 0,
            width: 0
        };
        if (target instanceof HTMLElement) {
            targetRect = target.getBoundingClientRect();
        }
        else if (target instanceof Point) {
            const targetPoint = target;
            targetRect = {
                bottom: targetPoint.y,
                height: 0,
                left: targetPoint.x,
                right: targetPoint.x,
                top: targetPoint.y,
                width: 0
            };
        }
        return targetRect;
    }
    /** @hidden @internal */
    static getViewportRect(document) {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const scrollPosition = Util.getViewportScrollPosition(document);
        return {
            top: scrollPosition.y,
            left: scrollPosition.x,
            right: scrollPosition.x + width,
            bottom: scrollPosition.y + height,
            width,
            height,
        };
    }
    /** @hidden @internal */
    static getViewportScrollPosition(document) {
        const documentElement = document.documentElement;
        const documentRect = documentElement.getBoundingClientRect();
        const horizontalScrollPosition = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;
        const verticalScrollPosition = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;
        return new Point(horizontalScrollPosition, verticalScrollPosition);
    }
    /** @hidden @internal */
    static cloneInstance(object) {
        const clonedObj = Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        clonedObj.settings = cloneValue(clonedObj.settings);
        return clonedObj;
    }
}

/**
 * Positions the element based on the directions and start point passed in trough PositionSettings.
 * It is possible to either pass a start point or an HTMLElement as a positioning base.
 */
class ConnectedPositioningStrategy {
    constructor(settings) {
        this._defaultSettings = {
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom,
            openAnimation: scaleInVerTop,
            closeAnimation: scaleOutVerTop,
            minSize: { width: 0, height: 0 }
        };
        this.settings = Object.assign({}, this._defaultSettings, settings);
    }
    /** @inheritdoc */
    position(contentElement, size, document, initialCall, target) {
        const targetElement = target || this.settings.target;
        const rects = this.calculateElementRectangles(contentElement, targetElement);
        this.setStyle(contentElement, rects.targetRect, rects.elementRect, {});
    }
    /**
     * @inheritdoc
     * Creates clone of this position strategy
     * @returns clone of this position strategy
     */
    clone() {
        return Util.cloneInstance(this);
    }
    /**
     * Obtains the ClientRect objects for the required elements - target and element to position
     *
     * @returns target and element ClientRect objects
     */
    calculateElementRectangles(contentElement, target) {
        return {
            targetRect: Util.getTargetRect(target),
            elementRect: contentElement.getBoundingClientRect()
        };
    }
    /**
     * Sets element's style which effectively positions provided element according
     * to provided position settings
     *
     * @param element Element to position
     * @param targetRect Bounding rectangle of strategy target
     * @param elementRect Bounding rectangle of the element
     */
    setStyle(element, targetRect, elementRect, connectedFit) {
        const horizontalOffset = connectedFit.horizontalOffset ? connectedFit.horizontalOffset : 0;
        const verticalOffset = connectedFit.verticalOffset ? connectedFit.verticalOffset : 0;
        const startPoint = {
            x: targetRect.right + targetRect.width * this.settings.horizontalStartPoint + horizontalOffset,
            y: targetRect.bottom + targetRect.height * this.settings.verticalStartPoint + verticalOffset
        };
        const wrapperRect = element.parentElement.getBoundingClientRect();
        //  clean up styles - if auto position strategy is chosen we may pass here several times
        element.style.right = '';
        element.style.left = '';
        element.style.bottom = '';
        element.style.top = '';
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                element.style.right = `${Math.round(wrapperRect.right - startPoint.x)}px`;
                break;
            case HorizontalAlignment.Center:
                element.style.left = `${Math.round(startPoint.x - wrapperRect.left - elementRect.width / 2)}px`;
                break;
            case HorizontalAlignment.Right:
                element.style.left = `${Math.round(startPoint.x - wrapperRect.left)}px`;
                break;
        }
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                element.style.bottom = `${Math.round(wrapperRect.bottom - startPoint.y)}px`;
                break;
            case VerticalAlignment.Middle:
                element.style.top = `${Math.round(startPoint.y - wrapperRect.top - elementRect.height / 2)}px`;
                break;
            case VerticalAlignment.Bottom:
                element.style.top = `${Math.round(startPoint.y - wrapperRect.top)}px`;
                break;
        }
    }
}

/**
 * Positions the element based on the directions passed in trough PositionSettings.
 * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
 */
class GlobalPositionStrategy {
    constructor(settings) {
        this._defaultSettings = {
            horizontalDirection: HorizontalAlignment.Center,
            verticalDirection: VerticalAlignment.Middle,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle,
            openAnimation: fadeIn,
            closeAnimation: fadeOut,
            minSize: { width: 0, height: 0 }
        };
        this.settings = Object.assign({}, this._defaultSettings, settings);
    }
    /** @inheritdoc */
    position(contentElement, size, document, initialCall) {
        contentElement.classList.add('igx-overlay__content--relative');
        contentElement.parentElement.classList.add('igx-overlay__wrapper--flex');
        this.setPosition(contentElement, this.settings);
    }
    /** @inheritdoc */
    clone() {
        return Util.cloneInstance(this);
    }
    setPosition(contentElement, settings) {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                contentElement.parentElement.style.justifyContent = 'flex-start';
                break;
            case HorizontalAlignment.Center:
                contentElement.parentElement.style.justifyContent = 'center';
                break;
            case HorizontalAlignment.Right:
                contentElement.parentElement.style.justifyContent = 'flex-end';
                break;
            default:
                break;
        }
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                contentElement.parentElement.style.alignItems = 'flex-start';
                break;
            case VerticalAlignment.Middle:
                contentElement.parentElement.style.alignItems = 'center';
                break;
            case VerticalAlignment.Bottom:
                contentElement.parentElement.style.alignItems = 'flex-end';
                break;
            default:
                break;
        }
    }
}

class ScrollStrategy {
    constructor(scrollContainer) { }
}

/**
 * Empty scroll strategy. Does nothing.
 */
class NoOpScrollStrategy extends ScrollStrategy {
    constructor(scrollContainer) {
        super(scrollContainer);
    }
    /** @inheritdoc */
    initialize(document, overlayService, id) { }
    /** @inheritdoc */
    attach() { }
    /** @inheritdoc */
    detach() { }
}

/**
 * Positions the element inside the containing outlet based on the directions passed in trough PositionSettings.
 * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
 */
class ContainerPositionStrategy extends GlobalPositionStrategy {
    constructor(settings) {
        super(settings);
    }
    /** @inheritdoc */
    position(contentElement, size, document, initialCall) {
        contentElement.classList.add('igx-overlay__content--relative');
        contentElement.parentElement.classList.add('igx-overlay__wrapper--flex-container');
        this.setPosition(contentElement, this.settings);
    }
}

class BaseFitPositionStrategy extends ConnectedPositioningStrategy {
    /** @inheritdoc */
    position(contentElement, size, document, initialCall, target) {
        const targetElement = target || this.settings.target;
        const rects = super.calculateElementRectangles(contentElement, targetElement);
        const connectedFit = {};
        if (initialCall) {
            connectedFit.targetRect = rects.targetRect;
            connectedFit.contentElementRect = rects.elementRect;
            this._initialSettings = this._initialSettings || Object.assign({}, this.settings);
            this.settings = Object.assign({}, this._initialSettings);
            connectedFit.viewPortRect = Util.getViewportRect(document);
            this.updateViewPortFit(connectedFit);
            if (this.shouldFitInViewPort(connectedFit)) {
                this.fitInViewport(contentElement, connectedFit);
            }
        }
        this.setStyle(contentElement, rects.targetRect, rects.elementRect, connectedFit);
    }
    /**
     * Checks if element can fit in viewport and updates provided connectedFit
     * with the result
     *
     * @param connectedFit connectedFit to update
     */
    updateViewPortFit(connectedFit) {
        connectedFit.left = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.horizontalStartPoint, this.settings.horizontalDirection, connectedFit.horizontalOffset ? connectedFit.horizontalOffset : 0);
        connectedFit.right = connectedFit.left + connectedFit.contentElementRect.width;
        connectedFit.fitHorizontal = {
            back: Math.round(connectedFit.left),
            forward: Math.round(connectedFit.viewPortRect.width - connectedFit.right)
        };
        connectedFit.top = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.verticalStartPoint, this.settings.verticalDirection, connectedFit.verticalOffset ? connectedFit.verticalOffset : 0);
        connectedFit.bottom = connectedFit.top + connectedFit.contentElementRect.height;
        connectedFit.fitVertical = {
            back: Math.round(connectedFit.top),
            forward: Math.round(connectedFit.viewPortRect.height - connectedFit.bottom)
        };
    }
    /**
     * Calculates the position of the left border of the element if it gets positioned
     * with provided start point and direction
     *
     * @param targetRect Rectangle of the target where element is attached
     * @param elementRect Rectangle of the element
     * @param startPoint Start point of the target
     * @param direction Direction in which to show the element
     */
    calculateLeft(targetRect, elementRect, startPoint, direction, offset) {
        return targetRect.right + targetRect.width * startPoint + elementRect.width * direction + offset;
    }
    /**
     * Calculates the position of the top border of the element if it gets positioned
     * with provided position settings related to the target
     *
     * @param targetRect Rectangle of the target where element is attached
     * @param elementRect Rectangle of the element
     * @param startPoint Start point of the target
     * @param direction Direction in which to show the element
     */
    calculateTop(targetRect, elementRect, startPoint, direction, offset) {
        return targetRect.bottom + targetRect.height * startPoint + elementRect.height * direction + offset;
    }
    /**
     * Returns whether the element should fit in viewport
     *
     * @param connectedFit connectedFit object containing all necessary parameters
     */
    shouldFitInViewPort(connectedFit) {
        return connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0 ||
            connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0;
    }
}

/**
 * Positions the element as in **Connected** positioning strategy and resize the element
 * to fit in the view port in case the element is partially getting out of view
 */
class ElasticPositionStrategy extends BaseFitPositionStrategy {
    /** @inheritdoc */
    fitInViewport(element, connectedFit) {
        element.classList.add('igx-overlay__content--elastic');
        const transformString = [];
        if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
            const maxReduction = Math.max(0, connectedFit.contentElementRect.width - this.settings.minSize.width);
            const leftExtend = Math.max(0, -connectedFit.fitHorizontal.back);
            const rightExtend = Math.max(0, -connectedFit.fitHorizontal.forward);
            const reduction = Math.min(maxReduction, leftExtend + rightExtend);
            element.style.width = `${connectedFit.contentElementRect.width - reduction}px`;
            //  if direction is center and element goes off the screen in left direction we should push the
            //  element to the right. Prevents left still going out of view when normally positioned
            if (this.settings.horizontalDirection === HorizontalAlignment.Center) {
                //  the amount of translation depends on whether element goes off the screen to the left,
                //  to the right or in both directions, as well as how much it goes of the screen and finally
                //  on the minSize. The translation should be proportional between left and right extend
                //  taken from the reduction
                const translation = leftExtend * reduction / (leftExtend + rightExtend);
                if (translation > 0) {
                    transformString.push(`translateX(${translation}px)`);
                }
            }
        }
        if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
            const maxReduction = Math.max(0, connectedFit.contentElementRect.height - this.settings.minSize.height);
            const topExtend = Math.max(0, -connectedFit.fitVertical.back);
            const bottomExtend = Math.max(0, -connectedFit.fitVertical.forward);
            const reduction = Math.min(maxReduction, topExtend + bottomExtend);
            element.style.height = `${connectedFit.contentElementRect.height - reduction}px`;
            //  if direction is middle and element goes off the screen in top direction we should push the
            //  element to the bottom. Prevents top still going out of view when normally positioned
            if (this.settings.verticalDirection === VerticalAlignment.Middle) {
                //  the amount of translation depends on whether element goes off the screen to the top,
                //  to the bottom or in both directions, as well as how much it goes of the screen and finally
                //  on the minSize. The translation should be proportional between top and bottom extend
                //  taken from the reduction
                const translation = topExtend * reduction / (topExtend + bottomExtend);
                if (translation > 0) {
                    transformString.push(`translateY(${translation}px)`);
                }
            }
        }
        element.style.transform = transformString.join(' ').trim();
    }
}

/**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
class AutoPositionStrategy extends BaseFitPositionStrategy {
    /** @inheritdoc */
    fitInViewport(element, connectedFit) {
        const transformString = [];
        if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
            if (this.canFlipHorizontal(connectedFit)) {
                this.flipHorizontal();
                this.flipAnimation(FlipDirection.Horizontal);
            }
            else {
                const horizontalPush = this.horizontalPush(connectedFit);
                transformString.push(`translateX(${horizontalPush}px)`);
            }
        }
        if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
            if (this.canFlipVertical(connectedFit)) {
                this.flipVertical();
                this.flipAnimation(FlipDirection.Vertical);
            }
            else {
                const verticalPush = this.verticalPush(connectedFit);
                transformString.push(`translateY(${verticalPush}px)`);
            }
        }
        element.style.transform = transformString.join(' ').trim();
    }
    /**
     * Checks if element can be flipped without get off the viewport
     *
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    canFlipHorizontal(connectedFit) {
        //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
        //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
        //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
        //  this way:
        //  (-1) * (Left + 1) = 0 = Right
        //  (-1) * (Center + 1) = -0.5 = Center
        //  (-1) * (Right + 1) = -1 = Left
        const flippedStartPoint = (-1) * (this.settings.horizontalStartPoint + 1);
        const flippedDirection = (-1) * (this.settings.horizontalDirection + 1);
        const leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        const rightBorder = leftBorder + connectedFit.contentElementRect.width;
        return 0 < leftBorder && rightBorder < connectedFit.viewPortRect.width;
    }
    /**
     * Checks if element can be flipped without get off the viewport
     *
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    canFlipVertical(connectedFit) {
        const flippedStartPoint = (-1) * (this.settings.verticalStartPoint + 1);
        const flippedDirection = (-1) * (this.settings.verticalDirection + 1);
        const topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        const bottomBorder = topBorder + connectedFit.contentElementRect.height;
        return 0 < topBorder && bottomBorder < connectedFit.viewPortRect.height;
    }
    /**
     * Flips direction and start point of the position settings
     */
    flipHorizontal() {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                this.settings.horizontalDirection = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalDirection = HorizontalAlignment.Left;
                break;
        }
        switch (this.settings.horizontalStartPoint) {
            case HorizontalAlignment.Left:
                this.settings.horizontalStartPoint = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalStartPoint = HorizontalAlignment.Left;
                break;
        }
    }
    /**
     * Flips direction and start point of the position settings
     */
    flipVertical() {
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                this.settings.verticalDirection = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalDirection = VerticalAlignment.Top;
                break;
        }
        switch (this.settings.verticalStartPoint) {
            case VerticalAlignment.Top:
                this.settings.verticalStartPoint = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalStartPoint = VerticalAlignment.Top;
                break;
        }
    }
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     *
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    horizontalPush(connectedFit) {
        const leftExtend = connectedFit.left;
        const rightExtend = connectedFit.right - connectedFit.viewPortRect.width;
        //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
        //  as much as it is beyond the screen.
        //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
        //  extend but with amount not bigger than what left between left border of screen and left border of
        //  overlay, e.g. leftExtend
        if (leftExtend < 0) {
            return Math.abs(leftExtend);
        }
        else if (rightExtend > 0) {
            return -Math.min(rightExtend, leftExtend);
        }
        else {
            return 0;
        }
    }
    /**
     * Calculates necessary vertical push according to provided connectedFit
     *
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    verticalPush(connectedFit) {
        const topExtend = connectedFit.top;
        const bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.height;
        if (topExtend < 0) {
            return Math.abs(topExtend);
        }
        else if (bottomExtend > 0) {
            return -Math.min(bottomExtend, topExtend);
        }
        else {
            return 0;
        }
    }
    /**
     * Changes open and close animation with reverse animation if one exists
     *
     * @param flipDirection direction for which to change the animations
     */
    flipAnimation(flipDirection) {
        if (this.settings.openAnimation) {
            this.settings.openAnimation = this.updateAnimation(this.settings.openAnimation, flipDirection);
        }
        if (this.settings.closeAnimation) {
            this.settings.closeAnimation = this.updateAnimation(this.settings.closeAnimation, flipDirection);
        }
    }
    /**
     * Tries to find the reverse animation according to provided direction
     *
     * @param animation animation to update
     * @param direction required animation direction
     * @returns reverse animation in given direction if one exists
     */
    updateAnimation(animation, direction) {
        switch (direction) {
            case FlipDirection.Horizontal:
                if (isHorizontalAnimation(animation)) {
                    return reverseAnimationResolver(animation);
                }
                break;
            case FlipDirection.Vertical:
                if (isVerticalAnimation(animation)) {
                    return reverseAnimationResolver(animation);
                }
                break;
        }
        return animation;
    }
}
var FlipDirection;
(function (FlipDirection) {
    FlipDirection[FlipDirection["Horizontal"] = 0] = "Horizontal";
    FlipDirection[FlipDirection["Vertical"] = 1] = "Vertical";
})(FlipDirection || (FlipDirection = {}));

let warningShown = false;
/**
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/overlay-main)
 * The overlay service allows users to show components on overlay div above all other elements in the page.
 */
class IgxOverlayService {
    constructor(_factoryResolver, _appRef, _injector, builder, document, _zone, platformUtil) {
        this._factoryResolver = _factoryResolver;
        this._appRef = _appRef;
        this._injector = _injector;
        this.builder = builder;
        this.document = document;
        this._zone = _zone;
        this.platformUtil = platformUtil;
        /**
         * Emitted before the component is opened.
         * ```typescript
         * onOpening(event: OverlayCancelableEventArgs){
         *     const onOpening = event;
         * }
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted after the component is appended to the overlay, and before animations are started.
         * ```typescript
         * onAppended(event: OverlayEventArgs){
         *     const onAppended = event;
         * }
         * ```
         */
        this.onAppended = new EventEmitter();
        /**
         * Emitted after the component is opened and all animations are finished.
         * ```typescript
         * onOpened(event: OverlayEventArgs){
         *     const onOpened = event;
         * }
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted before the component is closed.
         * ```typescript
         * onClosing(event: OverlayCancelableEventArgs){
         *     const onClosing = event;
         * }
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted after the component is closed and all animations are finished.
         * ```typescript
         * onClosed(event: OverlayEventArgs){
         *     const onClosed = event;
         * }
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted before animation is started
         * ```typescript
         * onAnimation(event: OverlayAnimationEventArgs){
         *     const onAnimation = event;
         * }
         * ```
         */
        this.onAnimation = new EventEmitter();
        this._componentId = 0;
        this._overlayInfos = [];
        this.destroy$ = new Subject();
        this._cursorStyleIsSet = false;
        this._defaultSettings = {
            excludeFromOutsideClick: [],
            positionStrategy: new GlobalPositionStrategy(),
            scrollStrategy: new NoOpScrollStrategy(),
            modal: true,
            closeOnOutsideClick: true,
            closeOnEscape: false
        };
        /** @hidden */
        this.repositionAll = () => {
            for (let i = this._overlayInfos.length; i--;) {
                this.reposition(this._overlayInfos[i].id);
            }
        };
        this.documentClicked = (ev) => {
            //  if we get to modal overlay just return - we should not close anything under it
            //  if we get to non-modal overlay do the next:
            //   1. Check it has close on outside click. If not go on to next overlay;
            //   2. If true check if click is on the element. If it is on the element we have closed
            //  already all previous non-modal with close on outside click elements, so we return. If
            //  not close the overlay and check next
            for (let i = this._overlayInfos.length; i--;) {
                const info = this._overlayInfos[i];
                if (info.settings.modal) {
                    return;
                }
                if (info.settings.closeOnOutsideClick) {
                    const target = ev.composed ? ev.composedPath()[0] : ev.target;
                    const overlayElement = info.elementRef.nativeElement;
                    // check if the click is on the overlay element or on an element from the exclusion list, and if so do not close the overlay
                    const excludeElements = info.settings.excludeFromOutsideClick ?
                        [...info.settings.excludeFromOutsideClick, overlayElement] : [overlayElement];
                    const isInsideClick = excludeElements.some(e => e.contains(target));
                    if (isInsideClick) {
                        return;
                        //  if the click is outside click, but close animation has started do nothing
                    }
                    else if (!(info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted())) {
                        this._hide(info.id, ev);
                    }
                }
            }
        };
        this._document = this.document;
    }
    /**
     * Creates overlay settings with global or container position strategy and preset position settings
     *
     * @param position Preset position settings. Default position is 'center'
     * @param outlet The outlet container to attach the overlay to
     * @returns Non-modal overlay settings based on Global or Container position strategy and the provided position.
     */
    static createAbsoluteOverlaySettings(position, outlet) {
        const positionSettings = this.createAbsolutePositionSettings(position);
        const strategy = outlet ? new ContainerPositionStrategy(positionSettings) : new GlobalPositionStrategy(positionSettings);
        const overlaySettings = {
            positionStrategy: strategy,
            scrollStrategy: new NoOpScrollStrategy(),
            modal: false,
            closeOnOutsideClick: true,
            outlet
        };
        return overlaySettings;
    }
    /**
     * Creates overlay settings with auto, connected or elastic position strategy and preset position settings
     *
     * @param target Attaching target for the component to show
     * @param strategy The relative position strategy to be applied to the overlay settings. Default is Auto positioning strategy.
     * @param position Preset position settings. By default the element is positioned below the target, left aligned.
     * @returns Non-modal overlay settings based on the provided target, strategy and position.
     */
    static createRelativeOverlaySettings(target, position, strategy) {
        const positionSettings = this.createRelativePositionSettings(position);
        const overlaySettings = {
            target,
            positionStrategy: this.createPositionStrategy(strategy, positionSettings),
            scrollStrategy: new NoOpScrollStrategy(),
            modal: false,
            closeOnOutsideClick: true
        };
        return overlaySettings;
    }
    static createAbsolutePositionSettings(position) {
        let positionSettings;
        switch (position) {
            case AbsolutePosition.Bottom:
                positionSettings = {
                    horizontalDirection: HorizontalAlignment.Center,
                    verticalDirection: VerticalAlignment.Bottom,
                    openAnimation: slideInBottom,
                    closeAnimation: slideOutBottom
                };
                break;
            case AbsolutePosition.Top:
                positionSettings = {
                    horizontalDirection: HorizontalAlignment.Center,
                    verticalDirection: VerticalAlignment.Top,
                    openAnimation: slideInTop,
                    closeAnimation: slideOutTop
                };
                break;
            case AbsolutePosition.Center:
            default:
                positionSettings = {
                    horizontalDirection: HorizontalAlignment.Center,
                    verticalDirection: VerticalAlignment.Middle,
                    openAnimation: fadeIn,
                    closeAnimation: fadeOut
                };
        }
        return positionSettings;
    }
    static createRelativePositionSettings(position) {
        let positionSettings;
        switch (position) {
            case RelativePosition.Above:
                positionSettings = {
                    horizontalStartPoint: HorizontalAlignment.Center,
                    verticalStartPoint: VerticalAlignment.Top,
                    horizontalDirection: HorizontalAlignment.Center,
                    verticalDirection: VerticalAlignment.Top,
                    openAnimation: scaleInVerBottom,
                    closeAnimation: scaleOutVerBottom,
                };
                break;
            case RelativePosition.Below:
                positionSettings = {
                    horizontalStartPoint: HorizontalAlignment.Center,
                    verticalStartPoint: VerticalAlignment.Bottom,
                    horizontalDirection: HorizontalAlignment.Center,
                    verticalDirection: VerticalAlignment.Bottom,
                    openAnimation: scaleInVerTop,
                    closeAnimation: scaleOutVerTop
                };
                break;
            case RelativePosition.After:
                positionSettings = {
                    horizontalStartPoint: HorizontalAlignment.Right,
                    verticalStartPoint: VerticalAlignment.Middle,
                    horizontalDirection: HorizontalAlignment.Right,
                    verticalDirection: VerticalAlignment.Middle,
                    openAnimation: scaleInHorLeft,
                    closeAnimation: scaleOutHorLeft
                };
                break;
            case RelativePosition.Before:
                positionSettings = {
                    horizontalStartPoint: HorizontalAlignment.Left,
                    verticalStartPoint: VerticalAlignment.Middle,
                    horizontalDirection: HorizontalAlignment.Left,
                    verticalDirection: VerticalAlignment.Middle,
                    openAnimation: scaleInHorRight,
                    closeAnimation: scaleOutHorRight
                };
                break;
            case RelativePosition.Default:
            default:
                positionSettings = {
                    horizontalStartPoint: HorizontalAlignment.Left,
                    verticalStartPoint: VerticalAlignment.Bottom,
                    horizontalDirection: HorizontalAlignment.Right,
                    verticalDirection: VerticalAlignment.Bottom,
                    openAnimation: scaleInVerTop,
                    closeAnimation: scaleOutVerTop,
                };
                break;
        }
        return positionSettings;
    }
    static createPositionStrategy(strategy, positionSettings) {
        switch (strategy) {
            case RelativePositionStrategy.Connected:
                return new ConnectedPositioningStrategy(positionSettings);
            case RelativePositionStrategy.Elastic:
                return new ElasticPositionStrategy(positionSettings);
            case RelativePositionStrategy.Auto:
            default:
                return new AutoPositionStrategy(positionSettings);
        }
    }
    attach(component, settings, moduleRef) {
        const info = this.getOverlayInfo(component, moduleRef);
        //  if there is no info most probably wrong type component was provided and we just go out
        if (!info) {
            return null;
        }
        info.id = (this._componentId++).toString();
        settings = Object.assign({}, this._defaultSettings, settings);
        info.settings = settings;
        this._overlayInfos.push(info);
        return info.id;
    }
    show(compOrId, settings) {
        let info;
        let id;
        if (typeof compOrId === 'string') {
            id = compOrId;
            info = this.getOverlayById(compOrId);
            if (!info) {
                console.warn('igxOverlay.show was called with wrong id: ' + compOrId);
                return null;
            }
        }
        else {
            warningShown = showMessage('`show(component, settings?)` overload is deprecated. Use `attach(component)` to obtain an Id.' +
                'Then `show(id, settings?)` with provided Id.', warningShown);
            id = (this._componentId++).toString();
            info = this.getOverlayInfo(compOrId);
            //  if there is no info most probably wrong type component was provided and we just go out
            if (!info) {
                return;
            }
            info.id = id;
        }
        settings = Object.assign({}, this._defaultSettings, info.settings, settings);
        info.settings = settings;
        this._show(info);
        return id;
    }
    /**
     * Hides the component with the ID provided as a parameter.
     * ```typescript
     * this.overlay.hide(id);
     * ```
     */
    hide(id, event) {
        this._hide(id, event);
    }
    /**
     * Hides all the components and the overlay.
     * ```typescript
     * this.overlay.hideAll();
     * ```
     */
    hideAll() {
        // since overlays are removed on animation done, que all hides
        for (let i = this._overlayInfos.length; i--;) {
            this.hide(this._overlayInfos[i].id);
        }
    }
    /**
     * Repositions the component with ID provided as a parameter.
     * ```typescript
     * this.overlay.reposition(id);
     * ```
     */
    reposition(id) {
        const overlayInfo = this.getOverlayById(id);
        if (!overlayInfo || !overlayInfo.settings) {
            console.error('Wrong id provided in overlay.reposition method. Id: ' + id);
            return;
        }
        const contentElement = overlayInfo.elementRef.nativeElement.parentElement;
        const contentElementRect = contentElement.getBoundingClientRect();
        overlayInfo.settings.positionStrategy.position(contentElement, {
            width: contentElementRect.width,
            height: contentElementRect.height
        }, this._document, false, overlayInfo.settings.target);
    }
    /**
     * Offsets the content along the corresponding axis by the provided amount
     * ```typescript
     * this.overlay.setOffset(id, deltaX, deltaY);
     * ```
     */
    setOffset(id, deltaX, deltaY) {
        const info = this.getOverlayById(id);
        if (!info) {
            return;
        }
        info.transformX += deltaX;
        info.transformY += deltaY;
        const transformX = info.transformX;
        const transformY = info.transformY;
        const translate = `translate(${transformX}px, ${transformY}px)`;
        info.elementRef.nativeElement.parentElement.style.transform = translate;
    }
    /** @hidden @internal */
    getOverlayById(id) {
        if (!id) {
            return null;
        }
        const info = this._overlayInfos.find(e => e.id === id);
        return info;
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    _show(info) {
        const eventArgs = { id: info.id, componentRef: info.componentRef, cancel: false };
        this.onOpening.emit(eventArgs);
        if (eventArgs.cancel) {
            if (info.componentRef) {
                this._appRef.detachView(info.componentRef.hostView);
                info.componentRef.destroy();
            }
            return;
        }
        //  if there is no close animation player, or there is one but it is not started yet we are in clear
        //  opening. Otherwise, if there is close animation player playing animation now we should not setup
        //  overlay this is already done
        if (!info.closeAnimationPlayer || (info.closeAnimationPlayer && !info.closeAnimationPlayer.hasStarted())) {
            const elementRect = info.elementRef.nativeElement.getBoundingClientRect();
            info.initialSize = { width: elementRect.width, height: elementRect.height };
            info.hook = this.placeElementHook(info.elementRef.nativeElement);
            this.moveElementToOverlay(info);
            if (info.componentRef) {
                info.componentRef.changeDetectorRef.detectChanges();
            }
            this.onAppended.emit({ id: info.id, componentRef: info.componentRef });
            this.updateSize(info);
            if (this._overlayInfos.indexOf(info) === -1) {
                this._overlayInfos.push(info);
            }
            info.settings.positionStrategy.position(info.elementRef.nativeElement.parentElement, { width: info.initialSize.width, height: info.initialSize.height }, document, true, info.settings.target);
            info.settings.scrollStrategy.initialize(this._document, this, info.id);
            info.settings.scrollStrategy.attach();
        }
        this.addOutsideClickListener(info);
        this.addResizeHandler();
        this.addCloseOnEscapeListener(info);
        if (info.settings.modal) {
            const wrapperElement = info.elementRef.nativeElement.parentElement.parentElement;
            wrapperElement.classList.remove('igx-overlay__wrapper');
            this.applyAnimationParams(wrapperElement, info.settings.positionStrategy.settings.openAnimation);
            wrapperElement.classList.add('igx-overlay__wrapper--modal');
        }
        if (info.settings.positionStrategy.settings.openAnimation) {
            this.playOpenAnimation(info);
        }
        else {
            //  to eliminate flickering show the element just before onOpened fire
            info.elementRef.nativeElement.parentElement.style.visibility = '';
            this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
        }
    }
    _hide(id, event) {
        const info = this.getOverlayById(id);
        if (!info) {
            console.warn('igxOverlay.hide was called with wrong id: ' + id);
            return;
        }
        const eventArgs = { id, componentRef: info.componentRef, cancel: false, event };
        this.onClosing.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        //  TODO: synchronize where these are added/attached and where removed/detached
        info.settings.scrollStrategy.detach();
        this.removeOutsideClickListener(info);
        this.removeResizeHandler();
        const child = info.elementRef.nativeElement;
        if (info.settings.modal) {
            const parent = child.parentNode.parentNode;
            this.applyAnimationParams(parent, info.settings.positionStrategy.settings.closeAnimation);
            parent.classList.remove('igx-overlay__wrapper--modal');
            parent.classList.add('igx-overlay__wrapper');
        }
        if (info.settings.positionStrategy.settings.closeAnimation) {
            this.playCloseAnimation(info, event);
        }
        else {
            this.onCloseDone(info, event);
        }
    }
    getOverlayInfo(component, moduleRef) {
        const info = { ngZone: this._zone, transformX: 0, transformY: 0 };
        if (component instanceof ElementRef) {
            info.elementRef = component;
        }
        else {
            let dynamicFactory;
            const factoryResolver = moduleRef ? moduleRef.componentFactoryResolver : this._factoryResolver;
            try {
                dynamicFactory = factoryResolver.resolveComponentFactory(component);
            }
            catch (error) {
                console.error(error);
                return null;
            }
            const injector = moduleRef ? moduleRef.injector : this._injector;
            const dynamicComponent = dynamicFactory.create(injector);
            this._appRef.attachView(dynamicComponent.hostView);
            // If the element is newly created from a Component, it is wrapped in 'ng-component' tag - we do not want that.
            const element = dynamicComponent.location.nativeElement;
            info.elementRef = { nativeElement: element };
            info.componentRef = dynamicComponent;
        }
        return info;
    }
    placeElementHook(element) {
        if (!element.parentElement) {
            return null;
        }
        const hook = this._document.createElement('div');
        element.parentElement.insertBefore(hook, element);
        return hook;
    }
    moveElementToOverlay(info) {
        const wrapperElement = this.getWrapperElement();
        const contentElement = this.getContentElement(wrapperElement, info.settings.modal);
        this.getOverlayElement(info).appendChild(wrapperElement);
        contentElement.appendChild(info.elementRef.nativeElement);
    }
    getWrapperElement() {
        const wrapper = this._document.createElement('div');
        wrapper.classList.add('igx-overlay__wrapper');
        return wrapper;
    }
    getContentElement(wrapperElement, modal) {
        const content = this._document.createElement('div');
        if (modal) {
            content.classList.add('igx-overlay__content--modal');
            content.addEventListener('click', (ev) => {
                ev.stopPropagation();
            });
        }
        else {
            content.classList.add('igx-overlay__content');
        }
        content.addEventListener('scroll', (ev) => {
            ev.stopPropagation();
        });
        //  hide element to eliminate flickering. Show the element exactly before animation starts
        content.style.visibility = 'hidden';
        wrapperElement.appendChild(content);
        return content;
    }
    getOverlayElement(info) {
        if (info.settings.outlet) {
            return info.settings.outlet.nativeElement || info.settings.outlet;
        }
        if (!this._overlayElement) {
            this._overlayElement = this._document.createElement('div');
            this._overlayElement.classList.add('igx-overlay');
            this._document.body.appendChild(this._overlayElement);
        }
        return this._overlayElement;
    }
    updateSize(info) {
        if (info.componentRef) {
            //  if we are positioning component this is first time it gets visible
            //  and we can finally get its size
            info.initialSize = info.elementRef.nativeElement.getBoundingClientRect();
        }
        // set content div width only if element to show has width
        if (info.initialSize.width !== 0) {
            info.elementRef.nativeElement.parentElement.style.width = info.initialSize.width + 'px';
        }
    }
    onCloseDone(info, event) {
        this.cleanUp(info);
        this.onClosed.emit({ id: info.id, componentRef: info.componentRef, event });
    }
    cleanUp(info) {
        const child = info.elementRef.nativeElement;
        const outlet = this.getOverlayElement(info);
        if (!outlet.contains(child)) {
            console.warn('Component with id:' + info.id + ' is already removed!');
            return;
        }
        outlet.removeChild(child.parentNode.parentNode);
        if (info.componentRef) {
            this._appRef.detachView(info.componentRef.hostView);
            info.componentRef.destroy();
        }
        if (info.hook) {
            info.hook.parentElement.insertBefore(info.elementRef.nativeElement, info.hook);
            info.hook.parentElement.removeChild(info.hook);
        }
        const index = this._overlayInfos.indexOf(info);
        this._overlayInfos.splice(index, 1);
        // this._overlayElement.parentElement check just for tests that manually delete the element
        if (this._overlayInfos.length === 0) {
            if (this._overlayElement && this._overlayElement.parentElement) {
                this._overlayElement.parentElement.removeChild(this._overlayElement);
                this._overlayElement = null;
            }
            this.removeCloseOnEscapeListener();
        }
    }
    playOpenAnimation(info) {
        if (!info.openAnimationPlayer) {
            const animationBuilder = this.builder.build(info.settings.positionStrategy.settings.openAnimation);
            info.openAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
            //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack
            const innerRenderer = info.openAnimationPlayer._renderer;
            info.openAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.openAnimationPlayer.onDone(() => {
                this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
                if (info.openAnimationPlayer) {
                    info.openAnimationPlayer.reset();
                    info.openAnimationPlayer = null;
                }
                if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
                    info.closeAnimationPlayer.reset();
                }
            });
        }
        //  if there is opening animation already started do nothing
        if (info.openAnimationPlayer.hasStarted()) {
            return;
        }
        //  if there is closing animation already started start open animation from where close one has reached
        //  and remove close animation
        if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one
            const position = 1 - info.closeAnimationInnerPlayer.getPosition();
            info.closeAnimationPlayer.reset();
            info.closeAnimationPlayer = null;
            info.openAnimationPlayer.init();
            info.openAnimationPlayer.setPosition(position);
        }
        this.onAnimation.emit({ id: info.id, animationPlayer: info.openAnimationPlayer, animationType: 'open' });
        //  to eliminate flickering show the element just before animation start
        info.elementRef.nativeElement.parentElement.style.visibility = '';
        info.openAnimationPlayer.play();
    }
    playCloseAnimation(info, ev) {
        if (!info.closeAnimationPlayer) {
            const animationBuilder = this.builder.build(info.settings.positionStrategy.settings.closeAnimation);
            info.closeAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
            //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack
            const innerRenderer = info.closeAnimationPlayer._renderer;
            info.closeAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.closeAnimationPlayer.onDone(() => {
                if (info.closeAnimationPlayer) {
                    info.closeAnimationPlayer.reset();
                    info.closeAnimationPlayer = null;
                }
                if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
                    info.openAnimationPlayer.reset();
                }
                this.onCloseDone(info, ev);
            });
        }
        //  if there is closing animation already started do nothing
        if (info.closeAnimationPlayer.hasStarted()) {
            return;
        }
        //  if there is opening animation already started start close animation from where open one has reached
        //  and remove open animation
        if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one
            const position = 1 - info.openAnimationInnerPlayer.getPosition();
            info.openAnimationPlayer.reset();
            info.openAnimationPlayer = null;
            info.closeAnimationPlayer.init();
            info.closeAnimationPlayer.setPosition(position);
        }
        this.onAnimation.emit({ id: info.id, animationPlayer: info.closeAnimationPlayer, animationType: 'close' });
        info.closeAnimationPlayer.play();
    }
    //  TODO: check if applyAnimationParams will work with complex animations
    applyAnimationParams(wrapperElement, animationOptions) {
        if (!animationOptions) {
            wrapperElement.style.transitionDuration = '0ms';
            return;
        }
        if (animationOptions.type === 10 /* AnimateRef */) {
            animationOptions = animationOptions.animation;
        }
        if (!animationOptions.options || !animationOptions.options.params) {
            return;
        }
        const params = animationOptions.options.params;
        if (params.duration) {
            wrapperElement.style.transitionDuration = params.duration;
        }
        if (params.easing) {
            wrapperElement.style.transitionTimingFunction = params.easing;
        }
    }
    addOutsideClickListener(info) {
        if (info.settings.closeOnOutsideClick) {
            if (info.settings.modal) {
                fromEvent(info.elementRef.nativeElement.parentElement.parentElement, 'click')
                    .pipe(takeUntil(this.destroy$))
                    .subscribe((e) => this._hide(info.id, e));
            }
            else if (
            //  if all overlays minus closing overlays equals one add the handler
            this._overlayInfos.filter(x => x.settings.closeOnOutsideClick && !x.settings.modal).length -
                this._overlayInfos.filter(x => x.settings.closeOnOutsideClick && !x.settings.modal &&
                    x.closeAnimationPlayer &&
                    x.closeAnimationPlayer.hasStarted()).length === 1) {
                // click event is not fired on iOS. To make element "clickable" we are
                // setting the cursor to pointer
                if (this.platformUtil.isIOS && !this._cursorStyleIsSet) {
                    this._cursorOriginalValue = this._document.body.style.cursor;
                    this._document.body.style.cursor = 'pointer';
                    this._cursorStyleIsSet = true;
                }
                this._document.addEventListener('click', this.documentClicked, true);
            }
        }
    }
    removeOutsideClickListener(info) {
        if (info.settings.modal === false) {
            let shouldRemoveClickEventListener = true;
            this._overlayInfos.forEach(o => {
                if (o.settings.modal === false && o.id !== info.id) {
                    shouldRemoveClickEventListener = false;
                }
            });
            if (shouldRemoveClickEventListener) {
                if (this._cursorStyleIsSet) {
                    this._document.body.style.cursor = this._cursorOriginalValue;
                    this._cursorOriginalValue = '';
                    this._cursorStyleIsSet = false;
                }
                this._document.removeEventListener('click', this.documentClicked, true);
            }
        }
    }
    addResizeHandler() {
        const closingOverlaysCount = this._overlayInfos
            .filter(o => o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted())
            .length;
        if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.addEventListener('resize', this.repositionAll);
        }
    }
    removeResizeHandler() {
        const closingOverlaysCount = this._overlayInfos
            .filter(o => o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted())
            .length;
        if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.removeEventListener('resize', this.repositionAll);
        }
    }
    addCloseOnEscapeListener(info) {
        if (info.settings.closeOnEscape && !this._keyPressEventListener) {
            this._keyPressEventListener = fromEvent(this._document, 'keydown').pipe(filter((ev) => ev.key === 'Escape' || ev.key === 'Esc')).subscribe((ev) => {
                const targetOverlay = this._overlayInfos[this._overlayInfos.length - 1];
                if (targetOverlay.settings.closeOnEscape) {
                    this.hide(targetOverlay.id, ev);
                }
            });
        }
    }
    removeCloseOnEscapeListener() {
        if (this._keyPressEventListener) {
            this._keyPressEventListener.unsubscribe();
            this._keyPressEventListener = null;
        }
    }
}
IgxOverlayService.ɵprov = ɵɵdefineInjectable({ factory: function IgxOverlayService_Factory() { return new IgxOverlayService(ɵɵinject(ComponentFactoryResolver), ɵɵinject(ApplicationRef), ɵɵinject(INJECTOR), ɵɵinject(AnimationBuilder), ɵɵinject(DOCUMENT), ɵɵinject(NgZone), ɵɵinject(PlatformUtil)); }, token: IgxOverlayService, providedIn: "root" });
IgxOverlayService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
IgxOverlayService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: Injector },
    { type: AnimationBuilder },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone },
    { type: PlatformUtil }
];

// Export position strategies

/**
 * On scroll reposition the overlay content.
 */
class AbsoluteScrollStrategy extends ScrollStrategy {
    constructor(scrollContainer) {
        super(scrollContainer);
        this._initialized = false;
        this.onScroll = (e) => {
            const overlayInfo = this._overlayService.getOverlayById(this._id);
            if (!overlayInfo) {
                return;
            }
            if (!overlayInfo.elementRef.nativeElement.contains(e.target)) {
                this._overlayService.reposition(this._id);
            }
        };
        this._scrollContainer = scrollContainer;
    }
    /** @inheritdoc */
    initialize(document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._overlayService = overlayService;
        this._id = id;
        this._document = document;
        this._zone = overlayService.getOverlayById(id).ngZone;
        this._initialized = true;
    }
    /** @inheritdoc */
    attach() {
        if (this._zone) {
            this._zone.runOutsideAngular(() => {
                this.addScrollEventListener();
            });
        }
        else {
            this.addScrollEventListener();
        }
    }
    /** @inheritdoc */
    detach() {
        var _a;
        if (this._scrollContainer) {
            this._scrollContainer.removeEventListener('scroll', this.onScroll, true);
        }
        else {
            // Tired of this thing throwing every other time. Fix it ffs!
            (_a = this._document) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', this.onScroll, true);
        }
        this._initialized = false;
    }
    addScrollEventListener() {
        if (this._scrollContainer) {
            this._scrollContainer.addEventListener('scroll', this.onScroll, true);
        }
        else {
            this._document.addEventListener('scroll', this.onScroll, true);
        }
    }
}

/**
 * Prevents scrolling while the overlay content is shown.
 */
class BlockScrollStrategy extends ScrollStrategy {
    constructor(scrollContainer) {
        super(scrollContainer);
        this._initialized = false;
        this.onScroll = (ev) => {
            ev.preventDefault();
            if (!this._sourceElement || this._sourceElement !== ev.target) {
                this._sourceElement = ev.target;
                this._initialScrollTop = this._sourceElement.scrollTop;
                this._initialScrollLeft = this._sourceElement.scrollLeft;
            }
            this._sourceElement.scrollTop = this._initialScrollTop;
            this._sourceElement.scrollLeft = this._initialScrollLeft;
        };
    }
    /** @inheritdoc */
    initialize(document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._document = document;
        this._initialized = true;
    }
    /** @inheritdoc */
    attach() {
        this._document.addEventListener('scroll', this.onScroll, true);
    }
    /** @inheritdoc */
    detach() {
        this._document.removeEventListener('scroll', this.onScroll, true);
        this._sourceElement = null;
        this._initialScrollTop = 0;
        this._initialScrollLeft = 0;
        this._initialized = false;
    }
}

/**
 * Uses a tolerance and closes the shown component upon scrolling if the tolerance is exceeded
 */
class CloseScrollStrategy extends ScrollStrategy {
    constructor(scrollContainer) {
        super(scrollContainer);
        this._initialized = false;
        this.onScroll = (ev) => {
            if (!this._sourceElement) {
                return;
            }
            this.cumulativeScrollTop += this._sourceElement.scrollTop;
            this.cumulativeScrollLeft += this._sourceElement.scrollLeft;
            if (Math.abs(this.cumulativeScrollTop - this.initialScrollTop) > this._threshold ||
                Math.abs(this.cumulativeScrollLeft - this.initialScrollLeft) > this._threshold) {
                this._document.removeEventListener('scroll', this.onScroll, true);
                this._overlayService.hide(this._id);
            }
        };
        this._scrollContainer = scrollContainer;
        this._threshold = 10;
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
    }
    /** @inheritdoc */
    initialize(document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._overlayService = overlayService;
        this._id = id;
        this._document = document;
        this._initialized = true;
    }
    /** @inheritdoc */
    attach() {
        if (this._scrollContainer) {
            this._scrollContainer.addEventListener('scroll', this.onScroll);
            this._sourceElement = this._scrollContainer;
        }
        else {
            this._document.addEventListener('scroll', this.onScroll);
            if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
                this._sourceElement = document.documentElement;
            }
            else if (document.body.scrollHeight > document.body.clientHeight) {
                this._sourceElement = document.body;
            }
        }
        if (!this._sourceElement) {
            return;
        }
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
        this.initialScrollTop = this._sourceElement.scrollTop;
        this.initialScrollLeft = this._sourceElement.scrollLeft;
    }
    /** @inheritdoc */
    detach() {
        // TODO: check why event listener removes only on first call and remains on each next!!!
        if (this._scrollContainer) {
            this._scrollContainer.removeEventListener('scroll', this.onScroll);
        }
        else {
            this._document.removeEventListener('scroll', this.onScroll);
        }
        this._sourceElement = null;
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
        this.initialScrollTop = 0;
        this.initialScrollLeft = 0;
        this._initialized = false;
    }
}

// Export scroll strategies

class IgxBaseTransactionService {
    constructor() {
        /**
         * @inheritdoc
         */
        this.onStateUpdate = new EventEmitter();
        this._isPending = false;
        this._pendingTransactions = [];
        this._pendingStates = new Map();
    }
    /**
     * @inheritdoc
     */
    get canRedo() {
        return false;
    }
    /**
     * @inheritdoc
     */
    get canUndo() {
        return false;
    }
    /**
     * @inheritdoc
     */
    get enabled() {
        return this._isPending;
    }
    /**
     * @inheritdoc
     */
    add(transaction, recordRef) {
        if (this._isPending) {
            this.updateState(this._pendingStates, transaction, recordRef);
            this._pendingTransactions.push(transaction);
        }
    }
    /**
     * @inheritdoc
     */
    getTransactionLog(id) {
        return [];
    }
    /**
     * @inheritdoc
     */
    undo() { }
    /**
     * @inheritdoc
     */
    redo() { }
    /**
     * @inheritdoc
     */
    getAggregatedChanges(mergeChanges) {
        const result = [];
        this._pendingStates.forEach((state, key) => {
            const value = mergeChanges ? this.getAggregatedValue(key, mergeChanges) : state.value;
            result.push({ id: key, newValue: value, type: state.type });
        });
        return result;
    }
    /**
     * @inheritdoc
     */
    getState(id) {
        return this._pendingStates.get(id);
    }
    /**
     * @inheritdoc
     */
    getAggregatedValue(id, mergeChanges) {
        const state = this._pendingStates.get(id);
        if (!state) {
            return null;
        }
        if (mergeChanges) {
            return this.updateValue(state);
        }
        return state.value;
    }
    /**
     * @inheritdoc
     */
    commit(data, id) { }
    /**
     * @inheritdoc
     */
    clear(id) {
        this._pendingStates.clear();
        this._pendingTransactions = [];
    }
    /**
     * @inheritdoc
     */
    startPending() {
        this._isPending = true;
    }
    /**
     * @inheritdoc
     */
    endPending(commit) {
        this._isPending = false;
        this._pendingStates.clear();
        this._pendingTransactions = [];
    }
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     *
     * @param states States collection to apply the update to
     * @param transaction Transaction to apply to the current state
     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     */
    updateState(states, transaction, recordRef) {
        let state = states.get(transaction.id);
        if (state) {
            if (isObject(state.value)) {
                mergeObjects(state.value, transaction.newValue);
            }
            else {
                state.value = transaction.newValue;
            }
        }
        else {
            state = { value: cloneValue(transaction.newValue), recordRef, type: transaction.type };
            states.set(transaction.id, state);
        }
    }
    /**
     * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types
     *
     * @param state State to update value for
     * @returns updated value including all the changes in provided state
     */
    updateValue(state) {
        return this.mergeValues(state.recordRef, state.value);
    }
    /**
     * Merges second values in first value and the result in empty object. If values are primitive type
     * returns second value if exists, or first value.
     *
     * @param first Value to merge into
     * @param second Value to merge
     */
    mergeValues(first, second) {
        if (isObject(first) || isObject(second)) {
            return mergeObjects(cloneValue(first), second);
        }
        else {
            return second ? second : first;
        }
    }
}
IgxBaseTransactionService.decorators = [
    { type: Injectable }
];

class IgxTransactionService extends IgxBaseTransactionService {
    constructor() {
        super(...arguments);
        /**
         * @inheritdoc
         */
        this.onStateUpdate = new EventEmitter();
        this._transactions = [];
        this._redoStack = [];
        this._undoStack = [];
        this._states = new Map();
    }
    /**
     * @inheritdoc
     */
    get canUndo() {
        return this._undoStack.length > 0;
    }
    /**
     * @inheritdoc
     */
    get canRedo() {
        return this._redoStack.length > 0;
    }
    /**
     * @inheritdoc
     */
    add(transaction, recordRef) {
        const states = this._isPending ? this._pendingStates : this._states;
        this.verifyAddedTransaction(states, transaction, recordRef);
        this.addTransaction(transaction, states, recordRef);
    }
    /**
     * @inheritdoc
     */
    getTransactionLog(id) {
        if (id !== undefined) {
            return this._transactions.filter(t => t.id === id);
        }
        return [...this._transactions];
    }
    /**
     * @inheritdoc
     */
    getAggregatedChanges(mergeChanges) {
        const result = [];
        this._states.forEach((state, key) => {
            const value = mergeChanges ? this.mergeValues(state.recordRef, state.value) : state.value;
            result.push({ id: key, newValue: value, type: state.type });
        });
        return result;
    }
    /**
     * @inheritdoc
     */
    getState(id, pending = false) {
        return pending ? this._pendingStates.get(id) : this._states.get(id);
    }
    /**
     * @inheritdoc
     */
    get enabled() {
        return true;
    }
    /**
     * @inheritdoc
     */
    getAggregatedValue(id, mergeChanges) {
        const state = this._states.get(id);
        const pendingState = super.getState(id);
        //  if there is no state and there is no pending state return null
        if (!state && !pendingState) {
            return null;
        }
        const pendingChange = super.getAggregatedValue(id, false);
        const change = state && state.value;
        let aggregatedValue = this.mergeValues(change, pendingChange);
        if (mergeChanges) {
            const originalValue = state ? state.recordRef : pendingState.recordRef;
            aggregatedValue = this.mergeValues(originalValue, aggregatedValue);
        }
        return aggregatedValue;
    }
    /**
     * @inheritdoc
     */
    endPending(commit) {
        this._isPending = false;
        if (commit) {
            const actions = [];
            // don't use addTransaction due to custom undo handling
            for (const transaction of this._pendingTransactions) {
                const pendingState = this._pendingStates.get(transaction.id);
                this._transactions.push(transaction);
                this.updateState(this._states, transaction, pendingState.recordRef);
                actions.push({ transaction, recordRef: pendingState.recordRef });
            }
            this._undoStack.push(actions);
            this._redoStack = [];
            this.onStateUpdate.emit({ origin: TransactionEventOrigin.END, actions });
        }
        super.endPending(commit);
    }
    /**
     * @inheritdoc
     */
    commit(data, id) {
        if (id !== undefined) {
            const state = this.getState(id);
            if (state) {
                this.updateRecord(data, state);
            }
        }
        else {
            this._states.forEach((s) => {
                this.updateRecord(data, s);
            });
        }
        this.clear(id);
    }
    /**
     * @inheritdoc
     */
    clear(id) {
        if (id !== undefined) {
            this._transactions = this._transactions.filter(t => t.id !== id);
            this._states.delete(id);
            //  Undo stack is an array of actions. Each action is array of transaction like objects
            //  We are going trough all the actions. For each action we are filtering out transactions
            //  with provided id. Finally if any action ends up as empty array we are removing it from
            //  undo stack
            this._undoStack = this._undoStack.map(a => a.filter(t => t.transaction.id !== id)).filter(a => a.length > 0);
        }
        else {
            this._transactions = [];
            this._states.clear();
            this._undoStack = [];
        }
        this._redoStack = [];
        this.onStateUpdate.emit({ origin: TransactionEventOrigin.CLEAR, actions: [] });
    }
    /**
     * @inheritdoc
     */
    undo() {
        if (this._undoStack.length <= 0) {
            return;
        }
        const lastActions = this._undoStack.pop();
        this._transactions.splice(this._transactions.length - lastActions.length);
        this._redoStack.push(lastActions);
        this._states.clear();
        for (const currentActions of this._undoStack) {
            for (const transaction of currentActions) {
                this.updateState(this._states, transaction.transaction, transaction.recordRef);
            }
        }
        this.onStateUpdate.emit({ origin: TransactionEventOrigin.UNDO, actions: lastActions });
    }
    /**
     * @inheritdoc
     */
    redo() {
        if (this._redoStack.length > 0) {
            const actions = this._redoStack.pop();
            for (const action of actions) {
                this.updateState(this._states, action.transaction, action.recordRef);
                this._transactions.push(action.transaction);
            }
            this._undoStack.push(actions);
            this.onStateUpdate.emit({ origin: TransactionEventOrigin.REDO, actions });
        }
    }
    addTransaction(transaction, states, recordRef) {
        this.updateState(states, transaction, recordRef);
        const transactions = this._isPending ? this._pendingTransactions : this._transactions;
        transactions.push(transaction);
        if (!this._isPending) {
            const actions = [{ transaction, recordRef }];
            this._undoStack.push(actions);
            this._redoStack = [];
            this.onStateUpdate.emit({ origin: TransactionEventOrigin.ADD, actions });
        }
    }
    /**
     * Verifies if the passed transaction is correct. If not throws an exception.
     *
     * @param transaction Transaction to be verified
     */
    verifyAddedTransaction(states, transaction, recordRef) {
        const state = states.get(transaction.id);
        switch (transaction.type) {
            case TransactionType.ADD:
                if (state) {
                    //  cannot add same item twice
                    throw new Error(`Cannot add this transaction. Transaction with id: ${transaction.id} has been already added.`);
                }
                break;
            case TransactionType.DELETE:
            case TransactionType.UPDATE:
                if (state && state.type === TransactionType.DELETE) {
                    //  cannot delete or update deleted items
                    throw new Error(`Cannot add this transaction. Transaction with id: ${transaction.id} has been already deleted.`);
                }
                if (!state && !recordRef && !this._isPending) {
                    //  cannot initially add transaction or delete item with no recordRef
                    throw new Error(`Cannot add this transaction. This is first transaction of type ${transaction.type} ` +
                        `for id ${transaction.id}. For first transaction of this type recordRef is mandatory.`);
                }
                break;
        }
    }
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     *
     * @param states States collection to apply the update to
     * @param transaction Transaction to apply to the current state
     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     */
    updateState(states, transaction, recordRef) {
        let state = states.get(transaction.id);
        //  if TransactionType is ADD simply add transaction to states;
        //  if TransactionType is DELETE:
        //    - if there is state with this id of type ADD remove it from the states;
        //    - if there is state with this id of type UPDATE change its type to DELETE;
        //    - if there is no state with this id add transaction to states;
        //  if TransactionType is UPDATE:
        //    - if there is state with this id of type ADD merge new value and state recordRef into state new value
        //    - if there is state with this id of type UPDATE merge new value into state new value
        //    - if there is state with this id and state type is DELETE change its type to UPDATE
        //    - if there is no state with this id add transaction to states;
        if (state) {
            switch (transaction.type) {
                case TransactionType.DELETE:
                    if (state.type === TransactionType.ADD) {
                        states.delete(transaction.id);
                    }
                    else if (state.type === TransactionType.UPDATE) {
                        state.value = transaction.newValue;
                        state.type = TransactionType.DELETE;
                    }
                    break;
                case TransactionType.UPDATE:
                    if (isObject(state.value)) {
                        if (state.type === TransactionType.ADD) {
                            state.value = this.mergeValues(state.value, transaction.newValue);
                        }
                        if (state.type === TransactionType.UPDATE) {
                            mergeObjects(state.value, transaction.newValue);
                        }
                    }
                    else {
                        state.value = transaction.newValue;
                    }
            }
        }
        else {
            state = { value: cloneValue(transaction.newValue), recordRef, type: transaction.type };
            states.set(transaction.id, state);
        }
        //  should not clean pending state. This will happen automatically on endPending call
        if (!this._isPending) {
            this.cleanState(transaction.id, states);
        }
    }
    /**
     * Compares the state with recordRef and clears all duplicated values. If any state ends as
     * empty object removes it from states.
     *
     * @param state State to clean
     */
    cleanState(id, states) {
        const state = states.get(id);
        //  do nothing if
        //  there is no state, or
        //  there is no state value (e.g. DELETED transaction), or
        //  there is no recordRef (e.g. ADDED transaction)
        if (state && state.value && state.recordRef) {
            //  if state's value is object compare each key with the ones in recordRef
            //  if values in any key are the same delete it from state's value
            //  if state's value is not object, simply compare with recordRef and remove
            //  the state if they are equal
            if (isObject(state.recordRef)) {
                for (const key of Object.keys(state.value)) {
                    if (JSON.stringify(state.recordRef[key]) === JSON.stringify(state.value[key])) {
                        delete state.value[key];
                    }
                }
                //  if state's value is empty remove the state from the states, only if state is not DELETE type
                if (state.type !== TransactionType.DELETE && Object.keys(state.value).length === 0) {
                    states.delete(id);
                }
            }
            else {
                if (state.recordRef === state.value) {
                    states.delete(id);
                }
            }
        }
    }
    /**
     * Updates state related record in the provided data
     *
     * @param data Data source to update
     * @param state State to update data from
     */
    updateRecord(data, state) {
        const index = data.findIndex(i => JSON.stringify(i) === JSON.stringify(state.recordRef || {}));
        switch (state.type) {
            case TransactionType.ADD:
                data.push(state.value);
                break;
            case TransactionType.DELETE:
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
                break;
            case TransactionType.UPDATE:
                if (0 <= index && index < data.length) {
                    data[index] = this.updateValue(state);
                }
                break;
        }
    }
}
IgxTransactionService.decorators = [
    { type: Injectable }
];

/** @experimental @hidden */
class IgxHierarchicalTransactionService extends IgxTransactionService {
    getAggregatedChanges(mergeChanges) {
        const result = [];
        this._states.forEach((state, key) => {
            const value = mergeChanges ? this.mergeValues(state.recordRef, state.value) : cloneValue(state.value);
            this.clearArraysFromObject(value);
            result.push({ id: key, path: state.path, newValue: value, type: state.type });
        });
        return result;
    }
    commit(data, primaryKeyOrId, childDataKey, id) {
        if (childDataKey !== undefined) {
            let transactions = this.getAggregatedChanges(true);
            if (id !== undefined) {
                transactions = transactions.filter(t => t.id === id);
            }
            DataUtil.mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKeyOrId, true);
            this.clear(id);
        }
        else {
            super.commit(data, primaryKeyOrId);
        }
    }
    updateState(states, transaction, recordRef) {
        super.updateState(states, transaction, recordRef);
        //  if transaction has no path, e.g. flat data source, get out
        if (!transaction.path) {
            return;
        }
        const currentState = states.get(transaction.id);
        if (currentState) {
            currentState.path = transaction.path;
        }
        //  if transaction has path, Hierarchical data source, and it is DELETE
        //  type transaction for all child rows remove ADD states and update
        //  transaction type and value of UPDATE states
        if (transaction.type === TransactionType.DELETE) {
            states.forEach((v, k) => {
                if (v.path && v.path.indexOf(transaction.id) !== -1) {
                    switch (v.type) {
                        case TransactionType.ADD:
                            states.delete(k);
                            break;
                        case TransactionType.UPDATE:
                            states.get(k).type = TransactionType.DELETE;
                            states.get(k).value = null;
                    }
                }
            });
        }
    }
    //  TODO: remove this method. Force cloning to strip child arrays when needed instead
    clearArraysFromObject(obj) {
        if (obj) {
            for (const prop of Object.keys(obj)) {
                if (Array.isArray(obj[prop])) {
                    delete obj[prop];
                }
            }
        }
    }
}
IgxHierarchicalTransactionService.decorators = [
    { type: Injectable }
];

// Export services

class IgxToggleDirective {
    /**
     * @hidden
     */
    constructor(elementRef, cdr, overlayService, navigationService) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlayService = overlayService;
        this.navigationService = navigationService;
        /**
         * Emits an event after the toggle container is opened.
         *
         * ```typescript
         * onToggleOpened(event) {
         *    alert("Toggle opened!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpened)='onToggleOpened($event)'>
         * </div>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emits an event before the toggle container is opened.
         *
         * ```typescript
         * onToggleOpening(event) {
         *  alert("Toggle opening!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpening)='onToggleOpening($event)'>
         * </div>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emits an event after the toggle container is closed.
         *
         * ```typescript
         * onToggleClosed(event) {
         *  alert("Toggle closed!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onClosed)='onToggleClosed($event)'>
         * </div>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emits an event before the toggle container is closed.
         *
         * ```typescript
         * onToggleClosing(event) {
         *  alert("Toggle closing!");
         * }
         * ```
         *
         * ```html
         * <div
         *  igxToggle
         *  (onClosing)='onToggleClosing($event)'>
         * </div>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emits an event after the toggle element is appended to the overlay container.
         *
         * ```typescript
         * onAppended() {
         *  alert("Content appended!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onAppended)='onToggleAppended()'>
         * </div>
         * ```
         */
        this.onAppended = new EventEmitter();
        this._collapsed = true;
        this.destroy$ = new Subject();
        this._overlaySubFilter = [
            filter(x => x.id === this._overlayId),
            takeUntil(this.destroy$)
        ];
        this.overlayClosed = (ev) => {
            this._collapsed = true;
            this.cdr.detectChanges();
            delete this._overlayId;
            this.unsubscribe();
            const closedEventArgs = { owner: this, id: this._overlayId, event: ev.event };
            this.onClosed.emit(closedEventArgs);
        };
    }
    /**
     * @hidden
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get hiddenClass() {
        return this.collapsed;
    }
    /**
     * @hidden
     */
    get defaultClass() {
        return !this.collapsed;
    }
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     */
    open(overlaySettings) {
        //  if there is open animation do nothing
        //  if toggle is not collapsed and there is no close animation do nothing
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasOpenAnimation = info ? info.openAnimationPlayer : false;
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (hasOpenAnimation || !(this._collapsed || hasCloseAnimation)) {
            return;
        }
        if (!info) {
            this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);
        }
        const openEventArgs = { cancel: false, owner: this, id: this._overlayId };
        this.onOpening.emit(openEventArgs);
        if (openEventArgs.cancel) {
            return;
        }
        this._collapsed = false;
        this.cdr.detectChanges();
        this.unsubscribe();
        this._overlayAppendedSub = this.overlayService.onAppended.pipe(...this._overlaySubFilter).subscribe(() => {
            const appendedEventArgs = { owner: this, id: this._overlayId };
            this.onAppended.emit(appendedEventArgs);
        });
        this._overlayOpenedSub = this.overlayService.onOpened.pipe(...this._overlaySubFilter).subscribe(() => {
            const openedEventArgs = { owner: this, id: this._overlayId };
            this.onOpened.emit(openedEventArgs);
        });
        this._overlayClosingSub = this.overlayService
            .onClosing
            .pipe(...this._overlaySubFilter)
            .subscribe((e) => {
            const eventArgs = { cancel: false, event: e.event, owner: this, id: this._overlayId };
            this.onClosing.emit(eventArgs);
            e.cancel = eventArgs.cancel;
            //  in case event is not canceled this will close the toggle and we need to unsubscribe.
            //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
            //  onClosed was fired we will end with calling onClosing more than once
            if (!e.cancel) {
                this.clearSubscription(this._overlayClosingSub);
            }
        });
        this._overlayClosedSub = this.overlayService.onClosed
            .pipe(...this._overlaySubFilter)
            .subscribe(this.overlayClosed);
        this.overlayService.show(this._overlayId, overlaySettings);
    }
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     */
    close() {
        //  if toggle is collapsed do nothing
        //  if there is close animation do nothing, toggle will close anyway
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (this._collapsed || hasCloseAnimation) {
            return;
        }
        this.overlayService.hide(this._overlayId);
    }
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     */
    toggle(overlaySettings) {
        //  if toggle is collapsed call open
        //  if there is close animation call open
        if (this.collapsed || this.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    }
    /** @hidden @internal */
    get isClosing() {
        const info = this.overlayService.getOverlayById(this._overlayId);
        return info ? info.closeAnimationPlayer : false;
    }
    /**
     * Returns the id of the overlay the content is rendered in.
     * ```typescript
     * this.myToggle.overlayId;
     * ```
     */
    get overlayId() {
        return this._overlayId;
    }
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     */
    reposition() {
        this.overlayService.reposition(this._overlayId);
    }
    /**
     * Offsets the content along the corresponding axis by the provided amount
     */
    setOffset(deltaX, deltaY) {
        this.overlayService.setOffset(this._overlayId, deltaX, deltaY);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.navigationService && this.id) {
            this.navigationService.add(this.id, this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.navigationService && this.id) {
            this.navigationService.remove(this.id);
        }
        if (!this.collapsed && this._overlayId) {
            this.overlayService.hide(this._overlayId);
        }
        this.unsubscribe();
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    unsubscribe() {
        this.clearSubscription(this._overlayOpenedSub);
        this.clearSubscription(this._overlayClosingSub);
        this.clearSubscription(this._overlayClosedSub);
        this.clearSubscription(this._overlayAppendedSub);
    }
    clearSubscription(subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    }
}
IgxToggleDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'toggle',
                selector: '[igxToggle]'
            },] }
];
IgxToggleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
IgxToggleDirective.propDecorators = {
    onOpened: [{ type: Output }],
    onOpening: [{ type: Output }],
    onClosed: [{ type: Output }],
    onClosing: [{ type: Output }],
    onAppended: [{ type: Output }],
    id: [{ type: Input }],
    hiddenClass: [{ type: HostBinding, args: ['class.igx-toggle--hidden',] }, { type: HostBinding, args: ['attr.aria-hidden',] }],
    defaultClass: [{ type: HostBinding, args: ['class.igx-toggle',] }]
};
class IgxToggleActionDirective {
    constructor(element, navigationService) {
        this.element = element;
        this.navigationService = navigationService;
    }
    /**
     * @hidden
     */
    set target(target) {
        if (target !== null && target !== '') {
            this._target = target;
        }
    }
    /**
     * @hidden
     */
    get target() {
        if (typeof this._target === 'string') {
            return this.navigationService.get(this._target);
        }
        return this._target;
    }
    /**
     * @hidden
     */
    onClick() {
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
        const clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);
        this.updateOverlaySettings(clonedSettings);
        this.target.toggle(clonedSettings);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        const targetElement = this.element.nativeElement;
        this._overlayDefaults = {
            target: targetElement,
            positionStrategy: new ConnectedPositioningStrategy(),
            scrollStrategy: new AbsoluteScrollStrategy(),
            closeOnOutsideClick: true,
            modal: false,
            excludeFromOutsideClick: [targetElement]
        };
    }
    /**
     * Updates provided overlay settings
     *
     * @param settings settings to update
     * @returns returns updated copy of provided overlay settings
     */
    updateOverlaySettings(settings) {
        if (settings && settings.positionStrategy) {
            const positionStrategyClone = settings.positionStrategy.clone();
            settings.target = this.element.nativeElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    }
}
IgxToggleActionDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'toggle-action',
                selector: '[igxToggleAction]'
            },] }
];
IgxToggleActionDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
IgxToggleActionDirective.propDecorators = {
    overlaySettings: [{ type: Input }],
    outlet: [{ type: Input, args: ['igxToggleOutlet',] }],
    target: [{ type: Input, args: ['igxToggleAction',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
class IgxOverlayOutletDirective {
    constructor(element) {
        this.element = element;
    }
    /** @hidden */
    get nativeElement() {
        return this.element.nativeElement;
    }
}
IgxOverlayOutletDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'overlay-outlet',
                selector: '[igxOverlayOutlet]'
            },] }
];
IgxOverlayOutletDirective.ctorParameters = () => [
    { type: ElementRef }
];
/**
 * @hidden
 */
class IgxToggleModule {
}
IgxToggleModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                providers: [IgxNavigationService]
            },] }
];

/** @hidden */
var Navigate;
(function (Navigate) {
    Navigate[Navigate["Up"] = -1] = "Up";
    Navigate[Navigate["Down"] = 1] = "Down";
})(Navigate || (Navigate = {}));
/** Key actions that have designated handlers in IgxDropDownComponent */
const DropDownActionKey = mkenum({
    ESCAPE: 'escape',
    ENTER: 'enter',
    SPACE: 'space'
});
const IGX_DROPDOWN_BASE = new InjectionToken('IgxDropDownBaseToken');

/** @hidden */
class IgxSelectionAPIService {
    constructor() {
        /**
         * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.
         * If the primaryKey is omitted, then selection is based on the item data
         */
        this.selection = new Map();
    }
    /**
     * Get current component selection.
     *
     * @param componentID ID of the component.
     */
    get(componentID) {
        return this.selection.get(componentID);
    }
    /**
     * Set new component selection.
     *
     * @param componentID ID of the component.
     * @param newSelection The new component selection to be set.
     */
    set(componentID, newSelection) {
        if (!componentID) {
            throw Error('Invalid value for component id!');
        }
        this.selection.set(componentID, newSelection);
    }
    /**
     * Clears selection for component.
     *
     * @param componentID ID of the component.
     */
    clear(componentID) {
        this.selection.set(componentID, this.get_empty());
    }
    /**
     * Get current component selection length.
     *
     * @param componentID ID of the component.
     */
    size(componentID) {
        const sel = this.get(componentID);
        return sel ? sel.size : 0;
    }
    /**
     * Creates new selection that consist of the new item added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_item() one.
     *
     * @param componentID ID of the component, which we add new item to.
     * @param itemID ID of the item to add to component selection.
     * @param sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
     *
     * @returns Selection after the new item is added.
     */
    add_item(componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            sel = this.get_empty();
        }
        if (!itemID && itemID !== 0) {
            throw Error('Invalid value for item id!');
        }
        sel.add(itemID);
        return sel;
    }
    /**
     * Creates new selection that consist of the new items added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_items() one.
     *
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     * @param clearSelection If true it will clear previous selection.
     *
     * @returns Selection after the new items are added.
     */
    add_items(componentID, itemIDs, clearSelection) {
        let selection;
        if (clearSelection) {
            selection = this.get_empty();
        }
        else if (itemIDs && itemIDs.length === 0) {
            selection = new Set(this.get(componentID));
        }
        itemIDs.forEach((item) => selection = this.add_item(componentID, item, selection));
        return selection;
    }
    /**
     * Add item to the current component selection.
     *
     * @param componentID ID of the component, which we add new item to.
     * @param itemID ID of the item to add to component selection.
     * @param sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
     */
    select_item(componentID, itemID, sel) {
        this.set(componentID, this.add_item(componentID, itemID, sel));
    }
    /**
     * Add items to the current component selection.
     *
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     * @param clearSelection If true it will clear previous selection.
     */
    select_items(componentID, itemID, clearSelection) {
        this.set(componentID, this.add_items(componentID, itemID, clearSelection));
    }
    /**
     * Creates new selection that consist of the new items excluded from the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_item() one.
     *
     * @param componentID ID of the component, which we remove items from.
     * @param itemID ID of the item to remove from component selection.
     * @param sel Used internally only by the selection (delete_items method) to accumulate deselected items.
     *
     * @returns Selection after the item is removed.
     */
    delete_item(componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            return;
        }
        sel.delete(itemID);
        return sel;
    }
    /**
     * Creates new selection that consist of the new items removed to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_items() one.
     *
     * @param componentID ID of the component, which we remove items from.
     * @param itemID ID of the items to remove from component selection.
     *
     * @returns Selection after the items are removed.
     */
    delete_items(componentID, itemIDs) {
        let selection;
        itemIDs.forEach((deselectedItem) => selection = this.delete_item(componentID, deselectedItem, selection));
        return selection;
    }
    /**
     * Remove item from the current component selection.
     *
     * @param componentID ID of the component, which we remove item from.
     * @param itemID ID of the item to remove from component selection.
     * @param sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
     */
    deselect_item(componentID, itemID, sel) {
        this.set(componentID, this.delete_item(componentID, itemID, sel));
    }
    /**
     * Remove items to the current component selection.
     *
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     */
    deselect_items(componentID, itemID, clearSelection) {
        this.set(componentID, this.delete_items(componentID, itemID));
    }
    /**
     * Check if the item is selected in the component selection.
     *
     * @param componentID ID of the component.
     * @param itemID ID of the item to search.
     *
     * @returns If item is selected.
     */
    is_item_selected(componentID, itemID) {
        const sel = this.get(componentID);
        if (!sel) {
            return false;
        }
        return sel.has(itemID);
    }
    /**
     * Get first element in the selection.
     * This is correct when we have only one item in the collection (for single selection purposes)
     * and the method returns that item.
     *
     * @param componentID ID of the component.
     *
     * @returns First element in the set.
     */
    first_item(componentID) {
        const sel = this.get(componentID);
        if (sel && sel.size > 0) {
            return sel.values().next().value;
        }
    }
    /**
     * Returns whether all items are selected.
     *
     * @param componentID ID of the component.
     * @param dataCount: number Number of items in the data.
     *
     * @returns If all items are selected.
     */
    are_all_selected(componentID, dataCount) {
        return dataCount > 0 && dataCount === this.size(componentID);
    }
    /**
     * Returns whether any of the items is selected.
     *
     * @param componentID ID of the component.
     * @param data Entire data array.
     *
     * @returns If there is any item selected.
     */
    are_none_selected(componentID) {
        return this.size(componentID) === 0;
    }
    /**
     * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
     *
     * @param data Entire data array.
     * @param primaryKey Data primary key.
     *
     * @returns Array of identifiers, either primary key values or the entire data array.
     */
    get_all_ids(data, primaryKey) {
        // If primaryKey is 0, this should still map to the property
        return primaryKey !== undefined && primaryKey !== null ? data.map((x) => x[primaryKey]) : data;
    }
    /**
     * Returns empty selection collection.
     *
     * @returns empty set.
     */
    get_empty() {
        return new Set();
    }
}
IgxSelectionAPIService.ɵprov = ɵɵdefineInjectable({ factory: function IgxSelectionAPIService_Factory() { return new IgxSelectionAPIService(); }, token: IgxSelectionAPIService, providedIn: "root" });
IgxSelectionAPIService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];

let NEXT_ID = 0;
/**
 * The `<igx-drop-down-item>` is a container intended for row items in
 * a `<igx-drop-down>` container.
 */
class IgxDropDownGroupComponent {
    constructor() {
        /**
         * @hidden @internal
         */
        this.role = 'group';
        /** @hidden @internal */
        this.groupClass = true;
        /**
         * Sets/gets if the item group is disabled
         *
         * ```typescript
         * const myDropDownGroup: IgxDropDownGroupComponent = this.dropdownGroup;
         * // get
         * ...
         * const groupState: boolean = myDropDownGroup.disabled;
         * ...
         * //set
         * ...
         * myDropDownGroup,disabled = false;
         * ...
         * ```
         *
         * ```html
         * <igx-drop-down-item-group [label]="'My Items'" [disabled]="true">
         *     <igx-drop-down-item *ngFor="let item of items[index]" [value]="item.value">
         *         {{ item.text }}
         *     </igx-drop-down-item>
         * </igx-drop-down-item-group>
         * ```
         *
         * **NOTE:** All items inside of a disabled drop down group will be treated as disabled
         */
        this.disabled = false;
        this._id = NEXT_ID++;
    }
    /**
     * @hidden @internal
     */
    get labelId() {
        return `igx-item-group-label-${this._id}`;
    }
    get labelledBy() {
        return this.labelId;
    }
}
IgxDropDownGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-drop-down-item-group',
                template: `
        <label id="{{labelId}}">{{ label }}</label>
        <ng-content select="igx-drop-down-item"></ng-content>
    `
            },] }
];
IgxDropDownGroupComponent.propDecorators = {
    labelledBy: [{ type: HostBinding, args: [`attr.aria-labelledby`,] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    groupClass: [{ type: HostBinding, args: ['class.igx-drop-down__group',] }],
    disabled: [{ type: Input }, { type: HostBinding, args: [`attr.aria-disabled`,] }, { type: HostBinding, args: ['class.igx-drop-down__group--disabled',] }],
    label: [{ type: Input }]
};

let NEXT_ID$1 = 0;
let warningShown$1 = false;
/**
 * An abstract class defining a drop-down item:
 * With properties / styles for selection, highlight, height
 * Bindable property for passing data (`value: any`)
 * Parent component (has to be used under a parent with type `IDropDownBase`)
 * Method for handling click on Host()
 */
class IgxDropDownItemBaseDirective {
    constructor(dropDown, elementRef, group, selection) {
        this.dropDown = dropDown;
        this.elementRef = elementRef;
        this.group = group;
        this.selection = selection;
        /**
         * Sets/gets the `id` of the item.
         * ```html
         * <igx-drop-down-item [id] = 'igx-drop-down-item-0'></igx-drop-down-item>
         * ```
         * ```typescript
         * let itemId =  this.item.id;
         * ```
         *
         * @memberof IgxSelectItemComponent
         */
        this.id = `igx-drop-down-item-${NEXT_ID$1++}`;
        /**
         * @hidden
         */
        this.selectedChange = new EventEmitter();
        /**
         * Gets/sets the `role` attribute of the item. Default is 'option'.
         *
         * ```html
         *  <igx-drop-down-item [role]="customRole"></igx-drop-down-item>
         * ```
         */
        this.role = 'option';
        /**
         * @hidden
         */
        this._focused = false;
        this._selected = false;
        this._index = null;
        this._disabled = false;
    }
    /**
     * @hidden @internal
     */
    get itemID() {
        return this;
    }
    /**
     * The data index of the dropdown item.
     *
     * ```typescript
     * // get the data index of the selected dropdown item
     * let selectedItemIndex = this.dropdown.selectedItem.index
     * ```
     */
    get index() {
        if (this._index === null) {
            warningShown$1 = showMessage('IgxDropDownItemBaseDirective: Automatic index is deprecated.' +
                'Bind in the template instead using `<igx-drop-down-item [index]="i"` instead.`', warningShown$1);
            return this.itemIndex;
        }
        return this._index;
    }
    set index(value) {
        this._index = value;
    }
    /**
     * @hidden @internal
     */
    get itemStyle() {
        return !this.isHeader;
    }
    /**
     * @hidden @internal
     */
    get itemStyleCosy() {
        return this.dropDown.displayDensity === 'cosy' && !this.isHeader;
    }
    /**
     * @hidden @internal
     */
    get itemStyleCompact() {
        return this.dropDown.displayDensity === 'compact' && !this.isHeader;
    }
    /**
     * Sets/Gets if the item is the currently selected one in the dropdown
     *
     * ```typescript
     *  let mySelectedItem = this.dropdown.selectedItem;
     *  let isMyItemSelected = mySelectedItem.selected; // true
     * ```
     *
     * Two-way data binding
     * ```html
     * <igx-drop-down-item [(selected)]='model.isSelected'></igx-drop-down-item>
     * ```
     */
    get selected() {
        return this._selected;
    }
    set selected(value) {
        if (this.isHeader) {
            return;
        }
        this._selected = value;
        this.selectedChange.emit(this._selected);
    }
    /**
     * Sets/gets if the given item is focused
     * ```typescript
     *  let mySelectedItem = this.dropdown.selectedItem;
     *  let isMyItemFocused = mySelectedItem.focused;
     * ```
     */
    get focused() {
        return this.isSelectable && this._focused;
    }
    /**
     * ```html
     *  <igx-drop-down-item *ngFor="let item of items" focused={{!item.focused}}>
     *      <div>
     *          {{item.field}}
     *      </div>
     *  </igx-drop-down-item>
     * ```
     */
    set focused(value) {
        this._focused = value;
    }
    /**
     * @hidden @internal
     */
    get headerClassCosy() {
        return this.isHeader && this.dropDown.displayDensity === 'cosy';
    }
    /**
     * @hidden @internal
     */
    get headerClassCompact() {
        return this.isHeader && this.dropDown.displayDensity === 'compact';
    }
    /**
     * Sets/gets if the given item is disabled
     *
     * ```typescript
     *  // get
     *  let mySelectedItem = this.dropdown.selectedItem;
     *  let myItemIsDisabled = mySelectedItem.disabled;
     * ```
     *
     * ```html
     *  <igx-drop-down-item *ngFor="let item of items" disabled={{!item.disabled}}>
     *      <div>
     *          {{item.field}}
     *      </div>
     *  </igx-drop-down-item>
     * ```
     * **NOTE:** Drop-down items inside of a disabled `IgxDropDownGroup` will always count as disabled
     */
    get disabled() {
        return this.group ? this.group.disabled || this._disabled : this._disabled;
    }
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * Gets item index
     *
     * @hidden @internal
     */
    get itemIndex() {
        return this.dropDown.items.indexOf(this);
    }
    /**
     * Gets item element height
     *
     * @hidden @internal
     */
    get elementHeight() {
        return this.elementRef.nativeElement.clientHeight;
    }
    /**
     * Get item html element
     *
     * @hidden @internal
     */
    get element() {
        return this.elementRef;
    }
    get hasIndex() {
        return this._index !== null && this._index !== undefined;
    }
    /**
     * @hidden
     * @internal
     */
    clicked(event) {
    }
    ngDoCheck() {
        if (this._selected) {
            const dropDownSelectedItem = this.dropDown.selectedItem;
            if (!dropDownSelectedItem) {
                this.dropDown.selectItem(this);
            }
            else if (this.hasIndex
                ? this._index !== dropDownSelectedItem.index || this.value !== dropDownSelectedItem.value :
                this !== dropDownSelectedItem) {
                this.dropDown.selectItem(this);
            }
        }
    }
    /** Returns true if the items is not a header or disabled  */
    get isSelectable() {
        return !(this.disabled || this.isHeader);
    }
    /** If `allowItemsFocus` is enabled, keep the browser focus on the active item */
    ensureItemFocus() {
        if (this.dropDown.allowItemsFocus) {
            const focusedItem = this.dropDown.items.find((item) => item.focused);
            if (!focusedItem) {
                return;
            }
            focusedItem.element.nativeElement.focus({ preventScroll: true });
        }
    }
}
IgxDropDownItemBaseDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDropDownItemBase]'
            },] }
];
IgxDropDownItemBaseDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DROPDOWN_BASE,] }] },
    { type: ElementRef },
    { type: IgxDropDownGroupComponent, decorators: [{ type: Optional }] },
    { type: IgxSelectionAPIService, decorators: [{ type: Optional }, { type: Inject, args: [IgxSelectionAPIService,] }] }
];
IgxDropDownItemBaseDirective.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    index: [{ type: Input }],
    value: [{ type: Input }],
    itemStyle: [{ type: HostBinding, args: ['class.igx-drop-down__item',] }],
    itemStyleCosy: [{ type: HostBinding, args: ['class.igx-drop-down__item--cosy',] }],
    itemStyleCompact: [{ type: HostBinding, args: ['class.igx-drop-down__item--compact',] }],
    selected: [{ type: Input }, { type: HostBinding, args: ['attr.aria-selected',] }, { type: HostBinding, args: ['class.igx-drop-down__item--selected',] }],
    selectedChange: [{ type: Output }],
    focused: [{ type: HostBinding, args: ['class.igx-drop-down__item--focused',] }],
    isHeader: [{ type: Input }, { type: HostBinding, args: ['class.igx-drop-down__header',] }],
    headerClassCosy: [{ type: HostBinding, args: ['class.igx-drop-down__header--cosy',] }],
    headerClassCompact: [{ type: HostBinding, args: ['class.igx-drop-down__header--compact',] }],
    disabled: [{ type: Input }, { type: HostBinding, args: ['attr.aria-disabled',] }, { type: HostBinding, args: ['class.igx-drop-down__item--disabled',] }],
    role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }],
    clicked: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * The `<igx-drop-down-item>` is a container intended for row items in
 * a `<igx-drop-down>` container.
 */
class IgxDropDownItemComponent extends IgxDropDownItemBaseDirective {
    /**
     * @inheritdoc
     */
    get focused() {
        let focusedState = this._focused;
        if (this.hasIndex) {
            const focusedItem = this.selection.first_item(`${this.dropDown.id}-active`);
            const focusedIndex = focusedItem ? focusedItem.index : -1;
            focusedState = this._index === focusedIndex;
        }
        return this.isSelectable && focusedState;
    }
    /**
     * @inheritdoc
     */
    set focused(value) {
        this._focused = value;
    }
    /**
     * @inheritdoc
     */
    get selected() {
        if (this.hasIndex) {
            const item = this.selection.first_item(`${this.dropDown.id}`);
            return item ? item.index === this._index && item.value === this.value : false;
        }
        return this._selected;
    }
    /**
     * @inheritdoc
     */
    set selected(value) {
        if (this.isHeader) {
            return;
        }
        this._selected = value;
        this.selectedChange.emit(this._selected);
    }
    /**
     * @hidden @internal
     */
    get setTabIndex() {
        const shouldSetTabIndex = this.dropDown.allowItemsFocus && this.isSelectable;
        if (shouldSetTabIndex) {
            return 0;
        }
        else {
            return null;
        }
    }
    /**
     * @inheritdoc
     */
    clicked(event) {
        if (!this.isSelectable) {
            this.ensureItemFocus();
            return;
        }
        if (this.selection) {
            this.dropDown.selectItem(this, event);
        }
    }
}
IgxDropDownItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-drop-down-item',
                template: "<span class=\"igx-drop-down__content\">\n    <ng-content select=\"igx-prefix, [igxPrefix]\"></ng-content>\n    <span class=\"igx-drop-down__inner\">\n        <ng-content></ng-content>\n    </span>\n    <ng-content select=\"igx-suffix, [igxSuffix]\"></ng-content>\n    <ng-content select=\"igx-divider\"></ng-content>\n</span>\n"
            },] }
];
IgxDropDownItemComponent.propDecorators = {
    setTabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }]
};

/**
 * Defines the possible values of the components' display density.
 */
const DisplayDensity = mkenum({
    comfortable: 'comfortable',
    cosy: 'cosy',
    compact: 'compact'
});
/**
 * Defines the DisplayDensity DI token.
 */
const DisplayDensityToken = new InjectionToken('DisplayDensity');
/**
 * Base class containing all logic required for implementing DisplayDensity.
 */
// eslint-disable-next-line @angular-eslint/directive-class-suffix
class DisplayDensityBase {
    constructor(displayDensityOptions) {
        this.displayDensityOptions = displayDensityOptions;
        this.onDensityChanged = new EventEmitter();
        this.oldDisplayDensityOptions = { displayDensity: DisplayDensity.comfortable };
        Object.assign(this.oldDisplayDensityOptions, displayDensityOptions);
    }
    /**
     * Returns the theme of the component.
     * The default theme is `comfortable`.
     * Available options are `comfortable`, `cosy`, `compact`.
     * ```typescript
     * let componentTheme = this.component.displayDensity;
     * ```
     */
    get displayDensity() {
        return this._displayDensity ||
            ((this.displayDensityOptions && this.displayDensityOptions.displayDensity) || DisplayDensity.comfortable);
    }
    /**
     * Sets the theme of the component.
     */
    set displayDensity(val) {
        const currentDisplayDensity = this._displayDensity;
        this._displayDensity = val;
        if (currentDisplayDensity !== this._displayDensity) {
            const densityChangedArgs = {
                oldDensity: currentDisplayDensity,
                newDensity: this._displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.initialDensity = this._displayDensity;
    }
    ngDoCheck() {
        if (!this._displayDensity && this.displayDensityOptions &&
            this.oldDisplayDensityOptions.displayDensity !== this.displayDensityOptions.displayDensity) {
            const densityChangedArgs = {
                oldDensity: this.oldDisplayDensityOptions.displayDensity,
                newDensity: this.displayDensityOptions.displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
            this.oldDisplayDensityOptions = Object.assign(this.oldDisplayDensityOptions, this.displayDensityOptions);
        }
    }
    /**
     * Given a style class of a component/element returns the modified version of it based
     * on the current display density.
     */
    getComponentDensityClass(baseStyleClass) {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return `${baseStyleClass}--${DisplayDensity.cosy}`;
            case DisplayDensity.compact:
                return `${baseStyleClass}--${DisplayDensity.compact}`;
            default:
                return baseStyleClass;
        }
    }
}
DisplayDensityBase.decorators = [
    { type: Directive, args: [{
                selector: '[igxDisplayDensityBase]'
            },] }
];
DisplayDensityBase.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
DisplayDensityBase.propDecorators = {
    onDensityChanged: [{ type: Output }],
    displayDensity: [{ type: Input }]
};
class IgxDisplayDensityModule {
}
IgxDisplayDensityModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DisplayDensityBase
                ],
                exports: [
                    DisplayDensityBase
                ]
            },] }
];

let NEXT_ID$2 = 0;
/**
 * An abstract class, defining a drop-down component, with:
 * Properties for display styles and classes
 * A collection items of type `IgxDropDownItemBaseDirective`
 * Properties and methods for navigating (highlighting/focusing) items from the collection
 * Properties and methods for selecting items from the collection
 */
class IgxDropDownBaseDirective extends DisplayDensityBase {
    constructor(elementRef, cdr, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * Emitted when item selection is changing, before the selection completes
         *
         * ```html
         * <igx-drop-down (onSelection)='handleSelection()'></igx-drop-down>
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         * Gets/Sets the drop down's container max height.
         *
         * ```typescript
         * // get
         * let maxHeight = this.dropdown.maxHeight;
         * ```
         * ```html
         * <!--set-->
         * <igx-drop-down [maxHeight]='200px'></igx-drop-down>
         * ```
         */
        this.maxHeight = null;
        /**
         * @hidden @internal
         */
        this.cssClass = true;
        this._focusedItem = null;
        this._id = `igx-drop-down-${NEXT_ID$2++}`;
    }
    /**
     * Gets/Sets the drop down's id
     *
     * ```typescript
     * // get
     * let myDropDownCurrentId = this.dropdown.id;
     * ```
     * ```html
     * <!--set-->
     * <igx-drop-down [id]='newDropDownId'></igx-drop-down>
     * ```
     */
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    /**
     * Get all non-header items
     *
     * ```typescript
     * let myDropDownItems = this.dropdown.items;
     * ```
     */
    get items() {
        const items = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (!child.isHeader) {
                    items.push(child);
                }
            }
        }
        return items;
    }
    /**
     * Get all header items
     *
     * ```typescript
     * let myDropDownHeaderItems = this.dropdown.headers;
     * ```
     */
    get headers() {
        const headers = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (child.isHeader) {
                    headers.push(child);
                }
            }
        }
        return headers;
    }
    /**
     * Get dropdown html element
     *
     * ```typescript
     * let myDropDownElement = this.dropdown.element;
     * ```
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden @internal
     * Get dropdown's html element of its scroll container
     */
    get scrollContainer() {
        return this.element;
    }
    /** Keydown Handler */
    onItemActionKey(key, event) {
        switch (key) {
            case DropDownActionKey.ENTER:
            case DropDownActionKey.SPACE:
                this.selectItem(this.focusedItem, event);
                break;
            case DropDownActionKey.ESCAPE:
        }
    }
    /**
     * Emits onSelection with the target item & event
     *
     * @hidden @internal
     * @param newSelection the item selected
     * @param event the event that triggered the call
     */
    selectItem(newSelection, event) {
        this.onSelection.emit({
            newSelection,
            oldSelection: null,
            cancel: false
        });
    }
    /**
     * @hidden @internal
     */
    get focusedItem() {
        return this._focusedItem;
    }
    /**
     * @hidden @internal
     */
    set focusedItem(item) {
        this._focusedItem = item;
    }
    /**
     * Navigates to the item on the specified index
     *
     * @param newIndex number - the index of the item in the `items` collection
     */
    navigateItem(newIndex) {
        if (newIndex !== -1) {
            const oldItem = this._focusedItem;
            const newItem = this.items[newIndex];
            if (oldItem) {
                oldItem.focused = false;
            }
            this.focusedItem = newItem;
            this.scrollToHiddenItem(newItem);
            this.focusedItem.focused = true;
        }
    }
    /**
     * @hidden @internal
     */
    navigateFirst() {
        this.navigate(Navigate.Down, -1);
    }
    /**
     * @hidden @internal
     */
    navigateLast() {
        this.navigate(Navigate.Up, this.items.length);
    }
    /**
     * @hidden @internal
     */
    navigateNext() {
        this.navigate(Navigate.Down);
    }
    /**
     * @hidden @internal
     */
    navigatePrev() {
        this.navigate(Navigate.Up);
    }
    scrollToHiddenItem(newItem) {
        const elementRect = newItem.element.nativeElement.getBoundingClientRect();
        const parentRect = this.scrollContainer.getBoundingClientRect();
        if (parentRect.top > elementRect.top) {
            this.scrollContainer.scrollTop -= (parentRect.top - elementRect.top);
        }
        if (parentRect.bottom < elementRect.bottom) {
            this.scrollContainer.scrollTop += (elementRect.bottom - parentRect.bottom);
        }
    }
    navigate(direction, currentIndex) {
        let index = -1;
        if (this._focusedItem) {
            index = currentIndex ? currentIndex : this.focusedItem.itemIndex;
        }
        const newIndex = this.getNearestSiblingFocusableItemIndex(index, direction);
        this.navigateItem(newIndex);
    }
    getNearestSiblingFocusableItemIndex(startIndex, direction) {
        let index = startIndex;
        const items = this.items;
        while (items[index + direction] && items[index + direction].disabled) {
            index += direction;
        }
        index += direction;
        if (index >= 0 && index < items.length) {
            return index;
        }
        else {
            return -1;
        }
    }
}
IgxDropDownBaseDirective.decorators = [
    { type: Directive }
];
IgxDropDownBaseDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxDropDownBaseDirective.propDecorators = {
    onSelection: [{ type: Output }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    id: [{ type: Input }],
    maxHeight: [{ type: Input }, { type: HostBinding, args: ['style.maxHeight',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-drop-down',] }]
};

class DisplayContainerComponent {
    constructor(cdr, _viewContainer) {
        this.cdr = cdr;
        this._viewContainer = _viewContainer;
        this.cssClass = 'igx-display-container';
        this.notVirtual = true;
    }
}
DisplayContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-display-container',
                template: `
        <ng-template
            #display_container
            igxScrollInertia
            [IgxScrollInertiaScrollContainer]="scrollContainer"
            [IgxScrollInertiaDirection]="scrollDirection">
        </ng-template>
    `
            },] }
];
DisplayContainerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ViewContainerRef }
];
DisplayContainerComponent.propDecorators = {
    _vcr: [{ type: ViewChild, args: ['display_container', { read: ViewContainerRef, static: true },] }],
    cssClass: [{ type: HostBinding, args: ['class',] }],
    notVirtual: [{ type: HostBinding, args: ['class.igx-display-container--inactive',] }]
};

class VirtualHelperBaseDirective {
    constructor(elementRef, cdr, _zone, document, platformUtil) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this._zone = _zone;
        this.document = document;
        this.platformUtil = platformUtil;
        this.scrollAmount = 0;
        this._size = 0;
        this.destroy$ = new Subject();
        this._afterViewInit = false;
        this._detached = false;
        this._scrollNativeSize = this.calculateScrollNativeSize();
    }
    onScroll(event) {
        this.scrollAmount = event.target.scrollTop || event.target.scrollLeft;
    }
    ngAfterViewInit() {
        this._afterViewInit = true;
        if (!this.platformUtil.isBrowser) {
            return;
        }
        const delayTime = isIE() ? 40 : 0;
        this._zone.runOutsideAngular(() => {
            resizeObservable(this.nativeElement).pipe(throttleTime(delayTime), takeUntil(this.destroy$)).subscribe((event) => this.handleMutations(event));
        });
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    ngOnDestroy() {
        this.destroyed = true;
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    calculateScrollNativeSize() {
        const div = this.document.createElement('div');
        const style = div.style;
        style.width = '100px';
        style.height = '100px';
        style.position = 'absolute';
        style.top = '-10000px';
        style.top = '-10000px';
        style.overflow = 'scroll';
        this.document.body.appendChild(div);
        const scrollWidth = div.offsetWidth - div.clientWidth;
        this.document.body.removeChild(div);
        return scrollWidth ? scrollWidth + 1 : 1;
    }
    set size(value) {
        if (this.destroyed) {
            return;
        }
        this._size = value;
        if (this._afterViewInit) {
            this.cdr.detectChanges();
        }
    }
    get size() {
        return this._size;
    }
    get scrollNativeSize() {
        return this._scrollNativeSize;
    }
    get isAttachedToDom() {
        return this.document.body.contains(this.nativeElement);
    }
    handleMutations(event) {
        const hasSize = !(event[0].contentRect.height === 0 && event[0].contentRect.width === 0);
        if (!hasSize && !this.isAttachedToDom) {
            // scroll bar detached from DOM
            this._detached = true;
        }
        else if (this._detached && hasSize && this.isAttachedToDom) {
            // attached back now.
            this.restoreScroll();
        }
    }
    restoreScroll() { }
}
VirtualHelperBaseDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxVirtualHelperBase]'
            },] }
];
VirtualHelperBaseDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: PlatformUtil }
];
VirtualHelperBaseDirective.propDecorators = {
    onScroll: [{ type: HostListener, args: ['scroll', ['$event'],] }]
};

/**
 * @hidden
 */
class HVirtualHelperComponent extends VirtualHelperBaseDirective {
    constructor(elementRef, cdr, zone, document, platformUtil) {
        super(elementRef, cdr, zone, document, platformUtil);
        this.cssClasses = 'igx-vhelper--horizontal';
    }
    restoreScroll() {
        this.nativeElement.scrollLeft = this.scrollAmount;
    }
}
HVirtualHelperComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-horizontal-virtual-helper',
                template: '<div #horizontal_container class="igx-vhelper__placeholder-content" [style.width.px]="size"></div>'
            },] }
];
HVirtualHelperComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: PlatformUtil }
];
HVirtualHelperComponent.propDecorators = {
    _vcr: [{ type: ViewChild, args: ['horizontal_container', { read: ViewContainerRef, static: true },] }],
    width: [{ type: Input }],
    cssClasses: [{ type: HostBinding, args: ['class',] }]
};

class VirtualHelperComponent extends VirtualHelperBaseDirective {
    constructor(elementRef, cdr, zone, document, platformUtil) {
        super(elementRef, cdr, zone, document, platformUtil);
        this.cssClasses = 'igx-vhelper--vertical';
    }
    ngOnInit() {
        this.scrollWidth = this.scrollNativeSize;
    }
    restoreScroll() {
        this.nativeElement.scrollTop = this.scrollAmount;
    }
}
VirtualHelperComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-virtual-helper',
                template: '<div #container class="igx-vhelper__placeholder-content" [style.height.px]="size"></div>'
            },] }
];
VirtualHelperComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: PlatformUtil }
];
VirtualHelperComponent.propDecorators = {
    scrollTop: [{ type: HostBinding, args: ['scrollTop',] }],
    scrollWidth: [{ type: HostBinding, args: ['style.width.px',] }],
    _vcr: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }],
    itemsLength: [{ type: Input }],
    cssClasses: [{ type: HostBinding, args: ['class',] }]
};

/**
 * @hidden
 */
class IgxScrollInertiaDirective {
    constructor(element, _zone) {
        this.element = element;
        this._zone = _zone;
        this.wheelStep = 50;
        this.inertiaStep = 1.5;
        this.swipeToleranceX = 20;
        this.inertiaDeltaY = 3;
        this.inertiaDeltaX = 2;
        this.inertiaDuration = 0.5;
        this._savedSpeedsX = [];
        this.setPointerCaptureFName = typeof Element.prototype['msSetPointerCapture'] === 'function' ?
            'msSetPointerCapture' :
            'setPointerCapture';
        this.releasePointerCaptureFName = typeof Element.prototype['msReleasePointerCapture'] === 'function' ?
            'msReleasePointerCapture' :
            'releasePointerCapture';
        this.baseDeltaMultiplier = 1 / 120;
        this.firefoxDeltaMultiplier = 1 / 30;
    }
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            this.parentElement = this.element.nativeElement.parentElement || this.element.nativeElement.parentNode;
            if (!this.parentElement) {
                return;
            }
            const targetElem = this.parentElement;
            targetElem.addEventListener('wheel', this.onWheel.bind(this));
            targetElem.addEventListener('touchstart', this.onTouchStart.bind(this));
            targetElem.addEventListener('touchmove', this.onTouchMove.bind(this));
            targetElem.addEventListener('touchend', this.onTouchEnd.bind(this));
            targetElem.addEventListener('pointerdown', this.onPointerDown.bind(this));
            targetElem.addEventListener('pointerup', this.onPointerUp.bind(this));
            targetElem.addEventListener('MSGestureStart', this.onMSGestureStart.bind(this));
            targetElem.addEventListener('MSGestureChange', this.onMSGestureChange.bind(this));
        });
    }
    ngOnDestroy() {
        this._zone.runOutsideAngular(() => {
            const targetElem = this.parentElement;
            if (!targetElem) {
                return;
            }
            targetElem.removeEventListener('wheel', this.onWheel);
            targetElem.removeEventListener('touchstart', this.onTouchStart);
            targetElem.removeEventListener('touchmove', this.onTouchMove);
            targetElem.removeEventListener('touchend', this.onTouchEnd);
            targetElem.removeEventListener('pointerdown', this.onPointerDown);
            targetElem.removeEventListener('pointerup', this.onPointerUp);
            targetElem.removeEventListener('MSGestureStart', this.onMSGestureStart);
            targetElem.removeEventListener('MSGestureChange', this.onMSGestureChange);
        });
    }
    /**
     * @hidden
     * Function that is called when scrolling with the mouse wheel or using touchpad
     */
    onWheel(evt) {
        // if no scrollbar return
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        // if ctrl key is pressed and the user want to zoom in/out the page
        if (evt.ctrlKey) {
            return;
        }
        if (evt.shiftKey && isIE()) {
            evt.preventDefault();
        }
        let scrollDeltaX;
        let scrollDeltaY;
        const scrollStep = this.wheelStep;
        const minWheelStep = 1 / this.wheelStep;
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        if (evt.wheelDeltaX) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaX = -evt.wheelDeltaX * this.baseDeltaMultiplier;
            if (-minWheelStep < scrollDeltaX && scrollDeltaX < minWheelStep) {
                scrollDeltaX = Math.sign(scrollDeltaX) * minWheelStep;
            }
        }
        else if (evt.deltaX) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            const deltaScaledX = evt.deltaX * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);
            scrollDeltaX = this.calcAxisCoords(deltaScaledX, -1, 1);
        }
        /** Get delta for the Y axis */
        if (evt.wheelDeltaY) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaY = -evt.wheelDeltaY * this.baseDeltaMultiplier;
            if (-minWheelStep < scrollDeltaY && scrollDeltaY < minWheelStep) {
                scrollDeltaY = Math.sign(scrollDeltaY) * minWheelStep;
            }
        }
        else if (evt.deltaY) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            const deltaScaledY = evt.deltaY * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);
            scrollDeltaY = this.calcAxisCoords(deltaScaledY, -1, 1);
        }
        if (scrollDeltaX && this.IgxScrollInertiaDirection === 'horizontal') {
            this._scrollToX(this._startX + scrollDeltaX * scrollStep);
            const curScrollLeft = this.IgxScrollInertiaScrollContainer.scrollLeft;
            const maxScrollLeft = parseInt(this.IgxScrollInertiaScrollContainer.children[0].style.width, 10);
            if (0 < curScrollLeft && curScrollLeft < maxScrollLeft) {
                // Prevent navigating through pages when scrolling on Mac
                evt.preventDefault();
            }
        }
        else if (evt.shiftKey && scrollDeltaY && this.IgxScrollInertiaDirection === 'horizontal') {
            const step = this._startX + scrollDeltaY * scrollStep;
            this._scrollToX(step);
        }
        else if (!evt.shiftKey && scrollDeltaY && this.IgxScrollInertiaDirection === 'vertical') {
            this._scrollToY(this._startY + scrollDeltaY * scrollStep);
            this.preventParentScroll(evt, true);
        }
    }
    /**
     * @hidden
     * When there is still room to scroll up/down prevent the parent elements from scrolling too.
     */
    preventParentScroll(evt, preventDefault) {
        const curScrollTop = this.IgxScrollInertiaScrollContainer.scrollTop;
        const maxScrollTop = this.IgxScrollInertiaScrollContainer.children[0].scrollHeight -
            this.IgxScrollInertiaScrollContainer.offsetHeight;
        if (0 < curScrollTop && curScrollTop < maxScrollTop) {
            if (preventDefault) {
                evt.preventDefault();
            }
            if (evt.stopPropagation) {
                evt.stopPropagation();
            }
        }
    }
    /**
     * @hidden
     * Function that is called the first moment we start interacting with the content on a touch device
     */
    onTouchStart(event) {
        if (typeof MSGesture === 'function' || !this.IgxScrollInertiaScrollContainer) {
            return false;
        }
        // stops any current ongoing inertia
        cancelAnimationFrame(this._touchInertiaAnimID);
        const touch = event.touches[0];
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = touch.pageX;
        this._touchStartY = touch.pageY;
        this._lastTouchEnd = new Date().getTime();
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._savedSpeedsX = [];
        this._savedSpeedsY = [];
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        this._touchPrevented = false;
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    /**
     * @hidden
     * Function that is called when we need to scroll the content based on touch interactions
     */
    onTouchMove(event) {
        if (typeof MSGesture === 'function') {
            this._touchPrevented = false;
            return false;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        const touch = event.touches[0];
        const destX = this._startX + (this._touchStartX - touch.pageX) * Math.sign(this.inertiaStep);
        const destY = this._startY + (this._touchStartY - touch.pageY) * Math.sign(this.inertiaStep);
        /* Handle complex touchmoves when swipe stops but the toch doesn't end and then a swipe is initiated again */
        /* **********************************************************/
        const timeFromLastTouch = (new Date().getTime()) - this._lastTouchEnd;
        if (timeFromLastTouch !== 0 && timeFromLastTouch < 100) {
            const speedX = (this._lastTouchX - touch.pageX) / timeFromLastTouch;
            const speedY = (this._lastTouchY - touch.pageY) / timeFromLastTouch;
            // Save the last 5 speeds between two touchmoves on X axis
            if (this._savedSpeedsX.length < 5) {
                this._savedSpeedsX.push(speedX);
            }
            else {
                this._savedSpeedsX.shift();
                this._savedSpeedsX.push(speedX);
            }
            // Save the last 5 speeds between two touchmoves on Y axis
            if (this._savedSpeedsY.length < 5) {
                this._savedSpeedsY.push(speedY);
            }
            else {
                this._savedSpeedsY.shift();
                this._savedSpeedsY.push(speedY);
            }
        }
        this._lastTouchEnd = new Date().getTime();
        this._lastMovedX = this._lastTouchX - touch.pageX;
        this._lastMovedY = this._lastTouchY - touch.pageY;
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._totalMovedX += this._lastMovedX;
        let scrolledXY; // Object: {x, y}
        /*	Do not scroll using touch untill out of the swipeToleranceX bounds */
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            scrolledXY = this._scrollTo(this._startX, destY);
        }
        else {
            /*	Record the direction the first time we are out of the swipeToleranceX bounds.
            *	That way we know which direction we apply the offset so it doesn't hickup when moving out of the swipeToleranceX bounds */
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /*	Scroll with offset ammout of swipeToleranceX in the direction we have exited the bounds and
            don't change it after that ever until touchend and again touchstart */
            scrolledXY = this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        if (scrolledXY.x === 0 && scrolledXY.y === 0) {
            this._touchPrevented = true;
        }
        // On Safari preventing the touchmove would prevent default page scroll behaviour even if there is the element doesn't have overflow
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, true);
        }
    }
    onTouchEnd(event) {
        if (typeof MSGesture === 'function') {
            return;
        }
        let speedX = 0;
        let speedY = 0;
        // savedSpeedsX and savedSpeedsY have same length
        for (let i = 0; i < this._savedSpeedsX.length; i++) {
            speedX += this._savedSpeedsX[i];
            speedY += this._savedSpeedsY[i];
        }
        speedX = this._savedSpeedsX.length ? speedX / this._savedSpeedsX.length : 0;
        speedY = this._savedSpeedsX.length ? speedY / this._savedSpeedsY.length : 0;
        // Use the lastMovedX and lastMovedY to determine if the swipe stops without lifting the finger so we don't start inertia
        if ((Math.abs(speedX) > 0.1 || Math.abs(speedY) > 0.1) &&
            (Math.abs(this._lastMovedX) > 2 || Math.abs(this._lastMovedY) > 2)) {
            this._inertiaInit(speedX, speedY);
        }
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    /**
     * @hidden
     * Function that is called when we need to detect touch starting on a touch device on IE/Edge
     */
    onPointerDown(event) {
        if (!event || (event.pointerType !== 2 && event.pointerType !== 'touch') ||
            typeof MSGesture !== 'function') {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        // setPointerCaptureFName is the name of the function that is supported
        event.target[this.setPointerCaptureFName](this._pointer = event.pointerId);
        // create gestureObject only one time to prevent overlapping during intertia
        if (!this._gestureObject) {
            this._gestureObject = new MSGesture();
            this._gestureObject.target = this.parentElement;
        }
        this._gestureObject.addPointer(this._pointer);
    }
    /**
     * @hidden
     * Function that is called when we need to detect touch ending on a touch device on IE/Edge
     */
    onPointerUp(event) {
        if (!this._pointer) {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        /* releasePointerCaptureFName is the name of the function that is supported */
        event.target[this.releasePointerCaptureFName](this._pointer);
        delete this._pointer;
    }
    /**
     * @hidden
     *  Function that is called when a gesture begins on IE/Edge
     */
    onMSGestureStart(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = event.screenX;
        this._touchStartY = event.screenY;
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        return false;
    }
    /**
     * @hidden
     * Function that is called when a we need to scroll based on the gesture performed on IE/Edge
     */
    onMSGestureChange(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        const touchPos = event;
        const destX = this._startX + this._touchStartX - touchPos.screenX;
        const destY = this._startY + this._touchStartY - touchPos.screenY;
        /* Logic regarding x tolerance to prevent accidental horizontal scrolling when scrolling vertically */
        this._totalMovedX = this._touchStartX - touchPos.screenX;
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            /* Do not scroll horizontally yet while in the tolerance range */
            this._scrollToY(destY);
        }
        else {
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /* Once the tolerance is exceeded it can be scrolled horizontally */
            this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        return false;
    }
    _inertiaInit(speedX, speedY) {
        const stepModifer = this.inertiaStep;
        const inertiaDuration = this.inertiaDuration;
        let x = 0;
        this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // Sets timeout until executing next movement iteration of the inertia
        const inertiaStep = () => {
            if (x > 6) {
                cancelAnimationFrame(this._touchInertiaAnimID);
                return;
            }
            if (Math.abs(speedX) > Math.abs(speedY)) {
                x += 0.05 / (1 * inertiaDuration);
            }
            else {
                x += 0.05 / (1 * inertiaDuration);
            }
            if (x <= 1) {
                // We use constant quation to determine the offset without speed falloff befor x reaches 1
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += 1 * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += 1 * speedY * 15 * stepModifer;
                }
            }
            else {
                // We use the quation "y = 2 / (x + 0.55) - 0.3" to determine the offset
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += Math.abs(2 / (x + 0.55) - 0.3) * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += Math.abs(2 / (x + 0.55) - 0.3) * speedY * 15 * stepModifer;
                }
            }
            // If we have mixed environment we use the default behaviour. i.e. touchscreen + mouse
            this._scrollTo(this._nextX, this._nextY);
            this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
        };
        // Start inertia and continue it recursively
        this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
    }
    calcAxisCoords(target, min, max) {
        if (target === undefined || target < min) {
            target = min;
        }
        else if (target > max) {
            target = max;
        }
        return target;
    }
    _scrollTo(destX, destY) {
        // TODO Trigger scrolling event?
        const scrolledX = this._scrollToX(destX);
        const scrolledY = this._scrollToY(destY);
        return { x: scrolledX, y: scrolledY };
    }
    _scrollToX(dest) {
        this.IgxScrollInertiaScrollContainer.scrollLeft = dest;
    }
    _scrollToY(dest) {
        this.IgxScrollInertiaScrollContainer.scrollTop = dest;
    }
}
IgxScrollInertiaDirective.decorators = [
    { type: Directive, args: [{ selector: '[igxScrollInertia]' },] }
];
IgxScrollInertiaDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
IgxScrollInertiaDirective.propDecorators = {
    IgxScrollInertiaDirection: [{ type: Input }],
    IgxScrollInertiaScrollContainer: [{ type: Input }],
    wheelStep: [{ type: Input }],
    inertiaStep: [{ type: Input }],
    swipeToleranceX: [{ type: Input }],
    inertiaDeltaY: [{ type: Input }],
    inertiaDeltaX: [{ type: Input }],
    inertiaDuration: [{ type: Input }]
};
/**
 * @hidden
 */
class IgxScrollInertiaModule {
}
IgxScrollInertiaModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxScrollInertiaDirective],
                exports: [IgxScrollInertiaDirective],
                imports: [CommonModule]
            },] }
];

class IgxForOfSyncService {
    constructor() {
        this._master = new Map();
    }
    /**
     * @hidden
     */
    isMaster(directive) {
        return this._master.get(directive.igxForScrollOrientation) === directive;
    }
    /**
     * @hidden
     */
    setMaster(directive, forced = false) {
        const orientation = directive.igxForScrollOrientation;
        if (orientation && (forced || !this._master.has(orientation))) {
            this._master.set(orientation, directive);
        }
    }
    /**
     * @hidden
     */
    resetMaster() {
        this._master.clear();
    }
    /**
     * @hidden
     */
    sizesCache(dir) {
        return this._master.get(dir).sizesCache;
    }
    /**
     * @hidden
     */
    chunkSize(dir) {
        return this._master.get(dir).state.chunkSize;
    }
}
IgxForOfSyncService.ɵprov = ɵɵdefineInjectable({ factory: function IgxForOfSyncService_Factory() { return new IgxForOfSyncService(); }, token: IgxForOfSyncService, providedIn: "root" });
IgxForOfSyncService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
class IgxForOfScrollSyncService {
    constructor() {
        this._masterScroll = new Map();
    }
    setScrollMaster(dir, scroll) {
        this._masterScroll.set(dir, scroll);
    }
    getScrollMaster(dir) {
        return this._masterScroll.get(dir);
    }
}
IgxForOfScrollSyncService.ɵprov = ɵɵdefineInjectable({ factory: function IgxForOfScrollSyncService_Factory() { return new IgxForOfScrollSyncService(); }, token: IgxForOfScrollSyncService, providedIn: "root" });
IgxForOfScrollSyncService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];

/* eslint-disable @angular-eslint/no-conflicting-lifecycle */
const MAX_PERF_SCROLL_DIFF = 4;
/**
 *  @publicApi
 */
class IgxForOfContext {
    constructor($implicit, index, count) {
        this.$implicit = $implicit;
        this.index = index;
        this.count = count;
    }
    /**
     * A function that returns whether the element is the first or not
     */
    get first() {
        return this.index === 0;
    }
    /**
     * A function that returns whether the element is the last or not
     */
    get last() {
        return this.index === this.count - 1;
    }
    /**
     * A function that returns whether the element is even or not
     */
    get even() {
        return this.index % 2 === 0;
    }
    /**
     * A function that returns whether the element is odd or not
     */
    get odd() {
        return !this.even;
    }
}
// eslint-disable @angular-eslint/no-conflicting-lifecycle
class IgxForOfDirective {
    constructor(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService, platformUtil, document) {
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this.resolver = resolver;
        this.cdr = cdr;
        this._zone = _zone;
        this.syncScrollService = syncScrollService;
        this.platformUtil = platformUtil;
        this.document = document;
        /**
         * An @Input property that specifies the scroll orientation.
         * Scroll orientation can be "vertical" or "horizontal".
         * ```html
         * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'"></ng-template>
         * ```
         */
        this.igxForScrollOrientation = 'vertical';
        /**
         * An event that is emitted after a new chunk has been loaded.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkLoad)="chunkLoad($event)"></ng-template>
         * ```
         * ```typescript
         * chunkLoad(e){
         * alert("chunk loaded!");
         * }
         * ```
         */
        this.onChunkLoad = new EventEmitter();
        /**
         * @hidden @internal
         * An event that is emitted when scrollbar visibility has changed.
         */
        this.onScrollbarVisibilityChanged = new EventEmitter();
        /**
         * An event that is emitted after the rendered content size of the igxForOf has been changed.
         */
        this.onContentSizeChange = new EventEmitter();
        /**
         * An event that is emitted after data has been changed.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onDataChanged)="dataChanged($event)"></ng-template>
         * ```
         * ```typescript
         * dataChanged(e){
         * alert("data changed!");
         * }
         * ```
         */
        this.onDataChanged = new EventEmitter();
        this.onBeforeViewDestroyed = new EventEmitter();
        /**
         * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
         * Can be used for implementing remote load on demand for the igxFor data.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkPreload)="chunkPreload($event)"></ng-template>
         * ```
         * ```typescript
         * chunkPreload(e){
         * alert("chunk is loading!");
         * }
         * ```
         */
        this.onChunkPreload = new EventEmitter();
        /**
         * The current state of the directive. It contains `startIndex` and `chunkSize`.
         * state.startIndex - The index of the item at which the current visible chunk begins.
         * state.chunkSize - The number of items the current visible chunk holds.
         * These options can be used when implementing remote virtualization as they provide the necessary state information.
         * ```typescript
         * const gridState = this.parentVirtDir.state;
         * ```
         */
        this.state = {
            startIndex: 0,
            chunkSize: 0
        };
        this._sizesCache = [];
        this._differ = null;
        this.heightCache = [];
        /** Internal track for scroll top that is being virtualized */
        this._virtScrollTop = 0;
        /** If the next onScroll event is triggered due to internal setting of scrollTop */
        this._bScrollInternal = false;
        // End properties related to virtual height handling
        this._embeddedViews = [];
        this.contentResizeNotify = new Subject();
        /** Height that is being virtualized. */
        this._virtHeight = 0;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        this._totalItemCount = null;
        /**
         * Ratio for height that's being virtualizaed and the one visible
         * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxHeight > _virtHeight.
         */
        this._virtHeightRatio = 1;
    }
    /**
     * The total count of the virtual data items, when using remote service.
     * Similar to the property totalItemCount, but this will allow setting the data count into the template.
     * ```html
     * <ng-template igxFor let-item [igxForOf]="data | async" [igxForTotalItemCount]="count | async"
     *  [igxForContainerSize]="'500px'" [igxForItemSize]="'50px'"></ng-template>
     * ```
     */
    get igxForTotalItemCount() {
        return this.totalItemCount;
    }
    set igxForTotalItemCount(value) {
        this.totalItemCount = value;
    }
    /**
     * The total count of the virtual data items, when using remote service.
     * ```typescript
     * this.parentVirtDir.totalItemCount = data.Count;
     * ```
     */
    get totalItemCount() {
        return this._totalItemCount;
    }
    set totalItemCount(val) {
        if (this._totalItemCount !== val) {
            this._totalItemCount = val;
            // update sizes in case total count changes.
            const newSize = this.initSizesCache(this.igxForOf);
            const sizeDiff = this.scrollComponent.size - newSize;
            this.scrollComponent.size = newSize;
            const lastChunkExceeded = this.state.startIndex + this.state.chunkSize > val;
            if (lastChunkExceeded) {
                this.state.startIndex = val - this.state.chunkSize;
            }
            this._adjustScrollPositionAfterSizeChange(sizeDiff);
        }
    }
    get displayContainer() {
        var _a, _b, _c, _d;
        return (_d = (_c = (_b = (_a = this.dc) === null || _a === void 0 ? void 0 : _a.instance) === null || _b === void 0 ? void 0 : _b._viewContainer) === null || _c === void 0 ? void 0 : _c.element) === null || _d === void 0 ? void 0 : _d.nativeElement;
    }
    get virtualHelper() {
        return this.scrollComponent.nativeElement;
    }
    /**
     * @hidden
     */
    get isRemote() {
        return this.totalItemCount !== null;
    }
    /**
     *
     * Gets/Sets the scroll position.
     * ```typescript
     * const position = directive.scrollPosition;
     * directive.scrollPosition = value;
     * ```
     */
    get scrollPosition() {
        return this.scrollComponent.scrollAmount;
    }
    set scrollPosition(val) {
        if (val === this.scrollComponent.scrollAmount) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal' && this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollLeft = val;
        }
        else if (this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollTop = val;
        }
    }
    get sizesCache() {
        return this._sizesCache;
    }
    set sizesCache(value) {
        this._sizesCache = value;
    }
    get _isScrolledToBottom() {
        if (!this.getScroll()) {
            return true;
        }
        const scrollHeight = this.getScroll().scrollHeight;
        // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.
        // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.
        return Math.round(this.getScroll().scrollTop + this.igxForContainerSize) === scrollHeight;
    }
    get _isAtBottomIndex() {
        return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;
    }
    verticalScrollHandler(event) {
        this.onScroll(event);
    }
    isScrollable() {
        return this.scrollComponent.size > parseInt(this.igxForContainerSize, 10);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        let totalSize = 0;
        const vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;
        this.igxForSizePropName = this.igxForSizePropName || 'width';
        const dcFactory = this.resolver.resolveComponentFactory(DisplayContainerComponent);
        this.dc = this._viewContainer.createComponent(dcFactory, 0);
        this.dc.instance.scrollDirection = this.igxForScrollOrientation;
        if (typeof MSGesture === 'function') {
            // On Edge and IE when scrolling on touch the page scroll instead of the grid.
            this.dc.instance._viewContainer.element.nativeElement.style.touchAction = 'none';
        }
        if (this.igxForOf && this.igxForOf.length) {
            totalSize = this.initSizesCache(this.igxForOf);
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            this.state.chunkSize = this._calculateChunkSize();
            this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);
            if (this.scrollComponent && !this.scrollComponent.destroyed) {
                this.state.startIndex = Math.min(this.getIndexAt(this.scrollPosition, this.sizesCache), this.igxForOf.length - this.state.chunkSize);
            }
            for (let i = this.state.startIndex; i < this.state.startIndex + this.state.chunkSize &&
                this.igxForOf[i] !== undefined; i++) {
                const input = this.igxForOf[i];
                const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
                this._embeddedViews.push(embeddedView);
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
            const factory = this.resolver.resolveComponentFactory(VirtualHelperComponent);
            this.scrollComponent = vc.createComponent(factory).instance;
            this._maxHeight = this._calcMaxBrowserHeight();
            this.scrollComponent.size = this.igxForOf ? this._calcHeight() : 0;
            this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
            this._zone.runOutsideAngular(() => {
                this.verticalScrollHandler = this.verticalScrollHandler.bind(this);
                this.scrollComponent.nativeElement.addEventListener('scroll', this.verticalScrollHandler);
                this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
            });
            const destructor = takeUntil(this.destroy$);
            this.contentResizeNotify.pipe(destructor, filter(() => this.igxForContainerSize && this.igxForOf && this.igxForOf.length > 0), throttleTime(40, undefined, { leading: true, trailing: true })).subscribe(() => this._zone.runTask(() => this.updateSizes()));
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.func = (evt) => this.onHScroll(evt);
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            if (!this.scrollComponent) {
                const hvFactory = this.resolver.resolveComponentFactory(HVirtualHelperComponent);
                this.scrollComponent = vc.createComponent(hvFactory).instance;
                this.scrollComponent.size = totalSize;
                this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            else {
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            this._updateHScrollOffset();
        }
    }
    ngAfterViewInit() {
        if (this.igxForScrollOrientation === 'vertical') {
            this._zone.runOutsideAngular(() => {
                this.contentObserver = new ResizeObserver(() => this.contentResizeNotify.next());
                this.contentObserver.observe(this.dc.instance._viewContainer.element.nativeElement);
            });
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.removeScrollEventListeners();
        this.destroy$.next(true);
        this.destroy$.complete();
        if (this.contentObserver) {
            this.contentObserver.disconnect();
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        const forOf = 'igxForOf';
        if (forOf in changes) {
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
        }
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
            this._applyChanges();
        }
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                this._updateSizeCache();
                this._zone.run(() => {
                    this._applyChanges();
                    this.cdr.markForCheck();
                    this._updateScrollOffset();
                    this.onDataChanged.emit();
                });
            }
        }
    }
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScrollTop(5);
     * ```
     *
     * @param addTop negative value to scroll up and positive to scroll down;
     */
    addScrollTop(addTop) {
        if (addTop === 0 && this.igxForScrollOrientation === 'horizontal') {
            return false;
        }
        const originalVirtScrollTop = this._virtScrollTop;
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const maxVirtScrollTop = this._virtHeight - containerSize;
        this._bScrollInternal = true;
        this._virtScrollTop += addTop;
        this._virtScrollTop = this._virtScrollTop > 0 ?
            (this._virtScrollTop < maxVirtScrollTop ? this._virtScrollTop : maxVirtScrollTop) :
            0;
        this.scrollPosition += addTop / this._virtHeightRatio;
        if (Math.abs(addTop / this._virtHeightRatio) < 1) {
            // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px
            const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
            // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        }
        const maxRealScrollTop = this.scrollComponent.nativeElement.scrollHeight - containerSize;
        if ((this._virtScrollTop > 0 && this.scrollPosition === 0) ||
            (this._virtScrollTop < maxVirtScrollTop && this.scrollPosition === maxRealScrollTop)) {
            // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)
            // Recalculate actual scroll position based on the virtual scroll.
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
        }
        else if (this._virtScrollTop === 0 && this.scrollPosition > 0) {
            // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll
            this.scrollPosition = 0;
        }
        else if (this._virtScrollTop === maxVirtScrollTop && this.scrollPosition < maxRealScrollTop) {
            // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll
            this.scrollPosition = maxRealScrollTop;
        }
        return this._virtScrollTop !== originalVirtScrollTop;
    }
    /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     *
     * @param index
     */
    scrollTo(index) {
        if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {
            return;
        }
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const isPrevItem = index < this.state.startIndex || this.scrollPosition > this.sizesCache[index];
        let nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;
        if (nextScroll < 0) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition = nextScroll;
        }
        else {
            const maxVirtScrollTop = this._virtHeight - containerSize;
            if (nextScroll > maxVirtScrollTop) {
                nextScroll = maxVirtScrollTop;
            }
            this._bScrollInternal = true;
            this._virtScrollTop = nextScroll;
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
            this._adjustToIndex = !isPrevItem ? index : null;
        }
    }
    /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     */
    scrollNext() {
        const scr = Math.ceil(this.scrollPosition);
        const endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache);
        this.scrollTo(endIndex);
    }
    /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     */
    scrollPrev() {
        this.scrollTo(this.state.startIndex - 1);
    }
    /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     */
    scrollNextPage() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition += parseInt(this.igxForContainerSize, 10);
        }
        else {
            this.addScrollTop(parseInt(this.igxForContainerSize, 10));
        }
    }
    /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     */
    scrollPrevPage() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition -= parseInt(this.igxForContainerSize, 10);
        }
        else {
            const containerSize = (parseInt(this.igxForContainerSize, 10));
            this.addScrollTop(-containerSize);
        }
    }
    /**
     * @hidden
     */
    getColumnScrollLeft(colIndex) {
        return this.sizesCache[colIndex];
    }
    /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     */
    getItemCountInView() {
        let startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache);
        if (this.scrollPosition - this.sizesCache[startIndex] > 0) {
            // fisrt item is not fully in view
            startIndex++;
        }
        const endIndex = this.getIndexAt(this.scrollPosition + parseInt(this.igxForContainerSize, 10), this.sizesCache);
        return endIndex - startIndex;
    }
    /**
     * Returns a reference to the scrollbar DOM element.
     * This is either a vertical or horizontal scrollbar depending on the specified igxForScrollOrientation.
     * ```typescript
     * dir.getScroll();
     * ```
     */
    getScroll() {
        var _a;
        return (_a = this.scrollComponent) === null || _a === void 0 ? void 0 : _a.nativeElement;
    }
    /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     */
    getSizeAt(index) {
        return this.sizesCache[index + 1] - this.sizesCache[index];
    }
    /**
     * @hidden
     * Function that is called to get the native scrollbar size that the browsers renders.
     */
    getScrollNativeSize() {
        return this.scrollComponent ? this.scrollComponent.scrollNativeSize : 0;
    }
    /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     */
    getScrollForIndex(index, bottom) {
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const scroll = bottom ? Math.max(0, this.sizesCache[index + 1] - containerSize) : this.sizesCache[index];
        return scroll;
    }
    /**
     * @hidden
     * Function that recaculates and updates cache sizes.
     */
    recalcUpdateSizes() {
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        const diffs = [];
        let totalDiff = 0;
        const l = this._embeddedViews.length;
        const rNodes = this._embeddedViews.map(view => view.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE) || view.rootNodes[0].nextElementSibling);
        for (let i = 0; i < l; i++) {
            const rNode = rNodes[i];
            if (rNode) {
                const h = rNode.offsetHeight || parseInt(this.igxForItemSize, 10);
                const index = this.state.startIndex + i;
                if (!this.isRemote && !this.igxForOf[index]) {
                    continue;
                }
                const oldVal = dimension === 'height' ? this.heightCache[index] : this.igxForOf[index][dimension];
                const newVal = dimension === 'height' ? h : rNode.clientWidth;
                if (dimension === 'height') {
                    this.heightCache[index] = newVal;
                }
                else {
                    this.igxForOf[index][dimension] = newVal;
                }
                const currDiff = newVal - oldVal;
                diffs.push(currDiff);
                totalDiff += currDiff;
                this.sizesCache[index + 1] += totalDiff;
            }
        }
        // update cache
        if (Math.abs(totalDiff) > 0) {
            for (let j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {
                this.sizesCache[j] += totalDiff;
            }
            // update scrBar heights/widths
            if (this.igxForScrollOrientation === 'horizontal') {
                const totalWidth = parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10) + totalDiff;
                this.scrollComponent.nativeElement.children[0].style.width = totalWidth + 'px';
            }
            const reducer = (acc, val) => acc + val;
            if (this.igxForScrollOrientation === 'vertical') {
                const scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;
                const hSum = this.heightCache.reduce(reducer);
                if (hSum > this._maxHeight) {
                    this._virtHeightRatio = hSum / this._maxHeight;
                }
                this.scrollComponent.size = Math.min(this.scrollComponent.size + totalDiff, this._maxHeight);
                this._virtHeight = hSum;
                if (!this.scrollComponent.destroyed) {
                    this.scrollComponent.cdr.detectChanges();
                }
                if (scrToBottom && !this._isAtBottomIndex) {
                    const containerSize = parseInt(this.igxForContainerSize, 10);
                    const maxVirtScrollTop = this._virtHeight - containerSize;
                    this._bScrollInternal = true;
                    this._virtScrollTop = maxVirtScrollTop;
                    this.scrollPosition = maxVirtScrollTop;
                    return;
                }
                if (this._adjustToIndex) {
                    // in case scrolled to specific index where after scroll heights are changed
                    // need to adjust the offsets so that item is last in view.
                    const updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;
                    const sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);
                    if (sumDiffs !== 0) {
                        this.addScrollTop(sumDiffs);
                    }
                    this._adjustToIndex = null;
                }
            }
        }
    }
    /**
     * @hidden
     * Reset scroll position.
     * Needed in case scrollbar is hidden/detached but we still need to reset it.
     */
    resetScrollPosition() {
        this.scrollPosition = 0;
        this.scrollComponent.scrollAmount = 0;
        this.state.startIndex = 0;
    }
    /**
     * @hidden
     */
    removeScrollEventListeners() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._zone.runOutsideAngular(() => { var _a, _b; return (_b = (_a = this.scrollComponent) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.removeEventListener('scroll', this.func); });
        }
        else {
            this._zone.runOutsideAngular(() => { var _a, _b; return (_b = (_a = this.scrollComponent) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.removeEventListener('scroll', this.verticalScrollHandler); });
        }
    }
    /**
     * @hidden
     * Function that is called when scrolling vertically
     */
    onScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollTop(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        const prevStartIndex = this.state.startIndex;
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    }
    updateSizes() {
        this.recalcUpdateSizes();
        this._applyChanges();
        this._updateScrollOffset();
        this.onContentSizeChange.emit();
    }
    /**
     * @hidden
     */
    fixedUpdateAllElements(inScrollTop) {
        const count = this.isRemote ? this.totalItemCount : this.igxForOf.length;
        let newStart = this.getIndexAt(inScrollTop, this.sizesCache);
        if (newStart + this.state.chunkSize > count) {
            newStart = count - this.state.chunkSize;
        }
        const prevStart = this.state.startIndex;
        const diff = newStart - this.state.startIndex;
        this.state.startIndex = newStart;
        if (diff) {
            this.onChunkPreload.emit(this.state);
            if (!this.isRemote) {
                // recalculate and apply page size.
                if (diff && Math.abs(diff) <= MAX_PERF_SCROLL_DIFF) {
                    if (diff > 0) {
                        this.moveApplyScrollNext(prevStart);
                    }
                    else {
                        this.moveApplyScrollPrev(prevStart);
                    }
                }
                else {
                    this.fixedApplyScroll();
                }
            }
        }
        return inScrollTop - this.sizesCache[this.state.startIndex];
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     */
    moveApplyScrollNext(prevIndex) {
        const start = prevIndex + this.state.chunkSize;
        const end = start + this.state.startIndex - prevIndex;
        const container = this.dc.instance._vcr;
        for (let i = start; i < end && this.igxForOf[i] !== undefined; i++) {
            const embView = this._embeddedViews.shift();
            this.scrollFocus(embView.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE)
                || embView.rootNodes[0].nextElementSibling);
            const view = container.detach(0);
            this.updateTemplateContext(embView.context, i);
            container.insert(view);
            this._embeddedViews.push(embView);
        }
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     */
    moveApplyScrollPrev(prevIndex) {
        const container = this.dc.instance._vcr;
        for (let i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {
            const embView = this._embeddedViews.pop();
            this.scrollFocus(embView.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE)
                || embView.rootNodes[0].nextElementSibling);
            const view = container.detach(container.length - 1);
            this.updateTemplateContext(embView.context, i);
            container.insert(view, 0);
            this._embeddedViews.unshift(embView);
        }
    }
    /**
     * @hidden
     */
    getContextIndex(input) {
        return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);
    }
    /**
     * @hidden
     * Function which updates the passed context of an embedded view with the provided index
     * from the view container.
     * Often, called while handling a scroll event.
     */
    updateTemplateContext(context, index = 0) {
        context.$implicit = this.igxForOf[index];
        context.index = this.getContextIndex(this.igxForOf[index]);
        context.count = this.igxForOf.length;
    }
    /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     */
    fixedApplyScroll() {
        let j = 0;
        const endIndex = this.state.startIndex + this.state.chunkSize;
        for (let i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
            const embView = this._embeddedViews[j++];
            this.updateTemplateContext(embView.context, i);
        }
    }
    /**
     * @hidden
     * @internal
     *
     * Clears focus inside the virtualized container on small scroll swaps.
     */
    scrollFocus(node) {
        const activeElement = this.document.activeElement;
        // Remove focus in case the the active element is inside the view container.
        // Otherwise we hit an exception while doing the 'small' scrolls swapping.
        // For more information:
        //
        // https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild
        // https://bugs.chromium.org/p/chromium/issues/detail?id=432392
        if (node && node.contains(this.document.activeElement)) {
            activeElement.blur();
        }
    }
    /**
     * @hidden
     * Function that is called when scrolling horizontally
     */
    onHScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
        }
        const prevStartIndex = this.state.startIndex;
        // Updating horizontal chunks
        const scrollOffset = this.fixedUpdateAllElements(event.target.scrollLeft);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    }
    /**
     * Gets the function used to track changes in the items collection.
     * By default the object references are compared. However this can be optimized if you have unique identifier
     * value that can be used for the comparison instead of the object ref or if you have some other property values
     * in the item object that should be tracked for changes.
     * This option is similar to ngForTrackBy.
     * ```typescript
     * const trackFunc = this.parentVirtDir.igxForTrackBy;
     * ```
     */
    get igxForTrackBy() {
        return this._trackByFn;
    }
    /**
     * Sets the function used to track changes in the items collection.
     * This function can be set in scenarios where you want to optimize or
     * customize the tracking of changes for the items in the collection.
     * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
     * ```typescript
     * this.parentVirtDir.igxForTrackBy = (index, item) => {
     *      return item.id + item.width;
     * };
     * ```
     */
    set igxForTrackBy(fn) {
        this._trackByFn = fn;
    }
    /**
     * @hidden
     */
    _applyChanges() {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            let startIndex = this.state.startIndex;
            let endIndex = this.state.chunkSize + this.state.startIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                const embView = embeddedViewCopy.shift();
                this.updateTemplateContext(embView.context, i);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
        }
    }
    /**
     * @hidden
     */
    _calcMaxBrowserHeight() {
        if (!this.platformUtil.isBrowser) {
            return 0;
        }
        const div = this.document.createElement('div');
        const style = div.style;
        style.position = 'absolute';
        style.top = '9999999999999999px';
        this.document.body.appendChild(div);
        const size = Math.abs(div.getBoundingClientRect()['top']);
        this.document.body.removeChild(div);
        return size;
    }
    /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     */
    _calculateChunkSize() {
        let chunkSize = 0;
        if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {
            if (!this.sizesCache) {
                this.initSizesCache(this.igxForOf);
            }
            chunkSize = this._calcMaxChunkSize();
            if (this.igxForOf && chunkSize > this.igxForOf.length) {
                chunkSize = this.igxForOf.length;
            }
        }
        else {
            if (this.igxForOf) {
                chunkSize = this.igxForOf.length;
            }
        }
        return chunkSize;
    }
    /**
     * @hidden
     */
    getElement(viewref, nodeName) {
        const elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);
        return elem.length > 0 ? elem[0] : null;
    }
    /**
     * @hidden
     */
    initSizesCache(items) {
        let totalSize = 0;
        let size = 0;
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        let i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            if (dimension === 'height') {
                // cols[i][dimension] = parseInt(this.igxForItemSize, 10) || 0;
                size = parseInt(this.igxForItemSize, 10) || 0;
                this.heightCache.push(size);
            }
            else {
                size = this._getItemSize(items[i], dimension);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    _updateSizeCache() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        const oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce((acc, val) => acc + val) : 0;
        const newHeight = this.initSizesCache(this.igxForOf);
        const diff = oldHeight - newHeight;
        this._adjustScrollPositionAfterSizeChange(diff);
    }
    /**
     * @hidden
     */
    _calcMaxChunkSize() {
        let i = 0;
        let length = 0;
        let maxLength = 0;
        const arr = [];
        let sum = 0;
        const availableSize = parseInt(this.igxForContainerSize, 10);
        if (!availableSize) {
            return 0;
        }
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        const reducer = (accumulator, currentItem) => accumulator + this._getItemSize(currentItem, dimension);
        for (i; i < this.igxForOf.length; i++) {
            let item = this.igxForOf[i];
            if (dimension === 'height') {
                item = { value: this.igxForOf[i], height: this.heightCache[i] };
            }
            const size = dimension === 'height' ?
                this.heightCache[i] :
                this._getItemSize(item, dimension);
            sum = arr.reduce(reducer, size);
            if (sum < availableSize) {
                arr.push(item);
                length = arr.length;
                if (i === this.igxForOf.length - 1) {
                    // reached end without exceeding
                    // include prev items until size is filled or first item is reached.
                    let curItem = dimension === 'height' ? arr[0].value : arr[0];
                    let prevIndex = this.igxForOf.indexOf(curItem) - 1;
                    while (prevIndex >= 0 && sum <= availableSize) {
                        curItem = dimension === 'height' ? arr[0].value : arr[0];
                        prevIndex = this.igxForOf.indexOf(curItem) - 1;
                        const prevItem = this.igxForOf[prevIndex];
                        const prevSize = dimension === 'height' ?
                            this.heightCache[prevIndex] :
                            parseInt(prevItem[dimension], 10);
                        sum = arr.reduce(reducer, prevSize);
                        arr.unshift(prevItem);
                        length = arr.length;
                    }
                }
            }
            else {
                arr.push(item);
                length = arr.length + 1;
                arr.shift();
            }
            if (length > maxLength) {
                maxLength = length;
            }
        }
        return maxLength;
    }
    /**
     * @hidden
     */
    getIndexAt(left, set) {
        let start = 0;
        let end = set.length - 1;
        if (left === 0) {
            return 0;
        }
        while (start <= end) {
            const midIdx = Math.floor((start + end) / 2);
            const midLeft = set[midIdx];
            const cmp = left - midLeft;
            if (cmp > 0) {
                start = midIdx + 1;
            }
            else if (cmp < 0) {
                end = midIdx - 1;
            }
            else {
                return midIdx;
            }
        }
        return end;
    }
    _recalcScrollBarSize() {
        const count = this.isRemote ? this.totalItemCount : (this.igxForOf ? this.igxForOf.length : 0);
        this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);
        const scrollable = this.isScrollable();
        if (this.igxForScrollOrientation === 'horizontal') {
            const totalWidth = this.igxForContainerSize ? this.initSizesCache(this.igxForOf) : 0;
            this.scrollComponent.nativeElement.style.width = this.igxForContainerSize + 'px';
            this.scrollComponent.size = totalWidth;
            if (totalWidth <= parseInt(this.igxForContainerSize, 10)) {
                this.resetScrollPosition();
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.scrollComponent.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';
            this.scrollComponent.size = this._calcHeight();
            if (this.scrollComponent.size <= parseInt(this.igxForContainerSize, 10)) {
                this.resetScrollPosition();
            }
        }
        if (scrollable !== this.isScrollable()) {
            // scrollbar visibility has changed
            this.onScrollbarVisibilityChanged.emit();
        }
    }
    _calcHeight() {
        let height;
        if (this.heightCache) {
            height = this.heightCache.reduce((acc, val) => acc + val, 0);
        }
        else {
            height = this.initSizesCache(this.igxForOf);
        }
        this._virtHeight = height;
        if (height > this._maxHeight) {
            this._virtHeightRatio = height / this._maxHeight;
            height = this._maxHeight;
        }
        return height;
    }
    _recalcOnContainerChange(changes) {
        this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
        this.dc.instance._viewContainer.element.nativeElement.style.left = '0px';
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (prevChunkSize !== this.state.chunkSize) {
            this.onChunkLoad.emit(this.state);
        }
        if (this.sizesCache && this.igxForScrollOrientation === 'horizontal') {
            // Updating horizontal chunks and offsets based on the new scrollLeft
            const scrollOffset = this.fixedUpdateAllElements(this.scrollPosition);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
    }
    /**
     * @hidden
     * Removes an elemenet from the embedded views and updates chunkSize.
     */
    removeLastElem() {
        const oldElem = this._embeddedViews.pop();
        this.onBeforeViewDestroyed.emit(oldElem);
        // also detach from ViewContainerRef to make absolutely sure this is removed from the view container.
        this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
        oldElem.destroy();
        this.state.chunkSize--;
    }
    /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     */
    addLastElem() {
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        const input = this.igxForOf[elemIndex];
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
        this._zone.run(() => this.cdr.markForCheck());
    }
    /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in @addLastElem() or @removeLastElem()
     */
    applyChunkSizeChange() {
        const chunkSize = this.isRemote ? (this.igxForOf ? this.igxForOf.length : 0) : this._calculateChunkSize();
        if (chunkSize > this.state.chunkSize) {
            const diff = chunkSize - this.state.chunkSize;
            for (let i = 0; i < diff; i++) {
                this.addLastElem();
            }
        }
        else if (chunkSize < this.state.chunkSize) {
            const diff = this.state.chunkSize - chunkSize;
            for (let i = 0; i < diff; i++) {
                this.removeLastElem();
            }
        }
    }
    _updateScrollOffset() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._updateHScrollOffset();
        }
        else {
            this._updateVScrollOffset();
        }
    }
    _calcVirtualScrollTop(scrollTop) {
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const maxRealScrollTop = this.scrollComponent.size - containerSize;
        const realPercentScrolled = maxRealScrollTop !== 0 ? scrollTop / maxRealScrollTop : 0;
        const maxVirtScrollTop = this._virtHeight - containerSize;
        this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
    }
    _updateVScrollOffset() {
        let scrollOffset = 0;
        let currentScrollTop = this.scrollPosition;
        if (this._virtHeightRatio !== 1) {
            this._calcVirtualScrollTop(this.scrollPosition);
            currentScrollTop = this._virtScrollTop;
        }
        const vScroll = this.scrollComponent.nativeElement;
        scrollOffset = vScroll && this.scrollComponent.size ?
            currentScrollTop - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
    }
    _updateHScrollOffset() {
        let scrollOffset = 0;
        scrollOffset = this.scrollComponent.nativeElement &&
            this.scrollComponent.size ?
            this.scrollPosition - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    }
    _getItemSize(item, dimension) {
        const dim = item[dimension];
        return typeof dim === 'number' ? dim : parseInt(this.igxForItemSize, 10) || 0;
    }
    _adjustScrollPositionAfterSizeChange(sizeDiff) {
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(sizeDiff) > 0 && this.scrollPosition > 0) {
            this.recalcUpdateSizes();
            const offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            const newSize = this.sizesCache[this.state.startIndex] - offset;
            this.scrollPosition = newSize === this.scrollPosition ? newSize + 1 : newSize;
        }
    }
}
IgxForOfDirective.decorators = [
    { type: Directive, args: [{ selector: '[igxFor][igxForOf]',
                providers: [IgxForOfScrollSyncService] },] }
];
IgxForOfDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: IterableDiffers },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: IgxForOfScrollSyncService },
    { type: PlatformUtil },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
IgxForOfDirective.propDecorators = {
    igxForOf: [{ type: Input }],
    igxForSizePropName: [{ type: Input }],
    igxForScrollOrientation: [{ type: Input }],
    igxForScrollContainer: [{ type: Input }],
    igxForContainerSize: [{ type: Input }],
    igxForItemSize: [{ type: Input }],
    onChunkLoad: [{ type: Output }],
    onScrollbarVisibilityChanged: [{ type: Output }],
    onContentSizeChange: [{ type: Output }],
    onDataChanged: [{ type: Output }],
    onBeforeViewDestroyed: [{ type: Output }],
    onChunkPreload: [{ type: Output }],
    igxForTotalItemCount: [{ type: Input }],
    igxForTrackBy: [{ type: Input }]
};
const getTypeNameForDebugging = (type) => type.name || typeof type;
class IgxGridForOfDirective extends IgxForOfDirective {
    constructor(_viewContainer, _template, _differs, resolver, cdr, _zone, _platformUtil, _document, syncScrollService, syncService) {
        super(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService, _platformUtil, _document);
        this.syncScrollService = syncScrollService;
        this.syncService = syncService;
        /**
         * @hidden @internal
         * An event that is emitted after data has been changed but before the view is refreshed
         */
        this.onDataChanging = new EventEmitter();
    }
    set igxGridForOf(value) {
        this.igxForOf = value;
    }
    get igxGridForOf() {
        return this.igxForOf;
    }
    /**
     * @hidden
     * @internal
     */
    get sizesCache() {
        if (this.syncService.isMaster(this)) {
            return this._sizesCache;
        }
        return this.syncService.sizesCache(this.igxForScrollOrientation);
    }
    /**
     * @hidden
     * @internal
     */
    set sizesCache(value) {
        this._sizesCache = value;
    }
    get itemsDimension() {
        return this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
    }
    ngOnInit() {
        this.syncService.setMaster(this);
        super.ngOnInit();
        this.removeScrollEventListeners();
    }
    ngOnChanges(changes) {
        const forOf = 'igxGridForOf';
        this.syncService.setMaster(this);
        if (forOf in changes) {
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
        }
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
        }
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    }
    /**
     * @hidden
     * @internal
     */
    assumeMaster() {
        this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
        this.syncService.setMaster(this, true);
    }
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                const args = {
                    containerSize: this.igxForContainerSize
                };
                this.onDataChanging.emit(args);
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                /* we need to reset the master dir if all rows are removed
                (e.g. because of filtering); if all columns are hidden, rows are
                still rendered empty, so we should not reset master */
                if (!this.igxForOf.length &&
                    this.igxForScrollOrientation === 'vertical') {
                    this.syncService.resetMaster();
                }
                this.syncService.setMaster(this);
                this.igxForContainerSize = args.containerSize;
                this._updateSizeCache(changes);
                this._applyChanges();
                this._updateScrollOffset();
                this.onDataChanged.emit();
            }
        }
    }
    onScroll(event) {
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollTop(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this._zone.onStable.pipe(first$1()).subscribe(this.recalcUpdateSizes.bind(this));
        this.cdr.markForCheck();
    }
    onHScroll(scrollAmount) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!this.scrollComponent || !parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
        }
        // Updating horizontal chunks
        const scrollOffset = this.fixedUpdateAllElements(scrollAmount);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    }
    getItemSize(item) {
        let size = 0;
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        if (dimension === 'height') {
            size = parseInt(this.igxForItemSize, 10) || 0;
            if (item && item.summaries) {
                size = item.max;
            }
            else if (item && item.groups && item.height) {
                size = item.height;
            }
        }
        else {
            size = parseInt(item[dimension], 10) || 0;
        }
        return size;
    }
    initSizesCache(items) {
        if (!this.syncService.isMaster(this)) {
            const masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
            return masterSizesCache[masterSizesCache.length - 1];
        }
        let totalSize = 0;
        let size = 0;
        let i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            size = this.getItemSize(items[i]);
            if (this.itemsDimension === 'height') {
                this.heightCache.push(size);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    _updateSizeCache(changes = null) {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        const oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce((acc, val) => acc + val) : 0;
        let newHeight = oldHeight;
        if (changes && !this.isRemote) {
            newHeight = this.handleCacheChanges(changes);
        }
        else {
            return;
        }
        const diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0 && this.platformUtil.isBrowser) {
            // TODO: This code can be removed. However tests need to be rewritten in a way that they wait for ResizeObserved to complete.
            // So leaving as is for the moment.
            requestAnimationFrame(() => {
                this.recalcUpdateSizes();
                const offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                if (this.scrollPosition !== 0) {
                    this.scrollPosition = this.sizesCache[this.state.startIndex] - offset;
                }
                else {
                    this._updateScrollOffset();
                }
            });
        }
    }
    handleCacheChanges(changes) {
        const identityChanges = [];
        const newHeightCache = [];
        const newSizesCache = [];
        newSizesCache.push(0);
        let newHeight = 0;
        // When there are more than one removed items the changes are not reliable so those with identity change should be default size.
        let numRemovedItems = 0;
        changes.forEachRemovedItem(() => numRemovedItems++);
        // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.
        changes.forEachIdentityChange((item) => {
            if (item.currentIndex !== item.previousIndex) {
                // Filter out ones that have not changed their index.
                identityChanges[item.currentIndex] = item;
            }
        });
        // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.
        changes.forEachItem((item) => {
            if (item.previousIndex !== null &&
                (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])) {
                // Reuse cache on those who have previousIndex.
                // When there are more than one removed items currently the changes are not readable so ones with identity change
                // should be racalculated.
                newHeightCache[item.currentIndex] = this.heightCache[item.previousIndex];
            }
            else {
                // Assign default item size.
                newHeightCache[item.currentIndex] = this.getItemSize(item.item);
            }
            newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];
            newHeight += newHeightCache[item.currentIndex];
        });
        this.heightCache = newHeightCache;
        this.sizesCache = newSizesCache;
        return newHeight;
    }
    addLastElem() {
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        const input = this.igxForOf[elemIndex];
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
    }
    _updateViews(prevChunkSize) {
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            let startIndex;
            let endIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            else {
                startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache);
                if (startIndex + this.state.chunkSize > this.igxForOf.length) {
                    startIndex = this.igxForOf.length - this.state.chunkSize;
                }
                this.state.startIndex = startIndex;
                endIndex = this.state.chunkSize + this.state.startIndex;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                const embView = embeddedViewCopy.shift();
                this.updateTemplateContext(embView.context, i);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
        }
    }
    _applyChanges() {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        this._updateViews(prevChunkSize);
    }
    /**
     * @hidden
     */
    _calcMaxChunkSize() {
        if (this.syncService.isMaster(this)) {
            return super._calcMaxChunkSize();
        }
        return this.syncService.chunkSize(this.igxForScrollOrientation);
    }
}
IgxGridForOfDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxGridFor][igxGridForOf]'
            },] }
];
IgxGridForOfDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: IterableDiffers },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: PlatformUtil },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: IgxForOfScrollSyncService },
    { type: IgxForOfSyncService }
];
IgxGridForOfDirective.propDecorators = {
    igxGridForOf: [{ type: Input }],
    onDataChanging: [{ type: Output }]
};
/**
 * @hidden
 */
class IgxForOfModule {
}
IgxForOfModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxForOfDirective, IgxGridForOfDirective, DisplayContainerComponent, VirtualHelperComponent,
                    HVirtualHelperComponent, VirtualHelperBaseDirective],
                entryComponents: [DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent],
                exports: [IgxForOfDirective, IgxGridForOfDirective],
                imports: [IgxScrollInertiaModule, CommonModule]
            },] }
];

/**
 * **Ignite UI for Angular DropDown** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/drop-down)
 *
 * The Ignite UI for Angular Drop Down displays a scrollable list of items which may be visually grouped and
 * supports selection of a single item. Clicking or tapping an item selects it and closes the Drop Down
 *
 * Example:
 * ```html
 * <igx-drop-down>
 *   <igx-drop-down-item *ngFor="let item of items" disabled={{item.disabled}} isHeader={{item.header}}>
 *     {{ item.value }}
 *   </igx-drop-down-item>
 * </igx-drop-down>
 * ```
 */
class IgxDropDownComponent extends IgxDropDownBaseDirective {
    constructor(elementRef, cdr, selection, _displayDensityOptions) {
        super(elementRef, cdr, _displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-drop-down (onOpening)='handleOpening()'></igx-drop-down>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-drop-down (onOpened)='handleOpened()'></igx-drop-down>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-drop-down (onClosing)='handleClosing()'></igx-drop-down>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-drop-down (onClosed)='handleClosed()'></igx-drop-down>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Gets/sets whether items take focus. Disabled by default.
         * When enabled, drop down items gain tab index and are focused when active -
         * this includes activating the selected item when opening the drop down and moving with keyboard navigation.
         *
         * Note: Keep that focus shift in mind when using the igxDropDownItemNavigation directive
         * and ensure it's placed either on each focusable item or a common ancestor to allow it to handle keyboard events.
         *
         * ```typescript
         * // get
         * let dropDownAllowsItemFocus = this.dropdown.allowItemsFocus;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-drop-down [allowItemsFocus]='true'></igx-drop-down>
         * ```
         */
        this.allowItemsFocus = false;
        this.destroy$ = new Subject();
    }
    /**
     * @hidden @internal
     */
    get focusedItem() {
        if (this.virtDir) {
            return this._focusedItem && this._focusedItem.index !== -1 ?
                (this.children.find(e => e.index === this._focusedItem.index) || null) :
                null;
        }
        return this._focusedItem;
    }
    set focusedItem(value) {
        if (!value) {
            this.selection.clear(`${this.id}-active`);
            this._focusedItem = null;
            return;
        }
        this._focusedItem = value;
        if (this.virtDir) {
            this._focusedItem = {
                value: value.value,
                index: value.index
            };
        }
        this.selection.set(`${this.id}-active`, new Set([this._focusedItem]));
    }
    get id() {
        return this._id;
    }
    set id(value) {
        this.selection.set(value, this.selection.get(this.id));
        this.selection.clear(this.id);
        this.selection.set(value, this.selection.get(`${this.id}-active`));
        this.selection.clear(`${this.id}-active`);
        this._id = value;
    }
    /** Id of the internal listbox of the drop down */
    get listId() {
        return this.id + '-list';
    }
    /**
     * Get currently selected item
     *
     * ```typescript
     * let currentItem = this.dropdown.selectedItem;
     * ```
     */
    get selectedItem() {
        const selectedItem = this.selection.first_item(this.id);
        if (selectedItem) {
            return selectedItem;
        }
        return null;
    }
    /**
     * Gets if the dropdown is collapsed
     *
     * ```typescript
     * let isCollapsed = this.dropdown.collapsed;
     * ```
     */
    get collapsed() {
        return this.toggleDirective.collapsed;
    }
    /** @hidden @internal */
    get scrollContainer() {
        return this.scrollContainerRef.nativeElement;
    }
    get collectionLength() {
        if (this.virtDir) {
            return this.virtDir.totalItemCount || this.virtDir.igxForOf.length;
        }
    }
    /**
     * Opens the dropdown
     *
     * ```typescript
     * this.dropdown.open();
     * ```
     */
    open(overlaySettings) {
        this.toggleDirective.open(overlaySettings);
        this.updateScrollPosition();
    }
    /**
     * Closes the dropdown
     *
     * ```typescript
     * this.dropdown.close();
     * ```
     */
    close() {
        this.toggleDirective.close();
    }
    /**
     * Toggles the dropdown
     *
     * ```typescript
     * this.dropdown.toggle();
     * ```
     */
    toggle(overlaySettings) {
        if (this.collapsed || this.toggleDirective.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    }
    /**
     * Select an item by index
     *
     * @param index of the item to select; If the drop down uses *igxFor, pass the index in data
     */
    setSelectedItem(index) {
        if (index < 0 || index >= this.items.length) {
            return;
        }
        let newSelection;
        if (this.virtDir) {
            newSelection = {
                value: this.virtDir.igxForOf[index],
                index
            };
        }
        else {
            newSelection = this.items[index];
        }
        this.selectItem(newSelection);
    }
    /**
     * Navigates to the item on the specified index
     * If the data in the drop-down is virtualized, pass the index of the item in the virtualized data.
     *
     * @param newIndex number
     */
    navigateItem(index) {
        if (this.virtDir) {
            if (index === -1 || index >= this.collectionLength) {
                return;
            }
            const direction = index > (this.focusedItem ? this.focusedItem.index : -1) ? Navigate.Down : Navigate.Up;
            const subRequired = this.isIndexOutOfBounds(index, direction);
            this.focusedItem = {
                value: this.virtDir.igxForOf[index],
                index
            };
            if (subRequired) {
                this.virtDir.scrollTo(index);
            }
            if (subRequired) {
                this.virtDir.onChunkLoad.pipe(take(1)).subscribe(() => {
                    this.skipHeader(direction);
                });
            }
            else {
                this.skipHeader(direction);
            }
        }
        else {
            super.navigateItem(index);
        }
        if (this.allowItemsFocus && this.focusedItem) {
            this.focusedItem.element.nativeElement.focus();
            this.cdr.markForCheck();
        }
    }
    /**
     * @hidden @internal
     */
    updateScrollPosition() {
        if (!this.virtDir) {
            return;
        }
        if (!this.selectedItem) {
            this.virtDir.scrollTo(0);
            return;
        }
        let targetScroll = this.virtDir.getScrollForIndex(this.selectedItem.index);
        const itemsInView = this.virtDir.igxForContainerSize / this.virtDir.igxForItemSize;
        targetScroll -= (itemsInView / 2 - 1) * this.virtDir.igxForItemSize;
        this.virtDir.getScroll().scrollTop = targetScroll;
    }
    /**
     * @hidden @internal
     */
    onToggleOpening(e) {
        // do not mutate passed event args
        const eventArgs = Object.assign({}, e, { owner: this });
        this.onOpening.emit(eventArgs);
        e.cancel = eventArgs.cancel;
        if (e.cancel) {
            return;
        }
        if (this.virtDir) {
            this.virtDir.scrollPosition = this._scrollPosition;
        }
    }
    /**
     * @hidden @internal
     */
    onToggleContentAppended() {
        if (!this.virtDir && this.selectedItem) {
            this.scrollToItem(this.selectedItem);
        }
    }
    /**
     * @hidden @internal
     */
    onToggleOpened() {
        this.updateItemFocus();
        this.onOpened.emit();
    }
    /**
     * @hidden @internal
     */
    onToggleClosing(e) {
        const eventArgs = Object.assign({}, e, { owner: this });
        this.onClosing.emit(eventArgs);
        e.cancel = eventArgs.cancel;
        if (e.cancel) {
            return;
        }
        if (this.virtDir) {
            this._scrollPosition = this.virtDir.scrollPosition;
        }
    }
    /**
     * @hidden @internal
     */
    onToggleClosed() {
        this.focusItem(false);
        this.onClosed.emit();
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
        this.selection.clear(this.id);
        this.selection.clear(`${this.id}-active`);
    }
    /** @hidden @internal */
    calculateScrollPosition(item) {
        if (!item) {
            return 0;
        }
        const elementRect = item.element.nativeElement.getBoundingClientRect();
        const parentRect = this.scrollContainer.getBoundingClientRect();
        const scrollDelta = parentRect.top - elementRect.top;
        let scrollPosition = this.scrollContainer.scrollTop - scrollDelta;
        const dropDownHeight = this.scrollContainer.clientHeight;
        scrollPosition -= dropDownHeight / 2;
        scrollPosition += item.elementHeight / 2;
        return Math.floor(scrollPosition);
    }
    /**
     * @hidden @internal
     */
    ngOnChanges(changes) {
        if (changes.id) {
            // temp workaround until fix --> https://github.com/angular/angular/issues/34992
            this.toggleDirective.id = changes.id.currentValue;
        }
    }
    ngAfterViewInit() {
        if (this.virtDir) {
            this.virtDir.igxForItemSize = 28;
        }
    }
    /** Keydown Handler */
    onItemActionKey(key, event) {
        super.onItemActionKey(key, event);
        this.close();
    }
    /**
     * Virtual scroll implementation
     *
     * @hidden @internal
     */
    navigateFirst() {
        if (this.virtDir) {
            this.navigateItem(0);
        }
        else {
            super.navigateFirst();
        }
    }
    /**
     * @hidden @internal
     */
    navigateLast() {
        if (this.virtDir) {
            this.navigateItem(this.virtDir.totalItemCount ? this.virtDir.totalItemCount - 1 : this.virtDir.igxForOf.length - 1);
        }
        else {
            super.navigateLast();
        }
    }
    /**
     * @hidden @internal
     */
    navigateNext() {
        if (this.virtDir) {
            this.navigateItem(this._focusedItem ? this._focusedItem.index + 1 : 0);
        }
        else {
            super.navigateNext();
        }
    }
    /**
     * @hidden @internal
     */
    navigatePrev() {
        if (this.virtDir) {
            this.navigateItem(this._focusedItem ? this._focusedItem.index - 1 : 0);
        }
        else {
            super.navigatePrev();
        }
    }
    /**
     * Handles the `onSelection` emit and the drop down toggle when selection changes
     *
     * @hidden
     * @internal
     * @param newSelection
     * @param event
     */
    selectItem(newSelection, event) {
        const oldSelection = this.selectedItem;
        if (!newSelection) {
            newSelection = this.focusedItem;
        }
        if (newSelection === null) {
            return;
        }
        if (newSelection instanceof IgxDropDownItemBaseDirective && newSelection.isHeader) {
            return;
        }
        if (this.virtDir) {
            newSelection = {
                value: newSelection.value,
                index: newSelection.index
            };
        }
        const args = { oldSelection, newSelection, cancel: false };
        this.onSelection.emit(args);
        if (!args.cancel) {
            if (this.isSelectionValid(args.newSelection)) {
                this.selection.set(this.id, new Set([args.newSelection]));
                if (!this.virtDir) {
                    if (oldSelection) {
                        oldSelection.selected = false;
                    }
                    if (args.newSelection) {
                        args.newSelection.selected = true;
                    }
                }
                if (event) {
                    this.toggleDirective.close();
                }
            }
            else {
                throw new Error('Please provide a valid drop-down item for the selection!');
            }
        }
    }
    /**
     * Clears the selection of the dropdown
     * ```typescript
     * this.dropdown.clearSelection();
     * ```
     */
    clearSelection() {
        const oldSelection = this.selectedItem;
        const newSelection = null;
        const args = { oldSelection, newSelection, cancel: false };
        this.onSelection.emit(args);
        if (this.selectedItem && !args.cancel) {
            this.selectedItem.selected = false;
            this.selection.clear(this.id);
        }
    }
    /**
     * Checks whether the selection is valid
     * `null` - the selection should be emptied
     * Virtual? - the selection should at least have and `index` and `value` property
     * Non-virtual? - the selection should be a valid drop-down item and **not** be a header
     */
    isSelectionValid(selection) {
        return selection === null
            || (this.virtDir && selection.hasOwnProperty('value') && selection.hasOwnProperty('index'))
            || (selection instanceof IgxDropDownItemComponent && !selection.isHeader);
    }
    scrollToItem(item) {
        const itemPosition = this.calculateScrollPosition(item);
        //  in IE11 setting sctrollTop is somehow slow and forces dropdown
        //  to appear on screen before animation start. As a result dropdown
        //  flickers badly. This is why we set scrollTop just a little later
        //  allowing animation to start and prevent dropdown flickering
        if (isIE()) {
            setTimeout(() => {
                this.scrollContainer.scrollTop = (itemPosition);
            }, 1);
        }
        else {
            this.scrollContainer.scrollTop = (itemPosition);
        }
    }
    focusItem(value) {
        if (value || this._focusedItem) {
            this._focusedItem.focused = value;
        }
    }
    updateItemFocus() {
        if (this.selectedItem) {
            this.focusedItem = this.selectedItem;
            this.focusItem(true);
        }
        else if (this.allowItemsFocus) {
            this.navigateFirst();
        }
    }
    skipHeader(direction) {
        if (!this.focusedItem) {
            return;
        }
        if (this.focusedItem.isHeader || this.focusedItem.disabled) {
            if (direction === Navigate.Up) {
                this.navigatePrev();
            }
            else {
                this.navigateNext();
            }
        }
    }
    isIndexOutOfBounds(index, direction) {
        const virtState = this.virtDir.state;
        const currentPosition = this.virtDir.getScroll().scrollTop;
        const itemPosition = this.virtDir.getScrollForIndex(index, direction === Navigate.Down);
        const indexOutOfChunk = index < virtState.startIndex || index > virtState.chunkSize + virtState.startIndex;
        const scrollNeeded = direction === Navigate.Down ? currentPosition < itemPosition : currentPosition > itemPosition;
        const subRequired = indexOutOfChunk || scrollNeeded;
        return subRequired;
    }
}
IgxDropDownComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-drop-down',
                template: "<div class=\"igx-drop-down__list\" [style.width]=\"width\"\nigxToggle\n(onAppended)=\"onToggleContentAppended()\"\n(onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n(onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <div class=\"igx-drop-down__list-scroll\" #scrollContainer [attr.id]=\"this.listId\" role=\"listbox\"\n    [style.height]=\"height\"\n    [style.maxHeight]=\"maxHeight\">\n        <ng-container *ngIf=\"!collapsed\">\n            <ng-content></ng-content>\n        </ng-container>\n    </div>\n</div>\n",
                providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxDropDownComponent }]
            },] }
];
IgxDropDownComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxSelectionAPIService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxDropDownComponent.propDecorators = {
    children: [{ type: ContentChildren, args: [forwardRef(() => IgxDropDownItemComponent), { descendants: true },] }],
    onOpening: [{ type: Output }],
    onOpened: [{ type: Output }],
    onClosing: [{ type: Output }],
    onClosed: [{ type: Output }],
    allowItemsFocus: [{ type: Input }],
    virtDir: [{ type: ContentChild, args: [IgxForOfDirective, { read: IgxForOfDirective },] }],
    toggleDirective: [{ type: ViewChild, args: [IgxToggleDirective, { static: true },] }],
    scrollContainerRef: [{ type: ViewChild, args: ['scrollContainer', { static: true },] }]
};

/**
 * Navigation Directive that handles keyboard events on its host and controls a targeted IgxDropDownBaseDirective component
 */
class IgxDropDownItemNavigationDirective {
    constructor(dropdown) {
        this.dropdown = dropdown;
        this._target = null;
    }
    /**
     * Gets the target of the navigation directive;
     *
     * ```typescript
     * // Get
     * export class MyComponent {
     *  ...
     *  @ContentChild(IgxDropDownNavigationDirective)
     *  navDirective: IgxDropDownNavigationDirective = null
     *  ...
     *  const navTarget: IgxDropDownBaseDirective = navDirective.navTarget
     * }
     * ```
     */
    get target() {
        return this._target;
    }
    /**
     * Sets the target of the navigation directive;
     * If no valid target is passed, it falls back to the drop down context
     *
     * ```html
     * <!-- Set -->
     * <input [igxDropDownItemNavigation]="dropdown" />
     * ...
     * <igx-drop-down #dropdown>
     * ...
     * </igx-drop-down>
     * ```
     */
    set target(target) {
        this._target = target ? target : this.dropdown;
    }
    /**
     * Captures keydown events and calls the appropriate handlers on the target component
     */
    handleKeyDown(event) {
        if (event) {
            const key = event.key.toLowerCase();
            if (!this.target.collapsed) { // If dropdown is opened
                const navKeys = ['esc', 'escape', 'enter', 'space', 'spacebar', ' ',
                    'arrowup', 'up', 'arrowdown', 'down', 'home', 'end'];
                if (navKeys.indexOf(key) === -1) { // If key has appropriate function in DD
                    return;
                }
                event.preventDefault();
                event.stopPropagation();
            }
            else { // If dropdown is closed, do nothing
                return;
            }
            switch (key) {
                case 'esc':
                case 'escape':
                    this.target.onItemActionKey(DropDownActionKey.ESCAPE, event);
                    break;
                case 'enter':
                    this.target.onItemActionKey(DropDownActionKey.ENTER, event);
                    break;
                case 'space':
                case 'spacebar':
                case ' ':
                    this.target.onItemActionKey(DropDownActionKey.SPACE, event);
                    break;
                case 'arrowup':
                case 'up':
                    this.onArrowUpKeyDown();
                    break;
                case 'arrowdown':
                case 'down':
                    this.onArrowDownKeyDown();
                    break;
                case 'home':
                    this.onHomeKeyDown();
                    break;
                case 'end':
                    this.onEndKeyDown();
                    break;
                default:
                    return;
            }
        }
    }
    /**
     * Navigates to previous item
     */
    onArrowDownKeyDown() {
        this.target.navigateNext();
    }
    /**
     * Navigates to previous item
     */
    onArrowUpKeyDown() {
        this.target.navigatePrev();
    }
    /**
     * Navigates to target's last item
     */
    onEndKeyDown() {
        this.target.navigateLast();
    }
    /**
     * Navigates to target's first item
     */
    onHomeKeyDown() {
        this.target.navigateFirst();
    }
}
IgxDropDownItemNavigationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDropDownItemNavigation]'
            },] }
];
IgxDropDownItemNavigationDirective.ctorParameters = () => [
    { type: IgxDropDownBaseDirective, decorators: [{ type: Self }, { type: Optional }, { type: Inject, args: [IGX_DROPDOWN_BASE,] }] }
];
IgxDropDownItemNavigationDirective.propDecorators = {
    target: [{ type: Input, args: ['igxDropDownItemNavigation',] }],
    handleKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * @hidden
 */
class IgxDropDownModule {
}
IgxDropDownModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxDropDownComponent,
                    IgxDropDownItemBaseDirective,
                    IgxDropDownItemComponent,
                    IgxDropDownGroupComponent,
                    IgxDropDownItemNavigationDirective
                ],
                exports: [
                    IgxDropDownComponent,
                    IgxDropDownItemComponent,
                    IgxDropDownGroupComponent,
                    IgxDropDownItemNavigationDirective
                ],
                imports: [
                    CommonModule,
                    IgxToggleModule
                ]
            },] }
];

var IgxHintPosition;
(function (IgxHintPosition) {
    IgxHintPosition[IgxHintPosition["START"] = 0] = "START";
    IgxHintPosition[IgxHintPosition["END"] = 1] = "END";
})(IgxHintPosition || (IgxHintPosition = {}));
class IgxHintDirective {
    constructor() {
        /**
         * Sets/gets whether the hint position is at the start.
         * Default value is `false`.
         * ```typescript
         * @ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionStart = true;
         * ```
         * ```typescript
         * let isHintPositionStart = this.igxHint.isPositionStart;
         * ```
         *
         * @memberof IgxHintDirective
         */
        this.isPositionStart = false;
        /**
         * Sets/gets whether the hint position is at the end.
         * Default value is `false`.
         * ```typescript
         * @ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionEnd = true;
         * ```
         * ```typescript
         * let isHintPositionEnd = this.igxHint.isPositionEnd;
         * ```
         *
         * @memberof IgxHintDirective
         */
        this.isPositionEnd = false;
        this._position = IgxHintPosition.START;
    }
    /**
     * Sets the position of the hint.
     * ```html
     * <igx-input-group>
     *  <input igxInput type="text"/>
     *  <igx-hint #hint [position]="'start'">IgxHint displayed at the start</igx-hint>
     * </igx-input-group>
     * ```
     *
     * @memberof IgxHintDirective
     */
    set position(value) {
        const position = IgxHintPosition[value.toUpperCase()];
        if (position !== undefined) {
            this._position = position;
            this._applyPosition(this._position);
        }
    }
    /**
     * Gets the position of the hint.
     * ```typescript
     * @ViewChild('hint', {read: IgxHintDirective})
     * public igxHint: IgxHintDirective;
     * let hintPosition =  this.igxHint.position;
     * ```
     *
     * @memberof IgxHintDirective
     */
    get position() {
        return this._position.toString();
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._applyPosition(this._position);
    }
    _applyPosition(position) {
        this.isPositionStart = this.isPositionEnd = false;
        switch (position) {
            case IgxHintPosition.START:
                this.isPositionStart = true;
                break;
            case IgxHintPosition.END:
                this.isPositionEnd = true;
                break;
            default: break;
        }
    }
}
IgxHintDirective.decorators = [
    { type: Directive, args: [{
                selector: 'igx-hint,[igxHint]'
            },] }
];
IgxHintDirective.propDecorators = {
    isPositionStart: [{ type: HostBinding, args: ['class.igx-input-group__hint-item--start',] }],
    isPositionEnd: [{ type: HostBinding, args: ['class.igx-input-group__hint-item--end',] }],
    position: [{ type: Input, args: ['position',] }]
};

/** @hidden */
class IgxInputGroupBase {
}

const nativeValidationAttributes = [
    'required',
    'pattern',
    'minlength',
    'maxlength',
    'min',
    'max',
    'step',
];
var IgxInputState;
(function (IgxInputState) {
    IgxInputState[IgxInputState["INITIAL"] = 0] = "INITIAL";
    IgxInputState[IgxInputState["VALID"] = 1] = "VALID";
    IgxInputState[IgxInputState["INVALID"] = 2] = "INVALID";
})(IgxInputState || (IgxInputState = {}));
/**
 * The `igxInput` directive creates single- or multiline text elements, covering common scenarios when dealing with form inputs.
 *
 * @igxModule IgxInputGroupModule
 *
 * @igxParent Data Entry & Display
 *
 * @igxTheme igx-input-group-theme
 *
 * @igxKeywords input, input group, form, field, validation
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <input-group>
 *  <label for="address">Address</label>
 *  <input igxInput name="address" type="text" [(ngModel)]="customer.address">
 * </input-group>
 * ```
 */
class IgxInputDirective {
    constructor(inputGroup, ngModel, formControl, element, cdr) {
        this.inputGroup = inputGroup;
        this.ngModel = ngModel;
        this.formControl = formControl;
        this.element = element;
        this.cdr = cdr;
        /**
         * Sets/gets whether the `"igx-input-group__input"` class is added to the host element.
         * Default value is `false`.
         *
         * @example
         * ```typescript
         * this.igxInput.isInput = true;
         * ```
         *
         * @example
         * ```typescript
         * let isCLassAdded = this.igxInput.isInput;
         * ```
         */
        this.isInput = false;
        /**
         * Sets/gets whether the `"class.igx-input-group__textarea"` class is added to the host element.
         * Default value is `false`.
         *
         * @example
         * ```typescript
         * this.igxInput.isTextArea = true;
         * ```
         *
         * @example
         * ```typescript
         * let isCLassAdded = this.igxInput.isTextArea;
         * ```
         */
        this.isTextArea = false;
        this._valid = IgxInputState.INITIAL;
    }
    get ngControl() {
        return this.ngModel ? this.ngModel : this.formControl;
    }
    /**
     * Sets the `value` property.
     *
     * @example
     * ```html
     * <input-group>
     *  <input igxInput #igxInput [value]="'IgxInput Value'">
     * </input-group>
     * ```
     */
    set value(value) {
        this.nativeElement.value = value !== null && value !== void 0 ? value : '';
        this.updateValidityState();
    }
    /**
     * Gets the `value` property.
     *
     * @example
     * ```typescript
     * @ViewChild('igxInput', {read: IgxInputDirective})
     *  public igxInput: IgxInputDirective;
     * let inputValue = this.igxInput.value;
     * ```
     */
    get value() {
        return this.nativeElement.value;
    }
    /**
     * Sets the `disabled` property.
     *
     * @example
     * ```html
     * <input-group>
     *  <input igxInput #igxInput [disabled]="true">
     * </input-group>
     * ```
     */
    set disabled(value) {
        this.nativeElement.disabled = value;
        this.inputGroup.disabled = value;
    }
    /**
     * Gets the `disabled` property
     *
     * @example
     * ```typescript
     * @ViewChild('igxInput', {read: IgxInputDirective})
     *  public igxInput: IgxInputDirective;
     * let isDisabled = this.igxInput.disabled;
     * ```
     */
    get disabled() {
        return this.nativeElement.hasAttribute('disabled');
    }
    /**
     * Sets the `required` property.
     *
     * @example
     * ```html
     * <input-group>
     *  <input igxInput #igxInput [required]="true">
     * </input-group>
     * ```
     */
    set required(value) {
        this.nativeElement.required = this.inputGroup.isRequired = value;
    }
    /**
     * Gets whether the igxInput is required.
     *
     * @example
     * ```typescript
     * let isRequired = this.igxInput.required;
     * ```
     */
    get required() {
        return this.nativeElement.hasAttribute('required');
    }
    /**
     * @hidden
     * @internal
     */
    onFocus() {
        this.inputGroup.isFocused = true;
    }
    /**
     * @param event The event to invoke the handler
     *
     * @hidden
     * @internal
     */
    onBlur() {
        this.inputGroup.isFocused = false;
        this.updateValidityState();
    }
    /** @hidden @internal */
    onInput() {
        this.checkNativeValidity();
    }
    /** @hidden @internal */
    change(event) {
        if (this.type === 'file') {
            const fileList = event.target
                .files;
            const fileArray = [];
            if (fileList) {
                for (const file of Array.from(fileList)) {
                    fileArray.push(file);
                }
            }
            this._fileNames = (fileArray || []).map((f) => f.name).join(', ');
            if (this.required && (fileList === null || fileList === void 0 ? void 0 : fileList.length) > 0) {
                this._valid = IgxInputState.INITIAL;
            }
        }
    }
    /** @hidden @internal */
    get fileNames() {
        return this._fileNames;
    }
    /** @hidden @internal */
    clear() {
        this.nativeElement.value = null;
        this._fileNames = '';
    }
    /** @hidden @internal */
    ngAfterViewInit() {
        this.inputGroup.hasPlaceholder = this.nativeElement.hasAttribute('placeholder');
        this.inputGroup.disabled =
            this.inputGroup.disabled ||
                this.nativeElement.hasAttribute('disabled');
        this.inputGroup.isRequired = this.nativeElement.hasAttribute('required');
        // Make sure we do not invalidate the input on init
        if (!this.ngControl) {
            this._valid = IgxInputState.INITIAL;
        }
        // Also check the control's validators for required
        if (!this.inputGroup.isRequired &&
            this.ngControl &&
            this.ngControl.control.validator) {
            const validation = this.ngControl.control.validator({});
            this.inputGroup.isRequired = validation && validation.required;
        }
        const elTag = this.nativeElement.tagName.toLowerCase();
        if (elTag === 'textarea') {
            this.isTextArea = true;
        }
        else {
            this.isInput = true;
        }
        if (this.ngControl) {
            this._statusChanges$ = this.ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
        }
        this.cdr.detectChanges();
    }
    /** @hidden @internal */
    ngOnDestroy() {
        if (this._statusChanges$) {
            this._statusChanges$.unsubscribe();
        }
    }
    /**
     * Sets a focus on the igxInput.
     *
     * @example
     * ```typescript
     * this.igxInput.focus();
     * ```
     */
    focus() {
        this.nativeElement.focus();
    }
    /**
     * Gets the `nativeElement` of the igxInput.
     *
     * @example
     * ```typescript
     * let igxInputNativeElement = this.igxInput.nativeElement;
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /** @hidden @internal */
    onStatusChanged() {
        // Enable/Disable control based on ngControl #7086
        if (this.disabled !== this.ngControl.disabled) {
            this.disabled = this.ngControl.disabled;
        }
        this.updateValidityState();
    }
    /**
     * @hidden
     * @internal
     */
    updateValidityState() {
        if (this.ngControl) {
            if (this.ngControl.control.validator || this.ngControl.control.asyncValidator) {
                if (!this.disabled && (this.ngControl.control.touched || this.ngControl.control.dirty)) {
                    // the control is not disabled and is touched or dirty
                    this._valid = this.ngControl.invalid ?
                        IgxInputState.INVALID : this.focused ? IgxInputState.VALID :
                        IgxInputState.INITIAL;
                }
                else {
                    //  if control is untouched, pristine, or disabled its state is initial. This is when user did not interact
                    //  with the input or when form/control is reset
                    this._valid = IgxInputState.INITIAL;
                }
            }
        }
        else {
            this.checkNativeValidity();
        }
    }
    /**
     * Gets whether the igxInput has a placeholder.
     *
     * @example
     * ```typescript
     * let hasPlaceholder = this.igxInput.hasPlaceholder;
     * ```
     */
    get hasPlaceholder() {
        return this.nativeElement.hasAttribute('placeholder');
    }
    /**
     * Gets the placeholder element of the igxInput.
     *
     * @example
     * ```typescript
     * let igxInputPlaceholder = this.igxInput.placeholder;
     * ```
     */
    get placeholder() {
        return this.nativeElement.placeholder;
    }
    /**
     * @returns An indicator of whether the input has validator attributes or not
     *
     * @hidden
     * @internal
     */
    _hasValidators() {
        for (const nativeValidationAttribute of nativeValidationAttributes) {
            if (this.nativeElement.hasAttribute(nativeValidationAttribute)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Gets whether the igxInput is focused.
     *
     * @example
     * ```typescript
     * let isFocused = this.igxInput.focused;
     * ```
     */
    get focused() {
        return this.inputGroup.isFocused;
    }
    /**
     * Gets the state of the igxInput.
     *
     * @example
     * ```typescript
     * let igxInputState = this.igxInput.valid;
     * ```
     */
    get valid() {
        return this._valid;
    }
    /**
     * Sets the state of the igxInput.
     *
     * @example
     * ```typescript
     * this.igxInput.valid = IgxInputState.INVALID;
     * ```
     */
    set valid(value) {
        this._valid = value;
    }
    /**
     * Gets whether the igxInput is valid.
     *
     * @example
     * ```typescript
     * let valid = this.igxInput.isValid;
     * ```
     */
    get isValid() {
        return this.valid !== IgxInputState.INVALID;
    }
    /**
     * A function to assign a native validity property of an input.
     * This should be used when there's no ngControl
     *
     * @hidden
     * @internal
     */
    checkNativeValidity() {
        if (!this.disabled && this._hasValidators()) {
            this._valid = this.nativeElement.checkValidity() ?
                this.focused ? IgxInputState.VALID : IgxInputState.INITIAL :
                IgxInputState.INVALID;
        }
    }
    /**
     * Returns the input type.
     *
     * @hidden
     * @internal
     */
    get type() {
        return this.nativeElement.type;
    }
}
IgxInputDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxInput]',
                exportAs: 'igxInput',
            },] }
];
IgxInputDirective.ctorParameters = () => [
    { type: IgxInputGroupBase },
    { type: NgModel, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NgModel,] }] },
    { type: FormControlName, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [FormControlName,] }] },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxInputDirective.propDecorators = {
    isInput: [{ type: HostBinding, args: ['class.igx-input-group__input',] }],
    isTextArea: [{ type: HostBinding, args: ['class.igx-input-group__textarea',] }],
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    required: [{ type: Input }],
    onFocus: [{ type: HostListener, args: ['focus',] }],
    onBlur: [{ type: HostListener, args: ['blur',] }],
    onInput: [{ type: HostListener, args: ['input',] }],
    change: [{ type: HostListener, args: ['change', ['$event'],] }]
};

let NEXT_ID$3 = 0;
class IgxLabelDirective {
    constructor() {
        this.defaultClass = true;
        /**
         * @hidden
         */
        this.id = `igx-label-${NEXT_ID$3++}`;
    }
}
IgxLabelDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxLabel]'
            },] }
];
IgxLabelDirective.propDecorators = {
    defaultClass: [{ type: HostBinding, args: ['class.igx-input-group__label',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }]
};

/**
 * The Button directive provides the Ignite UI Button functionality to every component that's intended to be used as a button.
 *
 * @igxModule IgxButtonModule
 *
 * @igxParent Data Entry & Display
 *
 * @igxTheme igx-button-theme
 *
 * @igxKeywords button, span, div, click
 *
 * @remarks
 * The Ignite UI Button directive is intended to be used by any button, span or div and turn it into a fully functional button.
 *
 * @example
 * ```html
 * <button igxButton="outlined">A Button</button>
 * ```
 */
class IgxButtonDirective extends DisplayDensityBase {
    constructor(element, _renderer, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.element = element;
        this._renderer = _renderer;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * Gets or sets whether the button is selected.
         * Mainly used in the IgxButtonGroup component and it will have no effect if set separately.
         *
         * @example
         * ```html
         * <button igxButton="flat" [selected]="button.selected"></button>
         * ```
         */
        this.selected = false;
        /**
         * Called when the button is clicked.
         */
        this.buttonClick = new EventEmitter();
        /**
         * Sets/gets the `role` attribute.
         *
         * @example
         * ```typescript
         * this.button.role = 'navbutton';
         * let buttonRole = this.button.role;
         * ```
         */
        this.role = 'button';
        /**
         * @hidden
         * @internal
         */
        this._defaultType = 'flat';
        /**
         * @hidden
         * @internal
         */
        this._cssClassPrefix = 'igx-button';
    }
    /**
     * Returns the underlying DOM element.
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * Sets the type of the button.
     *
     * @example
     * ```html
     * <button igxButton="icon"></button>
     * ```
     */
    set type(value) {
        const newValue = value ? value : this._defaultType;
        if (this._type !== newValue) {
            this._renderer.removeClass(this.nativeElement, `${this._cssClassPrefix}--${this._type}`);
            this._type = newValue;
            this._renderer.addClass(this.nativeElement, `${this._cssClassPrefix}--${this._type}`);
        }
    }
    /**
     * Sets the button text color.
     *
     * @example
     * ```html
     * <button igxButton="gradient" igxButtonColor="blue"></button>
     * ```
     */
    set color(value) {
        this._color = value || this.nativeElement.style.color;
        this._renderer.setStyle(this.nativeElement, 'color', this._color);
    }
    /**
     * Sets the background color of the button.
     *
     * @example
     *  ```html
     * <button igxButton="raised" igxButtonBackground="red"></button>
     * ```
     */
    set background(value) {
        this._backgroundColor = value || this._backgroundColor;
        this._renderer.setStyle(this.nativeElement, 'background', this._backgroundColor);
    }
    /**
     * Sets the `aria-label` attribute.
     *
     * @example
     *  ```html
     * <button igxButton= "flat" igxLabel="Label"></button>
     * ```
     */
    set label(value) {
        this._label = value || this._label;
        this._renderer.setAttribute(this.nativeElement, `aria-label`, this._label);
    }
    /**
     * Enables/disables the button.
     *
     * @example
     * ```html
     * <button igxButton= "fab" [disabled]="true"></button>
     * ```
     */
    set disabled(val) {
        val = !!val;
        this._disabled = val;
        if (val) {
            this._renderer.addClass(this.nativeElement, `${this._cssClassPrefix}--disabled`);
        }
        else {
            this._renderer.removeClass(this.nativeElement, `${this._cssClassPrefix}--disabled`);
        }
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCosy() {
        return (this._type === 'flat' || this._type === 'raised') &&
            this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCompact() {
        return (this._type === 'flat' || this._type === 'raised') &&
            this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCosyOutlined() {
        return this._type === 'outlined' && this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCompactOutlined() {
        return this._type === 'outlined' && this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCosyFab() {
        return this._type === 'fab' && this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCompactFab() {
        return this._type === 'fab' && this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @hidden
     * @internal
     */
    get disabledAttribute() {
        return this._disabled ? this._disabled : null;
    }
    /**
     * @hidden
     * @internal
     */
    onClick(ev) {
        this.buttonClick.emit(ev);
    }
}
IgxButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxButton]'
            },] }
];
IgxButtonDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxButtonDirective.propDecorators = {
    selected: [{ type: Input }],
    buttonClick: [{ type: Output }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    type: [{ type: Input, args: ['igxButton',] }],
    color: [{ type: Input, args: ['igxButtonColor',] }],
    background: [{ type: Input, args: ['igxButtonBackground',] }],
    label: [{ type: Input, args: ['igxLabel',] }],
    disabled: [{ type: Input }],
    cssClassCosy: [{ type: HostBinding, args: ['class.igx-button--cosy',] }],
    cssClassCompact: [{ type: HostBinding, args: ['class.igx-button--compact',] }],
    cssClassCosyOutlined: [{ type: HostBinding, args: ['class.igx-button--outlined-cosy',] }],
    cssClassCompactOutlined: [{ type: HostBinding, args: ['class.igx-button--outlined-compact',] }],
    cssClassCosyFab: [{ type: HostBinding, args: ['class.igx-button--fab-cosy',] }],
    cssClassCompactFab: [{ type: HostBinding, args: ['class.igx-button--fab-compact',] }],
    disabledAttribute: [{ type: HostBinding, args: ['attr.disabled',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxButtonModule {
}
IgxButtonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxButtonDirective],
                exports: [IgxButtonDirective]
            },] }
];

/**
 * **Ignite UI for Angular Icon Service** -
 *
 * The Ignite UI Icon Service makes it easy for developers to include custom SVG images and use them with IgxIconComponent.
 * In addition it could be used to associate a custom class to be applied on IgxIconComponent according to given font-family.
 *
 * Example:
 * ```typescript
 * this.iconService.registerFamilyAlias('material', 'material-icons');
 * this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
 * ```
 */
class IgxIconService {
    constructor(_sanitizer, _document) {
        this._sanitizer = _sanitizer;
        this._document = _document;
        this._family = 'material-icons';
        this._familyAliases = new Map();
        this._cachedSvgIcons = new Set();
        this._iconLoaded = new Subject();
        this.iconLoaded = this._iconLoaded.asObservable();
    }
    /**
     *  Returns the default font-family.
     * ```typescript
     *   const defaultFamily = this.iconService.defaultFamily;
     * ```
     */
    get defaultFamily() {
        return this._family;
    }
    /**
     *  Sets the default font-family.
     * ```typescript
     *   this.iconService.defaultFamily = 'svg-flags';
     * ```
     */
    set defaultFamily(className) {
        this._family = className;
    }
    /**
     *  Registers a custom class to be applied to IgxIconComponent for a given font-family.
     * ```typescript
     *   this.iconService.registerFamilyAlias('material', 'material-icons');
     * ```
     */
    registerFamilyAlias(alias, className = alias) {
        this._familyAliases.set(alias, className);
        return this;
    }
    /**
     *  Returns the custom class, if any, associated to a given font-family.
     * ```typescript
     *   const familyClass = this.iconService.familyClassName('material');
     * ```
     */
    familyClassName(alias) {
        return this._familyAliases.get(alias) || alias;
    }
    /**
     *  Adds an SVG image to the cache. SVG source is an url.
     * ```typescript
     *   this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
     * ```
     */
    addSvgIcon(name, url, family = '') {
        if (name && url) {
            const safeUrl = this._sanitizer.bypassSecurityTrustResourceUrl(url);
            if (!safeUrl) {
                throw new Error(`The provided URL could not be processed as trusted resource URL by Angular's DomSanitizer: "${url}".`);
            }
            const sanitizedUrl = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);
            if (!sanitizedUrl) {
                throw new Error(`The URL provided was not trusted as a resource URL: "${url}".`);
            }
            this.fetchSvg(name, url, family);
        }
        else {
            throw new Error('You should provide at least `name` and `url` to register an svg icon.');
        }
    }
    /**
     *  Adds an SVG image to the cache. SVG source is its text.
     * ```typescript
     *   this.iconService.addSvgIcon('simple', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
     *   <path d="M74 74h54v54H74" /></svg>', 'svg-flags');
     * ```
     */
    addSvgIconFromText(name, iconText, family = '') {
        if (name && iconText) {
            this.cacheSvgIcon(name, iconText, family);
        }
        else {
            throw new Error('You should provide at least `name` and `iconText` to register an svg icon.');
        }
    }
    /**
     *  Returns whether a given SVG image is present in the cache.
     * ```typescript
     *   const isSvgCached = this.iconService.isSvgIconCached('aruba', 'svg-flags');
     * ```
     */
    isSvgIconCached(name, family = '') {
        const iconKey = this.getSvgIconKey(name, family);
        return this._cachedSvgIcons.has(iconKey);
    }
    /**
     *  Returns the key of a cached SVG image.
     * ```typescript
     *   const svgIconKey = this.iconService.getSvgIconKey('aruba', 'svg-flags');
     * ```
     */
    getSvgIconKey(name, family = '') {
        return family + '_' + name;
    }
    /**
     * @hidden
     */
    fetchSvg(name, url, family = '') {
        const instance = this;
        const httpRequest = new XMLHttpRequest();
        httpRequest.open('GET', url, true);
        httpRequest.responseType = 'text';
        // load – when the result is ready, that includes HTTP errors like 404.
        httpRequest.onload = (event) => {
            if (event) {
                const request = event.target;
                if (request.status === 200) {
                    instance.cacheSvgIcon(name, request.responseText, family);
                    instance._iconLoaded.next({ name, value: request.responseText, family });
                }
                else {
                    throw new Error(`Could not fetch SVG from url: ${url}; error: ${request.status} (${request.statusText})`);
                }
            }
            else {
                throw new Error(`Could not fetch SVG from url: ${url};`);
            }
        };
        // error – when the request couldn’t be made, e.g.network down or invalid URL.
        httpRequest.onerror = (event) => {
            if (event) {
                const request = event.target;
                throw new Error(`Could not fetch SVG from url: ${url}; error status code: ${request.status} (${request.statusText})`);
            }
            throw new Error(`Could not fetch SVG from url: ${url};`);
        };
        httpRequest.send();
    }
    /**
     * @hidden
     */
    cacheSvgIcon(name, value, family = '') {
        if (name && value) {
            this.ensureSvgContainerCreated();
            const div = this._document.createElement('DIV');
            div.innerHTML = value;
            const svg = div.querySelector('svg');
            if (svg) {
                const iconKey = this.getSvgIconKey(name, family);
                svg.setAttribute('id', iconKey);
                svg.setAttribute('fit', '');
                svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
                if (this._cachedSvgIcons.has(iconKey)) {
                    const oldChild = this._svgContainer.querySelector(`svg[id='${iconKey}']`);
                    this._svgContainer.removeChild(oldChild);
                }
                this._svgContainer.appendChild(svg);
                this._cachedSvgIcons.add(iconKey);
            }
        }
    }
    /**
     * @hidden
     */
    ensureSvgContainerCreated() {
        if (!this._svgContainer) {
            this._svgContainer = this._document.documentElement.querySelector('.igx-svg-container');
            if (!this._svgContainer) {
                this._svgContainer = this._document.createElement('DIV');
                this._svgContainer.classList.add('igx-svg-container');
                this._document.documentElement.appendChild(this._svgContainer);
            }
        }
    }
}
IgxIconService.ɵprov = ɵɵdefineInjectable({ factory: function IgxIconService_Factory() { return new IgxIconService(ɵɵinject(DomSanitizer), ɵɵinject(DOCUMENT)); }, token: IgxIconService, providedIn: "root" });
IgxIconService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
IgxIconService.ctorParameters = () => [
    { type: DomSanitizer },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];

/**
 * Icon provides a way to include material icons to markup
 *
 * @igxModule IgxIconModule
 *
 * @igxTheme igx-icon-theme
 *
 * @igxKeywords icon, picture
 *
 * @igxGroup Display
 *
 * @remarks
 *
 * The Ignite UI Icon makes it easy for developers to include material design icons directly in their markup. The icons
 * support different icon families and can be marked as active or disabled using the `active` property. This will change the appearance
 * of the icon.
 *
 * @example
 * ```html
 * <igx-icon family="filter-icons" active="true">home</igx-icon>
 * ```
 */
class IgxIconComponent {
    constructor(el, iconService, ref) {
        this.el = el;
        this.iconService = iconService;
        this.ref = ref;
        /**
         *  This allows you to change the value of `class.igx-icon`. By default it's `igx-icon`.
         *
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-icon';
        /**
         *  This allows you to disable the `aria-hidden` attribute. By default it's applied.
         *
         * @example
         * ```typescript
         * @ViewChild("MyIcon") public icon: IgxIconComponent;
         * constructor(private cdRef:ChangeDetectorRef) {}
         * ngAfterViewInit() {
         *     this.icon.ariaHidden = false;
         *     this.cdRef.detectChanges();
         * }
         * ```
         */
        this.ariaHidden = true;
        /**
         * An @Input property that allows you to disable the `active` property. By default it's applied.
         *
         * @example
         * ```html
         * <igx-icon [active]="false">settings</igx-icon>
         * ```
         */
        this.active = true;
        this.destroy$ = new Subject();
        this.family = this.iconService.defaultFamily;
        this.iconService.registerFamilyAlias('material', 'material-icons');
        this.iconService.iconLoaded.pipe(first$1(e => e.name === this.name && e.family === this.family), takeUntil(this.destroy$))
            .subscribe(() => this.ref.detectChanges());
    }
    /**
     * @hidden
     * @internal
     */
    ngOnInit() {
        this.updateIconClass();
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     *  An accessor that returns the value of the family property.
     *
     * @example
     * ```typescript
     *  @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconFamily = this.icon.getFamily;
     * }
     * ```
     */
    get getFamily() {
        return this.family;
    }
    /**
     *  An accessor that returns the value of the active property.
     *
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconActive = this.icon.getActive;
     * }
     * ```
     */
    get getActive() {
        return this.active;
    }
    /**
     *  An accessor that returns inactive property.
     *
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconActive = this.icon.getInactive;
     * }
     * ```
     */
    get getInactive() {
        return !this.active;
    }
    /**
     * An accessor that returns the opposite value of the `color` property.
     *
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let color = this.icon.getColor;
     * }
     * ```
     */
    get getColor() {
        return this.color;
    }
    /**
     * An accessor that returns the value of the iconName property.
     *
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let name = this.icon.getName;
     * }
     * ```
     */
    get getName() {
        return this.name;
    }
    /**
     *  An accessor that returns the key of the SVG image.
     *  The key consists of the font-family and the name separated by underscore.
     *
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let svgKey = this.icon.getSvgKey;
     * }
     * ```
     */
    get getSvgKey() {
        if (this.iconService.isSvgIconCached(this.name, this.family)) {
            return '#' + this.iconService.getSvgIconKey(this.name, this.family);
        }
        return null;
    }
    /**
     *   An accessor that returns a TemplateRef to explicit, svg or no ligature.
     *
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconTemplate = this.icon.template;
     * }
     * ```
     */
    get template() {
        if (this.name) {
            if (this.iconService.isSvgIconCached(this.name, this.family)) {
                return this.svgImage;
            }
            return this.noLigature;
        }
        return this.explicitLigature;
    }
    /**
     * @hidden
     * @internal
     */
    updateIconClass() {
        const className = this.iconService.familyClassName(this.family);
        this.el.nativeElement.classList.add(className);
        if (this.name && !this.iconService.isSvgIconCached(this.name, this.family)) {
            this.el.nativeElement.classList.add(this.name);
        }
    }
}
IgxIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-icon',
                template: "<ng-template #noLigature></ng-template>\n\n<ng-template #explicitLigature>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #svgImage>\n    <svg>\n        <use [attr.href]=\"getSvgKey\"></use>\n    </svg>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
            },] }
];
IgxIconComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxIconService },
    { type: ChangeDetectorRef }
];
IgxIconComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-icon',] }],
    ariaHidden: [{ type: HostBinding, args: ['attr.aria-hidden',] }],
    family: [{ type: Input, args: ['family',] }],
    active: [{ type: Input, args: ['active',] }],
    color: [{ type: Input, args: ['color',] }],
    name: [{ type: Input, args: ['name',] }],
    noLigature: [{ type: ViewChild, args: ['noLigature', { read: TemplateRef, static: true },] }],
    explicitLigature: [{ type: ViewChild, args: ['explicitLigature', { read: TemplateRef, static: true },] }],
    svgImage: [{ type: ViewChild, args: ['svgImage', { read: TemplateRef, static: true },] }],
    getInactive: [{ type: HostBinding, args: ['class.igx-icon--inactive',] }],
    getColor: [{ type: HostBinding, args: ['style.color',] }]
};
__decorate([
    DeprecateProperty('`color` is deprecated.')
], IgxIconComponent.prototype, "color", void 0);

/**
 * @hidden
 */
class IgxIconModule {
}
IgxIconModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxIconComponent],
                exports: [IgxIconComponent],
                imports: [CommonModule]
            },] }
];

/**
 * @hidden
 */
class IgxPrefixDirective {
}
IgxPrefixDirective.decorators = [
    { type: Directive, args: [{
                selector: 'igx-prefix,[igxPrefix]'
            },] }
];
/**
 * @hidden
 */
class IgxPrefixModule {
}
IgxPrefixModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxPrefixDirective],
                exports: [IgxPrefixDirective]
            },] }
];

/**
 * @hidden
 */
class IgxSuffixDirective {
}
IgxSuffixDirective.decorators = [
    { type: Directive, args: [{
                selector: 'igx-suffix,[igxSuffix]'
            },] }
];
/**
 * @hidden
 */
class IgxSuffixModule {
}
IgxSuffixModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxSuffixDirective],
                exports: [IgxSuffixDirective]
            },] }
];

const IgxInputGroupEnum = mkenum({
    Line: 'line',
    Box: 'box',
    Border: 'border',
    Search: 'search'
});
/**
 * Defines the InputGroupType DI token.
 */
// Should this go trough Interface https://angular.io/api/core/InjectionToken
const IGX_INPUT_GROUP_TYPE = new InjectionToken('InputGroupType');

const DateRangePickerResourceStringsEN = {
    igx_date_range_picker_date_separator: 'to'
};

const GridResourceStringsEN = {
    igx_grid_groupByArea_message: 'Drag a column header and drop it here to group by that column.',
    igx_grid_groupByArea_select_message: 'Select all rows in the group with field name {0} and value {1}.',
    igx_grid_groupByArea_deselect_message: 'Deselect all rows in the group with field name {0} and value {1}.',
    igx_grid_emptyFilteredGrid_message: 'No records found.',
    igx_grid_emptyGrid_message: 'Grid has no data.',
    igx_grid_filter: 'Filter',
    igx_grid_filter_row_close: 'Close',
    igx_grid_filter_row_reset: 'Reset',
    igx_grid_filter_row_placeholder: 'Add filter value',
    igx_grid_filter_row_boolean_placeholder: 'All',
    igx_grid_filter_row_date_placeholder: 'Pick up date',
    igx_grid_filter_operator_and: 'And',
    igx_grid_filter_operator_or: 'Or',
    igx_grid_complex_filter: 'Complex Filter',
    igx_grid_filter_contains: 'Contains',
    igx_grid_filter_doesNotContain: 'Does Not Contain',
    igx_grid_filter_startsWith: 'Starts With',
    igx_grid_filter_endsWith: 'Ends With',
    igx_grid_filter_equals: 'Equals',
    igx_grid_filter_doesNotEqual: 'Does Not Equal',
    igx_grid_filter_empty: 'Empty',
    igx_grid_filter_notEmpty: 'Not Empty',
    igx_grid_filter_null: 'Null',
    igx_grid_filter_notNull: 'Not Null',
    igx_grid_filter_before: 'Before',
    igx_grid_filter_after: 'After',
    igx_grid_filter_today: 'Today',
    igx_grid_filter_yesterday: 'Yesterday',
    igx_grid_filter_thisMonth: 'This Month',
    igx_grid_filter_lastMonth: 'Last Month',
    igx_grid_filter_nextMonth: 'Next Month',
    igx_grid_filter_thisYear: 'This Year',
    igx_grid_filter_lastYear: 'Last Year',
    igx_grid_filter_nextYear: 'Next Year',
    igx_grid_filter_greaterThan: 'Greater Than',
    igx_grid_filter_lessThan: 'Less Than',
    igx_grid_filter_greaterThanOrEqualTo: 'Greater Than Or Equal To',
    igx_grid_filter_lessThanOrEqualTo: 'Less Than Or Equal To',
    igx_grid_filter_true: 'True',
    igx_grid_filter_false: 'False',
    igx_grid_filter_all: 'All',
    igx_grid_filter_condition_placeholder: 'Select filter',
    igx_grid_summary_count: 'Count',
    igx_grid_summary_min: 'Min',
    igx_grid_summary_max: 'Max',
    igx_grid_summary_sum: 'Sum',
    igx_grid_summary_average: 'Avg',
    igx_grid_summary_earliest: 'Earliest',
    igx_grid_summary_latest: 'Latest',
    igx_grid_excel_filter_moving_left: 'move left',
    igx_grid_excel_filter_moving_left_short: 'left',
    igx_grid_excel_filter_moving_right: 'move right',
    igx_grid_excel_filter_moving_right_short: 'right',
    igx_grid_excel_filter_moving_header: 'move',
    igx_grid_excel_filter_sorting_asc: 'ascending',
    igx_grid_excel_filter_sorting_asc_short: 'asc',
    igx_grid_excel_filter_sorting_desc: 'descending',
    igx_grid_excel_filter_sorting_desc_short: 'desc',
    igx_grid_excel_filter_sorting_header: 'sort',
    igx_grid_excel_filter_clear: 'Clear column filters',
    igx_grid_excel_custom_dialog_add: 'add filter',
    igx_grid_excel_custom_dialog_clear: 'Clear filter',
    igx_grid_excel_custom_dialog_header: 'Custom auto-filter on column: ',
    igx_grid_excel_cancel: 'cancel',
    igx_grid_excel_apply: 'apply',
    igx_grid_excel_search_placeholder: 'Search',
    igx_grid_excel_select_all: 'Select All',
    igx_grid_excel_select_all_search_results: 'Select all search results',
    igx_grid_excel_add_to_filter: 'Add current selection to filter',
    igx_grid_excel_blanks: '(Blanks)',
    igx_grid_excel_hide: 'Hide column',
    igx_grid_excel_show: 'Show column',
    igx_grid_excel_pin: 'Pin column',
    igx_grid_excel_unpin: 'Unpin column',
    igx_grid_excel_select: 'Select column',
    igx_grid_excel_text_filter: 'Text filter',
    igx_grid_excel_number_filter: 'Number filter',
    igx_grid_excel_date_filter: 'Date filter',
    igx_grid_excel_boolean_filter: 'Boolean filter',
    igx_grid_excel_currency_filter: 'Currency filter',
    igx_grid_excel_custom_filter: 'Custom filter...',
    igx_grid_advanced_filter_title: 'Advanced Filtering',
    igx_grid_advanced_filter_and_group: '"And" Group',
    igx_grid_advanced_filter_or_group: '"Or" Group',
    igx_grid_advanced_filter_end_group: 'End Group',
    igx_grid_advanced_filter_create_and_group: 'Create "And" Group',
    igx_grid_advanced_filter_create_or_group: 'Create "Or" Group',
    igx_grid_advanced_filter_and_label: 'and',
    igx_grid_advanced_filter_or_label: 'or',
    igx_grid_advanced_filter_add_condition: 'Condition',
    igx_grid_advanced_filter_ungroup: 'Ungroup',
    igx_grid_advanced_filter_delete: 'Delete',
    igx_grid_advanced_filter_delete_filters: 'Delete filters',
    igx_grid_advanced_filter_initial_text: 'Start with creating a group of conditions linked with "And" or "Or"',
    igx_grid_advanced_filter_column_placeholder: 'Select column',
    igx_grid_advanced_filter_value_placeholder: 'Value',
    igx_grid_pinned_row_indicator: 'Pinned',
    igx_grid_hiding_check_all_label: 'Show All',
    igx_grid_hiding_uncheck_all_label: 'Hide All',
    igx_grid_pinning_check_all_label: 'Pin All',
    igx_grid_pinning_uncheck_all_label: 'Unpin All',
    igx_grid_toolbar_actions_filter_prompt: 'Filter columns list ...',
    igx_grid_toolbar_pinning_button_tooltip: 'Open column pinning dropdown',
    igx_grid_toolbar_hiding_button_tooltip: 'Open column hiding dropdown',
    igx_grid_toolbar_pinning_title: 'Pinned columns',
    igx_grid_toolbar_hiding_title: 'Visible columns',
    igx_grid_toolbar_advanced_filtering_button_tooltip: 'Open advanced filtering dialog',
    igx_grid_toolbar_advanced_filtering_button_label: 'Advanced filtering',
    igx_grid_toolbar_exporter_button_tooltip: 'Open exporter dropdown',
    igx_grid_toolbar_exporter_button_label: 'Export',
    igx_grid_toolbar_exporter_excel_entry_text: 'Export to Excel',
    igx_grid_toolbar_exporter_csv_entry_text: 'Export to CSV',
    igx_grid_snackbar_addrow_label: 'Row added',
    igx_grid_snackbar_addrow_actiontext: 'SHOW',
    igx_grid_actions_edit_label: 'Edit',
    igx_grid_actions_add_label: 'Add',
    igx_grid_add_row_label: 'ADD ROW',
    igx_grid_actions_add_child_label: 'Add Child',
    igx_grid_actions_delete_label: 'Delete',
    igx_grid_actions_pin_label: 'Pin',
    igx_grid_actions_unpin_label: 'Unpin',
    igx_grid_actions_jumpUp_label: 'Jump up',
    igx_grid_actions_jumpDown_label: 'Jump down'
};

const TimePickerResourceStringsEN = {
    igx_time_picker_ok: 'OK',
    igx_time_picker_cancel: 'Cancel'
};

const PaginatorResourceStringsEN = {
    igx_paginator_label: 'Items per page',
    igx_paginator_pager_text: 'of',
    igx_paginator_first_page_button_text: 'Go to first page',
    igx_paginator_previous_page_button_text: 'Previous page',
    igx_paginator_last_page_button_text: 'Go to last page',
    igx_paginator_next_page_button_text: 'Next page',
};

const CarouselResourceStringsEN = {
    igx_carousel_of: 'of',
    igx_carousel_slide: 'slide',
    igx_carousel_previous_slide: 'previous slide',
    igx_carousel_next_slide: 'next slide'
};

const ListResourceStringsEN = {
    igx_list_no_items: 'There are no items in the list.',
    igx_list_loading: 'Loading data from the server...'
};

const CalendarResourceStringsEN = {
    igx_calendar_previous_month: 'Previous Month',
    igx_calendar_next_month: 'Next Month',
    igx_calendar_select_month: 'Select Month',
    igx_calendar_select_year: 'Select Year',
    igx_calendar_range_start: 'Range start',
    igx_calendar_range_end: 'Range end',
    igx_calendar_selected_month_is: 'Selected month is ',
    igx_calendar_first_picker_of: 'First picker of {0} starts from',
    igx_calendar_multi_selection: 'Multi selection calendar with {0} date pickers',
    igx_calendar_range_selection: 'Range selection calendar with {0} date pickers',
    igx_calendar_single_selection: 'Calendar with {0} date pickers',
    igx_calendar_singular_multi_selection: 'Multi selection calendar',
    igx_calendar_singular_range_selection: 'Range selection calendar',
    igx_calendar_singular_single_selection: 'Calendar',
};

const InputResourceStringsEN = {
    igx_input_upload_button: 'Upload File',
    igx_input_clear_button: 'clear',
    igx_input_file_placeholder: 'No file chosen',
};

/**
 * @hidden
 */
const CurrentResourceStrings = {
    GridResStrings: cloneValue(GridResourceStringsEN),
    PaginatorResStrings: cloneValue(PaginatorResourceStringsEN),
    TimePickerResStrings: cloneValue(TimePickerResourceStringsEN),
    CalendarResStrings: cloneValue(CalendarResourceStringsEN),
    DateRangePickerResStrings: cloneValue(DateRangePickerResourceStringsEN),
    CarouselResStrings: cloneValue(CarouselResourceStringsEN),
    ListResStrings: cloneValue(ListResourceStringsEN),
    InputResStrings: cloneValue(InputResourceStringsEN),
};
const updateResourceStrings = (currentStrings, newStrings) => {
    for (const key of Object.keys(newStrings)) {
        if (key in currentStrings) {
            currentStrings[key] = newStrings[key];
        }
    }
};
const ɵ0$2 = updateResourceStrings;
/**
 * Changes the resource strings for all components in the application
 * ```
 * @param resourceStrings to be applied
 */
const changei18n = (resourceStrings) => {
    for (const key of Object.keys(CurrentResourceStrings)) {
        updateResourceStrings(CurrentResourceStrings[key], resourceStrings);
    }
};
/**
 * Returns current resource strings for all components
 */
const getCurrentResourceStrings = () => (Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, CurrentResourceStrings.CalendarResStrings), CurrentResourceStrings.CarouselResStrings), CurrentResourceStrings.DateRangePickerResStrings), CurrentResourceStrings.GridResStrings), CurrentResourceStrings.InputResStrings), CurrentResourceStrings.ListResStrings), CurrentResourceStrings.PaginatorResStrings), CurrentResourceStrings.TimePickerResStrings));

const IgxInputGroupTheme = mkenum({
    Material: 'material',
    Fluent: 'fluent',
    Bootstrap: 'bootstrap',
    IndigoDesign: 'indigo-design'
});
class IgxInputGroupComponent extends DisplayDensityBase {
    constructor(element, _displayDensityOptions, _inputGroupType, document, renderer) {
        super(_displayDensityOptions);
        this.element = element;
        this._inputGroupType = _inputGroupType;
        this.document = document;
        this.renderer = renderer;
        /**
         * Property that enables/disables the autogenerated class of the `IgxInputGroupComponent`.
         * By default applied the class is applied.
         * ```typescript
         *  @ViewChild("MyInputGroup")
         *  public inputGroup: IgxInputGroupComponent;
         *  ngAfterViewInit(){
         *  this.inputGroup.defaultClass = false;
         * ```
         * }
         */
        this.defaultClass = true;
        /** @hidden */
        this.hasPlaceholder = false;
        /** @hidden */
        this.isRequired = false;
        /** @hidden */
        this.isFocused = false;
        /**
         * An @Input property that disables the `IgxInputGroupComponent`.
         * ```html
         * <igx-input-group [disabled]="'true'"></igx-input-group>
         * ```
         */
        this.disabled = false;
        /**
         * Prevents automatically focusing the input when clicking on other elements in the input group (e.g. prefix or suffix).
         *
         * @remarks Automatic focus causes software keyboard to show on mobile devices.
         *
         * @example
         * ```html
         * <igx-input-group [suppressInputAutofocus]="true"></igx-input-group>
         * ```
         */
        this.suppressInputAutofocus = false;
        /** @hidden */
        this.hasWarning = false;
        this._type = null;
        this._filled = false;
        this._resourceStrings = CurrentResourceStrings.InputResStrings;
    }
    /**
     * Sets the resource strings.
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * Returns the resource strings.
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /** @hidden */
    get validClass() {
        return this.input.valid === IgxInputState.VALID;
    }
    /** @hidden */
    get invalidClass() {
        return this.input.valid === IgxInputState.INVALID;
    }
    /** @hidden */
    get isFilled() {
        return this._filled || (this.input && this.input.value);
    }
    /** @hidden */
    get isDisplayDensityCosy() {
        return this.displayDensity === DisplayDensity.cosy;
    }
    /** @hidden */
    get isDisplayDensityComfortable() {
        return this.displayDensity === DisplayDensity.comfortable;
    }
    /** @hidden */
    get isDisplayDensityCompact() {
        return this.displayDensity === DisplayDensity.compact;
    }
    /**
     * An @Input property that sets how the input will be styled.
     * Allowed values of type IgxInputGroupType.
     * ```html
     * <igx-input-group [type]="'search'">
     * ```
     */
    set type(value) {
        this._type = value;
    }
    /**
     * Returns the type of the `IgxInputGroupComponent`. How the input is styled.
     * The default is `line`.
     * ```typescript
     * @ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let inputType = this.inputGroup.type;
     * }
     * ```
     */
    get type() {
        return this._type || this._inputGroupType || 'line';
    }
    /**
     * Sets the theme of the input.
     * Allowed values of type IgxInputGroupTheme.
     * ```typescript
     * @ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit() {
     *  let inputTheme = 'fluent';
     * }
     */
    set theme(variant) {
        this._variant = variant;
    }
    /**
     * Returns the theme of the input.
     * The returned value is of tyep IgxInputGroupType.
     * ```typescript
     * @ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit() {
     *  let inputTheme = this.inputGroup.theme;
     * }
     */
    get theme() {
        return this._variant;
    }
    /** @hidden */
    onClick(event) {
        if (!this.isFocused &&
            event.target !== this.input.nativeElement &&
            !this.suppressInputAutofocus) {
            this.input.focus();
        }
    }
    /** @hidden */
    onPointerDown(event) {
        if (this.isFocused && event.target !== this.input.nativeElement) {
            event.preventDefault();
        }
    }
    /** @hidden @internal */
    hintClickHandler(event) {
        event.stopPropagation();
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        if (!this.theme) {
            if (isIE()) {
                this._variant = IgxInputGroupTheme.Material;
            }
            else {
                this._variant = this.document.defaultView
                    .getComputedStyle(this.element.nativeElement)
                    .getPropertyValue('--igx-input-group-variant')
                    .trim();
            }
        }
    }
    /**
     * Returns whether the `IgxInputGroupComponent` has hints.
     * ```typescript
     * @ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let inputHints = this.inputGroup.hasHints;
     * }
     * ```
     */
    get hasHints() {
        return this.hints.length > 0;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` has border.
     * ```typescript
     * @ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let inputBorder = this.inputGroup.hasBorder;
     * }
     * ```
     */
    get hasBorder() {
        return ((this.type === 'line' || this.type === 'box') &&
            this._variant === 'material');
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is line.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeLine = this.inputGroup.isTypeLine;
     * }
     * ```
     */
    get isTypeLine() {
        return this.type === 'line' && this._variant === 'material';
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is box.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeBox = this.inputGroup.isTypeBox;
     * }
     * ```
     */
    get isTypeBox() {
        return this.type === 'box' && this._variant === 'material';
    }
    /** @hidden @internal */
    uploadButtonHandler() {
        this.input.nativeElement.click();
    }
    /** @hidden @internal */
    clearValueHandler() {
        this.input.clear();
    }
    /** @hidden @internal */
    get isFileType() {
        return this.input.type === 'file';
    }
    /** @hidden @internal */
    get fileNames() {
        return this.input.fileNames || this._resourceStrings.igx_input_file_placeholder;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is border.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeBorder = this.inputGroup.isTypeBorder;
     * }
     * ```
     */
    get isTypeBorder() {
        return this.type === 'border' && this._variant === 'material';
    }
    /**
     * Returns true if the `IgxInputGroupComponent` theme is Fluent.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeFluent = this.inputGroup.isTypeFluent;
     * }
     * ```
     */
    get isTypeFluent() {
        return this._variant === 'fluent';
    }
    /**
     * Returns true if the `IgxInputGroupComponent` theme is Bootstrap.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeBootstrap = this.inputGroup.isTypeBootstrap;
     * }
     * ```
     */
    get isTypeBootstrap() {
        return this._variant === 'bootstrap';
    }
    /**
     * Returns true if the `IgxInputGroupComponent` theme is Indigo.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeIndigo = this.inputGroup.isTypeIndigo;
     * }
     * ```
     */
    get isTypeIndigo() {
        return this._variant === 'indigo-design';
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is search.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeSearch = this.inputGroup.isTypeSearch;
     * }
     * ```
     */
    get isTypeSearch() {
        return this.type === 'search';
    }
    /** @hidden */
    get filled() {
        return this._filled;
    }
    /** @hidden */
    set filled(val) {
        this._filled = val;
    }
}
IgxInputGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-input-group',
                template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n\n<div class=\"igx-input-group__hint\" (click)=\"hintClickHandler($event)\">\n    <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n</div>\n\n<ng-template #label>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #input>\n    <ng-content select=\"[igxInput]\"></ng-content>\n</ng-template>\n\n<ng-template #prefix>\n    <ng-content select=\"igx-prefix, [igxPrefix]\"></ng-content>\n</ng-template>\n\n<ng-template #uploadButton>\n    <igx-prefix *ngIf=\"isFileType\">\n        <button\n            igxButton=\"raised\"\n            (click)=\"uploadButtonHandler()\"\n            [displayDensity]=\"displayDensity\"\n            [disabled]=\"disabled\"\n            [ngClass]=\"{ 'igx-input-group__upload-button': isTypeLine }\"\n        >\n            {{ resourceStrings.igx_input_upload_button }}\n        </button>\n    </igx-prefix>\n</ng-template>\n\n<ng-template #files>\n    <div\n        *ngIf=\"isFileType\"\n        class=\"igx-input-group__file-input\"\n        [title]=\"fileNames\"\n    >\n        <span>{{ fileNames }}</span>\n    </div>\n</ng-template>\n\n<ng-template #clear>\n    <igx-suffix\n        class=\"igx-input-group__clear-icon\"\n        *ngIf=\"isFileType && isFilled\"\n        (click)=\"clearValueHandler()\"\n        (keydown.Enter)=\"clearValueHandler()\"\n        title=\"clear files\"\n        tabindex=\"0\"\n    >\n        <igx-icon>{{ resourceStrings.igx_input_clear_button }}</igx-icon>\n    </igx-suffix>\n</ng-template>\n\n<ng-template #suffix>\n    <ng-content select=\"igx-suffix, [igxSuffix]\"></ng-content>\n</ng-template>\n\n<ng-template #materialBundle>\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #fluentBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bootstrapBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bundle>\n    <ng-container [ngSwitch]=\"theme\">\n        <ng-container *ngSwitchCase=\"'bootstrap'\">\n            <ng-container *ngTemplateOutlet=\"bootstrapBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'fluent'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'indigo-design'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"materialBundle\"></ng-container>\n        </ng-container>\n    </ng-container>\n</ng-template>\n",
                providers: [
                    { provide: IgxInputGroupBase, useExisting: IgxInputGroupComponent },
                ]
            },] }
];
IgxInputGroupComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [IGX_INPUT_GROUP_TYPE,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Renderer2 }
];
IgxInputGroupComponent.propDecorators = {
    resourceStrings: [{ type: Input }],
    defaultClass: [{ type: HostBinding, args: ['class.igx-input-group',] }],
    hasPlaceholder: [{ type: HostBinding, args: ['class.igx-input-group--placeholder',] }],
    isRequired: [{ type: HostBinding, args: ['class.igx-input-group--required',] }],
    isFocused: [{ type: HostBinding, args: ['class.igx-input-group--focused',] }],
    disabled: [{ type: HostBinding, args: ['class.igx-input-group--disabled',] }, { type: Input }],
    suppressInputAutofocus: [{ type: Input }],
    hasWarning: [{ type: HostBinding, args: ['class.igx-input-group--warning',] }],
    hints: [{ type: ContentChildren, args: [IgxHintDirective, { read: IgxHintDirective },] }],
    input: [{ type: ContentChild, args: [IgxInputDirective, { read: IgxInputDirective, static: true },] }],
    validClass: [{ type: HostBinding, args: ['class.igx-input-group--valid',] }],
    invalidClass: [{ type: HostBinding, args: ['class.igx-input-group--invalid',] }],
    isFilled: [{ type: HostBinding, args: ['class.igx-input-group--filled',] }],
    isDisplayDensityCosy: [{ type: HostBinding, args: ['class.igx-input-group--cosy',] }],
    isDisplayDensityComfortable: [{ type: HostBinding, args: ['class.igx-input-group--comfortable',] }],
    isDisplayDensityCompact: [{ type: HostBinding, args: ['class.igx-input-group--compact',] }],
    type: [{ type: Input, args: ['type',] }],
    theme: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onPointerDown: [{ type: HostListener, args: ['pointerdown', ['$event'],] }],
    isTypeBox: [{ type: HostBinding, args: ['class.igx-input-group--box',] }],
    isFileType: [{ type: HostBinding, args: ['class.igx-input-group--file',] }],
    isTypeBorder: [{ type: HostBinding, args: ['class.igx-input-group--border',] }],
    isTypeFluent: [{ type: HostBinding, args: ['class.igx-input-group--fluent',] }],
    isTypeBootstrap: [{ type: HostBinding, args: ['class.igx-input-group--bootstrap',] }],
    isTypeIndigo: [{ type: HostBinding, args: ['class.igx-input-group--indigo',] }],
    isTypeSearch: [{ type: HostBinding, args: ['class.igx-input-group--search',] }]
};
/** @hidden */
class IgxInputGroupModule {
}
IgxInputGroupModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxInputGroupComponent,
                    IgxHintDirective,
                    IgxInputDirective,
                    IgxLabelDirective,
                ],
                exports: [
                    IgxInputGroupComponent,
                    IgxHintDirective,
                    IgxInputDirective,
                    IgxLabelDirective,
                    IgxPrefixModule,
                    IgxSuffixModule,
                    IgxButtonModule,
                    IgxIconModule
                ],
                imports: [CommonModule, IgxPrefixModule, IgxSuffixModule, IgxButtonModule, IgxIconModule],
            },] }
];

/**
 * **Ignite UI for Angular Autocomplete** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/autocomplete.html)
 *
 * The igxAutocomplete directive provides a way to enhance a text input
 * by showing a drop down of suggested options, provided by the developer.
 *
 * Example:
 * ```html
 * <input type="text" [igxAutocomplete]="townsPanel" #autocompleteRef="igxAutocomplete"/>
 * <igx-drop-down #townsPanel>
 *     <igx-drop-down-item *ngFor="let town of towns | startsWith:townSelected" [value]="town">
 *         {{town}}
 *     </igx-drop-down-item>
 * </igx-drop-down>
 * ```
 */
class IgxAutocompleteDirective extends IgxDropDownItemNavigationDirective {
    constructor(ngModel, formControl, group, elementRef, cdr) {
        super(null);
        this.ngModel = ngModel;
        this.formControl = formControl;
        this.group = group;
        this.elementRef = elementRef;
        this.cdr = cdr;
        /** @hidden @internal */
        this.autofill = 'off';
        /** @hidden  @internal */
        this.role = 'combobox';
        /**
         * Enables/disables autocomplete component
         *
         * ```typescript
         * // get
         * let disabled = this.autocomplete.disabled;
         * ```
         * ```html
         * <!--set-->
         * <input type="text" [igxAutocomplete]="townsPanel" [igxAutocompleteDisabled]="disabled"/>
         * ```
         * ```typescript
         * // set
         * public disabled = true;
         * ```
         */
        this.disabled = false;
        /**
         * Emitted after item from the drop down is selected
         *
         * ```html
         * <input igxInput [igxAutocomplete]="townsPanel" (onItemSelected)='itemSelected($event)' />
         * ```
         */
        this.onItemSelected = new EventEmitter();
        this._shouldBeOpen = false;
        this.destroy$ = new Subject();
    }
    /**
     * Sets the target of the autocomplete directive
     *
     * ```html
     * <!-- Set -->
     * <input [igxAutocomplete]="dropdown" />
     * ...
     * <igx-drop-down #dropdown>
     * ...
     * </igx-drop-down>
     * ```
     */
    get target() {
        return this._target;
    }
    set target(v) {
        this._target = v;
    }
    /** @hidden @internal */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /** @hidden @internal */
    get parentElement() {
        return this.group ? this.group.element.nativeElement : this.nativeElement;
    }
    get settings() {
        const settings = Object.assign({}, this.defaultSettings, this.autocompleteSettings);
        const target = settings.target || settings.positionStrategy.settings.target;
        if (!target) {
            const positionStrategyClone = settings.positionStrategy.clone();
            settings.target = this.parentElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    }
    /** @hidden  @internal */
    get ariaExpanded() {
        return !this.collapsed;
    }
    /** @hidden  @internal */
    get hasPopUp() {
        return 'listbox';
    }
    /** @hidden  @internal */
    get ariaOwns() {
        return this.target.listId;
    }
    /** @hidden  @internal */
    get ariaActiveDescendant() {
        return !this.target.collapsed && this.target.focusedItem ? this.target.focusedItem.id : null;
    }
    /** @hidden  @internal */
    get ariaAutocomplete() {
        return 'list';
    }
    get model() {
        return this.ngModel || this.formControl;
    }
    /** @hidden  @internal */
    onInput() {
        this.open();
    }
    /** @hidden  @internal */
    onArrowDown(event) {
        event.preventDefault();
        this.open();
    }
    /** @hidden  @internal */
    onTab() {
        this.close();
    }
    /** @hidden  @internal */
    handleKeyDown(event) {
        if (!this.collapsed) {
            switch (event.key.toLowerCase()) {
                case 'space':
                case 'spacebar':
                case ' ':
                case 'home':
                case 'end':
                    return;
                default:
                    super.handleKeyDown(event);
            }
        }
    }
    /** @hidden  @internal */
    onArrowDownKeyDown() {
        super.onArrowDownKeyDown();
    }
    /** @hidden  @internal */
    onArrowUpKeyDown() {
        super.onArrowUpKeyDown();
    }
    /** @hidden  @internal */
    onEndKeyDown() {
        super.onEndKeyDown();
    }
    /** @hidden  @internal */
    onHomeKeyDown() {
        super.onHomeKeyDown();
    }
    /**
     * Closes autocomplete drop down
     */
    close() {
        this._shouldBeOpen = false;
        if (this.collapsed) {
            return;
        }
        this.target.close();
    }
    /**
     * Opens autocomplete drop down
     */
    open() {
        this._shouldBeOpen = true;
        if (this.disabled || !this.collapsed || this.target.children.length === 0) {
            return;
        }
        // if no drop-down width is set, the drop-down will be as wide as the autocomplete input;
        this.target.width = this.target.width || (this.parentElement.clientWidth + 'px');
        this.target.open(this.settings);
        this.highlightFirstItem();
    }
    /** @hidden @internal */
    ngOnInit() {
        const targetElement = this.parentElement;
        this.defaultSettings = {
            target: targetElement,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy(),
            excludeFromOutsideClick: [targetElement]
        };
    }
    /** @hidden */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    ngAfterViewInit() {
        this.target.children.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (this.target.children.length) {
                if (!this.collapsed) {
                    this.highlightFirstItem();
                }
                else if (this._shouldBeOpen) {
                    this.open();
                }
            }
            else {
                // _shouldBeOpen flag should remain unchanged since this state change doesn't come from outside of the component
                // (like in the case of public API or user interaction).
                this.target.close();
            }
        });
        this.target.onSelection.pipe(takeUntil(this.destroy$)).subscribe(this.select.bind(this));
    }
    get collapsed() {
        return this.target ? this.target.collapsed : true;
    }
    select(value) {
        if (!value.newSelection) {
            return;
        }
        value.cancel = true; // Disable selection in the drop down, because in autocomplete we do not save selection.
        const newValue = value.newSelection.value;
        const args = { value: newValue, cancel: false };
        this.onItemSelected.emit(args);
        if (args.cancel) {
            return;
        }
        this.close();
        this.nativeElement.focus();
        // Update model after the input is re-focused, in order to have proper valid styling.
        // Otherwise when item is selected using mouse (and input is blurred), then valid style will be removed.
        if (this.model) {
            this.model.control.setValue(newValue);
        }
        else {
            this.nativeElement.value = newValue;
        }
    }
    ;
    highlightFirstItem() {
        if (this.target.focusedItem) {
            this.target.focusedItem.focused = false;
            this.target.focusedItem = null;
        }
        this.target.navigateFirst();
        this.cdr.detectChanges();
    }
    ;
}
IgxAutocompleteDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxAutocomplete]',
                exportAs: 'igxAutocomplete'
            },] }
];
IgxAutocompleteDirective.ctorParameters = () => [
    { type: NgModel, decorators: [{ type: Self }, { type: Optional }, { type: Inject, args: [NgModel,] }] },
    { type: FormControlName, decorators: [{ type: Self }, { type: Optional }, { type: Inject, args: [FormControlName,] }] },
    { type: IgxInputGroupComponent, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxAutocompleteDirective.propDecorators = {
    target: [{ type: Input, args: ['igxAutocomplete',] }],
    autocompleteSettings: [{ type: Input, args: ['igxAutocompleteSettings',] }],
    autofill: [{ type: HostBinding, args: ['attr.autocomplete',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    disabled: [{ type: Input, args: ['igxAutocompleteDisabled',] }],
    onItemSelected: [{ type: Output }],
    ariaExpanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
    hasPopUp: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
    ariaOwns: [{ type: HostBinding, args: ['attr.aria-owns',] }],
    ariaActiveDescendant: [{ type: HostBinding, args: ['attr.aria-activedescendant',] }],
    ariaAutocomplete: [{ type: HostBinding, args: ['attr.aria-autocomplete',] }],
    onInput: [{ type: HostListener, args: ['input',] }],
    onArrowDown: [{ type: HostListener, args: ['keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['keydown.Alt.ArrowDown', ['$event'],] }, { type: HostListener, args: ['keydown.ArrowUp', ['$event'],] }, { type: HostListener, args: ['keydown.Alt.ArrowUp', ['$event'],] }],
    onTab: [{ type: HostListener, args: ['keydown.Tab',] }, { type: HostListener, args: ['keydown.Shift.Tab',] }]
};
/** @hidden */
class IgxAutocompleteModule {
}
IgxAutocompleteModule.decorators = [
    { type: NgModule, args: [{
                imports: [IgxDropDownModule, CommonModule],
                declarations: [IgxAutocompleteDirective],
                exports: [IgxAutocompleteDirective]
            },] }
];

const IgxDividerType = mkenum({
    SOLID: 'solid',
    DASHED: 'dashed'
});
let NEXT_ID$4 = 0;
class IgxDividerDirective {
    constructor() {
        /**
         * Sets/gets the `id` of the divider.
         * If not set, `id` will have value `"igx-divider-0"`;
         * ```html
         * <igx-divider id="my-divider"></igx-divider>
         * ```
         * ```typescript
         * let dividerId =  this.divider.id;
         * ```
         */
        this.id = `igx-divider-${NEXT_ID$4++}`;
        /**
         * An @Input property that sets the value of `role` attribute.
         * If not the default value of `separator` will be used.
         */
        this.role = 'separator';
        /**
         * Sets the type of the divider. The default value
         * is `default`. The divider can also be `dashed`;
         * ```html
         * <igx-divider type="dashed"></igx-divider>
         * ```
         */
        this.type = IgxDividerType.SOLID;
        /**
         * An @Input that sets the `middle` attribute of the divider.
         * If set to `true` and an `inset` value has been provided,
         * the divider will start shrinking from both ends.
         * ```html
         * <igx-divider [middle]="true"></igx-divider>
         * ```
         */
        this.middle = false;
        /**
         * An @Input that sets the vertical attribute of the divider.
         * ```html
         * <igx-divider [vertical]="true"></igx-divider>
         * ```
         */
        this.vertical = false;
        /**
         * An @Input property that sets the value of the `inset` attribute.
         * If not provided it will be set to `'0'`.
         * ```html
         * <igx-divider inset="16px"></igx-divider>
         * ```
         */
        this._inset = '0';
    }
    get isDashed() {
        return this.type === IgxDividerType.DASHED;
    }
    /**
     * Sets the inset of the divider from the side(s).
     * If the divider attribute `middle` is set to `true`,
     * it will inset the divider on both sides.
     * ```typescript
     * this.divider.inset = '32px';
     * ```
     */
    set inset(value) {
        this._inset = value;
    }
    /**
     * Gets the current divider inset in terms of
     * margin representation as applied to the divider.
     * ```typescript
     * const inset = this.divider.inset;
     * ```
     */
    get inset() {
        const baseMargin = '0';
        if (this.middle) {
            if (this.vertical) {
                return `${this._inset} ${baseMargin}`;
            }
            return `${baseMargin} ${this._inset}`;
        }
        else {
            if (this.vertical) {
                return `${this._inset} ${baseMargin} 0 ${baseMargin}`;
            }
            return `${baseMargin} 0 ${baseMargin} ${this._inset}`;
        }
    }
    /**
     * A getter that returns `true` if the type of the divider is `default`;
     * ```typescript
     * const isDefault = this.divider.isDefault;
     * ```
     */
    get isSolid() {
        return this.type === IgxDividerType.SOLID;
    }
}
IgxDividerDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: 'igx-divider'
            },] }
];
IgxDividerDirective.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    type: [{ type: HostBinding, args: ['class.igx-divider',] }, { type: Input }],
    isDashed: [{ type: HostBinding, args: ['class.igx-divider--dashed',] }],
    middle: [{ type: HostBinding, args: ['class.igx-divider--inset',] }, { type: Input }],
    vertical: [{ type: HostBinding, args: ['class.igx-divider--vertical',] }, { type: Input }],
    inset: [{ type: HostBinding, args: ['style.margin',] }],
    _inset: [{ type: Input, args: ['inset',] }]
};
class IgxDividerModule {
}
IgxDividerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxDividerDirective],
                exports: [IgxDividerDirective]
            },] }
];

// @dynamic
class IgxDefaultDropStrategy {
    dropAction(drag, drop, atIndex) { }
}
// @dynamic
class IgxAppendDropStrategy {
    constructor(_renderer) {
        this._renderer = _renderer;
    }
    dropAction(drag, drop, atIndex) {
        const dragElement = drag.element.nativeElement;
        const dropAreaElement = drop.element.nativeElement;
        this._renderer.removeChild(dragElement.parentNode, dragElement);
        this._renderer.appendChild(dropAreaElement, dragElement);
    }
}
// @dynamic
class IgxPrependDropStrategy {
    constructor(_renderer) {
        this._renderer = _renderer;
    }
    dropAction(drag, drop, atIndex) {
        const dragElement = drag.element.nativeElement;
        const dropAreaElement = drop.element.nativeElement;
        this._renderer.removeChild(dragElement.parentNode, dragElement);
        if (dropAreaElement.children.length) {
            this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[0]);
        }
        else {
            this._renderer.appendChild(dropAreaElement, dragElement);
        }
    }
}
// @dynamic
class IgxInsertDropStrategy {
    constructor(_renderer) {
        this._renderer = _renderer;
    }
    dropAction(drag, drop, atIndex) {
        if (drag.element.nativeElement.parentElement === drop.element.nativeElement && atIndex === -1) {
            return;
        }
        const dragElement = drag.element.nativeElement;
        const dropAreaElement = drop.element.nativeElement;
        this._renderer.removeChild(dragElement.parentNode, dragElement);
        if (atIndex !== -1 && dropAreaElement.children.length > atIndex) {
            this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[atIndex]);
        }
        else {
            this._renderer.appendChild(dropAreaElement, dragElement);
        }
    }
}

var DragDirection;
(function (DragDirection) {
    DragDirection[DragDirection["VERTICAL"] = 0] = "VERTICAL";
    DragDirection[DragDirection["HORIZONTAL"] = 1] = "HORIZONTAL";
    DragDirection[DragDirection["BOTH"] = 2] = "BOTH";
})(DragDirection || (DragDirection = {}));
class IgxDragLocation {
    constructor(_pageX, _pageY) {
        this._pageX = _pageX;
        this._pageY = _pageY;
        this.pageX = parseFloat(_pageX);
        this.pageY = parseFloat(_pageY);
    }
}
class IgxDragHandleDirective {
    constructor(element) {
        this.element = element;
        this.baseClass = true;
    }
}
IgxDragHandleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDragHandle]'
            },] }
];
IgxDragHandleDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxDragHandleDirective.propDecorators = {
    baseClass: [{ type: HostBinding, args: ['class.igx-drag__handle',] }]
};
class IgxDragIgnoreDirective {
    constructor(element) {
        this.element = element;
        this.baseClass = true;
    }
}
IgxDragIgnoreDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDragIgnore]'
            },] }
];
IgxDragIgnoreDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxDragIgnoreDirective.propDecorators = {
    baseClass: [{ type: HostBinding, args: ['class.igx-drag__ignore',] }]
};
class IgxDragDirective {
    constructor(cdr, element, viewContainer, zone, renderer, platformUtil) {
        this.cdr = cdr;
        this.element = element;
        this.viewContainer = viewContainer;
        this.zone = zone;
        this.renderer = renderer;
        this.platformUtil = platformUtil;
        /**
         * An @Input property that indicates when the drag should start.
         * By default the drag starts after the draggable element is moved by 5px.
         * ```html
         * <div igxDrag [dragTolerance]="100">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragTolerance = 5;
        /**
         * An @Input property that indicates the directions that the element can be dragged.
         * By default it is set to both horizontal and vertical directions.
         * ```html
         * <div igxDrag [dragDirection]="dragDir">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public dragDir = DragDirection.HORIZONTAL;
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragDirection = DragDirection.BOTH;
        /**
         * An @Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
         * By default it is set to `true`.
         * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
         * ```html
         * <div igxDrag [ghost]="false">
         *      <span>Drag Me!</span>
         * </div>
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.ghost = true;
        /**
         * Sets a custom class that will be added to the `ghostElement` element.
         * ```html
         * <div igxDrag [ghostClass]="'ghostElement'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.ghostClass = '';
        /**
         * Event triggered when the draggable element drag starts.
         * ```html
         * <div igxDrag (dragStart)="onDragStart()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragStart(){
         *      alert("The drag has stared!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragStart = new EventEmitter();
        /**
         * Event triggered when the draggable element has been moved.
         * ```html
         * <div igxDrag  (dragMove)="onDragMove()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragMove(){
         *      alert("The element has moved!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragMove = new EventEmitter();
        /**
         * Event triggered when the draggable element is released.
         * ```html
         * <div igxDrag (dragEnd)="onDragEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragEnd(){
         *      alert("The drag has ended!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragEnd = new EventEmitter();
        /**
         * Event triggered when the draggable element is clicked.
         * ```html
         * <div igxDrag (dragClick)="onDragClick()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragClick(){
         *      alert("The element has been clicked!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragClick = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostCreate)="ghostCreated()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostCreated(){
         *      alert("The ghost has been created!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.ghostCreate = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostDestroy)="ghostDestroyed()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostDestroyed(){
         *      alert("The ghost has been destroyed!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.ghostDestroy = new EventEmitter();
        /**
         * Event triggered after the draggable element is released and after its animation has finished.
         * ```html
         * <div igxDrag (transitioned)="onMoveEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onMoveEnd(){
         *      alert("The move has ended!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.transitioned = new EventEmitter();
        /**
         * @hidden
         */
        this.baseClass = true;
        /**
         * @hidden
         */
        this.selectDisabled = false;
        /**
         * @hidden
         */
        this.defaultReturnDuration = '0.5s';
        /**
         * @hidden
         */
        this.animInProgress = false;
        this.ghostContext = null;
        this._startX = 0;
        this._startY = 0;
        this._lastX = 0;
        this._lastY = 0;
        this._dragStarted = false;
        this._ghostHostX = 0;
        this._ghostHostY = 0;
        this._pointerDownId = null;
        this._clicked = false;
        this._lastDropArea = null;
        this._destroy = new Subject();
        this._removeOnDestroy = true;
    }
    /**
     * Gets the current location of the element relative to the page.
     */
    get location() {
        return new IgxDragLocation(this.pageX, this.pageY);
    }
    /**
     * Gets the original location of the element before dragging started.
     */
    get originLocation() {
        return new IgxDragLocation(this.baseOriginLeft, this.baseOriginTop);
    }
    /**
     * @hidden
     */
    get pointerEventsEnabled() {
        return typeof PointerEvent !== 'undefined';
    }
    /**
     * @hidden
     */
    get touchEventsEnabled() {
        return 'ontouchstart' in window;
    }
    /**
     * @hidden
     */
    get pageX() {
        if (this.ghost && this.ghostElement) {
            return this.ghostLeft;
        }
        return this.baseLeft;
    }
    /**
     * @hidden
     */
    get pageY() {
        if (this.ghost && this.ghostElement) {
            return this.ghostTop;
        }
        return this.baseTop;
    }
    get baseLeft() {
        return this.element.nativeElement.getBoundingClientRect().left;
    }
    get baseTop() {
        return this.element.nativeElement.getBoundingClientRect().top;
    }
    get baseOriginLeft() {
        return this.baseLeft - this.getTransformX(this.element.nativeElement);
    }
    get baseOriginTop() {
        return this.baseTop - this.getTransformY(this.element.nativeElement);
    }
    set ghostLeft(pageX) {
        if (this.ghostElement) {
            // We need to take into account marginLeft, since top style does not include margin, but pageX includes the margin.
            const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
            // If ghost host is defined it needs to be taken into account.
            this.ghostElement.style.left = (pageX - ghostMarginLeft - this._ghostHostX) + 'px';
        }
    }
    get ghostLeft() {
        return parseInt(this.ghostElement.style.left, 10) + this._ghostHostX;
    }
    set ghostTop(pageY) {
        if (this.ghostElement) {
            // We need to take into account marginTop, since top style does not include margin, but pageY includes the margin.
            const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
            // If ghost host is defined it needs to be taken into account.
            this.ghostElement.style.top = (pageY - ghostMarginTop - this._ghostHostY) + 'px';
        }
    }
    get ghostTop() {
        return parseInt(this.ghostElement.style.top, 10) + this._ghostHostY;
    }
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetX]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     *
     * @memberof IgxDragDirective
     */
    set ghostOffsetX(value) {
        this._offsetX = parseInt(value, 10);
    }
    get ghostOffsetX() {
        return this._offsetX !== undefined ? this._offsetX : this._defaultOffsetX;
    }
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetY]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     *
     * @memberof IgxDragDirective
     */
    set ghostOffsetY(value) {
        this._offsetY = parseInt(value, 10);
    }
    get ghostOffsetY() {
        return this._offsetY !== undefined ? this._offsetY : this._defaultOffsetY;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (!this.dragHandles || !this.dragHandles.length) {
            // Set user select none to the whole draggable element if no drag handles are defined.
            this.selectDisabled = true;
        }
        // Bind events
        this.zone.runOutsideAngular(() => {
            if (!this.platformUtil.isBrowser) {
                return;
            }
            const targetElements = this.dragHandles && this.dragHandles.length ?
                this.dragHandles.map((item) => item.element.nativeElement) : [this.element.nativeElement];
            targetElements.forEach((element) => {
                if (this.pointerEventsEnabled) {
                    fromEvent(element, 'pointerdown').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                    fromEvent(element, 'pointermove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                    fromEvent(element, 'pointerup').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerUp(res));
                    if (!this.ghost) {
                        // Do not bind `lostpointercapture` to the target, because we will bind it on the ghost later.
                        fromEvent(element, 'lostpointercapture').pipe(takeUntil(this._destroy))
                            .subscribe((res) => this.onPointerLost(res));
                    }
                }
                else if (this.touchEventsEnabled) {
                    fromEvent(element, 'touchstart').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
                else {
                    // We don't have pointer events and touch events. Use then mouse events.
                    fromEvent(element, 'mousedown').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
            });
            // We should bind to document events only once when there are no pointer events.
            if (!this.pointerEventsEnabled && this.touchEventsEnabled) {
                fromEvent(document.defaultView, 'touchmove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'touchend').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            else if (!this.pointerEventsEnabled) {
                fromEvent(document.defaultView, 'mousemove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'mouseup').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            this.element.nativeElement.addEventListener('transitionend', (args) => {
                this.onTransitionEnd(args);
            });
        });
        // Set transition duration to 0s. This also helps with setting `visibility: hidden` to the base to not lag.
        this.element.nativeElement.style.transitionDuration = '0.0s';
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
        if (this.ghost && this.ghostElement && this._removeOnDestroy) {
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
        }
    }
    /**
     * Sets desired location of the base element or ghost element if rended relative to the document.
     *
     * @param newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
     */
    setLocation(newLocation) {
        // We do not subtract marginLeft and marginTop here because here we calculate deltas.
        if (this.ghost && this.ghostElement) {
            const offsetHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
            const offsetHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
            this.ghostLeft = newLocation.pageX - offsetHostX + this.getWindowScrollLeft();
            this.ghostTop = newLocation.pageY - offsetHostY + this.getWindowScrollTop();
        }
        else if (!this.ghost) {
            const deltaX = newLocation.pageX - this.pageX;
            const deltaY = newLocation.pageY - this.pageY;
            const transformX = this.getTransformX(this.element.nativeElement);
            const transformY = this.getTransformY(this.element.nativeElement);
            this.setTransformXY(transformX + deltaX, transformY + deltaY);
        }
        this._startX = this.baseLeft;
        this._startY = this.baseTop;
    }
    /**
     * Animates the base or ghost element depending on the `ghost` input to its initial location.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * If the base element has changed its DOM position its initial location will be changed accordingly.
     *
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionToOrigin(customAnimArgs, startLocation) {
        if ((!!startLocation && startLocation.pageX === this.baseOriginLeft && startLocation.pageY === this.baseOriginLeft) ||
            (!startLocation && this.ghost && !this.ghostElement)) {
            return;
        }
        if (!!startLocation && startLocation.pageX !== this.pageX && startLocation.pageY !== this.pageY) {
            if (this.ghost && !this.ghostElement) {
                this._startX = startLocation.pageX;
                this._startY = startLocation.pageY;
                this._ghostStartX = this._startX;
                this._ghostStartY = this._startY;
                this.createGhost(this._startX, this._startY);
            }
            this.setLocation(startLocation);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            if (this.ghost) {
                this.ghostElement.style.transitionProperty = 'top, left';
                this.ghostElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.ghostElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.ghostElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this.setLocation(new IgxDragLocation(this.baseLeft, this.baseTop));
            }
            else if (!this.ghost) {
                this.element.nativeElement.style.transitionProperty = 'transform';
                this.element.nativeElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.element.nativeElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.element.nativeElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this._startX = this.baseLeft;
                this._startY = this.baseTop;
                this.setTransformXY(0, 0);
            }
        }, 0);
    }
    /**
     * Animates the base or ghost element to a specific target location or other element using transition.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
     *
     * @param target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionTo(target, customAnimArgs, startLocation) {
        if (!!startLocation && this.ghost && !this.ghostElement) {
            this._startX = startLocation.pageX;
            this._startY = startLocation.pageY;
            this._ghostStartX = this._startX;
            this._ghostStartY = this._startY;
        }
        else if (!!startLocation && (!this.ghost || this.ghostElement)) {
            this.setLocation(startLocation);
        }
        else if (this.ghost && !this.ghostElement) {
            this._startX = this.baseLeft;
            this._startY = this.baseTop;
            this._ghostStartX = this._startX + this.getWindowScrollLeft();
            this._ghostStartY = this._startY + this.getWindowScrollTop();
        }
        if (this.ghost && !this.ghostElement) {
            this.createGhost(this._startX, this._startY);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            const movedElem = this.ghost ? this.ghostElement : this.element.nativeElement;
            movedElem.style.transitionProperty = this.ghost && this.ghostElement ? 'left, top' : 'transform';
            movedElem.style.transitionDuration =
                customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
            movedElem.style.transitionTimingFunction =
                customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
            movedElem.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
            if (target instanceof IgxDragLocation) {
                this.setLocation(new IgxDragLocation(target.pageX, target.pageY));
            }
            else {
                const targetRects = target.nativeElement.getBoundingClientRect();
                this.setLocation(new IgxDragLocation(targetRects.left - this.getWindowScrollLeft(), targetRects.top - this.getWindowScrollTop()));
            }
        }, 0);
    }
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param event PointerDown event captured
     */
    onPointerDown(event) {
        const ignoredElement = this.dragIgnoredElems.find(elem => elem.element.nativeElement === event.target);
        if (ignoredElement) {
            return;
        }
        this._clicked = true;
        this._pointerDownId = event.pointerId;
        // Set pointer capture so we detect pointermove even if mouse is out of bounds until ghostElement is created.
        const handleFound = this.dragHandles.find(handle => handle.element.nativeElement === event.currentTarget);
        const targetElement = handleFound ? handleFound.element.nativeElement : this.element.nativeElement;
        if (this.pointerEventsEnabled) {
            targetElement.setPointerCapture(this._pointerDownId);
        }
        else {
            targetElement.focus();
            event.preventDefault();
        }
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            this._startX = event.pageX;
            this._startY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            this._startX = event.touches[0].pageX;
            this._startY = event.touches[0].pageY;
        }
        this._defaultOffsetX = this.baseLeft - this._startX + this.getWindowScrollLeft();
        this._defaultOffsetY = this.baseTop - this._startY + this.getWindowScrollTop();
        this._ghostStartX = this._startX + this.ghostOffsetX;
        this._ghostStartY = this._startY + this.ghostOffsetY;
        this._lastX = this._startX;
        this._lastY = this._startY;
    }
    /**
     * @hidden
     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
     * @param event PointerMove event captured
     */
    onPointerMove(event) {
        if (this._clicked) {
            let pageX;
            let pageY;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            const totalMovedX = pageX - this._startX;
            const totalMovedY = pageY - this._startY;
            if (!this._dragStarted &&
                (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                const dragStartArgs = {
                    originalEvent: event,
                    owner: this,
                    startX: pageX - totalMovedX,
                    startY: pageY - totalMovedY,
                    pageX,
                    pageY,
                    cancel: false
                };
                this.zone.run(() => {
                    this.dragStart.emit(dragStartArgs);
                });
                if (!dragStartArgs.cancel) {
                    this._dragStarted = true;
                    if (this.ghost) {
                        // We moved enough so ghostElement can be rendered and actual dragging to start.
                        // When creating it will take into account any offset set by the user by default.
                        this.createGhost(pageX, pageY);
                    }
                    else if (this._offsetX !== undefined || this._offsetY !== undefined) {
                        // There is no need for ghost, but we will need to position initially the base element to reflect any offset.
                        const transformX = (this._offsetX !== undefined ? this._offsetX - this._defaultOffsetX : 0) +
                            this.getTransformX(this.element.nativeElement);
                        const transformY = (this._offsetY !== undefined ? this._offsetY - this._defaultOffsetY : 0) +
                            this.getTransformY(this.element.nativeElement);
                        this.setTransformXY(transformX, transformY);
                    }
                }
                else {
                    return;
                }
            }
            else if (!this._dragStarted) {
                return;
            }
            const moveArgs = {
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._lastX,
                pageY: this._lastY,
                nextPageX: pageX,
                nextPageY: pageY,
                cancel: false
            };
            this.dragMove.emit(moveArgs);
            const setPageX = moveArgs.nextPageX;
            const setPageY = moveArgs.nextPageY;
            if (!moveArgs.cancel) {
                if (this.ghost) {
                    const updatedTotalMovedX = this.dragDirection === DragDirection.VERTICAL ? 0 : setPageX - this._startX;
                    const updatedTotalMovedY = this.dragDirection === DragDirection.HORIZONTAL ? 0 : setPageY - this._startY;
                    this.ghostLeft = this._ghostStartX + updatedTotalMovedX;
                    this.ghostTop = this._ghostStartY + updatedTotalMovedY;
                }
                else {
                    const lastMovedX = this.dragDirection === DragDirection.VERTICAL ? 0 : setPageX - this._lastX;
                    const lastMovedY = this.dragDirection === DragDirection.HORIZONTAL ? 0 : setPageY - this._lastY;
                    const translateX = this.getTransformX(this.element.nativeElement) + lastMovedX;
                    const translateY = this.getTransformY(this.element.nativeElement) + lastMovedY;
                    this.setTransformXY(translateX, translateY);
                }
                this.dispatchDragEvents(pageX, pageY, event);
            }
            this._lastX = setPageX;
            this._lastY = setPageY;
        }
    }
    /**
     * @hidden
     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
     * @param event PointerUp event captured
     */
    onPointerUp(event) {
        if (!this._clicked) {
            return;
        }
        let pageX;
        let pageY;
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            pageX = event.pageX;
            pageY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            pageX = event.touches[0].pageX;
            pageY = event.touches[0].pageY;
            // Prevent scrolling on touch while dragging
            event.preventDefault();
        }
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX,
            pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                this.dispatchDropEvent(event.pageX, event.pageY, event);
            }
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
        else {
            // Trigger our own click event because when there is no ghost, native click cannot be prevented when dragging.
            this.zone.run(() => {
                this.dragClick.emit(eventArgs);
            });
        }
    }
    /**
     * @hidden
     * Execute this method whe the pointer capture has been lost.
     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
     * @param event Event captured
     */
    onPointerLost(event) {
        if (!this._clicked) {
            return;
        }
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: event.pageX,
            pageY: event.pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
    }
    /**
     * @hidden
     */
    onTransitionEnd(event) {
        if ((!this._dragStarted && !this.animInProgress) || this._clicked) {
            // Return if no dragging started and there is no animation in progress.
            return;
        }
        if (this.ghost && this.ghostElement) {
            this._ghostStartX = this.baseLeft + this.getWindowScrollLeft();
            this._ghostStartY = this.baseTop + this.getWindowScrollTop();
            const ghostDestroyArgs = {
                owner: this,
                ghostElement: this.ghostElement,
                cancel: false
            };
            this.ghostDestroy.emit(ghostDestroyArgs);
            if (ghostDestroyArgs.cancel) {
                return;
            }
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
        }
        else if (!this.ghost) {
            this.element.nativeElement.style.transitionProperty = '';
            this.element.nativeElement.style.transitionDuration = '0.0s';
            this.element.nativeElement.style.transitionTimingFunction = '';
            this.element.nativeElement.style.transitionDelay = '';
        }
        this.animInProgress = false;
        this._dragStarted = false;
        // Execute transitioned after everything is reset so if the user sets new location on the base now it would work as expected.
        this.zone.run(() => {
            this.transitioned.emit({
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._startX,
                pageY: this._startY
            });
        });
    }
    /**
     * @hidden
     * Create ghost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @param pageX Latest pointer position on the X axis relative to the page.
     * @param pageY Latest pointer position on the Y axis relative to the page.
     * @param node The Node object to be cloned.
     */
    createGhost(pageX, pageY, node = null) {
        if (!this.ghost) {
            return;
        }
        let dynamicGhostRef;
        if (this.ghostTemplate) {
            dynamicGhostRef = this.viewContainer.createEmbeddedView(this.ghostTemplate, this.ghostContext);
            this.ghostElement = dynamicGhostRef.rootNodes[0];
        }
        else {
            this.ghostElement = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);
        }
        const totalMovedX = pageX - this._startX;
        const totalMovedY = pageY - this._startY;
        this._ghostHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
        this._ghostHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
        this.ghostElement.style.transitionDuration = '0.0s';
        this.ghostElement.style.position = 'absolute';
        if (this.ghostClass) {
            this.renderer.addClass(this.ghostElement, this.ghostClass);
        }
        const createEventArgs = {
            owner: this,
            ghostElement: this.ghostElement,
            cancel: false
        };
        this.ghostCreate.emit(createEventArgs);
        if (createEventArgs.cancel) {
            this.ghostElement = null;
            if (this.ghostTemplate && dynamicGhostRef) {
                dynamicGhostRef.destroy();
            }
            return;
        }
        if (this.ghostHost) {
            this.ghostHost.appendChild(this.ghostElement);
        }
        else {
            document.body.appendChild(this.ghostElement);
        }
        const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
        const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
        this.ghostElement.style.left = (this._ghostStartX - ghostMarginLeft + totalMovedX - this._ghostHostX) + 'px';
        this.ghostElement.style.top = (this._ghostStartY - ghostMarginTop + totalMovedY - this._ghostHostX) + 'px';
        if (this.pointerEventsEnabled) {
            // The ghostElement takes control for moving and dragging after it has been rendered.
            if (this._pointerDownId !== null) {
                this.ghostElement.setPointerCapture(this._pointerDownId);
            }
            this.ghostElement.addEventListener('pointermove', (args) => {
                this.onPointerMove(args);
            });
            this.ghostElement.addEventListener('pointerup', (args) => {
                this.onPointerUp(args);
            });
            this.ghostElement.addEventListener('lostpointercapture', (args) => {
                this.onPointerLost(args);
            });
        }
        // Transition animation when the ghostElement is released and it returns to it's original position.
        this.ghostElement.addEventListener('transitionend', (args) => {
            this.onTransitionEnd(args);
        });
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     */
    dispatchDragEvents(pageX, pageY, originalEvent) {
        let topDropArea;
        const customEventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX,
            pageY,
            owner: this,
            originalEvent
        };
        const elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
        for (const element of elementsFromPoint) {
            if (element.getAttribute('droppable') === 'true' &&
                element !== this.ghostElement && element !== this.element.nativeElement) {
                topDropArea = element;
                break;
            }
        }
        if (topDropArea &&
            (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
            if (this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            }
            this._lastDropArea = topDropArea;
            this.dispatchEvent(this._lastDropArea, 'igxDragEnter', customEventArgs);
        }
        else if (!topDropArea && this._lastDropArea) {
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            this._lastDropArea = null;
            return;
        }
        if (topDropArea) {
            this.dispatchEvent(topDropArea, 'igxDragOver', customEventArgs);
        }
    }
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in @dispatchDragEvents method.
     */
    dispatchDropEvent(pageX, pageY, originalEvent) {
        const eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX,
            pageY,
            owner: this,
            originalEvent
        };
        this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
        this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
        this._lastDropArea = null;
    }
    /**
     * @hidden
     */
    getElementsAtPoint(pageX, pageY) {
        // correct the coordinates with the current scroll position, because
        // document.elementsFromPoint consider position within the current viewport
        // window.pageXOffset == window.scrollX; // always true
        // using window.pageXOffset for IE9 compatibility
        const viewPortX = pageX - window.pageXOffset;
        const viewPortY = pageY - window.pageYOffset;
        if (document['msElementsFromPoint']) {
            // Edge and IE special snowflakes
            const elements = document['msElementsFromPoint'](viewPortX, viewPortY);
            return elements === null ? [] : elements;
        }
        else {
            // Other browsers like Chrome, Firefox, Opera
            return document.elementsFromPoint(viewPortX, viewPortY);
        }
    }
    /**
     * @hidden
     */
    dispatchEvent(target, eventName, eventArgs) {
        // This way is IE11 compatible.
        const dragLeaveEvent = document.createEvent('CustomEvent');
        dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
        target.dispatchEvent(dragLeaveEvent);
        // Otherwise can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
    }
    getTransformX(elem) {
        let posX = 0;
        if (elem.style.transform) {
            const matrix = elem.style.transform;
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posX = values ? Number(values[1]) : 0;
        }
        return posX;
    }
    getTransformY(elem) {
        let posY = 0;
        if (elem.style.transform) {
            const matrix = elem.style.transform;
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posY = values ? Number(values[2]) : 0;
        }
        return posY;
    }
    /** Method setting transformation to the base draggable element. */
    setTransformXY(x, y) {
        this.element.nativeElement.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)';
    }
    getWindowScrollTop() {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    }
    getWindowScrollLeft() {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    }
    ghostHostOffsetLeft(ghostHost) {
        const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().left - this.getWindowScrollLeft();
        }
        return ghostHost.getBoundingClientRect().left - this.getWindowScrollLeft();
    }
    ghostHostOffsetTop(ghostHost) {
        const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().top - this.getWindowScrollTop();
        }
        return ghostHost.getBoundingClientRect().top - this.getWindowScrollTop();
    }
}
IgxDragDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'drag',
                selector: '[igxDrag]'
            },] }
];
IgxDragDirective.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: NgZone },
    { type: Renderer2 },
    { type: PlatformUtil }
];
IgxDragDirective.propDecorators = {
    data: [{ type: Input, args: ['igxDrag',] }],
    dragTolerance: [{ type: Input }],
    dragDirection: [{ type: Input }],
    dragChannel: [{ type: Input }],
    ghost: [{ type: Input }],
    ghostClass: [{ type: Input }],
    ghostTemplate: [{ type: Input }],
    ghostHost: [{ type: Input }],
    dragStart: [{ type: Output }],
    dragMove: [{ type: Output }],
    dragEnd: [{ type: Output }],
    dragClick: [{ type: Output }],
    ghostCreate: [{ type: Output }],
    ghostDestroy: [{ type: Output }],
    transitioned: [{ type: Output }],
    dragHandles: [{ type: ContentChildren, args: [IgxDragHandleDirective, { descendants: true },] }],
    dragIgnoredElems: [{ type: ContentChildren, args: [IgxDragIgnoreDirective, { descendants: true },] }],
    baseClass: [{ type: HostBinding, args: ['class.igx-drag',] }],
    selectDisabled: [{ type: HostBinding, args: ['class.igx-drag--select-disabled',] }],
    ghostOffsetX: [{ type: Input }],
    ghostOffsetY: [{ type: Input }]
};
class IgxDropDirective {
    constructor(element, _renderer, _zone) {
        this.element = element;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         *
         * @memberof IgxDropDirective
         */
        this.enter = new EventEmitter();
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         *
         * @memberof IgxDropDirective
         */
        this.over = new EventEmitter();
        /**
         * Event triggered when dragged element leaves the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragLeave(){
         *     alert("A draggable element has left the chip area!");
         * }
         * ```
         *
         * @memberof IgxDropDirective
         */
        this.leave = new EventEmitter();
        /**
         * Event triggered when dragged element is dropped in the area of the element.
         * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
         * To cancel the default logic the `cancel` property of the event needs to be set to true.
         * ```html
         * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragDrop(){
         *     alert("A draggable element has been dropped in the chip area!");
         * }
         * ```
         *
         * @memberof IgxDropDirective
         */
        this.dropped = new EventEmitter();
        /**
         * @hidden
         */
        this.droppable = true;
        /**
         * @hidden
         */
        this.dragover = false;
        /**
         * @hidden
         */
        this._destroy = new Subject();
        this._dropStrategy = new IgxDefaultDropStrategy();
    }
    /**
     * - Save data inside the `igxDrop` directive. This can be set when instancing `igxDrop` on an element.
     * ```html
     * <div [igxDrop]="{ source: myElement }"></div>
     * ```
     *
     * @memberof IgxDropDirective
     */
    set data(v) {
        this._data = v;
    }
    get data() {
        return this._data;
    }
    /**
     * An @Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
     *  the current drop area. The provided strategies are:
     *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
     *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
     *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
     *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
     *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
     * ```html
     * <div igxDrag>
     *      <span>DragMe</span>
     * </div>
     * <div igxDrop [dropStrategy]="myDropStrategy">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * ```typescript
     * import { IgxAppendDropStrategy } from 'igniteui-angular';
     *
     * export class App {
     *      public myDropStrategy = IgxAppendDropStrategy;
     * }
     * ```
     *
     * @memberof IgxDropDirective
     */
    set dropStrategy(classRef) {
        this._dropStrategy = new classRef(this._renderer);
    }
    get dropStrategy() {
        return this._dropStrategy;
    }
    /**
     * @hidden
     */
    onDragDrop(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const args = {
            owner: this,
            originalEvent: event.detail.originalEvent,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX,
            offsetY,
            cancel: false
        };
        this._zone.run(() => {
            this.dropped.emit(args);
        });
        if (this._dropStrategy && !args.cancel) {
            const elementsAtPoint = event.detail.owner.getElementsAtPoint(event.detail.pageX, event.detail.pageY);
            const insertIndex = this.getInsertIndexAt(event.detail.owner, elementsAtPoint);
            this._dropStrategy.dropAction(event.detail.owner, this, insertIndex);
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            fromEvent(this.element.nativeElement, 'igxDragEnter').pipe(takeUntil(this._destroy))
                .subscribe((res) => this.onDragEnter(res));
            fromEvent(this.element.nativeElement, 'igxDragLeave').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragLeave(res));
            fromEvent(this.element.nativeElement, 'igxDragOver').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragOver(res));
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
    }
    /**
     * @hidden
     */
    onDragOver(event) {
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX,
            offsetY
        };
        this.over.emit(eventArgs);
    }
    /**
     * @hidden
     */
    onDragEnter(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = true;
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX,
            offsetY
        };
        this._zone.run(() => {
            this.enter.emit(eventArgs);
        });
    }
    /**
     * @hidden
     */
    onDragLeave(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = false;
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX,
            offsetY
        };
        this._zone.run(() => {
            this.leave.emit(eventArgs);
        });
    }
    getWindowScrollTop() {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    }
    getWindowScrollLeft() {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    }
    isDragLinked(drag) {
        const dragLinkArray = drag.dragChannel instanceof Array;
        const dropLinkArray = this.dropChannel instanceof Array;
        if (!dragLinkArray && !dropLinkArray) {
            return this.dropChannel === drag.dragChannel;
        }
        else if (!dragLinkArray && dropLinkArray) {
            const dropLinks = this.dropChannel;
            for (const link of dropLinks) {
                if (link === drag.dragChannel) {
                    return true;
                }
            }
        }
        else if (dragLinkArray && !dropLinkArray) {
            const dragLinks = drag.dragChannel;
            for (const link of dragLinks) {
                if (link === this.dropChannel) {
                    return true;
                }
            }
        }
        else {
            const dragLinks = drag.dragChannel;
            const dropLinks = this.dropChannel;
            for (const draglink of dragLinks) {
                for (const droplink of dropLinks) {
                    if (draglink === droplink) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    getInsertIndexAt(draggedDir, elementsAtPoint) {
        let insertIndex = -1;
        const dropChildren = Array.prototype.slice.call(this.element.nativeElement.children);
        if (!dropChildren.length) {
            return insertIndex;
        }
        let i = 0;
        let childUnder = null;
        while (!childUnder && i < elementsAtPoint.length) {
            if (elementsAtPoint[i].parentElement === this.element.nativeElement) {
                childUnder = elementsAtPoint[i];
            }
            i++;
        }
        const draggedElemIndex = dropChildren.indexOf(draggedDir.element.nativeElement);
        insertIndex = dropChildren.indexOf(childUnder);
        if (draggedElemIndex !== -1 && draggedElemIndex < insertIndex) {
            insertIndex++;
        }
        return insertIndex;
    }
}
IgxDropDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'drop',
                selector: '[igxDrop]'
            },] }
];
IgxDropDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
IgxDropDirective.propDecorators = {
    data: [{ type: Input, args: ['igxDrop',] }],
    dropChannel: [{ type: Input }],
    dropStrategy: [{ type: Input }],
    enter: [{ type: Output }],
    over: [{ type: Output }],
    leave: [{ type: Output }],
    dropped: [{ type: Output }],
    droppable: [{ type: HostBinding, args: ['attr.droppable',] }],
    dragover: [{ type: HostBinding, args: ['class.dragOver',] }],
    onDragDrop: [{ type: HostListener, args: ['igxDrop', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxDragDropModule {
}
IgxDragDropModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective],
                exports: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective]
            },] }
];

class IgxFilterOptions {
    constructor() {
        // Input text value that will be used as a filtering pattern (matching condition is based on it)
        this.inputValue = '';
    }
    // Function - get value to be tested from the item
    // item - single item of the list to be filtered
    // key - property name of item, which value should be tested
    // Default behavior - returns "key"- named property value of item if key si provided,
    // otherwise textContent of the item's html element
    get_value(item, key) {
        let result = '';
        if (key && item[key]) {
            result = item[key].toString();
        }
        else if (item.element) {
            if (item.element.nativeElement) {
                result = item.element.nativeElement.textContent.trim();
                // Check if element doesn't return the DOM element directly
            }
            else if (item.element.textContent) {
                result = item.element.textContent.trim();
            }
        }
        return result;
    }
    // Function - formats the original text before matching process
    // Default behavior - returns text to lower case
    formatter(valueToTest) {
        return valueToTest.toLowerCase();
    }
    // Function - determines whether the item met the condition
    // valueToTest - text value that should be tested
    // inputValue - text value from input that condition is based on
    // Default behavior - "contains"
    matchFn(valueToTest, inputValue) {
        return valueToTest.indexOf(inputValue && inputValue.toLowerCase() || '') > -1;
    }
    // Function - executed after matching test for every matched item
    // Default behavior - shows the item
    metConditionFn(item) {
        if (item.hasOwnProperty('hidden')) {
            item.hidden = false;
        }
    }
    // Function - executed for every NOT matched item after matching test
    // Default behavior - hides the item
    overdueConditionFn(item) {
        if (item.hasOwnProperty('hidden')) {
            item.hidden = true;
        }
    }
}
class IgxFilterDirective {
    constructor(element, renderer) {
        this.element = element;
        this.filtering = new EventEmitter(false); // synchronous event emitter
        this.filtered = new EventEmitter();
    }
    ngOnChanges(changes) {
        // Detect only changes of input value
        if (changes.filterOptions &&
            changes.filterOptions.currentValue &&
            changes.filterOptions.currentValue.inputValue !== undefined &&
            changes.filterOptions.previousValue &&
            changes.filterOptions.currentValue.inputValue !== changes.filterOptions.previousValue.inputValue) {
            this.filter();
        }
    }
    filter() {
        if (!this.filterOptions.items) {
            return;
        }
        const args = { cancel: false, items: this.filterOptions.items };
        this.filtering.emit(args);
        if (args.cancel) {
            return;
        }
        const pipe = new IgxFilterPipe();
        const filtered = pipe.transform(this.filterOptions.items, this.filterOptions);
        this.filtered.emit({ filteredItems: filtered });
    }
}
IgxFilterDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxFilter]'
            },] }
];
IgxFilterDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
IgxFilterDirective.propDecorators = {
    filtering: [{ type: Output }],
    filtered: [{ type: Output }],
    filterOptions: [{ type: Input, args: ['igxFilter',] }]
};
class IgxFilterPipe {
    transform(items, 
    // options - initial settings of filter functionality
    options) {
        let result = [];
        if (!items || !items.length || !options) {
            return;
        }
        if (options.items) {
            items = options.items;
        }
        result = items.filter((item) => {
            const match = options.matchFn(options.formatter(options.get_value(item, options.key)), options.inputValue);
            if (match) {
                if (options.metConditionFn) {
                    options.metConditionFn(item);
                }
            }
            else {
                if (options.overdueConditionFn) {
                    options.overdueConditionFn(item);
                }
            }
            return match;
        });
        return result;
    }
}
IgxFilterPipe.decorators = [
    { type: Pipe, args: [{
                name: 'igxFilter',
                pure: false
            },] }
];
/**
 * @hidden
 */
class IgxFilterModule {
}
IgxFilterModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxFilterDirective, IgxFilterPipe],
                exports: [IgxFilterDirective, IgxFilterPipe],
                imports: [CommonModule]
            },] }
];

class IgxFocusDirective {
    constructor(element, comp) {
        this.element = element;
        this.comp = comp;
        this.focusState = true;
    }
    /**
     * Returns the state of the igxFocus.
     * ```typescript
     * @ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * let isFocusOn = this.igxFocus.focused;
     * ```
     *
     * @memberof IgxFocusDirective
     */
    get focused() {
        return this.focusState;
    }
    /**
     * Sets the state of the igxFocus.
     * ```html
     * <igx-input-group >
     *  <input #focusContainer igxInput [igxFocus]="true"/>
     * </igx-input-group>
     * ```
     *
     * @memberof IgxFocusDirective
     */
    set focused(val) {
        this.focusState = val;
        this.trigger();
    }
    /**
     * Gets the native element of the igxFocus.
     * ```typescript
     * @ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * let igxFocusNativeElement = this.igxFocus.nativeElement;
     * ```
     *
     * @memberof IgxFocusDirective
     */
    get nativeElement() {
        if (this.comp && this.comp[0] && this.comp[0].getEditElement) {
            return this.comp[0].getEditElement();
        }
        return this.element.nativeElement;
    }
    /**
     * Triggers the igxFocus state.
     * ```typescript
     * @ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * this.igxFocus.trigger();
     * ```
     *
     * @memberof IgxFocusDirective
     */
    trigger() {
        if (this.focusState) {
            requestAnimationFrame(() => this.nativeElement.focus({ preventScroll: true }));
        }
    }
}
IgxFocusDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'igxFocus',
                selector: '[igxFocus]'
            },] }
];
IgxFocusDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Array, decorators: [{ type: Inject, args: [NG_VALUE_ACCESSOR,] }, { type: Self }, { type: Optional }] }
];
IgxFocusDirective.propDecorators = {
    focused: [{ type: Input, args: ['igxFocus',] }]
};
/**
 * @hidden
 */
class IgxFocusModule {
}
IgxFocusModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxFocusDirective],
                exports: [IgxFocusDirective]
            },] }
];

class IgxLayoutDirective {
    constructor() {
        /**
         * Sets the default flow direction of the container's children.
         *
         * Defaults to `rows`.
         *
         * ```html
         *  <div
         *   igxLayout
         *   igxLayoutDir="row">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         *  </div>
         * ```
         */
        this.dir = 'row';
        /**
         * Defines the direction flex children are placed in the flex container.
         *
         * When set to `true`, the `rows` direction goes right to left and `columns` goes bottom to top.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutReverse="true">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         * </div>
         * ```
         */
        this.reverse = false;
        /**
         * By default the immediate children will all try to fit onto one line.
         *
         * The default value `nowrap` sets this behavior.
         *
         * Other accepted values are `wrap` and `wrap-reverse`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="row"
         *   igxLayoutWrap="wrap">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */
        this.wrap = 'nowrap';
        /**
         * Defines the alignment along the main axis.
         *
         * Defaults to `flex-start` which packs the children toward the start line.
         *
         * Other possible values are `flex-end`, `center`, `space-between`, `space-around`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutJustify="space-between">
         *    <div>1</div>
         *    <div>2</div>
         *    <div>3</div>
         * </div>
         * ```
         */
        this.justify = 'flex-start';
        /**
         * Defines the default behavior for how children are laid out along the corss axis of the current line.
         *
         * Defaults to `flex-start`.
         *
         * Other possible values are `flex-end`, `center`, `baseline`, and `stretch`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutItemAlign="start">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */
        this.itemAlign = 'stretch';
        /**
         * @hidden
         */
        this.display = 'flex';
    }
    /**
     * @hidden
     */
    get flexwrap() {
        return this.wrap;
    }
    /**
     * @hidden
     */
    get justifycontent() {
        return this.justify;
    }
    /**
     * @hidden
     */
    get align() {
        return this.itemAlign;
    }
    /**
     * @hidden
     */
    get direction() {
        if (this.reverse) {
            return (this.dir === 'row') ? 'row-reverse' : 'column-reverse';
        }
        return (this.dir === 'row') ? 'row' : 'column';
    }
}
IgxLayoutDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxLayout]'
            },] }
];
IgxLayoutDirective.propDecorators = {
    dir: [{ type: Input, args: ['igxLayoutDir',] }],
    reverse: [{ type: Input, args: ['igxLayoutReverse',] }],
    wrap: [{ type: Input, args: ['igxLayoutWrap',] }],
    justify: [{ type: Input, args: ['igxLayoutJustify',] }],
    itemAlign: [{ type: Input, args: ['igxLayoutItemAlign',] }],
    display: [{ type: HostBinding, args: ['style.display',] }],
    flexwrap: [{ type: HostBinding, args: ['style.flex-wrap',] }],
    justifycontent: [{ type: HostBinding, args: ['style.justify-content',] }],
    align: [{ type: HostBinding, args: ['style.align-items',] }],
    direction: [{ type: HostBinding, args: ['style.flex-direction',] }]
};
class IgxFlexDirective {
    constructor() {
        /**
         * Applies the `grow` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexGrow="0">Content1</div>
         *    <div igxFlex igxFlexGrow="1">Content2</div>
         *    <div igxFlex igxFlexGrow="0">Content3</div>
         * </div>
         * ```
         */
        this.grow = 1;
        /**
         * Applies the `shrink` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexShrink="1">Content1</div>
         *    <div igxFlex igxFlexShrink="0">Content2</div>
         *    <div igxFlex igxFlexShrink="1">Content3</div>
         * </div>
         * ```
         */
        this.shrink = 1;
        /**
         * Applies the directive to an element.
         *
         * Possible values include `igxFlexGrow`, `igxFlexShrink`, `igxFlexOrder`, `igxFlexBasis`.
         *
         * ```html
         * <div igxFlex>Content</div>
         * ```
         */
        this.flex = '';
        /**
         * Applies the `order` attribute to an element that uses the directive.
         *
         * Default value is `0`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexOrder="1">Content1</div>
         *    <div igxFlex igxFlexOrder="0">Content2</div>
         *    <div igxFlex igxFlexOrder="2">Content3</div>
         * </div>
         * ```
         */
        this.order = 0;
        /**
         * Applies the `flex-basis` attribute to an element that uses the directive.
         *
         * Default value is `auto`.
         *
         * Other possible values include `content`, `max-content`, `min-content`, `fit-content`.
         *
         * ```html
         * <div igxFlex igxFlexBasis="fit-content">Content</div>
         * ```
         */
        this.basis = 'auto';
    }
    /**
     * @hidden
     */
    get style() {
        if (this.flex) {
            return `${this.flex}`;
        }
        return `${this.grow} ${this.shrink} ${this.basis}`;
    }
    /**
     * @hidden
     */
    get itemorder() {
        return this.order || 0;
    }
}
IgxFlexDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxFlex]'
            },] }
];
IgxFlexDirective.propDecorators = {
    grow: [{ type: Input, args: ['igxFlexGrow',] }],
    shrink: [{ type: Input, args: ['igxFlexShrink',] }],
    flex: [{ type: Input, args: ['igxFlex',] }],
    order: [{ type: Input, args: ['igxFlexOrder',] }],
    basis: [{ type: Input, args: ['igxFlexBasis',] }],
    style: [{ type: HostBinding, args: ['style.flex',] }],
    itemorder: [{ type: HostBinding, args: ['style.order',] }]
};
/**
 * @hidden
 */
class IgxLayoutModule {
}
IgxLayoutModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxFlexDirective, IgxLayoutDirective],
                exports: [IgxFlexDirective, IgxLayoutDirective]
            },] }
];

/** @hidden */
const MASK_FLAGS = ['C', '&', 'a', 'A', '?', 'L', '9', '0', '#'];
/** @hidden */
class MaskParsingService {
    applyMask(inputVal, maskOptions) {
        let outputVal = '';
        let value = '';
        const mask = maskOptions.format;
        const literals = this.getMaskLiterals(mask);
        const literalKeys = Array.from(literals.keys());
        const nonLiteralIndices = this.getNonLiteralIndices(mask, literalKeys);
        const literalValues = Array.from(literals.values());
        if (inputVal != null) {
            value = inputVal.toString();
        }
        for (const maskSym of mask) {
            outputVal += maskOptions.promptChar;
        }
        literals.forEach((val, key) => {
            outputVal = this.replaceCharAt(outputVal, key, val);
        });
        if (!value) {
            return outputVal;
        }
        const nonLiteralValues = this.getNonLiteralValues(value, literalValues);
        for (let i = 0; i < nonLiteralValues.length; i++) {
            const char = nonLiteralValues[i];
            const isCharValid = this.validateCharOnPosition(char, nonLiteralIndices[i], mask);
            if (!isCharValid && char !== maskOptions.promptChar) {
                nonLiteralValues[i] = maskOptions.promptChar;
            }
        }
        if (nonLiteralValues.length > nonLiteralIndices.length) {
            nonLiteralValues.splice(nonLiteralIndices.length);
        }
        let pos = 0;
        for (const nonLiteralValue of nonLiteralValues) {
            const char = nonLiteralValue;
            outputVal = this.replaceCharAt(outputVal, nonLiteralIndices[pos++], char);
        }
        return outputVal;
    }
    parseValueFromMask(maskedValue, maskOptions) {
        let outputVal = '';
        const mask = maskOptions.format;
        const literals = this.getMaskLiterals(mask);
        const literalValues = Array.from(literals.values());
        for (const val of maskedValue) {
            if (literalValues.indexOf(val) === -1) {
                if (val !== maskOptions.promptChar) {
                    outputVal += val;
                }
            }
        }
        return outputVal;
    }
    replaceInMask(maskedValue, value, maskOptions, start, end) {
        const literalsPositions = Array.from(this.getMaskLiterals(maskOptions.format).keys());
        const chars = Array.from(value);
        let cursor = start;
        end = Math.min(end, maskedValue.length);
        for (let i = start; i < end || (chars.length && i < maskedValue.length); i++) {
            if (literalsPositions.indexOf(i) !== -1) {
                if (chars[0] === maskedValue[i]) {
                    cursor = i + 1;
                    chars.shift();
                }
                continue;
            }
            if (chars[0]
                && !this.validateCharOnPosition(chars[0], i, maskOptions.format)
                && chars[0] !== maskOptions.promptChar) {
                break;
            }
            let char = maskOptions.promptChar;
            if (chars.length) {
                cursor = i + 1;
                char = chars.shift();
            }
            maskedValue = this.replaceCharAt(maskedValue, i, char);
        }
        return { value: maskedValue, end: cursor };
    }
    replaceCharAt(strValue, index, char) {
        if (strValue !== undefined) {
            return strValue.substring(0, index) + char + strValue.substring(index + 1);
        }
    }
    /** Validates only non literal positions. */
    validateCharOnPosition(inputChar, position, mask) {
        let regex;
        let isValid;
        const letterOrDigitRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
        const letterDigitOrSpaceRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
        const letterRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
        const letterSpaceRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
        const digitRegEx = '[\\d]';
        const digitSpaceRegEx = '[\\d\\u0020]';
        const digitSpecialRegEx = '[\\d-\\+]';
        switch (mask.charAt(position)) {
            case 'C':
                isValid = inputChar !== '';
                break;
            case '&':
                regex = new RegExp('[\\u0020]');
                isValid = !regex.test(inputChar);
                break;
            case 'a':
                regex = new RegExp(letterDigitOrSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case 'A':
                regex = new RegExp(letterOrDigitRegEx);
                isValid = regex.test(inputChar);
                break;
            case '?':
                regex = new RegExp(letterSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case 'L':
                regex = new RegExp(letterRegEx);
                isValid = regex.test(inputChar);
                break;
            case '0':
                regex = new RegExp(digitRegEx);
                isValid = regex.test(inputChar);
                break;
            case '9':
                regex = new RegExp(digitSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case '#':
                regex = new RegExp(digitSpecialRegEx);
                isValid = regex.test(inputChar);
                break;
            default: {
                isValid = null;
            }
        }
        return isValid;
    }
    getMaskLiterals(mask) {
        const literals = new Map();
        for (let i = 0; i < mask.length; i++) {
            const char = mask.charAt(i);
            if (MASK_FLAGS.indexOf(char) === -1) {
                literals.set(i, char);
            }
        }
        return literals;
    }
    getNonLiteralIndices(mask, literalKeys) {
        const nonLiteralsIndices = new Array();
        for (let i = 0; i < mask.length; i++) {
            if (literalKeys.indexOf(i) === -1) {
                nonLiteralsIndices.push(i);
            }
        }
        return nonLiteralsIndices;
    }
    getNonLiteralValues(value, literalValues) {
        const nonLiteralValues = new Array();
        for (const val of value) {
            if (literalValues.indexOf(val) === -1) {
                nonLiteralValues.push(val);
            }
        }
        return nonLiteralValues;
    }
}
MaskParsingService.ɵprov = ɵɵdefineInjectable({ factory: function MaskParsingService_Factory() { return new MaskParsingService(); }, token: MaskParsingService, providedIn: "root" });
MaskParsingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];

class IgxMaskDirective {
    constructor(elementRef, maskParser, renderer) {
        this.elementRef = elementRef;
        this.maskParser = maskParser;
        this.renderer = renderer;
        /**
         * Sets the character representing a fillable spot in the input mask.
         * Default value is "'_'".
         * ```html
         * <input [promptChar] = "'/'">
         * ```
         */
        this.promptChar = '_';
        /**
         * Emits an event each time the value changes.
         * Provides `rawValue: string` and `formattedValue: string` as event arguments.
         * ```html
         * <input (onValueChange) = "onValueChange(rawValue: string, formattedValue: string)">
         * ```
         */
        this.onValueChange = new EventEmitter();
        this._end = 0;
        this._start = 0;
        this._oldText = '';
        this._dataValue = '';
        this._focused = false;
        this._onTouchedCallback = noop;
        this._onChangeCallback = noop;
    }
    /**
     * Specifies a placeholder.
     * ```html
     * <input placeholder = "enter text...">
     * ```
     */
    set placeholder(val) {
        this.renderer.setAttribute(this.nativeElement, 'placeholder', val);
    }
    get placeholder() {
        return this.nativeElement.placeholder;
    }
    /** @hidden */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /** @hidden @internal; */
    get inputValue() {
        return this.nativeElement.value;
    }
    /** @hidden @internal */
    set inputValue(val) {
        this.nativeElement.value = val;
    }
    /** @hidden */
    get maskOptions() {
        const format = this.mask || 'CCCCCCCCCC';
        const promptChar = this.promptChar && this.promptChar.substring(0, 1);
        return { format, promptChar };
    }
    /** @hidden */
    get selectionStart() {
        // Edge(classic) and FF don't select text on drop
        return this.nativeElement.selectionStart === this.nativeElement.selectionEnd && this._hasDropAction ?
            this.nativeElement.selectionEnd - this._droppedData.length :
            this.nativeElement.selectionStart;
    }
    /** @hidden */
    get selectionEnd() {
        return this.nativeElement.selectionEnd;
    }
    /** @hidden */
    get start() {
        return this._start;
    }
    /** @hidden */
    get end() {
        return this._end;
    }
    /** @hidden */
    onKeyDown(event) {
        const key = event.keyCode || event.charCode;
        if (!key) {
            return;
        }
        if (isIE() && this._stopPropagation) {
            this._stopPropagation = false;
        }
        if ((key === 17 /* CTRL */ && key === 90 /* Z */) || (key === 17 /* CTRL */ && key === 89 /* Y */)) {
            event.preventDefault();
        }
        this._key = key;
        this._start = this.selectionStart;
        this._end = this.selectionEnd;
    }
    /** @hidden */
    onInputChanged() {
        /**
         * '!this._focused' is a fix for #8165
         * On page load IE triggers input events before focus events and
         * it does so for every single input on the page.
         * The mask needs to be prevented from doing anything while this is happening because
         * the end user will be unable to blur the input.
         * https://stackoverflow.com/questions/21406138/input-event-triggered-on-internet-explorer-when-placeholder-changed
         */
        if (isIE() && (this._stopPropagation || !this._focused)) {
            this._stopPropagation = false;
            return;
        }
        if (this._hasDropAction) {
            this._start = this.selectionStart;
        }
        if (this.inputValue.length < this._oldText.length && this._key === 229 /* INPUT_METHOD */) {
            // software keyboard input delete
            this._key = 8 /* BACKSPACE */;
        }
        let valueToParse = '';
        switch (this._key) {
            case 46 /* DELETE */:
                this._end = this._start === this._end ? ++this._end : this._end;
                break;
            case 8 /* BACKSPACE */:
                this._start = this.selectionStart;
                break;
            default:
                valueToParse = this.inputValue.substring(this._start, this.selectionEnd);
                break;
        }
        const replacedData = this.maskParser.replaceInMask(this._oldText, valueToParse, this.maskOptions, this._start, this._end);
        this.inputValue = replacedData.value;
        if (this._key === 8 /* BACKSPACE */) {
            replacedData.end = this._start;
        }
        this.setSelectionRange(replacedData.end);
        const rawVal = this.maskParser.parseValueFromMask(this.inputValue, this.maskOptions);
        this._dataValue = this.includeLiterals ? this.inputValue : rawVal;
        this._onChangeCallback(this._dataValue);
        this.onValueChange.emit({ rawValue: rawVal, formattedValue: this.inputValue });
        this.afterInput();
    }
    /** @hidden */
    onPaste() {
        this._oldText = this.inputValue;
        this._start = this.selectionStart;
    }
    /** @hidden */
    onFocus() {
        this._focused = true;
        this.showMask(this._dataValue);
    }
    /** @hidden */
    onBlur(value) {
        this._focused = false;
        this.showDisplayValue(value);
        this._onTouchedCallback();
    }
    /** @hidden */
    onDragEnter() {
        if (!this._focused) {
            this.showMask(this._dataValue);
        }
    }
    /** @hidden */
    onDragLeave() {
        if (!this._focused) {
            this.showDisplayValue(this.inputValue);
        }
    }
    /** @hidden */
    onDrop(event) {
        this._hasDropAction = true;
        this._droppedData = event.dataTransfer.getData('text');
    }
    /** @hidden */
    ngOnInit() {
        if (!this.nativeElement.placeholder) {
            this.renderer.setAttribute(this.nativeElement, 'placeholder', this.maskOptions.format);
        }
    }
    /**
     * TODO: Remove after date/time picker integration refactor
     *
     * @hidden
     */
    ngAfterViewChecked() {
        this._oldText = this.inputValue;
    }
    /** @hidden */
    writeValue(value) {
        if (this.promptChar && this.promptChar.length > 1) {
            this.maskOptions.promptChar = this.promptChar.substring(0, 1);
        }
        this.inputValue = value ? this.maskParser.applyMask(value, this.maskOptions) : '';
        if (this.displayValuePipe) {
            this.inputValue = this.displayValuePipe.transform(this.inputValue);
        }
        this._dataValue = this.includeLiterals ? this.inputValue : value;
        this.onValueChange.emit({ rawValue: value, formattedValue: this.inputValue });
    }
    /** @hidden */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /** @hidden */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /** @hidden */
    showMask(value) {
        if (this.focusedValuePipe) {
            if (isIE()) {
                this._stopPropagation = true;
            }
            // TODO(D.P.): focusedValuePipe should be deprecated or force-checked to match mask format
            this.inputValue = this.focusedValuePipe.transform(value);
        }
        else {
            this.inputValue = this.maskParser.applyMask(this.inputValue, this.maskOptions);
        }
        this._oldText = this.inputValue;
    }
    /** @hidden */
    setSelectionRange(start, end = start) {
        this.nativeElement.setSelectionRange(start, end);
    }
    /** @hidden */
    afterInput() {
        this._oldText = this.inputValue;
        this._hasDropAction = false;
        this._start = 0;
        this._end = 0;
        this._key = null;
    }
    showDisplayValue(value) {
        if (this.displayValuePipe) {
            this.inputValue = this.displayValuePipe.transform(value);
        }
        else if (value === this.maskParser.applyMask(null, this.maskOptions)) {
            this.inputValue = '';
        }
    }
}
IgxMaskDirective.decorators = [
    { type: Directive, args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxMaskDirective, multi: true }],
                selector: '[igxMask]',
                exportAs: 'igxMask'
            },] }
];
IgxMaskDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: MaskParsingService },
    { type: Renderer2 }
];
IgxMaskDirective.propDecorators = {
    mask: [{ type: Input, args: ['igxMask',] }],
    promptChar: [{ type: Input }],
    includeLiterals: [{ type: Input }],
    displayValuePipe: [{ type: Input }],
    focusedValuePipe: [{ type: Input }],
    onValueChange: [{ type: Output }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onInputChanged: [{ type: HostListener, args: ['input',] }],
    onPaste: [{ type: HostListener, args: ['paste',] }],
    onFocus: [{ type: HostListener, args: ['focus',] }],
    onBlur: [{ type: HostListener, args: ['blur', ['$event.target.value'],] }],
    onDragEnter: [{ type: HostListener, args: ['dragenter',] }],
    onDragLeave: [{ type: HostListener, args: ['dragleave',] }],
    onDrop: [{ type: HostListener, args: ['drop', ['$event'],] }]
};
__decorate([
    DeprecateProperty('"placeholder" is deprecated, use native placeholder instead.')
], IgxMaskDirective.prototype, "placeholder", null);
/** @hidden */
class IgxMaskModule {
}
IgxMaskModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxMaskDirective],
                exports: [IgxMaskDirective],
                imports: [CommonModule]
            },] }
];

const RadioLabelPosition = mkenum({
    BEFORE: 'before',
    AFTER: 'after'
});
let nextId = 0;
/**
 * **Ignite UI for Angular Radio Button** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/radio_button.html)
 *
 * The Ignite UI Radio Button allows the user to select a single option from an available set of options that are listed side by side.
 *
 * Example:
 * ```html
 * <igx-radio>
 *   Simple radio button
 * </igx-radio>
 * ```
 */
class IgxRadioComponent {
    constructor(cdr) {
        this.cdr = cdr;
        /**
         * Sets/gets the `id` of the radio component.
         * If not set, the `id` of the first radio component will be `"igx-radio-0"`.
         * ```html
         * <igx-radio id = "my-first-radio"></igx-radio>
         * ```
         * ```typescript
         * let radioId =  this.radio.id;
         * ```
         *
         * @memberof IgxRadioComponent
         */
        this.id = `igx-radio-${nextId++}`;
        /**
         * Sets/gets the id of the `label` element in the radio component.
         * If not set, the id of the `label` in the first radio component will be `"igx-radio-0-label"`.
         * ```html
         * <igx-radio labelId = "Label1"></igx-radio>
         * ```
         * ```typescript
         * let labelId =  this.radio.labelId;
         * ```
         *
         * @memberof IgxRadioComponent
         */
        this.labelId = `${this.id}-label`;
        /**
         * Sets/gets the position of the `label` in the radio component.
         * If not set, `labelPosition` will have value `"after"`.
         * ```html
         * <igx-radio labelPosition = "before"></igx-radio>
         * ```
         * ```typescript
         * let labelPosition =  this.radio.labelPosition;
         * ```
         *
         * @memberof IgxRadioComponent
         */
        this.labelPosition = 'after';
        /**
         * Sets the value of the `tabindex` attribute.
         * ```html
         * <igx-radio [tabindex] = "1"></igx-radio>
         * ```
         * ```typescript
         * let tabIndex =  this.radio.tabindex;
         * ```
         *
         * @memberof IgxRadioComponent
         */
        this.tabindex = null;
        /**
         * Enables/disables the ripple effect on the radio button..
         * If not set, the `disableRipple` will have value `false`.
         * ```html
         * <igx-radio [disableRipple] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isDisabledRipple =  this.radio.disableRipple;
         * ```
         *
         * @memberof IgxRadioComponent
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether the radio button is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-radio [required] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isRequired =  this.radio.required;
         * ```
         *
         * @memberof IgxRadioComponent
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledby` attribute of the radio component.
         * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
         * ```html
         * <igx-radio aria-labelledby = "Radio1"></igx-radio>
         * ```
         * ```typescript
         * let ariaLabelledBy = this.radio.ariaLabelledBy;
         * ```
         *
         * @memberof IgxRadioComponent
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the `aria-label` attribute of the radio component.
         * ```html
         * <igx-radio aria-label = "Radio1"></igx-radio>
         * ```
         * ```typescript
         * let ariaLabel =  this.radio.ariaLabel;
         * ```
         *
         * @memberof IgxRadioComponent
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the radio `value` is changed.
         * Provides references to the `IgxRadioComponent` and the `value` property as event arguments.
         *
         * @memberof IgxRadioComponent
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.change = new EventEmitter();
        /**
         * Returns the class of the radio component.
         * ```typescript
         * let radioClass = this.radio.cssClass;
         * ```
         *
         * @memberof IgxRadioComponent
         */
        this.cssClass = 'igx-radio';
        /**
         * Sets/gets  the `checked` attribute.
         * Default value is `false`.
         * ```html
         * <igx-radio [checked] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isChecked =  this.radio.checked;
         * ```
         *
         * @memberof IgxRadioComponent
         */
        this.checked = false;
        /**
         * Sets/gets  the `disabled` attribute.
         * Default value is `false`.
         * ```html
         * <igx-radio [disabled] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isDisabled =  this.radio.disabled;
         * ```
         *
         * @memberof IgxRadioComponent
         */
        this.disabled = false;
        /**
         * Sets/gets whether the radio component is on focus.
         * Default value is `false`.
         * ```typescript
         * this.radio.focus = true;
         * ```
         * ```typescript
         * let isFocused =  this.radio.focused;
         * ```
         *
         * @memberof IgxRadioComponent
         */
        this.focused = false;
        /**
         * @hidden
         */
        this.inputId = `${this.id}-input`;
        /**
         * @hidden
         */
        this._onTouchedCallback = noop;
        /**
         * @hidden
         */
        this._onChangeCallback = noop;
    }
    /**
     * @hidden
     * @internal
     */
    onKeyUp(event) {
        event.stopPropagation();
        this.focused = true;
        this.select();
    }
    /**
     * @hidden
     */
    _clicked(event) {
        event.stopPropagation();
        this.select();
    }
    /**
     * Selects the current radio button.
     * ```typescript
     * this.radio.select();
     * ```
     *
     * @memberof IgxRadioComponent
     */
    select() {
        this.nativeRadio.nativeElement.focus();
        if (isIE()) {
            this.nativeRadio.nativeElement.blur();
        }
        if (!this.checked) {
            this.checked = true;
            this.change.emit({ value: this.value, radio: this });
            this._onChangeCallback(this.value);
        }
    }
    /**
     * Deselects the current radio button.
     * ```typescript
     * this.radio.deselect();
     * ```
     *
     * @memberof IgxRadioComponent
     */
    deselect() {
        this.checked = false;
        this.focused = false;
        this.cdr.markForCheck();
    }
    /**
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true`;
     * ```typescript
     * this.radio.writeValue('radioButtonValue');
     * ```
     */
    writeValue(value) {
        this.value = this.value || value;
        if (value === this.value) {
            this.select();
        }
        else {
            this.deselect();
        }
    }
    /** @hidden */
    getEditElement() {
        return this.nativeRadio.nativeElement;
    }
    /**
     * @hidden
     */
    get labelClass() {
        switch (this.labelPosition) {
            case RadioLabelPosition.BEFORE:
                return `${this.cssClass}__label--before`;
            case RadioLabelPosition.AFTER:
            default:
                return `${this.cssClass}__label`;
        }
    }
    /**
     * @hidden
     */
    onBlur() {
        this.focused = false;
        this._onTouchedCallback();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
}
IgxRadioComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxRadioComponent,
                        multi: true,
                    },
                ],
                selector: 'igx-radio',
                template: "<input #radio class=\"igx-radio__input\" type=\"radio\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (blur)=\"onBlur()\" />\n\n<label #nativeLabel class=\"igx-radio__composite\" igxRipple\n    (click)=\"_clicked($event)\"\n    igxRippleTarget=\".igx-radio__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    [for]=\"inputId\">\n    <div class=\"igx-radio__ripple\"></div>\n</label>\n\n<span #placeholderLabel\n    (click)=\"_clicked($event)\"\n    [id]=\"labelId\"\n    [class]=\"labelClass\">\n    <ng-content></ng-content>\n</span>\n"
            },] }
];
IgxRadioComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
IgxRadioComponent.propDecorators = {
    nativeRadio: [{ type: ViewChild, args: ['radio', { static: true },] }],
    nativeLabel: [{ type: ViewChild, args: ['nativeLabel', { static: true },] }],
    placeholderLabel: [{ type: ViewChild, args: ['placeholderLabel', { static: true },] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    labelId: [{ type: Input }],
    labelPosition: [{ type: Input }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    tabindex: [{ type: Input }],
    disableRipple: [{ type: Input }],
    required: [{ type: Input }],
    ariaLabelledBy: [{ type: Input, args: ['aria-labelledby',] }],
    ariaLabel: [{ type: Input, args: ['aria-label',] }],
    change: [{ type: Output }],
    cssClass: [{ type: HostBinding, args: ['class.igx-radio',] }],
    checked: [{ type: HostBinding, args: ['class.igx-radio--checked',] }, { type: Input }],
    disabled: [{ type: HostBinding, args: ['class.igx-radio--disabled',] }, { type: Input }],
    focused: [{ type: HostBinding, args: ['class.igx-radio--focused',] }],
    onKeyUp: [{ type: HostListener, args: ['keyup', ['$event'],] }]
};

class IgxRippleDirective {
    constructor(builder, elementRef, renderer, zone) {
        this.builder = builder;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        /**
         * Sets/gets the ripple target.
         * ```html
         * <div  #rippleContainer class="div-1" igxRipple [igxRippleTarget] = "'.div-1'"></div>
         * ```
         * ```typescript
         * @ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let rippleTarget = this.ripple.rippleTarget;
         * ```
         * Can set the ripple to activate on a child element inside the parent where igxRipple is defined.
         * ```html
         * <div #rippleContainer [igxRippleTarget] = "'#child"'>
         *  <button id="child">Click</button>
         * </div>
         * ```
         *
         * @memberof IgxRippleDirective
         */
        this.rippleTarget = '';
        /**
         * Sets/gets the ripple duration(in milliseconds).
         * Default value is `600`.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleDuration] = "800"></button>
         * ```
         * ```typescript
         * @ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let rippleDuration = this.ripple.rippleDuration;
         * ```
         *
         * @memberof IgxRippleDirective
         */
        this.rippleDuration = 600;
        /**
         * Sets/gets whether the ripple is disabled.
         * Default value is `false`.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleDisabled] = "true"></button>
         * ```
         * ```typescript
         * @ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let isRippleDisabled = this.ripple.rippleDisabled;
         * ```
         *
         * @memberof IgxRippleDirective
         */
        this.rippleDisabled = false;
        this.rippleElementClass = 'igx-ripple__inner';
        this.rippleHostClass = 'igx-ripple';
        this._centered = false;
        this.animationQueue = [];
    }
    /**
     * Enables/disables the ripple to be centered.
     * ```html
     * <button #rippleContainer igxRipple [igxRippleCentered] = "true"></button>
     * ```
     *
     * @memberof IgxRippleDirective
     */
    set centered(value) {
        this._centered = value || this.centered;
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    onMouseDown(event) {
        this.zone.runOutsideAngular(() => this._ripple(event));
    }
    setStyles(rippleElement, styleParams) {
        this.renderer.addClass(rippleElement, this.rippleElementClass);
        this.renderer.setStyle(rippleElement, 'width', `${styleParams.radius}px`);
        this.renderer.setStyle(rippleElement, 'height', `${styleParams.radius}px`);
        this.renderer.setStyle(rippleElement, 'top', `${styleParams.top}px`);
        this.renderer.setStyle(rippleElement, 'left', `${styleParams.left}px`);
        if (this.rippleColor) {
            this.renderer.setStyle(rippleElement, 'background', this.rippleColor);
        }
    }
    _ripple(event) {
        if (this.rippleDisabled) {
            return;
        }
        const target = (this.rippleTarget ? this.nativeElement.querySelector(this.rippleTarget) || this.nativeElement : this.nativeElement);
        const rectBounds = target.getBoundingClientRect();
        const radius = Math.max(rectBounds.width, rectBounds.height);
        let left = Math.round(event.clientX - rectBounds.left - radius / 2);
        let top = Math.round(event.clientY - rectBounds.top - radius / 2);
        if (this._centered) {
            left = top = 0;
        }
        const dimensions = {
            radius,
            top,
            left
        };
        const rippleElement = this.renderer.createElement('span');
        this.setStyles(rippleElement, dimensions);
        this.renderer.addClass(target, this.rippleHostClass);
        this.renderer.appendChild(target, rippleElement);
        const animation = this.builder.build([
            style({ opacity: 0.5, transform: 'scale(.3)' }),
            animate(this.rippleDuration, style({ opacity: 0, transform: 'scale(2)' }))
        ]).create(rippleElement);
        this.animationQueue.push(animation);
        animation.onDone(() => {
            this.animationQueue.splice(this.animationQueue.indexOf(animation), 1);
            target.removeChild(rippleElement);
            if (this.animationQueue.length < 1) {
                this.renderer.removeClass(target, this.rippleHostClass);
            }
        });
        animation.play();
    }
}
IgxRippleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxRipple]'
            },] }
];
IgxRippleDirective.ctorParameters = () => [
    { type: AnimationBuilder },
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
IgxRippleDirective.propDecorators = {
    rippleTarget: [{ type: Input, args: ['igxRippleTarget',] }],
    rippleColor: [{ type: Input, args: ['igxRipple',] }],
    rippleDuration: [{ type: Input, args: ['igxRippleDuration',] }],
    centered: [{ type: Input, args: ['igxRippleCentered',] }],
    rippleDisabled: [{ type: Input, args: ['igxRippleDisabled',] }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxRippleModule {
}
IgxRippleModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxRippleDirective],
                exports: [IgxRippleDirective]
            },] }
];

/**
 * Determines the Radio Group alignment
 */
const RadioGroupAlignment = mkenum({
    horizontal: 'horizontal',
    vertical: 'vertical'
});
let nextId$1 = 0;
/**
 * Radio group directive renders set of radio buttons.
 *
 * @igxModule IgxRadioModule
 *
 * @igxTheme igx-radio-theme
 *
 * @igxKeywords radiogroup, radio, button, input
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 * The Ignite UI Radio Group allows the user to select a single option from an available set of options that are listed side by side.
 *
 * @example:
 * ```html
 * <igx-radio-group name="radioGroup">
 *   <igx-radio *ngFor="let item of ['Foo', 'Bar', 'Baz']" value="{{item}}">
 *      {{item}}
 *   </igx-radio>
 * </igx-radio-group>
 * ```
 */
class IgxRadioGroupDirective {
    constructor() {
        /**
         * An event that is emitted after the radio group `value` is changed.
         *
         * @remarks
         * Provides references to the selected `IgxRadioComponent` and the `value` property as event arguments.
         *
         * @example
         * ```html
         * <igx-radio-group (change)="handler($event)"></igx-radio-group>
         * ```
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.change = new EventEmitter();
        /**
         * The css class applied to the component.
         *
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-radio-group';
        /**
         * Sets vertical alignment to the radio group, if `alignment` is set to `vertical`.
         * By default the alignment is horizontal.
         *
         * @example
         * ```html
         * <igx-radio-group alignment="vertical"></igx-radio-group>
         * ```
         */
        this.vertical = false;
        /**
         * @hidden
         * @internal
         */
        this._onChangeCallback = noop;
        /**
         * @hidden
         * @internal
         */
        this._name = `igx-radio-group-${nextId$1++}`;
        /**
         * @hidden
         * @internal
         */
        this._value = null;
        /**
         * @hidden
         * @internal
         */
        this._selected = null;
        /**
         * @hidden
         * @internal
         */
        this._isInitialized = false;
        /**
         * @hidden
         * @internal
         */
        this._labelPosition = 'after';
        /**
         * @hidden
         * @internal
         */
        this._disabled = false;
        /**
         * @hidden
         * @internal
         */
        this._required = false;
        /**
         * @hidden
         * @internal
         */
        this.destroy$ = new Subject();
    }
    /**
     * Sets/gets the `value` attribute.
     *
     * @example
     * ```html
     * <igx-radio-group [value] = "'radioButtonValue'"></igx-radio-group>
     * ```
     */
    get value() {
        return this._value;
    }
    set value(newValue) {
        if (this._value !== newValue) {
            this._value = newValue;
            this._selectRadioButton();
        }
    }
    /**
     * Sets/gets the `name` attribute of the radio group component. All child radio buttons inherits this name.
     *
     * @example
     * ```html
     * <igx-radio-group name = "Radio1"></igx-radio-group>
     *  ```
     */
    get name() {
        return this._name;
    }
    set name(newValue) {
        if (this._name !== newValue) {
            this._name = newValue;
            this._setRadioButtonNames();
        }
    }
    /**
     * Sets/gets whether the radio group is required.
     *
     * @remarks
     * If not set, `required` will have value `false`.
     *
     * @example
     * ```html
     * <igx-radio-group [required] = "true"></igx-radio-group>
     * ```
     */
    get required() {
        return this._required;
    }
    set required(newValue) {
        if (this._required !== newValue) {
            this._required = newValue;
            this._setRadioButtonsRequired();
        }
    }
    /**
     * An @Input property that allows you to disable the radio group. By default it's false.
     *
     * @example
     *  ```html
     * <igx-radio-group [disabled]="true"></igx-radio-group>
     * ```
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(newValue) {
        if (this._disabled !== newValue) {
            this._disabled = newValue;
            this.setDisabledState(newValue);
        }
    }
    /**
     * Sets/gets the position of the `label` in the child radio buttons.
     *
     * @remarks
     * If not set, `labelPosition` will have value `"after"`.
     *
     * @example
     * ```html
     * <igx-radio-group labelPosition = "before"></igx-radio-group>
     * ```
     */
    get labelPosition() {
        return this._labelPosition;
    }
    set labelPosition(newValue) {
        if (this._labelPosition !== newValue) {
            this._labelPosition = newValue === RadioLabelPosition.BEFORE ? RadioLabelPosition.BEFORE : RadioLabelPosition.AFTER;
            this._setRadioButtonLabelPosition();
        }
    }
    /**
     * Sets/gets the selected child radio button.
     *
     * @example
     * ```typescript
     * let selectedButton = this.radioGroup.selected;
     * this.radioGroup.selected = selectedButton;
     * ```
     */
    get selected() {
        return this._selected;
    }
    set selected(selected) {
        if (this._selected !== selected) {
            this._selected = selected;
            this.value = selected ? selected.value : null;
        }
    }
    /**
     * Returns the alignment of the `igx-radio-group`.
     * ```typescript
     * @ViewChild("MyRadioGroup")
     * public radioGroup: IgxRadioGroupDirective;
     * ngAfterViewInit(){
     *    let radioAlignment = this.radioGroup.alignment;
     * }
     * ```
     */
    get alignment() {
        return this.vertical ? RadioGroupAlignment.vertical : RadioGroupAlignment.horizontal;
    }
    /**
     * Allows you to set the radio group alignment.
     * Available options are `RadioGroupAlignment.horizontal` (default) and `RadioGroupAlignment.vertical`.
     * ```typescript
     * public alignment = RadioGroupAlignment.vertical;
     * //..
     * ```
     * ```html
     * <igx-radio-group [alignment]="alignment"></igx-radio-group>
     * ```
     */
    set alignment(value) {
        this.vertical = value === RadioGroupAlignment.vertical;
    }
    /**
     * @hidden
     * @internal
     */
    ngAfterContentInit() {
        // The initial value can possibly be set by NgModel and it is possible that
        // the OnInit of the NgModel occurs after the OnInit of this class.
        this._isInitialized = true;
        setTimeout(() => {
            this._initRadioButtons();
        });
    }
    /**
     * Sets the "checked" property value on the radio input element.
     *
     * @remarks
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true` and selected property will contain the selected `IgxRadioComponent`.
     *
     * @example
     * ```typescript
     * this.radioGroup.writeValue('radioButtonValue');
     * ```
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * Registers a function called when the control value changes.
     *
     * @hidden
     * @internal
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     * @internal
     */
    setDisabledState(isDisabled) {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.disabled = isDisabled;
            });
        }
    }
    /**
     * Registers a function called when the control is touched.
     *
     * @hidden
     * @internal
     */
    registerOnTouched(fn) {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.registerOnTouched(fn);
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     * @internal
     */
    _initRadioButtons() {
        if (this.radioButtons) {
            const props = { name: this._name, labelPosition: this._labelPosition, disabled: this._disabled, required: this._required };
            this.radioButtons.forEach((button) => {
                Object.assign(button, props);
                if (button.value === this._value) {
                    button.checked = true;
                    this._selected = button;
                }
                button.change.pipe(takeUntil(this.destroy$)).subscribe((ev) => this._selectedRadioButtonChanged(ev));
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _selectedRadioButtonChanged(args) {
        this.radioButtons.forEach(button => {
            button.checked = button.id === args.radio.id;
        });
        this._selected = args.radio;
        this._value = args.value;
        if (this._isInitialized) {
            this.change.emit(args);
            this._onChangeCallback(this.value);
        }
    }
    /**
     * @hidden
     * @internal
     */
    _setRadioButtonNames() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.name = this._name;
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _selectRadioButton() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                if (!this._value) {
                    // no value - uncheck all radio buttons
                    if (button.checked) {
                        button.checked = false;
                    }
                }
                else {
                    if (this._value === button.value) {
                        // selected button
                        if (this._selected !== button) {
                            this._selected = button;
                        }
                        if (!button.checked) {
                            button.select();
                        }
                    }
                    else {
                        // non-selected button
                        if (button.checked) {
                            button.checked = false;
                        }
                    }
                }
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _setRadioButtonLabelPosition() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.labelPosition = this._labelPosition;
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _setRadioButtonsRequired() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.required = this._required;
            });
        }
    }
}
IgxRadioGroupDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'igxRadioGroup',
                selector: 'igx-radio-group, [igxRadioGroup]',
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxRadioGroupDirective, multi: true }]
            },] }
];
IgxRadioGroupDirective.propDecorators = {
    radioButtons: [{ type: ContentChildren, args: [IgxRadioComponent, { descendants: true },] }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    required: [{ type: Input }],
    disabled: [{ type: Input }],
    labelPosition: [{ type: Input }],
    selected: [{ type: Input }],
    change: [{ type: Output }],
    cssClass: [{ type: HostBinding, args: ['class.igx-radio-group',] }],
    vertical: [{ type: HostBinding, args: ['class.igx-radio-group--vertical',] }],
    alignment: [{ type: Input }]
};
/**
 * @hidden
 */
class IgxRadioModule {
}
IgxRadioModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxRadioGroupDirective, IgxRadioComponent],
                exports: [IgxRadioGroupDirective, IgxRadioComponent],
                imports: [IgxRippleModule]
            },] }
];

class IgxTextHighlightDirective {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        /**
         * Identifies the highlight within a unique group.
         * This allows it to have several different highlight groups,
         * with each of them having their own active highlight.
         *
         * ```html
         * <div
         *   igxTextHighlight
         *   [groupName]="myGroupName">
         * </div>
         * ```
         */
        this.groupName = '';
        this.destroy$ = new Subject();
        this._value = '';
        this._div = null;
        this._observer = null;
        this._nodeWasRemoved = false;
        this._forceEvaluation = false;
        this._activeElementIndex = -1;
        this._defaultCssClass = 'igx-highlight';
        this._defaultActiveCssClass = 'igx-highlight--active';
        IgxTextHighlightDirective.onActiveElementChanged.pipe(takeUntil(this.destroy$)).subscribe((groupName) => {
            if (this.groupName === groupName) {
                if (this._activeElementIndex !== -1) {
                    this.deactivate();
                }
                this.activateIfNecessary();
            }
        });
    }
    /**
     * The underlying value of the element that will be highlighted.
     *
     * ```typescript
     * // get
     * const elementValue = this.textHighlight.value;
     * ```
     *
     * ```html
     * <!--set-->
     * <div
     *   igxTextHighlight
     *   [value]="newValue">
     * </div>
     * ```
     */
    get value() {
        return this._value;
    }
    set value(value) {
        if (value === undefined || value === null) {
            this._value = '';
        }
        else {
            this._value = value;
        }
    }
    /**
     * @hidden
     */
    get lastSearchInfo() {
        return this._lastSearchInfo;
    }
    /**
     * Activates the highlight at a given index.
     * (if such index exists)
     */
    static setActiveHighlight(groupName, highlight) {
        IgxTextHighlightDirective.highlightGroupsMap.set(groupName, highlight);
        IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);
    }
    /**
     * Clears any existing highlight.
     */
    static clearActiveHighlight(groupName) {
        IgxTextHighlightDirective.highlightGroupsMap.set(groupName, {
            index: -1
        });
        IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.clearHighlight();
        if (this._observer !== null) {
            this._observer.disconnect();
        }
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (changes.value && !changes.value.firstChange) {
            this._valueChanged = true;
        }
        else if ((changes.row !== undefined && !changes.row.firstChange) ||
            (changes.column !== undefined && !changes.column.firstChange) ||
            (changes.page !== undefined && !changes.page.firstChange)) {
            if (this._activeElementIndex !== -1) {
                this.deactivate();
            }
            this.activateIfNecessary();
        }
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.parentElement = this.renderer.parentNode(this.element.nativeElement);
        if (IgxTextHighlightDirective.highlightGroupsMap.has(this.groupName) === false) {
            IgxTextHighlightDirective.highlightGroupsMap.set(this.groupName, {
                index: -1
            });
        }
        this._lastSearchInfo = {
            searchedText: '',
            content: this.value,
            matchCount: 0,
            caseSensitive: false,
            exactMatch: false
        };
        this._container = this.parentElement.firstElementChild;
    }
    /**
     * @hidden
     */
    ngAfterViewChecked() {
        if (this._valueChanged) {
            this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
            this.activateIfNecessary();
            this._valueChanged = false;
        }
    }
    /**
     * Clears the existing highlight and highlights the searched text.
     * Returns how many times the element contains the searched text.
     */
    highlight(text, caseSensitive, exactMatch) {
        const caseSensitiveResolved = caseSensitive ? true : false;
        const exactMatchResolved = exactMatch ? true : false;
        if (this.searchNeedsEvaluation(text, caseSensitiveResolved, exactMatchResolved)) {
            this._lastSearchInfo.searchedText = text;
            this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
            this._lastSearchInfo.exactMatch = exactMatchResolved;
            this._lastSearchInfo.content = this.value;
            if (text === '' || text === undefined || text === null) {
                this.clearHighlight();
            }
            else {
                this.clearChildElements(true);
                this._lastSearchInfo.matchCount = this.getHighlightedText(text, caseSensitive, exactMatch);
            }
        }
        else if (this._nodeWasRemoved) {
            this._lastSearchInfo.searchedText = text;
            this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
            this._lastSearchInfo.exactMatch = exactMatchResolved;
        }
        return this._lastSearchInfo.matchCount;
    }
    /**
     * Clears any existing highlight.
     */
    clearHighlight() {
        this.clearChildElements(false);
        this._lastSearchInfo.searchedText = '';
        this._lastSearchInfo.matchCount = 0;
    }
    /**
     * Activates the highlight if it is on the currently active row and column.
     */
    activateIfNecessary() {
        const group = IgxTextHighlightDirective.highlightGroupsMap.get(this.groupName);
        if (group.column === this.column && group.row === this.row && compareMaps(this.metadata, group.metadata)) {
            this.activate(group.index);
        }
    }
    /**
     * Attaches a MutationObserver to the parentElement and watches for when the container element is removed/readded to the DOM.
     * Should be used only when necessary as using many observers may lead to performance degradation.
     */
    observe() {
        if (this._observer === null) {
            const callback = (mutationList) => {
                mutationList.forEach((mutation) => {
                    const removedNodes = Array.from(mutation.removedNodes);
                    removedNodes.forEach((n) => {
                        if (n === this._container) {
                            this._nodeWasRemoved = true;
                            this.clearChildElements(false);
                        }
                    });
                    const addedNodes = Array.from(mutation.addedNodes);
                    addedNodes.forEach((n) => {
                        if (n === this.parentElement.firstElementChild && this._nodeWasRemoved) {
                            this._container = this.parentElement.firstElementChild;
                            this._nodeWasRemoved = false;
                            this._forceEvaluation = true;
                            this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
                            this._forceEvaluation = false;
                            this.activateIfNecessary();
                            this._observer.disconnect();
                            this._observer = null;
                        }
                    });
                });
            };
            this._observer = new MutationObserver(callback);
            this._observer.observe(this.parentElement, { childList: true });
        }
    }
    activate(index) {
        this.deactivate();
        if (this._div !== null) {
            const spans = this._div.querySelectorAll('span');
            this._activeElementIndex = index;
            if (spans.length <= index) {
                return;
            }
            const elementToActivate = spans[index];
            this.renderer.addClass(elementToActivate, this._defaultActiveCssClass);
            this.renderer.addClass(elementToActivate, this.activeCssClass);
        }
    }
    deactivate() {
        if (this._activeElementIndex === -1) {
            return;
        }
        const spans = this._div.querySelectorAll('span');
        if (spans.length <= this._activeElementIndex) {
            this._activeElementIndex = -1;
            return;
        }
        const elementToDeactivate = spans[this._activeElementIndex];
        this.renderer.removeClass(elementToDeactivate, this._defaultActiveCssClass);
        this.renderer.removeClass(elementToDeactivate, this.activeCssClass);
        this._activeElementIndex = -1;
    }
    clearChildElements(originalContentHidden) {
        this.renderer.setProperty(this.element.nativeElement, 'hidden', originalContentHidden);
        if (this._div !== null) {
            this.renderer.removeChild(this.parentElement, this._div);
            this._div = null;
            this._activeElementIndex = -1;
        }
    }
    getHighlightedText(searchText, caseSensitive, exactMatch) {
        this.appendDiv();
        const stringValue = String(this.value);
        const contentStringResolved = !caseSensitive ? stringValue.toLowerCase() : stringValue;
        const searchTextResolved = !caseSensitive ? searchText.toLowerCase() : searchText;
        let matchCount = 0;
        if (exactMatch) {
            if (contentStringResolved === searchTextResolved) {
                this.appendSpan(`<span class="${this._defaultCssClass} ${this.cssClass ? this.cssClass : ''}">${stringValue}</span>`);
                matchCount++;
            }
            else {
                this.appendText(stringValue);
            }
        }
        else {
            let foundIndex = contentStringResolved.indexOf(searchTextResolved, 0);
            let previousMatchEnd = 0;
            while (foundIndex !== -1) {
                const start = foundIndex;
                const end = foundIndex + searchTextResolved.length;
                this.appendText(stringValue.substring(previousMatchEnd, start));
                // eslint-disable-next-line max-len
                this.appendSpan(`<span class="${this._defaultCssClass} ${this.cssClass ? this.cssClass : ''}">${stringValue.substring(start, end)}</span>`);
                previousMatchEnd = end;
                matchCount++;
                foundIndex = contentStringResolved.indexOf(searchTextResolved, end);
            }
            this.appendText(stringValue.substring(previousMatchEnd, stringValue.length));
        }
        return matchCount;
    }
    appendText(text) {
        const textElement = this.renderer.createText(text);
        this.renderer.appendChild(this._div, textElement);
    }
    appendSpan(outerHTML) {
        const span = this.renderer.createElement('span');
        this.renderer.appendChild(this._div, span);
        this.renderer.setProperty(span, 'outerHTML', outerHTML);
    }
    appendDiv() {
        this._div = this.renderer.createElement('div');
        if (this.containerClass) {
            this.renderer.addClass(this._div, this.containerClass);
        }
        this.renderer.appendChild(this.parentElement, this._div);
    }
    searchNeedsEvaluation(text, caseSensitive, exactMatch) {
        const searchedText = this._lastSearchInfo.searchedText;
        return !this._nodeWasRemoved &&
            (searchedText === null ||
                searchedText !== text ||
                this._lastSearchInfo.content !== this.value ||
                this._lastSearchInfo.caseSensitive !== caseSensitive ||
                this._lastSearchInfo.exactMatch !== exactMatch ||
                this._forceEvaluation);
    }
}
IgxTextHighlightDirective.highlightGroupsMap = new Map();
IgxTextHighlightDirective.onActiveElementChanged = new EventEmitter();
IgxTextHighlightDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxTextHighlight]'
            },] }
];
IgxTextHighlightDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
IgxTextHighlightDirective.propDecorators = {
    cssClass: [{ type: Input, args: ['cssClass',] }],
    activeCssClass: [{ type: Input, args: ['activeCssClass',] }],
    containerClass: [{ type: Input, args: ['containerClass',] }],
    groupName: [{ type: Input, args: ['groupName',] }],
    value: [{ type: Input, args: ['value',] }],
    row: [{ type: Input, args: ['row',] }],
    column: [{ type: Input, args: ['column',] }],
    metadata: [{ type: Input }]
};
/**
 * @hidden
 */
class IgxTextHighlightModule {
}
IgxTextHighlightModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxTextHighlightDirective],
                exports: [IgxTextHighlightDirective]
            },] }
];

class IgxTextSelectionDirective {
    constructor(element) {
        this.element = element;
        this.selectionState = true;
    }
    /**
     * Returns whether the input element is selectable through the directive.
     *
     * ```typescript
     * // get
     * @ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public firstName: IgxTextSelectionDirective;
     *
     * public getFirstNameSelectionStatus() {
     *  return this.firstName.selected;
     * }
     * ```
     */
    get selected() {
        return this.selectionState;
    }
    /**
     *  Determines whether the input element could be selected through the directive.
     *
     * ```html
     * <!--set-->
     * <input
     *   type="text"
     *   id="firstName"
     *   [igxTextSelection]="true">
     * </input>
     *
     * <input
     *   type="text"
     *   id="lastName"
     *   igxTextSelection
     *   [selected]="true">
     * </input>
     * ```
     */
    set selected(val) {
        this.selectionState = val;
    }
    /**
     * Returns the nativeElement of the element where the directive was applied.
     *
     * ```html
     * <input
     *   type="text"
     *   id="firstName"
     *   igxTextSelection>
     * </input>
     * ```
     *
     * ```typescript
     * @ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public inputElement: IgxTextSelectionDirective;
     *
     * public getNativeElement() {
     *  return this.inputElement.nativeElement;
     * }
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     */
    onFocus() {
        this.trigger();
    }
    /**
     * Triggers the selection of the element if it is marked as selectable.
     *
     * ```html
     * <input
     *   type="text"
     *   id="firstName"
     *   igxTextSelection>
     * </input>
     * ```
     *
     * ```typescript
     * @ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public inputElement: IgxTextSelectionDirective;
     *
     * public triggerElementSelection() {
     *  this.inputElement.trigger();
     * }
     * ```
     */
    trigger() {
        if (this.selected && this.nativeElement.value.length) {
            requestAnimationFrame(() => this.nativeElement.setSelectionRange(0, this.nativeElement.value.length));
        }
    }
}
IgxTextSelectionDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'igxTextSelection',
                selector: '[igxTextSelection]'
            },] }
];
IgxTextSelectionDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxTextSelectionDirective.propDecorators = {
    selected: [{ type: Input, args: ['igxTextSelection',] }],
    onFocus: [{ type: HostListener, args: ['focus',] }]
};
/**
 * @hidden
 */
class IgxTextSelectionModule {
}
IgxTextSelectionModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxTextSelectionDirective],
                exports: [IgxTextSelectionDirective]
            },] }
];

/**
 * **Ignite UI for Angular Tooltip Target** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip)
 *
 * The Ignite UI for Angular Tooltip Target directive is used to mark an HTML element in the markup as one that has a tooltip.
 * The tooltip target is used in combination with the Ignite UI for Angular Tooltip by assigning the exported tooltip reference to the
 * target's selector property.
 *
 * Example:
 * ```html
 * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
 * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
 * ```
 */
class IgxTooltipTargetDirective extends IgxToggleActionDirective {
    constructor(_element, _navigationService) {
        super(_element, _navigationService);
        this._element = _element;
        this._navigationService = _navigationService;
        /**
         * Gets/sets the amount of milliseconds that should pass before showing the tooltip.
         *
         * ```typescript
         * // get
         * let tooltipShowDelay = this.tooltipTarget.showDelay;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" showDelay="1500">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.showDelay = 500;
        /**
         * Gets/sets the amount of milliseconds that should pass before hiding the tooltip.
         *
         * ```typescript
         * // get
         * let tooltipHideDelay = this.tooltipTarget.hideDelay;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" hideDelay="1500">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.hideDelay = 500;
        /**
         * Specifies if the tooltip should not show when hovering its target with the mouse. (defaults to false)
         * While setting this property to 'true' will disable the user interactions that shows/hides the tooltip,
         * the developer will still be able to show/hide the tooltip through the API.
         *
         * ```typescript
         * // get
         * let tooltipDisabledValue = this.tooltipTarget.tooltipDisabled;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" [tooltipDisabled]="true">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.tooltipDisabled = false;
        /**
         * Emits an event when the tooltip that is associated with this target starts showing.
         * This event is fired before the start of the countdown to showing the tooltip.
         *
         * ```typescript
         * tooltipShowing(args: ITooltipShowEventArgs) {
         *    alert("Tooltip started showing!");
         * }
         * ```
         *
         * ```html
         * <button [igxTooltipTarget]="tooltipRef"
         *         (tooltipShow)='tooltipShowing($event)'>Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.tooltipShow = new EventEmitter();
        /**
         * Emits an event when the tooltip that is associated with this target starts hiding.
         * This event is fired before the start of the countdown to hiding the tooltip.
         *
         * ```typescript
         * tooltipHiding(args: ITooltipHideEventArgs) {
         *    alert("Tooltip started hiding!");
         * }
         * ```
         *
         * ```html
         * <button [igxTooltipTarget]="tooltipRef"
         *         (tooltipHide)='tooltipHiding($event)'>Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.tooltipHide = new EventEmitter();
        this.destroy$ = new Subject();
    }
    /**
     * @hidden
     */
    set target(target) {
        if (target !== null && target !== '') {
            this._target = target;
        }
    }
    /**
     * @hidden
     */
    get target() {
        if (typeof this._target === 'string') {
            return this._navigationService.get(this._target);
        }
        return this._target;
    }
    /**
     * Gets the respective native element of the directive.
     *
     * ```typescript
     * let tooltipTargetElement = this.tooltipTarget.nativeElement;
     * ```
     */
    get nativeElement() {
        return this._element.nativeElement;
    }
    /**
     * Indicates if the tooltip that is is associated with this target is currently hidden.
     *
     * ```typescript
     * let tooltipHiddenValue = this.tooltipTarget.tooltipHidden;
     * ```
     */
    get tooltipHidden() {
        return !this.target || this.target.collapsed;
    }
    /**
     * @hidden
     */
    onClick() {
        if (!this.target.collapsed) {
            this.target.forceClose(this.mergedOverlaySettings);
        }
    }
    /**
     * @hidden
     */
    onMouseEnter() {
        if (this.tooltipDisabled) {
            return;
        }
        this.checkOutletAndOutsideClick();
        const shouldReturn = this.preMouseEnterCheck();
        if (shouldReturn) {
            return;
        }
        const showingArgs = { target: this, tooltip: this.target, cancel: false };
        this.tooltipShow.emit(showingArgs);
        if (showingArgs.cancel) {
            return;
        }
        this.target.toBeShown = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.open(this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
            this.target.toBeShown = false;
        }, this.showDelay);
    }
    /**
     * @hidden
     */
    onMouseLeave() {
        if (this.tooltipDisabled) {
            return;
        }
        this.checkOutletAndOutsideClick();
        const shouldReturn = this.preMouseLeaveCheck();
        if (shouldReturn || this.target.collapsed) {
            return;
        }
        this.target.toBeHidden = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.close(); // Call close() of IgxTooltipDirective
            this.target.toBeHidden = false;
        }, this.hideDelay);
    }
    /**
     * @hidden
     */
    onTouchStart() {
        if (this.tooltipDisabled) {
            return;
        }
        this.showTooltip();
    }
    /**
     * @hidden
     */
    onDocumentTouchStart(event) {
        if (this.tooltipDisabled) {
            return;
        }
        if (this.nativeElement !== event.target &&
            !this.nativeElement.contains(event.target)) {
            this.hideTooltip();
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        const positionSettings = {
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            openAnimation: useAnimation(scaleInCenter, { params: { duration: '150ms' } }),
            closeAnimation: useAnimation(fadeOut, { params: { duration: '75ms' } })
        };
        this._overlayDefaults.positionStrategy = new AutoPositionStrategy(positionSettings);
        this._overlayDefaults.closeOnOutsideClick = false;
        this._overlayDefaults.closeOnEscape = true;
        this.target.onClosing.pipe(takeUntil(this.destroy$)).subscribe((event) => {
            const hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.tooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                event.cancel = true;
            }
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * Shows the tooltip by respecting the 'showDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.showTooltip();
     * ```
     */
    showTooltip() {
        clearTimeout(this.target.timeoutId);
        if (!this.target.collapsed) {
            //  if close animation has started finish it, or close the tooltip with no animation
            this.target.forceClose(this.mergedOverlaySettings);
            this.target.toBeHidden = false;
        }
        const showingArgs = { target: this, tooltip: this.target, cancel: false };
        this.tooltipShow.emit(showingArgs);
        if (showingArgs.cancel) {
            return;
        }
        this.target.toBeShown = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.open(this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
            this.target.toBeShown = false;
        }, this.showDelay);
    }
    /**
     * Hides the tooltip by respecting the 'hideDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.hideTooltip();
     * ```
     */
    hideTooltip() {
        if (this.target.collapsed && this.target.toBeShown) {
            clearTimeout(this.target.timeoutId);
        }
        if (this.target.collapsed || this.target.toBeHidden) {
            return;
        }
        this.target.toBeHidden = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.close(); // Call close() of IgxTooltipDirective
            this.target.toBeHidden = false;
        }, this.hideDelay);
    }
    checkOutletAndOutsideClick() {
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
    }
    get mergedOverlaySettings() {
        return Object.assign({}, this._overlayDefaults, this.overlaySettings);
    }
    // Return true if the execution in onMouseEnter should be terminated after this method
    preMouseEnterCheck() {
        // If tooltip is about to be opened
        if (this.target.toBeShown) {
            clearTimeout(this.target.timeoutId);
            this.target.toBeShown = false;
        }
        // If Tooltip is opened or about to be hidden
        if (!this.target.collapsed || this.target.toBeHidden) {
            clearTimeout(this.target.timeoutId);
            //  if close animation has started finish it, or close the tooltip with no animation
            this.target.forceClose(this.mergedOverlaySettings);
            this.target.toBeHidden = false;
        }
        return false;
    }
    // Return true if the execution in onMouseLeave should be terminated after this method
    preMouseLeaveCheck() {
        clearTimeout(this.target.timeoutId);
        // If tooltip is about to be opened
        if (this.target.toBeShown) {
            this.target.toBeShown = false;
            this.target.toBeHidden = false;
            return true;
        }
        return false;
    }
}
IgxTooltipTargetDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'tooltipTarget',
                selector: '[igxTooltipTarget]'
            },] }
];
IgxTooltipTargetDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
IgxTooltipTargetDirective.propDecorators = {
    showDelay: [{ type: Input, args: ['showDelay',] }],
    hideDelay: [{ type: Input, args: ['hideDelay',] }],
    tooltipDisabled: [{ type: Input, args: ['tooltipDisabled',] }],
    target: [{ type: Input, args: ['igxTooltipTarget',] }],
    tooltipShow: [{ type: Output }],
    tooltipHide: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }],
    onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }],
    onTouchStart: [{ type: HostListener, args: ['touchstart',] }],
    onDocumentTouchStart: [{ type: HostListener, args: ['document:touchstart', ['$event'],] }]
};
let NEXT_ID$5 = 0;
/**
 * **Ignite UI for Angular Tooltip** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip)
 *
 * The Ignite UI for Angular Tooltip directive is used to mark an HTML element in the markup as one that should behave as a tooltip.
 * The tooltip is used in combination with the Ignite UI for Angular Tooltip Target by assigning the exported tooltip reference to the
 * respective target's selector property.
 *
 * Example:
 * ```html
 * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
 * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
 * ```
 */
class IgxTooltipDirective extends IgxToggleDirective {
    /** @hidden */
    constructor(elementRef, cdr, overlayService, navigationService) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        super(elementRef, cdr, overlayService, navigationService);
        /**
         * Identifier for the tooltip.
         * If this is property is not explicitly set, it will be automatically generated.
         *
         * ```typescript
         * let tooltipId = this.tooltip.id;
         * ```
         */
        this.id = `igx-tooltip-${NEXT_ID$5++}`;
        /**
         * @hidden
         * Returns whether close time out has started
         */
        this.toBeHidden = false;
        /**
         * @hidden
         * Returns whether open time out has started
         */
        this.toBeShown = false;
    }
    /**
     * @hidden
     */
    get hiddenClass() {
        return this.collapsed;
    }
    /**
     * @hidden
     */
    get defaultClass() {
        return !this.collapsed;
    }
    /**
     * Get the role attribute of the tooltip.
     *
     * ```typescript
     * let tooltipRole = this.tooltip.role;
     * ```
     */
    get role() {
        return 'tooltip';
    }
    /**
     * If there is open animation in progress this method will finish is.
     * If there is no open animation in progress this method will open the toggle with no animation.
     *
     * @param overlaySettings setting to use for opening the toggle
     */
    forceOpen(overlaySettings) {
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasOpenAnimation = info ? info.openAnimationPlayer : false;
        if (hasOpenAnimation) {
            info.openAnimationPlayer.finish();
            info.openAnimationPlayer.reset();
            info.openAnimationPlayer = null;
        }
        else if (this.collapsed) {
            const animation = overlaySettings.positionStrategy.settings.openAnimation;
            overlaySettings.positionStrategy.settings.openAnimation = null;
            this.open(overlaySettings);
            overlaySettings.positionStrategy.settings.openAnimation = animation;
        }
    }
    /**
     * If there is close animation in progress this method will finish is.
     * If there is no close animation in progress this method will close the toggle with no animation.
     *
     * @param overlaySettings settings to use for closing the toggle
     */
    forceClose(overlaySettings) {
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (hasCloseAnimation) {
            info.closeAnimationPlayer.finish();
            info.closeAnimationPlayer.reset();
            info.closeAnimationPlayer = null;
        }
        else if (!this.collapsed) {
            const animation = overlaySettings.positionStrategy.settings.closeAnimation;
            overlaySettings.positionStrategy.settings.closeAnimation = null;
            this.close();
            overlaySettings.positionStrategy.settings.closeAnimation = animation;
        }
    }
}
IgxTooltipDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'tooltip',
                selector: '[igxTooltip]'
            },] }
];
IgxTooltipDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
IgxTooltipDirective.propDecorators = {
    hiddenClass: [{ type: HostBinding, args: ['class.igx-tooltip--hidden',] }],
    defaultClass: [{ type: HostBinding, args: ['class.igx-tooltip--desktop',] }],
    context: [{ type: Input, args: ['context',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }]
};
/**
 * @hidden
 */
class IgxTooltipModule {
}
IgxTooltipModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxTooltipDirective, IgxTooltipTargetDirective],
                exports: [IgxTooltipDirective, IgxTooltipTargetDirective],
                imports: [CommonModule],
                providers: [IgxOverlayService]
            },] }
];

/**
 * Specify a particular date, time or AmPm part.
 */
var DatePart;
(function (DatePart) {
    DatePart["Date"] = "date";
    DatePart["Month"] = "month";
    DatePart["Year"] = "year";
    DatePart["Hours"] = "hour";
    DatePart["Minutes"] = "minute";
    DatePart["Seconds"] = "second";
    DatePart["AmPm"] = "ampm";
    DatePart["Literal"] = "literal";
})(DatePart || (DatePart = {}));

const DATE_CHARS = ['h', 'H', 'm', 's', 'S', 't', 'T'];
const TIME_CHARS = ['d', 'D', 'M', 'y', 'Y'];
/** @hidden */
class DatePickerUtil {
    /**
     *  TODO: (in issue #6483) Unit tests and docs for all public methods.
     */
    /**
     * Parse a Date value from masked string input based on determined date parts
     *
     * @param inputData masked value to parse
     * @param dateTimeParts Date parts array for the mask
     */
    static parseValueFromMask(inputData, dateTimeParts, promptChar) {
        const parts = {};
        dateTimeParts.forEach(dp => {
            let value = parseInt(DatePickerUtil.getCleanVal(inputData, dp, promptChar), 10);
            if (!value) {
                value = dp.type === DatePart.Date || dp.type === DatePart.Month ? 1 : 0;
            }
            parts[dp.type] = value;
        });
        parts[DatePart.Month] -= 1;
        if (parts[DatePart.Month] < 0 || 11 < parts[DatePart.Month]) {
            return null;
        }
        // TODO: Century threshold
        if (parts[DatePart.Year] < 50) {
            parts[DatePart.Year] += 2000;
        }
        if (parts[DatePart.Date] > DatePickerUtil.daysInMonth(parts[DatePart.Year], parts[DatePart.Month])) {
            return null;
        }
        if (parts[DatePart.Hours] > 23 || parts[DatePart.Minutes] > 59 || parts[DatePart.Seconds] > 59) {
            return null;
        }
        return new Date(parts[DatePart.Year] || 2000, parts[DatePart.Month] || 0, parts[DatePart.Date] || 1, parts[DatePart.Hours] || 0, parts[DatePart.Minutes] || 0, parts[DatePart.Seconds] || 0);
    }
    /**
     * Parse the mask into date/time and literal parts
     */
    static parseDateTimeFormat(mask, locale = DatePickerUtil.DEFAULT_LOCALE) {
        const format = mask || DatePickerUtil.getDefaultInputFormat(locale);
        const dateTimeParts = [];
        const formatArray = Array.from(format);
        let currentPart = null;
        let position = 0;
        for (let i = 0; i < formatArray.length; i++, position++) {
            const type = DatePickerUtil.determineDatePart(formatArray[i]);
            if (currentPart) {
                if (currentPart.type === type) {
                    currentPart.format += formatArray[i];
                    if (i < formatArray.length - 1) {
                        continue;
                    }
                }
                DatePickerUtil.ensureLeadingZero(currentPart);
                currentPart.end = currentPart.start + currentPart.format.length;
                position = currentPart.end;
                dateTimeParts.push(currentPart);
            }
            currentPart = {
                start: position,
                end: position + formatArray[i].length,
                type,
                format: formatArray[i]
            };
        }
        return dateTimeParts;
    }
    static getDefaultInputFormat(locale) {
        if (!Intl || !Intl.DateTimeFormat || !Intl.DateTimeFormat.prototype.formatToParts) {
            // TODO: fallback with Intl.format for IE?
            return DatePickerUtil.SHORT_DATE_MASK;
        }
        const parts = DatePickerUtil.getDefaultLocaleMask(locale);
        parts.forEach(p => {
            if (p.type !== DatePart.Year && p.type !== DatePickerUtil.SEPARATOR) {
                p.formatType = "2-digit" /* TwoDigits */;
            }
        });
        return DatePickerUtil.getMask(parts);
    }
    static formatDate(value, format, locale, timezone) {
        let formattedDate;
        try {
            formattedDate = formatDate(value, format, locale, timezone);
        }
        catch (_a) {
            DatePickerUtil.logMissingLocaleSettings(locale);
            const formatter = new Intl.DateTimeFormat(locale);
            formattedDate = formatter.format(value);
        }
        return formattedDate;
    }
    static getLocaleDateFormat(locale, displayFormat) {
        const formatKeys = Object.keys(FormatWidth);
        const targetKey = formatKeys.find(k => k.toLowerCase() === (displayFormat === null || displayFormat === void 0 ? void 0 : displayFormat.toLowerCase().replace('date', '')));
        if (!targetKey) {
            // if displayFormat is not shortDate, longDate, etc.
            // or if it is not set by the user
            return displayFormat;
        }
        let format;
        try {
            format = getLocaleDateFormat(locale, FormatWidth[targetKey]);
        }
        catch (_a) {
            DatePickerUtil.logMissingLocaleSettings(locale);
            format = DatePickerUtil.getDefaultInputFormat(locale);
        }
        return format;
    }
    static isDateOrTimeChar(char) {
        return DATE_CHARS.indexOf(char) !== -1 || TIME_CHARS.indexOf(char) !== -1;
    }
    static spinDate(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth());
        let date = newDate.getDate() + delta;
        if (date > maxDate) {
            date = isSpinLoop ? date % maxDate : maxDate;
        }
        else if (date < 1) {
            date = isSpinLoop ? maxDate + (date % maxDate) : 1;
        }
        newDate.setDate(date);
    }
    static spinMonth(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth() + delta);
        if (newDate.getDate() > maxDate) {
            newDate.setDate(maxDate);
        }
        const maxMonth = 11;
        const minMonth = 0;
        let month = newDate.getMonth() + delta;
        if (month > maxMonth) {
            month = isSpinLoop ? (month % maxMonth) - 1 : maxMonth;
        }
        else if (month < minMonth) {
            month = isSpinLoop ? maxMonth + (month % maxMonth) + 1 : minMonth;
        }
        newDate.setMonth(month);
    }
    static spinYear(delta, newDate) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear() + delta, newDate.getMonth());
        if (newDate.getDate() > maxDate) {
            // clip to max to avoid leap year change shifting the entire value
            newDate.setDate(maxDate);
        }
        newDate.setFullYear(newDate.getFullYear() + delta);
    }
    static spinHours(delta, newDate, isSpinLoop) {
        const maxHour = 23;
        const minHour = 0;
        let hours = newDate.getHours() + delta;
        if (hours > maxHour) {
            hours = isSpinLoop ? hours % maxHour - 1 : maxHour;
        }
        else if (hours < minHour) {
            hours = isSpinLoop ? maxHour + (hours % maxHour) + 1 : minHour;
        }
        newDate.setHours(hours);
    }
    static spinMinutes(delta, newDate, isSpinLoop) {
        const maxMinutes = 59;
        const minMinutes = 0;
        let minutes = newDate.getMinutes() + delta;
        if (minutes > maxMinutes) {
            minutes = isSpinLoop ? minutes % maxMinutes - 1 : maxMinutes;
        }
        else if (minutes < minMinutes) {
            minutes = isSpinLoop ? maxMinutes + (minutes % maxMinutes) + 1 : minMinutes;
        }
        newDate.setMinutes(minutes);
    }
    static spinSeconds(delta, newDate, isSpinLoop) {
        const maxSeconds = 59;
        const minSeconds = 0;
        let seconds = newDate.getSeconds() + delta;
        if (seconds > maxSeconds) {
            seconds = isSpinLoop ? seconds % maxSeconds - 1 : maxSeconds;
        }
        else if (seconds < minSeconds) {
            seconds = isSpinLoop ? maxSeconds + (seconds % maxSeconds) + 1 : minSeconds;
        }
        newDate.setSeconds(seconds);
    }
    static spinAmPm(newDate, currentDate, amPmFromMask) {
        switch (amPmFromMask) {
            case 'AM':
                newDate = new Date(newDate.setHours(newDate.getHours() + 12));
                break;
            case 'PM':
                newDate = new Date(newDate.setHours(newDate.getHours() - 12));
                break;
        }
        if (newDate.getDate() !== currentDate.getDate()) {
            return currentDate;
        }
        return newDate;
    }
    /**
     * Determines whether the provided value is greater than the provided max value.
     *
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is greater than provided maxValue
     */
    static greaterThanMaxValue(value, maxValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if maxValue is Invalid Date and value is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() > maxValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _maxValue = new Date(maxValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _maxValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _maxValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() > _maxValue.getTime();
    }
    /**
     * Determines whether the provided value is less than the provided min value.
     *
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is less than provided minValue
     */
    static lessThanMinValue(value, minValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if value is Invalid Date and minValue is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() < minValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _minValue = new Date(minValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _minValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _minValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() < _minValue.getTime();
    }
    /**
     * This method generates date parts structure based on editor mask and locale.
     *
     * @param maskValue: string
     * @param locale: string
     * @returns array containing information about date parts - type, position, format
     */
    static parseDateFormat(maskValue, locale = DatePickerUtil.DEFAULT_LOCALE) {
        let dateStruct = [];
        if (maskValue === undefined && !isIE()) {
            dateStruct = DatePickerUtil.getDefaultLocaleMask(locale);
        }
        else {
            const mask = (maskValue) ? maskValue : DatePickerUtil.SHORT_DATE_MASK;
            const maskArray = Array.from(mask);
            const monthInitPosition = mask.indexOf("M" /* MonthChar */);
            const dayInitPosition = mask.indexOf("d" /* DayChar */);
            const yearInitPosition = mask.indexOf("y" /* YearChar */);
            if (yearInitPosition !== -1) {
                dateStruct.push({
                    type: "year" /* Year */,
                    initialPosition: yearInitPosition,
                    formatType: DatePickerUtil.getYearFormatType(mask)
                });
            }
            if (monthInitPosition !== -1) {
                dateStruct.push({
                    type: "month" /* Month */,
                    initialPosition: monthInitPosition,
                    formatType: DatePickerUtil.getMonthFormatType(mask)
                });
            }
            if (dayInitPosition !== -1) {
                dateStruct.push({
                    type: "day" /* Day */,
                    initialPosition: dayInitPosition,
                    formatType: DatePickerUtil.getDayFormatType(mask)
                });
            }
            for (let i = 0; i < maskArray.length; i++) {
                if (!DatePickerUtil.isDateChar(maskArray[i])) {
                    dateStruct.push({
                        type: DatePickerUtil.SEPARATOR,
                        initialPosition: i,
                        value: maskArray[i]
                    });
                }
            }
            dateStruct.sort((a, b) => a.initialPosition - b.initialPosition);
            DatePickerUtil.fillDatePartsPositions(dateStruct);
        }
        return dateStruct;
    }
    /**
     * This method generates input mask based on date parts.
     *
     * @param dateStruct array
     * @returns input mask
     */
    static getInputMask(dateStruct) {
        const inputMask = [];
        for (const part of dateStruct) {
            if (part.type === DatePickerUtil.SEPARATOR) {
                inputMask.push(part.value);
            }
            else if (part.type === "day" /* Day */ || part.type === "month" /* Month */) {
                inputMask.push('00');
            }
            else if (part.type === "year" /* Year */) {
                switch (part.formatType) {
                    case "numeric" /* Numeric */: {
                        inputMask.push('0000');
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        inputMask.push('00');
                        break;
                    }
                }
            }
        }
        return inputMask.join('');
    }
    /**
     * This method generates editor mask.
     *
     * @param dateStruct
     * @returns editor mask
     */
    static getMask(dateStruct) {
        const mask = [];
        for (const part of dateStruct) {
            switch (part.formatType) {
                case "numeric" /* Numeric */: {
                    if (part.type === "day" /* Day */) {
                        mask.push('d');
                    }
                    else if (part.type === "month" /* Month */) {
                        mask.push('M');
                    }
                    else {
                        mask.push('yyyy');
                    }
                    break;
                }
                case "2-digit" /* TwoDigits */: {
                    if (part.type === "day" /* Day */) {
                        mask.push('dd');
                    }
                    else if (part.type === "month" /* Month */) {
                        mask.push('MM');
                    }
                    else {
                        mask.push('yy');
                    }
                }
            }
            if (part.type === DatePickerUtil.SEPARATOR) {
                mask.push(part.value);
            }
        }
        return mask.join('');
    }
    /**
     * This method parses an input string base on date parts and returns a date and its validation state.
     *
     * @param dateFormatParts
     * @param prevDateValue
     * @param inputValue
     * @returns object containing a date and its validation state
     */
    static parseDateArray(dateFormatParts, prevDateValue, inputValue) {
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, inputValue);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue);
        const yearStr = DatePickerUtil.getYearValueFromInput(dateFormatParts, inputValue);
        const yearFormat = DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType;
        const day = (dayStr !== '') ? parseInt(dayStr, 10) : 1;
        const month = (monthStr !== '') ? parseInt(monthStr, 10) - 1 : 0;
        let year;
        if (yearStr === '') {
            year = (yearFormat === "2-digit" /* TwoDigits */) ? '00' : '2000';
        }
        else {
            year = yearStr;
        }
        let yearPrefix;
        if (prevDateValue) {
            const originalYear = prevDateValue.getFullYear().toString();
            if (originalYear.length === 4) {
                yearPrefix = originalYear.substring(0, 2);
            }
        }
        else {
            yearPrefix = '20';
        }
        const fullYear = (yearFormat === "2-digit" /* TwoDigits */) ? yearPrefix.concat(year) : year;
        if ((month < 0) || (month > 11) || isNaN(month)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        if ((day < 1) || (day > DatePickerUtil.daysInMonth(fullYear, month)) || isNaN(day)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        return { state: "valid" /* Valid */, date: new Date(fullYear, month, day) };
    }
    static maskToPromptChars(mask) {
        const result = mask.replace(/0|L/g, DatePickerUtil.PROMPT_CHAR);
        return result;
    }
    /**
     * This method replaces prompt chars with empty string.
     *
     * @param value
     */
    static trimEmptyPlaceholders(value, promptChar) {
        const result = value.replace(new RegExp(promptChar || '_', 'g'), '');
        return result;
    }
    /**
     * This method is used for spinning date parts.
     *
     * @param dateFormatParts
     * @param inputValue
     * @param position
     * @param delta
     * @param isSpinLoop
     * @return modified text input
     */
    static getModifiedDateInput(dateFormatParts, inputValue, position, delta, isSpinLoop) {
        const datePart = DatePickerUtil.getDatePartOnPosition(dateFormatParts, position);
        const datePartType = datePart.type;
        const datePartFormatType = datePart.formatType;
        let newValue;
        const datePartValue = DatePickerUtil.getDateValueFromInput(dateFormatParts, datePartType, inputValue);
        newValue = parseInt(datePartValue, 10);
        const minMax = DatePickerUtil.getMinMaxValue(dateFormatParts, datePart, inputValue);
        const minValue = minMax.min;
        const maxValue = minMax.max;
        if (isNaN(newValue)) {
            if (minValue === 'infinite') {
                newValue = 2000;
            }
            else {
                newValue = minValue;
            }
        }
        let tempValue = newValue;
        tempValue += delta;
        // Infinite loop for full years
        if (maxValue === 'infinite' && minValue === 'infinite') {
            newValue = tempValue;
        }
        if (isSpinLoop) {
            if (tempValue > maxValue) {
                tempValue = minValue;
            }
            if (tempValue < minValue) {
                tempValue = maxValue;
            }
            newValue = tempValue;
        }
        else {
            if (tempValue <= maxValue && tempValue >= minValue) {
                newValue = tempValue;
            }
        }
        const startIdx = datePart.position[0];
        const endIdx = datePart.position[1];
        const start = inputValue.slice(0, startIdx);
        const end = inputValue.slice(endIdx, inputValue.length);
        const prefix = DatePickerUtil.getNumericFormatPrefix(datePartFormatType);
        const changedPart = (newValue < 10) ? `${prefix}${newValue}` : `${newValue}`;
        return `${start}${changedPart}${end}`;
    }
    /**
     * This method returns date input with prompt chars.
     *
     * @param dateFormatParts
     * @param date
     * @param inputValue
     * @returns date input including prompt chars
     */
    static addPromptCharsEditMode(dateFormatParts, date, inputValue) {
        const dateArray = Array.from(inputValue);
        for (const part of dateFormatParts) {
            if (part.formatType === "numeric" /* Numeric */) {
                if ((part.type === "day" /* Day */ && date.getDate() < 10)
                    || (part.type === "month" /* Month */ && date.getMonth() + 1 < 10)) {
                    dateArray.splice(part.position[0], 0, DatePickerUtil.PROMPT_CHAR);
                    dateArray.join('');
                }
            }
        }
        return dateArray.join('');
    }
    /**
     * This method checks if date input is done.
     *
     * @param dateFormatParts
     * @param input
     * @returns input completeness
     */
    static checkForCompleteDateInput(dateFormatParts, input) {
        const dayValue = DatePickerUtil.getDayValueFromInput(dateFormatParts, input);
        const monthValue = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input);
        const yearValue = DatePickerUtil.getYearValueFromInput(dateFormatParts, input);
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, input, false);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input, false);
        if (DatePickerUtil.isFullInput(dayValue, dayStr)
            && DatePickerUtil.isFullInput(monthValue, monthStr)
            && DatePickerUtil.isFullYearInput(dateFormatParts, yearValue)) {
            return 'complete';
        }
        else if (dayValue === '' && monthValue === '' && yearValue === '') {
            return 'empty';
        }
        else if (dayValue === '' || monthValue === '' || yearValue === '') {
            return 'partial';
        }
        return '';
    }
    static daysInMonth(fullYear, month) {
        return new Date(fullYear, month + 1, 0).getDate();
    }
    /**
     * Parse provided input to Date.
     *
     * @param value input to parse
     * @returns Date if parse succeed or null
     */
    static parseDate(value) {
        if (typeof value === 'number') {
            return new Date(value);
        }
        // if value is Invalid Date we should return null
        if (DatePickerUtil.isDate(value)) {
            return DatePickerUtil.isValidDate(value) ? value : null;
        }
        return value ? new Date(Date.parse(value)) : null;
    }
    /**
     * Returns whether provided input is date
     *
     * @param value input to check
     * @returns true if provided input is date
     */
    static isDate(value) {
        return Object.prototype.toString.call(value) === '[object Date]';
    }
    /**
     * Returns whether the input is valid date
     *
     * @param value input to check
     * @returns true if provided input is a valid date
     */
    static isValidDate(value) {
        if (DatePickerUtil.isDate(value)) {
            return !isNaN(value.getTime());
        }
        return false;
    }
    static logMissingLocaleSettings(locale) {
        console.warn(`Missing locale data for the locale ${locale}. Please refer to https://angular.io/guide/i18n#i18n-pipes`);
        console.warn('Using default browser locale settings.');
    }
    static ensureLeadingZero(part) {
        switch (part.type) {
            case DatePart.Date:
            case DatePart.Month:
            case DatePart.Hours:
            case DatePart.Minutes:
            case DatePart.Seconds:
                if (part.format.length === 1) {
                    part.format = part.format.repeat(2);
                }
                break;
        }
    }
    static getCleanVal(inputData, datePart, promptChar) {
        return DatePickerUtil.trimEmptyPlaceholders(inputData.substring(datePart.start, datePart.end), promptChar);
    }
    static determineDatePart(char) {
        switch (char) {
            case 'd':
            case 'D':
                return DatePart.Date;
            case 'M':
                return DatePart.Month;
            case 'y':
            case 'Y':
                return DatePart.Year;
            case 'h':
            case 'H':
                return DatePart.Hours;
            case 'm':
                return DatePart.Minutes;
            case 's':
            case 'S':
                return DatePart.Seconds;
            case 't':
            case 'T':
                return DatePart.AmPm;
            default:
                return DatePart.Literal;
        }
    }
    static getYearFormatType(format) {
        switch (format.match(new RegExp("y" /* YearChar */, 'g')).length) {
            case 1: {
                // y (2020)
                return "numeric" /* Numeric */;
            }
            case 4: {
                // yyyy (2020)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // yy (20)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getMonthFormatType(format) {
        switch (format.match(new RegExp("M" /* MonthChar */, 'g')).length) {
            case 1: {
                // M (8)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // MM (08)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDayFormatType(format) {
        switch (format.match(new RegExp("d" /* DayChar */, 'g')).length) {
            case 1: {
                // d (6)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // dd (06)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDefaultLocaleMask(locale) {
        const dateStruct = [];
        const formatter = new Intl.DateTimeFormat(locale);
        const formatToParts = formatter.formatToParts(new Date());
        for (const part of formatToParts) {
            if (part.type === DatePickerUtil.SEPARATOR) {
                dateStruct.push({
                    type: DatePickerUtil.SEPARATOR,
                    value: part.value
                });
            }
            else {
                dateStruct.push({
                    type: part.type
                });
            }
        }
        const formatterOptions = formatter.resolvedOptions();
        for (const part of dateStruct) {
            switch (part.type) {
                case "day" /* Day */: {
                    part.formatType = formatterOptions.day;
                    break;
                }
                case "month" /* Month */: {
                    part.formatType = formatterOptions.month;
                    break;
                }
                case "year" /* Year */: {
                    part.formatType = formatterOptions.year;
                    break;
                }
            }
        }
        DatePickerUtil.fillDatePartsPositions(dateStruct);
        return dateStruct;
    }
    static isDateChar(char) {
        return (char === "y" /* YearChar */ || char === "M" /* MonthChar */ || char === "d" /* DayChar */);
    }
    static getNumericFormatPrefix(formatType) {
        switch (formatType) {
            case "2-digit" /* TwoDigits */: {
                return '0';
            }
            case "numeric" /* Numeric */: {
                return DatePickerUtil.PROMPT_CHAR;
            }
        }
    }
    static getMinMaxValue(dateFormatParts, datePart, inputValue) {
        let maxValue;
        let minValue;
        switch (datePart.type) {
            case "month" /* Month */: {
                minValue = 1;
                maxValue = DatePickerUtil.NUMBER_OF_MONTHS;
                break;
            }
            case "day" /* Day */: {
                minValue = 1;
                maxValue = DatePickerUtil.daysInMonth(DatePickerUtil.getFullYearFromString(DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */), inputValue), parseInt(DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue), 10));
                break;
            }
            case "year" /* Year */: {
                if (datePart.formatType === "2-digit" /* TwoDigits */) {
                    minValue = 0;
                    maxValue = 99;
                }
                else {
                    // Infinite loop
                    minValue = 'infinite';
                    maxValue = 'infinite';
                }
                break;
            }
        }
        return { min: minValue, max: maxValue };
    }
    static getDateValueFromInput(dateFormatParts, type, inputValue, trim = true) {
        const partPosition = DatePickerUtil.getDateFormatPart(dateFormatParts, type).position;
        const result = inputValue.substring(partPosition[0], partPosition[1]);
        return (trim) ? DatePickerUtil.trimEmptyPlaceholders(result) : result;
    }
    static getDayValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "day" /* Day */, inputValue, trim);
    }
    static getMonthValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "month" /* Month */, inputValue, trim);
    }
    static getYearValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "year" /* Year */, inputValue, trim);
    }
    static getDateFormatPart(dateFormatParts, type) {
        const result = dateFormatParts.filter((datePart) => (datePart.type === type))[0];
        return result;
    }
    static isFullInput(value, input) {
        return (value !== '' && input.length === 2 && input.charAt(1) !== DatePickerUtil.PROMPT_CHAR);
    }
    static isFullYearInput(dateFormatParts, value) {
        switch (DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType) {
            case "numeric" /* Numeric */: {
                return (value !== '' && value.length === 4);
            }
            case "2-digit" /* TwoDigits */: {
                return (value !== '' && value.length === 2);
            }
            default: {
                return false;
            }
        }
    }
    static getDatePartOnPosition(dateFormatParts, position) {
        const result = dateFormatParts.filter((element) => element.position[0] <= position && position <= element.position[1] && element.type !== DatePickerUtil.SEPARATOR)[0];
        return result;
    }
    static getFullYearFromString(yearPart, inputValue) {
        return parseInt(inputValue.substring(yearPart.position[0], yearPart.position[1]), 10);
    }
    static fillDatePartsPositions(dateArray) {
        let currentPos = 0;
        for (const part of dateArray) {
            // Day|Month part positions
            if (part.type === "day" /* Day */ || part.type === "month" /* Month */) {
                // Offset 2 positions for number
                part.position = [currentPos, currentPos + 2];
                currentPos += 2;
            }
            else if (part.type === "year" /* Year */) {
                // Year part positions
                switch (part.formatType) {
                    case "numeric" /* Numeric */: {
                        // Offset 4 positions for full year
                        part.position = [currentPos, currentPos + 4];
                        currentPos += 4;
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        // Offset 2 positions for short year
                        part.position = [currentPos, currentPos + 2];
                        currentPos += 2;
                        break;
                    }
                }
            }
            else if (part.type === DatePickerUtil.SEPARATOR) {
                // Separator positions
                part.position = [currentPos, currentPos + 1];
                currentPos++;
            }
        }
    }
}
DatePickerUtil.DEFAULT_INPUT_FORMAT = 'MM/dd/yyyy';
// TODO: this is the def mask for the date-picker, should remove it during refactoring
DatePickerUtil.SHORT_DATE_MASK = 'MM/dd/yy';
DatePickerUtil.SEPARATOR = 'literal';
DatePickerUtil.NUMBER_OF_MONTHS = 12;
DatePickerUtil.PROMPT_CHAR = '_';
DatePickerUtil.DEFAULT_LOCALE = 'en';

/* eslint-disable @angular-eslint/no-conflicting-lifecycle */
/**
 * Date Time Editor provides a functionality to input, edit and format date and time.
 *
 * @igxModule IgxDateTimeEditorModule
 *
 * @igxParent IgxInputGroup
 *
 * @igxTheme igx-input-theme
 *
 * @igxKeywords date, time, editor
 *
 * @igxGroup Scheduling
 *
 * @remarks
 *
 * The Ignite UI Date Time Editor Directive makes it easy for developers to manipulate date/time user input.
 * It requires input in a specified or default input format which is visible in the input element as a placeholder.
 * It allows the input of only date (ex: 'dd/MM/yyyy'), only time (ex:'HH:mm tt') or both at once, if needed.
 * Supports display format that may differ from the input format.
 * Provides methods to increment and decrement any specific/targeted `DatePart`.
 *
 * @example
 * ```html
 * <igx-input-group>
 *   <input type="text" igxInput [igxDateTimeEditor]="'dd/MM/yyyy'" [displayFormat]="'shortDate'" [(ngModel)]="date"/>
 * </igx-input-group>
 * ```
 */
class IgxDateTimeEditorDirective extends IgxMaskDirective {
    constructor(renderer, elementRef, maskParser, _document, _locale) {
        super(elementRef, maskParser, renderer);
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.maskParser = maskParser;
        this._document = _document;
        this._locale = _locale;
        /**
         * Specify if the currently spun date segment should loop over.
         *
         * @example
         * ```html
         * <input igxDateTimeEditor [isSpinLoop]="false">
         * ```
         */
        this.isSpinLoop = true;
        /**
         * Emitted when the editor's value has changed.
         *
         * @example
         * ```html
         * <input igxDateTimeEditor (valueChange)="onValueChanged($event)"/>
         * ```
         */
        this.valueChange = new EventEmitter();
        /**
         * Emitted when the editor is not within a specified range or when the editor's value is in an invalid state.
         *
         * @example
         * ```html
         * <input igxDateTimeEditor [minValue]="minDate" [maxValue]="maxDate" (validationFailed)="onValidationFailed($event)"/>
         * ```
         */
        this.validationFailed = new EventEmitter();
        this.onTouchCallback = noop;
        this.onChangeCallback = noop;
        this.onValidatorChange = noop;
        this.document = this._document;
        this.locale = this.locale || this._locale;
    }
    /**
     * Minimum value required for the editor to remain valid.
     *
     * @remarks
     * If a `string` value is passed, it must be in the defined input format.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [minValue]="minDate">
     * ```
     */
    get minValue() {
        return this._minValue;
    }
    set minValue(value) {
        this._minValue = value;
        this.onValidatorChange();
    }
    /**
     * Maximum value required for the editor to remain valid.
     *
     * @remarks
     * If a `string` value is passed in, it must be in the defined input format.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [maxValue]="maxDate">
     * ```
     */
    get maxValue() {
        return this._maxValue;
    }
    set maxValue(value) {
        this._maxValue = value;
        this.onValidatorChange();
    }
    /**
     * Expected user input format (and placeholder).
     *
     * @example
     * ```html
     * <input [igxDateTimeEditor]="'dd/MM/yyyy'">
     * ```
     */
    set inputFormat(value) {
        if (value) {
            this._format = value;
        }
        const mask = (this.inputFormat || DatePickerUtil.DEFAULT_INPUT_FORMAT)
            .replace(new RegExp(/(?=[^t])[\w]/, 'g'), '0');
        this.mask = mask.indexOf('tt') !== -1 ? mask.replace(new RegExp('tt', 'g'), 'LL') : mask;
    }
    get inputFormat() {
        return this._format;
    }
    /**
     * Editor value.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [value]="date">
     * ```
     */
    set value(value) {
        this._value = value;
        this.onChangeCallback(value);
        this.updateMask();
    }
    get value() {
        return this._value;
    }
    get emptyMask() {
        return this.maskParser.applyMask(null, this.maskOptions);
    }
    get targetDatePart() {
        var _a;
        if (this.document.activeElement === this.nativeElement) {
            return (_a = this._inputDateParts
                .find(p => p.start <= this.selectionStart && this.selectionStart <= p.end && p.type !== DatePart.Literal)) === null || _a === void 0 ? void 0 : _a.type;
        }
        else {
            if (this._inputDateParts.some(p => p.type === DatePart.Date)) {
                return DatePart.Date;
            }
            else if (this._inputDateParts.some(p => p.type === DatePart.Hours)) {
                return DatePart.Hours;
            }
        }
    }
    get hasDateParts() {
        return this._inputDateParts.some(p => p.type === DatePart.Date
            || p.type === DatePart.Month
            || p.type === DatePart.Year);
    }
    get hasTimeParts() {
        return this._inputDateParts.some(p => p.type === DatePart.Hours
            || p.type === DatePart.Minutes
            || p.type === DatePart.Seconds);
    }
    /** @hidden @internal */
    ngOnChanges(changes) {
        if (changes['inputFormat'] || changes['locale']) {
            this.updateInputFormat();
        }
    }
    /** @hidden @internal */
    ngDoCheck() {
        if (this._inputFormat !== this.inputFormat) {
            this.updateInputFormat();
        }
    }
    /** Clear the input element value. */
    clear() {
        this.updateValue(null);
    }
    /**
     * Increment specified DatePart.
     *
     * @param datePart The optional DatePart to increment. Defaults to Date or Hours(when Date is absent from the inputFormat - ex:'HH:mm').
     */
    increment(datePart) {
        const targetDatePart = this.targetDatePart;
        if (!targetDatePart) {
            return;
        }
        const newValue = datePart
            ? this.spinValue(datePart, 1)
            : this.spinValue(targetDatePart, 1);
        this.updateValue(newValue ? newValue : new Date());
    }
    /**
     * Decrement specified DatePart.
     *
     * @param datePart The optional DatePart to decrement. Defaults to Date or Hours(when Date is absent from the inputFormat - ex:'HH:mm').
     */
    decrement(datePart) {
        const targetDatePart = this.targetDatePart;
        if (!targetDatePart) {
            return;
        }
        const newValue = datePart
            ? this.spinValue(datePart, -1)
            : this.spinValue(targetDatePart, -1);
        this.updateValue(newValue ? newValue : new Date());
    }
    /** @hidden @internal */
    writeValue(value) {
        this._value = value;
        this.updateMask();
    }
    /** @hidden @internal */
    validate(control) {
        if (!this.inputIsComplete() || !control.value) {
            return { value: true };
        }
        const maxValueAsDate = this.isDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);
        const minValueAsDate = this.isDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);
        if (minValueAsDate
            && DatePickerUtil.lessThanMinValue(control.value, minValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return { minValue: true };
        }
        if (maxValueAsDate
            && DatePickerUtil.greaterThanMaxValue(control.value, maxValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return { maxValue: true };
        }
        return null;
    }
    /** @hidden @internal */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /** @hidden @internal */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /** @hidden @internal */
    registerOnTouched(fn) {
        this.onTouchCallback = fn;
    }
    /** @hidden @internal */
    setDisabledState(isDisabled) { }
    /** @hidden @internal */
    onInputChanged() {
        var _a;
        super.onInputChanged();
        if (this.inputIsComplete()) {
            const parsedDate = this.parseDate(this.inputValue);
            if (this.isValidDate(parsedDate)) {
                this.updateValue(parsedDate);
            }
            else {
                const oldValue = this.value && new Date(this.value.getTime());
                const args = { oldValue, newValue: parsedDate, userInput: this.inputValue };
                this.validationFailed.emit(args);
                if (((_a = args.newValue) === null || _a === void 0 ? void 0 : _a.getTime) && args.newValue.getTime() !== oldValue.getTime()) {
                    this.updateValue(args.newValue);
                }
                else {
                    this.updateValue(null);
                }
            }
        }
        else {
            this.updateValue(null);
        }
    }
    /** @hidden @internal */
    onKeyDown(event) {
        super.onKeyDown(event);
        if (event.altKey) {
            return;
        }
        if (event.key === "ArrowUp" /* UP_ARROW */ || event.key === "Up" /* UP_ARROW_IE */ ||
            event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */) {
            this.spin(event);
            return;
        }
        if (event.ctrlKey && event.key === ";" /* SEMICOLON */) {
            this.updateValue(new Date());
        }
        this.moveCursor(event);
    }
    /** @hidden @internal */
    onFocus() {
        this._isFocused = true;
        this.onTouchCallback();
        this.updateMask();
        super.onFocus();
    }
    /** @hidden @internal */
    onBlur(value) {
        this._isFocused = false;
        if (!this.inputIsComplete() && this.inputValue !== this.emptyMask) {
            this.updateValue(this.parseDate(this.inputValue));
        }
        else {
            this.updateMask();
        }
        super.onBlur(value);
    }
    /** @hidden @internal */
    updateMask() {
        if (this._isFocused) {
            if (!this.value) {
                return;
            }
            // store the cursor position as it will be moved during masking
            const cursor = this.selectionEnd;
            this.inputValue = this.getMaskedValue();
            this.setSelectionRange(cursor);
        }
        else {
            if (!this.value || !this.isValidDate(this.value)) {
                this.inputValue = '';
                return;
            }
            const format = this.displayFormat || this.inputFormat;
            if (format) {
                this.inputValue = DatePickerUtil.formatDate(this.value, format.replace('tt', 'aa'), this.locale);
            }
            else {
                // TODO: formatter function?
                this.inputValue = this.value.toLocaleString();
            }
        }
    }
    // TODO: move parseDate to utils
    parseDate(val) {
        if (!val) {
            return null;
        }
        return DatePickerUtil.parseValueFromMask(val, this._inputDateParts, this.promptChar);
    }
    getMaskedValue() {
        let mask = this.emptyMask;
        for (const part of this._inputDateParts) {
            if (part.type === DatePart.Literal) {
                continue;
            }
            const targetValue = this.getPartValue(part, part.format.length);
            mask = this.maskParser.replaceInMask(mask, targetValue, this.maskOptions, part.start, part.end).value;
        }
        return mask;
    }
    updateInputFormat() {
        const defPlaceholder = this.inputFormat || DatePickerUtil.getDefaultInputFormat(this.locale);
        this._inputDateParts = DatePickerUtil.parseDateTimeFormat(this.inputFormat);
        this.inputFormat = this._inputDateParts.map(p => p.format).join('');
        if (!this.nativeElement.placeholder || this._inputFormat !== this.inputFormat) {
            this.renderer.setAttribute(this.nativeElement, 'placeholder', defPlaceholder);
        }
        // TODO: fill in partial dates?
        this.updateMask();
        this._inputFormat = this.inputFormat;
    }
    // TODO: move isDate to utils
    isDate(value) {
        return value instanceof Date && typeof value === 'object';
    }
    valueInRange(value) {
        if (!value) {
            return false;
        }
        const maxValueAsDate = this.isDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);
        const minValueAsDate = this.isDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);
        if (minValueAsDate
            && DatePickerUtil.lessThanMinValue(value, minValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return false;
        }
        if (maxValueAsDate
            && DatePickerUtil.greaterThanMaxValue(value, maxValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return false;
        }
        return true;
    }
    spinValue(datePart, delta) {
        if (!this.value || !this.isValidDate(this.value)) {
            return null;
        }
        const newDate = new Date(this.value.getTime());
        switch (datePart) {
            case DatePart.Date:
                DatePickerUtil.spinDate(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Month:
                DatePickerUtil.spinMonth(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Year:
                DatePickerUtil.spinYear(delta, newDate);
                break;
            case DatePart.Hours:
                DatePickerUtil.spinHours(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Minutes:
                DatePickerUtil.spinMinutes(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Seconds:
                DatePickerUtil.spinSeconds(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.AmPm:
                const formatPart = this._inputDateParts.find(dp => dp.type === DatePart.AmPm);
                const amPmFromMask = this.inputValue.substring(formatPart.start, formatPart.end);
                return DatePickerUtil.spinAmPm(newDate, this.value, amPmFromMask);
        }
        return newDate;
    }
    updateValue(newDate) {
        this._oldValue = this.value;
        this.value = newDate;
        if (this.value && !this.valueInRange(this.value)) {
            this.validationFailed.emit({ oldValue: this._oldValue, newValue: this.value, userInput: this.inputValue });
        }
        if (this.inputIsComplete() || this.inputValue === this.emptyMask) {
            this.valueChange.emit(this.value);
        }
    }
    toTwelveHourFormat(value) {
        let hour = parseInt(value.replace(new RegExp(this.promptChar, 'g'), '0'), 10);
        if (hour > 12) {
            hour -= 12;
        }
        else if (hour === 0) {
            hour = 12;
        }
        return hour;
    }
    getPartValue(datePartInfo, partLength) {
        let maskedValue;
        const datePart = datePartInfo.type;
        switch (datePart) {
            case DatePart.Date:
                maskedValue = this.value.getDate();
                break;
            case DatePart.Month:
                // months are zero based
                maskedValue = this.value.getMonth() + 1;
                break;
            case DatePart.Year:
                if (partLength === 2) {
                    maskedValue = this.prependValue(parseInt(this.value.getFullYear().toString().slice(-2), 10), partLength, '0');
                }
                else {
                    maskedValue = this.value.getFullYear();
                }
                break;
            case DatePart.Hours:
                if (datePartInfo.format.indexOf('h') !== -1) {
                    maskedValue = this.prependValue(this.toTwelveHourFormat(this.value.getHours().toString()), partLength, '0');
                }
                else {
                    maskedValue = this.value.getHours();
                }
                break;
            case DatePart.Minutes:
                maskedValue = this.value.getMinutes();
                break;
            case DatePart.Seconds:
                maskedValue = this.value.getSeconds();
                break;
            case DatePart.AmPm:
                maskedValue = this.value.getHours() >= 12 ? 'PM' : 'AM';
                break;
        }
        if (datePartInfo.type !== DatePart.AmPm) {
            return this.prependValue(maskedValue, partLength, '0');
        }
        return maskedValue;
    }
    prependValue(value, partLength, prependChar) {
        return (prependChar + value.toString()).slice(-partLength);
    }
    spin(event) {
        event.preventDefault();
        switch (event.key) {
            case "ArrowUp" /* UP_ARROW */:
            case "Up" /* UP_ARROW_IE */:
                this.increment();
                break;
            case "ArrowDown" /* DOWN_ARROW */:
            case "Down" /* DOWN_ARROW_IE */:
                this.decrement();
                break;
        }
    }
    inputIsComplete() {
        return this.inputValue.indexOf(this.promptChar) === -1;
    }
    isValidDate(date) {
        return date && date.getTime && !isNaN(date.getTime());
    }
    moveCursor(event) {
        const value = event.target.value;
        switch (event.key) {
            case "ArrowLeft" /* LEFT_ARROW */:
            case "Left" /* LEFT_ARROW_IE */:
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.setSelectionRange(this.getNewPosition(value));
                }
                break;
            case "ArrowRight" /* RIGHT_ARROW */:
            case "Right" /* RIGHT_ARROW_IE */:
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.setSelectionRange(this.getNewPosition(value, 1));
                }
                break;
        }
    }
    /**
     * Move the cursor in a specific direction until it reaches a date/time separator.
     * Then return its index.
     *
     * @param value The string it operates on.
     * @param direction 0 is left, 1 is right. Default is 0.
     */
    getNewPosition(value, direction = 0) {
        const literals = this._inputDateParts.filter(p => p.type === DatePart.Literal);
        let cursorPos = this.selectionStart;
        if (!direction) {
            do {
                cursorPos = cursorPos > 0 ? --cursorPos : cursorPos;
            } while (!literals.some(l => l.end === cursorPos) && cursorPos > 0);
            return cursorPos;
        }
        else {
            do {
                cursorPos++;
            } while (!literals.some(l => l.start === cursorPos) && cursorPos < value.length);
            return cursorPos;
        }
    }
}
IgxDateTimeEditorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDateTimeEditor]',
                exportAs: 'igxDateTimeEditor',
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: IgxDateTimeEditorDirective, multi: true },
                    { provide: NG_VALIDATORS, useExisting: IgxDateTimeEditorDirective, multi: true }
                ]
            },] }
];
IgxDateTimeEditorDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: MaskParsingService },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
IgxDateTimeEditorDirective.propDecorators = {
    locale: [{ type: Input }],
    minValue: [{ type: Input }],
    maxValue: [{ type: Input }],
    isSpinLoop: [{ type: Input }],
    displayFormat: [{ type: Input }],
    inputFormat: [{ type: Input, args: [`igxDateTimeEditor`,] }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    validationFailed: [{ type: Output }]
};
class IgxDateTimeEditorModule {
}
IgxDateTimeEditorModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxDateTimeEditorDirective],
                exports: [IgxDateTimeEditorDirective]
            },] }
];

/**
 * Provides base filtering operations
 * Implementations should be Singleton
 *
 * @export
 */
class IgxFilteringOperand {
    constructor() {
        this.operations = [{
                name: 'null',
                isUnary: true,
                iconName: 'is-null',
                logic: (target) => target === null
            }, {
                name: 'notNull',
                isUnary: true,
                iconName: 'is-not-null',
                logic: (target) => target !== null
            }, {
                name: 'in',
                isUnary: false,
                iconName: 'is-in',
                hidden: true,
                logic: (target, searchVal) => this.findValueInSet(target, searchVal)
            }];
    }
    static instance() {
        return this._instance || (this._instance = new this());
    }
    /**
     * Returns an array of names of the conditions which are visible in the UI
     */
    conditionList() {
        return this.operations.filter(f => !f.hidden).map((element) => element.name);
    }
    /**
     * Returns an instance of the condition with the specified name.
     *
     * @param name The name of the condition.
     */
    condition(name) {
        return this.operations.find((element) => element.name === name);
    }
    /**
     * Adds a new condition to the filtering operations.
     *
     * @param operation The filtering operation.
     */
    append(operation) {
        this.operations.push(operation);
    }
    /**
     * @hidden
     */
    findValueInSet(target, searchVal) {
        return searchVal.has(target);
    }
}
IgxFilteringOperand._instance = null;
/**
 * Provides filtering operations for booleans
 *
 * @export
 */
class IgxBooleanFilteringOperand extends IgxFilteringOperand {
    constructor() {
        super();
        this.operations = [{
                name: 'all',
                isUnary: true,
                iconName: 'select-all',
                logic: (target) => true
            }, {
                name: 'true',
                isUnary: true,
                iconName: 'is-true',
                logic: (target) => !!(target && target !== null && target !== undefined)
            }, {
                name: 'false',
                isUnary: true,
                iconName: 'is-false',
                logic: (target) => !target && target !== null && target !== undefined
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'is-empty',
                logic: (target) => target === null || target === undefined
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not-empty',
                logic: (target) => target !== null && target !== undefined
            }].concat(this.operations);
    }
}
/**
 * Provides filtering operations for Dates
 *
 * @export
 */
class IgxDateFilteringOperand extends IgxFilteringOperand {
    constructor() {
        super();
        this.operations = [{
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: (target, searchVal) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    const searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                    return targetp.year === searchp.year &&
                        targetp.month === searchp.month &&
                        targetp.day === searchp.day;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not-equal',
                logic: (target, searchVal) => {
                    if (!target) {
                        return true;
                    }
                    this.validateInputData(target);
                    const targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    const searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                    return targetp.year !== searchp.year ||
                        targetp.month !== searchp.month ||
                        targetp.day !== searchp.day;
                }
            }, {
                name: 'before',
                isUnary: false,
                iconName: 'is-before',
                logic: (target, searchVal) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    return target < searchVal;
                }
            }, {
                name: 'after',
                isUnary: false,
                iconName: 'is-after',
                logic: (target, searchVal) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    return target > searchVal;
                }
            }, {
                name: 'today',
                isUnary: true,
                iconName: 'today',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yMd');
                    return d.year === now.year &&
                        d.month === now.month &&
                        d.day === now.day;
                }
            }, {
                name: 'yesterday',
                isUnary: true,
                iconName: 'yesterday',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const td = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    const y = ((d) => new Date(d.setDate(d.getDate() - 1)))(new Date());
                    const yesterday = IgxDateFilteringOperand.getDateParts(y, 'yMd');
                    return td.year === yesterday.year &&
                        td.month === yesterday.month &&
                        td.day === yesterday.day;
                }
            }, {
                name: 'thisMonth',
                isUnary: true,
                iconName: 'this-month',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'lastMonth',
                isUnary: true,
                iconName: 'last-month',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    if (!now.month) {
                        now.month = 11;
                        now.year -= 1;
                    }
                    else {
                        now.month--;
                    }
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'nextMonth',
                isUnary: true,
                iconName: 'next-month',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    if (now.month === 11) {
                        now.month = 0;
                        now.year += 1;
                    }
                    else {
                        now.month++;
                    }
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'thisYear',
                isUnary: true,
                iconName: 'this-year',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year;
                }
            }, {
                name: 'lastYear',
                isUnary: true,
                iconName: 'last-year',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year - 1;
                }
            }, {
                name: 'nextYear',
                isUnary: true,
                iconName: 'next-year',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year + 1;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'is-empty',
                logic: (target) => target === null || target === undefined
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not-empty',
                logic: (target) => target !== null && target !== undefined
            }].concat(this.operations);
    }
    /**
     * Splits a Date object into parts
     *
     * @memberof IgxDateFilteringOperand
     */
    static getDateParts(date, dateFormat) {
        const res = {
            day: null,
            hours: null,
            milliseconds: null,
            minutes: null,
            month: null,
            seconds: null,
            year: null
        };
        if (!date || !dateFormat) {
            return res;
        }
        if (dateFormat.indexOf('y') >= 0) {
            res.year = date.getFullYear();
        }
        if (dateFormat.indexOf('M') >= 0) {
            res.month = date.getMonth();
        }
        if (dateFormat.indexOf('d') >= 0) {
            res.day = date.getDate();
        }
        if (dateFormat.indexOf('h') >= 0) {
            res.hours = date.getHours();
        }
        if (dateFormat.indexOf('m') >= 0) {
            res.minutes = date.getMinutes();
        }
        if (dateFormat.indexOf('s') >= 0) {
            res.seconds = date.getSeconds();
        }
        if (dateFormat.indexOf('f') >= 0) {
            res.milliseconds = date.getMilliseconds();
        }
        return res;
    }
    findValueInSet(target, searchVal) {
        if (!target) {
            return false;
        }
        return searchVal.has(target.toISOString());
    }
    validateInputData(target) {
        if (!(target instanceof Date)) {
            throw new Error('Could not perform filtering on \'date\' column because the datasource object type is not \'Date\'.');
        }
    }
}
/**
 * Provides filtering operations for numbers
 *
 * @export
 */
class IgxNumberFilteringOperand extends IgxFilteringOperand {
    constructor() {
        super();
        this.operations = [{
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: (target, searchVal) => target === searchVal
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not-equal',
                logic: (target, searchVal) => target !== searchVal
            }, {
                name: 'greaterThan',
                isUnary: false,
                iconName: 'greater-than',
                logic: (target, searchVal) => target > searchVal
            }, {
                name: 'lessThan',
                isUnary: false,
                iconName: 'less-than',
                logic: (target, searchVal) => target < searchVal
            }, {
                name: 'greaterThanOrEqualTo',
                isUnary: false,
                iconName: 'greater-than-or-equal',
                logic: (target, searchVal) => target >= searchVal
            }, {
                name: 'lessThanOrEqualTo',
                isUnary: false,
                iconName: 'less-than-or-equal',
                logic: (target, searchVal) => target <= searchVal
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'is-empty',
                logic: (target) => target === null || target === undefined || isNaN(target)
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not-empty',
                logic: (target) => target !== null && target !== undefined && !isNaN(target)
            }].concat(this.operations);
    }
}
/**
 * Provides filtering operations for strings
 *
 * @export
 */
class IgxStringFilteringOperand extends IgxFilteringOperand {
    constructor() {
        super();
        this.operations = [{
                name: 'contains',
                isUnary: false,
                iconName: 'contains',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.indexOf(search) !== -1;
                }
            }, {
                name: 'doesNotContain',
                isUnary: false,
                iconName: 'does-not-contain',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.indexOf(search) === -1;
                }
            }, {
                name: 'startsWith',
                isUnary: false,
                iconName: 'starts-with',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.startsWith(search);
                }
            }, {
                name: 'endsWith',
                isUnary: false,
                iconName: 'ends-with',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.endsWith(search);
                }
            }, {
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target === search;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not-equal',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target !== search;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'is-empty',
                logic: (target) => target === null || target === undefined || target.length === 0
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not-empty',
                logic: (target) => target !== null && target !== undefined && target.length > 0
            }].concat(this.operations);
    }
    /**
     * Applies case sensitivity on strings if provided
     *
     * @memberof IgxStringFilteringOperand
     */
    static applyIgnoreCase(a, ignoreCase) {
        a = a !== null && a !== void 0 ? a : '';
        // bulletproof
        return ignoreCase ? ('' + a).toLowerCase() : a;
    }
}

const filteringStateDefaults = {
    strategy: new FilteringStrategy()
};

/**
 * @hidden
 */
class GroupedRecords extends Array {
}

class IgxGridActionButtonComponent {
    constructor() {
        /**
         * Event emitted when action button is clicked.
         *
         * @example
         * ```html
         *  <igx-grid-action-button (actionClick)="startEdit($event)"></igx-grid-action-button>
         * ```
         */
        this.actionClick = new EventEmitter();
        /**
         * Whether button action is rendered in menu and should container text label.
         */
        this.asMenuItem = false;
    }
    /** @hidden @internal */
    get containerClass() {
        return 'igx-action-strip__menu-button ' + (this.classNames || '');
    }
    /**
     * @hidden
     * @internal
     */
    handleClick(event) {
        this.actionClick.emit(event);
    }
    /**
     * @hidden @internal
     */
    preventEvent(event) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
    }
}
IgxGridActionButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-grid-action-button',
                template: "<ng-container *ngIf=\"!asMenuItem\">\n\n    <ng-container *ngIf=\"!asMenuItem\">\n        <button igxButton=\"icon\" igxRipple (click)=\"handleClick($event)\" (mousedown)=\"preventEvent($event)\">\n            <igx-icon *ngIf=\"iconSet\" [family]=\"iconSet\" [name]=\"iconName\">{{iconName}}</igx-icon>\n            <igx-icon *ngIf=\"!iconSet\" >{{iconName}}</igx-icon>\n        </button>\n    </ng-container>\n\n    <ng-container *ngIf=\"asMenuItem\">\n        <div #container [className]='containerClass'>\n            <igx-icon *ngIf=\"iconSet\" [family]=\"iconSet\" [name]=\"iconName\">{{iconName}}</igx-icon>\n            <igx-icon *ngIf=\"!iconSet\" >{{iconName}}</igx-icon>\n            <label *ngIf='asMenuItem' igxLabel>{{labelText}}</label>\n        </div>\n    </ng-container>\n</ng-container>\n"
            },] }
];
IgxGridActionButtonComponent.propDecorators = {
    container: [{ type: ViewChild, args: ['container',] }],
    actionClick: [{ type: Output }],
    templateRef: [{ type: ViewChild, args: [TemplateRef,] }],
    asMenuItem: [{ type: Input }],
    iconName: [{ type: Input }],
    classNames: [{ type: Input }],
    iconSet: [{ type: Input }],
    labelText: [{ type: Input }]
};

const LabelPosition = mkenum({
    BEFORE: 'before',
    AFTER: 'after'
});
let nextId$2 = 0;
/**
 * Allows users to make a binary choice for a certain condition.
 *
 * @igxModule IgxCheckboxModule
 *
 * @igxTheme igx-checkbox-theme
 *
 * @igxKeywords checkbox, label
 *
 * @igxGroup Data entry and display
 *
 * @remarks
 * The Ignite UI Checkbox is a selection control that allows users to make a binary choice for a certain condition.It behaves similarly
 * to the native browser checkbox.
 *
 * @example
 * ```html
 * <igx-checkbox checked="true">
 *   simple checkbox
 * </igx-checkbox>
 * ```
 */
class IgxCheckboxComponent {
    constructor() {
        /**
         * An event that is emitted after the checkbox state is changed.
         * Provides references to the `IgxCheckboxComponent` and the `checked` property as event arguments.
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.change = new EventEmitter();
        /**
         * Sets/gets the `id` of the checkbox component.
         * If not set, the `id` of the first checkbox component will be `"igx-checkbox-0"`.
         *
         * @example
         * ```html
         * <igx-checkbox id="my-first-checkbox"></igx-checkbox>
         * ```
         * ```typescript
         * let checkboxId =  this.checkbox.id;
         * ```
         */
        this.id = `igx-checkbox-${nextId$2++}`;
        /**
         * Sets/gets the id of the `label` element.
         * If not set, the id of the `label` in the first checkbox component will be `"igx-checkbox-0-label"`.
         *
         * @example
         * ```html
         * <igx-checkbox labelId = "Label1"></igx-checkbox>
         * ```
         * ```typescript
         * let labelId =  this.checkbox.labelId;
         * ```
         */
        this.labelId = `${this.id}-label`;
        /**
         * Sets/gets the value of the `tabindex` attribute.
         *
         * @example
         * ```html
         * <igx-checkbox [tabindex] = "1"></igx-checkbox>
         * ```
         * ```typescript
         * let tabIndex =  this.checkbox.tabindex;
         * ```
         */
        this.tabindex = null;
        /**
         *  Sets/gets the position of the `label`.
         *  If not set, the `labelPosition` will have value `"after"`.
         *
         * @example
         * ```html
         * <igx-checkbox labelPosition = "before"></igx-checkbox>
         * ```
         * ```typescript
         * let labelPosition =  this.checkbox.labelPosition;
         * ```
         */
        this.labelPosition = LabelPosition.AFTER;
        /**
         * Enables/Disables the ripple effect.
         * If not set, `disableRipple` will have value `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [disableRipple] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isRippleDisabled = this.checkbox.desableRipple;
         * ```
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether the checkbox is required.
         * If not set, `required` will have value `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [required] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isRequired =  this.checkbox.required;
         * ```
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledby` attribute.
         * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
         *
         * @example
         * ```html
         * <igx-checkbox aria-labelledby = "Checkbox1"></igx-checkbox>
         * ```
         * ```typescript
         * let ariaLabelledBy =  this.checkbox.ariaLabelledBy;
         * ```
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the value of the `aria-label` attribute.
         *
         * @example
         * ```html
         * <igx-checkbox aria-label = "Checkbox1"></igx-checkbox>
         * ```
         * ```typescript
         * let ariaLabel = this.checkbox.ariaLabel;
         * ```
         */
        this.ariaLabel = null;
        /**
         * Returns the class of the checkbox component.
         *
         * @example
         * ```typescript
         * let class =  this.checkbox.cssClass;
         * ```
         */
        this.cssClass = 'igx-checkbox';
        /**
         * Sets/gets whether the checkbox component is on focus.
         * Default value is `false`.
         *
         * @example
         * ```typescript
         * this.checkbox.focused =  true;
         * ```
         * ```typescript
         * let isFocused =  this.checkbox.focused;
         * ```
         */
        this.focused = false;
        /**
         * Sets/gets the checkbox indeterminate visual state.
         * Default value is `false`;
         *
         * @example
         * ```html
         * <igx-checkbox [indeterminate] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isIndeterminate = this.checkbox.indeterminate;
         * ```
         */
        this.indeterminate = false;
        /**
         * Sets/gets whether the checkbox is checked.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [checked] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isChecked =  this.checkbox.checked;
         * ```
         */
        this.checked = false;
        /**
         * Sets/gets whether the checkbox is disabled.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [disabled] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isDisabled = this.checkbox.disabled;
         * ```
         */
        this.disabled = false;
        /**
         * Sets/gets whether the checkbox is readonly.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [readonly]="true"></igx-checkbox>
         * ```
         * ```typescript
         * let readonly = this.checkbox.readonly;
         * ```
         */
        this.readonly = false;
        /**
         * Sets/gets whether the checkbox should disable all css transitions.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [disableTransitions]="true"></igx-checkbox>
         * ```
         * ```typescript
         * let disableTransitions = this.checkbox.disableTransitions;
         * ```
         */
        this.disableTransitions = false;
        /** @hidden @internal */
        this.inputId = `${this.id}-input`;
        /**
         * @hidden
         */
        this._onTouchedCallback = noop;
        /**
         * @hidden
         */
        this._onChangeCallback = noop;
    }
    /**
     * @hidden
     * @internal
     */
    onKeyUp(event) {
        event.stopPropagation();
        this.focused = true;
    }
    /**
     * If `disabled` is `false`, switches the `checked` state.
     *
     * @example
     * ```typescript
     * this.checkbox.toggle();
     * ```
     */
    toggle() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.nativeCheckbox.nativeElement.focus();
        this.indeterminate = false;
        this.checked = !this.checked;
        this.change.emit({ checked: this.checked, checkbox: this });
        this._onChangeCallback(this.checked);
    }
    /** @hidden @internal */
    _onCheckboxChange(event) {
        // We have to stop the original checkbox change event
        // from bubbling up since we emit our own change event
        event.stopPropagation();
    }
    /** @hidden @internal */
    _onCheckboxClick(event) {
        // Since the original checkbox is hidden and the label
        // is used for styling and to change the checked state of the checkbox,
        // we need to prevent the checkbox click event from bubbling up
        // as it gets triggered on label click
        event.stopPropagation();
        if (this.readonly) {
            // readonly prevents the component from changing state (see toggle() method).
            // However, the native checkbox can still be activated through user interaction (focus + space, label click)
            // Prevent the native change so the input remains in sync
            event.preventDefault();
        }
        this.toggle();
        if (isIE()) {
            this.nativeCheckbox.nativeElement.blur();
        }
    }
    /** @hidden @internal */
    _onLabelClick() {
        // We use a span element as a placeholder label
        // in place of the native label, we need to emit
        // the change event separately here alongside
        // the click event emitted on click
        this.toggle();
    }
    /** @hidden @internal */
    onBlur() {
        this.focused = false;
        this._onTouchedCallback();
    }
    /** @hidden @internal */
    writeValue(value) {
        this._value = value;
        this.checked = !!this._value;
    }
    /** @hidden @internal */
    get labelClass() {
        switch (this.labelPosition) {
            case LabelPosition.BEFORE:
                return `${this.cssClass}__label--before`;
            case LabelPosition.AFTER:
            default:
                return `${this.cssClass}__label`;
        }
    }
    /** @hidden @internal */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /** @hidden @internal */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /** @hidden @internal */
    getEditElement() {
        return this.nativeCheckbox.nativeElement;
    }
}
IgxCheckboxComponent.decorators = [
    { type: Component, args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxCheckboxComponent, multi: true }],
                selector: 'igx-checkbox',
                preserveWhitespaces: false,
                template: "<input #checkbox class=\"igx-checkbox__input\"\n    type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [indeterminate]=\"indeterminate\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onCheckboxChange($event)\"\n    (click)=\"_onCheckboxClick($event)\"\n    (blur)=\"onBlur()\" />\n\n<div\n    igxRipple\n    igxRippleTarget=\".igx-checkbox__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    class=\"igx-checkbox__composite-wrapper\"\n>\n    <label #label class=\"igx-checkbox__composite\"\n        [attr.for]=\"inputId\">\n        <svg class=\"igx-checkbox__composite-mark\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n            <path d=\"M4.1,12.7 9,17.6 20.3,6.3\" />\n        </svg>\n    </label>\n\n    <div class=\"igx-checkbox__ripple\"></div>\n</div>\n\n<span #placeholderLabel\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick()\">\n    <ng-content></ng-content>\n</span>\n"
            },] }
];
IgxCheckboxComponent.propDecorators = {
    change: [{ type: Output }],
    nativeCheckbox: [{ type: ViewChild, args: ['checkbox', { static: true },] }],
    nativeLabel: [{ type: ViewChild, args: ['label', { static: true },] }],
    placeholderLabel: [{ type: ViewChild, args: ['placeholderLabel', { static: true },] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    labelId: [{ type: Input }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    tabindex: [{ type: Input }],
    labelPosition: [{ type: Input }],
    disableRipple: [{ type: Input }],
    required: [{ type: Input }],
    ariaLabelledBy: [{ type: Input, args: ['aria-labelledby',] }],
    ariaLabel: [{ type: Input, args: ['aria-label',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-checkbox',] }],
    focused: [{ type: HostBinding, args: ['class.igx-checkbox--focused',] }],
    indeterminate: [{ type: HostBinding, args: ['class.igx-checkbox--indeterminate',] }, { type: Input }],
    checked: [{ type: HostBinding, args: ['class.igx-checkbox--checked',] }, { type: Input }],
    disabled: [{ type: HostBinding, args: ['class.igx-checkbox--disabled',] }, { type: Input }],
    readonly: [{ type: Input }],
    disableTransitions: [{ type: HostBinding, args: ['class.igx-checkbox--plain',] }, { type: Input }],
    onKeyUp: [{ type: HostListener, args: ['keyup', ['$event'],] }]
};
const IGX_CHECKBOX_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => IgxCheckboxRequiredDirective),
    multi: true
};
/* eslint-disable  @angular-eslint/directive-selector */
class IgxCheckboxRequiredDirective extends CheckboxRequiredValidator {
}
IgxCheckboxRequiredDirective.decorators = [
    { type: Directive, args: [{
                selector: `igx-checkbox[required][formControlName],
    igx-checkbox[required][formControl],
    igx-checkbox[required][ngModel]`,
                providers: [IGX_CHECKBOX_REQUIRED_VALIDATOR]
            },] }
];
/**
 * @hidden
 */
class IgxCheckboxModule {
}
IgxCheckboxModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                exports: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                imports: [IgxRippleModule]
            },] }
];

/**
 * @hidden
 */
class GridBaseAPIService {
    constructor() {
        this.destroyMap = new Map();
    }
    get_column_by_name(name) {
        return this.grid.columnList.find((col) => col.field === name);
    }
    get_summary_data() {
        const grid = this.grid;
        let data = grid.filteredData;
        if (data && grid.hasPinnedRecords) {
            data = grid._filteredUnpinnedData;
        }
        if (!data) {
            if (grid.transactions.enabled) {
                data = DataUtil.mergeTransactions(cloneArray(grid.data), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
                const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === TransactionType.DELETE).map(t => t.id);
                deletedRows.forEach(rowID => {
                    const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
                    const index = tempData.indexOf(rowID);
                    if (index !== -1) {
                        data.splice(index, 1);
                    }
                });
            }
            else {
                data = grid.data;
            }
        }
        return data;
    }
    /**
     * @hidden
     * @internal
     */
    getRowData(rowID) {
        const data = this.get_all_data(this.grid.transactions.enabled);
        const index = this.get_row_index_in_data(rowID, data);
        return data[index];
    }
    get_row_index_in_data(rowID, dataCollection) {
        const grid = this.grid;
        if (!grid) {
            return -1;
        }
        const data = dataCollection !== null && dataCollection !== void 0 ? dataCollection : this.get_all_data(grid.transactions.enabled);
        return grid.primaryKey ? data.findIndex(record => record.recordRef ? record.recordRef[grid.primaryKey] === rowID
            : record[grid.primaryKey] === rowID) : data.indexOf(rowID);
    }
    get_row_by_key(rowSelector) {
        if (!this.grid) {
            return null;
        }
        const primaryKey = this.grid.primaryKey;
        if (primaryKey !== undefined && primaryKey !== null) {
            return this.grid.dataRowList.find((row) => row.rowData[primaryKey] === rowSelector);
        }
        else {
            return this.grid.dataRowList.find((row) => row.rowData === rowSelector);
        }
    }
    get_row_by_index(rowIndex) {
        return this.grid.rowList.find((row) => row.index === rowIndex);
    }
    get_cell_by_key(rowSelector, field) {
        const row = this.get_row_by_key(rowSelector);
        if (row && row.cells) {
            return row.cells.find((cell) => cell.column.field === field);
        }
    }
    get_cell_by_index(rowIndex, columnIndex) {
        const row = this.get_row_by_index(rowIndex);
        if (row && row.cells) {
            return row.cells.find((cell) => cell.columnIndex === columnIndex);
        }
    }
    get_cell_by_visible_index(rowIndex, columnIndex) {
        const row = this.get_row_by_index(rowIndex);
        if (row && row.cells) {
            return row.cells.find((cell) => cell.visibleColumnIndex === columnIndex);
        }
    }
    submit_value(event) {
        const cell = this.grid.crudService.cell;
        if (cell) {
            const args = this.update_cell(cell, cell.editValue, event);
            this.grid.crudService.cellEditingBlocked = args.cancel;
            if (args.cancel) {
                return args.cancel;
            }
            this.grid.crudService.exitCellEdit(event);
        }
    }
    submit_add_value(event) {
        const cell = this.grid.crudService.cell;
        if (cell) {
            const args = this.update_add_cell(cell, cell.editValue, event);
            if (args.cancel) {
                this.grid.endAddRow();
                return args.cancel;
            }
            return this.grid.crudService.exitCellEdit(event);
        }
    }
    update_add_cell(cell, value, event) {
        cell.editValue = value;
        const args = cell.createEditEventArgs(true, event);
        if (isEqual(args.oldValue, args.newValue)) {
            return args;
        }
        this.grid.cellEdit.emit(args);
        this.grid.crudService.cellEditingBlocked = args.cancel;
        if (args.cancel) {
            return args;
        }
        const data = cell.rowData;
        if (cell.column.hasNestedPath) {
            mergeObjects(data, reverseMapper(cell.column.field, args.newValue));
        }
        else {
            data[cell.column.field] = args.newValue;
        }
        this.grid.crudService.row.data = data;
        const doneArgs = cell.createDoneEditEventArgs(args.newValue, event);
        doneArgs.rowData = data;
        this.grid.cellEditDone.emit(doneArgs);
        return args;
    }
    update_cell(cell, value, event) {
        cell.editValue = value;
        const args = cell.createEditEventArgs(true, event);
        if (isEqual(args.oldValue, args.newValue)) {
            return args;
        }
        this.grid.cellEdit.emit(args);
        this.grid.crudService.cellEditingBlocked = args.cancel;
        if (args.cancel) {
            return args;
        }
        this.grid.summaryService.clearSummaryCache(args);
        const data = this.getRowData(cell.id.rowID);
        this.updateData(this.grid, cell.id.rowID, data, cell.rowData, reverseMapper(cell.column.field, args.newValue));
        if (this.grid.primaryKey === cell.column.field) {
            if (this.grid.selectionService.isRowSelected(cell.id.rowID)) {
                this.grid.selectionService.deselectRow(cell.id.rowID);
                this.grid.selectionService.selectRowById(args.newValue);
            }
            if (this.grid.hasSummarizedColumns) {
                this.grid.summaryService.removeSummaries(cell.id.rowID);
            }
        }
        if (!this.grid.rowEditable || !this.grid.crudService.row ||
            this.grid.crudService.row.id !== cell.id.rowID || !this.grid.transactions.enabled) {
            this.grid.summaryService.clearSummaryCache(args);
            this.grid._pipeTrigger++;
        }
        const doneArgs = cell.createDoneEditEventArgs(args.newValue, event);
        this.grid.cellEditDone.emit(doneArgs);
        return args;
    }
    _update_row(row, value) {
        const grid = this.grid;
        const rowInEditMode = grid.crudService.row;
        row.newData = value !== null && value !== void 0 ? value : rowInEditMode.transactionState;
        if (rowInEditMode && row.id === rowInEditMode.id) {
            row.data = Object.assign(Object.assign({}, row.data), rowInEditMode.transactionState);
            // TODO: Workaround for updating a row in edit mode through the API
        }
        else if (this.grid.transactions.enabled) {
            const state = grid.transactions.getState(row.id);
            row.data = state ? Object.assign({}, row.data, state.value) : row.data;
        }
    }
    update_row(row, value, event) {
        const grid = this.grid;
        const selected = grid.selectionService.isRowSelected(row.id);
        const rowInEditMode = grid.crudService.row;
        const data = this.get_all_data(grid.transactions.enabled);
        const index = this.get_row_index_in_data(row.id, data);
        const hasSummarized = grid.hasSummarizedColumns;
        this._update_row(row, value);
        const args = row.createEditEventArgs(true, event);
        // If no valid row is found
        if (index === -1) {
            return args;
        }
        grid.rowEdit.emit(args);
        if (args.cancel) {
            return args;
        }
        const cachedRowData = Object.assign({}, args.oldValue);
        if (rowInEditMode) {
            const hasChanges = grid.transactions.getState(args.rowID, true);
            grid.transactions.endPending(false);
            if (!hasChanges) {
                return args;
            }
        }
        if (!args.newValue) {
            return args;
        }
        if (hasSummarized) {
            grid.summaryService.removeSummaries(args.rowID);
        }
        this.updateData(grid, row.id, data[index], args.oldValue, args.newValue);
        const newId = grid.primaryKey ? args.newValue[grid.primaryKey] : args.newValue;
        if (selected) {
            grid.selectionService.deselectRow(row.id);
            grid.selectionService.selectRowById(newId);
        }
        // make sure selection is handled prior to updating the row.id
        row.id = newId;
        if (hasSummarized) {
            grid.summaryService.removeSummaries(newId);
        }
        grid._pipeTrigger++;
        const doneArgs = row.createDoneEditEventArgs(cachedRowData, event);
        grid.rowEditDone.emit(doneArgs);
        return args;
    }
    sort(expression) {
        if (expression.dir === SortingDirection.None) {
            this.remove_grouping_expression(expression.fieldName);
        }
        const sortingState = cloneArray(this.grid.sortingExpressions);
        this.prepare_sorting_expression([sortingState], expression);
        this.grid.sortingExpressions = sortingState;
    }
    sort_multiple(expressions) {
        const sortingState = cloneArray(this.grid.sortingExpressions);
        for (const each of expressions) {
            if (each.dir === SortingDirection.None) {
                this.remove_grouping_expression(each.fieldName);
            }
            this.prepare_sorting_expression([sortingState], each);
        }
        this.grid.sortingExpressions = sortingState;
    }
    clear_sort(fieldName) {
        const sortingState = this.grid.sortingExpressions;
        const index = sortingState.findIndex((expr) => expr.fieldName === fieldName);
        if (index > -1) {
            sortingState.splice(index, 1);
            this.grid.sortingExpressions = sortingState;
        }
    }
    clear_groupby(name) {
    }
    should_apply_number_style(column) {
        return column.dataType === DataType.Number;
    }
    get_data() {
        const grid = this.grid;
        const data = grid.data ? grid.data : [];
        return data;
    }
    get_all_data(includeTransactions = false) {
        const grid = this.grid;
        let data = grid && grid.data ? grid.data : [];
        data = includeTransactions ? grid.dataWithAddedInTransactionRows : data;
        return data;
    }
    get_filtered_data() {
        return this.grid.filteredData;
    }
    addRowToData(rowData, parentRowID) {
        // Add row goes to transactions and if rowEditable is properly implemented, added rows will go to pending transactions
        // If there is a row in edit - > commit and close
        const grid = this.grid;
        if (grid.transactions.enabled) {
            const transactionId = grid.primaryKey ? rowData[grid.primaryKey] : rowData;
            const transaction = { id: transactionId, type: TransactionType.ADD, newValue: rowData };
            grid.transactions.add(transaction);
        }
        else {
            grid.data.push(rowData);
        }
    }
    deleteRowFromData(rowID, index) {
        //  if there is a row (index !== 0) delete it
        //  if there is a row in ADD or UPDATE state change it's state to DELETE
        const grid = this.grid;
        if (index !== -1) {
            if (grid.transactions.enabled) {
                const transaction = { id: rowID, type: TransactionType.DELETE, newValue: null };
                grid.transactions.add(transaction, grid.data[index]);
            }
            else {
                grid.data.splice(index, 1);
            }
        }
        else {
            const state = grid.transactions.getState(rowID);
            grid.transactions.add({ id: rowID, type: TransactionType.DELETE, newValue: null }, state && state.recordRef);
        }
    }
    deleteRowById(rowId) {
        let index;
        const grid = this.grid;
        const data = this.get_all_data();
        if (grid.primaryKey) {
            index = data.map((record) => record[grid.primaryKey]).indexOf(rowId);
        }
        else {
            index = data.indexOf(rowId);
        }
        const state = grid.transactions.getState(rowId);
        const hasRowInNonDeletedState = state && state.type !== TransactionType.DELETE;
        //  if there is a row (index !== -1) and the we have cell in edit mode on same row exit edit mode
        //  if there is no row (index === -1), but there is a row in ADD or UPDATE state do as above
        //  Otherwise just exit - there is nothing to delete
        if (index !== -1 || hasRowInNonDeletedState) {
            // Always exit edit when row is deleted
            grid.endEdit(true);
        }
        else {
            return;
        }
        //  TODO: should we emit this when cascadeOnDelete is true for each row?!?!
        grid.onRowDeleted.emit({ data: data[index] });
        this.deleteRowFromData(rowId, index);
        if (grid.selectionService.isRowSelected(rowId)) {
            grid.selectionService.deselectRow(rowId);
        }
        else {
            grid.selectionService.clearHeaderCBState();
        }
        grid._pipeTrigger++;
        grid.notifyChanges();
        // Data needs to be recalculated if transactions are in place
        // If no transactions, `data` will be a reference to the grid getter, otherwise it will be stale
        const dataAfterDelete = grid.transactions.enabled ? grid.dataWithAddedInTransactionRows : data;
        grid.refreshSearch();
        if (dataAfterDelete.length % grid.perPage === 0 && dataAfterDelete.length / grid.perPage - 1 < grid.page && grid.page !== 0) {
            grid.page--;
        }
    }
    get_row_id(rowData) {
        return this.grid.primaryKey ? rowData[this.grid.primaryKey] : rowData;
    }
    row_deleted_transaction(rowID) {
        const grid = this.grid;
        if (!grid) {
            return false;
        }
        if (!grid.transactions.enabled) {
            return false;
        }
        const state = grid.transactions.getState(rowID);
        if (state) {
            return state.type === TransactionType.DELETE;
        }
        return false;
    }
    get_row_expansion_state(record) {
        const grid = this.grid;
        const states = grid.expansionStates;
        const rowID = grid.primaryKey ? record[grid.primaryKey] : record;
        const expanded = states.get(rowID);
        if (expanded !== undefined) {
            return expanded;
        }
        else {
            return grid.getDefaultExpandState(record);
        }
    }
    set_row_expansion_state(rowID, expanded, event) {
        const grid = this.grid;
        const expandedStates = grid.expansionStates;
        if (!this.allow_expansion_state_change(rowID, expanded)) {
            return;
        }
        const args = {
            rowID,
            expanded,
            event,
            cancel: false
        };
        grid.onRowToggle.emit(args);
        if (args.cancel) {
            return;
        }
        expandedStates.set(rowID, expanded);
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(false);
        }
    }
    get_rec_by_id(rowID) {
        return this.grid.primaryKey ? this.getRowData(rowID) : rowID;
    }
    allow_expansion_state_change(rowID, expanded) {
        return this.grid.expansionStates.get(rowID) !== expanded;
    }
    prepare_sorting_expression(stateCollections, expression) {
        if (expression.dir === SortingDirection.None) {
            stateCollections.forEach(state => {
                state.splice(state.findIndex((expr) => expr.fieldName === expression.fieldName), 1);
            });
            return;
        }
        /**
         * We need to make sure the states in each collection with same fields point to the same object reference.
         * If the different state collections provided have different sizes we need to get the largest one.
         * That way we can get the state reference from the largest one that has the same fieldName as the expression to prepare.
         */
        let maxCollection = stateCollections[0];
        for (let i = 1; i < stateCollections.length; i++) {
            if (maxCollection.length < stateCollections[i].length) {
                maxCollection = stateCollections[i];
            }
        }
        const maxExpr = maxCollection.find((expr) => expr.fieldName === expression.fieldName);
        stateCollections.forEach(collection => {
            const myExpr = collection.find((expr) => expr.fieldName === expression.fieldName);
            if (!myExpr && !maxExpr) {
                // Expression with this fieldName is missing from the current and the max collection.
                collection.push(expression);
            }
            else if (!myExpr && maxExpr) {
                // Expression with this fieldName is missing from the current and but the max collection has.
                collection.push(maxExpr);
                Object.assign(maxExpr, expression);
            }
            else {
                // The current collection has the expression so just update it.
                Object.assign(myExpr, expression);
            }
        });
    }
    remove_grouping_expression(fieldName) {
    }
    filterDataByExpressions(expressionsTree) {
        let data = this.get_all_data();
        if (expressionsTree.filteringOperands.length) {
            const state = { expressionsTree, strategy: this.grid.filterStrategy };
            data = DataUtil.filter(cloneArray(data), state, this.grid);
        }
        return data;
    }
    /**
     * Updates related row of provided grid's data source with provided new row value
     *
     * @param grid Grid to update data for
     * @param rowID ID of the row to update
     * @param rowValueInDataSource Initial value of the row as it is in data source
     * @param rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param rowNewValue New value of the row
     */
    updateData(grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
        if (grid.transactions.enabled) {
            const transaction = {
                id: rowID,
                type: TransactionType.UPDATE,
                newValue: rowNewValue
            };
            grid.transactions.add(transaction, rowCurrentValue);
        }
        else {
            mergeObjects(rowValueInDataSource, rowNewValue);
        }
    }
    update_row_in_array(value, rowID, index) {
        const grid = this.grid;
        grid.data[index] = value;
    }
    getSortStrategyPerColumn(fieldName) {
        return this.get_column_by_name(fieldName) ?
            this.get_column_by_name(fieldName).sortStrategy : undefined;
    }
}
GridBaseAPIService.decorators = [
    { type: Injectable }
];

// TODO: Refactor - export in a separate file
class IgxRow {
    constructor(id, index, data, grid) {
        this.id = id;
        this.index = index;
        this.data = data;
        this.grid = grid;
    }
    createEditEventArgs(includeNewValue = true, event) {
        const args = {
            rowID: this.id,
            rowData: this.data,
            oldValue: this.data,
            cancel: false,
            owner: this.grid,
            isAddRow: this.isAddRow || false,
            event
        };
        if (includeNewValue) {
            args.newValue = this.newData;
        }
        return args;
    }
    createDoneEditEventArgs(cachedRowData, event) {
        const updatedData = this.grid.transactions.enabled ?
            this.grid.transactions.getAggregatedValue(this.id, true) : this.grid.gridAPI.getRowData(this.id);
        const rowData = updatedData === null ? this.grid.gridAPI.getRowData(this.id) : updatedData;
        const args = {
            rowID: this.id,
            rowData,
            oldValue: cachedRowData,
            newValue: updatedData,
            owner: this.grid,
            isAddRow: this.isAddRow || false,
            event
        };
        return args;
    }
}
class IgxCell {
    constructor(id, rowIndex, column, value, editValue, rowData, grid) {
        this.id = id;
        this.rowIndex = rowIndex;
        this.column = column;
        this.value = value;
        this.editValue = editValue;
        this.rowData = rowData;
        this.grid = grid;
    }
    castToNumber(value) {
        if (this.column.dataType === 'number' && !this.column.inlineEditorTemplate) {
            const v = parseFloat(value);
            return !isNaN(v) && isFinite(v) ? v : 0;
        }
        return value;
    }
    createEditEventArgs(includeNewValue = true, event) {
        const args = {
            rowID: this.id.rowID,
            cellID: this.id,
            rowData: this.rowData,
            oldValue: this.value,
            cancel: false,
            column: this.column,
            owner: this.grid,
            event
        };
        if (includeNewValue) {
            args.newValue = this.castToNumber(this.editValue);
        }
        return args;
    }
    createDoneEditEventArgs(value, event) {
        const updatedData = this.grid.transactions.enabled ?
            this.grid.transactions.getAggregatedValue(this.id.rowID, true) : this.rowData;
        const rowData = updatedData === null ? this.grid.gridAPI.getRowData(this.id.rowID) : updatedData;
        const args = {
            rowID: this.id.rowID,
            cellID: this.id,
            // rowData - should be the updated/committed rowData - this effectively should be the newValue
            // the only case we use this.rowData directly, is when there is no rowEditing or transactions enabled
            rowData,
            oldValue: this.value,
            newValue: value,
            column: this.column,
            owner: this.grid,
            event
        };
        return args;
    }
}
class IgxGridCRUDService {
    constructor() {
        this.cell = null;
        this.row = null;
        this.isInCompositionMode = false;
        this._cellEditingBlocked = false;
        this._rowEditingBlocked = false;
    }
    createCell(cell) {
        return new IgxCell(cell.cellID, cell.rowIndex, cell.column, cell.value, cell.value, cell.row.rowData, cell.grid);
    }
    createRow(cell) {
        return new IgxRow(cell.id.rowID, cell.rowIndex, cell.rowData, cell.grid);
    }
    sameRow(rowID) {
        return this.row && this.row.id === rowID;
    }
    sameCell(cell) {
        return (this.cell.id.rowID === cell.id.rowID &&
            this.cell.id.columnID === cell.id.columnID);
    }
    get cellInEditMode() {
        return !!this.cell;
    }
    get rowInEditMode() {
        return !!this.row;
    }
    get rowEditing() {
        return this.grid.rowEditable;
    }
    get primaryKey() {
        return this.grid.primaryKey;
    }
    get cellEditingBlocked() {
        return this._cellEditingBlocked;
    }
    set cellEditingBlocked(val) {
        this._cellEditingBlocked = val;
    }
    get rowEditingBlocked() {
        return this._rowEditingBlocked;
    }
    set rowEditingBlocked(val) {
        this._rowEditingBlocked = val;
    }
    enterEditMode(cell, event) {
        if (this.isInCompositionMode) {
            return;
        }
        if (this.cellInEditMode) {
            // TODO: case solely for f2/enter nav that uses enterEditMode as toggle. Refactor.
            const canceled = this.grid.endEdit(true, event);
            if (!canceled || !this.cell) {
                this.grid.tbody.nativeElement.focus();
            }
        }
        else {
            if (cell === null || cell === void 0 ? void 0 : cell.row.addRow) {
                this.beginAddRow(cell, event);
                return;
            }
            /** Changing the reference with the new editable cell */
            const newCell = this.createCell(cell);
            if (this.rowEditing) {
                const canceled = this.beginRowEdit(newCell, event);
                if (!canceled) {
                    this.beginCellEdit(newCell, event);
                }
            }
            else {
                this.beginCellEdit(newCell, event);
            }
        }
    }
    /** Enters row edit mode */
    beginRowEdit(newCell, event) {
        if (this.row && !this.sameRow(newCell.id.rowID)) {
            this._rowEditingBlocked = this.grid.endEdit(true, event);
            if (this.rowEditingBlocked) {
                return true;
            }
            this.cell = newCell;
            this._rowEditingBlocked = false;
            this.endRowEdit();
        }
        if (this.grid.rowEditable && (this.grid.primaryKey === undefined || this.grid.primaryKey === null)) {
            console.warn('The grid must have a `primaryKey` specified when using `rowEditable`!');
        }
        if (!this.row) {
            this.cell = newCell;
            this.row = this.createRow(this.cell);
            const rowArgs = this.row.createEditEventArgs(false, event);
            this.grid.rowEditEnter.emit(rowArgs);
            if (rowArgs.cancel) {
                this.endEditMode();
                return true;
            }
            this.row.transactionState = this.grid.transactions.getAggregatedValue(this.row.id, true);
            this.grid.transactions.startPending();
            this.grid.openRowOverlay(this.row.id);
        }
    }
    /** Exit row edit mode */
    exitRowEdit(commit, event) {
        if (!this.grid.rowEditable ||
            this.grid.rowEditingOverlay &&
                this.grid.rowEditingOverlay.collapsed || !this.row) {
            return false;
        }
        if (this.rowEditingBlocked && this.cellEditingBlocked) {
            return true;
        }
        const canceled = this.grid.endRowTransaction(commit, this.row, event);
        if (canceled) {
            return true;
        }
    }
    /** Enters cell edit mode */
    beginAddRow(cell, event) {
        const newCell = this.createCell(cell);
        newCell.primaryKey = this.primaryKey;
        cell.enterAddMode = true;
        this.cell = newCell;
        if (!this.sameRow(newCell.id.rowID)) {
            this.row = this.createRow(this.cell);
            this.row.isAddRow = true;
            const rowArgs = this.row.createEditEventArgs(false, event);
            this.grid.rowEditEnter.emit(rowArgs);
            if (rowArgs.cancel) {
                this.endEditMode();
                this.grid.endAddRow();
                return;
            }
            this.grid.openRowOverlay(this.row.id);
        }
        const args = newCell.createEditEventArgs(false, event);
        this.grid.cellEditEnter.emit(args);
        if (args.cancel) {
            this.endCellEdit();
            return;
        }
    }
    beginCellEdit(newCell, event) {
        const args = newCell.createEditEventArgs(false, event);
        this.grid.cellEditEnter.emit(args);
        this._cellEditingBlocked = args.cancel;
        if (args.cancel) {
            this.endCellEdit();
        }
        else {
            this.cell = newCell;
        }
    }
    /** Exit cell edit mode */
    exitCellEdit(event) {
        var _a;
        if (!this.cell) {
            return false;
        }
        const newValue = this.cell.castToNumber(this.cell.editValue);
        const args = (_a = this.cell) === null || _a === void 0 ? void 0 : _a.createDoneEditEventArgs(newValue, event);
        this.cell.value = newValue;
        this.grid.cellEditExit.emit(args);
        this.endCellEdit();
        return false;
    }
    /** Clears cell editing state */
    endCellEdit() {
        this.cell = null;
        this.cellEditingBlocked = false;
    }
    /** Clears row editing state */
    endRowEdit() {
        this.row = null;
        this.rowEditingBlocked = false;
    }
    /** Clears cell and row editing state and closes row editing template if it is open */
    endEditMode() {
        this.endCellEdit();
        if (this.grid.rowEditable) {
            this.endRowEdit();
            this.grid.closeRowEditingOverlay();
        }
    }
    /** Returns whether the targeted cell is in edit mode */
    targetInEdit(rowIndex, columnIndex) {
        if (!this.cell) {
            return false;
        }
        const res = this.cell.column.index === columnIndex && this.cell.rowIndex === rowIndex;
        return res;
    }
}
IgxGridCRUDService.decorators = [
    { type: Injectable }
];
class IgxGridSelectionService {
    constructor(zone) {
        this.zone = zone;
        this.dragMode = false;
        this.keyboardState = {};
        this.pointerState = {};
        this.columnsState = {};
        this.selection = new Map();
        this.temp = new Map();
        this._ranges = new Set();
        this.rowSelection = new Set();
        this.indeterminateRows = new Set();
        this.columnSelection = new Set();
        /**
         * @hidden @internal
         */
        this.selectedRowsChange = new Subject();
        this.initPointerState();
        this.initKeyboardState();
        this.initColumnsState();
    }
    /**
     * Returns the current selected ranges in the grid from both
     * keyboard and pointer interactions
     */
    get ranges() {
        // The last action was keyboard + shift selection -> add it
        this.addKeyboardRange();
        const ranges = Array.from(this._ranges).map(range => JSON.parse(range));
        // No ranges but we have a focused cell -> add it
        if (!ranges.length && this.activeElement && this.grid.isCellSelectable) {
            ranges.push(this.generateRange(this.activeElement));
        }
        return ranges;
    }
    get primaryButton() {
        return this.pointerState.primaryButton;
    }
    set primaryButton(value) {
        this.pointerState.primaryButton = value;
    }
    /**
     * Resets the keyboard state
     */
    initKeyboardState() {
        this.keyboardState.node = null;
        this.keyboardState.shift = false;
        this.keyboardState.range = null;
        this.keyboardState.active = false;
    }
    /**
     * Resets the pointer state
     */
    initPointerState() {
        this.pointerState.node = null;
        this.pointerState.ctrl = false;
        this.pointerState.shift = false;
        this.pointerState.range = null;
        this.pointerState.primaryButton = true;
    }
    /**
     * Resets the columns state
     */
    initColumnsState() {
        this.columnsState.field = null;
        this.columnsState.range = [];
    }
    /**
     * Adds a single node.
     * Single clicks | Ctrl + single clicks on cells is the usual case.
     */
    add(node, addToRange = true) {
        if (this.selection.has(node.row)) {
            this.selection.get(node.row).add(node.column);
        }
        else {
            this.selection.set(node.row, new Set()).get(node.row).add(node.column);
        }
        if (addToRange) {
            this._ranges.add(JSON.stringify(this.generateRange(node)));
        }
    }
    /**
     * Adds the active keyboard range selection (if any) to the `ranges` meta.
     */
    addKeyboardRange() {
        if (this.keyboardState.range) {
            this._ranges.add(JSON.stringify(this.keyboardState.range));
        }
    }
    remove(node) {
        if (this.selection.has(node.row)) {
            this.selection.get(node.row).delete(node.column);
        }
        if (this.isActiveNode(node)) {
            this.activeElement = null;
        }
        this._ranges.delete(JSON.stringify(this.generateRange(node)));
    }
    isInMap(node) {
        return (this.selection.has(node.row) && this.selection.get(node.row).has(node.column)) ||
            (this.temp.has(node.row) && this.temp.get(node.row).has(node.column));
    }
    selected(node) {
        return (this.isActiveNode(node) && this.grid.isCellSelectable) || this.isInMap(node);
    }
    isActiveNode(node) {
        if (this.activeElement) {
            const isActive = this.activeElement.column === node.column && this.activeElement.row === node.row;
            if (this.grid.hasColumnLayouts) {
                const layout = this.activeElement.layout;
                return isActive && this.isActiveLayout(layout, node.layout);
            }
            return isActive;
        }
        return false;
    }
    isActiveLayout(current, target) {
        return current.columnVisibleIndex === target.columnVisibleIndex;
    }
    addRangeMeta(node, state) {
        this._ranges.add(JSON.stringify(this.generateRange(node, state)));
    }
    removeRangeMeta(node, state) {
        this._ranges.delete(JSON.stringify(this.generateRange(node, state)));
    }
    /**
     * Generates a new selection range from the given `node`.
     * If `state` is passed instead it will generate the range based on the passed `node`
     * and the start node of the `state`.
     */
    generateRange(node, state) {
        if (!state) {
            return {
                rowStart: node.row,
                rowEnd: node.row,
                columnStart: node.column,
                columnEnd: node.column
            };
        }
        const { row, column } = state.node;
        const rowStart = Math.min(node.row, row);
        const rowEnd = Math.max(node.row, row);
        const columnStart = Math.min(node.column, column);
        const columnEnd = Math.max(node.column, column);
        return { rowStart, rowEnd, columnStart, columnEnd };
    }
    /**
     *
     */
    keyboardStateOnKeydown(node, shift, shiftTab) {
        this.keyboardState.active = true;
        this.initPointerState();
        this.keyboardState.shift = shift && !shiftTab;
        if (!this.grid.navigation.isDataRow(node.row)) {
            return;
        }
        // Kb navigation with shift and no previous node.
        // Clear the current selection init the start node.
        if (this.keyboardState.shift && !this.keyboardState.node) {
            this.clear();
            this.keyboardState.node = Object.assign({}, node);
        }
    }
    keyboardStateOnFocus(node, emitter, dom) {
        const kbState = this.keyboardState;
        // Focus triggered by keyboard navigation
        if (kbState.active) {
            if (isChromium()) {
                this._moveSelectionChrome(dom);
            }
            // Start generating a range if shift is hold
            if (kbState.shift) {
                this.dragSelect(node, kbState);
                kbState.range = this.generateRange(node, kbState);
                emitter.emit(this.generateRange(node, kbState));
                return;
            }
            this.initKeyboardState();
            this.clear();
            this.add(node);
        }
    }
    pointerDown(node, shift, ctrl) {
        this.addKeyboardRange();
        this.initKeyboardState();
        this.pointerState.ctrl = ctrl;
        this.pointerState.shift = shift;
        // No ctrl key pressed - no multiple selection
        if (!ctrl) {
            this.clear();
        }
        if (shift) {
            // No previously 'clicked' node. Use the last active node.
            if (!this.pointerState.node) {
                this.pointerState.node = this.activeElement || node;
            }
            this.pointerDownShiftKey(node);
            this.clearTextSelection();
            return;
        }
        this.removeRangeMeta(node);
        this.pointerState.node = node;
    }
    pointerDownShiftKey(node) {
        this.clear();
        this.selectRange(node, this.pointerState);
    }
    mergeMap(target, source) {
        const iterator = source.entries();
        let pair = iterator.next();
        let key;
        let value;
        while (!pair.done) {
            [key, value] = pair.value;
            if (target.has(key)) {
                const newValue = target.get(key);
                value.forEach(record => newValue.add(record));
                target.set(key, newValue);
            }
            else {
                target.set(key, value);
            }
            pair = iterator.next();
        }
    }
    pointerEnter(node, event) {
        // https://www.w3.org/TR/pointerevents/#the-button-property
        this.dragMode = event.buttons === 1 && (event.button === -1 || event.button === 0);
        if (!this.dragMode) {
            return false;
        }
        this.clearTextSelection();
        // If the users triggers a drag-like event by first clicking outside the grid cells
        // and then enters in the grid body we may not have a initial pointer starting node.
        // Assume the first pointerenter node is where we start.
        if (!this.pointerState.node) {
            this.pointerState.node = node;
        }
        if (this.pointerState.ctrl) {
            this.selectRange(node, this.pointerState, this.temp);
        }
        else {
            this.dragSelect(node, this.pointerState);
        }
        return true;
    }
    pointerUp(node, emitter) {
        if (this.dragMode) {
            this.restoreTextSelection();
            this.addRangeMeta(node, this.pointerState);
            this.mergeMap(this.selection, this.temp);
            this.zone.runTask(() => emitter.emit(this.generateRange(node, this.pointerState)));
            this.temp.clear();
            this.dragMode = false;
            return true;
        }
        if (this.pointerState.shift) {
            this.clearTextSelection();
            this.restoreTextSelection();
            this.addRangeMeta(node, this.pointerState);
            emitter.emit(this.generateRange(node, this.pointerState));
            return true;
        }
        this.add(node);
        return false;
    }
    selectRange(node, state, collection = this.selection) {
        if (collection === this.temp) {
            collection.clear();
        }
        const { rowStart, rowEnd, columnStart, columnEnd } = this.generateRange(node, state);
        for (let i = rowStart; i <= rowEnd; i++) {
            for (let j = columnStart; j <= columnEnd; j++) {
                if (collection.has(i)) {
                    collection.get(i).add(j);
                }
                else {
                    collection.set(i, new Set()).get(i).add(j);
                }
            }
        }
    }
    dragSelect(node, state) {
        if (!this.pointerState.ctrl) {
            this.selection.clear();
        }
        this.selectRange(node, state);
    }
    clear(clearAcriveEl = false) {
        if (clearAcriveEl) {
            this.activeElement = null;
        }
        this.selection.clear();
        this.temp.clear();
        this._ranges.clear();
    }
    clearTextSelection() {
        const selection = window.getSelection();
        if (selection.rangeCount) {
            this._selectionRange = selection.getRangeAt(0);
            this._selectionRange.collapse(true);
            selection.removeAllRanges();
        }
    }
    restoreTextSelection() {
        const selection = window.getSelection();
        if (!selection.rangeCount) {
            selection.addRange(this._selectionRange || document.createRange());
        }
    }
    /**
     * (╯°□°）╯︵ ┻━┻
     * Chrome and Chromium don't care about the active
     * range after keyboard navigation, thus this.
     */
    _moveSelectionChrome(node) {
        const selection = window.getSelection();
        selection.removeAllRanges();
        const range = new Range();
        range.selectNode(node);
        range.collapse(true);
        selection.addRange(range);
    }
    /** Returns array of the selected row id's. */
    getSelectedRows() {
        return this.rowSelection.size ? Array.from(this.rowSelection.keys()) : [];
    }
    /** Returns array of the rows in indeterminate state. */
    getIndeterminateRows() {
        return this.indeterminateRows.size ? Array.from(this.indeterminateRows.keys()) : [];
    }
    /** Clears row selection, if filtering is applied clears only selected rows from filtered data. */
    clearRowSelection(event) {
        const removedRec = this.isFilteringApplied() ?
            this.getRowIDs(this.allData).filter(rID => this.isRowSelected(rID)) : this.getSelectedRows();
        const newSelection = this.isFilteringApplied() ? this.getSelectedRows().filter(x => !removedRec.includes(x)) : [];
        this.emitRowSelectionEvent(newSelection, [], removedRec, event);
    }
    /** Select all rows, if filtering is applied select only from filtered data. */
    selectAllRows(event) {
        const allRowIDs = this.getRowIDs(this.allData);
        const addedRows = allRowIDs.filter((rID) => !this.isRowSelected(rID));
        const newSelection = this.rowSelection.size ? this.getSelectedRows().concat(addedRows) : addedRows;
        this.indeterminateRows.clear();
        this.selectedRowsChange.next();
        this.emitRowSelectionEvent(newSelection, addedRows, [], event);
    }
    /** Select the specified row and emit event. */
    selectRowById(rowID, clearPrevSelection, event) {
        if (!this.grid.isRowSelectable || this.isRowDeleted(rowID)) {
            return;
        }
        clearPrevSelection = !this.grid.isMultiRowSelectionEnabled || clearPrevSelection;
        const newSelection = clearPrevSelection ? [rowID] : this.getSelectedRows().indexOf(rowID) !== -1 ?
            this.getSelectedRows() : [...this.getSelectedRows(), rowID];
        const removed = clearPrevSelection ? this.getSelectedRows() : [];
        this.selectedRowsChange.next();
        this.emitRowSelectionEvent(newSelection, [rowID], removed, event);
    }
    /** Deselect the specified row and emit event. */
    deselectRow(rowID, event) {
        if (!this.isRowSelected(rowID)) {
            return;
        }
        const newSelection = this.getSelectedRows().filter(r => r !== rowID);
        if (this.rowSelection.size && this.rowSelection.has(rowID)) {
            this.selectedRowsChange.next();
            this.emitRowSelectionEvent(newSelection, [], [rowID], event);
        }
    }
    /** Select specified rows. No event is emitted. */
    selectRowsWithNoEvent(rowIDs, clearPrevSelection) {
        if (clearPrevSelection) {
            this.rowSelection.clear();
        }
        rowIDs.forEach(rowID => this.rowSelection.add(rowID));
        this.allRowsSelected = undefined;
        this.selectedRowsChange.next();
    }
    /** Deselect specified rows. No event is emitted. */
    deselectRowsWithNoEvent(rowIDs) {
        rowIDs.forEach(rowID => this.rowSelection.delete(rowID));
        this.allRowsSelected = undefined;
        this.selectedRowsChange.next();
    }
    isRowSelected(rowID) {
        return this.rowSelection.size > 0 && this.rowSelection.has(rowID);
    }
    isRowInIndeterminateState(rowID) {
        return this.indeterminateRows.size > 0 && this.indeterminateRows.has(rowID);
    }
    /** Select range from last selected row to the current specified row. */
    selectMultipleRows(rowID, rowData, event) {
        this.allRowsSelected = undefined;
        if (!this.rowSelection.size || this.isRowDeleted(rowID)) {
            this.selectRowById(rowID);
            return;
        }
        const gridData = this.allData;
        const lastRowID = this.getSelectedRows()[this.rowSelection.size - 1];
        const currIndex = gridData.indexOf(this.getRowDataById(lastRowID));
        const newIndex = gridData.indexOf(rowData);
        const rows = gridData.slice(Math.min(currIndex, newIndex), Math.max(currIndex, newIndex) + 1);
        const added = this.getRowIDs(rows).filter(rID => !this.isRowSelected(rID));
        const newSelection = this.getSelectedRows().concat(added);
        this.selectedRowsChange.next();
        this.emitRowSelectionEvent(newSelection, added, [], event);
    }
    areAllRowSelected() {
        if (!this.grid.data) {
            return false;
        }
        if (this.allRowsSelected !== undefined) {
            return this.allRowsSelected;
        }
        const dataItemsID = this.getRowIDs(this.allData);
        return this.allRowsSelected = Math.min(this.rowSelection.size, dataItemsID.length) > 0 &&
            new Set(Array.from(this.rowSelection.values()).concat(dataItemsID)).size === this.rowSelection.size;
    }
    hasSomeRowSelected() {
        const filteredData = this.isFilteringApplied() ?
            this.getRowIDs(this.grid.filteredData).some(rID => this.isRowSelected(rID)) : true;
        return this.rowSelection.size > 0 && filteredData && !this.areAllRowSelected();
    }
    get filteredSelectedRowIds() {
        return this.isFilteringApplied() ?
            this.getRowIDs(this.allData).filter(rowID => this.isRowSelected(rowID)) :
            this.getSelectedRows().filter(rowID => !this.isRowDeleted(rowID));
    }
    emitRowSelectionEvent(newSelection, added, removed, event) {
        const currSelection = this.getSelectedRows();
        if (this.areEqualCollections(currSelection, newSelection)) {
            return;
        }
        const args = {
            oldSelection: currSelection, newSelection,
            added, removed, event, cancel: false
        };
        this.grid.onRowSelectionChange.emit(args);
        if (args.cancel) {
            return;
        }
        this.selectRowsWithNoEvent(args.newSelection, true);
    }
    getRowDataById(rowID) {
        if (!this.grid.primaryKey) {
            return rowID;
        }
        const rowIndex = this.getRowIDs(this.grid.gridAPI.get_all_data(true)).indexOf(rowID);
        return rowIndex < 0 ? {} : this.grid.gridAPI.get_all_data(true)[rowIndex];
    }
    getRowIDs(data) {
        return this.grid.primaryKey && data.length ? data.map(rec => rec[this.grid.primaryKey]) : data;
    }
    clearHeaderCBState() {
        this.allRowsSelected = undefined;
    }
    /** Clear rowSelection and update checkbox state */
    clearAllSelectedRows() {
        this.rowSelection.clear();
        this.indeterminateRows.clear();
        this.clearHeaderCBState();
        this.selectedRowsChange.next();
    }
    /** Returns all data in the grid, with applied filtering and sorting and without deleted rows. */
    get allData() {
        let allData;
        if (this.isFilteringApplied() || this.grid.sortingExpressions.length) {
            allData = this.grid.pinnedRecordsCount ? this.grid._filteredSortedUnpinnedData : this.grid.filteredSortedData;
        }
        else {
            allData = this.grid.gridAPI.get_all_data(true);
        }
        return allData.filter(rData => !this.isRowDeleted(this.grid.gridAPI.get_row_id(rData)));
    }
    /** Returns array of the selected columns fields. */
    getSelectedColumns() {
        return this.columnSelection.size ? Array.from(this.columnSelection.keys()) : [];
    }
    isColumnSelected(field) {
        return this.columnSelection.size > 0 && this.columnSelection.has(field);
    }
    /** Select the specified column and emit event. */
    selectColumn(field, clearPrevSelection, selectColumnsRange, event) {
        const stateColumn = this.columnsState.field ? this.grid.getColumnByName(this.columnsState.field) : null;
        if (!event || !stateColumn || stateColumn.visibleIndex < 0 || !selectColumnsRange) {
            this.columnsState.field = field;
            this.columnsState.range = [];
            const newSelection = clearPrevSelection ? [field] : this.getSelectedColumns().indexOf(field) !== -1 ?
                this.getSelectedColumns() : [...this.getSelectedColumns(), field];
            const removed = clearPrevSelection ? this.getSelectedColumns().filter(colField => colField !== field) : [];
            const added = this.isColumnSelected(field) ? [] : [field];
            this.emitColumnSelectionEvent(newSelection, added, removed, event);
        }
        else if (selectColumnsRange) {
            this.selectColumnsRange(field, event);
        }
    }
    /** Select specified columns. And emit event. */
    selectColumns(fields, clearPrevSelection, selectColumnsRange, event) {
        const columns = fields.map(f => this.grid.getColumnByName(f)).sort((a, b) => a.visibleIndex - b.visibleIndex);
        const stateColumn = this.columnsState.field ? this.grid.getColumnByName(this.columnsState.field) : null;
        if (!stateColumn || stateColumn.visibleIndex < 0 || !selectColumnsRange) {
            this.columnsState.field = columns[0] ? columns[0].field : null;
            this.columnsState.range = [];
            const added = fields.filter(colField => !this.isColumnSelected(colField));
            const removed = clearPrevSelection ? this.getSelectedColumns().filter(colField => fields.indexOf(colField) === -1) : [];
            const newSelection = clearPrevSelection ? fields : this.getSelectedColumns().concat(added);
            this.emitColumnSelectionEvent(newSelection, added, removed, event);
        }
        else {
            const filedStart = stateColumn.visibleIndex >
                columns[columns.length - 1].visibleIndex ? columns[0].field : columns[columns.length - 1].field;
            this.selectColumnsRange(filedStart, event);
        }
    }
    /** Select range from last clicked column to the current specified column. */
    selectColumnsRange(field, event) {
        const currIndex = this.grid.getColumnByName(this.columnsState.field).visibleIndex;
        const newIndex = this.grid.columnToVisibleIndex(field);
        const columnsFields = this.grid.visibleColumns
            .filter(c => !c.columnGroup)
            .sort((a, b) => a.visibleIndex - b.visibleIndex)
            .slice(Math.min(currIndex, newIndex), Math.max(currIndex, newIndex) + 1)
            .filter(col => col.selectable).map(col => col.field);
        const removed = [];
        const oldAdded = [];
        const added = columnsFields.filter(colField => !this.isColumnSelected(colField));
        this.columnsState.range.forEach(f => {
            if (columnsFields.indexOf(f) === -1) {
                removed.push(f);
            }
            else {
                oldAdded.push(f);
            }
        });
        this.columnsState.range = columnsFields.filter(colField => !this.isColumnSelected(colField) || oldAdded.indexOf(colField) > -1);
        const newSelection = this.getSelectedColumns().concat(added).filter(c => removed.indexOf(c) === -1);
        this.emitColumnSelectionEvent(newSelection, added, removed, event);
    }
    /** Select specified columns. No event is emitted. */
    selectColumnsWithNoEvent(fields, clearPrevSelection) {
        if (clearPrevSelection) {
            this.columnSelection.clear();
        }
        fields.forEach(field => {
            this.columnSelection.add(field);
        });
    }
    /** Deselect the specified column and emit event. */
    deselectColumn(field, event) {
        this.initColumnsState();
        const newSelection = this.getSelectedColumns().filter(c => c !== field);
        this.emitColumnSelectionEvent(newSelection, [], [field], event);
    }
    /** Deselect specified columns. No event is emitted. */
    deselectColumnsWithNoEvent(fields) {
        fields.forEach(field => this.columnSelection.delete(field));
    }
    /** Deselect specified columns. And emit event. */
    deselectColumns(fields, event) {
        const removed = this.getSelectedColumns().filter(colField => fields.indexOf(colField) > -1);
        const newSelection = this.getSelectedColumns().filter(colField => fields.indexOf(colField) === -1);
        this.emitColumnSelectionEvent(newSelection, [], removed, event);
    }
    emitColumnSelectionEvent(newSelection, added, removed, event) {
        const currSelection = this.getSelectedColumns();
        if (this.areEqualCollections(currSelection, newSelection)) {
            return;
        }
        const args = {
            oldSelection: currSelection, newSelection,
            added, removed, event, cancel: false
        };
        this.grid.onColumnSelectionChange.emit(args);
        if (args.cancel) {
            return;
        }
        this.selectColumnsWithNoEvent(args.newSelection, true);
    }
    /** Clear columnSelection */
    clearAllSelectedColumns() {
        this.columnSelection.clear();
    }
    areEqualCollections(first, second) {
        return first.length === second.length && new Set(first.concat(second)).size === first.length;
    }
    isFilteringApplied() {
        const grid = this.grid;
        return !FilteringExpressionsTree.empty(grid.filteringExpressionsTree) ||
            !FilteringExpressionsTree.empty(grid.advancedFilteringExpressionsTree);
    }
    isRowDeleted(rowID) {
        return this.grid.gridAPI.row_deleted_transaction(rowID);
    }
}
IgxGridSelectionService.decorators = [
    { type: Injectable }
];
IgxGridSelectionService.ctorParameters = () => [
    { type: NgZone }
];
const isChromium = () => (/Chrom|e?ium/g.test(navigator.userAgent) ||
    /Google Inc/g.test(navigator.vendor)) && !/Edge/g.test(navigator.userAgent);

class IgxRowDirective {
    constructor(gridAPI, crudService, selectionService, element, cdr) {
        this.gridAPI = gridAPI;
        this.crudService = crudService;
        this.selectionService = selectionService;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */
        this.onAnimationEnd = new EventEmitter();
        /**
         * @hidden
         */
        this.role = 'row';
        /**
         * Sets whether this specific row has disabled functionality for editing and row selection.
         * Default value is `false`.
         * ```typescript
         * this.grid.selectedRows[0].pinned = true;
         * ```
         */
        this.disabled = false;
        /**
         * @hidden
         */
        this.focused = false;
        /**
         * @hidden
         * @internal
         */
        this.defaultCssClass = 'igx-grid__tr';
        /**
         * @hidden
         */
        this.animateAdd = false;
        this.destroy$ = new Subject();
    }
    /**
     *  The data passed to the row component.
     *
     * ```typescript
     * // get the row data for the first selected row
     * let selectedRowData = this.grid.selectedRows[0].rowData;
     * ```
     */
    get rowData() {
        if (this.inEditMode) {
            return mergeWith(cloneValue(this._rowData), this.grid.transactions.getAggregatedValue(this.rowID, false), (objValue, srcValue) => {
                if (Array.isArray(srcValue)) {
                    return objValue = srcValue;
                }
            });
        }
        return this._rowData;
    }
    set rowData(v) {
        this._rowData = v;
    }
    /**
     * Sets whether the row is pinned.
     * Default value is `false`.
     * ```typescript
     * this.grid.selectedRows[0].pinned = true;
     * ```
     */
    set pinned(value) {
        if (value) {
            this.grid.pinRow(this.rowID);
        }
        else {
            this.grid.unpinRow(this.rowID);
        }
    }
    /**
     * Gets whether the row is pinned.
     * ```typescript
     * let isPinned = row.pinned;
     * ```
     */
    get pinned() {
        return this.grid.isRecordPinned(this.rowData);
    }
    get addRow() {
        return this._addRow;
    }
    set addRow(v) {
        this._addRow = v;
    }
    get rowHeight() {
        let height = this.grid.rowHeight || 32;
        if (this.grid.hasColumnLayouts) {
            const maxRowSpan = this.grid.multiRowLayoutRowSize;
            height = height * maxRowSpan;
        }
        return this.addRow ? height : null;
    }
    get cellHeight() {
        return this.addRow && !this.inEditMode ? null : this.grid.rowHeight || 32;
    }
    get virtDirRow() {
        return this._virtDirRow ? this._virtDirRow.first : null;
    }
    /**
     * Gets the rendered cells in the row component.
     *
     * ```typescript
     * // get the cells of the third selected row
     * let selectedRowCells = this.grid.selectedRows[2].cells;
     * ```
     */
    get cells() {
        const res = new QueryList();
        if (!this._cells) {
            return res;
        }
        const cList = this._cells.filter((item) => item.nativeElement.parentElement !== null)
            .sort((item1, item2) => item1.column.visibleIndex - item2.column.visibleIndex);
        res.reset(cList);
        return res;
    }
    set cells(cells) {
    }
    get dataRowIndex() {
        return this.index;
    }
    /**
     * @hidden
     */
    get styleClasses() {
        return this.resolveClasses();
    }
    /**
     * @hidden
     */
    get selected() {
        return this.selectionService.isRowSelected(this.rowID);
    }
    set selected(value) {
        if (value) {
            this.selectionService.selectRowsWithNoEvent([this.rowID]);
        }
        else {
            this.selectionService.deselectRowsWithNoEvent([this.rowID]);
        }
        this.grid.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    get columns() {
        return this.grid.visibleColumns;
    }
    /**
     * @hidden
     * @internal
     */
    get viewIndex() {
        if (this.grid.groupingExpressions.length) {
            return this.grid.filteredSortedData.indexOf(this.rowData);
        }
        return this.index + this.grid.page * this.grid.perPage;
    }
    /**
     * @hidden
     */
    get pinnedColumns() {
        return this.grid.pinnedColumns;
    }
    /**
     * @hidden
     */
    get isRoot() {
        return true;
    }
    /**
     * @hidden
     */
    get hasChildren() {
        return false;
    }
    /**
     * @hidden
     */
    get unpinnedColumns() {
        return this.grid.unpinnedColumns;
    }
    /**
     * @hidden
     */
    get showRowSelectors() {
        return this.grid.showRowSelectors;
    }
    /** @hidden */
    get dirty() {
        const row = this.grid.transactions.getState(this.rowID);
        if (row) {
            return row.type === TransactionType.ADD || row.type === TransactionType.UPDATE;
        }
        return false;
    }
    /**
     * @hidden
     */
    get rowDraggable() {
        return this.grid.rowDraggable;
    }
    /** @hidden */
    get added() {
        const row = this.grid.transactions.getState(this.rowID);
        if (row) {
            return row.type === TransactionType.ADD;
        }
        return false;
    }
    /** @hidden */
    get deleted() {
        return this.gridAPI.row_deleted_transaction(this.rowID);
    }
    /**
     * @hidden
     */
    get dragging() {
        return this.grid.dragRowID === this.rowID;
    }
    // TODO: Refactor
    get inEditMode() {
        if (this.grid.rowEditable) {
            const editRowState = this.crudService.row;
            return (editRowState && editRowState.id === this.rowID) || false;
        }
        else {
            return false;
        }
    }
    /**
     * Get a reference to the grid that contains the selected row.
     *
     * ```typescript
     * handleRowSelection(event) {
     *  // the grid on which the onRowSelectionChange event was triggered
     *  const grid = event.row.grid;
     * }
     * ```
     *
     * ```html
     *  <igx-grid
     *    [data]="data"
     *    (onRowSelectionChange)="handleRowSelection($event)">
     *  </igx-grid>
     * ```
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Gets the ID of the row.
     * A row in the grid is identified either by:
     * - primaryKey data value,
     * - the whole rowData, if the primaryKey is omitted.
     *
     * ```typescript
     * let rowID = this.grid.selectedRows[2].rowID;
     * ```
     */
    get rowID() {
        const primaryKey = this.grid.primaryKey;
        return primaryKey ? this._rowData[primaryKey] : this._rowData;
    }
    /**
     * The native DOM element representing the row. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second selected row
     * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @internal
     */
    onClick(event) {
        if (this.grid.rowSelection === 'none' || this.deleted || !this.grid.selectRowOnClick) {
            return;
        }
        if (event.shiftKey && this.grid.isMultiRowSelectionEnabled) {
            this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
            return;
        }
        this.selectionService.selectRowById(this.rowID, !event.ctrlKey, event);
    }
    /**
     * @hidden
     * @internal
     */
    showActionStrip() {
        if (this.grid.actionStrip) {
            this.grid.actionStrip.show(this);
        }
    }
    ngAfterViewInit() {
        // If the template of the row changes, the forOf in it is recreated and is not detected by the grid and rows can't be scrolled.
        this._virtDirRow.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.grid.resetHorizontalForOfs());
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    onRowSelectorClick(event) {
        event.stopPropagation();
        if (event.shiftKey && this.grid.isMultiRowSelectionEnabled) {
            this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
            return;
        }
        if (this.selected) {
            this.selectionService.deselectRow(this.rowID, event);
        }
        else {
            this.selectionService.selectRowById(this.rowID, false, event);
        }
    }
    /**
     * Updates the specified row object and the data source record with the passed value.
     * This method emits `onEditDone` event.
     *
     * ```typescript
     * // update the second selected row's value
     * let newValue = "Apple";
     * this.grid.selectedRows[1].update(newValue);
     * ```
     */
    update(value) {
        const crudService = this.crudService;
        if (crudService.cellInEditMode && crudService.cell.id.rowID === this.rowID) {
            this.grid.endEdit(false);
        }
        const row = new IgxRow(this.rowID, this.index, this.rowData, this.grid);
        this.gridAPI.update_row(row, value);
        this.cdr.markForCheck();
    }
    /**
     * Removes the specified row from the grid's data source.
     * This method emits `onRowDeleted` event.
     *
     * ```typescript
     * // delete the third selected row from the grid
     * this.grid.selectedRows[2].delete();
     * ```
     */
    delete() {
        this.grid.deleteRowById(this.rowID);
    }
    isCellActive(visibleColumnIndex) {
        const node = this.grid.navigation.activeNode;
        return node ? node.row === this.index && node.column === visibleColumnIndex : false;
    }
    /**
     * Pins the specified row.
     * This method emits `onRowPinning` event.
     *
     * ```typescript
     * // pin the selected row from the grid
     * this.grid.selectedRows[0].pin();
     * ```
     */
    pin() {
        return this.grid.pinRow(this.rowID);
    }
    /**
     * Unpins the specified row.
     * This method emits `onRowPinning` event.
     *
     * ```typescript
     * // unpin the selected row from the grid
     * this.grid.selectedRows[0].unpin();
     * ```
     */
    unpin() {
        return this.grid.unpinRow(this.rowID);
    }
    /**
     * @hidden
     */
    get rowCheckboxAriaLabel() {
        return this.grid.primaryKey ?
            this.selected ? 'Deselect row with key ' + this.rowID : 'Select row with key ' + this.rowID :
            this.selected ? 'Deselect row' : 'Select row';
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    shouldDisplayPinnedChip(visibleColumnIndex) {
        return this.pinned && this.disabled && visibleColumnIndex === 0;
    }
    animationEndHandler() {
        this.onAnimationEnd.emit(this);
    }
    /**
     * Spawns the add row UI for the specific row.
     *
     * @example
     * ```typescript
     * const row = this.grid1.getRowByIndex(1);
     * row.beginAddRow();
     * ```
     */
    beginAddRow() {
        this.grid.beginAddRowByIndex(this.rowID, this.index);
    }
    /**
     * @hidden
     */
    resolveClasses() {
        const indexClass = this.index % 2 ? this.grid.evenRowCSS : this.grid.oddRowCSS;
        const selectedClass = this.selected ? 'igx-grid__tr--selected' : '';
        const editClass = this.inEditMode ? 'igx-grid__tr--edit' : '';
        const dirtyClass = this.dirty ? 'igx-grid__tr--edited' : '';
        const deletedClass = this.deleted ? 'igx-grid__tr--deleted' : '';
        const mrlClass = this.grid.hasColumnLayouts ? 'igx-grid__tr--mrl' : '';
        const dragClass = this.dragging ? 'igx-grid__tr--drag' : '';
        return `${this.defaultCssClass} ${indexClass} ${selectedClass} ${editClass} ${dirtyClass}
         ${deletedClass} ${mrlClass} ${dragClass}`.trim();
    }
    /**
     * @hidden
     */
    get resolveDragIndicatorClasses() {
        const defaultDragIndicatorCssClass = 'igx-grid__drag-indicator';
        const dragIndicatorOff = this.grid.rowDragging && !this.dragging ? 'igx-grid__drag-indicator--off' : '';
        return `${defaultDragIndicatorCssClass} ${dragIndicatorOff}`;
    }
}
IgxRowDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxRowBaseComponent]'
            },] }
];
IgxRowDirective.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxGridCRUDService },
    { type: IgxGridSelectionService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxRowDirective.propDecorators = {
    onAnimationEnd: [{ type: Output }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    rowData: [{ type: Input }],
    index: [{ type: Input }],
    disabled: [{ type: Input }, { type: HostBinding, args: ['attr.aria-disabled',] }, { type: HostBinding, args: ['class.igx-grid__tr--disabled',] }],
    addRow: [{ type: Input }],
    rowHeight: [{ type: HostBinding, args: ['style.min-height.px',] }],
    gridID: [{ type: Input }],
    _virtDirRow: [{ type: ViewChildren, args: ['igxDirRef', { read: IgxGridForOfDirective },] }],
    checkboxElement: [{ type: ViewChild, args: [forwardRef(() => IgxCheckboxComponent), { read: IgxCheckboxComponent },] }],
    _cells: [{ type: ViewChildren, args: ['cell',] }],
    dataRowIndex: [{ type: HostBinding, args: ['attr.data-rowIndex',] }],
    styleClasses: [{ type: HostBinding, args: ['class',] }],
    selected: [{ type: Input }, { type: HostBinding, args: ['attr.aria-selected',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    showActionStrip: [{ type: HostListener, args: ['mouseenter',] }]
};

class IgxGridActionsBaseDirective {
    constructor(iconService, differs) {
        this.iconService = iconService;
        this.differs = differs;
        /**
         * Gets/Sets if the action buttons will be rendered as menu items. When in menu, items will be rendered with text label.
         *
         * @example
         * ```html
         *  <igx-grid-pinning-actions [asMenuItems]='true'></igx-grid-pinning-actions>
         *  <igx-grid-editing-actions [asMenuItems]='true'></igx-grid-editing-actions>
         * ```
         */
        this.asMenuItems = false;
    }
    /**
     * @hidden
     * @internal
     */
    get grid() {
        return this.strip.context.grid;
    }
    /**
     * Getter to be used in template
     *
     * @hidden
     * @internal
     */
    get isRowContext() {
        return this.isRow(this.strip.context) && !this.strip.context.inEditMode;
    }
    /**
     * @hidden
     * @internal
     */
    ngAfterViewInit() {
        if (this.asMenuItems) {
            this.buttons.changes.subscribe(() => {
                this.strip.cdr.detectChanges();
            });
        }
    }
    /**
     * Check if the param is a row from a grid
     *
     * @hidden
     * @internal
     * @param context
     */
    isRow(context) {
        return context && context instanceof IgxRowDirective;
    }
}
IgxGridActionsBaseDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxGridActionsBase]'
            },] }
];
IgxGridActionsBaseDirective.ctorParameters = () => [
    { type: IgxIconService },
    { type: IterableDiffers }
];
IgxGridActionsBaseDirective.propDecorators = {
    buttons: [{ type: ViewChildren, args: [IgxGridActionButtonComponent,] }],
    asMenuItems: [{ type: Input }]
};

class IgxGridEditingActionsComponent extends IgxGridActionsBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Host `class.igx-action-strip` binding.
         *
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-action-strip__editing-actions';
        /**
         * An input to enable/disable action strip child row adding button
         */
        this.addChild = false;
        this.isMessageShown = false;
        this._addRow = false;
        this.iconsRendered = false;
    }
    /**
     * An input to enable/disable action strip row adding button
     */
    set addRow(value) {
        this._addRow = value;
    }
    get addRow() {
        if (!this.iconsRendered) {
            this.registerIcons();
            this.iconsRendered = true;
        }
        return this._addRow;
    }
    /**
     * Getter if the row is disabled
     *
     * @hidden
     * @internal
     */
    get disabled() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        return this.strip.context.disabled;
    }
    /**
     * Getter if the row is root.
     *
     * @hidden
     * @internal
     */
    get isRootRow() {
        if (!this.isRow(this.strip.context)) {
            return false;
        }
        return this.strip.context.isRoot;
    }
    get hasChildren() {
        if (!this.isRow(this.strip.context)) {
            return false;
        }
        return this.strip.context.hasChildren;
    }
    /**
     * Enter row or cell edit mode depending the grid rowEditable option
     *
     * @example
     * ```typescript
     * this.gridEditingActions.startEdit();
     * ```
     */
    startEdit(event) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const row = this.strip.context;
        const firstEditable = row.cells.filter(cell => cell.editable)[0];
        const grid = row.grid;
        if (!grid.hasEditableColumns) {
            this.isMessageShown = showMessage('The grid should be editable in order to use IgxGridEditingActionsComponent', this.isMessageShown);
            return;
        }
        // be sure row is in view
        if (grid.rowList.filter(r => r === row).length !== 0) {
            grid.crudService.enterEditMode(firstEditable, event);
        }
        this.strip.hide();
    }
    /**
     * Delete a row according to the context
     *
     * @example
     * ```typescript
     * this.gridEditingActions.deleteRow();
     * ```
     */
    deleteRow(event) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        const grid = context.grid;
        grid.deleteRow(context.rowID);
        this.strip.hide();
    }
    addRowHandler(event, asChild) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        const grid = context.grid;
        if (!grid.rowEditable) {
            console.warn('The grid must use row edit mode to perform row adding! Please set rowEditable to true.');
            return;
        }
        grid.beginAddRowByIndex(context.rowID, context.index, asChild, event);
        this.strip.hide();
    }
    /**
     * @hidden
     * @internal
     */
    registerIcons() {
        this.iconService.addSvgIconFromText(addRow.name, addRow.value, 'imx-icons');
        this.iconService.addSvgIconFromText(addChild.name, addChild.value, 'imx-icons');
    }
}
IgxGridEditingActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-grid-editing-actions',
                template: "\n<ng-container *ngIf=\"isRowContext\">\n    <igx-grid-action-button *ngIf=\"!disabled\" [asMenuItem]=\"asMenuItems\" iconName=\"edit\" [labelText]=\"grid.resourceStrings.igx_grid_actions_edit_label\" (actionClick)=\"startEdit($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"addRow && isRootRow\" [asMenuItem]=\"asMenuItems\" iconName=\"add-row\" iconSet=\"imx-icons\" [labelText]=\"grid.resourceStrings.igx_grid_actions_add_label\" (actionClick)=\"addRowHandler($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"addChild && hasChildren\" [asMenuItem]=\"asMenuItems\" iconName=\"add-child\" iconSet=\"imx-icons\" [labelText]=\"grid.resourceStrings.igx_grid_actions_add_child_label\" (actionClick)=\"addRowHandler($event, true)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"!disabled\" class=\"igx-action-strip__delete\" classNames='igx-action-strip__menu-item--danger' [asMenuItem]=\"asMenuItems\" iconName=\"delete\" [labelText]=\"grid.resourceStrings.igx_grid_actions_delete_label\" (actionClick)=\"deleteRow($event)\"></igx-grid-action-button>\n</ng-container>\n\n",
                providers: [{ provide: IgxGridActionsBaseDirective, useExisting: IgxGridEditingActionsComponent }]
            },] }
];
IgxGridEditingActionsComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-action-strip__editing-actions',] }],
    addRow: [{ type: Input }],
    addChild: [{ type: Input }]
};

class IgxGridPinningActionsComponent extends IgxGridActionsBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Host `class.igx-action-strip` binding.
         *
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-action-strip__pinning-actions';
        this.iconsRendered = false;
    }
    /**
     * Getter to know if the row is pinned
     *
     * @hidden
     * @internal
     */
    get pinned() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        if (context && !this.iconsRendered) {
            this.registerSVGIcons();
            this.iconsRendered = true;
        }
        return context && context.pinned;
    }
    /**
     * Getter to know if the row is in pinned and ghost
     *
     * @hidden
     * @internal
     */
    get inPinnedArea() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        return this.pinned && !context.disabled;
    }
    /**
     * Getter to know if the row pinning is set to top or bottom
     *
     * @hidden
     * @internal
     */
    get pinnedTop() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        return this.strip.context.grid.isRowPinningToTop;
    }
    /**
     * Pin the row according to the context.
     *
     * @example
     * ```typescript
     * this.gridPinningActions.pin();
     * ```
     */
    pin(event) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const row = this.strip.context;
        const grid = row.grid;
        grid.pinRow(row.rowID);
        this.strip.hide();
    }
    /**
     * Unpin the row according to the context.
     *
     * @example
     * ```typescript
     * this.gridPinningActions.unpin();
     * ```
     */
    unpin(event) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const row = this.strip.context;
        const grid = row.grid;
        grid.unpinRow(row.rowID);
        this.strip.hide();
    }
    scrollToRow(event) {
        if (event) {
            event.stopPropagation();
        }
        const context = this.strip.context;
        const grid = context.grid;
        grid.scrollTo(context.rowData, 0);
        this.strip.hide();
    }
    registerSVGIcons() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        const grid = context.grid;
        if (grid) {
            this.iconService.addSvgIconFromText(pinLeft.name, pinLeft.value, 'imx-icons');
            this.iconService.addSvgIconFromText(unpinLeft.name, unpinLeft.value, 'imx-icons');
            this.iconService.addSvgIconFromText(jumpDown.name, jumpDown.value, 'imx-icons');
            this.iconService.addSvgIconFromText(jumpUp.name, jumpDown.value, 'imx-icons');
        }
    }
}
IgxGridPinningActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-grid-pinning-actions',
                template: "<ng-container *ngIf=\"isRowContext\">\n    <igx-grid-action-button *ngIf=\"inPinnedArea && pinnedTop\" [asMenuItem]=\"asMenuItems\" iconSet=\"imx-icons\" iconName=\"jump-down\" [labelText]=\"grid.resourceStrings.igx_grid_actions_jumpDown_label\" (actionClick)=\"scrollToRow($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"inPinnedArea && !pinnedTop\" [asMenuItem]=\"asMenuItems\" iconSet=\"imx-icons\" iconName=\"jump-up\" [labelText]=\"grid.resourceStrings.igx_grid_actions_jumpUp_label\" (actionClick)=\"scrollToRow($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"!pinned\" [asMenuItem]=\"asMenuItems\" iconSet=\"imx-icons\" iconName=\"pin-left\" [labelText]=\"grid.resourceStrings.igx_grid_actions_pin_label\" (actionClick)=\"pin($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"pinned\" [asMenuItem]=\"asMenuItems\" iconSet=\"imx-icons\" iconName=\"unpin-left\" [labelText]=\"grid.resourceStrings.igx_grid_actions_unpin_label\" (actionClick)=\"unpin($event)\"></igx-grid-action-button>\n</ng-container>",
                providers: [{ provide: IgxGridActionsBaseDirective, useExisting: IgxGridPinningActionsComponent }]
            },] }
];
IgxGridPinningActionsComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-action-strip__pinning-actions',] }]
};

class IgxActionStripMenuItemDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
IgxActionStripMenuItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxActionStripMenuItem]'
            },] }
];
IgxActionStripMenuItemDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * Action Strip provides templatable area for one or more actions.
 *
 * @igxModule IgxActionStripModule
 *
 * @igxTheme igx-action-strip-theme
 *
 * @igxKeywords action, strip, actionStrip, pinning, editing
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 * The Ignite UI Action Strip is a container, overlaying its parent container,
 * and displaying action buttons with action applicable to the parent component the strip is instantiated or shown for.
 *
 * @example
 * ```html
 * <igx-action-strip #actionStrip>
 *     <igx-icon (click)="doSomeAction()"></igx-icon>
 * </igx-action-strip>
 */
class IgxActionStripComponent extends DisplayDensityBase {
    constructor(_viewContainer, renderer, _displayDensityOptions, cdr) {
        super(_displayDensityOptions);
        this._viewContainer = _viewContainer;
        this.renderer = renderer;
        this._displayDensityOptions = _displayDensityOptions;
        this.cdr = cdr;
        /**
         * Getter for menu overlay settings
         *
         * @hidden
         * @internal
         */
        this.menuOverlaySettings = { scrollStrategy: new CloseScrollStrategy() };
        this._hidden = false;
    }
    /**
     * An @Input property that set the visibility of the Action Strip.
     * Could be used to set if the Action Strip will be initially hidden.
     *
     * @example
     * ```html
     *  <igx-action-strip [hidden]="false">
     * ```
     */
    set hidden(value) {
        this._hidden = value;
    }
    get hidden() {
        return this._hidden;
    }
    /**
     * Getter for the 'display' property of the current `IgxActionStrip`
     *
     * @hidden
     * @internal
     */
    get display() {
        return this._hidden ? 'none' : 'flex';
    }
    /**
     * Host `attr.class` binding.
     *
     * @hidden
     * @internal
     */
    get hostClasses() {
        const classes = [this.getComponentDensityClass('igx-action-strip')];
        // The custom classes should be at the end.
        if (!classes.includes('igx-action-strip')) {
            classes.push('igx-action-strip');
        }
        classes.push(this.hostClass);
        return classes.join(' ');
    }
    /**
     * Menu Items list.
     *
     * @hidden
     * @internal
     */
    get menuItems() {
        const actions = [];
        this.actionButtons.forEach(button => {
            if (button.asMenuItems) {
                const children = button.buttons;
                if (children) {
                    children.toArray().forEach(x => actions.push(x));
                }
            }
        });
        return [...this._menuItems.toArray(), ...actions];
    }
    /**
     * @hidden
     * @internal
     */
    ngAfterContentInit() {
        this.actionButtons.forEach(button => {
            button.strip = this;
        });
        this.actionButtons.changes.subscribe(() => {
            this.actionButtons.forEach(button => {
                button.strip = this;
            });
        });
    }
    /**
     * @hidden
     * @internal
     */
    ngAfterViewInit() {
        this.menu.onSelection.subscribe(($event) => {
            const newSelection = $event.newSelection.elementRef.nativeElement;
            let allButtons = [];
            this.actionButtons.forEach(actionButtons => {
                if (actionButtons.asMenuItems) {
                    allButtons = [...allButtons, ...actionButtons.buttons.toArray()];
                }
            });
            const button = allButtons.find(x => newSelection.contains(x.container.nativeElement));
            if (button) {
                button.actionClick.emit();
            }
        });
    }
    /**
     * Showing the Action Strip and appending it the specified context element.
     *
     * @param context
     * @example
     * ```typescript
     * this.actionStrip.show(row);
     * ```
     */
    show(context) {
        this.hidden = false;
        if (!context) {
            return;
        }
        // when shown for different context make sure the menu won't stay opened
        if (this.context !== context) {
            this.closeMenu();
        }
        this.context = context;
        if (this.context && this.context.element) {
            this.renderer.appendChild(context.element.nativeElement, this._viewContainer.element.nativeElement);
        }
        this.cdr.detectChanges();
    }
    /**
     * Hiding the Action Strip and removing it from its current context element.
     *
     * @example
     * ```typescript
     * this.actionStrip.hide();
     * ```
     */
    hide() {
        this.hidden = true;
        this.closeMenu();
        if (this.context && this.context.element) {
            this.renderer.removeChild(this.context.element.nativeElement, this._viewContainer.element.nativeElement);
        }
    }
    /**
     * Close the menu if opened
     *
     * @hidden
     * @internal
     */
    closeMenu() {
        if (this.menu && !this.menu.collapsed) {
            this.menu.close();
        }
    }
}
IgxActionStripComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-action-strip',
                template: "<div class=\"igx-action-strip__actions\">\n    <ng-content #content></ng-content>\n    <ng-container *ngIf=\"menuItems.length > 0\">\n        <button\n            igxButton=\"icon\"\n            igxRipple\n            [igxToggleAction]=\"dropdown\"\n            [overlaySettings]=\"menuOverlaySettings\"\n            (click)=\"$event.stopPropagation()\"\n            [igxDropDownItemNavigation]=\"dropdown\"\n        >\n            <igx-icon>more_vert</igx-icon>\n        </button>\n    </ng-container>\n    <igx-drop-down #dropdown [displayDensity]=\"displayDensity\">\n        <igx-drop-down-item\n            *ngFor=\"let item of menuItems\"\n            class=\"igx-action-strip__menu-item\"\n        >\n            <div class=\"igx-drop-down__item-template\">\n                <ng-container\n                    *ngTemplateOutlet=\"\n                        item.templateRef;\n                        context: { $implicit: item }\n                    \"\n                ></ng-container>\n            </div>\n        </igx-drop-down-item>\n    </igx-drop-down>\n</div>\n"
            },] }
];
IgxActionStripComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: ChangeDetectorRef }
];
IgxActionStripComponent.propDecorators = {
    context: [{ type: Input }],
    _menuItems: [{ type: ContentChildren, args: [IgxActionStripMenuItemDirective,] }],
    actionButtons: [{ type: ContentChildren, args: [IgxGridActionsBaseDirective,] }],
    hidden: [{ type: Input }],
    hostClass: [{ type: Input, args: ['class',] }],
    menu: [{ type: ViewChild, args: ['dropdown',] }],
    display: [{ type: HostBinding, args: ['style.display',] }],
    hostClasses: [{ type: HostBinding, args: ['attr.class',] }]
};

/**
 * @hidden
 */
class IgxActionStripModule {
}
IgxActionStripModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxActionStripComponent,
                    IgxActionStripMenuItemDirective,
                    IgxGridPinningActionsComponent,
                    IgxGridEditingActionsComponent,
                    IgxGridActionsBaseDirective,
                    IgxGridActionButtonComponent
                ],
                entryComponents: [],
                exports: [
                    IgxActionStripComponent,
                    IgxActionStripMenuItemDirective,
                    IgxGridPinningActionsComponent,
                    IgxGridEditingActionsComponent,
                    IgxGridActionsBaseDirective,
                    IgxGridActionButtonComponent
                ],
                imports: [CommonModule, IgxDropDownModule, IgxToggleModule, IgxButtonModule, IgxIconModule, IgxRippleModule]
            },] }
];

let NEXT_ID$6 = 0;
const IgxAvatarSize = mkenum({
    SMALL: 'small',
    MEDIUM: 'medium',
    LARGE: 'large'
});
const IgxAvatarType = mkenum({
    INITIALS: 'initials',
    IMAGE: 'image',
    ICON: 'icon',
    CUSTOM: 'custom'
});
/**
 * Avatar provides a way to display an image, icon or initials to the user.
 *
 * @igxModule IgxAvatarModule
 *
 * @igxTheme igx-avatar-theme, igx-icon-theme
 *
 * @igxKeywords avatar, profile, picture, initials
 *
 * @igxGroup Layouts
 *
 * @remarks
 *
 * The Ignite UI Avatar provides an easy way to add an avatar icon to your application.  This icon can be an
 * image, someone's initials or a material icon from the Google Material icon set.
 *
 * @example
 * ```html
 * <igx-avatar initials="MS" [roundShape]="true" size="large">
 * </igx-avatar>
 * ```
 */
class IgxAvatarComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Returns the `aria-label` attribute of the avatar.
         *
         * @example
         * ```typescript
         * let ariaLabel = this.avatar.ariaLabel;
         * ```
         *
         */
        this.ariaLabel = 'avatar';
        /**
         * Returns the `role` attribute of the avatar.
         *
         * @example
         * ```typescript
         * let avatarRole = this.avatar.role;
         * ```
         */
        this.role = 'img';
        /**
         * Host `class.igx-avatar` binding.
         *
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-avatar';
        /**
         * Sets the `id` of the avatar. If not set, the first avatar component will have `id` = `"igx-avatar-0"`.
         *
         * @example
         * ```html
         * <igx-avatar id="my-first-avatar"></igx-avatar>
         * ```
         */
        this.id = `igx-avatar-${NEXT_ID$6++}`;
        /**
         * Sets a round shape to the avatar, if `[roundShape]` is set to `true`.
         * By default the shape of the avatar is a square.
         *
         * @example
         * ```html
         * <igx-avatar [roundShape]="true" ></igx-avatar>
         * ```
         */
        this.roundShape = false;
        /**
         * @hidden
         * @internal
         */
        this._size = IgxAvatarSize.SMALL;
    }
    /**
     * Returns the size of the avatar.
     *
     * @example
     * ```typescript
     * let avatarSize = this.avatar.size;
     * ```
     */
    get size() {
        return this._size;
    }
    /**
     * Sets the size  of the avatar.
     * By default, the size is `"small"`. It can be set to `"medium"` or `"large"`.
     *
     * @example
     * ```html
     * <igx-avatar size="large"></igx-avatar>
     * ```
     */
    set size(value) {
        switch (value) {
            case 'small':
            case 'medium':
            case 'large':
                this._size = value;
                break;
            default:
                this._size = 'small';
        }
    }
    /** @hidden @internal */
    get _isSmallSize() {
        return this.size === 'small';
    }
    /** @hidden @internal */
    get _isMediumSize() {
        return this.size === 'medium';
    }
    /** @hidden @internal */
    get _isLargeSize() {
        return this.size === 'large';
    }
    /**
     * Returns the type of the avatar.
     *
     * @example
     * ```typescript
     * let avatarType = this.avatar.type;
     * ```
     */
    get type() {
        if (this.src) {
            return IgxAvatarType.IMAGE;
        }
        if (this.icon) {
            return IgxAvatarType.ICON;
        }
        if (this.initials) {
            return IgxAvatarType.INITIALS;
        }
        return IgxAvatarType.CUSTOM;
    }
    /** @hidden @internal */
    get _isImageType() {
        return this.type === IgxAvatarType.IMAGE;
    }
    /** @hidden @internal */
    get _isIconType() {
        return this.type === IgxAvatarType.ICON;
    }
    /** @hidden @internal */
    get _isInitialsType() {
        return this.type === IgxAvatarType.INITIALS;
    }
    /**
     * Returns the template of the avatar.
     *
     * @hidden
     * @internal
     */
    get template() {
        switch (this.type) {
            case IgxAvatarType.IMAGE:
                return this.imageTemplate;
            case IgxAvatarType.INITIALS:
                return this.initialsTemplate;
            case IgxAvatarType.ICON:
                return this.iconTemplate;
            default:
                return this.defaultTemplate;
        }
    }
    /**
     * Returns the css url of the image.
     *
     * @hidden
     * @internal
     */
    getSrcUrl() {
        return `url(${this.src})`;
    }
    /** @hidden @internal */
    ngOnInit() {
        this.roleDescription = this.getRole();
    }
    /** @hidden @internal */
    getRole() {
        switch (this.type) {
            case IgxAvatarType.IMAGE:
                return 'image avatar';
            case IgxAvatarType.ICON:
                return 'icon avatar';
            case IgxAvatarType.INITIALS:
                return 'initials avatar';
            default:
                return 'custom avatar';
        }
    }
}
IgxAvatarComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-avatar',
                template: "<ng-template #defaultTemplate>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #imageTemplate>\n    <div #image class=\"igx-avatar__image\" [style.backgroundImage]=\"getSrcUrl()\"></div>\n</ng-template>\n\n<ng-template #initialsTemplate>\n    <span>{{initials.substring(0, 2)}}</span>\n</ng-template>\n\n<ng-template #iconTemplate>\n     <igx-icon>{{icon}}</igx-icon>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
            },] }
];
IgxAvatarComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxAvatarComponent.propDecorators = {
    ariaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-avatar',] }],
    roleDescription: [{ type: HostBinding, args: ['attr.aria-roledescription',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    roundShape: [{ type: HostBinding, args: ['class.igx-avatar--rounded',] }, { type: Input }],
    color: [{ type: HostBinding, args: ['style.color',] }, { type: Input }],
    bgColor: [{ type: HostBinding, args: ['style.background',] }, { type: Input }],
    initials: [{ type: Input }],
    icon: [{ type: Input }],
    src: [{ type: Input }],
    defaultTemplate: [{ type: ViewChild, args: ['defaultTemplate', { read: TemplateRef, static: true },] }],
    imageTemplate: [{ type: ViewChild, args: ['imageTemplate', { read: TemplateRef, static: true },] }],
    initialsTemplate: [{ type: ViewChild, args: ['initialsTemplate', { read: TemplateRef, static: true },] }],
    iconTemplate: [{ type: ViewChild, args: ['iconTemplate', { read: TemplateRef, static: true },] }],
    size: [{ type: Input }],
    _isSmallSize: [{ type: HostBinding, args: ['class.igx-avatar--small',] }],
    _isMediumSize: [{ type: HostBinding, args: ['class.igx-avatar--medium',] }],
    _isLargeSize: [{ type: HostBinding, args: ['class.igx-avatar--large',] }],
    _isImageType: [{ type: HostBinding, args: ['class.igx-avatar--image',] }],
    _isIconType: [{ type: HostBinding, args: ['class.igx-avatar--icon',] }],
    _isInitialsType: [{ type: HostBinding, args: ['class.igx-avatar--initials',] }]
};
/**
 * @hidden
 */
class IgxAvatarModule {
}
IgxAvatarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxAvatarComponent],
                exports: [IgxAvatarComponent],
                imports: [CommonModule, IgxIconModule]
            },] }
];

let NEXT_ID$7 = 0;
/**
 * Determines the igxBadge type
 */
const IgxBadgeType = mkenum({
    PRIMARY: 'primary',
    INFO: 'info',
    SUCCESS: 'success',
    WARNING: 'warning',
    ERROR: 'error'
});
/**
 * Badge provides visual notifications used to decorate avatars, menus, etc.
 *
 * @igxModule IgxBadgeModule
 *
 * @igxTheme igx-badge-theme
 *
 * @igxKeywords badge, icon, notification
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 * The Ignite UI Badge is used to decorate avatars, navigation menus, or other components in the
 * application when visual notification is needed. They are usually designed as icons with a predefined
 * style to communicate information, success, warnings, or errors.
 *
 * @example
 * ```html
 * <igx-avatar>
 *   <igx-badge icon="check" type="success"></igx-badge>
 * </igx-avatar>
 */
class IgxBadgeComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the badge.
         *
         * @remarks
         * If not set, the `id` will have value `"igx-badge-0"`.
         *
         * @example
         * ```html
         * <igx-badge id="igx-badge-2"></igx-badge>
         * ```
         */
        this.id = `igx-badge-${NEXT_ID$7++}`;
        /**
         * Sets/gets the type of the badge.
         *
         * @remarks
         * Allowed values are `primary`, `info`, `success`, `warning`, `error`.
         * Providing an invalid value won't display a badge.
         *
         * @example
         * ```html
         * <igx-badge type="success"></igx-badge>
         * ```
         */
        this.type = IgxBadgeType.PRIMARY;
        /**
         * Sets/gets the value to be displayed inside the badge.
         *
         * @remarks
         * If an `icon` property is already set the `icon` will be displayed.
         * If neither a `value` nor an `icon` is set the content of the badge will be empty.
         *
         * @example
         * ```html
         * <igx-badge value="11"></igx-badge>
         * ```
         */
        this.value = '';
        /**
         * Sets/gets the role attribute value.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.role = 'status';
         * ```
         */
        this.role = 'status';
        /**
         * Sets/gets the the css class to use on the badge.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.cssClass = 'my-badge-class';
         * ```
         */
        this.cssClass = 'igx-badge';
        /**
         * Sets/gets the aria-label attribute value.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.label = 'badge';
         * ```
         */
        this.label = 'badge';
    }
    /**
     * Defines a human-readable, accessor, author-localized description for
     * the `type` and the `icon` or `value` of the element.
     *
     * @hidden
     * @internal
     */
    get roleDescription() {
        if (this.icon) {
            return this.type + ' type badge with icon type ' + this.icon;
        }
        else if (this.value || this.value === 0) {
            return this.type + ' badge type with value ' + this.value;
        }
        return this.type + ' badge type without value';
    }
    get infoClass() {
        return this.type === IgxBadgeType.INFO;
    }
    get successClass() {
        return this.type === IgxBadgeType.SUCCESS;
    }
    get warningClass() {
        return this.type === IgxBadgeType.WARNING;
    }
    get errorClass() {
        return this.type === IgxBadgeType.ERROR;
    }
}
IgxBadgeComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-badge',
                template: "<span *ngIf=\"!icon\" class=\"igx-badge__value\">{{value}}</span>\n<igx-icon *ngIf=\"icon\">{{icon}}</igx-icon>\n"
            },] }
];
IgxBadgeComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    type: [{ type: Input }],
    value: [{ type: Input }],
    icon: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-badge',] }],
    label: [{ type: HostBinding, args: ['attr.aria-label',] }],
    roleDescription: [{ type: HostBinding, args: ['attr.aria-roledescription',] }],
    infoClass: [{ type: HostBinding, args: ['class.igx-badge--info',] }],
    successClass: [{ type: HostBinding, args: ['class.igx-badge--success',] }],
    warningClass: [{ type: HostBinding, args: ['class.igx-badge--warning',] }],
    errorClass: [{ type: HostBinding, args: ['class.igx-badge--error',] }]
};
/**
 * @hidden
 */
class IgxBadgeModule {
}
IgxBadgeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxBadgeComponent],
                exports: [IgxBadgeComponent],
                imports: [CommonModule, IgxIconModule]
            },] }
];

/** @hidden */
const IGX_EXPANSION_PANEL_COMPONENT = new InjectionToken('IgxExpansionPanelToken');

class IgxExpansionPanelBodyComponent {
    constructor(panel, element, cdr) {
        this.panel = panel;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */
        this.cssClass = `igx-expansion-panel__body`;
        /**
         * Gets/sets the `role` attribute of the panel body
         * Default is 'region';
         * Get
         * ```typescript
         *  const currentRole = this.panel.body.role;
         * ```
         * Set
         * ```typescript
         *  this.panel.body.role = 'content';
         * ```
         * ```html
         *  <igx-expansion-panel-body [role]="'custom'"></igx-expansion-panel-body>
         * ```
         */
        this.role = 'region';
        this._labelledBy = '';
        this._label = '';
    }
    /**
     * Gets the `aria-label` attribute of the panel body
     * Defaults to the panel id with '-region' in the end;
     * Get
     * ```typescript
     *  const currentLabel = this.panel.body.label;
     * ```
     */
    get label() {
        return this._label || this.panel.id + '-region';
    }
    /**
     * Sets the `aria-label` attribute of the panel body
     * ```typescript
     *  this.panel.body.label = 'my-custom-label';
     * ```
     * ```html
     *  <igx-expansion-panel-body [label]="'my-custom-label'"></igx-expansion-panel-body>
     * ```
     */
    set label(val) {
        this._label = val;
    }
    /**
     * Gets the `aria-labelledby` attribute of the panel body
     * Defaults to the panel header id;
     * Get
     * ```typescript
     *  const currentLabel = this.panel.body.labelledBy;
     * ```
     */
    get labelledBy() {
        return this._labelledBy;
    }
    /**
     * Sets the `aria-labelledby` attribute of the panel body
     * ```typescript
     *  this.panel.body.labelledBy = 'my-custom-id';
     * ```
     * ```html
     *  <igx-expansion-panel-body [labelledBy]="'my-custom-id'"></igx-expansion-panel-body>
     * ```
     */
    set labelledBy(val) {
        this._labelledBy = val;
    }
}
IgxExpansionPanelBodyComponent.decorators = [
    { type: Component, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: 'igx-expansion-panel-body',
                template: `<ng-content></ng-content>`
            },] }
];
IgxExpansionPanelBodyComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxExpansionPanelBodyComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel__body',] }],
    role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }],
    label: [{ type: Input }, { type: HostBinding, args: ['attr.aria-label',] }],
    labelledBy: [{ type: Input }, { type: HostBinding, args: ['attr.aria-labelledby',] }]
};

/**
 * @hidden @internal
 */
class IgxExpansionPanelTitleDirective {
    constructor() {
        this.cssClass = `igx-expansion-panel__header-title`;
    }
}
IgxExpansionPanelTitleDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: 'igx-expansion-panel-title'
            },] }
];
IgxExpansionPanelTitleDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel__header-title',] }]
};
/**
 * @hidden @internal
 */
class IgxExpansionPanelDescriptionDirective {
    constructor() {
        this.cssClass = `igx-expansion-panel__header-description`;
    }
}
IgxExpansionPanelDescriptionDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: 'igx-expansion-panel-description'
            },] }
];
IgxExpansionPanelDescriptionDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel__header-description',] }]
};
/**
 * @hidden @internal
 */
class IgxExpansionPanelIconDirective {
}
IgxExpansionPanelIconDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: 'igx-expansion-panel-icon'
            },] }
];

/**
 * @hidden
 */
const ICON_POSITION = mkenum({
    LEFT: 'left',
    NONE: 'none',
    RIGHT: 'right'
});
class IgxExpansionPanelHeaderComponent {
    constructor(panel, cdr, elementRef) {
        this.panel = panel;
        this.cdr = cdr;
        this.elementRef = elementRef;
        /**
         * Gets/sets the `aria-level` attribute of the header
         * Get
         * ```typescript
         *  const currentAriaLevel = this.panel.header.lv;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.lv = '5';
         * ```
         * ```html
         *  <igx-expansion-panel-header [lv]="myCustomLevel"></igx-expansion-panel-header>
         * ```
         */
        this.lv = '3';
        /**
         * Gets/sets the `role` attribute of the header
         * Get
         * ```typescript
         *  const currentRole = this.panel.header.role;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.role = '5';
         * ```
         * ```html
         *  <igx-expansion-panel-header [role]="'custom'"></igx-expansion-panel-header>
         * ```
         */
        this.role = 'heading';
        /**
         * Gets/sets the position of the expansion-panel-header expand/collapse icon
         * Accepts `left`, `right` or `none`
         * ```typescript
         *  const currentIconPosition = this.panel.header.iconPosition;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.iconPosition = 'left';
         * ```
         * ```html
         *  <igx-expansion-panel-header [iconPosition]="'right'"></igx-expansion-panel-header>
         * ```
         */
        this.iconPosition = ICON_POSITION.LEFT;
        /**
         * Emitted whenever a user interacts with the header host
         * ```typescript
         *  handleInteraction(event: IExpansionPanelCancelableEventArgs) {
         *  ...
         * }
         * ```
         * ```html
         *  <igx-expansion-panel-header (onInteraction)="handleInteraction($event)">
         *      ...
         *  </igx-expansion-panel-header>
         * ```
         */
        this.onInteraction = new EventEmitter();
        /**
         * @hidden
         */
        this.cssClass = 'igx-expansion-panel__header';
        /**
         * Gets/sets the whether the header is disabled
         * When disabled, the header will not handle user events and will stop their propagation
         *
         * ```typescript
         *  const isDisabled = this.panel.header.disabled;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.disabled = true;
         * ```
         * ```html
         *  <igx-expansion-panel-header [disabled]="true">
         *     ...
         *  </igx-expansion-panel-header>
         * ```
         */
        this.disabled = false;
        /**
         * Sets/gets the `id` of the expansion panel header.
         * ```typescript
         * let panelHeaderId =  this.panel.header.id;
         * ```
         *
         * @memberof IgxExpansionPanelComponent
         */
        this.id = '';
        // properties section
        this._iconTemplate = false;
        this.id = `${this.panel.id}-header`;
    }
    /**
     * Returns a reference to the `igx-expansion-panel-icon` element;
     * If `iconPosition` is `NONE` - return null;
     */
    get iconRef() {
        var _a;
        const renderedTemplate = (_a = this.customIconRef) !== null && _a !== void 0 ? _a : this.defaultIconRef;
        return this.iconPosition !== ICON_POSITION.NONE ? renderedTemplate : null;
    }
    /**
     * @hidden
     */
    set iconTemplate(val) {
        this._iconTemplate = val;
    }
    /**
     * @hidden
     */
    get iconTemplate() {
        return this._iconTemplate;
    }
    /**
     * @hidden
     */
    get controls() {
        return this.panel.id;
    }
    /**
     * @hidden
     */
    get isExpanded() {
        return !this.panel.collapsed;
    }
    /**
     * @hidden
     */
    onAction(evt) {
        if (this.disabled) {
            evt.stopPropagation();
            return;
        }
        const eventArgs = { event: evt, panel: this.panel, owner: this.panel, cancel: false };
        this.onInteraction.emit(eventArgs);
        if (eventArgs.cancel === true) {
            return;
        }
        this.panel.toggle(evt);
        evt.preventDefault();
    }
    /** @hidden @internal */
    openPanel(event) {
        if (event.altKey) {
            const eventArgs = { event, panel: this.panel, owner: this.panel, cancel: false };
            this.onInteraction.emit(eventArgs);
            if (eventArgs.cancel === true) {
                return;
            }
            this.panel.expand(event);
        }
    }
    /** @hidden @internal */
    closePanel(event) {
        if (event.altKey) {
            const eventArgs = { event, panel: this.panel, owner: this.panel, cancel: false };
            this.onInteraction.emit(eventArgs);
            if (eventArgs.cancel === true) {
                return;
            }
            this.panel.collapse(event);
        }
    }
    /**
     * @hidden
     */
    get iconPositionClass() {
        switch (this.iconPosition) {
            case (ICON_POSITION.LEFT):
                return `igx-expansion-panel__header-icon--start`;
            case (ICON_POSITION.RIGHT):
                return `igx-expansion-panel__header-icon--end`;
            case (ICON_POSITION.NONE):
                return `igx-expansion-panel__header-icon--none`;
            default:
                return '';
        }
    }
}
IgxExpansionPanelHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-expansion-panel-header',
                template: "<div class=\"igx-expansion-panel__header-inner\" tabindex=\"0\" role=\"button\" [attr.id]=\"id\"\n[attr.aria-disabled]=\"disabled\" [attr.aria-expanded]=\"isExpanded\" [attr.aria-controls]=\"controls\">\n    <div class=\"igx-expansion-panel__title-wrapper\">\n        <ng-content select=\"igx-expansion-panel-title\"></ng-content>\n        <ng-content select=\"igx-expansion-panel-description\"></ng-content>\n    </div>\n    <ng-content></ng-content>\n    <div [class]=\"iconPositionClass\">\n        <ng-content *ngIf=\"iconTemplate\" select=\"igx-expansion-panel-icon\"></ng-content>\n        <igx-icon *ngIf=\"!iconTemplate\">\n            {{panel.collapsed? 'expand_more':'expand_less'}}\n        </igx-icon>\n    </div>\n</div>\n"
            },] }
];
IgxExpansionPanelHeaderComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Host }, { type: Inject, args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
IgxExpansionPanelHeaderComponent.propDecorators = {
    iconTemplate: [{ type: ContentChild, args: [IgxExpansionPanelIconDirective,] }],
    lv: [{ type: HostBinding, args: ['attr.aria-level',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    iconPosition: [{ type: Input }],
    onInteraction: [{ type: Output }],
    cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel__header',] }],
    isExpanded: [{ type: HostBinding, args: ['class.igx-expansion-panel__header--expanded',] }],
    disabled: [{ type: Input }, { type: HostBinding, args: ['class.igx-expansion-panel--disabled',] }],
    customIconRef: [{ type: ContentChild, args: [IgxExpansionPanelIconDirective, { read: ElementRef },] }],
    defaultIconRef: [{ type: ViewChild, args: [IgxIconComponent, { read: ElementRef },] }],
    onAction: [{ type: HostListener, args: ['keydown.Enter', ['$event'],] }, { type: HostListener, args: ['keydown.Space', ['$event'],] }, { type: HostListener, args: ['keydown.Spacebar', ['$event'],] }, { type: HostListener, args: ['click', ['$event'],] }],
    openPanel: [{ type: HostListener, args: ['keydown.Alt.ArrowDown', ['$event'],] }],
    closePanel: [{ type: HostListener, args: ['keydown.Alt.ArrowUp', ['$event'],] }]
};

let NEXT_ID$8 = 0;
class IgxExpansionPanelComponent {
    constructor(cdr, builder) {
        this.cdr = cdr;
        this.builder = builder;
        /**
         * Sets/gets the animation settings of the expansion panel component
         * Open and Close animation should be passed
         *
         * Get
         * ```typescript
         *  const currentAnimations = this.panel.animationSettings;
         * ```
         * Set
         * ```typescript
         *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
         *  ...
         *  this.panel.animationsSettings = {
         *      openAnimation: slideInLeft,
         *      closeAnimation: slideOutRight
         * };
         * ```
         * or via template
         * ```typescript
         *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
         *  ...
         *  myCustomAnimationObject = {
         *      openAnimation: slideInLeft,
         *      closeAnimation: slideOutRight
         * };
         * ```html
         *  <igx-expansion-panel [animationSettings]='myCustomAnimationObject'>
         *  ...
         *  </igx-expansion-panel>
         * ```
         */
        this.animationSettings = {
            openAnimation: growVerIn,
            closeAnimation: growVerOut
        };
        /**
         * Sets/gets the `id` of the expansion panel component.
         * If not set, `id` will have value `"igx-expansion-panel-0"`;
         * ```html
         * <igx-expansion-panel id = "my-first-expansion-panel"></igx-expansion-panel>
         * ```
         * ```typescript
         * let panelId =  this.panel.id;
         * ```
         *
         * @memberof IgxExpansionPanelComponent
         */
        this.id = `igx-expansion-panel-${NEXT_ID$8++}`;
        /**
         * @hidden
         */
        this.cssClass = 'igx-expansion-panel';
        /**
         * @hidden
         */
        this.collapsedChange = new EventEmitter();
        /**
         * Emitted when the expansion panel finishes collapsing
         * ```typescript
         *  handleCollapsed(event: IExpansionPanelEventArgs)
         * ```
         * ```html
         *  <igx-expansion-panel (onCollapsed)="handleCollapsed($event)">
         *      ...
         *  </igx-expansion-panel>
         * ```
         */
        this.onCollapsed = new EventEmitter();
        /**
         * Emitted when the expansion panel finishes expanding
         * ```typescript
         *  handleExpanded(event: IExpansionPanelEventArgs)
         * ```
         * ```html
         *  <igx-expansion-panel (onExpanded)="handleExpanded($event)">
         *      ...
         *  </igx-expansion-panel>
         * ```
         */
        this.onExpanded = new EventEmitter();
        this._collapsed = true;
    }
    /**
     * Gets/sets whether the component is collapsed (its content is hidden)
     * Get
     * ```typescript
     *  const myPanelState: boolean = this.panel.collapsed;
     * ```
     * Set
     * ```html
     *  this.panel.collapsed = true;
     * ```
     *
     * Two-way data binding:
     * ```html
     * <igx-expansion-panel [(collapsed)]="model.isCollapsed"></igx-expansion-panel>
     * ```
     */
    get collapsed() {
        return this._collapsed;
    }
    set collapsed(value) {
        this._collapsed = value;
        this.collapsedChange.emit(this._collapsed);
    }
    /**
     * @hidden
     */
    get headerId() {
        return this.header ? `${this.id}-header` : '';
    }
    /** @hidden */
    ngAfterContentInit() {
        if (this.body && this.header) {
            // schedule at end of turn:
            Promise.resolve().then(() => {
                this.body.labelledBy = this.body.labelledBy || this.headerId;
                this.body.label = this.body.label || this.id + '-region';
            });
        }
    }
    /**
     * Collapses the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.collapse($event)">Collpase Panel</button>
     * ```
     */
    collapse(evt) {
        if (this.collapsed) { // If expansion panel is already collapsed, do nothing
            return;
        }
        this.playCloseAnimation(() => {
            this.onCollapsed.emit({ event: evt, panel: this, owner: this });
            this.collapsed = true;
            this.cdr.markForCheck();
        });
    }
    /**
     * Expands the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.expand($event)">Expand Panel</button>
     * ```
     */
    expand(evt) {
        if (!this.collapsed) { // If the panel is already opened, do nothing
            return;
        }
        this.collapsed = false;
        this.cdr.detectChanges();
        this.playOpenAnimation(() => {
            this.onExpanded.emit({ event: evt, panel: this, owner: this });
        });
    }
    /**
     * Toggles the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.toggle($event)">Expand Panel</button>
     * ```
     */
    toggle(evt) {
        if (this.collapsed) {
            this.open(evt);
        }
        else {
            this.close(evt);
        }
    }
    open(evt) {
        this.expand(evt);
    }
    close(evt) {
        this.collapse(evt);
    }
    playOpenAnimation(cb) {
        if (!this.body) { // if not body element is passed, there is nothing to animate
            return;
        }
        const animation = useAnimation(this.animationSettings.openAnimation);
        const animationBuilder = this.builder.build(animation);
        const openAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
        openAnimationPlayer.onDone(() => {
            cb();
            openAnimationPlayer.reset();
        });
        openAnimationPlayer.play();
    }
    playCloseAnimation(cb) {
        if (!this.body) { // if not body element is passed, there is nothing to animate
            return;
        }
        const animation = useAnimation(this.animationSettings.closeAnimation);
        const animationBuilder = this.builder.build(animation);
        const closeAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
        closeAnimationPlayer.onDone(() => {
            cb();
            closeAnimationPlayer.reset();
        });
        closeAnimationPlayer.play();
    }
}
IgxExpansionPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-expansion-panel',
                template: "<ng-content select=\"igx-expansion-panel-header\"></ng-content>\n<ng-content *ngIf=\"!collapsed\" select=\"igx-expansion-panel-body\"></ng-content>\n",
                providers: [{ provide: IGX_EXPANSION_PANEL_COMPONENT, useExisting: IgxExpansionPanelComponent }]
            },] }
];
IgxExpansionPanelComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: AnimationBuilder }
];
IgxExpansionPanelComponent.propDecorators = {
    animationSettings: [{ type: Input }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel',] }],
    collapsed: [{ type: Input }],
    collapsedChange: [{ type: Output }],
    onCollapsed: [{ type: Output }],
    onExpanded: [{ type: Output }],
    body: [{ type: ContentChild, args: [IgxExpansionPanelBodyComponent, { read: IgxExpansionPanelBodyComponent },] }],
    header: [{ type: ContentChild, args: [IgxExpansionPanelHeaderComponent, { read: IgxExpansionPanelHeaderComponent },] }]
};

/**
 * @hidden
 */
class IgxExpansionPanelModule {
}
IgxExpansionPanelModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxExpansionPanelComponent,
                    IgxExpansionPanelHeaderComponent,
                    IgxExpansionPanelBodyComponent,
                    IgxExpansionPanelDescriptionDirective,
                    IgxExpansionPanelTitleDirective,
                    IgxExpansionPanelIconDirective
                ],
                entryComponents: [],
                exports: [
                    IgxExpansionPanelComponent,
                    IgxExpansionPanelHeaderComponent,
                    IgxExpansionPanelBodyComponent,
                    IgxExpansionPanelDescriptionDirective,
                    IgxExpansionPanelTitleDirective,
                    IgxExpansionPanelIconDirective
                ],
                imports: [
                    CommonModule,
                    IgxRippleModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxAvatarModule
                ]
            },] }
];

/* eslint-disable @angular-eslint/directive-selector */
class IgxBannerActionsDirective {
}
IgxBannerActionsDirective.decorators = [
    { type: Directive, args: [{
                selector: 'igx-banner-actions'
            },] }
];

/**
 * **Ignite UI for Angular Banner** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/banner.html)
 *
 * The Ignite UI Banner provides a highly templateable and easy to use banner that can be shown in your application.
 *
 * Usage:
 *
 * ```html
 * <igx-banner #banner>
 *   Our privacy settings have changed.
 *  <igx-banner-actions>
 *      <button igxButton="raised">Read More</button>
 *      <button igxButton="raised">Accept and Continue</button>
 *  </igx-banner-actions>
 * </igx-banner>
 * ```
 */
class IgxBannerComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Fires after the banner shows up
         * ```typescript
         * public handleOpened(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onOpened)="handleOpened($event)"></igx-banner>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Fires before the banner shows up
         * ```typescript
         * public handleOpening(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onOpening)="handleOpening($event)"></igx-banner>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Fires after the banner hides
         * ```typescript
         * public handleClosed(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onClosed)="handleClosed($event)"></igx-banner>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Fires before the banner hides
         * ```typescript
         * public handleClosing(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onClosing)="handleClosing($event)"></igx-banner>
         * ```
         */
        this.onClosing = new EventEmitter();
    }
    /** @hidden */
    get useDefaultTemplate() {
        return !this._bannerActionTemplate;
    }
    /**
     * Get the animation settings used by the banner open/close methods
     * ```typescript
     * let currentAnimations: AnimationSettings = banner.animationSettings
     * ```
     */
    get animationSettings() {
        return this._animationSettings ? this._animationSettings : this._expansionPanel.animationSettings;
    }
    /**
     * Set the animation settings used by the banner open/close methods
     * ```typescript
     * import { slideInLeft, slideOutRight } from 'igniteui-angular';
     * ...
     * banner.animationSettings: AnimationSettings = { openAnimation: slideInLeft, closeAnimation: slideOutRight };
     * ```
     */
    set animationSettings(settings) {
        this._animationSettings = settings;
    }
    /**
     * Gets whether banner is collapsed
     *
     * ```typescript
     * const isCollapsed: boolean = banner.collapsed;
     * ```
     */
    get collapsed() {
        return this._expansionPanel.collapsed;
    }
    /**
     * Returns the native element of the banner component
     * ```typescript
     *  const myBannerElement: HTMLElement = banner.element;
     * ```
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get displayStyle() {
        return this.collapsed ? '' : 'block';
    }
    /**
     * Opens the banner
     *
     * ```typescript
     *  myBanner.open();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.open()">Open Banner</button>
     * ```
     */
    open(event) {
        this._bannerEvent = { banner: this, event };
        const openingArgs = {
            banner: this,
            event,
            cancel: false
        };
        this.onOpening.emit(openingArgs);
        if (openingArgs.cancel) {
            return;
        }
        this._expansionPanel.open(event);
    }
    /**
     * Closes the banner
     *
     * ```typescript
     *  myBanner.close();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.close()">Close Banner</button>
     * ```
     */
    close(event) {
        this._bannerEvent = { banner: this, event };
        const closingArgs = {
            banner: this,
            event,
            cancel: false
        };
        this.onClosing.emit(closingArgs);
        if (closingArgs.cancel) {
            return;
        }
        this._expansionPanel.close(event);
    }
    /**
     * Toggles the banner
     *
     * ```typescript
     *  myBanner.toggle();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.toggle()">Toggle Banner</button>
     * ```
     */
    toggle(event) {
        if (this.collapsed) {
            this.open(event);
        }
        else {
            this.close(event);
        }
    }
    /** @hidden */
    onExpansionPanelOpen() {
        this.onOpened.emit(this._bannerEvent);
    }
    /** @hidden */
    onExpansionPanelClose() {
        this.onClosed.emit(this._bannerEvent);
    }
}
IgxBannerComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-banner',
                template: "<igx-expansion-panel #expansionPanel [animationSettings]=\"animationSettings\" (onCollapsed)=\"onExpansionPanelClose()\" (onExpanded)=\"onExpansionPanelOpen()\"\n    [collapsed]=\"collapsed\" aria-live=\"polite\" [attr.aria-hidden]=\"collapsed\">\n    <igx-expansion-panel-body>\n        <div class=\"igx-banner\">\n            <div class=\"igx-banner__message\">\n                <div *ngIf=\"bannerIcon\" class=\"igx-banner__illustration\">\n                    <ng-content select=\"igx-icon\"></ng-content>\n                </div>\n                <span class=\"igx-banner__text\">\n                    <ng-content></ng-content>\n                </span>\n            </div>\n            <div class=\"igx-banner__actions\">\n                <div class=\"igx-banner__row\">\n                    <ng-container *ngIf=\"useDefaultTemplate\">\n                        <button igxButton=\"flat\" igxRipple (click)=\"close()\">\n                            Dismiss\n                        </button>\n                    </ng-container>\n                    <ng-container *ngIf=\"!useDefaultTemplate\">\n                        <ng-content select=\"igx-banner-actions\"></ng-content>\n                    </ng-container>\n                </div>\n            </div>\n        </div>\n    </igx-expansion-panel-body>\n</igx-expansion-panel>"
            },] }
];
IgxBannerComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxBannerComponent.propDecorators = {
    bannerIcon: [{ type: ContentChild, args: [IgxIconComponent,] }],
    onOpened: [{ type: Output }],
    onOpening: [{ type: Output }],
    onClosed: [{ type: Output }],
    onClosing: [{ type: Output }],
    animationSettings: [{ type: Input }],
    displayStyle: [{ type: HostBinding, args: ['style.display',] }],
    _expansionPanel: [{ type: ViewChild, args: ['expansionPanel', { static: true },] }],
    _bannerActionTemplate: [{ type: ContentChild, args: [IgxBannerActionsDirective,] }]
};
/**
 * @hidden
 */
class IgxBannerModule {
}
IgxBannerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxBannerComponent, IgxBannerActionsDirective],
                exports: [IgxBannerComponent, IgxBannerActionsDirective],
                imports: [CommonModule, IgxExpansionPanelModule, IgxIconModule, IgxButtonModule, IgxRippleModule]
            },] }
];

/**
 * Determines the Button Group alignment
 */
const ButtonGroupAlignment = mkenum({
    horizontal: 'horizontal',
    vertical: 'vertical'
});
let NEXT_ID$9 = 0;
/**
 * **Ignite UI for Angular Button Group** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/buttongroup.html)
 *
 * The Ignite UI Button Group displays a group of buttons either vertically or horizontally.  The group supports
 * single, multiple and toggle selection.
 *
 * Example:
 * ```html
 * <igx-buttongroup multiSelection="true" [values]="fontOptions">
 * </igx-buttongroup>
 * ```
 * The `fontOptions` value shown above is defined as:
 * ```typescript
 * this.fontOptions = [
 *   { icon: 'format_bold', selected: false },
 *   { icon: 'format_italic', selected: false },
 *   { icon: 'format_underlined', selected: false }];
 * ```
 */
class IgxButtonGroupComponent extends DisplayDensityBase {
    constructor(_cdr, _renderer, _displayDensityOptions) {
        super(_displayDensityOptions);
        this._cdr = _cdr;
        this._renderer = _renderer;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * An @Input property that sets the value of the `id` attribute. If not set it will be automatically generated.
         * ```html
         *  <igx-buttongroup [id]="'igx-dialog-56'" [multiSelection]="!multi" [values]="alignOptions">
         * ```
         */
        this.id = `igx-buttongroup-${NEXT_ID$9++}`;
        /**
         * @hidden
         */
        this.zIndex = 0;
        /**
         * An @Input property that enables selecting multiple buttons. By default, multi-selection is false.
         * ```html
         * <igx-buttongroup [multiSelection]="false" [alignment]="alignment"></igx-buttongroup>
         * ```
         */
        this.multiSelection = false;
        /**
         * An @Ouput property that emits an event when a button is selected.
         * ```typescript
         * @ViewChild("toast")
         * private toast: IgxToastComponent;
         * public selectedHandler(buttongroup) {
         *     this.toast.open()
         * }
         *  //...
         * ```
         * ```html
         * <igx-buttongroup #MyChild [multiSelection]="!multi" (selected)="selectedHandler($event)"></igx-buttongroup>
         * <igx-toast #toast message="You have made a selection!"></igx-toast>
         * ```
         */
        this.selected = new EventEmitter();
        /**
         * An @Ouput property that emits an event when a button is deselected.
         * ```typescript
         *  @ViewChild("toast")
         *  private toast: IgxToastComponent;
         *  public deselectedHandler(buttongroup){
         *     this.toast.open()
         * }
         *  //...
         * ```
         * ```html
         * <igx-buttongroup> #MyChild [multiSelection]="multi" (deselected)="deselectedHandler($event)"></igx-buttongroup>
         * <igx-toast #toast message="You have deselected a button!"></igx-toast>
         * ```
         */
        this.deselected = new EventEmitter();
        /**
         * @hidden
         */
        this.selectedIndexes = [];
        this.buttonClickNotifier$ = new Subject();
        this.queryListNotifier$ = new Subject();
        this._disabled = false;
    }
    /**
     * A collection containing all buttons inside the button group.
     */
    get buttons() {
        return [...this.viewButtons.toArray(), ...this.templateButtons.toArray()];
    }
    /**
     * Allows you to set a style using the `itemContentCssClass` input.
     * The value should be the CSS class name that will be applied to the button group.
     * ```typescript
     * public style1 = "styleClass";
     *  //..
     * ```
     *  ```html
     * <igx-buttongroup [itemContentCssClass]="style1" [multiSelection]="!multi" [values]="alignOptions">
     * ```
     */
    set itemContentCssClass(value) {
        this._itemContentCssClass = value || this._itemContentCssClass;
    }
    /**
     * Returns the CSS class of the item content of the `IgxButtonGroup`.
     * ```typescript
     *  @ViewChild("MyChild")
     * public buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let buttonSelect = this.buttonG.itemContentCssClass;
     * }
     * ```
     */
    get itemContentCssClass() {
        return this._itemContentCssClass;
    }
    /**
     * An @Input property that allows you to disable the `igx-buttongroup` component. By default it's false.
     * ```html
     * <igx-buttongroup [disabled]="true" [multiSelection]="multi" [values]="fontOptions"></igx-buttongroup>
     * ```
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        if (this._disabled !== value) {
            this._disabled = value;
            if (this.viewButtons && this.templateButtons) {
                this.buttons.forEach((b) => b.disabled = this._disabled);
            }
        }
    }
    /**
     * Allows you to set the button group alignment.
     * Available options are `ButtonGroupAlignment.horizontal` (default) and `ButtonGroupAlignment.vertical`.
     * ```typescript
     * public alignment = ButtonGroupAlignment.vertical;
     * //..
     * ```
     * ```html
     * <igx-buttongroup [multiSelection]="false" [values]="cities" [alignment]="alignment"></igx-buttongroup>
     * ```
     */
    set alignment(value) {
        this._isVertical = value === ButtonGroupAlignment.vertical;
    }
    /**
     * Returns the alignment of the `igx-buttongroup`.
     * ```typescript
     * @ViewChild("MyChild")
     * public buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let buttonAlignment = this.buttonG.alignment;
     * }
     * ```
     */
    get alignment() {
        return this._isVertical ? ButtonGroupAlignment.vertical : ButtonGroupAlignment.horizontal;
    }
    /**
     * Returns true if the `igx-buttongroup` alignment is vertical.
     * Note that in order for the accessor to work correctly the property should be set explicitly.
     * ```html
     * <igx-buttongroup #MyChild [alignment]="alignment" [values]="alignOptions">
     * ```
     * ```typescript
     * //...
     * @ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let orientation = this.buttonG.isVertical;
     * }
     * ```
     */
    get isVertical() {
        return this._isVertical;
    }
    /**
     * Gets the selected button/buttons.
     * ```typescript
     * @ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let selectedButton = this.buttonG.selectedButtons;
     * }
     * ```
     */
    get selectedButtons() {
        return this.buttons.filter((_, i) => this.selectedIndexes.indexOf(i) !== -1);
    }
    /**
     * Selects a button by its index.
     * ```typescript
     * @ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    this.buttonG.selectButton(2);
     *    this.cdr.detectChanges();
     * }
     * ```
     *
     * @memberOf {@link IgxButtonGroupComponent}
     */
    selectButton(index) {
        if (index >= this.buttons.length || index < 0) {
            return;
        }
        const button = this.buttons[index];
        const buttonElement = button.nativeElement;
        this.selectedIndexes.push(index);
        button.selected = true;
        this._renderer.setAttribute(buttonElement, 'aria-pressed', 'true');
        this._renderer.addClass(buttonElement, 'igx-button-group__item--selected');
        this.selected.emit({ button, index });
        const indexInViewButtons = this.viewButtons.toArray().indexOf(button);
        if (indexInViewButtons !== -1) {
            this.values[indexInViewButtons].selected = true;
        }
        // deselect other buttons if multiSelection is not enabled
        if (!this.multiSelection && this.selectedIndexes.length > 1) {
            this.buttons.forEach((_, i) => {
                if (i !== index && this.selectedIndexes.indexOf(i) !== -1) {
                    this.deselectButton(i);
                }
            });
        }
    }
    /**
     * Deselects a button by its index.
     * ```typescript
     * @ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    this.buttonG.deselectButton(2);
     *    this.cdr.detectChanges();
     * }
     * ```
     *
     * @memberOf {@link IgxButtonGroupComponent}
     */
    deselectButton(index) {
        if (index >= this.buttons.length || index < 0) {
            return;
        }
        const button = this.buttons[index];
        const buttonElement = button.nativeElement;
        this.selectedIndexes.splice(this.selectedIndexes.indexOf(index), 1);
        button.selected = false;
        this._renderer.setAttribute(buttonElement, 'aria-pressed', 'false');
        this._renderer.removeClass(buttonElement, 'igx-button-group__item--selected');
        this.deselected.emit({ button, index });
        const indexInViewButtons = this.viewButtons.toArray().indexOf(button);
        if (indexInViewButtons !== -1) {
            this.values[indexInViewButtons].selected = false;
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.templateButtons.forEach((button) => {
            if (!button.initialDensity) {
                button.displayDensity = this.displayDensity;
            }
        });
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        const initButtons = () => {
            // Cancel any existing buttonClick subscriptions
            this.buttonClickNotifier$.next();
            this.selectedIndexes.splice(0, this.selectedIndexes.length);
            // initial configuration
            this.buttons.forEach((button, index) => {
                const buttonElement = button.nativeElement;
                if (this.disabled) {
                    button.disabled = true;
                }
                if (button.selected) {
                    this.selectButton(index);
                }
                button.buttonClick.pipe(takeUntil(this.buttonClickNotifier$)).subscribe((ev) => this._clickHandler(ev, index));
                this._renderer.addClass(buttonElement, 'igx-button-group__item');
            });
        };
        this.viewButtons.changes.pipe(takeUntil(this.queryListNotifier$)).subscribe(() => initButtons());
        this.templateButtons.changes.pipe(takeUntil(this.queryListNotifier$)).subscribe(() => initButtons());
        initButtons();
        this._cdr.detectChanges();
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.buttonClickNotifier$.next();
        this.buttonClickNotifier$.complete();
        this.queryListNotifier$.next();
        this.queryListNotifier$.complete();
    }
    /**
     * @hidden
     */
    _clickHandler(_, i) {
        if (this.selectedIndexes.indexOf(i) !== -1) {
            this.deselectButton(i);
        }
        else {
            this.selectButton(i);
        }
    }
}
IgxButtonGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-buttongroup',
                template: "<div class=\"igx-button-group\" role=\"group\" [class.igx-button-group--vertical]=\"isVertical\">\n    <button *ngFor=\"let button of values; let i = 'index'\"\n        type=\"button\"\n        igxButton=\"flat\"\n        [displayDensity]=\"displayDensity\"\n        [selected]=\"button.selected\"\n        [attr.data-togglable]=\"button.togglable\"\n        [disabled]=\"disabled || button.disabled\"\n        [igxButtonColor]=\"button.color\"\n        [igxButtonBackground]=\"button.bgcolor\"\n        [igxLabel]=\"button.label\"\n        [igxRipple]=\"button.ripple\"\n    >\n        <span class=\"igx-button-group__item-content {{ itemContentCssClass }}\">\n            <igx-icon *ngIf=\"button.icon\">{{button.icon}}</igx-icon>\n            <span class=\"igx-button-group__button-text\" *ngIf=\"button.label\">{{button.label}}</span>\n        </span>\n    </button>\n    <ng-content></ng-content>\n</div>\n"
            },] }
];
IgxButtonGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxButtonGroupComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    zIndex: [{ type: HostBinding, args: ['style.zIndex',] }],
    itemContentCssClass: [{ type: Input }],
    multiSelection: [{ type: Input }],
    values: [{ type: Input }],
    disabled: [{ type: Input }],
    alignment: [{ type: Input }],
    selected: [{ type: Output }],
    deselected: [{ type: Output }],
    viewButtons: [{ type: ViewChildren, args: [IgxButtonDirective,] }],
    templateButtons: [{ type: ContentChildren, args: [IgxButtonDirective,] }]
};
/**
 * @hidden
 */
class IgxButtonGroupModule {
}
IgxButtonGroupModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxButtonGroupComponent],
                exports: [IgxButtonGroupComponent],
                imports: [IgxButtonModule, CommonModule, IgxRippleModule, IgxIconModule]
            },] }
];

var DateRangeType;
(function (DateRangeType) {
    DateRangeType[DateRangeType["After"] = 0] = "After";
    DateRangeType[DateRangeType["Before"] = 1] = "Before";
    DateRangeType[DateRangeType["Between"] = 2] = "Between";
    DateRangeType[DateRangeType["Specific"] = 3] = "Specific";
    DateRangeType[DateRangeType["Weekdays"] = 4] = "Weekdays";
    DateRangeType[DateRangeType["Weekends"] = 5] = "Weekends";
})(DateRangeType || (DateRangeType = {}));

/**
 * @hidden
 */
var TimeDeltaInterval;
(function (TimeDeltaInterval) {
    TimeDeltaInterval["Month"] = "month";
    TimeDeltaInterval["Year"] = "year";
})(TimeDeltaInterval || (TimeDeltaInterval = {}));
const MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const FEBRUARY = 1;
const range = (start = 0, stop, step = 1) => {
    const res = [];
    const cur = (stop === undefined) ? 0 : start;
    const max = (stop === undefined) ? start : stop;
    for (let i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
};
/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param year
 * @returns
 */
const isLeap = (year) => (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
const weekDay = (year, month, day) => new Date(year, month, day).getDay();
/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param year
 * @param month
 * @returns
 */
const monthRange = (year, month) => {
    if ((month < 0) || (month > 11)) {
        throw new Error('Invalid month specified');
    }
    const day = weekDay(year, month, 1);
    let nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
};
const isDateInRanges = (date, ranges) => {
    date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const dateInMs = date.getTime();
    if (!ranges) {
        return false;
    }
    for (const descriptor of ranges) {
        const dRanges = descriptor.dateRange ? descriptor.dateRange.map(r => new Date(r.getFullYear(), r.getMonth(), r.getDate())) : undefined;
        switch (descriptor.type) {
            case (DateRangeType.After):
                if (dateInMs > dRanges[0].getTime()) {
                    return true;
                }
                break;
            case (DateRangeType.Before):
                if (dateInMs < dRanges[0].getTime()) {
                    return true;
                }
                break;
            case (DateRangeType.Between):
                const dRange = dRanges.map(d => d.getTime());
                const min = Math.min(dRange[0], dRange[1]);
                const max = Math.max(dRange[0], dRange[1]);
                if (dateInMs >= min && dateInMs <= max) {
                    return true;
                }
                break;
            case (DateRangeType.Specific):
                const datesInMs = dRanges.map(d => d.getTime());
                for (const specificDateInMs of datesInMs) {
                    if (dateInMs === specificDateInMs) {
                        return true;
                    }
                }
                break;
            case (DateRangeType.Weekdays):
                const day = date.getDay();
                if (day % 6 !== 0) {
                    return true;
                }
                break;
            case (DateRangeType.Weekends):
                const weekday = date.getDay();
                if (weekday % 6 === 0) {
                    return true;
                }
                break;
            default:
                return false;
        }
    }
    return false;
};
var WEEKDAYS;
(function (WEEKDAYS) {
    WEEKDAYS[WEEKDAYS["SUNDAY"] = 0] = "SUNDAY";
    WEEKDAYS[WEEKDAYS["MONDAY"] = 1] = "MONDAY";
    WEEKDAYS[WEEKDAYS["TUESDAY"] = 2] = "TUESDAY";
    WEEKDAYS[WEEKDAYS["WEDNESDAY"] = 3] = "WEDNESDAY";
    WEEKDAYS[WEEKDAYS["THURSDAY"] = 4] = "THURSDAY";
    WEEKDAYS[WEEKDAYS["FRIDAY"] = 5] = "FRIDAY";
    WEEKDAYS[WEEKDAYS["SATURDAY"] = 6] = "SATURDAY";
})(WEEKDAYS || (WEEKDAYS = {}));
class Calendar {
    constructor(firstWeekDay = WEEKDAYS.SUNDAY) {
        this._firstWeekDay = firstWeekDay;
    }
    get firstWeekDay() {
        return this._firstWeekDay % 7;
    }
    set firstWeekDay(value) {
        this._firstWeekDay = value;
    }
    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * @returns
     *
     * @memberof Calendar
     */
    weekdays() {
        const res = [];
        for (const i of range(this.firstWeekDay, this.firstWeekDay + 7)) {
            res.push(i % 7);
        }
        return res;
    }
    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * @param year
     * @param month
     * @param boolean
     * @returns
     *
     * @memberof Calendar
     */
    monthdates(year, month, extraWeek = false) {
        let date = new Date(year, month, 1);
        let days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, 'day', -days);
        const res = [];
        let value;
        while (true) {
            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, 'day', 1);
            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    for (const _ of range(0, 7)) {
                        value = this.generateICalendarDate(date, year, month);
                        res.push(value);
                        date = this.timedelta(date, 'day', 1);
                    }
                }
                break;
            }
        }
        return res;
    }
    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * @param year
     * @param month
     * @returns
     *
     * @memberof Calendar
     */
    monthdatescalendar(year, month, extraWeek = false) {
        const dates = this.monthdates(year, month, extraWeek);
        const res = [];
        for (const i of range(0, dates.length, 7)) {
            res.push(dates.slice(i, i + 7));
        }
        return res;
    }
    timedelta(date, interval, units) {
        const ret = new Date(date);
        const checkRollover = () => {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };
        switch (interval.toLowerCase()) {
            case 'year':
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case 'quarter':
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case 'month':
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case 'week':
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case 'day':
                ret.setDate(ret.getDate() + units);
                break;
            case 'hour':
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case 'minute':
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case 'second':
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error('Invalid interval specifier');
        }
        return ret;
    }
    formatToParts(date, locale, options, parts) {
        const formatter = new Intl.DateTimeFormat(locale, options);
        const result = {
            date,
            full: formatter.format(date)
        };
        if (formatter.formatToParts) {
            const formattedParts = formatter.formatToParts(date);
            const toType = (partType) => {
                const index = formattedParts.findIndex(({ type }) => type === partType);
                const o = { value: '', literal: '', combined: '' };
                if (partType === 'era' && index > -1) {
                    o.value = formattedParts[index].value;
                    return o;
                }
                else if (partType === 'era' && index === -1) {
                    return o;
                }
                o.value = formattedParts[index].value;
                o.literal = formattedParts[index + 1] ? formattedParts[index + 1].value : '';
                o.combined = [o.value, o.literal].join('');
                return o;
            };
            for (const each of parts) {
                result[each] = toType(each);
            }
        }
        else {
            for (const each of parts) {
                result[each] = { value: '', literal: '', combined: '' };
            }
        }
        return result;
    }
    getFirstViewDate(date, interval, activeViewIdx) {
        return this.timedelta(date, interval, -activeViewIdx);
    }
    getDateByView(date, interval, activeViewIdx) {
        return this.timedelta(date, interval, activeViewIdx);
    }
    getNextMonth(date) {
        return this.timedelta(date, TimeDeltaInterval.Month, 1);
    }
    getPrevMonth(date) {
        return this.timedelta(date, TimeDeltaInterval.Month, -1);
    }
    getNextYear(date) {
        return this.timedelta(date, TimeDeltaInterval.Year, 1);
    }
    getPrevYear(date) {
        return this.timedelta(date, TimeDeltaInterval.Year, -1);
    }
    getWeekNumber(date) {
        const firstJan = new Date(date.getFullYear(), 0, 1).getTime();
        const today = new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
        const dayInMilSeconds = 86400000;
        const dayOfYear = ((today - firstJan + 1) / dayInMilSeconds);
        return Math.ceil(dayOfYear / 7);
    }
    generateICalendarDate(date, year, month) {
        return {
            date,
            isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
            isNextMonth: this.isNextMonth(date, year, month),
            isPrevMonth: this.isPreviousMonth(date, year, month)
        };
    }
    isPreviousMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    }
    isNextMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    }
}

/**
 * Sets the selection type - single, multi or range.
 */
const CalendarSelection = mkenum({
    SINGLE: 'single',
    MULTI: 'multi',
    RANGE: 'range'
});
var ScrollMonth;
(function (ScrollMonth) {
    ScrollMonth["PREV"] = "prev";
    ScrollMonth["NEXT"] = "next";
    ScrollMonth["NONE"] = "none";
})(ScrollMonth || (ScrollMonth = {}));
/** @hidden @internal */
class IgxCalendarBaseDirective {
    /**
     * @hidden
     */
    constructor() {
        /**
         * Sets/gets whether the outside dates (dates that are out of the current month) will be hidden.
         * Default value is `false`.
         * ```html
         * <igx-calendar [hideOutsideDays] = "true"></igx-calendar>
         * ```
         * ```typescript
         * let hideOutsideDays = this.calendar.hideOutsideDays;
         * ```
         */
        this.hideOutsideDays = false;
        /**
         * Emits an event when a date is selected.
         * Provides reference the `selectedDates` property.
         */
        this.selected = new EventEmitter();
        /**
         * Emits an event when the month in view is changed.
         * ```html
         * <igx-calendar (viewDateChanged)="viewDateChanged($event)"></igx-calendar>
         * ```
         * ```typescript
         * public viewDateChanged(event: IViewDateChangeEventArgs) {
         *  let viewDate = event.currentValue;
         * }
         * ```
         */
        this.viewDateChanged = new EventEmitter();
        /**
         * Emits an event when the active view is changed.
         * ```html
         * <igx-calendar (activeViewChanged)="activeViewChanged($event)"></igx-calendar>
         * ```
         * ```typescript
         * public activeViewChanged(event: CalendarView) {
         *  let activeView = event;
         * }
         * ```
         */
        this.activeViewChanged = new EventEmitter();
        /**
         * @hidden
         */
        this.rangeStarted = false;
        /**
         * @hidden
         */
        this.monthScrollDirection = ScrollMonth.NONE;
        /**
         * @hidden
         */
        this.scrollMonth$ = new Subject();
        /**
         * @hidden
         */
        this.stopMonthScroll$ = new Subject();
        /**
         * @hidden
         */
        this.startMonthScroll$ = new Subject();
        /**
         * @hidden
         */
        this._onTouchedCallback = noop;
        /**
         * @hidden
         */
        this._onChangeCallback = noop;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._selection = CalendarSelection.SINGLE;
        /** @hidden @internal */
        this._resourceStrings = CurrentResourceStrings.CalendarResStrings;
        /**
         * @hidden
         */
        this._formatOptions = {
            day: 'numeric',
            month: 'short',
            weekday: 'short',
            year: 'numeric'
        };
        /**
         * @hidden
         */
        this._formatViews = {
            day: false,
            month: true,
            year: false
        };
        this.calendarModel = new Calendar();
        this.viewDate = this.viewDate ? this.viewDate : new Date();
        this.calendarModel.firstWeekDay = this.weekStart;
        this.initFormatters();
    }
    /**
     * An accessor that sets the resource strings.
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     */
    get resourceStrings() {
        if (!this._resourceStrings) {
            this._resourceStrings = CurrentResourceStrings.CalendarResStrings;
        }
        return this._resourceStrings;
    }
    /**
     * Gets the start day of the week.
     * Can return a numeric or an enum representation of the week day.
     * Defaults to `Sunday` / `0`.
     */
    get weekStart() {
        return this.calendarModel.firstWeekDay;
    }
    /**
     * Sets the start day of the week.
     * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
     */
    set weekStart(value) {
        this.calendarModel.firstWeekDay = value;
    }
    /**
     * Gets the `locale` of the calendar.
     * Default value is `"en"`.
     */
    get locale() {
        return this._locale;
    }
    /**
     * Sets the `locale` of the calendar.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     */
    set locale(value) {
        this._locale = value;
        this.initFormatters();
    }
    /**
     * Gets the date format options of the days view.
     */
    get formatOptions() {
        return this._formatOptions;
    }
    /**
     * Sets the date format options of the days view.
     * Default is { day: 'numeric', month: 'short', weekday: 'short', year: 'numeric' }
     */
    set formatOptions(formatOptions) {
        this._formatOptions = Object.assign(this._formatOptions, formatOptions);
        this.initFormatters();
    }
    /**
     * Gets whether the `day`, `month` and `year` should be rendered
     * according to the locale and formatOptions, if any.
     */
    get formatViews() {
        return this._formatViews;
    }
    /**
     * Gets whether the `day`, `month` and `year` should be rendered
     * according to the locale and formatOptions, if any.
     */
    set formatViews(formatViews) {
        this._formatViews = Object.assign(this._formatViews, formatViews);
    }
    /**
     *
     * Gets the selection type.
     * Default value is `"single"`.
     * Changing the type of selection resets the currently
     * selected values if any.
     */
    get selection() {
        return this._selection;
    }
    /**
     * Sets the selection.
     */
    set selection(value) {
        switch (value) {
            case CalendarSelection.SINGLE:
                this.selectedDates = null;
                break;
            case CalendarSelection.MULTI:
            case CalendarSelection.RANGE:
                this.selectedDates = [];
                break;
            default:
                throw new Error('Invalid selection value');
        }
        this._onChangeCallback(this.selectedDates);
        this.rangeStarted = false;
        this._selection = value;
    }
    /**
     * Gets the selected date(s).
     *
     * When selection is set to `single`, it returns
     * a single `Date` object.
     * Otherwise it is an array of `Date` objects.
     */
    get value() {
        return this.selectedDates;
    }
    /**
     * Sets the selected date(s).
     *
     * When selection is set to `single`, it accepts
     * a single `Date` object.
     * Otherwise it is an array of `Date` objects.
     */
    set value(value) {
        if (!value || !!value && value.length === 0) {
            this.selectedDatesWithoutFocus = new Date();
            return;
        }
        if (!this.selectedDatesWithoutFocus) {
            const valueDate = value[0] ? Math.min.apply(null, value) : value;
            const date = this.getDateOnly(new Date(valueDate)).setDate(1);
            this.viewDate = new Date(date);
        }
        this.selectDate(value);
        this.selectedDatesWithoutFocus = value;
    }
    /**
     * Gets the date that is presented.
     * By default it is the current date.
     */
    get viewDate() {
        return this._viewDate;
    }
    /**
     * Sets the date that will be presented in the default view when the component renders.
     */
    set viewDate(value) {
        if (Array.isArray(value)) {
            return;
        }
        if (this._viewDate) {
            this.selectedDatesWithoutFocus = value;
        }
        const date = this.getDateOnly(value).setDate(1);
        this._viewDate = new Date(date);
    }
    /**
     * Gets the disabled dates descriptors.
     */
    get disabledDates() {
        return this._disabledDates;
    }
    /**
     * Sets the disabled dates' descriptors.
     * ```typescript
     * @ViewChild("MyCalendar")
     * public calendar: IgxCalendarComponent;
     * ngOnInit(){
     *    this.calendar.disabledDates = [
     *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
     *     {type: DateRangeType.Weekends}];
     * }
     * ```
     */
    set disabledDates(value) {
        this._disabledDates = value;
    }
    /**
     * Gets the special dates descriptors.
     */
    get specialDates() {
        return this._specialDates;
    }
    /**
     * Sets the special dates' descriptors.
     * ```typescript
     * @ViewChild("MyCalendar")
     * public calendar: IgxCalendarComponent;
     * ngOnInit(){
     *    this.calendar.specialDates = [
     *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
     *     {type: DateRangeType.Weekends}];
     * }
     * ```
     */
    set specialDates(value) {
        this._specialDates = value;
    }
    /**
     * Performs deselection of a single value, when selection is multi
     * Usually performed by the selectMultiple method, but leads to bug when multiple months are in view
     *
     * @hidden
     */
    deselectMultipleInMonth(value) {
        const valueDateOnly = this.getDateOnly(value);
        this.selectedDates = this.selectedDates.filter((date) => date.getTime() !== valueDateOnly.getTime());
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.selectDate(value);
    }
    /**
     * Checks whether a date is disabled.
     *
     * @hidden
     */
    isDateDisabled(date) {
        if (this.disabledDates === null) {
            return false;
        }
        return isDateInRanges(date, this.disabledDates);
    }
    /**
     * Selects date(s) (based on the selection type).
     */
    selectDate(value) {
        if (value === null || value === undefined || (Array.isArray(value) && value.length === 0)) {
            return;
        }
        switch (this.selection) {
            case CalendarSelection.SINGLE:
                if (isDate(value) && !this.isDateDisabled(value)) {
                    this.selectSingle(value);
                }
                break;
            case CalendarSelection.MULTI:
                this.selectMultiple(value);
                break;
            case CalendarSelection.RANGE:
                this.selectRange(value, true);
                break;
        }
    }
    /**
     * Deselects date(s) (based on the selection type).
     */
    deselectDate(value) {
        if (!this.selectedDates || this.selectedDates.length === 0) {
            return;
        }
        if (value === null || value === undefined) {
            this.selectedDates = this.selection === CalendarSelection.SINGLE ? null : [];
            this.rangeStarted = false;
            this._onChangeCallback(this.selectedDates);
            return;
        }
        switch (this.selection) {
            case CalendarSelection.SINGLE:
                this.deselectSingle(value);
                break;
            case CalendarSelection.MULTI:
                this.deselectMultiple(value);
                break;
            case CalendarSelection.RANGE:
                this.deselectRange(value);
                break;
        }
    }
    /**
     * @hidden
     */
    selectDateFromClient(value) {
        switch (this.selection) {
            case CalendarSelection.SINGLE:
            case CalendarSelection.MULTI:
                this.selectDate(value);
                break;
            case CalendarSelection.RANGE:
                this.selectRange(value, true);
                break;
        }
    }
    /**
     * @hidden
     */
    initFormatters() {
        this.formatterDay = new Intl.DateTimeFormat(this._locale, { day: this._formatOptions.day });
        this.formatterWeekday = new Intl.DateTimeFormat(this._locale, { weekday: this._formatOptions.weekday });
        this.formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month });
        this.formatterYear = new Intl.DateTimeFormat(this._locale, { year: this._formatOptions.year });
        this.formatterMonthday = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month, day: this._formatOptions.day });
    }
    /**
     * @hidden
     */
    getDateOnly(date) {
        return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }
    /**
     * @hidden
     */
    getDateOnlyInMs(date) {
        return this.getDateOnly(date).getTime();
    }
    /**
     * @hidden
     */
    generateDateRange(start, end) {
        const result = [];
        start = this.getDateOnly(start);
        end = this.getDateOnly(end);
        while (start.getTime() < end.getTime()) {
            start = this.calendarModel.timedelta(start, 'day', 1);
            result.push(start);
        }
        return result;
    }
    /**
     * Performs a single selection.
     *
     * @hidden
     */
    selectSingle(value) {
        this.selectedDates = this.getDateOnly(value);
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * Performs a multiple selection
     *
     * @hidden
     */
    selectMultiple(value) {
        if (Array.isArray(value)) {
            const newDates = value.map(v => this.getDateOnly(v).getTime());
            const selDates = this.selectedDates.map(v => this.getDateOnly(v).getTime());
            if (JSON.stringify(newDates) === JSON.stringify(selDates)) {
                return;
            }
            this.selectedDates = Array.from(new Set([...newDates, ...selDates])).map(v => new Date(v));
        }
        else {
            const valueDateOnly = this.getDateOnly(value);
            const newSelection = [];
            if (this.selectedDates.every((date) => date.getTime() !== valueDateOnly.getTime())) {
                newSelection.push(valueDateOnly);
            }
            else {
                this.selectedDates = this.selectedDates.filter((date) => date.getTime() !== valueDateOnly.getTime());
            }
            if (newSelection.length > 0) {
                this.selectedDates = this.selectedDates.concat(newSelection);
            }
        }
        this.selectedDates = this.selectedDates.filter(d => !this.isDateDisabled(d));
        this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * @hidden
     */
    selectRange(value, excludeDisabledDates = false) {
        let start;
        let end;
        if (Array.isArray(value)) {
            // this.rangeStarted = false;
            value.sort((a, b) => a.valueOf() - b.valueOf());
            start = this.getDateOnly(value[0]);
            end = this.getDateOnly(value[value.length - 1]);
            this.selectedDates = [start, ...this.generateDateRange(start, end)];
        }
        else {
            if (!this.rangeStarted) {
                this.rangeStarted = true;
                this.selectedDates = [value];
            }
            else {
                this.rangeStarted = false;
                if (this.selectedDates[0].getTime() === value.getTime()) {
                    this.selectedDates = [];
                    this._onChangeCallback(this.selectedDates);
                    return;
                }
                this.selectedDates.push(value);
                this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
                start = this.selectedDates.shift();
                end = this.selectedDates.pop();
                this.selectedDates = [start, ...this.generateDateRange(start, end)];
            }
        }
        if (excludeDisabledDates) {
            this.selectedDates = this.selectedDates.filter(d => !this.isDateDisabled(d));
        }
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * Performs a single deselection.
     *
     * @hidden
     */
    deselectSingle(value) {
        if (this.selectedDates !== null &&
            this.getDateOnlyInMs(value) === this.getDateOnlyInMs(this.selectedDates)) {
            this.selectedDates = null;
            this._onChangeCallback(this.selectedDates);
        }
    }
    /**
     * Performs a multiple deselection.
     *
     * @hidden
     */
    deselectMultiple(value) {
        value = value.filter(v => v !== null);
        const selectedDatesCount = this.selectedDates.length;
        const datesInMsToDeselect = new Set(value.map(v => this.getDateOnlyInMs(v)));
        for (let i = this.selectedDates.length - 1; i >= 0; i--) {
            if (datesInMsToDeselect.has(this.getDateOnlyInMs(this.selectedDates[i]))) {
                this.selectedDates.splice(i, 1);
            }
        }
        if (this.selectedDates.length !== selectedDatesCount) {
            this._onChangeCallback(this.selectedDates);
        }
    }
    /**
     * Performs a range deselection.
     *
     * @hidden
     */
    deselectRange(value) {
        value = value.filter(v => v !== null);
        if (value.length < 1) {
            return;
        }
        value.sort((a, b) => a.valueOf() - b.valueOf());
        const valueStart = this.getDateOnlyInMs(value[0]);
        const valueEnd = this.getDateOnlyInMs(value[value.length - 1]);
        this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
        const selectedDatesStart = this.getDateOnlyInMs(this.selectedDates[0]);
        const selectedDatesEnd = this.getDateOnlyInMs(this.selectedDates[this.selectedDates.length - 1]);
        if (!(valueEnd < selectedDatesStart) && !(valueStart > selectedDatesEnd)) {
            this.selectedDates = [];
            this.rangeStarted = false;
            this._onChangeCallback(this.selectedDates);
        }
    }
}
IgxCalendarBaseDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarBase]',
            },] }
];
IgxCalendarBaseDirective.ctorParameters = () => [];
IgxCalendarBaseDirective.propDecorators = {
    hideOutsideDays: [{ type: Input }],
    selected: [{ type: Output }],
    viewDateChanged: [{ type: Output }],
    activeViewChanged: [{ type: Output }],
    resourceStrings: [{ type: Input }],
    weekStart: [{ type: Input }],
    locale: [{ type: Input }],
    formatOptions: [{ type: Input }],
    formatViews: [{ type: Input }],
    selection: [{ type: Input }],
    value: [{ type: Input }],
    viewDate: [{ type: Input }],
    disabledDates: [{ type: Input }],
    specialDates: [{ type: Input }]
};

/**
 * This file contains all the directives used by the @link IgxCalendarComponent.
 * Except for the directives which are used for templating the calendar itself
 * you should generally not use them directly.
 *
 * @preferred
 */
/**
 * @hidden
 */
class IgxCalendarYearDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.yearSelection = new EventEmitter();
    }
    get defaultCSS() {
        return !this.isCurrentYear;
    }
    get currentCSS() {
        return this.isCurrentYear;
    }
    get role() {
        return this.isCurrentYear ? 'spinbutton' : null;
    }
    get valuenow() {
        return this.isCurrentYear ? this.date.getFullYear() : null;
    }
    get tabIndex() {
        return this.isCurrentYear ? 0 : -1;
    }
    get isCurrentYear() {
        return this.date.getFullYear() === this.value.getFullYear();
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    onClick() {
        this.yearSelection.emit(this.value);
    }
}
IgxCalendarYearDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarYear]'
            },] }
];
IgxCalendarYearDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxCalendarYearDirective.propDecorators = {
    value: [{ type: Input, args: ['igxCalendarYear',] }],
    date: [{ type: Input }],
    yearSelection: [{ type: Output }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-calendar__year',] }],
    currentCSS: [{ type: HostBinding, args: ['class.igx-calendar__year--current',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    valuenow: [{ type: HostBinding, args: ['attr.aria-valuenow',] }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
class IgxCalendarMonthDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.monthSelection = new EventEmitter();
    }
    get defaultCSS() {
        return !this.isCurrentMonth;
    }
    get currentCSS() {
        return this.isCurrentMonth;
    }
    get isCurrentMonth() {
        return this.date.getMonth() === this.value.getMonth();
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    onClick() {
        const date = new Date(this.value.getFullYear(), this.value.getMonth(), this.date.getDate());
        this.monthSelection.emit(date);
    }
}
IgxCalendarMonthDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarMonth]'
            },] }
];
IgxCalendarMonthDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxCalendarMonthDirective.propDecorators = {
    value: [{ type: Input, args: ['igxCalendarMonth',] }],
    date: [{ type: Input }],
    index: [{ type: Input }],
    monthSelection: [{ type: Output }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-calendar__month',] }],
    currentCSS: [{ type: HostBinding, args: ['class.igx-calendar__month--current',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
/**
 * @hidden
 */
class IgxCalendarHeaderTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCalendarHeaderTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarHeader]'
            },] }
];
IgxCalendarHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
class IgxCalendarSubheaderTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCalendarSubheaderTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarSubheader]'
            },] }
];
IgxCalendarSubheaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
class IgxCalendarScrollMonthDirective {
    constructor(element, zone) {
        this.element = element;
        this.zone = zone;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
    }
    /**
     * @hidden
     */
    onMouseDown() {
        this.startScroll();
    }
    /**
     * @hidden
     */
    onMouseUp(event) {
        this.stopScroll(event);
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        fromEvent(this.element.nativeElement, 'keyup').pipe(debounce(() => interval(100)), takeUntil(this.destroy$)).subscribe((event) => {
            this.stopScroll(event);
        });
        this.zone.runOutsideAngular(() => {
            fromEvent(this.element.nativeElement, 'keydown').pipe(tap((event) => {
                if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }), debounce(() => interval(100)), takeUntil(this.destroy$)).subscribe((event) => {
                if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                    this.zone.run(() => this.startScroll(true));
                }
            });
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
}
IgxCalendarScrollMonthDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarScrollMonth]'
            },] }
];
IgxCalendarScrollMonthDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
IgxCalendarScrollMonthDirective.propDecorators = {
    startScroll: [{ type: Input }],
    stopScroll: [{ type: Input }],
    onMouseDown: [{ type: HostListener, args: ['mousedown',] }],
    onMouseUp: [{ type: HostListener, args: ['mouseup', ['$event'],] }]
};

const IgxCalendarView = mkenum({
    Month: 'month',
    Year: 'year',
    Decade: 'decade'
});
/**
 * @hidden
 */
var CalendarView;
(function (CalendarView) {
    CalendarView[CalendarView["DEFAULT"] = 0] = "DEFAULT";
    CalendarView[CalendarView["YEAR"] = 1] = "YEAR";
    CalendarView[CalendarView["DECADE"] = 2] = "DECADE";
})(CalendarView || (CalendarView = {}));
class IgxMonthPickerBaseDirective extends IgxCalendarBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Holds month view index we are operating on.
         */
        this.activeViewIdx = 0;
        /**
         * @hidden
         */
        this._activeView = IgxCalendarView.Month;
    }
    /**
     * Gets the current active view.
     * ```typescript
     * this.activeView = calendar.activeView;
     * ```
     */
    get activeView() {
        return this._activeView;
    }
    /**
     * Sets the current active view.
     * ```html
     * <igx-calendar [activeView]="year" #calendar></igx-calendar>
     * ```
     * ```typescript
     * calendar.activeView = IgxCalendarView.YEAR;
     * ```
     */
    set activeView(val) {
        this._activeView = val;
    }
    /**
     * @hidden
     */
    get isDefaultView() {
        return this._activeView === CalendarView.DEFAULT || this._activeView === IgxCalendarView.Month;
    }
    /**
     * @hidden
     */
    get isDecadeView() {
        return this._activeView === CalendarView.DECADE || this._activeView === IgxCalendarView.Decade;
    }
    /**
     * @hidden
     */
    changeYear(event) {
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
        this.activeView = IgxCalendarView.Month;
        requestAnimationFrame(() => {
            if (this.yearsBtns && this.yearsBtns.length) {
                this.yearsBtns.find((e, idx) => idx === this.activeViewIdx).nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     */
    activeViewDecade(activeViewIdx = 0) {
        this.activeView = IgxCalendarView.Decade;
        this.activeViewIdx = activeViewIdx;
    }
    /**
     * @hidden
     */
    activeViewDecadeKB(event, activeViewIdx = 0) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            this.activeViewDecade(activeViewIdx);
        }
    }
    /**
     * Returns the locale representation of the year in the year view if enabled,
     * otherwise returns the default `Date.getFullYear()` value.
     *
     * @hidden
     */
    formattedYear(value) {
        if (this.formatViews.year) {
            return this.formatterYear.format(value);
        }
        return `${value.getFullYear()}`;
    }
}
IgxMonthPickerBaseDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxMonthPickerBase]'
            },] }
];
IgxMonthPickerBaseDirective.propDecorators = {
    yearsBtns: [{ type: ViewChildren, args: ['yearsBtn',] }],
    activeView: [{ type: Input }]
};

let NEXT_ID$a = 0;
class IgxMonthsViewComponent {
    constructor(el) {
        this.el = el;
        /**
         * Sets/gets the `id` of the months view.
         * If not set, the `id` will have value `"igx-months-view-0"`.
         * ```html
         * <igx-months-view id="my-months-view"></igx-months-view>
         * ```
         * ```typescript
         * let monthsViewId =  this.monthsView.id;
         * ```
         *
         * @memberof IgxMonthsViewComponent
         */
        this.id = `igx-months-view-${NEXT_ID$a++}`;
        /**
         * Gets/sets whether the view should be rendered
         * according to the locale and monthFormat, if any.
         */
        this.formatView = true;
        /**
         * Emits an event when a selection is made in the months view.
         * Provides reference the `date` property in the `IgxMonthsViewComponent`.
         * ```html
         * <igx-months-view (selected)="onSelection($event)"></igx-months-view>
         * ```
         *
         * @memberof IgxMonthsViewComponent
         */
        this.selected = new EventEmitter();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        this._date = new Date();
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._monthFormat = 'short';
        /**
         * @hidden
         */
        this._onTouchedCallback = noop;
        /**
         * @hidden
         */
        this._onChangeCallback = noop;
        this.initMonthFormatter();
        this._calendarModel = new Calendar();
    }
    /**
     * Gets/sets the selected date of the months view.
     * By default it is the current date.
     * ```html
     * <igx-months-view [date]="myDate"></igx-months-view>
     * ```
     * ```typescript
     * let date =  this.monthsView.date;
     * ```
     *
     * @memberof IgxMonthsViewComponent
     */
    set date(value) {
        if (!(value instanceof Date)) {
            return;
        }
        this._date = value;
        this.activeMonth = this.date.getMonth();
    }
    get date() {
        return this._date;
    }
    /**
     * Gets the month format option of the months view.
     * ```typescript
     * let monthFormat = this.monthsView.monthFormat.
     * ```
     */
    get monthFormat() {
        return this._monthFormat;
    }
    /**
     * Sets the month format option of the months view.
     * ```html
     * <igx-months-view> [monthFormat] = "short'"</igx-months-view>
     * ```
     *
     * @memberof IgxMonthsViewComponent
     */
    set monthFormat(value) {
        this._monthFormat = value;
        this.initMonthFormatter();
    }
    /**
     * Gets the `locale` of the months view.
     * Default value is `"en"`.
     * ```typescript
     * let locale =  this.monthsView.locale;
     * ```
     *
     * @memberof IgxMonthsViewComponent
     */
    get locale() {
        return this._locale;
    }
    /**
     * Sets the `locale` of the months view.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     * ```html
     * <igx-months-view [locale]="de"></igx-months-view>
     * ```
     *
     * @memberof IgxMonthsViewComponent
     */
    set locale(value) {
        this._locale = value;
        this.initMonthFormatter();
    }
    /**
     * Returns an array of date objects which are then used to
     * properly render the month names.
     *
     * Used in the template of the component
     *
     * @hidden
     */
    get months() {
        let start = new Date(this.date.getFullYear(), 0, 1);
        const result = [];
        for (let i = 0; i < 12; i++) {
            result.push(start);
            start = this._calendarModel.timedelta(start, 'month', 1);
        }
        return result;
    }
    /**
     * @hidden
     */
    onKeydownArrowUp(event) {
        event.preventDefault();
        event.stopPropagation();
        const node = this.monthsRef.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        const months = this.monthsRef.toArray();
        const nodeRect = node.nativeElement.getBoundingClientRect();
        for (let index = months.indexOf(node) - 1; index >= 0; index--) {
            const nextNodeRect = months[index].nativeElement.getBoundingClientRect();
            const tolerance = 6;
            if (nodeRect.top !== nextNodeRect.top && (nextNodeRect.left - nodeRect.left) < tolerance) {
                const month = months[index];
                month.nativeElement.focus();
                this.activeMonth = month.value.getMonth();
                break;
            }
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        const node = this.monthsRef.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        const months = this.monthsRef.toArray();
        const nodeRect = node.nativeElement.getBoundingClientRect();
        for (let index = months.indexOf(node) + 1; index < months.length; index++) {
            const nextNodeRect = months[index].nativeElement.getBoundingClientRect();
            const tolerance = 6;
            if (nextNodeRect.top !== nodeRect.top && (nodeRect.left - nextNodeRect.left) < tolerance) {
                const month = months[index];
                month.nativeElement.focus();
                this.activeMonth = month.value.getMonth();
                break;
            }
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowRight(event) {
        event.preventDefault();
        event.stopPropagation();
        const node = this.monthsRef.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        const months = this.monthsRef.toArray();
        if (months.indexOf(node) + 1 < months.length) {
            const month = months[months.indexOf(node) + 1];
            this.activeMonth = month.value.getMonth();
            month.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowLeft(event) {
        event.preventDefault();
        event.stopPropagation();
        const node = this.monthsRef.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        const months = this.monthsRef.toArray();
        if (months.indexOf(node) - 1 >= 0) {
            const month = months[months.indexOf(node) - 1];
            this.activeMonth = month.value.getMonth();
            month.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onKeydownHome(event) {
        event.preventDefault();
        event.stopPropagation();
        const month = this.monthsRef.toArray()[0];
        this.activeMonth = month.value.getMonth();
        month.nativeElement.focus();
    }
    /**
     * @hidden
     */
    onKeydownEnd(event) {
        event.preventDefault();
        event.stopPropagation();
        const months = this.monthsRef.toArray();
        const month = months[months.length - 1];
        this.activeMonth = month.value.getMonth();
        month.nativeElement.focus();
    }
    /**
     * @hidden
     */
    onKeydownEnter(event) {
        const value = this.monthsRef.find((date) => date.nativeElement === event.target).value;
        this.date = new Date(value.getFullYear(), value.getMonth(), this.date.getDate());
        this.activeMonth = this.date.getMonth();
        this.selected.emit(this.date);
        this._onChangeCallback(this.date);
    }
    resetActiveMonth() {
        this.activeMonth = this.date.getMonth();
    }
    /**
     * Returns the locale representation of the month in the months view.
     *
     * @hidden
     */
    formattedMonth(value) {
        if (this.formatView) {
            return this._formatterMonth.format(value);
        }
        return `${value.getMonth()}`;
    }
    /**
     * @hidden
     */
    selectMonth(event) {
        this.selected.emit(event);
        this.date = event;
        this.activeMonth = this.date.getMonth();
        this._onChangeCallback(this.date);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        if (value) {
            this.date = value;
        }
    }
    /**
     * @hidden
     */
    monthTracker(index, item) {
        return `${item.getMonth()}}`;
    }
    /**
     * @hidden
     */
    initMonthFormatter() {
        this._formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this.monthFormat });
    }
}
IgxMonthsViewComponent.decorators = [
    { type: Component, args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxMonthsViewComponent, multi: true }],
                selector: 'igx-months-view',
                template: "<div class=\"igx-calendar__body\">\n    <div  class=\"igx-calendar__body-row--wrap\">\n        <span\n            role=\"button\"\n            [attr.aria-label]=\"month | date: 'LLLL'\"\n            [igxCalendarMonth]=\"month\"\n            [date]=\"date\"\n            [attr.tabindex]=\"activeMonth === month.getMonth() ? 0 : -1\"\n            (monthSelection)=\"selectMonth($event)\" [index]=\"i\"\n            *ngFor=\"let month of months; index as i; trackBy: monthTracker\">\n            {{ formattedMonth(month) | titlecase }}\n        </span>\n    </div>\n</div>\n\n"
            },] }
];
IgxMonthsViewComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxMonthsViewComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    date: [{ type: Input }],
    monthFormat: [{ type: Input }],
    locale: [{ type: Input }],
    formatView: [{ type: Input }],
    selected: [{ type: Output }],
    styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
    monthsRef: [{ type: ViewChildren, args: [IgxCalendarMonthDirective, { read: IgxCalendarMonthDirective },] }],
    onKeydownArrowUp: [{ type: HostListener, args: ['keydown.arrowup', ['$event'],] }],
    onKeydownArrowDown: [{ type: HostListener, args: ['keydown.arrowdown', ['$event'],] }],
    onKeydownArrowRight: [{ type: HostListener, args: ['keydown.arrowright', ['$event'],] }],
    onKeydownArrowLeft: [{ type: HostListener, args: ['keydown.arrowleft', ['$event'],] }],
    onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }],
    onKeydownEnter: [{ type: HostListener, args: ['keydown.enter', ['$event'],] }],
    resetActiveMonth: [{ type: HostListener, args: ['focusout',] }]
};

class CalendarHammerConfig extends HammerGestureConfig {
    constructor() {
        super(...arguments);
        this.overrides = {
            pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
        };
    }
}
CalendarHammerConfig.decorators = [
    { type: Injectable }
];
class IgxYearsViewComponent {
    constructor(el) {
        this.el = el;
        /**
         * Emits an event when a selection is made in the years view.
         * Provides reference the `date` property in the `IgxYearsViewComponent`.
         * ```html
         * <igx-years-view (selected)="onSelection($event)"></igx-years-view>
         * ```
         *
         * @memberof IgxYearsViewComponent
         */
        this.selected = new EventEmitter();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._yearFormat = 'numeric';
        /**
         * @hidden
         */
        this._date = new Date();
        /**
         * @hidden
         */
        this._onTouchedCallback = noop;
        /**
         * @hidden
         */
        this._onChangeCallback = noop;
        this.initYearFormatter();
        this._calendarModel = new Calendar();
    }
    /**
     * Gets/sets the selected date of the years view.
     * By default it is the current date.
     * ```html
     * <igx-years-view [date]="myDate"></igx-years-view>
     * ```
     * ```typescript
     * let date =  this.yearsView.date;
     * ```
     *
     * @memberof IgxYearsViewComponent
     */
    get date() {
        return this._date;
    }
    set date(value) {
        if (!(value instanceof Date)) {
            return;
        }
        this._date = value;
    }
    /**
     * Gets the year format option of the years view.
     * ```typescript
     * let yearFormat = this.yearsView.yearFormat.
     * ```
     */
    get yearFormat() {
        return this._yearFormat;
    }
    /**
     * Sets the year format option of the years view.
     * ```html
     * <igx-years-view [yearFormat]="numeric"></igx-years-view>
     * ```
     *
     * @memberof IgxYearsViewComponent
     */
    set yearFormat(value) {
        this._yearFormat = value;
        this.initYearFormatter();
    }
    /**
     * Gets the `locale` of the years view.
     * Default value is `"en"`.
     * ```typescript
     * let locale =  this.yearsView.locale;
     * ```
     *
     * @memberof IgxYearsViewComponent
     */
    get locale() {
        return this._locale;
    }
    /**
     * Sets the `locale` of the years view.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     * ```html
     * <igx-years-view [locale]="de"></igx-years-view>
     * ```
     *
     * @memberof IgxYearsViewComponent
     */
    set locale(value) {
        this._locale = value;
        this.initYearFormatter();
    }
    /**
     * Returns an array of date objects which are then used to properly
     * render the years.
     *
     * Used in the template of the component.
     *
     * @hidden
     */
    get decade() {
        const result = [];
        const start = this.date.getFullYear() - 3;
        const end = this.date.getFullYear() + 4;
        for (const year of range(start, end)) {
            result.push(new Date(year, this.date.getMonth(), this.date.getDate()));
        }
        return result;
    }
    /**
     * @hidden
     */
    onKeydownArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        this.generateYearRange(1);
        this.calendarDir.find(date => date.isCurrentYear).nativeElement.nextElementSibling.focus();
    }
    /**
     * @hidden
     */
    onKeydownArrowUp(event) {
        event.preventDefault();
        event.stopPropagation();
        this.generateYearRange(-1);
        this.calendarDir.find(date => date.isCurrentYear).nativeElement.previousElementSibling.focus();
    }
    /**
     * @hidden
     */
    onKeydownEnter() {
        this.selected.emit(this.date);
        this._onChangeCallback(this.date);
    }
    /**
     * Returns the locale representation of the year in the years view.
     *
     * @hidden
     */
    formattedYear(value) {
        if (this.formatView) {
            return this._formatterYear.format(value);
        }
        return `${value.getFullYear()}`;
    }
    /**
     * @hidden
     */
    selectYear(event) {
        this.date = event;
        this.selected.emit(this.date);
        this._onChangeCallback(this.date);
    }
    /**
     * @hidden
     */
    scroll(event) {
        event.preventDefault();
        event.stopPropagation();
        const delta = event.deltaY < 0 ? -1 : 1;
        this.generateYearRange(delta);
    }
    /**
     * @hidden
     */
    pan(event) {
        const delta = event.deltaY < 0 ? 1 : -1;
        this.generateYearRange(delta);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    yearTracker(index, item) {
        return `${item.getFullYear()}}`;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        if (value) {
            this.date = value;
        }
    }
    /**
     * @hidden
     */
    initYearFormatter() {
        this._formatterYear = new Intl.DateTimeFormat(this._locale, { year: this.yearFormat });
    }
    /**
     * @hidden
     */
    generateYearRange(delta) {
        const currentYear = new Date().getFullYear();
        if ((delta > 0 && this.date.getFullYear() - currentYear >= 95) ||
            (delta < 0 && currentYear - this.date.getFullYear() >= 95)) {
            return;
        }
        this.date = this._calendarModel.timedelta(this.date, 'year', delta);
    }
}
IgxYearsViewComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxYearsViewComponent,
                        multi: true
                    },
                    {
                        provide: HAMMER_GESTURE_CONFIG,
                        useClass: CalendarHammerConfig
                    }
                ],
                selector: 'igx-years-view',
                template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-column\" (wheel)=\"scroll($event)\" (pan)=\"pan($event)\">\n        <span\n            [igxCalendarYear]=\"year\"\n            [date]=\"date\"\n            (yearSelection)=\"selectYear($event)\"\n            *ngFor=\"let year of decade; trackBy: yearTracker\">\n\n            {{ formattedYear(year) }}\n        </span>\n    </div>\n</div>\n"
            },] }
];
IgxYearsViewComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxYearsViewComponent.propDecorators = {
    formatView: [{ type: Input }],
    selected: [{ type: Output }],
    styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
    calendarDir: [{ type: ViewChildren, args: [IgxCalendarYearDirective, { read: IgxCalendarYearDirective },] }],
    date: [{ type: Input }],
    yearFormat: [{ type: Input }],
    locale: [{ type: Input }],
    onKeydownArrowDown: [{ type: HostListener, args: ['keydown.arrowdown', ['$event'],] }],
    onKeydownArrowUp: [{ type: HostListener, args: ['keydown.arrowup', ['$event'],] }],
    onKeydownEnter: [{ type: HostListener, args: ['keydown.enter',] }]
};

/**
 * @hidden
 */
class IgxDayItemComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.hideOutsideDays = false;
        this.isLastInRange = false;
        this.isFirstInRange = false;
        this.isWithinRange = false;
        this.dateSelection = new EventEmitter();
        this._selected = false;
    }
    /**
     * Returns boolean indicating if the day is selected
     *
     */
    get selected() {
        return this._selected;
    }
    /**
     * Selects the day
     */
    set selected(value) {
        this._selected = value;
    }
    get isCurrentMonth() {
        return this.date.isCurrentMonth;
    }
    get isPreviousMonth() {
        return this.date.isPrevMonth;
    }
    get isNextMonth() {
        return this.date.isNextMonth;
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    get isSelectedCSS() {
        return (!this.isDisabled && this.selected);
    }
    get isInactive() {
        return this.date.isNextMonth || this.date.isPrevMonth;
    }
    get isHidden() {
        return this.hideOutsideDays && this.isInactive;
    }
    get isToday() {
        const today = new Date(Date.now());
        const date = this.date.date;
        if (date.getDate() === today.getDate()) {
            this.nativeElement.setAttribute('aria-current', 'date');
        }
        return (date.getFullYear() === today.getFullYear() &&
            date.getMonth() === today.getMonth() &&
            date.getDate() === today.getDate());
    }
    get isWeekend() {
        const day = this.date.date.getDay();
        return day === 0 || day === 6;
    }
    get isDisabled() {
        if (this.disabledDates === null) {
            return false;
        }
        return isDateInRanges(this.date.date, this.disabledDates);
    }
    get isOutOfRange() {
        if (!this.outOfRangeDates) {
            return false;
        }
        return isDateInRanges(this.date.date, this.outOfRangeDates);
    }
    get isFocusable() {
        return this.isCurrentMonth && !this.isHidden && !this.isDisabled && !this.isOutOfRange;
    }
    get isWithinRangeCSS() {
        return !this.isSingleSelection && this.isWithinRange;
    }
    get isSpecial() {
        if (this.specialDates === null) {
            return false;
        }
        return isDateInRanges(this.date.date, this.specialDates);
    }
    get defaultCSS() {
        return this.date.isCurrentMonth && !(this.isWeekend && this.selected);
    }
    get isDisabledCSS() {
        return this.isHidden || this.isDisabled || this.isOutOfRange;
    }
    get isSingleSelection() {
        return this.selection !== CalendarSelection.RANGE;
    }
    onSelect(event) {
        event.stopPropagation();
        this.dateSelection.emit(this.date);
    }
}
IgxDayItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-day-item',
                template: "<span aria-hidden=\"true\" class=\"igx-calendar__date-content\">\n    <ng-content></ng-content>\n</span>\n"
            },] }
];
IgxDayItemComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxDayItemComponent.propDecorators = {
    date: [{ type: Input }],
    selection: [{ type: Input }],
    selected: [{ type: Input }],
    disabledDates: [{ type: Input }],
    outOfRangeDates: [{ type: Input }],
    specialDates: [{ type: Input }],
    hideOutsideDays: [{ type: Input }],
    isLastInRange: [{ type: Input }, { type: HostBinding, args: ['class.igx-calendar__date--last',] }],
    isFirstInRange: [{ type: Input }, { type: HostBinding, args: ['class.igx-calendar__date--first',] }],
    isWithinRange: [{ type: Input }],
    dateSelection: [{ type: Output }],
    isSelectedCSS: [{ type: HostBinding, args: ['class.igx-calendar__date--selected',] }],
    isInactive: [{ type: HostBinding, args: ['class.igx-calendar__date--inactive',] }],
    isHidden: [{ type: HostBinding, args: ['class.igx-calendar__date--hidden',] }],
    isToday: [{ type: HostBinding, args: ['class.igx-calendar__date--current',] }],
    isWeekend: [{ type: HostBinding, args: ['class.igx-calendar__date--weekend',] }],
    isWithinRangeCSS: [{ type: HostBinding, args: ['class.igx-calendar__date--range',] }],
    isSpecial: [{ type: HostBinding, args: ['class.igx-calendar__date--special',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-calendar__date',] }],
    isDisabledCSS: [{ type: HostBinding, args: ['class.igx-calendar__date--disabled',] }],
    isSingleSelection: [{ type: HostBinding, args: ['class.igx-calendar__date--single',] }],
    onSelect: [{ type: HostListener, args: ['click', ['$event'],] }, { type: HostListener, args: ['keydown.enter', ['$event'],] }]
};

var Direction;
(function (Direction) {
    Direction["Up"] = "ArrowUp";
    Direction["Down"] = "ArrowDown";
    Direction["Left"] = "ArrowLeft";
    Direction["Right"] = "ArrowRight";
})(Direction || (Direction = {}));
const ARROW = 'Arrow';
/** @hidden */
class IgxDaysViewNavigationService {
    /**
     * Implements kb navigation in all MoveDirections. nextDate and nextMonthView naming convention is used for both previous/next
     *
     * @hidden
     */
    focusNextDate(target, key, nextView = false) {
        if (target.childElementCount === 0) {
            target = target.parentElement;
        }
        if (key.indexOf('Arrow') === -1) {
            key = ARROW.concat(key);
        }
        const monthView = this.monthView;
        const node = monthView.dates.find((date) => date.nativeElement === target);
        let dates = monthView.dates.toArray();
        let day;
        let step;
        let i;
        let nextDate;
        const index = dates.indexOf(node);
        if (!node) {
            return;
        }
        // focus item in current month
        switch (key) {
            case Direction.Left: {
                step = -1;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i > 0; i--) {
                    day = nextView ? dates[i] : dates[i - 1];
                    nextDate = day.date.date;
                    if (day.date.isPrevMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
            case Direction.Right: {
                step = 1;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i < dates.length - 1; i++) {
                    day = nextView ? dates[i] : dates[i + 1];
                    nextDate = day.date.date;
                    if (day.date.isNextMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
            case Direction.Up: {
                step = -7;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i - 7 > -1; i -= 7) {
                    day = nextView ? dates[i] : dates[i - 7];
                    nextDate = day.date.date;
                    if (day.date.isPrevMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
            case Direction.Down: {
                step = 7;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i + 7 < 42; i += 7) {
                    day = nextView ? dates[i] : dates[i + 7];
                    nextDate = day.date.date;
                    if (day.date.isNextMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
        }
        // focus item in prev/next visible month
        const nextMonthView = step > 0 ? monthView.nextMonthView : monthView.prevMonthView;
        if (nextMonthView) {
            dates = nextMonthView.dates.toArray();
            day = dates.find((item) => item.date.date.getTime() === nextDate.getTime());
            if (day && day.isFocusable) {
                day.nativeElement.focus();
                return;
            }
            nextMonthView.daysNavService.focusNextDate(day.nativeElement, key);
        }
        // if iterating in the visible prev/next moths above found a day that is not focusable, ie is disabled, hidden, etc
        // then it is needed to recalculate the next day, which is going to be part of the prev/next months
        if (day && !day.isFocusable) {
            day = dates[i + step];
            if (!day) {
                nextDate = this.timedelta(node.date.date, step + i - index);
            }
        }
        // focus item in prev/next month, which is currently out of view
        let dayIsNextMonth; // determine what we need to check for next date - if it belongs to prev or next month
        if (day) {
            dayIsNextMonth = step > 0 ? day.date.isNextMonth : day.date.isPrevMonth;
        }
        if (monthView.changeDaysView && !nextMonthView && ((day && dayIsNextMonth) || !day)) {
            const monthAction = step > 0 ? ScrollMonth.NEXT : ScrollMonth.PREV;
            monthView.viewChanging.emit({ monthAction, key, nextDate });
        }
    }
    /**
     * Focuses first focusable day in the month. Will go to next visible month, if no day in the first month is focusable
     *
     * @hidden
     */
    focusHomeDate() {
        let monthView = this.monthView;
        while (!this.focusFirstDay(monthView) && monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
        }
    }
    /**
     * Focuses last focusable day in the month. Will go to previous visible month, if no day in the first month is focusable
     *
     * @hidden
     */
    focusEndDate() {
        let monthView = this.monthView;
        while (!this.focusLastDay(monthView) && monthView.prevMonthView) {
            monthView = monthView.prevMonthView;
        }
    }
    timedelta(date, units) {
        const ret = new Date(date);
        ret.setDate(ret.getDate() + units);
        return ret;
    }
    focusFirstDay(monthView) {
        const dates = monthView.dates.filter(d => d.isCurrentMonth);
        for (const date of dates) {
            if (date.isFocusable) {
                date.nativeElement.focus();
                return true;
            }
        }
        return false;
    }
    focusLastDay(monthView) {
        const dates = monthView.dates.filter(d => d.isCurrentMonth);
        for (let i = dates.length - 1; i >= 0; i--) {
            if (dates[i].isFocusable) {
                dates[i].nativeElement.focus();
                return true;
            }
        }
        return false;
    }
}
IgxDaysViewNavigationService.decorators = [
    { type: Injectable }
];

let NEXT_ID$b = 0;
class IgxDaysViewComponent extends IgxCalendarBaseDirective {
    /**
     * @hidden
     */
    constructor(daysNavService) {
        super();
        this.daysNavService = daysNavService;
        /**
         * Sets/gets the `id` of the days view.
         * If not set, the `id` will have value `"igx-days-view-0"`.
         * ```html
         * <igx-days-view id="my-days-view"></igx-days-view>
         * ```
         * ```typescript
         * let daysViewId =  this.daysView.id;
         * ```
         */
        this.id = `igx-days-view-${NEXT_ID$b++}`;
        /**
         * @hidden
         */
        this.changeDaysView = false;
        /**
         * @hidden
         */
        this.dateSelection = new EventEmitter();
        /**
         * @hidden
         */
        this.viewChanging = new EventEmitter();
        /**
         * @hidden
         */
        this.activeDateChange = new EventEmitter();
        /**
         * @hidden
         */
        this.monthsViewBlur = new EventEmitter();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /** @hidden */
        this.shouldResetDate = true;
    }
    /**
     * @hidden
     * @internal
     */
    set activeDate(value) {
        this._activeDate = value;
        this.activeDateChange.emit(this._activeDate);
    }
    get activeDate() {
        return this._activeDate ? this._activeDate : this.viewDate.toLocaleDateString();
    }
    /**
     * @hidden
     * @internal
     */
    resetActiveMonth() {
        if (this.shouldResetDate) {
            const date = this.dates.find(day => day.selected && day.isCurrentMonth) ||
                this.dates.find(day => day.isToday && day.isCurrentMonth) ||
                this.dates.find(d => d.isFocusable);
            if (date) {
                this.activeDate = date.date.date.toLocaleDateString();
            }
            this.monthsViewBlur.emit();
        }
        this.shouldResetDate = true;
    }
    /**
     * @hidden
     * @internal
     */
    pointerDown() {
        this.shouldResetDate = false;
    }
    /**
     * @hidden
     */
    onKeydownArrow(event) {
        event.preventDefault();
        event.stopPropagation();
        this.shouldResetDate = false;
        this.daysNavService.focusNextDate(event.target, event.key);
    }
    /**
     * @hidden
     */
    onKeydownHome(event) {
        event.preventDefault();
        event.stopPropagation();
        this.shouldResetDate = false;
        this.getFirstMonthView().daysNavService.focusHomeDate();
    }
    /**
     * @hidden
     */
    onKeydownEnd(event) {
        event.preventDefault();
        event.stopPropagation();
        this.shouldResetDate = false;
        this.getLastMonthView().daysNavService.focusEndDate();
    }
    /**
     * @hidden
     */
    get getCalendarMonth() {
        return this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth(), true);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.daysNavService.monthView = this;
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        if (!this.changeDaysView && this.dates) {
            this.disableOutOfRangeDates();
        }
    }
    /**
     * @hidden
     * @internal
     */
    tabIndex(day) {
        return this.activeDate && this.activeDate === day.date.toLocaleDateString() && day.isCurrentMonth ? 0 : -1;
    }
    /**
     * Returns the week number by date
     *
     * @hidden
     */
    getWeekNumber(date) {
        return this.calendarModel.getWeekNumber(date);
    }
    /**
     * Returns the locale representation of the date in the days view.
     *
     * @hidden
     */
    formattedDate(value) {
        if (this.formatViews.day) {
            return this.formatterDay.format(value);
        }
        return `${value.getDate()}`;
    }
    /**
     * @hidden
     */
    generateWeekHeader() {
        const dayNames = [];
        const rv = this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth())[0];
        for (const day of rv) {
            dayNames.push(this.formatterWeekday.format(day.date));
        }
        return dayNames;
    }
    /**
     * @hidden
     */
    rowTracker(index, item) {
        return `${item[index].date.getMonth()}${item[index].date.getDate()}`;
    }
    /**
     * @hidden
     */
    dateTracker(index, item) {
        return `${item.date.getMonth()}--${item.date.getDate()}`;
    }
    /**
     * @hidden
     */
    isCurrentMonth(value) {
        return this.viewDate.getMonth() === value.getMonth();
    }
    /**
     * @hidden
     */
    isCurrentYear(value) {
        return this.viewDate.getFullYear() === value.getFullYear();
    }
    /**
     * @hidden
     */
    isSelected(date) {
        let selectedDates;
        if (this.isDateDisabled(date.date) || !this.value ||
            (Array.isArray(this.value) && this.value.length === 0)) {
            return false;
        }
        if (this.selection === CalendarSelection.SINGLE) {
            selectedDates = this.value;
            return this.getDateOnly(selectedDates).getTime() === date.date.getTime();
        }
        selectedDates = this.value;
        if (this.selection === CalendarSelection.RANGE && selectedDates.length === 1) {
            return this.getDateOnly(selectedDates[0]).getTime() === date.date.getTime();
        }
        if (this.selection === CalendarSelection.MULTI) {
            const start = this.getDateOnly(selectedDates[0]);
            const end = this.getDateOnly(selectedDates[selectedDates.length - 1]);
            if (this.isWithinRange(date.date, false, start, end)) {
                const currentDate = selectedDates.find(element => element.getTime() === date.date.getTime());
                return !!currentDate;
            }
            else {
                return false;
            }
        }
        else {
            return this.isWithinRange(date.date, true);
        }
    }
    /**
     * @hidden
     */
    isLastInRange(date) {
        if (this.isSingleSelection || !this.value) {
            return false;
        }
        const dates = this.value;
        const lastDate = dates[dates.length - 1];
        return isEqual(lastDate, date.date);
    }
    /**
     * @hidden
     */
    isFirstInRange(date) {
        if (this.isSingleSelection || !this.value) {
            return false;
        }
        return isEqual(this.value[0], date.date);
    }
    /**
     * @hidden
     */
    isWithinRange(date, checkForRange, min, max) {
        if (checkForRange && !(Array.isArray(this.value) && this.value.length > 1)) {
            return false;
        }
        min = min ? min : this.value[0];
        max = max ? max : this.value[this.value.length - 1];
        return isDateInRanges(date, [
            {
                type: DateRangeType.Between,
                dateRange: [min, max]
            }
        ]);
    }
    /**
     * @hidden
     */
    focusActiveDate() {
        let date = this.dates.find((d) => d.selected);
        if (!date) {
            date = this.dates.find((d) => d.isToday);
        }
        if (date.isFocusable) {
            date.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    selectDay(event) {
        this.selectDateFromClient(event.date);
        this.dateSelection.emit(event);
        this.selected.emit(this.selectedDates);
    }
    /**
     * @hidden
     */
    getFirstMonthView() {
        let monthView = this;
        while (monthView.prevMonthView) {
            monthView = monthView.prevMonthView;
        }
        return monthView;
    }
    /**
     * @hidden
     */
    disableOutOfRangeDates() {
        const dateRange = [];
        this.dates.toArray().forEach((date) => {
            if (!date.isCurrentMonth) {
                dateRange.push(date.date.date);
            }
        });
        this.outOfRangeDates = [{
                type: DateRangeType.Specific,
                dateRange
            }];
    }
    /**
     * @hidden
     */
    getLastMonthView() {
        let monthView = this;
        while (monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
        }
        return monthView;
    }
    /**
     * @hidden
     */
    get isSingleSelection() {
        return this.selection !== CalendarSelection.RANGE;
    }
}
IgxDaysViewComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxDaysViewComponent
                    },
                    { provide: IgxDaysViewNavigationService, useClass: IgxDaysViewNavigationService }
                ],
                selector: 'igx-days-view',
                template: "<div role=\"row\" class=\"igx-calendar__body-row\">\n    <div role=\"columnheader\" *ngIf=\"showWeekNumbers\" class=\"igx-calendar__label igx-calendar__label--week-number\">\n        <span>Wk</span>\n    </div>\n    <span role=\"columnheader\" [attr.aria-label]=\"dayName\" *ngFor=\"let dayName of generateWeekHeader()\" class=\"igx-calendar__label\">\n        {{ dayName | titlecase }}\n    </span>\n</div>\n\n<div *ngFor=\"let week of getCalendarMonth; last as isLast; index as i; trackBy: rowTracker\"\n     class=\"igx-calendar__body-row\" role=\"row\">\n\n    <div *ngIf=\"showWeekNumbers\" class=\"igx-calendar__date igx-calendar__date--week-number\">\n\n        <span role=\"rowheader\" class=\"igx-calendar__date-content igx-calendar__date-content--week-number\">\n            {{getWeekNumber(week[0].date)}}\n        </span>\n\n    </div>\n\n    <!-- <igx-week-number-item *ngIf=\"showWeekNumbers\">{{getWeekNumber(week[0].date)}}</igx-week-number-item> -->\n    <igx-day-item\n        *ngFor=\"let day of week; trackBy: dateTracker\"\n        [attr.aria-selected]=\"isSelected(day)\"\n        role=\"gridcell\"\n        [attr.aria-disabled]=\"isDateDisabled(day.date)\"\n        [attr.aria-label]=\"isFirstInRange(day) ? day.date.toDateString() + ', ' + resourceStrings.igx_calendar_range_start : isLastInRange(day) ? day.date.toDateString() + ', ' +  resourceStrings.igx_calendar_range_end  : day.date.toDateString()\"\n        [date]=\"day\"\n        [selection]=\"selection\"\n        [selected]=\"isSelected(day)\"\n        [isLastInRange]=\"isLastInRange(day)\"\n        [isFirstInRange]=\"isFirstInRange(day)\"\n        [isWithinRange]=\"isWithinRange(day.date, true)\"\n        [disabledDates]=\"disabledDates\"\n        [specialDates]=\"specialDates\"\n        [outOfRangeDates]=\"outOfRangeDates\"\n        [hideOutsideDays]=\"hideOutsideDays\"\n        [attr.tabindex]=\"tabIndex(day)\"\n        (focus)=\"activeDate = day.date.toLocaleDateString()\"\n        (dateSelection)=\"selectDay($event)\">\n        {{ formattedDate(day.date) }}\n    </igx-day-item>\n</div>\n\n"
            },] }
];
IgxDaysViewComponent.ctorParameters = () => [
    { type: IgxDaysViewNavigationService }
];
IgxDaysViewComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    changeDaysView: [{ type: Input }],
    showWeekNumbers: [{ type: Input }],
    activeDate: [{ type: Input }],
    dateSelection: [{ type: Output }],
    viewChanging: [{ type: Output }],
    activeDateChange: [{ type: Output }],
    monthsViewBlur: [{ type: Output }],
    dates: [{ type: ViewChildren, args: [IgxDayItemComponent, { read: IgxDayItemComponent },] }],
    styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
    resetActiveMonth: [{ type: HostListener, args: ['focusout',] }],
    pointerDown: [{ type: HostListener, args: ['keydown.pagedown',] }, { type: HostListener, args: ['keydown.pageup',] }, { type: HostListener, args: ['keydown.shift.pagedown',] }, { type: HostListener, args: ['keydown.shift.pageup',] }, { type: HostListener, args: ['pointerdown',] }],
    onKeydownArrow: [{ type: HostListener, args: ['keydown.arrowleft', ['$event'],] }, { type: HostListener, args: ['keydown.arrowright', ['$event'],] }, { type: HostListener, args: ['keydown.arrowup', ['$event'],] }, { type: HostListener, args: ['keydown.arrowdown', ['$event'],] }],
    onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }]
};

let NEXT_ID$c = 0;
/**
 * Calendar provides a way to display date information.
 *
 * @igxModule IgxCalendarModule
 *
 * @igxTheme igx-calendar-theme, igx-icon-theme
 *
 * @igxKeywords calendar, datepicker, schedule, date
 *
 * @igxGroup Scheduling
 *
 * @remarks
 * The Ignite UI Calendar provides an easy way to display a calendar and allow users to select dates using single, multiple
 * or range selection.
 *
 * @example:
 * ```html
 * <igx-calendar selection="range"></igx-calendar>
 * ```
 */
class IgxCalendarComponent extends IgxMonthPickerBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Sets/gets the `id` of the calendar.
         *
         * @remarks
         * If not set, the `id` will have value `"igx-calendar-0"`.
         *
         * @example
         * ```html
         * <igx-calendar id="my-first-calendar"></igx-calendar>
         * ```
         * @memberof IgxCalendarComponent
         */
        this.id = `igx-calendar-${NEXT_ID$c++}`;
        /**
         * Sets/gets whether the calendar has header.
         * Default value is `true`.
         *
         * @example
         * ```html
         * <igx-calendar [hasHeader]="false"></igx-calendar>
         * ```
         */
        this.hasHeader = true;
        /**
         * Sets/gets whether the calendar header will be in vertical position.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-calendar [vertical] = "true"></igx-calendar>
         * ```
         */
        this.vertical = false;
        /**
         * Show/hide week numbers
         *
         * @example
         * ```html
         * <igx-calendar [showWeekNumbers]="true"></igx-calendar>
         * ``
         */
        this.showWeekNumbers = false;
        /**
         * Apply the different states for the transitions of animateChange
         *
         * @hidden
         * @internal
         */
        this.animationAction = '';
        /**
         * The default css class applied to the component.
         *
         * @hidden
         * @internal
         */
        this.styleClass = true;
        /**
         * @hidden
         * @internal
         */
        this.activeDate = new Date().toLocaleDateString();
        /**
         * Denote if the calendar view was changed with the keyboard
         *
         * @hidden
         * @internal
         */
        this.isKeydownTrigger = false;
        /**
         * @hidden
         * @internal
         */
        this._monthsViewNumber = 1;
        /**
         * Continious navigation through the previous months
         *
         * @hidden
         * @internal
         */
        this.startPrevMonthScroll = (isKeydownTrigger = false) => {
            this.startMonthScroll$.next();
            this.monthScrollDirection = ScrollMonth.PREV;
            this.animationAction = ScrollMonth.PREV;
            this.previousMonth(isKeydownTrigger);
        };
        /**
         * Continious navigation through the next months
         *
         * @hidden
         * @internal
         */
        this.startNextMonthScroll = (isKeydownTrigger = false) => {
            this.startMonthScroll$.next();
            this.monthScrollDirection = ScrollMonth.NEXT;
            this.animationAction = ScrollMonth.NEXT;
            this.nextMonth(isKeydownTrigger);
        };
        /**
         * Stop continuous navigation
         *
         * @hidden
         * @internal
         */
        this.stopMonthScroll = (event) => {
            event.stopPropagation();
            // generally the scrolling is built on the calendar component
            // and all start/stop scrolling methods are called on the calendar
            // if we change below lines to call stopMonthScroll$ on the calendar instead of on the views,
            // strange bug is introduced --> after changing number of months, continuous scrolling on mouse click does not happen
            this.daysView.stopMonthScroll$.next(true);
            this.daysView.stopMonthScroll$.complete();
            if (this.monthScrollDirection === ScrollMonth.PREV) {
                this.prevMonthBtn.nativeElement.focus();
            }
            else if (this.monthScrollDirection === ScrollMonth.NEXT) {
                this.nextMonthBtn.nativeElement.focus();
            }
            if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                this.resetActiveDate();
            }
            this.monthScrollDirection = ScrollMonth.NONE;
        };
    }
    /**
     * Sets/gets the number of month views displayed.
     * Default value is `1`.
     *
     * @example
     * ```html
     * <igx-calendar [monthsViewNumber]="2"></igx-calendar>
     * ```
     */
    get monthsViewNumber() {
        return this._monthsViewNumber;
    }
    set monthsViewNumber(val) {
        if (val < 1) {
            return;
        }
        this._monthsViewNumber = val;
    }
    /**
     * The default css class applied to the component.
     *
     * @hidden
     * @internal
     */
    get styleVerticalClass() {
        return this.vertical;
    }
    /**
     * Denote if the year view is active.
     *
     * @hidden
     * @internal
     */
    get isYearView() {
        return this.activeView === CalendarView.YEAR || this.activeView === IgxCalendarView.Year;
    }
    /**
     * Gets the header template.
     *
     * @example
     * ```typescript
     * let headerTemplate =  this.calendar.headerTeamplate;
     * ```
     * @memberof IgxCalendarComponent
     */
    get headerTemplate() {
        if (this.headerTemplateDirective) {
            return this.headerTemplateDirective.template;
        }
        return null;
    }
    /**
     * Sets the header template.
     *
     * @example
     * ```html
     * <igx-calendar headerTemplateDirective = "igxCalendarHeader"></igx-calendar>
     * ```
     * @memberof IgxCalendarComponent
     */
    set headerTemplate(directive) {
        this.headerTemplateDirective = directive;
    }
    /**
     * Gets the subheader template.
     *
     * @example
     * ```typescript
     * let subheaderTemplate = this.calendar.subheaderTemplate;
     * ```
     */
    get subheaderTemplate() {
        if (this.subheaderTemplateDirective) {
            return this.subheaderTemplateDirective.template;
        }
        return null;
    }
    /**
     * Sets the subheader template.
     *
     * @example
     * ```html
     * <igx-calendar subheaderTemplate = "igxCalendarSubheader"></igx-calendar>
     * ```
     * @memberof IgxCalendarComponent
     */
    set subheaderTemplate(directive) {
        this.subheaderTemplateDirective = directive;
    }
    /**
     * Gets the context for the template marked with the `igxCalendarHeader` directive.
     *
     * @example
     * ```typescript
     * let headerContext =  this.calendar.headerContext;
     * ```
     */
    get headerContext() {
        const date = this.headerDate;
        return this.generateContext(date);
    }
    /**
     * Gets the context for the template marked with either `igxCalendarSubHeaderMonth`
     * or `igxCalendarSubHeaderYear` directive.
     *
     * @example
     * ```typescript
     * let context =  this.calendar.context;
     * ```
     */
    get context() {
        const date = this.viewDate;
        return this.generateContext(date);
    }
    /**
     * Date displayed in header
     *
     * @hidden
     * @internal
     */
    get headerDate() {
        return this.selectedDates ? this.selectedDates : new Date();
    }
    /**
     * Keyboard navigation of the calendar
     *
     * @hidden
     * @internal
     */
    onKeydownPageDown(event) {
        event.preventDefault();
        if (!this.isDefaultView) {
            return;
        }
        const isPageDown = event.key === 'PageDown';
        const step = isPageDown ? 1 : -1;
        let monthView = this.daysView;
        let activeDate;
        while (!activeDate && monthView) {
            activeDate = monthView.dates.find((date) => date.nativeElement === document.activeElement);
            monthView = monthView.nextMonthView;
        }
        if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            let year = this.nextDate.getFullYear();
            let month = this.nextDate.getMonth() + step;
            if (isPageDown) {
                if (month > 11) {
                    month = 0;
                    year += step;
                }
            }
            else {
                if (month < 0) {
                    month = 11;
                    year += step;
                }
            }
            const range = monthRange(this.nextDate.getFullYear(), month);
            let day = this.nextDate.getDate();
            if (day > range[1]) {
                day = range[1];
            }
            this.nextDate.setDate(day);
            this.nextDate.setMonth(month);
            this.nextDate.setFullYear(year);
            this.callback = (next) => {
                monthView = this.daysView;
                let dayItem;
                while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                    dayItem = monthView.dates.find((d) => d.date.date.getTime() === next.getTime());
                    monthView = monthView.nextMonthView;
                }
                if (dayItem && dayItem.isFocusable) {
                    dayItem.nativeElement.focus();
                }
            };
        }
        if (isPageDown) {
            if (event.repeat) {
                requestAnimationFrame(() => this.nextMonth(true));
            }
            else {
                this.nextMonth(true);
            }
        }
        else {
            if (event.repeat) {
                requestAnimationFrame(() => this.previousMonth(true));
            }
            else {
                this.previousMonth(true);
            }
        }
    }
    /**
     * Keyboard navigation of the calendar
     *
     * @hidden
     * @internal
     */
    onKeydownShiftPageUp(event) {
        event.preventDefault();
        if (!this.isDefaultView) {
            return;
        }
        const isPageDown = event.key === 'PageDown';
        const step = isPageDown ? 1 : -1;
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', step);
        this.animationAction = isPageDown ? ScrollMonth.NEXT : ScrollMonth.PREV;
        this.isKeydownTrigger = true;
        let monthView = this.daysView;
        let activeDate;
        while (!activeDate && monthView) {
            activeDate = monthView.dates.find((date) => date.nativeElement === document.activeElement);
            monthView = monthView.nextMonthView;
        }
        if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            const year = this.nextDate.getFullYear() + step;
            const range = monthRange(year, this.nextDate.getMonth());
            let day = this.nextDate.getDate();
            if (day > range[1]) {
                day = range[1];
            }
            this.nextDate.setDate(day);
            this.nextDate.setFullYear(year);
            this.callback = (next) => {
                monthView = this.daysView;
                let dayItem;
                while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                    dayItem = monthView.dates.find((d) => d.date.date.getTime() === next.getTime());
                    monthView = monthView.nextMonthView;
                }
                if (dayItem && dayItem.isFocusable) {
                    dayItem.nativeElement.focus();
                }
            };
        }
    }
    /**
     * Keyboard navigation of the calendar
     *
     * @hidden
     * @internal
     */
    onKeydownHome(event) {
        if (this.daysView) {
            this.daysView.onKeydownHome(event);
        }
    }
    /**
     * Keyboard navigation of the calendar
     *
     * @hidden
     * @internal
     */
    onKeydownEnd(event) {
        if (this.daysView) {
            this.daysView.onKeydownEnd(event);
        }
    }
    /**
     * Stop continuous navigation on mouseup event
     *
     * @hidden
     * @internal
     */
    onMouseUp(event) {
        if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.stopMonthScroll(event);
        }
    }
    ngAfterViewInit() {
        this.setSiblingMonths(this.monthViews);
        this._monthViewsChanges$ = this.monthViews.changes.subscribe(c => {
            this.setSiblingMonths(c);
        });
        this.startMonthScroll$.pipe(takeUntil(this.stopMonthScroll$), switchMap(() => this.scrollMonth$.pipe(skipLast(1), debounce(() => interval(300)), takeUntil(this.stopMonthScroll$)))).subscribe(() => {
            switch (this.monthScrollDirection) {
                case ScrollMonth.PREV:
                    this.previousMonth();
                    break;
                case ScrollMonth.NEXT:
                    this.nextMonth();
                    break;
                case ScrollMonth.NONE:
                default:
                    break;
            }
        });
    }
    /**
     * Returns the locale representation of the month in the month view if enabled,
     * otherwise returns the default `Date.getMonth()` value.
     *
     * @hidden
     * @internal
     */
    formattedMonth(value) {
        if (this.formatViews.month) {
            return this.formatterMonth.format(value);
        }
        return `${value.getMonth()}`;
    }
    /**
     * Change to previous month
     *
     * @hidden
     * @internal
     */
    previousMonth(isKeydownTrigger = false) {
        if (isKeydownTrigger && this.animationAction === ScrollMonth.NEXT) {
            return;
        }
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getPrevMonth(this.viewDate);
        this.animationAction = ScrollMonth.PREV;
        this.isKeydownTrigger = isKeydownTrigger;
    }
    suppressBlur() {
        var _a;
        (_a = this.monthViews) === null || _a === void 0 ? void 0 : _a.forEach(d => d.shouldResetDate = false);
        if (this.daysView) {
            this.daysView.shouldResetDate = false;
        }
    }
    /**
     * Change to next month
     *
     * @hidden
     * @internal
     */
    nextMonth(isKeydownTrigger = false) {
        if (isKeydownTrigger && this.animationAction === 'prev') {
            return;
        }
        this.isKeydownTrigger = isKeydownTrigger;
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getNextMonth(this.viewDate);
        this.animationAction = ScrollMonth.NEXT;
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewDecade(args, activeViewIdx) {
        super.activeViewDecade(activeViewIdx);
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.date = args;
                this.dacadeView.calendarDir.find(date => date.isCurrentYear).nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewDecadeKB(event, args, activeViewIdx) {
        super.activeViewDecadeKB(event, activeViewIdx);
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.date = args;
                this.dacadeView.calendarDir.find(date => date.isCurrentYear).nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @internal
     */
    getFormattedDate() {
        const date = this.headerDate;
        return {
            monthday: this.formatterMonthday.format(date),
            weekday: this.formatterWeekday.format(date),
        };
    }
    /**
     * Handles invoked on date selection
     *
     * @hidden
     * @internal
     */
    childClicked(instance) {
        if (instance.isPrevMonth) {
            this.previousMonth();
        }
        if (instance.isNextMonth) {
            this.nextMonth();
        }
        this.selectDateFromClient(instance.date);
        if (this.selection === 'multi') {
            this.deselectDateInMonthViews(instance.date);
        }
        this.selected.emit(this.selectedDates);
    }
    /**
     * @hidden
     * @internal
     */
    viewChanging(args) {
        this.animationAction = args.monthAction;
        this.isKeydownTrigger = true;
        this.nextDate = args.nextDate;
        this.callback = (next) => {
            const day = this.daysView.dates.find((item) => item.date.date.getTime() === next.getTime());
            if (day) {
                this.daysView.daysNavService.focusNextDate(day.nativeElement, args.key, true);
            }
        };
        this.previousViewDate = this.viewDate;
        this.viewDate = this.nextDate;
    }
    /**
     * @hidden
     * @intenal
     */
    changeMonth(event) {
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
        this.activeView = IgxCalendarView.Month;
        requestAnimationFrame(() => {
            const elem = this.monthsBtns.find((e, idx) => idx === this.activeViewIdx);
            if (elem) {
                elem.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewYear(args, activeViewIdx) {
        this.activeView = IgxCalendarView.Year;
        this.activeViewIdx = activeViewIdx;
        requestAnimationFrame(() => {
            this.monthsView.date = args;
            this.focusMonth();
        });
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewYearKB(args, event, activeViewIdx) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            this.onActiveViewYear(args, activeViewIdx);
        }
    }
    /**
     * Deselects date(s) (based on the selection type).
     *
     * @example
     * ```typescript
     *  this.calendar.deselectDate(new Date(`2018-06-12`));
     * ````
     */
    deselectDate(value) {
        super.deselectDate(value);
        this.monthViews.forEach((view) => {
            view.selectedDates = this.selectedDates;
            view.rangeStarted = false;
        });
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * @hidden
     * @internal
     */
    getViewDate(i) {
        const date = this.calendarModel.timedelta(this.viewDate, 'month', i);
        return date;
    }
    /**
     * Getter for the context object inside the calendar templates.
     *
     * @hidden
     * @internal
     */
    getContext(i) {
        const date = this.getViewDate(i);
        return this.generateContext(date, i);
    }
    /**
     * @hidden
     * @internal
     */
    animationDone(event) {
        if ((event.fromState === ScrollMonth.NONE && (event.toState === ScrollMonth.PREV || event.toState === ScrollMonth.NEXT)) ||
            (event.fromState === 'void' && event.toState === ScrollMonth.NONE)) {
            this.viewDateChanged.emit({ previousValue: this.previousViewDate, currentValue: this.viewDate });
        }
        if (!this.isKeydownTrigger) {
            this.resetActiveDate();
        }
        if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.scrollMonth$.next();
        }
        if (!this.isDefaultView) {
            return;
        }
        let monthView = this.daysView;
        let date = monthView.dates.find((d) => d.selected);
        while (!date && monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
            date = monthView.dates.find((d) => d.selected);
        }
        if (date && date.isFocusable && !this.isKeydownTrigger) {
            setTimeout(() => {
                date.nativeElement.focus();
            }, parseInt(slideInRight.options.params.duration, 10));
        }
        else if (this.callback && (event.toState === ScrollMonth.NEXT || event.toState === ScrollMonth.PREV)) {
            this.callback(this.nextDate);
        }
        this.animationAction = ScrollMonth.NONE;
    }
    /**
     * @hidden
     * @internal
     */
    viewRendered(event) {
        if (event.fromState !== 'void') {
            this.activeViewChanged.emit(this.activeView);
            if (this.isDefaultView) {
                this.resetActiveDate();
            }
        }
    }
    /**
     * @hidden
     * @internal
     */
    resetActiveDate() {
        if (!this.monthViews) {
            return;
        }
        let dates = [];
        this.monthViews.map(mv => mv.dates).forEach(days => {
            dates = dates.concat(days.toArray());
        });
        const date = dates.find(day => day.selected && day.isCurrentMonth) || dates.find(day => day.isToday && day.isCurrentMonth)
            || dates.find(d => d.isFocusable);
        if (date) {
            this.activeDate = date.date.date.toLocaleDateString();
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        if (this._monthViewsChanges$) {
            this._monthViewsChanges$.unsubscribe();
        }
    }
    /**
     * @hidden
     * @internal
     */
    getPrevMonth(date) {
        return this.calendarModel.getPrevMonth(date);
    }
    /**
     * @hidden
     * @internal
     */
    getNextMonth(date, viewIndex) {
        return this.calendarModel.getDateByView(date, 'Month', viewIndex);
    }
    /**
     * Helper method building and returning the context object inside
     * the calendar templates.
     *
     * @hidden
     * @internal
     */
    generateContext(value, i) {
        const formatObject = Object.assign({ index: i, monthView: () => this.onActiveViewYear(value, i), yearView: () => this.onActiveViewDecade(value, i) }, this.calendarModel.formatToParts(value, this.locale, this.formatOptions, ['era', 'year', 'month', 'day', 'weekday']));
        return { $implicit: formatObject };
    }
    /**
     * Helper method that sets references for prev/next months for each month in the view
     *
     * @hidden
     * @internal
     */
    setSiblingMonths(monthViews) {
        monthViews.forEach((item, index) => {
            const prevMonthView = this.getMonthView(index - 1);
            const nextMonthView = this.getMonthView(index + 1);
            item.nextMonthView = nextMonthView;
            item.prevMonthView = prevMonthView;
        });
    }
    /**
     * Helper method returning previous/next day views
     *
     * @hidden
     * @internal
     */
    getMonthView(index) {
        if (index === -1 || index === this.monthViews.length) {
            return null;
        }
        else {
            return this.monthViews.toArray()[index];
        }
    }
    /**
     * Helper method that does deselection for all month views when selection is "multi"
     * If not called, selection in other month views stays
     *
     * @hidden
     * @internal
     */
    deselectDateInMonthViews(value) {
        this.monthViews.forEach(m => {
            m.deselectMultipleInMonth(value);
        });
    }
    focusMonth() {
        const month = this.monthsView.monthsRef.find((e) => e.index === this.monthsView.date.getMonth());
        if (month) {
            month.nativeElement.focus();
        }
    }
}
IgxCalendarComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxCalendarComponent
                    }
                ],
                animations: [
                    trigger('animateView', [
                        transition('void => 0', useAnimation(fadeIn)),
                        transition('void => *', useAnimation(scaleInCenter, {
                            params: {
                                duration: '.2s',
                                fromScale: .9
                            }
                        }))
                    ]),
                    trigger('animateChange', [
                        transition('* => prev', useAnimation(slideInLeft, {
                            params: {
                                fromPosition: 'translateX(-30%)'
                            }
                        })),
                        transition('* => next', useAnimation(slideInRight, {
                            params: {
                                fromPosition: 'translateX(30%)'
                            }
                        }))
                    ])
                ],
                selector: 'igx-calendar',
                template: "<ng-template let-result #defaultHeader>\n    <span>{{ getFormattedDate().weekday }},&nbsp;</span>\n    <span>{{ getFormattedDate().monthday }}</span>\n</ng-template>\n\n<ng-template let-result #defaultMonth let-obj>\n        <span *ngIf=\"monthsViewNumber < 2 || obj.index < 1\" class=\"igx-calendar__aria-off-screen\" aria-live=\"polite\">\n            {{ monthsViewNumber > 1 ? (resourceStrings.igx_calendar_first_picker_of.replace('{0}', monthsViewNumber.toString())  + ' ' + (getViewDate(obj.index) | date: 'LLLL yyyy')) : resourceStrings.igx_calendar_selected_month_is + (getViewDate(obj.index) | date: 'LLLL yyyy')}}\n        </span>\n        <span\n            tabindex=\"0\"\n            role=\"button\"\n            [attr.aria-label]=\"(getViewDate(obj.index) | date: 'LLLL') + ' ' + resourceStrings.igx_calendar_select_month\"\n            #monthsBtn\n            (keydown)=\"onActiveViewYearKB(getViewDate(obj.index), $event, obj.index)\"\n            (click)=\"onActiveViewYear(getViewDate(obj.index), obj.index)\"\n            class=\"igx-calendar-picker__date\">\n            {{ formattedMonth(getViewDate(obj.index)) }}\n        </span>\n\n        <span\n            tabindex=\"0\"\n            role=\"button\"\n            [attr.aria-label]=\"(getViewDate(obj.index) | date: 'yyyy') + ' ' + resourceStrings.igx_calendar_select_year\"\n            #yearsBtn\n            (keydown)=\"onActiveViewDecadeKB($event, getViewDate(obj.index), obj.index)\"\n            (click)=\"onActiveViewDecade(getViewDate(obj.index), obj.index)\"\n            class=\"igx-calendar-picker__date\">\n            {{ formattedYear(getViewDate(obj.index)) }}\n        </span>\n</ng-template>\n\n<header\n    aria-labelledby=\"igx-aria-calendar-title-month igx-aria-calendar-title-year\"\n    class=\"igx-calendar__header\"\n    *ngIf=\"selection === 'single' && hasHeader\">\n\n    <h5 id=\"igx-aria-calendar-title-year\" class=\"igx-calendar__header-year\">\n        {{ formattedYear(headerDate) }}\n    </h5>\n\n    <h2 id=\"igx-aria-calendar-title-month\" class=\"igx-calendar__header-date\">\n        <ng-container *ngTemplateOutlet=\"headerTemplate ? headerTemplate : defaultHeader; context: headerContext\">\n        </ng-container>\n    </h2>\n</header>\n\n<div *ngIf=\"isDefaultView\"  class=\"igx-calendar__body\" [@animateView]=\"activeView\" (@animateView.done)=\"viewRendered($event)\" (swiperight)=\"previousMonth()\"\n    (swipeleft)=\"nextMonth()\" (pointerdown)=\"suppressBlur()\">\n    <section class=\"igx-calendar-picker\">\n        <span tabindex=\"0\" class=\"igx-calendar__aria-off-screen\">\n            <ng-container *ngIf=\"selection === 'multi'\">\n                {{ monthsViewNumber && monthsViewNumber > 1 ?  resourceStrings.igx_calendar_multi_selection.replace('{0}', monthsViewNumber.toString()) : resourceStrings.igx_calendar_singular_multi_selection}}\n            </ng-container>\n            <ng-container *ngIf=\"selection === 'range'\">\n                {{ monthsViewNumber && monthsViewNumber > 1 ?  resourceStrings.igx_calendar_range_selection.replace('{0}', monthsViewNumber.toString()) : resourceStrings.igx_calendar_singular_range_selection}}\n            </ng-container>\n            <ng-container *ngIf=\"selection === 'single'\">\n                {{ monthsViewNumber && monthsViewNumber > 1 ?  resourceStrings.igx_calendar_single_selection.replace('{0}', monthsViewNumber.toString()) : resourceStrings.igx_calendar_singular_single_selection}}\n            </ng-container>\n        </span>\n        <div\n            tabindex=\"0\"\n            class=\"igx-calendar-picker__prev\"\n            role=\"button\"\n            [attr.aria-label]=\"resourceStrings.igx_calendar_previous_month + ', ' + (getPrevMonth(viewDate) | date: 'LLLL')\"\n            data-action=\"prev\"\n            #prevMonthBtn\n            igxCalendarScrollMonth\n            [startScroll]=\"startPrevMonthScroll\"\n            [stopScroll]=\"stopMonthScroll\"\n            [ngStyle]=\"{ 'min-width.%': 100/(monthsViewNumber*7)}\">\n            <igx-icon aria-hidden=\"true\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div class=\"igx-calendar-picker__dates\"\n             *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\"\n             [style.width.%]=\"100/monthsViewNumber\"\n             [attr.data-month]=\"i | IgxGetViewDate:viewDate:false\">\n            <ng-container *ngTemplateOutlet=\"subheaderTemplate ? subheaderTemplate : defaultMonth; context: getContext(i)\">\n            </ng-container>\n        </div>\n        <div\n            tabindex=\"0\"\n            class=\"igx-calendar-picker__next\"\n            role=\"button\"\n            [attr.aria-label]=\"resourceStrings.igx_calendar_next_month + ', ' +  (getNextMonth(viewDate, monthsViewNumber) | date: 'LLLL')\"\n            data-action=\"next\"\n            #nextMonthBtn\n            igxCalendarScrollMonth\n            [startScroll]=\"startNextMonthScroll\"\n            [stopScroll]=\"stopMonthScroll\"\n            [ngStyle]=\"{'min-width.%': 100/(monthsViewNumber*7)}\">\n            <igx-icon aria-hidden=\"true\">keyboard_arrow_right</igx-icon>\n        </div>\n    </section>\n\n    <section style=\"display: flex\"\n        [@animateChange]=\"animationAction\"\n        (@animateChange.done)=\"animationDone($event)\">\n        <igx-days-view role=\"grid\" *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [changeDaysView]=\"true\" #days\n                [selection]=\"selection\"\n                [locale]=\"locale\"\n                [value]=\"value\"\n                [(activeDate)]=\"activeDate\"\n                [viewDate]=\"i | IgxGetViewDate:viewDate\"\n                [weekStart]=\"weekStart\"\n                [formatOptions]=\"formatOptions\"\n                [formatViews]=\"formatViews\"\n                [disabledDates]=\"disabledDates\"\n                [specialDates]=\"specialDates\"\n                [hideOutsideDays]=\"hideOutsideDays\"\n                [showWeekNumbers]=\"showWeekNumbers\"\n                (viewChanging)=\"viewChanging($event)\"\n                (dateSelection)=\"childClicked($event)\"\n                (monthsViewBlur)=\"resetActiveDate()\">\n        </igx-days-view>\n    </section>\n</div>\n\n<igx-months-view *ngIf=\"isYearView\"\n                 [@animateView]=\"activeView\"\n                 #months\n                 (@animateView.done)=\"viewRendered($event)\"\n                 [date]=\"viewDate\"\n                 [locale]=\"locale\"\n                 [formatView]=\"formatViews.month\"\n                 [monthFormat]=\"formatOptions.month\"\n                 (selected)=\"changeMonth($event)\">\n</igx-months-view>\n\n<igx-years-view *ngIf=\"isDecadeView\"\n                [@animateView]=\"activeView\"\n                #decade\n                (@animateView.done)=\"viewRendered($event)\"\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (selected)=\"changeYear($event)\">\n</igx-years-view>\n"
            },] }
];
IgxCalendarComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    hasHeader: [{ type: Input }],
    vertical: [{ type: Input }],
    monthsViewNumber: [{ type: Input }],
    showWeekNumbers: [{ type: Input }],
    animationAction: [{ type: Input }],
    styleVerticalClass: [{ type: HostBinding, args: ['class.igx-calendar--vertical',] }],
    styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
    monthsView: [{ type: ViewChild, args: ['months', { read: IgxMonthsViewComponent },] }],
    monthsBtns: [{ type: ViewChildren, args: ['monthsBtn',] }],
    dacadeView: [{ type: ViewChild, args: ['decade', { read: IgxYearsViewComponent },] }],
    daysView: [{ type: ViewChild, args: ['days', { read: IgxDaysViewComponent },] }],
    monthViews: [{ type: ViewChildren, args: ['days', { read: IgxDaysViewComponent },] }],
    prevMonthBtn: [{ type: ViewChild, args: ['prevMonthBtn',] }],
    nextMonthBtn: [{ type: ViewChild, args: ['nextMonthBtn',] }],
    headerTemplateDirective: [{ type: ContentChild, args: [forwardRef(() => IgxCalendarHeaderTemplateDirective), { read: IgxCalendarHeaderTemplateDirective, static: true },] }],
    subheaderTemplateDirective: [{ type: ContentChild, args: [forwardRef(() => IgxCalendarSubheaderTemplateDirective), { read: IgxCalendarSubheaderTemplateDirective, static: true },] }],
    onKeydownPageDown: [{ type: HostListener, args: ['keydown.pagedown', ['$event'],] }, { type: HostListener, args: ['keydown.pageup', ['$event'],] }],
    onKeydownShiftPageUp: [{ type: HostListener, args: ['keydown.shift.pageup', ['$event'],] }, { type: HostListener, args: ['keydown.shift.pagedown', ['$event'],] }],
    onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }],
    onMouseUp: [{ type: HostListener, args: ['document:mouseup', ['$event'],] }]
};

let NEXT_ID$d = 0;
class IgxMonthPickerComponent extends IgxMonthPickerBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Sets/gets the `id` of the month picker.
         * If not set, the `id` will have value `"igx-month-picker-0"`.
         */
        this.id = `igx-month-picker-${NEXT_ID$d++}`;
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * @hidden
         */
        this.yearAction = '';
    }
    /**
     * @hidden
     */
    previousYear(event) {
        event === null || event === void 0 ? void 0 : event.preventDefault();
        if (event && this.yearAction === 'next') {
            return;
        }
        this.yearAction = 'prev';
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getPrevYear(this.viewDate);
    }
    /**
     * @hidden
     */
    nextYear(event) {
        event === null || event === void 0 ? void 0 : event.preventDefault();
        if (event && this.yearAction === 'prev') {
            return;
        }
        this.yearAction = 'next';
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getNextYear(this.viewDate);
    }
    /**
     * @hidden
     */
    onKeydownHome(event) {
        if (this.monthsView) {
            this.monthsView.el.nativeElement.focus();
            this.monthsView.onKeydownHome(event);
        }
    }
    /**
     * @hidden
     */
    onKeydownEnd(event) {
        if (this.monthsView) {
            this.monthsView.el.nativeElement.focus();
            this.monthsView.onKeydownEnd(event);
        }
    }
    /**
     * @hidden
     */
    animationDone(event) {
        if ((event.fromState === 'void' && event.toState === '') ||
            (event.fromState === '' && (event.toState === ScrollMonth.PREV || event.toState === ScrollMonth.NEXT))) {
            this.viewDateChanged.emit({ previousValue: this.previousViewDate, currentValue: this.viewDate });
        }
        this.yearAction = '';
    }
    /**
     * @hidden
     */
    viewRendered(event) {
        if (event.fromState !== 'void') {
            this.activeViewChanged.emit(this.activeView);
        }
    }
    /**
     * @hidden
     */
    activeViewDecadeKB(event) {
        super.activeViewDecadeKB(event);
        if (event.key === "ArrowRight" /* RIGHT_ARROW */ || event.key === "Right" /* RIGHT_ARROW_IE */) {
            this.nextYear(event);
        }
        if (event.key === "ArrowLeft" /* LEFT_ARROW */ || event.key === "Left" /* LEFT_ARROW_IE */) {
            this.previousYear(event);
        }
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.el.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     */
    activeViewDecade() {
        super.activeViewDecade();
        requestAnimationFrame(() => {
            this.dacadeView.el.nativeElement.focus();
        });
    }
    /**
     * @hidden
     */
    changeYearKB(event, next = true) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.stopPropagation();
            if (next) {
                this.nextYear();
            }
            else {
                this.previousYear();
            }
        }
    }
    /**
     * @hidden
     */
    selectYear(event) {
        this.previousViewDate = this.viewDate;
        this.viewDate = new Date(event.getFullYear(), event.getMonth(), event.getDate());
        this.activeView = IgxCalendarView.Month;
        requestAnimationFrame(() => {
            if (this.yearsBtn) {
                this.yearsBtn.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     */
    selectMonth(event) {
        this.selectDate(event);
        this.selected.emit(this.selectedDates);
    }
    /**
     * Selects a date.
     * ```typescript
     *  this.monthPicker.selectDate(new Date(`2018-06-12`));
     * ```
     */
    selectDate(value) {
        if (!value) {
            return new Date();
        }
        super.selectDate(value);
        this.viewDate = value;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        if (value) {
            this.viewDate = this.selectedDates = value;
        }
    }
    /**
     * @hidden
     */
    getNextYear() {
        return this.calendarModel.getNextYear(this.viewDate).getFullYear();
    }
    /**
     * @hidden
     */
    getPreviousYear() {
        return this.calendarModel.getPrevYear(this.viewDate).getFullYear();
    }
}
IgxMonthPickerComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxMonthPickerComponent
                    }
                ],
                animations: [
                    trigger('animateView', [
                        transition('void => 0', useAnimation(fadeIn)),
                        transition('void => *', useAnimation(scaleInCenter, {
                            params: {
                                duration: '.2s',
                                fromScale: .9
                            }
                        }))
                    ]),
                    trigger('animateChange', [
                        transition('* => prev', useAnimation(slideInLeft, {
                            params: {
                                fromPosition: 'translateX(-30%)'
                            }
                        })),
                        transition('* => next', useAnimation(slideInRight, {
                            params: {
                                fromPosition: 'translateX(30%)'
                            }
                        }))
                    ])
                ],
                selector: 'igx-month-picker',
                template: "<div\n    *ngIf=\"isDefaultView\"\n    [@animateView]=\"activeView\"\n    (@animateView.done)=\"viewRendered($event)\"\n    class=\"igx-calendar__body\"\n    (swiperight)=\"previousYear()\"\n    (swipeleft)=\"nextYear()\">\n\n    <div role=\"rowheader\" class=\"igx-calendar-picker\">\n        <div\n            tabindex=\"0\"\n            class=\"igx-calendar-picker__prev\"\n            (click)=\"previousYear()\"\n            (keydown)=\"changeYearKB($event, false)\"\n            [ngStyle]=\"{'min-width.%': 25, 'left': 0}\"\n            role=\"button\"\n            [attr.aria-label]=\"'Previous Year ' + getPreviousYear()\"\n            data-action=\"prev\">\n            <igx-icon>keyboard_arrow_left</igx-icon>\n        </div>\n        <div [style.width.%]=\"100\">\n            <span\n                tabindex=\"0\"\n                aria-live=\"polite\"\n                #yearsBtn\n                (keydown)=\"activeViewDecadeKB($event)\"\n                (click)=\"activeViewDecade()\"\n                class=\"igx-calendar-picker__date\">\n                {{ formattedYear(viewDate) }}\n            </span>\n        </div>\n        <div\n            tabindex=\"0\"\n            class=\"igx-calendar-picker__next\"\n            (click)=\"nextYear()\"\n            (keydown)=\"changeYearKB($event)\"\n            [ngStyle]=\"{'min-width.%': 25,'right': 0}\"\n            role=\"button\"\n            [attr.aria-label]=\"'Next Year ' + getNextYear()\"\n            data-action=\"next\">\n\n            <igx-icon>keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <igx-months-view [@animateChange]=\"yearAction\" #months\n                     (@animateChange.done)=\"animationDone($event)\"\n                     (@animateView.done)=\"viewRendered($event)\"\n                     [date]=\"viewDate\"\n                     [locale]=\"locale\"\n                     [formatView]=\"formatViews.month\"\n                     [monthFormat]=\"formatOptions.month\"\n                     (selected)=\"selectMonth($event)\">\n    </igx-months-view>\n</div>\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade (@animateView.done)=\"viewRendered($event)\"\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (selected)=\"selectYear($event)\">\n</igx-years-view>\n"
            },] }
];
IgxMonthPickerComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
    monthsView: [{ type: ViewChild, args: ['months', { read: IgxMonthsViewComponent },] }],
    dacadeView: [{ type: ViewChild, args: ['decade', { read: IgxYearsViewComponent },] }],
    daysView: [{ type: ViewChild, args: ['days', { read: IgxDaysViewComponent },] }],
    yearsBtn: [{ type: ViewChild, args: ['yearsBtn',] }],
    previousYear: [{ type: HostListener, args: ['keydown.pageup', ['$event'],] }],
    nextYear: [{ type: HostListener, args: ['keydown.pagedown', ['$event'],] }],
    onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }]
};

class IgxMonthViewSlotsCalendar {
    transform(monthViews) {
        return new Array(monthViews);
    }
}
IgxMonthViewSlotsCalendar.decorators = [
    { type: Pipe, args: [{
                name: 'IgxMonthViewSlots'
            },] }
];
class IgxGetViewDateCalendar {
    constructor() {
        this.calendar = new Calendar();
    }
    transform(index, viewDate, wholeDate = true) {
        const date = this.calendar.timedelta(viewDate, 'month', index);
        return wholeDate ? date : date.getMonth();
    }
}
IgxGetViewDateCalendar.decorators = [
    { type: Pipe, args: [{
                name: 'IgxGetViewDate'
            },] }
];
IgxGetViewDateCalendar.ctorParameters = () => [];

/**
 * @hidden
 */
class IgxCalendarModule {
}
IgxCalendarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxCalendarBaseDirective,
                    IgxMonthPickerBaseDirective,
                    IgxDayItemComponent,
                    IgxDaysViewComponent,
                    IgxCalendarComponent,
                    IgxCalendarHeaderTemplateDirective,
                    IgxCalendarMonthDirective,
                    IgxCalendarYearDirective,
                    IgxCalendarSubheaderTemplateDirective,
                    IgxCalendarScrollMonthDirective,
                    IgxMonthsViewComponent,
                    IgxYearsViewComponent,
                    IgxMonthPickerComponent,
                    IgxMonthViewSlotsCalendar,
                    IgxGetViewDateCalendar
                ],
                exports: [
                    IgxCalendarComponent,
                    IgxDaysViewComponent,
                    IgxMonthsViewComponent,
                    IgxYearsViewComponent,
                    IgxMonthPickerComponent,
                    IgxCalendarHeaderTemplateDirective,
                    IgxCalendarMonthDirective,
                    IgxCalendarYearDirective,
                    IgxCalendarSubheaderTemplateDirective
                ],
                imports: [CommonModule, FormsModule, IgxIconModule]
            },] }
];

let NEXT_ID$e = 0;
/**
 * IgxCardMedia is container for the card media section.
 * Use it to wrap images and videos.
 */
class IgxCardMediaDirective {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card__media';
        /**
         * An @Input property that sets the `width` and `min-width` style property
         * of the media container. If not provided it will be set to `auto`.
         *
         * @example
         * ```html
         * <igx-card-media width="300px"></igx-card-media>
         * ```
         */
        this.width = 'auto';
        /**
         * An @Input property that sets the `height` style property of the media container.
         * If not provided it will be set to `auto`.
         *
         * @example
         * ```html
         * <igx-card-media height="50%"></igx-card-media>
         * ```
         */
        this.height = 'auto';
        /**
         * An @Input property that sets the `role` attribute of the media container.
         */
        this.role = 'img';
    }
}
IgxCardMediaDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: 'igx-card-media'
            },] }
];
IgxCardMediaDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-card__media',] }],
    width: [{ type: HostBinding, args: ['style.width',] }, { type: HostBinding, args: ['style.min-width',] }, { type: Input }],
    height: [{ type: HostBinding, args: ['style.height',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }]
};
/**
 * IgxCardHeader is container for the card header
 */
class IgxCardHeaderComponent {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card-header';
        /**
         * An @Input property that sets the layout style of the header.
         * By default the header elements(thumbnail and title/subtitle) are aligned horizontally.
         *
         * @example
         * ```html
         * <igx-card-header [vertical]="true"></igx-card-header>
         * ```
         */
        this.vertical = false;
        /**
         * An @Input property that sets the value of the `role` attribute of the card header.
         * By default the value is set to `header`.
         *
         * @example
         * ```html
         * <igx-card-header role="header"></igx-card-header>
         * ```
         */
        this.role = 'header';
    }
}
IgxCardHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-card-header',
                template: "<div class=\"igx-card-header__thumbnail\">\n    <ng-content select=\"igx-avatar, igx-card-media, [igxCardThumbnail]\"></ng-content>\n</div>\n\n<div class=\"igx-card-header__titles\">\n    <ng-content select=\"\n        [igxCardHeaderTitle],\n        [igxCardHeaderSubtitle],\n        .igx-card-header__title,\n        .igx-card-header__subtitle\">\n    </ng-content>\n</div>\n\n<ng-content></ng-content>\n"
            },] }
];
IgxCardHeaderComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-card-header',] }],
    vertical: [{ type: HostBinding, args: ['class.igx-card-header--vertical',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }]
};
/**
 * IgxCardThumbnail is container for the card thumbnail section.
 * Use it to wrap anything you want to be used as a thumbnail.
 */
class IgxCardThumbnailDirective {
}
IgxCardThumbnailDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCardThumbnail]'
            },] }
];
/**
 * igxCardHeaderTitle is used to denote the header title in a card.
 * Use it to tag text nodes.
 */
class IgxCardHeaderTitleDirective {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card__header__title';
    }
}
IgxCardHeaderTitleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCardHeaderTitle]'
            },] }
];
IgxCardHeaderTitleDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-card-header__title',] }]
};
/**
 * igxCardHeaderSubtitle is used to denote the header subtitle in a card.
 * Use it to tag text nodes.
 */
class IgxCardHeaderSubtitleDirective {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card-header__subtitle';
    }
}
IgxCardHeaderSubtitleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCardHeaderSubtitle]'
            },] }
];
IgxCardHeaderSubtitleDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-card-header__subtitle',] }]
};
/**
 * IgxCardContent is container for the card content.
 */
class IgxCardContentDirective {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card-content';
    }
}
IgxCardContentDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: 'igx-card-content'
            },] }
];
IgxCardContentDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-card-content',] }]
};
/**
 * IgxCardFooter is container for the card footer
 */
class IgxCardFooterDirective {
    constructor() {
        /**
         * An @Input property that sets the value of the `role` attribute of the card footer.
         * By default the value is set to `footer`.
         *
         * @example
         * ```html
         * <igx-card-footer role="footer"></igx-card-footer>
         * ```
         */
        this.role = 'footer';
    }
}
IgxCardFooterDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: 'igx-card-footer'
            },] }
];
IgxCardFooterDirective.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }]
};
/**
 * Card provides a way to display organized content in appealing way.
 *
 * @igxModule IgxCardModule
 *
 * @igxTheme igx-card-theme, igx-icon-theme, igx-button-theme
 *
 * @igxKeywords card, button, avatar, icon
 *
 * @igxGroup Layouts
 *
 * @remarks
 * The Ignite UI Card serves as a container that allows custom content to be organized in an appealing way. There are
 * five sections in a card that you can use to organize your content. These are header, media, content, actions, and footer.
 *
 * @example
 * ```html
 * <igx-card>
 *   <igx-card-header>
 *     <h3 igxCardHeaderTitle>{{title}}</h3>
 *     <h5 igxCardHeaderSubtitle>{{subtitle}}</h5>
 *   </igx-card-header>
 *   <igx-card-actions>
 *       <button igxButton igxRipple>Share</button>
 *       <button igxButton igxRipple>Play Album</button>
 *   </igx-card-actions>
 * </igx-card>
 * ```
 */
const IgxCardType = mkenum({
    ELEVATED: 'elevated',
    OUTLINED: 'outlined'
});
class IgxCardComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the card.
         * If not set, `id` will have value `"igx-card-0"`;
         *
         * @example
         * ```html
         * <igx-card id = "my-first-card"></igx-card>
         * ```
         * ```typescript
         * let cardId =  this.card.id;
         * ```
         */
        this.id = `igx-card-${NEXT_ID$e++}`;
        /**
         * An @Input property that sets the value of the `role` attribute of the card.
         * By default the value is set to `group`.
         *
         * @example
         * ```html
         * <igx-card role="group"></igx-card>
         * ```
         */
        this.role = 'group';
        /**
         * An @Input property that sets the value of the `type` attribute of the card.
         * By default the value is set to `elevated`. You can make the card use the
         * outlined style by setting the value to `outlined`.
         *
         * @example
         * ```html
         * <igx-card type="outlined"></igx-card>
         * ```
         */
        this.type = IgxCardType.ELEVATED;
        /**
         * An @Input property that sets the value of the `horizontal` attribute of the card.
         * Setting this to `true` will make the different card sections align horizontally,
         * essentially flipping the card to the side.
         *
         * @example
         * ```html
         * <igx-card [horizontal]="true"></igx-card>
         * ```
         */
        this.horizontal = false;
    }
    /**
     * A getter which will return true if the card type is `outlined`.
     */
    get isOutlinedCard() {
        return this.type === IgxCardType.OUTLINED;
    }
}
IgxCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-card',
                template: "<ng-content></ng-content>\n"
            },] }
];
IgxCardComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    type: [{ type: HostBinding, args: ['class.igx-card',] }, { type: Input }],
    isOutlinedCard: [{ type: HostBinding, args: ['class.igx-card--outlined',] }],
    horizontal: [{ type: HostBinding, args: ['class.igx-card--horizontal',] }, { type: Input }]
};
const IgxCardActionsLayout = mkenum({
    START: 'start',
    JUSTIFY: 'justify'
});
/**
 * IgxCardActions is container for the card actions.
 */
class IgxCardActionsComponent {
    constructor(card) {
        this.card = card;
        /**
         * An @Input property that sets the layout style of the actions.
         * By default icons and icon buttons, as well as regular buttons
         * are split into two containers, which are then positioned on both ends
         * of the card-actions area.
         * You can justify the elements in those groups so they are positioned equally
         * from one another taking up all the space available along the card actions axis.
         *
         * @example
         * ```html
         * <igx-card-actions layout="justify"></igx-card-actions>
         * ```
         */
        this.layout = IgxCardActionsLayout.START;
        /**
         * An @Input property that sets order of the buttons the actions area.
         * By default all icons/icon buttons are placed at the end of the action
         * area. Any regular buttons(flat, raised) will appear before the icons/icon buttons
         * placed in the actions area.
         * If you want to reverse their positions so that icons appear first, use the `reverse`
         * attribute.
         *
         * @example
         * ```html
         * <igx-card-actions [reverse]="true"></igx-card-actions>
         * ```
         */
        this.reverse = false;
        this.isVerticalSet = false;
    }
    /**
     * A getter that returns `true` when the layout has been
     * set to `justify`.
     */
    get isJustifyLayout() {
        return this.layout === IgxCardActionsLayout.JUSTIFY;
    }
    /**
     * @hidden
     * @internal
     */
    ngOnChanges(changes) {
        for (const prop in changes) {
            if (prop === 'vertical') {
                this.isVerticalSet = true;
            }
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnInit() {
        this.vertical = !this.isVerticalSet && this.card.horizontal;
    }
}
IgxCardActionsComponent.decorators = [
    { type: Component, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: 'igx-card-actions',
                template: "<div class=\"igx-card-actions__icons\">\n    <ng-content select=\"igx-icon, [igxButton='icon']\"></ng-content>\n</div>\n\n<div #buttons class=\"igx-card-actions__buttons\">\n    <ng-content select=\"[igxButton]\"></ng-content>\n</div>\n\n\n<ng-content></ng-content>\n"
            },] }
];
IgxCardActionsComponent.ctorParameters = () => [
    { type: IgxCardComponent, decorators: [{ type: Optional }, { type: Inject, args: [IgxCardComponent,] }] }
];
IgxCardActionsComponent.propDecorators = {
    layout: [{ type: HostBinding, args: ['class.igx-card-actions',] }, { type: Input }],
    vertical: [{ type: HostBinding, args: ['class.igx-card-actions--vertical',] }, { type: Input }],
    isJustifyLayout: [{ type: HostBinding, args: ['class.igx-card-actions--justify',] }],
    reverse: [{ type: HostBinding, args: ['class.igx-card-actions--reverse',] }, { type: Input }]
};
/**
 * @hidden
 */
class IgxCardModule {
}
IgxCardModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxCardComponent,
                    IgxCardHeaderComponent,
                    IgxCardMediaDirective,
                    IgxCardContentDirective,
                    IgxCardActionsComponent,
                    IgxCardFooterDirective,
                    IgxCardHeaderTitleDirective,
                    IgxCardHeaderSubtitleDirective,
                    IgxCardThumbnailDirective,
                ],
                exports: [
                    IgxCardComponent,
                    IgxCardHeaderComponent,
                    IgxCardMediaDirective,
                    IgxCardContentDirective,
                    IgxCardActionsComponent,
                    IgxCardFooterDirective,
                    IgxCardHeaderTitleDirective,
                    IgxCardHeaderSubtitleDirective,
                    IgxCardThumbnailDirective,
                ],
                imports: [CommonModule, IgxButtonModule]
            },] }
];

class IgxCarouselIndicatorDirective {
}
IgxCarouselIndicatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCarouselIndicator]'
            },] }
];
class IgxCarouselNextButtonDirective {
}
IgxCarouselNextButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCarouselNextButton]'
            },] }
];
class IgxCarouselPrevButtonDirective {
}
IgxCarouselPrevButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCarouselPrevButton]'
            },] }
];

var Direction$1;
(function (Direction) {
    Direction[Direction["NONE"] = 0] = "NONE";
    Direction[Direction["NEXT"] = 1] = "NEXT";
    Direction[Direction["PREV"] = 2] = "PREV";
})(Direction$1 || (Direction$1 = {}));
/**
 * A slide component that usually holds an image and/or a caption text.
 * IgxSlideComponent is usually a child component of an IgxCarouselComponent.
 *
 * ```
 * <igx-slide [input bindings] >
 *    <ng-content></ng-content>
 * </igx-slide>
 * ```
 *
 * @export
 */
class IgxSlideComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Returns the `role` of the slide component.
         * By default is set to `tabpanel`
         *
         * @memberof IgxSlideComponent
         */
        this.tab = 'tabpanel';
        /**
         * Returns the class of the slide component.
         * ```typescript
         * let class =  this.slide.cssClass;
         * ```
         *
         * @memberof IgxSlideComponent
         */
        this.cssClass = 'igx-slide';
        this.previous = false;
        /**
         * @hidden
         */
        this.activeChange = new EventEmitter();
        this._active = false;
        this._destroy$ = new Subject();
    }
    /**
     * Returns the `tabIndex` of the slide component.
     * ```typescript
     * let tabIndex =  this.carousel.tabIndex;
     * ```
     *
     * @memberof IgxSlideComponent
     */
    get tabIndex() {
        return this.active ? 0 : null;
    }
    /**
     * Gets/sets the `active` state of the slide.
     * ```html
     * <igx-carousel>
     *  <igx-slide [active] ="false"></igx-slide>
     * <igx-carousel>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-carousel>
     *  <igx-slide [(active)] ="model.isActive"></igx-slide>
     * <igx-carousel>
     * ```
     *
     * @memberof IgxSlideComponent
     */
    get active() {
        return this._active;
    }
    set active(value) {
        this._active = !!value;
        this.activeChange.emit(this._active);
    }
    /**
     * Returns a reference to the carousel element in the DOM.
     * ```typescript
     * let nativeElement =  this.slide.nativeElement;
     * ```
     *
     * @memberof IgxSlideComponent
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get isDestroyed() {
        return this._destroy$;
    }
    ngAfterContentChecked() {
        this.id = `panel-${this.index}`;
        this.ariaLabelledBy = `tab-${this.index}-${this.total}`;
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
    }
}
IgxSlideComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-slide',
                template: "<ng-content></ng-content>\n"
            },] }
];
IgxSlideComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxSlideComponent.propDecorators = {
    index: [{ type: Input }],
    direction: [{ type: Input }],
    total: [{ type: Input }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }],
    tab: [{ type: HostBinding, args: ['attr.role',] }],
    ariaLabelledBy: [{ type: HostBinding, args: ['attr.aria-labelledby',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-slide',] }],
    active: [{ type: HostBinding, args: ['class.igx-slide--current',] }, { type: Input }],
    previous: [{ type: HostBinding, args: ['class.igx-slide--previous',] }, { type: Input }],
    activeChange: [{ type: Output }]
};

let NEXT_ID$f = 0;
const CarouselIndicatorsOrientation = mkenum({
    bottom: 'bottom',
    top: 'top'
});
const CarouselAnimationType = mkenum({
    none: 'none',
    slide: 'slide',
    fade: 'fade'
});
class CarouselHammerConfig extends HammerGestureConfig {
    constructor() {
        super(...arguments);
        this.overrides = {
            pan: { direction: Hammer.DIRECTION_HORIZONTAL }
        };
    }
}
CarouselHammerConfig.decorators = [
    { type: Injectable }
];
/**
 * **Ignite UI for Angular Carousel** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/carousel.html)
 *
 * The Ignite UI Carousel is used to browse or navigate through a collection of slides. Slides can contain custom
 * content such as images or cards and be used for things such as on-boarding tutorials or page-based interfaces.
 * It can be used as a separate fullscreen element or inside another component.
 *
 * Example:
 * ```html
 * <igx-carousel>
 *   <igx-slide>
 *     <h3>First Slide Header</h3>
 *     <p>First slide Content</p>
 *   <igx-slide>
 *   <igx-slide>
 *     <h3>Second Slide Header</h3>
 *     <p>Second Slide Content</p>
 * </igx-carousel>
 * ```
 */
class IgxCarouselComponent {
    constructor(element, iterableDiffers, builder, platformUtil) {
        this.element = element;
        this.iterableDiffers = iterableDiffers;
        this.builder = builder;
        this.platformUtil = platformUtil;
        /**
         * Sets the `id` of the carousel.
         * If not set, the `id` of the first carousel component will be `"igx-carousel-0"`.
         * ```html
         * <igx-carousel id="my-first-carousel"></igx-carousel>
         * ```
         *
         * @memberof IgxCarouselComponent
         */
        this.id = `igx-carousel-${NEXT_ID$f++}`;
        /**
         * Returns the `role` attribute of the carousel.
         * ```typescript
         * let carouselRole =  this.carousel.role;
         * ```
         *
         * @memberof IgxCarouselComponent
         */
        this.role = 'region';
        /** @hidden */
        this.roleDescription = 'carousel';
        /**
         * Returns the class of the carousel component.
         * ```typescript
         * let class =  this.carousel.cssClass;
         * ```
         *
         * @memberof IgxCarouselComponent
         */
        this.cssClass = 'igx-carousel';
        /**
         * Sets whether the carousel should `loop` back to the first slide after reaching the last slide.
         * Default value is `true`.
         * ```html
         * <igx-carousel [loop]="false"></igx-carousel>
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        this.loop = true;
        /**
         * Sets whether the carousel will `pause` the slide transitions on user interactions.
         * Default value is `true`.
         * ```html
         *  <igx-carousel [pause]="false"></igx-carousel>
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        this.pause = true;
        /**
         * Controls whether the carousel should render the left/right `navigation` buttons.
         * Default value is `true`.
         * ```html
         * <igx-carousel [navigation] = "false"></igx-carousel>
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        this.navigation = true;
        /**
         * Controls whether the carousel should support keyboard navigation.
         * Default value is `true`.
         * ```html
         * <igx-carousel [keyboardSupport] = "false"></igx-carousel>
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        this.keyboardSupport = true;
        /**
         * Controls whether the carousel should support gestures.
         * Default value is `true`.
         * ```html
         * <igx-carousel [gesturesSupport] = "false"></igx-carousel>
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        this.gesturesSupport = true;
        /**
         * Controls the maximum indexes that can be shown.
         * Default value is `5`.
         * ```html
         * <igx-carousel [maximumIndicatorsCount] = "10"></igx-carousel>
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        this.maximumIndicatorsCount = 5;
        /**
         * Gets/sets the display mode of carousel indicators. It can be top or bottom.
         * Default value is `bottom`.
         * ```html
         * <igx-carousel indicatorsOrientation='top'>
         * <igx-carousel>
         * ```
         *
         * @memberOf IgxSlideComponent
         */
        this.indicatorsOrientation = CarouselIndicatorsOrientation.bottom;
        /**
         * Gets/sets the animation type of carousel.
         * Default value is `slide`.
         * ```html
         * <igx-carousel animationType='none'>
         * <igx-carousel>
         * ```
         *
         * @memberOf IgxSlideComponent
         */
        this.animationType = CarouselAnimationType.slide;
        /**
         * The custom template, if any, that should be used when rendering carousel indicators
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.carousel.indicatorTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-carousel #carousel>
         *      ...
         *      <ng-template igxCarouselIndicator let-slide>
         *         <igx-icon *ngIf="slide.active">brightness_7</igx-icon>
         *         <igx-icon *ngIf="!slide.active">brightness_5</igx-icon>
         *      </ng-template>
         *  </igx-carousel>
         * ```
         */
        this.indicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering carousel next button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.carousel.nextButtonTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-carousel #carousel>
         *      ...
         *      <ng-template igxCarouselNextButton let-disabled>
         *            <button igxButton="fab" igxRipple="white" [disabled]="disabled">
         *                <igx-icon>add</igx-icon>
         *           </button>
         *      </ng-template>
         *  </igx-carousel>
         * ```
         */
        this.nextButtonTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering carousel previous button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.carousel.nextButtonTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-carousel #carousel>
         *      ...
         *      <ng-template igxCarouselPrevButton let-disabled>
         *            <button igxButton="fab" igxRipple="white" [disabled]="disabled">
         *                <igx-icon>remove</igx-icon>
         *           </button>
         *      </ng-template>
         *  </igx-carousel>
         * ```
         */
        this.prevButtonTemplate = null;
        /**
         * An event that is emitted after a slide transition has happened.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideChanged)="onSlideChanged($event)"></igx-carousel>
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        this.onSlideChanged = new EventEmitter();
        /**
         * An event that is emitted after a slide has been added to the carousel.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideAdded)="onSlideAdded($event)"></igx-carousel>
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        this.onSlideAdded = new EventEmitter();
        /**
         * An event that is emitted after a slide has been removed from the carousel.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideRemoved)="onSlideRemoved($event)"></igx-carousel>
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        this.onSlideRemoved = new EventEmitter();
        /**
         * An event that is emitted after the carousel has been paused.
         * Provides a reference to the `IgxCarouselComponent` as an event argument.
         * ```html
         * <igx-carousel (onCarouselPaused)="onCarouselPaused($event)"></igx-carousel>
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        this.onCarouselPaused = new EventEmitter();
        /**
         * An event that is emitted after the carousel has resumed transitioning between `slides`.
         * Provides a reference to the `IgxCarouselComponent` as an event argument.
         * ```html
         * <igx-carousel (onCarouselPlaying)="onCarouselPlaying($event)"></igx-carousel>
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        this.onCarouselPlaying = new EventEmitter();
        this._resourceStrings = CurrentResourceStrings.CarouselResStrings;
        this.destroy$ = new Subject();
        this.differ = null;
        this.animationDuration = 320;
        this.animationPosition = 0;
        this.newDuration = 0;
        this.differ = this.iterableDiffers.find([]).create(null);
    }
    /** @hidden */
    get labelId() {
        return this.showIndicatorsLabel ? `${this.id}-label` : null;
    }
    /**
     * Gets the `touch-action` style of the `list item`.
     * ```typescript
     * let touchAction = this.listItem.touchAction;
     * ```
     */
    get touchAction() {
        return this.gesturesSupport ? 'pan-y' : 'auto';
    }
    /**
     * An accessor that sets the resource strings.
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /** @hidden */
    get getIndicatorTemplate() {
        if (this.indicatorTemplate) {
            return this.indicatorTemplate;
        }
        return this.defaultIndicator;
    }
    /** @hidden */
    get getNextButtonTemplate() {
        if (this.nextButtonTemplate) {
            return this.nextButtonTemplate;
        }
        return this.defaultNextButton;
    }
    /** @hidden */
    get getPrevButtonTemplate() {
        if (this.prevButtonTemplate) {
            return this.prevButtonTemplate;
        }
        return this.defaultPrevButton;
    }
    /** @hidden */
    get indicatorsOrientationClass() {
        return `igx-carousel-indicators--${this.indicatorsOrientation}`;
    }
    /** @hidden */
    get showIndicators() {
        return this.total <= this.maximumIndicatorsCount && this.total > 0;
    }
    /** @hidden */
    get showIndicatorsLabel() {
        return this.total > this.maximumIndicatorsCount;
    }
    /** @hidden */
    get getCarouselLabel() {
        return `${this.current + 1} ${this.resourceStrings.igx_carousel_of} ${this.total}`;
    }
    /**
     * Returns the total number of `slides` in the carousel.
     * ```typescript
     * let slideCount =  this.carousel.total;
     * ```
     *
     * @memberOf IgxCarouselComponent
     */
    get total() {
        var _a;
        return (_a = this.slides) === null || _a === void 0 ? void 0 : _a.length;
    }
    /**
     * The index of the slide being currently shown.
     * ```typescript
     * let currentSlideNumber =  this.carousel.current;
     * ```
     *
     * @memberOf IgxCarouselComponent
     */
    get current() {
        return !this.currentSlide ? 0 : this.currentSlide.index;
    }
    /**
     * Returns a boolean indicating if the carousel is playing.
     * ```typescript
     * let isPlaying =  this.carousel.isPlaying;
     * ```
     *
     * @memberOf IgxCarouselComponent
     */
    get isPlaying() {
        return this.playing;
    }
    /**
     * Returns а boolean indicating if the carousel is destroyed.
     * ```typescript
     * let isDestroyed =  this.carousel.isDestroyed;
     * ```
     *
     * @memberOf IgxCarouselComponent
     */
    get isDestroyed() {
        return this.destroyed;
    }
    /**
     * Returns a reference to the carousel element in the DOM.
     * ```typescript
     * let nativeElement =  this.carousel.nativeElement;
     * ```
     *
     * @memberof IgxCarouselComponent
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * Returns the time `interval` in milliseconds before the slide changes.
     * ```typescript
     * let timeInterval = this.carousel.interval;
     * ```
     *
     * @memberof IgxCarouselComponent
     */
    get interval() {
        return this._interval;
    }
    /**
     * Sets the time `interval` in milliseconds before the slide changes.
     * If not set, the carousel will not change `slides` automatically.
     * ```html
     * <igx-carousel [interval] = "1000"></igx-carousel>
     * ```
     *
     * @memberof IgxCarouselComponent
     */
    set interval(value) {
        this._interval = +value;
        this.restartInterval();
    }
    /** @hidden */
    onKeydownArrowRight(event) {
        if (this.keyboardSupport) {
            event.preventDefault();
            this.next();
            requestAnimationFrame(() => this.slides.find(s => s.active).nativeElement.focus());
        }
    }
    /** @hidden */
    onKeydownArrowLeft(event) {
        if (this.keyboardSupport) {
            event.preventDefault();
            this.prev();
            requestAnimationFrame(() => this.slides.find(s => s.active).nativeElement.focus());
        }
    }
    /** @hidden */
    onTap(event) {
        // play pause only when tap on slide
        if (event.target && event.target.classList.contains('igx-slide')) {
            if (this.isPlaying) {
                if (this.pause) {
                    this.stoppedByInteraction = true;
                }
                this.stop();
            }
            else if (this.stoppedByInteraction) {
                this.play();
            }
        }
    }
    /** @hidden */
    onKeydownHome(event) {
        if (this.keyboardSupport && this.slides.length > 0) {
            event.preventDefault();
            this.slides.first.active = true;
            requestAnimationFrame(() => this.slides.find(s => s.active).nativeElement.focus());
        }
    }
    /** @hidden */
    onKeydownEnd(event) {
        if (this.keyboardSupport && this.slides.length > 0) {
            event.preventDefault();
            this.slides.last.active = true;
            requestAnimationFrame(() => this.slides.find(s => s.active).nativeElement.focus());
        }
    }
    /** @hidden */
    onMouseEnter() {
        if (this.pause && this.isPlaying) {
            this.stoppedByInteraction = true;
        }
        this.stop();
    }
    /** @hidden */
    onMouseLeave() {
        if (this.stoppedByInteraction) {
            this.play();
        }
    }
    /** @hidden */
    onPanLeft(event) {
        this.pan(event);
    }
    /** @hidden */
    onPanRight(event) {
        this.pan(event);
    }
    /**
     * @hidden
     */
    onPanEnd(event) {
        if (!this.gesturesSupport) {
            return;
        }
        event.preventDefault();
        const slideWidth = this.currentSlide.nativeElement.offsetWidth;
        const panOffset = (slideWidth / 1000);
        const deltaX = Math.abs(event.deltaX) + panOffset < slideWidth ? Math.abs(event.deltaX) : slideWidth - panOffset;
        const velocity = Math.abs(event.velocity);
        this.resetSlideStyles(this.currentSlide);
        if (this.incomingSlide) {
            this.resetSlideStyles(this.incomingSlide);
            if (slideWidth / 2 < deltaX || velocity > 1) {
                this.incomingSlide.direction = event.deltaX < 0 ? Direction$1.NEXT : Direction$1.PREV;
                this.incomingSlide.previous = false;
                this.animationPosition = this.animationType === CarouselAnimationType.fade ?
                    deltaX / slideWidth : (slideWidth - deltaX) / slideWidth;
                if (velocity > 1) {
                    this.newDuration = this.animationDuration / velocity;
                }
                this.incomingSlide.active = true;
            }
            else {
                this.currentSlide.direction = event.deltaX > 0 ? Direction$1.NEXT : Direction$1.PREV;
                this.previousSlide = this.incomingSlide;
                this.previousSlide.previous = true;
                this.animationPosition = this.animationType === CarouselAnimationType.fade ?
                    Math.abs((slideWidth - deltaX) / slideWidth) : deltaX / slideWidth;
                this.playAnimations();
            }
        }
        if (this.stoppedByInteraction) {
            this.play();
        }
    }
    /** @hidden */
    ngAfterContentInit() {
        this.slides.changes
            .pipe(takeUntil(this.destroy$))
            .subscribe((change) => this.initSlides(change));
        this.initSlides(this.slides);
    }
    /** @hidden */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
        this.destroyed = true;
        if (this.lastInterval) {
            clearInterval(this.lastInterval);
        }
    }
    /**
     * Returns the slide corresponding to the provided `index` or null.
     * ```typescript
     * let slide1 =  this.carousel.get(1);
     * ```
     *
     * @memberOf IgxCarouselComponent
     */
    get(index) {
        return this.slides.find((slide) => slide.index === index);
    }
    /**
     * Adds a new slide to the carousel.
     * ```typescript
     * this.carousel.add(newSlide);
     * ```
     *
     * @memberOf IgxCarouselComponent
     */
    add(slide) {
        const newSlides = this.slides.toArray();
        newSlides.push(slide);
        this.slides.reset(newSlides);
        this.slides.notifyOnChanges();
    }
    /**
     * Removes a slide from the carousel.
     * ```typescript
     * this.carousel.remove(slide);
     * ```
     *
     * @memberOf IgxCarouselComponent
     */
    remove(slide) {
        if (slide && slide === this.get(slide.index)) { // check if the requested slide for delete is present in the carousel
            const newSlides = this.slides.toArray();
            newSlides.splice(slide.index, 1);
            this.slides.reset(newSlides);
            this.slides.notifyOnChanges();
        }
    }
    /**
     * Kicks in a transition for a given slide with a given `direction`.
     * ```typescript
     * this.carousel.select(this.carousel.get(2), Direction.NEXT);
     * ```
     *
     * @memberOf IgxCarouselComponent
     */
    select(slide, direction = Direction$1.NONE) {
        if (slide && slide !== this.currentSlide) {
            slide.direction = direction;
            slide.active = true;
        }
    }
    /**
     * Transitions to the next slide in the carousel.
     * ```typescript
     * this.carousel.next();
     * ```
     *
     * @memberOf IgxCarouselComponent
     */
    next() {
        const index = this.getNextIndex();
        if (index === 0 && !this.loop) {
            this.stop();
            return;
        }
        return this.select(this.get(index), Direction$1.NEXT);
    }
    /**
     * Transitions to the previous slide in the carousel.
     * ```typescript
     * this.carousel.prev();
     * ```
     *
     * @memberOf IgxCarouselComponent
     */
    prev() {
        const index = this.getPrevIndex();
        if (!this.loop && index === this.total - 1) {
            this.stop();
            return;
        }
        return this.select(this.get(index), Direction$1.PREV);
    }
    /**
     * Resumes playing of the carousel if in paused state.
     * No operation otherwise.
     * ```typescript
     * this.carousel.play();
     * }
     * ```
     *
     * @memberOf IgxCarouselComponent
     */
    play() {
        if (!this.playing) {
            this.playing = true;
            this.onCarouselPlaying.emit(this);
            this.restartInterval();
            this.stoppedByInteraction = false;
        }
    }
    /**
     * Stops slide transitions if the `pause` option is set to `true`.
     * No operation otherwise.
     * ```typescript
     *  this.carousel.stop();
     * }
     * ```
     *
     * @memberOf IgxCarouselComponent
     */
    stop() {
        if (this.pause) {
            this.playing = false;
            this.onCarouselPaused.emit(this);
            this.resetInterval();
        }
    }
    resetInterval() {
        if (this.lastInterval) {
            clearInterval(this.lastInterval);
            this.lastInterval = null;
        }
    }
    restartInterval() {
        this.resetInterval();
        if (!isNaN(this.interval) && this.interval > 0 && this.platformUtil.isBrowser) {
            this.lastInterval = setInterval(() => {
                const tick = +this.interval;
                if (this.playing && this.total && !isNaN(tick) && tick > 0) {
                    this.next();
                }
                else {
                    this.stop();
                }
            }, this.interval);
        }
    }
    /** @hidden */
    get nextButtonDisabled() {
        return !this.loop && this.current === (this.total - 1);
    }
    /** @hidden */
    get prevButtonDisabled() {
        return !this.loop && this.current === 0;
    }
    getNextIndex() {
        return (this.current + 1) % this.total;
    }
    getPrevIndex() {
        return this.current - 1 < 0 ? this.total - 1 : this.current - 1;
    }
    resetSlideStyles(slide) {
        slide.nativeElement.style.transform = '';
        slide.nativeElement.style.opacity = '';
    }
    pan(event) {
        const slideWidth = this.currentSlide.nativeElement.offsetWidth;
        const panOffset = (slideWidth / 1000);
        const deltaX = event.deltaX;
        const index = deltaX < 0 ? this.getNextIndex() : this.getPrevIndex();
        const offset = deltaX < 0 ? slideWidth + deltaX : -slideWidth + deltaX;
        if (!this.gesturesSupport || event.isFinal || Math.abs(deltaX) + panOffset >= slideWidth) {
            return;
        }
        if (!this.loop && ((this.current === 0 && deltaX > 0) || (this.current === this.total - 1 && deltaX < 0))) {
            this.incomingSlide = null;
            return;
        }
        event.preventDefault();
        if (this.isPlaying) {
            this.stoppedByInteraction = true;
            this.stop();
        }
        if (this.previousSlide && this.previousSlide.previous) {
            this.previousSlide.previous = false;
        }
        this.finishAnimations();
        if (this.incomingSlide) {
            if (index !== this.incomingSlide.index) {
                this.resetSlideStyles(this.incomingSlide);
                this.incomingSlide.previous = false;
                this.incomingSlide = this.get(index);
            }
        }
        else {
            this.incomingSlide = this.get(index);
        }
        this.incomingSlide.previous = true;
        if (this.animationType === CarouselAnimationType.fade) {
            this.currentSlide.nativeElement.style.opacity = `${Math.abs(offset) / slideWidth}`;
        }
        else {
            this.currentSlide.nativeElement.style.transform = `translateX(${deltaX}px)`;
            this.incomingSlide.nativeElement.style.transform = `translateX(${offset}px)`;
        }
    }
    unsubscriber(slide) {
        return merge(this.destroy$, slide.isDestroyed);
    }
    onSlideActivated(slide) {
        if (slide.active && slide !== this.currentSlide) {
            if (slide.direction === Direction$1.NONE) {
                const newIndex = slide.index;
                slide.direction = newIndex > this.current ? Direction$1.NEXT : Direction$1.PREV;
            }
            if (this.currentSlide) {
                if (this.previousSlide && this.previousSlide.previous) {
                    this.previousSlide.previous = false;
                }
                this.currentSlide.direction = slide.direction;
                this.currentSlide.active = false;
                this.previousSlide = this.currentSlide;
                this.currentSlide = slide;
                if (this.animationType !== CarouselAnimationType.none) {
                    if (this.animationStarted(this.leaveAnimationPlayer) || this.animationStarted(this.enterAnimationPlayer)) {
                        requestAnimationFrame(() => {
                            this.resetAnimations();
                            this.playAnimations();
                        });
                    }
                    else {
                        this.playAnimations();
                    }
                }
            }
            else {
                this.currentSlide = slide;
            }
            this.onSlideChanged.emit({ carousel: this, slide });
            this.restartInterval();
        }
    }
    playAnimations() {
        this.playLeaveAnimation();
        this.playEnterAnimation();
    }
    finishAnimations() {
        if (this.animationStarted(this.leaveAnimationPlayer)) {
            this.leaveAnimationPlayer.finish();
        }
        if (this.animationStarted(this.enterAnimationPlayer)) {
            this.enterAnimationPlayer.finish();
        }
    }
    resetAnimations() {
        if (this.animationStarted(this.leaveAnimationPlayer)) {
            this.leaveAnimationPlayer.reset();
        }
        if (this.animationStarted(this.enterAnimationPlayer)) {
            this.enterAnimationPlayer.reset();
        }
    }
    animationStarted(animation) {
        return animation && animation.hasStarted();
    }
    getAnimation() {
        let duration;
        if (this.newDuration) {
            duration = this.animationPosition ? this.animationPosition * this.newDuration : this.newDuration;
        }
        else {
            duration = this.animationPosition ? this.animationPosition * this.animationDuration : this.animationDuration;
        }
        switch (this.animationType) {
            case CarouselAnimationType.slide:
                const trans = this.animationPosition ? this.animationPosition * 100 : 100;
                return {
                    enterAnimation: useAnimation(slideInLeft, {
                        params: {
                            delay: '0s',
                            duration: `${duration}ms`,
                            endOpacity: 1,
                            startOpacity: 1,
                            fromPosition: `translateX(${this.currentSlide.direction === 1 ? trans : -trans}%)`,
                            toPosition: 'translateX(0%)'
                        }
                    }),
                    leaveAnimation: useAnimation(slideInLeft, {
                        params: {
                            delay: '0s',
                            duration: `${duration}ms`,
                            endOpacity: 1,
                            startOpacity: 1,
                            fromPosition: `translateX(0%)`,
                            toPosition: `translateX(${this.currentSlide.direction === 1 ? -trans : trans}%)`,
                        }
                    })
                };
            case CarouselAnimationType.fade:
                return {
                    enterAnimation: useAnimation(fadeIn, { params: { duration: `${duration}ms`, startOpacity: `${this.animationPosition}` } }),
                    leaveAnimation: null
                };
        }
        return {
            enterAnimation: null,
            leaveAnimation: null
        };
    }
    playEnterAnimation() {
        const animation = this.getAnimation().enterAnimation;
        if (!animation) {
            return;
        }
        const animationBuilder = this.builder.build(animation);
        this.enterAnimationPlayer = animationBuilder.create(this.currentSlide.nativeElement);
        this.enterAnimationPlayer.onDone(() => {
            if (this.enterAnimationPlayer) {
                this.enterAnimationPlayer.reset();
                this.enterAnimationPlayer = null;
            }
            this.animationPosition = 0;
            this.newDuration = 0;
            this.previousSlide.previous = false;
        });
        this.previousSlide.previous = true;
        this.enterAnimationPlayer.play();
    }
    playLeaveAnimation() {
        const animation = this.getAnimation().leaveAnimation;
        if (!animation) {
            return;
        }
        const animationBuilder = this.builder.build(animation);
        this.leaveAnimationPlayer = animationBuilder.create(this.previousSlide.nativeElement);
        this.leaveAnimationPlayer.onDone(() => {
            if (this.leaveAnimationPlayer) {
                this.leaveAnimationPlayer.reset();
                this.leaveAnimationPlayer = null;
            }
            this.animationPosition = 0;
            this.newDuration = 0;
        });
        this.leaveAnimationPlayer.play();
    }
    initSlides(change) {
        const diff = this.differ.diff(change.toArray());
        if (diff) {
            this.slides.reduce((any, c, ind) => c.index = ind, 0); // reset slides indexes
            diff.forEachAddedItem((record) => {
                const slide = record.item;
                slide.total = this.total;
                this.onSlideAdded.emit({ carousel: this, slide });
                if (slide.active) {
                    this.currentSlide = slide;
                }
                slide.activeChange.pipe(takeUntil(this.unsubscriber(slide))).subscribe(() => this.onSlideActivated(slide));
            });
            diff.forEachRemovedItem((record) => {
                const slide = record.item;
                this.onSlideRemoved.emit({ carousel: this, slide });
                if (slide.active) {
                    slide.active = false;
                    this.currentSlide = this.get(slide.index < this.total ? slide.index : this.total - 1);
                }
            });
            this.updateSlidesSelection();
        }
    }
    updateSlidesSelection() {
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(() => {
                if (this.currentSlide) {
                    this.currentSlide.active = true;
                    const activeSlides = this.slides.filter(slide => slide.active && slide.index !== this.currentSlide.index);
                    activeSlides.forEach(slide => slide.active = false);
                }
                else if (this.total) {
                    this.slides.first.active = true;
                }
                this.play();
            });
        }
    }
}
IgxCarouselComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    {
                        provide: HAMMER_GESTURE_CONFIG,
                        useClass: CarouselHammerConfig
                    }
                ],
                selector: 'igx-carousel',
                template: "<ng-template #defaultIndicator let-slide>\n    <div class=\"igx-nav-dot\"\n        [class.igx-nav-dot--active]=\"slide.active\">\n    </div>\n</ng-template>\n\n<ng-template #defaultNextButton let-disabled>\n    <span class=\"igx-nav-arrow\"\n          [class.igx-nav-arrow--disabled]=\"disabled\">\n        <igx-icon>arrow_forward</igx-icon>\n    </span>\n</ng-template>\n\n<ng-template #defaultPrevButton let-disabled>\n    <span class=\"igx-nav-arrow\"\n          [class.igx-nav-arrow--disabled]=\"disabled\">\n        <igx-icon>arrow_back</igx-icon>\n    </span>\n</ng-template>\n\n<div *ngIf=\"showIndicators\" [ngClass]=\"indicatorsOrientationClass\" [attr.role]=\"'tablist'\">\n    <div *ngFor=\"let slide of slides\"\n        class=\"igx-carousel-indicators__indicator\"\n        (click)=\"select(slide)\"\n        [id]=\"'tab-'+ slide.index + '-' + total\"\n        [attr.role]=\"'tab'\"\n        [attr.aria-label]=\"resourceStrings.igx_carousel_slide + ' ' + (slide.index + 1) + ' ' + resourceStrings.igx_carousel_of + ' ' + this.total\"\n        [attr.aria-controls]=\"'panel-' + slide.index\"\n        [attr.aria-selected]=\"slide.active\">\n        <ng-container *ngTemplateOutlet=\"getIndicatorTemplate; context: {$implicit: slide};\"></ng-container>\n    </div>\n</div>\n\n<div *ngIf=\"showIndicatorsLabel\" [ngClass]=\"indicatorsOrientationClass\">\n    <span [id]=\"labelId\" class=\"igx-carousel__label\">{{getCarouselLabel}}</span>\n</div>\n\n<div class=\"igx-carousel__inner\" [attr.aria-live]=\"!interval || stoppedByInteraction ? 'polite' : 'off'\">\n    <ng-content></ng-content>\n</div>\n\n<div *ngIf=\"navigation && slides.length\" role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--prev\" [attr.aria-label]=\"resourceStrings.igx_carousel_previous_slide\" (keydown.enter)=\"prev()\" (click)=\"prev()\">\n    <ng-container *ngTemplateOutlet=\"getPrevButtonTemplate; context: {$implicit: prevButtonDisabled};\"></ng-container>\n</div>\n\n<div *ngIf=\"navigation && slides.length\" role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--next\" [attr.aria-label]=\"resourceStrings.igx_carousel_next_slide\" (keydown.enter)=\"next()\" (click)=\"next()\">\n    <ng-container *ngTemplateOutlet=\"getNextButtonTemplate; context: {$implicit: nextButtonDisabled};\"></ng-container>\n</div>\n\n\n\n",
                styles: [`
    :host {
        display: block;
        outline-style: none;
    }`]
            },] }
];
IgxCarouselComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IterableDiffers },
    { type: AnimationBuilder },
    { type: PlatformUtil }
];
IgxCarouselComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    roleDescription: [{ type: HostBinding, args: ['attr.aria-roledescription',] }],
    labelId: [{ type: HostBinding, args: ['attr.aria-labelledby',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-carousel',] }],
    touchAction: [{ type: HostBinding, args: ['style.touch-action',] }],
    loop: [{ type: Input }],
    pause: [{ type: Input }],
    navigation: [{ type: Input }],
    keyboardSupport: [{ type: Input }],
    gesturesSupport: [{ type: Input }],
    maximumIndicatorsCount: [{ type: Input }],
    indicatorsOrientation: [{ type: Input }],
    animationType: [{ type: Input }],
    indicatorTemplate: [{ type: ContentChild, args: [IgxCarouselIndicatorDirective, { read: TemplateRef, static: false },] }],
    nextButtonTemplate: [{ type: ContentChild, args: [IgxCarouselNextButtonDirective, { read: TemplateRef, static: false },] }],
    prevButtonTemplate: [{ type: ContentChild, args: [IgxCarouselPrevButtonDirective, { read: TemplateRef, static: false },] }],
    slides: [{ type: ContentChildren, args: [IgxSlideComponent,] }],
    onSlideChanged: [{ type: Output }],
    onSlideAdded: [{ type: Output }],
    onSlideRemoved: [{ type: Output }],
    onCarouselPaused: [{ type: Output }],
    onCarouselPlaying: [{ type: Output }],
    defaultIndicator: [{ type: ViewChild, args: ['defaultIndicator', { read: TemplateRef, static: true },] }],
    defaultNextButton: [{ type: ViewChild, args: ['defaultNextButton', { read: TemplateRef, static: true },] }],
    defaultPrevButton: [{ type: ViewChild, args: ['defaultPrevButton', { read: TemplateRef, static: true },] }],
    resourceStrings: [{ type: Input }],
    interval: [{ type: Input }],
    onKeydownArrowRight: [{ type: HostListener, args: ['keydown.arrowright', ['$event'],] }],
    onKeydownArrowLeft: [{ type: HostListener, args: ['keydown.arrowleft', ['$event'],] }],
    onTap: [{ type: HostListener, args: ['tap', ['$event'],] }],
    onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }],
    onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }],
    onPanLeft: [{ type: HostListener, args: ['panleft', ['$event'],] }],
    onPanRight: [{ type: HostListener, args: ['panright', ['$event'],] }],
    onPanEnd: [{ type: HostListener, args: ['panend', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxCarouselModule {
}
IgxCarouselModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxCarouselComponent,
                    IgxSlideComponent,
                    IgxCarouselIndicatorDirective,
                    IgxCarouselNextButtonDirective,
                    IgxCarouselPrevButtonDirective
                ],
                exports: [
                    IgxCarouselComponent,
                    IgxSlideComponent,
                    IgxCarouselIndicatorDirective,
                    IgxCarouselNextButtonDirective,
                    IgxCarouselPrevButtonDirective
                ],
                imports: [CommonModule, IgxIconModule]
            },] }
];

let CHIP_ID = 0;
/**
 * Chip is compact visual component that displays information in an obround.
 *
 * @igxModule IgxChipsModule
 *
 * @igxTheme igx-chip-theme
 *
 * @igxKeywords chip
 *
 * @igxGroup display
 *
 * @remarks
 * The Ignite UI Chip can be templated, deleted, and selected.
 * Multiple chips can be reordered and visually connected to each other.
 * Chips reside in a container called chips area which is responsible for managing the interactions between the chips.
 *
 * @example
 * ```html
 * <igx-chip class="chipStyle" [id]="901" [draggable]="true" [removable]="true" (remove)="chipRemoved($event)">
 *    <igx-avatar class="chip-avatar-resized" igxPrefix roundShape="true"></igx-avatar>
 * </igx-chip>
 * ```
 */
class IgxChipComponent extends DisplayDensityBase {
    constructor(cdr, elementRef, renderer, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         *
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'"></igx-chip>
         * ```
         */
        this.id = `igx-chip-${CHIP_ID++}`;
        /**
         * An @Input property that defines if the `IgxChipComponent` can be dragged in order to change it's position.
         * By default it is set to false.
         *
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true"></igx-chip>
         * ```
         */
        this.draggable = false;
        /**
         * An @Input property that enables/disables the draggable element animation when the element is released.
         * By default it's set to true.
         *
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [animateOnRelease]="false"></igx-chip>
         * ```
         */
        this.animateOnRelease = true;
        /**
         * An @Input property that enables/disables the hiding of the base element that has been dragged.
         * By default it's set to true.
         *
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [hideBaseOnDrag]="false"></igx-chip>
         * ```
         */
        this.hideBaseOnDrag = true;
        /**
         * An @Input property that defines if the `IgxChipComponent` should render remove button and throw remove events.
         * By default it is set to false.
         *
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [removable]="true"></igx-chip>
         * ```
         */
        this.removable = false;
        /**
         * An @Input property that defines if the `IgxChipComponent` can be selected on click or through navigation,
         * By default it is set to false.
         *
         * @example
         * ```html
         * <igx-chip [id]="chip.id" [draggable]="true" [removable]="true" [selectable]="true"></igx-chip>
         * ```
         */
        this.selectable = false;
        /**
         * @hidden
         * @internal
         */
        this.class = '';
        /**
         * An @Input property that defines if the `IgxChipComponent` is disabled. When disabled it restricts user interactions
         * like focusing on click or tab, selection on click or Space, dragging.
         * By default it is set to false.
         *
         * @example
         * ```html
         * <igx-chip [id]="chip.id" [disabled]="true"></igx-chip>
         * ```
         */
        this.disabled = false;
        /**
         * @hidden
         * @internal
         */
        this.selectedChange = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` moving starts.
         * Returns the moving `IgxChipComponent`.
         *
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (moveStart)="moveStarted($event)">
         * ```
         */
        this.moveStart = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` moving ends.
         * Returns the moved `IgxChipComponent`.
         *
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (moveEnd)="moveEnded($event)">
         * ```
         */
        this.moveEnd = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` is removed.
         * Returns the removed `IgxChipComponent`.
         *
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (remove)="remove($event)">
         * ```
         */
        this.remove = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` is clicked.
         * Returns the clicked `IgxChipComponent`, whether the event should be canceled.
         *
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (click)="chipClick($event)">
         * ```
         */
        this.chipClick = new EventEmitter();
        /**
         * Emits event when the `IgxChipComponent` is selected/deselected.
         * Returns the selected chip reference, whether the event should be canceled, what is the next selection state and
         * when the event is triggered by interaction `originalEvent` is provided, otherwise `originalEvent` is `null`.
         *
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (selectedChanging)="chipSelect($event)">
         * ```
         */
        this.selectedChanging = new EventEmitter();
        /**
         * Emits event when the `IgxChipComponent` is selected/deselected and any related animations and transitions also end.
         *
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (selectedChanged)="chipSelectEnd($event)">
         * ```
         */
        this.selectedChanged = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` keyboard navigation is being used.
         * Returns the focused/selected `IgxChipComponent`, whether the event should be canceled,
         * if the `alt`, `shift` or `control` key is pressed and the pressed key name.
         *
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (keyDown)="chipKeyDown($event)">
         * ```
         */
        this.keyDown = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` has entered the `IgxChipsAreaComponent`.
         * Returns the target `IgxChipComponent`, the drag `IgxChipComponent`, as  well as
         * the original drop event arguments.
         *
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onDragEnter)="chipEnter($event)">
         * ```
         */
        this.dragEnter = new EventEmitter();
        /**
         * @hidden
         * @internal
         */
        this.hideBaseElement = false;
        this._tabIndex = null;
        this._selected = false;
        this._selectedItemClass = 'igx-chip__item--selected';
        this._movedWhileRemoving = false;
    }
    /**
     * An @Input property that sets the value of `tabindex` attribute. If not provided it will use the element's tabindex if set.
     *
     * @example
     * ```html
     * <igx-chip [id]="'igx-chip-1'" [tabIndex]="1"></igx-chip>
     * ```
     */
    set tabIndex(value) {
        this._tabIndex = value;
    }
    get tabIndex() {
        if (this._tabIndex !== null) {
            return this._tabIndex;
        }
        return !this.disabled ? 0 : null;
    }
    /**
     * Sets the `IgxChipComponent` selected state.
     *
     * @example
     * ```html
     * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [selected]="true">
     * ```
     *
     * Two-way data binding:
     * ```html
     * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [(selected)]="model.isSelected">
     * ```
     */
    set selected(newValue) {
        this.changeSelection(newValue);
    }
    /**
     * Returns if the `IgxChipComponent` is selected.
     *
     * @example
     * ```typescript
     * @ViewChild('myChip')
     * public chip: IgxChipComponent;
     * selectedChip(){
     *     let selectedChip = this.chip.selected;
     * }
     * ```
     */
    get selected() {
        return this._selected;
    }
    /**
     * An @Input property that sets the `IgxChipComponent` background color.
     * The `color` property supports string, rgb, hex.
     *
     * @example
     * ```html
     * <igx-chip #myChip [id]="'igx-chip-1'" [color]="'#ff0000'"></igx-chip>
     * ```
     */
    set color(newColor) {
        this.chipArea.nativeElement.style.backgroundColor = newColor;
    }
    /**
     * Returns the background color of the `IgxChipComponent`.
     *
     * @example
     * ```typescript
     * @ViewChild('myChip')
     * public chip: IgxChipComponent;
     * ngAfterViewInit(){
     *     let chipColor = this.chip.color;
     * }
     * ```
     */
    get color() {
        return this.chipArea.nativeElement.style.backgroundColor;
    }
    /**
     * @hidden
     * @internal
     */
    get hostClass() {
        const classes = [this.getComponentDensityClass('igx-chip')];
        classes.push(this.disabled ? 'igx-chip--disabled' : '');
        // The custom classes should be at the end.
        classes.push(this.class);
        return classes.join(' ');
    }
    /**
     * @hidden
     * @internal
     */
    get removeButtonTemplate() {
        return this.removeIcon || this.defaultRemoveIcon;
    }
    /**
     * @hidden
     * @internal
     */
    get selectIconTemplate() {
        return this.selectIcon || this.defaultSelectIcon;
    }
    /**
     * @hidden
     * @internal
     */
    get ghostClass() {
        return this.getComponentDensityClass('igx-chip__ghost');
    }
    /**
     * @hidden
     * @internal
     */
    keyEvent(event) {
        this.onChipKeyDown(event);
    }
    /**
     * @hidden
     * @internal
     */
    selectClass(condition) {
        const SELECT_CLASS = 'igx-chip__select';
        return {
            [SELECT_CLASS]: condition,
            [`${SELECT_CLASS}--hidden`]: !condition
        };
    }
    onSelectTransitionDone(event) {
        if (!!event.target.tagName) {
            // Trigger onSelectionDone on when `width` property is changed and the target is valid element(not comment).
            this.selectedChanged.emit({
                owner: this,
                originalEvent: event
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    onChipKeyDown(event) {
        const keyDownArgs = {
            originalEvent: event,
            owner: this,
            cancel: false
        };
        this.keyDown.emit(keyDownArgs);
        if (keyDownArgs.cancel) {
            return;
        }
        if ((event.key === 'Delete' || event.key === 'Del') && this.removable) {
            this.remove.emit({
                originalEvent: event,
                owner: this
            });
        }
        if ((event.key === ' ' || event.key === 'Spacebar') && this.selectable && !this.disabled) {
            this.changeSelection(!this.selected, event);
        }
        if (event.key !== 'Tab') {
            event.preventDefault();
        }
    }
    /**
     * @hidden
     * @internal
     */
    onRemoveBtnKeyDown(event) {
        if (event.key === ' ' || event.key === 'Spacebar' || event.key === 'Enter') {
            this.remove.emit({
                originalEvent: event,
                owner: this
            });
            event.preventDefault();
            event.stopPropagation();
        }
    }
    onRemoveMouseDown(event) {
        event.stopPropagation();
    }
    /**
     * @hidden
     * @internal
     */
    onRemoveClick(event) {
        this.remove.emit({
            originalEvent: event,
            owner: this
        });
    }
    /**
     * @hidden
     * @internal
     */
    onRemoveTouchMove() {
        // We don't remove chip if user starting touch interacting on the remove button moves the chip
        this._movedWhileRemoving = true;
    }
    /**
     * @hidden
     * @internal
     */
    onRemoveTouchEnd(event) {
        if (!this._movedWhileRemoving) {
            this.onRemoveClick(event);
        }
        this._movedWhileRemoving = false;
    }
    /**
     * @hidden
     * @internal
     */
    // -----------------------------
    // Start chip igxDrag behavior
    onChipDragStart(event) {
        this.moveStart.emit({
            originalEvent: event,
            owner: this
        });
        event.cancel = !this.draggable || this.disabled;
    }
    /**
     * @hidden
     * @internal
     */
    onChipDragEnd() {
        if (this.animateOnRelease) {
            this.dragDirective.transitionToOrigin();
        }
    }
    /**
     * @hidden
     * @internal
     */
    onChipMoveEnd(event) {
        // moveEnd is triggered after return animation has finished. This happen when we drag and release the chip.
        this.moveEnd.emit({
            originalEvent: event,
            owner: this
        });
        if (this.selected) {
            this.chipArea.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * @internal
     */
    onChipGhostCreate() {
        this.hideBaseElement = this.hideBaseOnDrag;
    }
    /**
     * @hidden
     * @internal
     */
    onChipGhostDestroy() {
        this.hideBaseElement = false;
    }
    /**
     * @hidden
     * @internal
     */
    onChipDragClicked(event) {
        const clickEventArgs = {
            originalEvent: event,
            owner: this,
            cancel: false
        };
        this.chipClick.emit(clickEventArgs);
        if (!clickEventArgs.cancel && this.selectable && !this.disabled) {
            this.changeSelection(!this.selected, event);
        }
    }
    // End chip igxDrag behavior
    /**
     * @hidden
     * @internal
     */
    // -----------------------------
    // Start chip igxDrop behavior
    onChipDragEnterHandler(event) {
        if (this.dragDirective === event.drag || !event.drag.data || !event.drag.data.chip) {
            return;
        }
        const eventArgs = {
            owner: this,
            dragChip: event.drag.data.chip,
            originalEvent: event
        };
        this.dragEnter.emit(eventArgs);
    }
    /**
     * @hidden
     * @internal
     */
    onChipDrop(event) {
        // Cancel the default drop logic
        event.cancel = true;
    }
    // End chip igxDrop behavior
    changeSelection(newValue, srcEvent = null) {
        const onSelectArgs = {
            originalEvent: srcEvent,
            owner: this,
            selected: false,
            cancel: false
        };
        fromEvent(this.selectContainer.nativeElement, 'transitionend')
            .pipe(filter(event => event.propertyName === 'width'), take(1))
            .subscribe(event => this.onSelectTransitionDone(event));
        if (newValue && !this._selected) {
            onSelectArgs.selected = true;
            this.selectedChanging.emit(onSelectArgs);
            if (!onSelectArgs.cancel) {
                this.renderer.addClass(this.chipArea.nativeElement, this._selectedItemClass);
                this._selected = newValue;
                this.selectedChange.emit(this._selected);
            }
        }
        else if (!newValue && this._selected) {
            this.selectedChanging.emit(onSelectArgs);
            if (!onSelectArgs.cancel) {
                this.renderer.removeClass(this.chipArea.nativeElement, this._selectedItemClass);
                this._selected = newValue;
                this.selectedChange.emit(this._selected);
            }
        }
    }
}
IgxChipComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-chip',
                template: "<div #chipArea class=\"igx-chip__item\"\n    [igxDrag]=\"{chip: this}\"\n    [style.visibility]='hideBaseElement ? \"hidden\" : \"visible\"'\n    [ghostClass]=\"ghostClass\"\n    (dragStart)=\"onChipDragStart($event)\"\n    (ghostCreate)=\"onChipGhostCreate()\"\n    (ghostDestroy)=\"onChipGhostDestroy()\"\n    (dragEnd)=\"onChipDragEnd()\"\n    (transitioned)=\"onChipMoveEnd($event)\"\n    (dragClick)=\"onChipDragClicked($event)\"\n    igxDrop\n    (enter)=\"onChipDragEnterHandler($event)\"\n    (dropped)=\"onChipDrop($event)\">\n\n    <div #selectContainer [ngClass]=\"selectClass(selected)\">\n        <ng-container *ngTemplateOutlet=\"selectIconTemplate\"></ng-container>\n    </div>\n\n    <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n\n    <div class=\"igx-chip__content\">\n        <ng-content></ng-content>\n    </div>\n\n    <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n\n    <div class=\"igx-chip__remove\" *ngIf=\"removable\"\n        [attr.tabIndex]=\"tabIndex\"\n        (keydown)=\"onRemoveBtnKeyDown($event)\"\n        (pointerdown)=\"onRemoveMouseDown($event)\"\n        (mousedown)=\"onRemoveMouseDown($event)\"\n        (click)=\"onRemoveClick($event)\"\n        (touchmove)=\"onRemoveTouchMove()\"\n        (touchend)=\"onRemoveTouchEnd($event)\">\n        <ng-container *ngTemplateOutlet=\"removeButtonTemplate\"></ng-container>\n    </div>\n</div>\n\n<ng-template #defaultSelectIcon>\n    <igx-icon>done</igx-icon>\n</ng-template>\n\n<ng-template #defaultRemoveIcon>\n    <igx-icon>cancel</igx-icon>\n</ng-template>\n"
            },] }
];
IgxChipComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxChipComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabIndex',] }, { type: Input }],
    data: [{ type: Input }],
    draggable: [{ type: Input }],
    animateOnRelease: [{ type: Input }],
    hideBaseOnDrag: [{ type: Input }],
    removable: [{ type: Input }],
    removeIcon: [{ type: Input }],
    selectable: [{ type: Input }],
    selectIcon: [{ type: Input }],
    class: [{ type: Input }],
    disabled: [{ type: Input }],
    selected: [{ type: Input }],
    selectedChange: [{ type: Output }],
    color: [{ type: Input }],
    moveStart: [{ type: Output }],
    moveEnd: [{ type: Output }],
    remove: [{ type: Output }],
    chipClick: [{ type: Output }],
    selectedChanging: [{ type: Output }],
    selectedChanged: [{ type: Output }],
    keyDown: [{ type: Output }],
    dragEnter: [{ type: Output }],
    hostClass: [{ type: HostBinding, args: ['attr.class',] }],
    dragDirective: [{ type: ViewChild, args: ['chipArea', { read: IgxDragDirective, static: true },] }],
    chipArea: [{ type: ViewChild, args: ['chipArea', { read: ElementRef, static: true },] }],
    selectContainer: [{ type: ViewChild, args: ['selectContainer', { read: ElementRef, static: true },] }],
    defaultRemoveIcon: [{ type: ViewChild, args: ['defaultRemoveIcon', { read: TemplateRef, static: true },] }],
    defaultSelectIcon: [{ type: ViewChild, args: ['defaultSelectIcon', { read: TemplateRef, static: true },] }],
    keyEvent: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * The chip area allows you to perform more complex scenarios with chips that require interaction,
 * like dragging, selection, navigation, etc.
 *
 * @igxModule IgxChipsModule
 *
 * @igxTheme igx-chip-theme
 *
 * @igxKeywords chip area, chip
 *
 * @igxGroup display
 *
 * @example
 * ```html
 * <igx-chips-area>
 *    <igx-chip *ngFor="let chip of chipList" [id]="chip.id">
 *        <span>{{chip.text}}</span>
 *    </igx-chip>
 * </igx-chips-area>
 * ```
 */
class IgxChipsAreaComponent {
    constructor(cdr, element, _iterableDiffers) {
        this.cdr = cdr;
        this.element = element;
        this._iterableDiffers = _iterableDiffers;
        /**
         * @hidden
         * @internal
         */
        this.class = '';
        /**
         * Emits an event when `IgxChipComponent`s in the `IgxChipsAreaComponent` should be reordered.
         * Returns an array of `IgxChipComponent`s.
         *
         * @example
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onReorder)="changedOrder($event)"></igx-chips-area>
         * ```
         */
        this.reorder = new EventEmitter();
        /**
         * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is selected/deselected.
         * Fired after the chips area is initialized if there are initially selected chips as well.
         * Returns an array of selected `IgxChipComponent`s and the `IgxChipAreaComponent`.
         *
         * @example
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (selectionChange)="selection($event)"></igx-chips-area>
         * ```
         */
        this.selectionChange = new EventEmitter();
        /**
         * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
         *
         * @example
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (moveStart)="moveStart($event)"></igx-chips-area>
         * ```
         */
        this.moveStart = new EventEmitter();
        /**
         * Emits an event after an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
         *
         * @example
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (moveEnd)="moveEnd($event)"></igx-chips-area>
         * ```
         */
        this.moveEnd = new EventEmitter();
        this.destroy$ = new Subject();
        this._differ = null;
        this._differ = this._iterableDiffers.find([]).create(null);
    }
    /**
     * @hidden
     * @internal
     */
    get hostClass() {
        const classes = ['igx-chip-area'];
        classes.push(this.class);
        return classes.join(' ');
    }
    /**
     * @hidden
     * @internal
     */
    ngAfterViewInit() {
        // If we have initially selected chips through their inputs, we need to get them, because we cannot listen to their events yet.
        if (this.chipsList.length) {
            const selectedChips = this.chipsList.filter((item) => item.selected);
            if (selectedChips.length) {
                this.selectionChange.emit({
                    originalEvent: null,
                    newSelection: selectedChips,
                    owner: this
                });
            }
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngDoCheck() {
        if (this.chipsList) {
            const changes = this._differ.diff(this.chipsList.toArray());
            if (changes) {
                changes.forEachAddedItem((addedChip) => {
                    addedChip.item.moveStart.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                        this.onChipMoveStart(args);
                    });
                    addedChip.item.moveEnd.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                        this.onChipMoveEnd(args);
                    });
                    addedChip.item.dragEnter.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                        this.onChipDragEnter(args);
                    });
                    addedChip.item.keyDown.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                        this.onChipKeyDown(args);
                    });
                    if (addedChip.item.selectable) {
                        addedChip.item.selectedChanging.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                            this.onChipSelectionChange(args);
                        });
                    }
                });
                this.modifiedChipsArray = this.chipsList.toArray();
            }
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     * @internal
     */
    onChipKeyDown(event) {
        let orderChanged = false;
        const chipsArray = this.chipsList.toArray();
        const dragChipIndex = chipsArray.findIndex((el) => el === event.owner);
        if (event.originalEvent.shiftKey === true) {
            if (event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') {
                orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex - 1, false, event.originalEvent);
                if (orderChanged) {
                    setTimeout(() => {
                        this.chipsList.toArray()[dragChipIndex - 1].elementRef.nativeElement.focus();
                    });
                }
            }
            else if (event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') {
                orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex + 1, true, event.originalEvent);
            }
        }
        else {
            if ((event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') && dragChipIndex > 0) {
                chipsArray[dragChipIndex - 1].elementRef.nativeElement.focus();
            }
            else if ((event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') &&
                dragChipIndex < chipsArray.length - 1) {
                chipsArray[dragChipIndex + 1].elementRef.nativeElement.focus();
            }
        }
    }
    /**
     * @hidden
     * @internal
     */
    onChipMoveStart(event) {
        this.moveStart.emit({
            originalEvent: event.originalEvent,
            owner: this
        });
    }
    /**
     * @hidden
     * @internal
     */
    onChipMoveEnd(event) {
        this.moveEnd.emit({
            originalEvent: event.originalEvent,
            owner: this
        });
    }
    /**
     * @hidden
     * @internal
     */
    onChipDragEnter(event) {
        const dropChipIndex = this.chipsList.toArray().findIndex((el) => el === event.owner);
        const dragChipIndex = this.chipsList.toArray().findIndex((el) => el === event.dragChip);
        if (dragChipIndex < dropChipIndex) {
            // from the left to right
            this.positionChipAtIndex(dragChipIndex, dropChipIndex, true, event.originalEvent);
        }
        else {
            // from the right to left
            this.positionChipAtIndex(dragChipIndex, dropChipIndex, false, event.originalEvent);
        }
    }
    /**
     * @hidden
     * @internal
     */
    positionChipAtIndex(chipIndex, targetIndex, shiftRestLeft, originalEvent) {
        if (chipIndex < 0 || this.chipsList.length <= chipIndex ||
            targetIndex < 0 || this.chipsList.length <= targetIndex) {
            return false;
        }
        const chipsArray = this.chipsList.toArray();
        const result = [];
        for (let i = 0; i < chipsArray.length; i++) {
            if (shiftRestLeft) {
                if (chipIndex <= i && i < targetIndex) {
                    result.push(chipsArray[i + 1]);
                }
                else if (i === targetIndex) {
                    result.push(chipsArray[chipIndex]);
                }
                else {
                    result.push(chipsArray[i]);
                }
            }
            else {
                if (targetIndex < i && i <= chipIndex) {
                    result.push(chipsArray[i - 1]);
                }
                else if (i === targetIndex) {
                    result.push(chipsArray[chipIndex]);
                }
                else {
                    result.push(chipsArray[i]);
                }
            }
        }
        this.modifiedChipsArray = result;
        const eventData = {
            chipsArray: this.modifiedChipsArray,
            originalEvent,
            owner: this
        };
        this.reorder.emit(eventData);
        return true;
    }
    /**
     * @hidden
     * @internal
     */
    onChipSelectionChange(event) {
        let selectedChips = this.chipsList.filter((chip) => chip.selected);
        if (event.selected && !selectedChips.includes(event.owner)) {
            selectedChips.push(event.owner);
        }
        else if (!event.selected && selectedChips.includes(event.owner)) {
            selectedChips = selectedChips.filter((chip) => chip.id !== event.owner.id);
        }
        this.selectionChange.emit({
            originalEvent: event.originalEvent,
            newSelection: selectedChips,
            owner: this
        });
    }
}
IgxChipsAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-chips-area',
                template: "<ng-content></ng-content>\n"
            },] }
];
IgxChipsAreaComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: IterableDiffers }
];
IgxChipsAreaComponent.propDecorators = {
    class: [{ type: Input }],
    hostClass: [{ type: HostBinding, args: ['attr.class',] }],
    width: [{ type: HostBinding, args: ['style.width.px',] }, { type: Input }],
    height: [{ type: HostBinding, args: ['style.height.px',] }, { type: Input }],
    reorder: [{ type: Output }],
    selectionChange: [{ type: Output }],
    moveStart: [{ type: Output }],
    moveEnd: [{ type: Output }],
    chipsList: [{ type: ContentChildren, args: [IgxChipComponent, { descendants: true },] }]
};

/**
 * @hidden
 */
class IgxChipsModule {
}
IgxChipsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxChipsAreaComponent,
                    IgxChipComponent
                ],
                exports: [
                    IgxChipsAreaComponent,
                    IgxChipComponent,
                    IgxPrefixDirective,
                    IgxSuffixDirective
                ],
                imports: [
                    CommonModule,
                    IgxRippleModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxAvatarModule,
                    IgxDragDropModule,
                    IgxPrefixModule,
                    IgxSuffixModule
                ]
            },] }
];

/**
 * @hidden
 */
class IgxComboHeaderDirective {
}
IgxComboHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxComboHeader]'
            },] }
];
/**
 * @hidden
 */
class IgxComboFooterDirective {
}
IgxComboFooterDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxComboFooter]'
            },] }
];
/**
 * @hidden
 */
class IgxComboItemDirective {
}
IgxComboItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxComboItem]'
            },] }
];
/**
 * @hidden
 */
class IgxComboEmptyDirective {
}
IgxComboEmptyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxComboEmpty]'
            },] }
];
/**
 * @hidden
 */
class IgxComboHeaderItemDirective {
}
IgxComboHeaderItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxComboHeaderItem]'
            },] }
];
/**
 * @hidden
 */
class IgxComboAddItemDirective {
}
IgxComboAddItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxComboAddItem]'
            },] }
];
/**
 * @hidden
 */
class IgxComboToggleIconDirective {
}
IgxComboToggleIconDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxComboToggleIcon]'
            },] }
];
/**
 * @hidden
 */
class IgxComboClearIconDirective {
}
IgxComboClearIconDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxComboClearIcon]'
            },] }
];

/**
 * @hidden
 */
class IgxComboAPIService {
    constructor() {
        this.disableTransitions = false;
    }
    get valueKey() {
        return this.combo.valueKey !== null && this.combo.valueKey !== undefined ? this.combo.valueKey : null;
    }
    get item_focusable() {
        return false;
    }
    get isRemote() {
        return this.combo.isRemote;
    }
    get comboID() {
        return this.combo.id;
    }
    register(combo) {
        this.combo = combo;
    }
    clear() {
        this.combo = null;
    }
    add_custom_item() {
        if (!this.combo) {
            return;
        }
        this.combo.addItemToCollection();
    }
    set_selected_item(itemID, event) {
        const selected = this.combo.isItemSelected(itemID);
        if (itemID === null || itemID === undefined) {
            return;
        }
        if (!selected) {
            this.combo.selectItems([itemID], false, event);
        }
        else {
            this.combo.deselectItems([itemID], event);
        }
    }
    is_item_selected(itemID) {
        return this.combo.isItemSelected(itemID);
    }
}
IgxComboAPIService.decorators = [
    { type: Injectable }
];

/** @hidden */
class IgxComboItemComponent extends IgxDropDownItemComponent {
    constructor(comboAPI, dropDown, elementRef, selection) {
        super(dropDown, elementRef, null, selection);
        this.comboAPI = comboAPI;
        this.dropDown = dropDown;
        this.elementRef = elementRef;
        this.selection = selection;
        /**
         * Gets the height of a list item
         *
         * @hidden
         */
        this.itemHeight = '';
    }
    /**
     * @hidden
     */
    get itemID() {
        const valueKey = this.comboAPI.valueKey;
        return valueKey !== null ? this.value[valueKey] : this.value;
    }
    /**
     * @hidden
     */
    get comboID() {
        return this.comboAPI.comboID;
    }
    /**
     * @hidden
     * @internal
     */
    get disableTransitions() {
        return this.comboAPI.disableTransitions;
    }
    /**
     * @hidden
     */
    get selected() {
        return this.comboAPI.is_item_selected(this.itemID);
    }
    set selected(value) {
        if (this.isHeader) {
            return;
        }
        this._selected = value;
    }
    /**
     * @hidden
     */
    isVisible(direction) {
        const rect = this.element.nativeElement.getBoundingClientRect();
        const parentDiv = this.element.nativeElement.parentElement.parentElement.getBoundingClientRect();
        if (direction === Navigate.Down) {
            return rect.y + rect.height <= parentDiv.y + parentDiv.height;
        }
        return rect.y >= parentDiv.y;
    }
    /**
     * @inheritdoc
     */
    clicked(event) {
        this.comboAPI.disableTransitions = false;
        if (!this.isSelectable) {
            return;
        }
        this.dropDown.navigateItem(this.index);
        this.comboAPI.set_selected_item(this.itemID, event);
    }
    /**
     * @hidden
     * @internal
     * The event that is prevented is the click on the checkbox label element.
     * That is the only visible element that a user can interact with.
     * The click propagates to the host and the preventDefault is to stop it from
     * switching focus to the input it's base on.
     * The toggle happens in an internal handler in the drop-down on the next task queue cycle.
     */
    disableCheck(event) {
        event.preventDefault();
    }
    ngDoCheck() {
    }
}
IgxComboItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-combo-item',
                template: "<ng-container *ngIf=\"!isHeader\">\n    <igx-checkbox [checked]=\"selected\" disableRipple=\"true\" [disableTransitions]=\"disableTransitions\" [tabindex]=\"-1\" (click)=\"disableCheck($event)\" class=\"igx-combo__checkbox\"></igx-checkbox>\n</ng-container>\n<span class=\"igx-drop-down__inner\"><ng-content></ng-content></span>\n"
            },] }
];
IgxComboItemComponent.ctorParameters = () => [
    { type: IgxComboAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DROPDOWN_BASE,] }] },
    { type: ElementRef },
    { type: IgxSelectionAPIService, decorators: [{ type: Inject, args: [IgxSelectionAPIService,] }] }
];
IgxComboItemComponent.propDecorators = {
    itemHeight: [{ type: Input }, { type: HostBinding, args: ['style.height.px',] }]
};

const IGX_COMBO_COMPONENT = new InjectionToken('IgxComboComponentToken');

/**
 * @hidden
 */
class IgxComboAddItemComponent extends IgxComboItemComponent {
    get selected() {
        return false;
    }
    set selected(value) {
    }
    /**
     * @inheritdoc
     */
    clicked(event) {
        this.comboAPI.disableTransitions = false;
        this.comboAPI.add_custom_item();
    }
}
IgxComboAddItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-combo-add-item',
                template: '<ng-content></ng-content>',
                providers: [{ provide: IgxComboItemComponent, useExisting: IgxComboAddItemComponent }]
            },] }
];

/** @hidden */
class IgxComboDropDownComponent extends IgxDropDownComponent {
    constructor(elementRef, cdr, selection, combo, comboAPI, _displayDensityOptions) {
        super(elementRef, cdr, selection, _displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this.combo = combo;
        this.comboAPI = comboAPI;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * @hidden
         * @internal
         */
        this.children = null;
        this.scrollHandler = () => {
            this.comboAPI.disableTransitions = true;
        };
    }
    /** @hidden @internal */
    get scrollContainer() {
        return this.virtDir.dc.location.nativeElement;
    }
    get isScrolledToLast() {
        const scrollTop = this.virtDir.scrollPosition;
        const scrollHeight = this.virtDir.getScroll().scrollHeight;
        return Math.floor(scrollTop + this.virtDir.igxForContainerSize) === scrollHeight;
    }
    get lastVisibleIndex() {
        return this.combo.totalItemCount ?
            Math.floor(this.combo.itemsMaxHeight / this.combo.itemHeight) :
            this.items.length - 1;
    }
    get sortedChildren() {
        if (this.children !== undefined) {
            return this.children.toArray()
                .sort((a, b) => a.index - b.index);
        }
        return null;
    }
    /**
     * Get all non-header items
     *
     * ```typescript
     * let myDropDownItems = this.dropdown.items;
     * ```
     */
    get items() {
        const items = [];
        if (this.children !== undefined) {
            const sortedChildren = this.sortedChildren;
            for (const child of sortedChildren) {
                if (!child.isHeader) {
                    items.push(child);
                }
            }
        }
        return items;
    }
    /**
     * @hidden @internal
     */
    onFocus() {
        this.focusedItem = this._focusedItem || this.items[0];
    }
    /**
     * @hidden @internal
     */
    onBlur(evt) {
        this.focusedItem = null;
    }
    /**
     * @hidden @internal
     */
    onToggleOpened() {
        this.onOpened.emit();
    }
    /**
     * @hidden
     */
    navigateFirst() {
        this.navigateItem(this.virtDir.igxForOf.findIndex(e => !e.isHeader));
    }
    /**
     * @hidden
     */
    navigatePrev() {
        if (this._focusedItem && this._focusedItem.index === 0 && this.virtDir.state.startIndex === 0) {
            this.combo.focusSearchInput(false);
        }
        else {
            super.navigatePrev();
        }
    }
    /**
     * @hidden
     */
    navigateNext() {
        const lastIndex = this.combo.totalItemCount ? this.combo.totalItemCount - 1 : this.virtDir.igxForOf.length - 1;
        if (this._focusedItem && this._focusedItem.index === lastIndex) {
            this.focusAddItemButton();
        }
        else {
            super.navigateNext();
        }
    }
    /**
     * @hidden @internal
     */
    selectItem(item) {
        if (item === null || item === undefined) {
            return;
        }
        this.comboAPI.set_selected_item(item.itemID);
        this._focusedItem = item;
    }
    /**
     * @hidden @internal
     */
    updateScrollPosition() {
        this.virtDir.getScroll().scrollTop = this._scrollPosition;
    }
    /**
     * @hidden @internal
     */
    onItemActionKey(key) {
        switch (key) {
            case DropDownActionKey.ENTER:
                this.handleEnter();
                break;
            case DropDownActionKey.SPACE:
                this.handleSpace();
                break;
            case DropDownActionKey.ESCAPE:
                this.close();
        }
    }
    ngAfterViewInit() {
        this.virtDir.getScroll().addEventListener('scroll', this.scrollHandler);
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.virtDir.getScroll().removeEventListener('scroll', this.scrollHandler);
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    scrollToHiddenItem(newItem) { }
    handleEnter() {
        if (this.isAddItemFocused()) {
            this.combo.addItemToCollection();
        }
        else {
            this.close();
        }
    }
    handleSpace() {
        if (this.isAddItemFocused()) {
            return;
        }
        else {
            this.selectItem(this.focusedItem);
        }
    }
    isAddItemFocused() {
        return this.focusedItem instanceof IgxComboAddItemComponent;
    }
    focusAddItemButton() {
        if (this.combo.isAddButtonVisible()) {
            this.focusedItem = this.items[this.items.length - 1];
        }
    }
}
IgxComboDropDownComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-combo-drop-down',
                template: "<div class=\"igx-drop-down__list\" [style.width]=\"width\"\nigxToggle\n(onAppended)=\"onToggleContentAppended()\"\n(onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n(onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <div class=\"igx-drop-down__list-scroll\" #scrollContainer [attr.id]=\"this.listId\" role=\"listbox\"\n    [style.height]=\"height\"\n    [style.maxHeight]=\"maxHeight\">\n        <ng-container *ngIf=\"!collapsed\">\n            <ng-content></ng-content>\n        </ng-container>\n    </div>\n</div>\n",
                providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxComboDropDownComponent }]
            },] }
];
IgxComboDropDownComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxSelectionAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IGX_COMBO_COMPONENT,] }] },
    { type: IgxComboAPIService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxComboDropDownComponent.propDecorators = {
    children: [{ type: ContentChildren, args: [IgxComboItemComponent, { descendants: true },] }]
};

/**
 * @hidden
 */
class IgxComboFilteringPipe {
    transform(collection, searchValue, displayKey, shouldFilter, filteringOptions) {
        if (!collection) {
            return [];
        }
        if (!searchValue || !shouldFilter) {
            return collection;
        }
        else {
            const searchTerm = filteringOptions.caseSensitive ? searchValue.trim() : searchValue.toLowerCase().trim();
            if (displayKey != null) {
                return collection.filter(e => filteringOptions.caseSensitive ? e[displayKey].includes(searchTerm) :
                    e[displayKey].toString().toLowerCase().includes(searchTerm));
            }
            else {
                return collection.filter(e => filteringOptions.caseSensitive ? e.includes(searchTerm) :
                    e.toLowerCase().includes(searchTerm));
            }
        }
    }
}
IgxComboFilteringPipe.decorators = [
    { type: Pipe, args: [{
                name: 'comboFiltering'
            },] }
];
/**
 * @hidden
 */
class IgxComboGroupingPipe {
    constructor(combo) {
        this.combo = combo;
    }
    transform(collection, groupKey, valueKey) {
        this.combo.filteredData = collection;
        if ((!groupKey && groupKey !== 0) || !collection.length) {
            return collection;
        }
        const sorted = DataUtil.sort(cloneArray(collection), [{
                fieldName: groupKey,
                dir: SortingDirection.Asc,
                ignoreCase: true,
                strategy: DefaultSortingStrategy.instance()
            }]);
        const data = cloneArray(sorted);
        let inserts = 0;
        let currentHeader = null;
        for (let i = 0; i < sorted.length; i++) {
            let insertFlag = 0;
            if (currentHeader !== sorted[i][groupKey]) {
                currentHeader = sorted[i][groupKey];
                insertFlag = 1;
            }
            if (insertFlag) {
                data.splice(i + inserts, 0, {
                    [valueKey]: currentHeader,
                    [groupKey]: currentHeader,
                    isHeader: true
                });
                inserts++;
            }
        }
        return data;
    }
}
IgxComboGroupingPipe.decorators = [
    { type: Pipe, args: [{
                name: 'comboGrouping'
            },] }
];
IgxComboGroupingPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_COMBO_COMPONENT,] }] }
];

/**
 * @hidden
 */
var DataTypes;
(function (DataTypes) {
    DataTypes["EMPTY"] = "empty";
    DataTypes["PRIMITIVE"] = "primitive";
    DataTypes["COMPLEX"] = "complex";
    DataTypes["PRIMARYKEY"] = "valueKey";
})(DataTypes || (DataTypes = {}));
/**
 * @hidden
 */
const ItemHeights = {
    comfortable: 40,
    cosy: 32,
    compact: 28,
};
/**
 * @hidden
 * The default number of items that should be in the combo's
 * drop-down list if no `[itemsMaxHeight]` is specified
 */
const itemsInContainer = 10;
var IgxComboState;
(function (IgxComboState) {
    /**
     * Combo with initial state.
     */
    IgxComboState[IgxComboState["INITIAL"] = 0] = "INITIAL";
    /**
     * Combo with valid state.
     */
    IgxComboState[IgxComboState["VALID"] = 1] = "VALID";
    /**
     * Combo with invalid state.
     */
    IgxComboState[IgxComboState["INVALID"] = 2] = "INVALID";
})(IgxComboState || (IgxComboState = {}));
/**
 * When called with sets A & B, returns A - B (as array);
 *
 * @hidden
 */
const diffInSets = (set1, set2) => {
    const results = [];
    set1.forEach(entry => {
        if (!set2.has(entry)) {
            results.push(entry);
        }
    });
    return results;
};
const ɵ0$3 = diffInSets;
let NEXT_ID$g = 0;
class IgxComboComponent extends DisplayDensityBase {
    constructor(elementRef, cdr, selection, comboAPI, _iconService, _displayDensityOptions, _inputGroupType, _injector) {
        super(_displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this.comboAPI = comboAPI;
        this._iconService = _iconService;
        this._displayDensityOptions = _displayDensityOptions;
        this._inputGroupType = _inputGroupType;
        this._injector = _injector;
        /**
         * Set custom overlay settings that control how the combo's list of items is displayed.
         * Set:
         * ```html
         * <igx-combo [overlaySettings] = "customOverlaySettings"></igx-combo>
         * ```
         *
         * ```typescript
         *  const customSettings = { positionStrategy: { settings: { target: myTarget } } };
         *  combo.overlaySettings = customSettings;
         * ```
         * Get any custom overlay settings used by the combo:
         * ```typescript
         *  const comboOverlaySettings: OverlaySettings = myCombo.overlaySettings;
         * ```
         */
        this.overlaySettings = null;
        /**
         * @hidden @internal
         */
        this.searchInput = null;
        /**
         * The custom template, if any, that should be used when rendering ITEMS in the combo list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.itemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboItem>
         *          <div class="custom-item" let-item let-key="valueKey">
         *              <div class="custom-item__name">{{ item[key] }}</div>
         *              <div class="custom-item__cost">{{ item.cost }}</div>
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.itemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the HEADER for the combo items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.headerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboHeader>
         *          <div class="combo__header">
         *              This is a custom header
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.headerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the FOOTER for the combo items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.footerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboFooter>
         *          <div class="combo__footer">
         *              This is a custom footer
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.footerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering HEADER ITEMS for groups in the combo list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.headerItemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboHeaderItem let-item let-key="groupKey">
         *          <div class="custom-item--group">Group header for {{ item[key] }}</div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.headerItemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.addItemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboAddItem>
         *          <button class="combo__add-button">
         *              Click to add item
         *          </button>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.addItemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.emptyTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboEmpty>
         *          <div class="combo--empty">
         *              There are no items to display
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.emptyTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the combo TOGGLE(open/close) button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.toggleIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboToggleIcon let-collapsed>
         *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.toggleIconTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the combo CLEAR button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.clearIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboClearIcon>
         *          <igx-icon>clear</igx-icon>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.clearIconTemplate = null;
        /**
         * Emitted when item selection is changing, before the selection completes
         *
         * ```html
         * <igx-combo (onSelectionChange)='handleSelection()'></igx-combo>
         * ```
         */
        this.onSelectionChange = new EventEmitter();
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-combo onOpening='handleOpening($event)'></igx-combo>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-combo (onOpened)='handleOpened()'></igx-combo>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-combo (onClosing)='handleClosing($event)'></igx-combo>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-combo (onClosed)='handleClosed()'></igx-combo>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted when an item is being added to the data collection
         *
         * ```html
         * <igx-combo (onAddition)='handleAdditionEvent()'></igx-combo>
         * ```
         */
        this.onAddition = new EventEmitter();
        /**
         * Emitted when the value of the search input changes (e.g. typing, pasting, clear, etc.)
         *
         * ```html
         * <igx-combo (onSearchInput)='handleSearchInputEvent()'></igx-combo>
         * ```
         */
        this.onSearchInput = new EventEmitter();
        /**
         * Emitted when new chunk of data is loaded from the virtualization
         *
         * ```html
         * <igx-combo (onDataPreLoad)='handleDataPreloadEvent()'></igx-combo>
         * ```
         */
        this.onDataPreLoad = new EventEmitter();
        /**
         * Gets/gets combo id.
         *
         * ```typescript
         * // get
         * let id = this.combo.id;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [id]='combo1'></igx-combo>
         * ```
         */
        this.id = `igx-combo-${NEXT_ID$g++}`;
        /**
         * @hidden @internal
         */
        this.cssClass = 'igx-combo'; // Independent of display density, at the time being
        /**
         * @hidden @internal
         */
        this.role = 'combobox';
        /**
         * Controls whether custom values can be added to the collection
         *
         * ```typescript
         * // get
         * let comboAllowsCustomValues = this.combo.allowCustomValues;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [allowCustomValues]='true'></igx-combo>
         * ```
         */
        this.allowCustomValues = false;
        /**
         * Defines the placeholder value for the combo dropdown search field
         *
         * ```typescript
         * // get
         * let myComboSearchPlaceholder = this.combo.searchPlaceholder;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [searchPlaceholder]='newPlaceHolder'></igx-combo>
         * ```
         */
        this.searchPlaceholder = 'Enter a Search Term';
        /**
         * Defines whether the caseSensitive icon should be shown in the search input
         *
         * ```typescript
         * // get
         * let myComboShowSearchCaseIcon = this.combo.showSearchCaseIcon;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [showSearchCaseIcon]='true'></igx-combo>
         * ```
         */
        this.showSearchCaseIcon = false;
        /**
         * Combo value data source property.
         *
         * ```typescript
         * // get
         * let myComboValueKey = this.combo.valueKey;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [valueKey]='myKey'></igx-combo>
         * ```
         */
        this.valueKey = null;
        /**
         * An @Input property that enabled/disables filtering in the list. The default is `true`.
         * ```html
         * <igx-combo [filterable]="false">
         * ```
         */
        this.filterable = true;
        /**
         * An @Input property that enabled/disables combo. The default is `false`.
         * ```html
         * <igx-combo [disabled]="'true'">
         * ```
         */
        this.disabled = false;
        /**
         * An @Input property that controls whether the combo's search box
         * should be focused after the `onOpened` event is called
         * When `false`, the combo's list item container will be focused instead
         */
        this.autoFocusSearch = true;
        this.dropdownContainer = null;
        /**
         * @hidden @internal
         */
        this.customValueFlag = true;
        /**
         * @hidden @internal
         */
        this.defaultFallbackGroup = 'Other';
        /**
         * @hidden @internal
         */
        this.filteringOptions = {
            caseSensitive: false
        };
        /**
         * @hidden @internal
         */
        this.filteringLogic = FilteringLogic.Or;
        /** @hidden @internal */
        this.filterValue = '';
        this.stringFilters = IgxStringFilteringOperand;
        this.booleanFilters = IgxBooleanFilteringOperand;
        this._groupKey = '';
        this._prevInputValue = '';
        this._dataType = '';
        this._searchValue = '';
        this._type = null;
        this.ngControl = null;
        this.destroy$ = new Subject();
        this._data = [];
        this._filteredData = [];
        this._itemHeight = null;
        this._itemsMaxHeight = null;
        this._remoteSelection = {};
        this._onChangeCallback = noop;
        this._onTouchedCallback = noop;
        this._value = '';
        this._valid = IgxComboState.INITIAL;
        this.onStatusChanged = () => {
            if ((this.ngControl.control.touched || this.ngControl.control.dirty) &&
                (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {
                if (!this.collapsed || this.inputGroup.isFocused) {
                    this.valid = this.ngControl.invalid ? IgxComboState.INVALID : IgxComboState.VALID;
                }
                else {
                    this.valid = this.ngControl.invalid ? IgxComboState.INVALID : IgxComboState.INITIAL;
                }
            }
            this.manageRequiredAsterisk();
        };
        this.comboAPI.register(this);
    }
    /**
     * @hidden @internal
     */
    get displaySearchInput() {
        return this.filterable || this.allowCustomValues;
    }
    /**
     * @hidden @internal
     */
    get ariaExpanded() {
        return !this.dropdown.collapsed;
    }
    /**
     * @hidden @internal
     */
    get hasPopUp() {
        return 'listbox';
    }
    /**
     * @hidden @internal
     */
    get ariaOwns() {
        return this.dropdown.id;
    }
    /**
     * Configures the drop down list height
     *
     * ```typescript
     * // get
     * let myComboItemsMaxHeight = this.combo.itemsMaxHeight;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-combo [itemsMaxHeight]='320'></igx-combo>
     * ```
     */
    get itemsMaxHeight() {
        if (this._itemsMaxHeight === null || this._itemsMaxHeight === undefined) {
            return this.itemHeight * itemsInContainer;
        }
        return this._itemsMaxHeight;
    }
    set itemsMaxHeight(val) {
        this._itemsMaxHeight = val;
    }
    /**
     * Configures the drop down list item height
     *
     * ```typescript
     * // get
     * let myComboItemHeight = this.combo.itemHeight;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-combo [itemHeight]='32'></igx-combo>
     * ```
     */
    get itemHeight() {
        if (this._itemHeight === null || this._itemHeight === undefined) {
            return ItemHeights[this.displayDensity];
        }
        return this._itemHeight;
    }
    set itemHeight(val) {
        this._itemHeight = val;
    }
    /**
     * @hidden @internal
     */
    get inputEmpty() {
        return !this.value && !this.placeholder;
    }
    /**
     * Combo data source.
     *
     * ```html
     * <!--set-->
     * <igx-combo [data]='items'></igx-combo>
     * ```
     */
    get data() {
        return this._data;
    }
    set data(val) {
        this._data = (val) ? val : [];
    }
    set displayKey(val) {
        this._displayKey = val;
    }
    /**
     * Combo text data source property.
     *
     * ```typescript
     * // get
     * let myComboDisplayKey = this.combo.displayKey;
     *
     * // set
     * this.combo.displayKey = 'val';
     *
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-combo [displayKey]='myDisplayKey'></igx-combo>
     * ```
     */
    get displayKey() {
        return this._displayKey ? this._displayKey : this.valueKey;
    }
    /**
     * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
     *
     * ```html
     * <!--set-->
     * <igx-combo [groupKey]='newGroupKey'></igx-combo>
     * ```
     */
    set groupKey(val) {
        this._groupKey = val;
    }
    /**
     * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
     *
     * ```typescript
     * // get
     * let currentGroupKey = this.combo.groupKey;
     * ```
     */
    get groupKey() {
        return this._groupKey;
    }
    /**
     * An @Input property that sets how the combo will be styled.
     * The allowed values are `line`, `box`, `border` and `search`. The default is `box`.
     * ```html
     * <igx-combo [type]="'line'">
     * ```
     */
    get type() {
        return this._type || this._inputGroupType || 'box';
    }
    set type(val) {
        this._type = val;
    }
    /**
     * Gets if control is valid, when used in a form
     *
     * ```typescript
     * // get
     * let valid = this.combo.valid;
     * ```
     */
    get valid() {
        return this._valid;
    }
    /**
     * Sets if control is valid, when used in a form
     *
     * ```typescript
     * // set
     * this.combo.valid = IgxComboState.INVALID;
     * ```
     */
    set valid(valid) {
        this._valid = valid;
        this.comboInput.valid = IgxInputState[IgxComboState[valid]];
    }
    /**
     * @hidden @internal
     */
    get searchValue() {
        return this._searchValue;
    }
    set searchValue(val) {
        this.filterValue = val;
        this._searchValue = val;
    }
    /**
     * @hidden @internal
     */
    onArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        this.open();
    }
    /**
     * @hidden @internal
     */
    onInputClick(event) {
        event.stopPropagation();
        event.preventDefault();
        if (!this.disabled) {
            this.toggle();
        }
    }
    /**
     * Defines the current state of the virtualized data. It contains `startIndex` and `chunkSize`
     *
     * ```typescript
     * // get
     * let state = this.combo.virtualizationState;
     * ```
     */
    get virtualizationState() {
        return this.virtDir.state;
    }
    /**
     * Sets the current state of the virtualized data.
     *
     * ```typescript
     * // set
     * this.combo.virtualizationState(state);
     * ```
     */
    set virtualizationState(state) {
        this.virtDir.state = state;
    }
    /**
     * Gets total count of the virtual data items, when using remote service.
     *
     * ```typescript
     * // get
     * let count = this.combo.totalItemCount;
     * ```
     */
    get totalItemCount() {
        return this.virtDir.totalItemCount;
    }
    /**
     * Sets total count of the virtual data items, when using remote service.
     *
     * ```typescript
     * // set
     * this.combo.totalItemCount(remoteService.count);
     * ```
     */
    set totalItemCount(count) {
        this.virtDir.totalItemCount = count;
    }
    /**
     * The text displayed in the combo input
     *
     * ```typescript
     * // get
     * let comboValue = this.combo.value;
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * @hidden @internal
     */
    get filteredData() {
        return this.filterable ? this._filteredData : this.data;
    }
    /**
     * @hidden @internal
     */
    set filteredData(val) {
        this._filteredData = this.groupKey ? (val || []).filter((e) => e.isHeader !== true) : val;
        this.checkMatch();
    }
    /**
     * @hidden @internal
     */
    handleKeyUp(event) {
        if (event.key === 'ArrowDown' || event.key === 'Down') {
            this.dropdown.focusedItem = this.dropdown.items[0];
            this.dropdownContainer.nativeElement.focus();
        }
        else if (event.key === 'Escape' || event.key === 'Esc') {
            this.toggle();
        }
    }
    /**
     * @hidden @internal
     */
    handleKeyDown(event) {
        if (event.key === 'ArrowUp' || event.key === 'Up') {
            event.preventDefault();
            event.stopPropagation();
            this.close();
        }
    }
    /**
     * @hidden @internal
     */
    handleInputChange(event) {
        if (event !== undefined) {
            const args = {
                searchText: event,
                owner: this,
                cancel: false
            };
            this.onSearchInput.emit(args);
            if (args.cancel) {
                this.filterValue = null;
            }
        }
        this.checkMatch();
    }
    /**
     * @hidden @internal
     */
    get dataType() {
        if (this.displayKey) {
            return DataTypes.COMPLEX;
        }
        return DataTypes.PRIMITIVE;
    }
    /**
     * @hidden @internal
     */
    get isRemote() {
        return this.totalItemCount > 0 &&
            this.valueKey &&
            this.dataType === DataTypes.COMPLEX;
    }
    /**
     * Returns if the specified itemID is selected
     *
     * @hidden
     * @internal
     */
    isItemSelected(item) {
        return this.selection.is_item_selected(this.id, item);
    }
    /**
     * Triggers change detection on the combo view
     */
    triggerCheck() {
        this.cdr.detectChanges();
    }
    /**
     * @hidden @internal
     */
    isAddButtonVisible() {
        // This should always return a boolean value. If this.searchValue was '', it returns '' instead of false;
        return this.searchValue !== '' && this.customValueFlag;
    }
    /**
     * @hidden @internal
     */
    handleSelectAll(evt) {
        if (evt.checked) {
            this.selectAllItems();
        }
        else {
            this.deselectAllItems();
        }
    }
    /**
     * @hidden @internal
     */
    addItemToCollection() {
        if (!this.searchValue) {
            return;
        }
        const newValue = this.searchValue.trim();
        const addedItem = this.displayKey ? {
            [this.valueKey]: newValue,
            [this.displayKey]: newValue
        } : newValue;
        if (this.groupKey) {
            Object.assign(addedItem, { [this.groupKey]: this.defaultFallbackGroup });
        }
        const oldCollection = this.data;
        const newCollection = [...this.data];
        newCollection.push(addedItem);
        const args = {
            oldCollection, addedItem, newCollection, owner: this
        };
        this.onAddition.emit(args);
        this.data.push(addedItem);
        // If you mutate the array, no pipe is invoked and the display isn't updated;
        // if you replace the array, the pipe executes and the display is updated.
        this.data = cloneArray(this.data);
        this.selectItems(this.comboAPI.valueKey !== null ? [addedItem[this.valueKey]] : [addedItem], false);
        this.customValueFlag = false;
        this.searchInput.nativeElement.focus();
        this.dropdown.focusedItem = null;
        this.virtDir.scrollTo(0);
    }
    /**
     * @hidden @internal
     */
    focusSearchInput(opening) {
        if (this.displaySearchInput && this.searchInput) {
            this.searchInput.nativeElement.focus();
        }
        else {
            if (opening) {
                this.dropdownContainer.nativeElement.focus();
            }
            else {
                this.comboInput.nativeElement.focus();
                this.toggle();
            }
        }
    }
    /**
     * @hidden @internal
     */
    onBlur() {
        if (this.collapsed) {
            this._onTouchedCallback();
            if (this.ngControl && this.ngControl.invalid) {
                this.valid = IgxComboState.INVALID;
            }
            else {
                this.valid = IgxComboState.INITIAL;
            }
        }
    }
    /**
     * @hidden @internal
     */
    ngOnInit() {
        this.ngControl = this._injector.get(NgControl, null);
        const targetElement = this.elementRef.nativeElement;
        this._overlaySettings = {
            target: targetElement,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy(),
            modal: false,
            closeOnOutsideClick: true,
            excludeFromOutsideClick: [targetElement]
        };
        this.selection.set(this.id, new Set());
        this._iconService.addSvgIconFromText(caseSensitive.name, caseSensitive.value, 'imx-icons');
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        this.filteredData = [...this.data];
        if (this.ngControl) {
            this.ngControl.statusChanges.pipe(takeUntil(this.destroy$)).subscribe(this.onStatusChanged);
            this.manageRequiredAsterisk();
            this.cdr.detectChanges();
        }
        this.virtDir.onChunkPreload.pipe(takeUntil(this.destroy$)).subscribe((e) => {
            const eventArgs = Object.assign({}, e, { owner: this });
            this.onDataPreLoad.emit(eventArgs);
        });
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.comboAPI.clear();
        this.selection.clear(this.id);
    }
    /**
     * @hidden @internal
     */
    writeValue(value) {
        const selection = Array.isArray(value) ? value : [];
        const oldSelection = this.selectedItems();
        this.selection.select_items(this.id, selection, true);
        this._value = this.createDisplayText(this.selectedItems(), oldSelection);
    }
    /**
     * @hidden @internal
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden @internal
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden @internal
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    getEditElement() {
        return this.comboInput.nativeElement;
    }
    /**
     * @hidden @internal
     */
    get template() {
        this._dataType = this.dataType;
        if (this.itemTemplate) {
            return this.itemTemplate;
        }
        if (this._dataType === DataTypes.COMPLEX) {
            return this.complexTemplate;
        }
        return this.primitiveTemplate;
    }
    /**
     * @hidden @internal
     */
    get context() {
        return {
            $implicit: this
        };
    }
    /**
     * @hidden @internal
     */
    handleClearItems(event) {
        if (this.disabled) {
            return;
        }
        this.deselectAllItems(true, event);
        if (this.collapsed) {
            this.getEditElement().focus();
        }
        else {
            this.focusSearchInput(true);
        }
        event.stopPropagation();
    }
    /**
     * A method that opens/closes the combo.
     *
     * ```html
     * <button (click)="combo.toggle()">Toggle Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     */
    toggle() {
        const overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
        this.dropdown.toggle(overlaySettings);
    }
    /**
     * A method that opens the combo.
     *
     * ```html
     * <button (click)="combo.open()">Open Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     */
    open() {
        const overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
        this.dropdown.open(overlaySettings);
    }
    /**
     * A method that closes the combo.
     *
     * ```html
     * <button (click)="combo.close()">Close Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     */
    close() {
        this.dropdown.close();
    }
    /**
     * Gets drop down state.
     *
     * ```typescript
     * let state = this.combo.collapsed;
     * ```
     */
    get collapsed() {
        return this.dropdown.collapsed;
    }
    /**
     * Get current selection state
     *
     * @returns Array of selected items
     * ```typescript
     * let selectedItems = this.combo.selectedItems();
     * ```
     */
    selectedItems() {
        const items = Array.from(this.selection.get(this.id));
        return items;
    }
    /**
     * Select defined items
     *
     * @param newItems new items to be selected
     * @param clearCurrentSelection if true clear previous selected items
     * ```typescript
     * this.combo.selectItems(["New York", "New Jersey"]);
     * ```
     */
    selectItems(newItems, clearCurrentSelection, event) {
        if (newItems) {
            const newSelection = this.selection.add_items(this.id, newItems, clearCurrentSelection);
            this.setSelection(newSelection, event);
        }
    }
    /**
     * Deselect defined items
     *
     * @param items items to deselected
     * ```typescript
     * this.combo.deselectItems(["New York", "New Jersey"]);
     * ```
     */
    deselectItems(items, event) {
        if (items) {
            const newSelection = this.selection.delete_items(this.id, items);
            this.setSelection(newSelection, event);
        }
    }
    /**
     * Select all (filtered) items
     *
     * @param ignoreFilter if set to true, selects all items, otherwise selects only the filtered ones.
     * ```typescript
     * this.combo.selectAllItems();
     * ```
     */
    selectAllItems(ignoreFilter, event) {
        const allVisible = this.selection.get_all_ids(ignoreFilter ? this.data : this.filteredData, this.valueKey);
        const newSelection = this.selection.add_items(this.id, allVisible);
        this.setSelection(newSelection, event);
    }
    /**
     * Deselect all (filtered) items
     *
     * @param ignoreFilter if set to true, deselects all items, otherwise deselects only the filtered ones.
     * ```typescript
     * this.combo.deselectAllItems();
     * ```
     */
    deselectAllItems(ignoreFilter, event) {
        let newSelection = this.selection.get_empty();
        if (this.filteredData.length !== this.data.length && !ignoreFilter) {
            newSelection = this.selection.delete_items(this.id, this.selection.get_all_ids(this.filteredData, this.valueKey));
        }
        this.setSelection(newSelection, event);
    }
    /**
     * Selects/Deselects a single item
     *
     * @param itemID the itemID of the specific item
     * @param select If the item should be selected (true) or deselected (false)
     *
     * Without specified valueKey;
     * ```typescript
     * this.combo.valueKey = null;
     * const items: { field: string, region: string}[] = data;
     * this.combo.setSelectedItem(items[0], true);
     * ```
     * With specified valueKey;
     * ```typescript
     * this.combo.valueKey = 'field';
     * const items: { field: string, region: string}[] = data;
     * this.combo.setSelectedItem('Connecticut', true);
     * ```
     */
    setSelectedItem(itemID, select = true, event) {
        if (itemID === null || itemID === undefined) {
            return;
        }
        if (select) {
            this.selectItems([itemID], false, event);
        }
        else {
            this.deselectItems([itemID], event);
        }
    }
    /**
     * Event handlers
     *
     * @hidden
     * @internal
     */
    handleOpening(event) {
        const eventArgs = Object.assign({}, event, { owner: this });
        this.onOpening.emit(eventArgs);
        event.cancel = eventArgs.cancel;
    }
    /**
     * @hidden @internal
     */
    handleOpened() {
        this.triggerCheck();
        // Disabling focus of the search input should happen only when drop down opens.
        // During keyboard navigation input should receive focus, even the autoFocusSearch is disabled.
        // That is why in such cases focusing of the dropdownContainer happens outside focusSearchInput method.
        if (this.autoFocusSearch) {
            this.focusSearchInput(true);
        }
        else {
            this.dropdownContainer.nativeElement.focus();
        }
        this.onOpened.emit();
    }
    /**
     * @hidden @internal
     */
    handleClosing(event) {
        const eventArgs = Object.assign({}, event, { owner: this });
        this.onClosing.emit(eventArgs);
        event.cancel = eventArgs.cancel;
        if (event.cancel) {
            return;
        }
        this.searchValue = '';
        this.comboInput.nativeElement.focus();
    }
    /**
     * @hidden @internal
     */
    handleClosed() {
        this.onClosed.emit();
    }
    /**
     * @hidden @internal
     */
    toggleCaseSensitive() {
        this.filteringOptions = { caseSensitive: !this.filteringOptions.caseSensitive };
    }
    setSelection(newSelection, event) {
        const removed = diffInSets(this.selection.get(this.id), newSelection);
        const added = diffInSets(newSelection, this.selection.get(this.id));
        const newSelectionAsArray = Array.from(newSelection);
        const oldSelectionAsArray = Array.from(this.selection.get(this.id) || []);
        const displayText = this.createDisplayText(newSelectionAsArray, oldSelectionAsArray);
        const args = {
            newSelection: newSelectionAsArray,
            oldSelection: oldSelectionAsArray,
            added,
            removed,
            event,
            owner: this,
            displayText,
            cancel: false
        };
        this.onSelectionChange.emit(args);
        if (!args.cancel) {
            this.selection.select_items(this.id, args.newSelection, true);
            if (displayText !== args.displayText) {
                this._value = args.displayText;
            }
            else {
                this._value = this.createDisplayText(args.newSelection, args.oldSelection);
            }
            this._onChangeCallback(args.newSelection);
        }
    }
    manageRequiredAsterisk() {
        if (this.ngControl && this.ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            const error = this.ngControl.control.validator({});
            this.inputGroup.isRequired = error && error.required;
        }
    }
    /** Contains key-value pairs of the selected valueKeys and their resp. displayKeys */
    registerRemoteEntries(ids, add = true) {
        if (add) {
            const selection = this.getValueDisplayPairs(ids);
            for (const entry of selection) {
                this._remoteSelection[entry[this.valueKey]] = entry[this.displayKey];
            }
        }
        else {
            for (const entry of ids) {
                delete this._remoteSelection[entry];
            }
        }
    }
    /**
     * For `id: any[]` returns a mapped `{ [combo.valueKey]: any, [combo.displayKey]: any }[]`
     */
    getValueDisplayPairs(ids) {
        return this.data.filter(entry => ids.indexOf(entry[this.valueKey]) > -1).map(e => ({
            [this.valueKey]: e[this.valueKey],
            [this.displayKey]: e[this.displayKey]
        }));
    }
    checkMatch() {
        const displayKey = this.displayKey;
        const matchFn = (e) => {
            const value = displayKey ? e[displayKey] : e;
            return value.toString().toLowerCase() === this.searchValue.trim().toLowerCase();
        };
        const itemMatch = this.filteredData.some(matchFn);
        this.customValueFlag = this.allowCustomValues && !itemMatch;
    }
    /** Returns a string that should be populated in the combo's text box */
    concatDisplayText(selection) {
        const value = this.displayKey !== null && this.displayKey !== undefined ?
            this.convertKeysToItems(selection).map(entry => entry[this.displayKey]).join(', ') :
            selection.join(', ');
        return value;
    }
    /**
     * Constructs the combo display value
     * If remote, caches the key displayText
     * If not, just combine the object.displayKeys
     */
    createDisplayText(newSelection, oldSelection) {
        let value = '';
        if (this.isRemote) {
            if (newSelection.length) {
                const removedItems = oldSelection.filter(e => newSelection.indexOf(e) < 0);
                const addedItems = newSelection.filter(e => oldSelection.indexOf(e) < 0);
                this.registerRemoteEntries(addedItems);
                this.registerRemoteEntries(removedItems, false);
                value = Object.keys(this._remoteSelection).map(e => this._remoteSelection[e]).join(', ');
            }
            else {
                // If new selection is empty, clear all items
                this.registerRemoteEntries(oldSelection, false);
            }
        }
        else {
            value = this.concatDisplayText(newSelection);
        }
        return value;
    }
    /** if there is a valueKey - map the keys to data items, else - just return the keys */
    convertKeysToItems(keys) {
        if (this.comboAPI.valueKey === null) {
            return keys;
        }
        // map keys vs. filter data to retain the order of the selected items
        return keys.map(key => this.data.find(entry => entry[this.valueKey] === key)).filter(e => e !== undefined);
    }
}
IgxComboComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-combo',
                template: "<igx-input-group #inputGroup [displayDensity]=\"displayDensity\" [type]=\"type\" (click)=\"onInputClick($event)\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-hint, [igxHint]\">\n        <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n    </ng-container>\n    <input igxInput #comboInput name=\"comboInput\" type=\"text\" [value]=\"value\" readonly [attr.placeholder]=\"placeholder\"\n        [disabled]=\"disabled\" (blur)=\"onBlur()\" />\n    <ng-container ngProjectAs=\"igx-suffix\">\n        <ng-content select=\"igx-suffix\"></ng-content>\n    </ng-container>\n    <igx-suffix *ngIf=\"value.length\" aria-label=\"Clear Selection\" class=\"igx-combo__clear-button\"\n        (click)=\"handleClearItems($event)\">\n        <ng-container *ngIf=\"clearIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"clearIconTemplate\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!clearIconTemplate\">\n            clear\n        </igx-icon>\n    </igx-suffix>\n    <igx-suffix class=\"igx-combo__toggle-button\">\n        <ng-container *ngIf=\"toggleIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!toggleIconTemplate\">\n            {{ dropdown.collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}\n        </igx-icon>\n    </igx-suffix>\n</igx-input-group>\n<igx-combo-drop-down #igxComboDropDown class=\"igx-combo__drop-down\" [displayDensity]=\"displayDensity\"\n    [width]=\"itemsWidth || '100%'\" (onOpening)=\"handleOpening($event)\" (onClosing)=\"handleClosing($event)\"\n    (onOpened)=\"handleOpened()\" (onClosed)=\"handleClosed()\">\n    <igx-input-group *ngIf=\"displaySearchInput\" [displayDensity]=\"displayDensity\" class=\"igx-combo__search\">\n        <input class=\"igx-combo-input\" igxInput #searchInput name=\"searchInput\" autocomplete=\"off\" type=\"text\"\n            [(ngModel)]=\"searchValue\" (ngModelChange)=\"handleInputChange($event)\" (keyup)=\"handleKeyUp($event)\"\n            (keydown)=\"handleKeyDown($event)\" (focus)=\"dropdown.onBlur($event)\" [attr.placeholder]=\"searchPlaceholder\"\n            aria-autocomplete=\"both\" [attr.aria-owns]=\"dropdown.id\" [attr.aria-labelledby]=\"ariaLabelledBy\" />\n        <igx-suffix *ngIf=\"showSearchCaseIcon\">\n            <igx-icon family=\"imx-icons\" name=\"case-sensitive\" [active]=\"filteringOptions.caseSensitive\"\n                (click)=\"toggleCaseSensitive()\">\n            </igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n    <ng-container *ngTemplateOutlet=\"headerTemplate\">\n    </ng-container>\n    <div #dropdownItemContainer class=\"igx-combo__content\" [style.overflow]=\"'hidden'\"\n        [style.maxHeight.px]=\"itemsMaxHeight\" [igxDropDownItemNavigation]=\"dropdown\" (focus)=\"dropdown.onFocus()\"\n        [tabindex]=\"dropdown.collapsed ? -1 : 0\" role=\"listbox\" [attr.id]=\"dropdown.id\">\n        <igx-combo-item role=\"option\" [itemHeight]='itemHeight' *igxFor=\"let item of data\n            | comboFiltering:filterValue:displayKey:filterable:filteringOptions\n            | comboGrouping:groupKey:valueKey;\n            index as rowIndex; containerSize: itemsMaxHeight; scrollOrientation: 'vertical'; itemSize: itemHeight\"\n            [value]=\"item\" [isHeader]=\"item.isHeader\" [index]=\"rowIndex\">\n            <ng-container *ngIf=\"item.isHeader\">\n                <ng-container\n                    *ngTemplateOutlet=\"headerItemTemplate ? headerItemTemplate : headerItemBase;\n                    context: {$implicit: item, data: data, valueKey: valueKey, groupKey: groupKey, displayKey: displayKey}\">\n                </ng-container>\n            </ng-container>\n            <ng-container *ngIf=\"!item.isHeader\">\n                <ng-container #listItem\n                    *ngTemplateOutlet=\"template; context: {$implicit: item, data: data, valueKey: valueKey, displayKey: displayKey};\">\n                </ng-container>\n            </ng-container>\n        </igx-combo-item>\n    </div>\n    <div class=\"igx-combo__add\" *ngIf=\"filteredData.length === 0 || isAddButtonVisible()\">\n        <div class=\"igx-combo__empty\" *ngIf=\"filteredData.length === 0\">\n            <ng-container *ngTemplateOutlet=\"emptyTemplate ? emptyTemplate : empty\">\n            </ng-container>\n        </div>\n        <igx-combo-add-item [itemHeight]='itemHeight' *ngIf=\"isAddButtonVisible()\"\n            [tabindex]=\"dropdown.collapsed ? -1 : customValueFlag ? 1 : -1\" class=\"igx-combo__add-item\" role=\"button\"\n            aria-label=\"Add Item\" [index]=\"virtualScrollContainer.igxForOf.length\">\n            <ng-container *ngTemplateOutlet=\"addItemTemplate ? addItemTemplate : addItemDefault\">\n            </ng-container>\n        </igx-combo-add-item>\n    </div>\n    <ng-container *ngTemplateOutlet=\"footerTemplate\">\n    </ng-container>\n</igx-combo-drop-down>\n<ng-template #complex let-display let-data=\"data\" let-key=\"displayKey\">\n    {{display[key]}}\n</ng-template>\n<ng-template #primitive let-display>\n    {{display}}\n</ng-template>\n<ng-template #empty>\n    <span>The list is empty</span>\n</ng-template>\n<ng-template #addItemDefault let-control>\n    <button igxButton=\"flat\" igxRipple>Add item</button>\n</ng-template>\n<ng-template #headerItemBase let-item let-key=\"valueKey\" let-groupKey=\"groupKey\">\n    {{ item[key] }}\n</ng-template>\n",
                providers: [
                    IgxComboAPIService,
                    { provide: IGX_COMBO_COMPONENT, useExisting: IgxComboComponent },
                    { provide: NG_VALUE_ACCESSOR, useExisting: IgxComboComponent, multi: true }
                ]
            },] }
];
IgxComboComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxSelectionAPIService },
    { type: IgxComboAPIService },
    { type: IgxIconService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [IGX_INPUT_GROUP_TYPE,] }] },
    { type: Injector, decorators: [{ type: Optional }] }
];
IgxComboComponent.propDecorators = {
    overlaySettings: [{ type: Input }],
    inputGroup: [{ type: ViewChild, args: ['inputGroup', { read: IgxInputGroupComponent, static: true },] }],
    comboInput: [{ type: ViewChild, args: ['comboInput', { read: IgxInputDirective, static: true },] }],
    dropdown: [{ type: ViewChild, args: [IgxComboDropDownComponent, { read: IgxComboDropDownComponent, static: true },] }],
    searchInput: [{ type: ViewChild, args: ['searchInput',] }],
    itemTemplate: [{ type: ContentChild, args: [IgxComboItemDirective, { read: TemplateRef },] }],
    headerTemplate: [{ type: ContentChild, args: [IgxComboHeaderDirective, { read: TemplateRef },] }],
    footerTemplate: [{ type: ContentChild, args: [IgxComboFooterDirective, { read: TemplateRef },] }],
    headerItemTemplate: [{ type: ContentChild, args: [IgxComboHeaderItemDirective, { read: TemplateRef },] }],
    addItemTemplate: [{ type: ContentChild, args: [IgxComboAddItemDirective, { read: TemplateRef },] }],
    emptyTemplate: [{ type: ContentChild, args: [IgxComboEmptyDirective, { read: TemplateRef },] }],
    toggleIconTemplate: [{ type: ContentChild, args: [IgxComboToggleIconDirective, { read: TemplateRef },] }],
    clearIconTemplate: [{ type: ContentChild, args: [IgxComboClearIconDirective, { read: TemplateRef },] }],
    virtualScrollContainer: [{ type: ViewChild, args: [IgxForOfDirective, { static: true },] }],
    onSelectionChange: [{ type: Output }],
    onOpening: [{ type: Output }],
    onOpened: [{ type: Output }],
    onClosing: [{ type: Output }],
    onClosed: [{ type: Output }],
    onAddition: [{ type: Output }],
    onSearchInput: [{ type: Output }],
    onDataPreLoad: [{ type: Output }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    width: [{ type: HostBinding, args: ['style.width',] }, { type: Input }],
    cssClass: [{ type: HostBinding, args: ['class.igx-combo',] }],
    role: [{ type: HostBinding, args: [`attr.role`,] }],
    ariaExpanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
    hasPopUp: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
    ariaOwns: [{ type: HostBinding, args: ['attr.aria-owns',] }],
    allowCustomValues: [{ type: Input }],
    itemsMaxHeight: [{ type: Input }],
    itemsWidth: [{ type: Input }],
    itemHeight: [{ type: Input }],
    placeholder: [{ type: Input }],
    searchPlaceholder: [{ type: Input }],
    showSearchCaseIcon: [{ type: Input }],
    data: [{ type: Input }],
    valueKey: [{ type: Input }],
    displayKey: [{ type: Input }],
    groupKey: [{ type: Input }],
    filterable: [{ type: Input }],
    ariaLabelledBy: [{ type: Input }, { type: HostBinding, args: ['attr.aria-labelledby',] }],
    disabled: [{ type: Input }],
    type: [{ type: Input }],
    autoFocusSearch: [{ type: Input }],
    dropdownContainer: [{ type: ViewChild, args: ['dropdownItemContainer', { static: true },] }],
    primitiveTemplate: [{ type: ViewChild, args: ['primitive', { read: TemplateRef, static: true },] }],
    complexTemplate: [{ type: ViewChild, args: ['complex', { read: TemplateRef, static: true },] }],
    virtDir: [{ type: ViewChild, args: [IgxForOfDirective, { read: IgxForOfDirective, static: true },] }],
    onArrowDown: [{ type: HostListener, args: ['keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['keydown.Alt.ArrowDown', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxComboModule {
}
IgxComboModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxComboComponent, IgxComboItemComponent, IgxComboGroupingPipe,
                    IgxComboFilteringPipe, IgxComboDropDownComponent, IgxComboAddItemComponent,
                    IgxComboItemDirective,
                    IgxComboEmptyDirective,
                    IgxComboHeaderItemDirective,
                    IgxComboHeaderDirective,
                    IgxComboFooterDirective,
                    IgxComboAddItemDirective,
                    IgxComboToggleIconDirective,
                    IgxComboClearIconDirective],
                exports: [IgxComboComponent, IgxComboItemComponent, IgxComboDropDownComponent, IgxComboAddItemComponent,
                    IgxComboItemDirective,
                    IgxComboEmptyDirective,
                    IgxComboHeaderItemDirective,
                    IgxComboHeaderDirective,
                    IgxComboFooterDirective,
                    IgxComboAddItemDirective,
                    IgxComboToggleIconDirective,
                    IgxComboClearIconDirective,
                    IgxInputGroupModule],
                imports: [IgxRippleModule, CommonModule, IgxInputGroupModule, FormsModule, ReactiveFormsModule,
                    IgxForOfModule, IgxToggleModule, IgxCheckboxModule, IgxDropDownModule, IgxButtonModule, IgxIconModule]
            },] }
];

/** @hidden */
const IGX_DATE_PICKER_COMPONENT = 'IgxDatePickerComponentToken';

/**
 * @hidden
 */
class DatePickerDisplayValuePipe {
    constructor(_datePicker) {
        this._datePicker = _datePicker;
    }
    transform(value, args) {
        if (value !== '') {
            if (value === DatePickerUtil.maskToPromptChars(this._datePicker.inputMask)) {
                return '';
            }
            this._datePicker.rawDateString = value;
            return DatePickerUtil.trimEmptyPlaceholders(value);
        }
        return '';
    }
}
DatePickerDisplayValuePipe.decorators = [
    { type: Pipe, args: [{
                name: 'displayValue'
            },] }
];
DatePickerDisplayValuePipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
];
/**
 * @hidden
 */
class DatePickerInputValuePipe {
    constructor(_datePicker) {
        this._datePicker = _datePicker;
    }
    transform(value, args) {
        /**
         * TODO(D.P.): This plugs into the mask, but constantly received display strings it can't handle at all
         * Those are almost immediately overridden by the pickers onFocus handling anyway; Refactor ASAP
         */
        if (this._datePicker.invalidDate !== '') {
            return this._datePicker.invalidDate;
        }
        else {
            if (this._datePicker.value === null || this._datePicker.value === undefined) {
                return DatePickerUtil.maskToPromptChars(this._datePicker.inputMask);
            }
            else {
                return this._datePicker._getEditorDate(this._datePicker.value);
                // return DatePickerUtil.addPromptCharsEditMode(this._datePicker.dateFormatParts, this._datePicker.value, value);
            }
        }
    }
}
DatePickerInputValuePipe.decorators = [
    { type: Pipe, args: [{
                name: 'inputValue'
            },] }
];
DatePickerInputValuePipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
];

/**
 * IgxDatePickerTemplateDirective can be used to re-template the date-picker input-group.
 *
 * @hidden
 */
class IgxDatePickerTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxDatePickerTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDatePickerTemplate]'
            },] }
];
IgxDatePickerTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * IgxDatePickerActionsDirective can be used to re-template the dropdown/dialog action buttons.
 */
class IgxDatePickerActionsDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxDatePickerActionsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDatePickerActions]'
            },] }
];
IgxDatePickerActionsDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * This enumeration is used to configure whether the date/time picker has an editable input with drop down
 * or is readonly - the date/time is selected only through a dialog.
 */
const InteractionMode = mkenum({
    DropDown: 'dropdown',
    Dialog: 'dialog'
});

/**
 * @hidden
 */
class IgxCalendarContainerComponent {
    constructor() {
        this.mode = InteractionMode.Dialog;
        this.vertical = false;
        this.onClose = new EventEmitter();
        this.onTodaySelection = new EventEmitter();
        this.styleClass = 'igx-date-picker';
    }
    get dropdownCSS() {
        return this.mode === InteractionMode.DropDown;
    }
    get verticalCSS() {
        return this.vertical && this.mode === InteractionMode.Dialog;
    }
    onEscape(event) {
        event.preventDefault();
        this.onClose.emit();
    }
    /**
     * Returns whether the date-picker is in readonly dialog mode.
     *
     * @hidden
     */
    get isReadonly() {
        return this.mode === InteractionMode.Dialog;
    }
    /**
     * Emits close event for the calendar.
     */
    closeCalendar() {
        this.onClose.emit();
    }
    /**
     * Emits today selection event for the calendar.
     */
    triggerTodaySelection() {
        this.onTodaySelection.emit();
    }
}
IgxCalendarContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-calendar-container',
                template: "<ng-template #defaultDatePickerActions>\n    <div *ngIf=\"cancelButtonLabel || todayButtonLabel\" class=\"igx-date-picker__buttons\">\n        <button #closeButton *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"closeCalendar()\">\n            {{ cancelButtonLabel }}\n        </button>\n        <button #todayButton *ngIf=\"todayButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"triggerTodaySelection()\">\n            {{ todayButtonLabel }}\n        </button>\n    </div>\n</ng-template>\n<igx-calendar #calendar></igx-calendar>\n<ng-container *ngTemplateOutlet=\"datePickerActions ? datePickerActions.template : defaultDatePickerActions\"></ng-container>\n",
                styles: [':host {display: block;}']
            },] }
];
IgxCalendarContainerComponent.propDecorators = {
    calendar: [{ type: ViewChild, args: ['calendar', { static: true },] }],
    mode: [{ type: Input }],
    vertical: [{ type: Input }],
    cancelButtonLabel: [{ type: Input }],
    todayButtonLabel: [{ type: Input }],
    datePickerActions: [{ type: Input }],
    onClose: [{ type: Output }],
    onTodaySelection: [{ type: Output }],
    styleClass: [{ type: HostBinding, args: ['class.igx-date-picker',] }],
    dropdownCSS: [{ type: HostBinding, args: ['class.igx-date-picker--dropdown',] }],
    verticalCSS: [{ type: HostBinding, args: ['class.igx-date-picker--vertical',] }],
    onEscape: [{ type: HostListener, args: ['keydown.esc', ['$event'],] }, { type: HostListener, args: ['keydown.alt.arrowup', ['$event'],] }]
};

let NEXT_ID$h = 0;
/**
 * This enumeration is used to configure the date picker to operate with pre-defined format option used in Angular DatePipe.
 * 'https://angular.io/api/common/DatePipe'
 * 'shortDate': equivalent to 'M/d/yy' (6/15/15).
 * 'mediumDate': equivalent to 'MMM d, y' (Jun 15, 2015).
 * 'longDate': equivalent to 'MMMM d, y' (June 15, 2015).
 * 'fullDate': equivalent to 'EEEE, MMMM d, y' (Monday, June 15, 2015).
 */
const PredefinedFormatOptions = mkenum({
    ShortDate: 'shortDate',
    MediumDate: 'mediumDate',
    LongDate: 'longDate',
    FullDate: 'fullDate'
});
/**
 * Date Picker displays a popup calendar that lets users select a single date.
 *
 * @igxModule IgxDatePickerModule
 * @igxTheme igx-calendar-theme, igx-icon-theme
 * @igxGroup Scheduling
 * @igxKeywords  datepicker, calendar, schedule, date
 * @example
 * ```html
 * <igx-date-picker [(ngModel)]="selectedDate"></igx-date-picker>
 * ```
 */
class IgxDatePickerComponent {
    constructor(_overlayService, element, _cdr, _moduleRef, _injector, _renderer) {
        this._overlayService = _overlayService;
        this.element = element;
        this._cdr = _cdr;
        this._moduleRef = _moduleRef;
        this._injector = _injector;
        this._renderer = _renderer;
        /**
         * Gets/Sets the `IgxDatePickerComponent` label visibility.
         *
         * @remarks
         * By default the visibility is set to true.
         * @example
         * <igx-date-picker [labelVisibility]="false"></igx-date-picker>
         */
        this.labelVisibility = true;
        /**
         * Gets/Sets on which day the week starts.
         *
         * @example
         * ```html
         * <igx-date-picker [weekStart]="WEEKDAYS.FRIDAY" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.weekStart = WEEKDAYS.SUNDAY;
        /**
         * Gets/Sets the number of month views displayed.
         *
         * @remarks
         * Default value is `1`.
         * @example
         * ```html
         * <igx-date-picker [monthsViewNumber]="2"></igx-date-picker>
         * ```
         * @example
         * ```typescript
         * let monthViewsDisplayed = this.datePicker.monthsViewNumber;
         * ```
         */
        this.monthsViewNumber = 1;
        /**
         * Gets/Sets the value of `id` attribute.
         *
         * @remarks If not provided it will be automatically generated.
         * @example
         * ```html
         * <igx-date-picker [id]="'igx-date-picker-3'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.id = `igx-date-picker-${NEXT_ID$h++}`;
        /**
         * Gets/Sets the orientation of the `IgxDatePickerComponent` header.
         *
         *  @example
         * ```html
         * <igx-date-picker [vertical]="'true'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.vertical = false;
        /**
         * Gets/Sets the interaction mode - dialog or drop down.
         *
         *  @example
         * ```html
         * <igx-date-picker mode="dropdown"></igx-date-picker>
         * ```
         */
        this.mode = InteractionMode.Dialog;
        /**
         * Gets/Sets whether date should spin continuously or stop when min/max is reached.
         *
         *  @example
         * ```html
         * <igx-date-picker [isSpinLoop]="false"></igx-date-picker>
         * ```
         */
        this.isSpinLoop = true;
        /**
         * Emitted when the `IgxDatePickerComponent` calendar is opened.
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted after the `IgxDatePickerComponent` is closed.
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted when the `IgxDatePickerComponent` is being closed.
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted when selection is made in the calendar.
         *
         *  @example
         * ```html
         * <igx-date-picker (onSelection)="selection($event)"></igx-date-picker>
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         * Emitted when date picker value is changed.
         *
         * @example
         * ```html
         * <igx-date-picker (valueChange)="valueChanged($event)" mode="dropdown"></igx-date-picker>
         * ```
         */
        this.valueChange = new EventEmitter();
        /**
         * Emitted when the user types/spins to a disabled date in the date-picker editor.
         *
         *  @example
         * ```html
         * <igx-date-picker (onDisabledDate)="onDisabledDate($event)"></igx-date-picker>
         * ```
         */
        this.onDisabledDate = new EventEmitter();
        /**
         * Emitted when the user types/spins invalid date in the date-picker editor.
         *
         *  @example
         * ```html
         * <igx-date-picker (onValidationFailed)="onValidationFailed($event)"></igx-date-picker>
         * ```
         */
        this.onValidationFailed = new EventEmitter();
        /** @hidden @internal */
        this.hasHeader = true;
        /** @hidden @internal */
        this.collapsed = true;
        /** @hidden @internal */
        this.displayValuePipe = new DatePickerDisplayValuePipe(this);
        /** @hidden @internal */
        this.inputValuePipe = new DatePickerInputValuePipe(this);
        /** @hidden @internal */
        this.dateFormatParts = [];
        /** @hidden @internal */
        this.isEmpty = true;
        /** @hidden @internal */
        this.invalidDate = '';
        this.spinDelta = 1;
        this.defaultLocale = 'en';
        this._formatOptions = {
            day: 'numeric',
            month: 'short',
            weekday: 'short',
            year: 'numeric'
        };
        this._formatViews = {
            day: false,
            month: true,
            year: false
        };
        this._destroy$ = new Subject();
        this._disabledDates = null;
        this._specialDates = null;
        this._onOpen = new EventEmitter();
        this._onClose = new EventEmitter();
        this._ngControl = null;
        this._label = 'Date';
        //#region ControlValueAccessor
        this._onChangeCallback = noop;
        this._onTouchedCallback = noop;
        this._onValidatorChange = noop;
    }
    /**
     * Gets/Sets the `IgxDatePickerComponent` label.
     *
     * @remarks
     * The default label is 'Date'.
     * @example
     * ```html
     * <igx-date-picker [label]="Calendar"></igx-date-picker>
     * ```
     * @deprecated Use igxLabel inside the date picker to change the label:
     * ````html
     * <igx-date-picker>
     *      <label igxLabel>Custom label</label>
     * </igx-date-picker>
     * ````
     * to set a custom label.
     */
    get label() {
        return this._label;
    }
    set label(v) {
        this._label = v;
    }
    get labelInternal() {
        return this._label;
    }
    /** @hidden @internal */
    get labelTemplate() {
        return this._labelDirectiveUserTemplate;
    }
    /**
     * Gets the format options of the `IgxDatePickerComponent`.
     *
     * @example
     * ```typescript
     * let formatOptions = this.datePicker.formatOptions;
     * ```
     */
    get formatOptions() {
        return this._formatOptions;
    }
    /**
     * Sets the format options of the `IgxDatePickerComponent`.
     *
     * @example
     * ```typescript
     * this.datePicker.formatOptions = {  day: "numeric",  month: "long", weekday: "long", year: "numeric"};
     * ```
     */
    set formatOptions(formatOptions) {
        this._formatOptions = Object.assign(this._formatOptions, formatOptions);
    }
    /**
     * Gets/Sets the date display format of the `IgxDatePickerComponent` in dropdown mode.
     *
     * @example
     * ```typescript
     * let format = this.datePicker.format;
     * this.datePicker.format = 'yyyy-M-d';
     * ```
     */
    get format() {
        return (this._format === undefined) ? PredefinedFormatOptions.ShortDate : this._format;
    }
    set format(format) {
        this._format = format;
    }
    /**
     * Gets/Sets the format views of the `IgxDatePickerComponent`.
     *
     * @example
     * ```typescript
     * let formatViews = this.datePicker.formatViews;
     *  this.datePicker.formatViews = {day:false, month: false, year:false};
     * ```
     */
    get formatViews() {
        return this._formatViews;
    }
    set formatViews(formatViews) {
        this._formatViews = Object.assign(this._formatViews, formatViews);
    }
    /**
     * Gets/Sets the disabled dates descriptors.
     *
     * @example
     * ```typescript
     * let disabledDates = this.datepicker.disabledDates;
     * this.datePicker.disabledDates = [ {type: DateRangeType.Weekends}, ...];
     * ```
     */
    get disabledDates() {
        return this._disabledDates;
    }
    set disabledDates(value) {
        this._disabledDates = value;
        this._onValidatorChange();
    }
    /**
     * Gets/Sets the special dates descriptors.
     *
     * @example
     * ```typescript
     * let specialDates = this.datepicker.specialDates;
     * this.datePicker.specialDates = [ {type: DateRangeType.Weekends}, ... ];
     * ```
     */
    get specialDates() {
        return this._specialDates;
    }
    set specialDates(value) {
        this._specialDates = value;
    }
    /**
     * Gets/Sets the modal overlay settings.
     */
    get modalOverlaySettings() {
        return this._modalOverlay;
    }
    set modalOverlaySettings(value) {
        this._modalOverlay = value;
    }
    /**
     * Gets/Sets the drop-down overlay settings.
     */
    get dropDownOverlaySettings() {
        return this._dropDownOverlaySettings || this._defaultDropDownOverlaySettings;
    }
    set dropDownOverlaySettings(value) {
        this._dropDownOverlaySettings = value;
    }
    /**
     * Gets the formatted date when `IgxDatePickerComponent` is in dialog mode.
     *
     *  @example
     * ```typescript
     * let selectedDate = this.datePicker.displayData;
     * ```
     */
    get displayData() {
        if (this.value) {
            return this._customFormatChecker(this.formatter, this.value);
        }
        return '';
    }
    /** @hidden @internal */
    get transformedDate() {
        if (this._value) {
            this._transformedDate = (this._isInEditMode) ? this._getEditorDate(this._value) : this._getDisplayDate(this._value);
            this.isEmpty = false;
        }
        else {
            this._transformedDate = (this._isInEditMode) ? DatePickerUtil.maskToPromptChars(this.inputMask) : '';
        }
        return this._transformedDate;
    }
    /** @hidden @internal */
    set transformedDate(value) {
        this._transformedDate = value;
    }
    /**
     * Gets the input group template.
     *
     * @example
     * ```typescript
     * let template = this.template();
     * ```
     */
    get template() {
        if (this.datePickerTemplateDirective) {
            return this.datePickerTemplateDirective.template;
        }
        return (this.mode === InteractionMode.Dialog) ? this.readOnlyDatePickerTemplate : this.editableDatePickerTemplate;
    }
    /**
     * Gets the context passed to the input group template.
     */
    get context() {
        return {
            disabled: this.disabled,
            disabledDates: this.disabledDates,
            displayData: this.displayData,
            format: this.format,
            isSpinLoop: this.isSpinLoop,
            labelVisibility: this.labelVisibility,
            locale: this.locale,
            mask: this.mask,
            mode: this.mode,
            specialDates: this.specialDates,
            value: this.value,
            openDialog: () => this.openDialog()
        };
    }
    get required() {
        if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            const error = this._ngControl.control.validator({});
            return error && error.required;
        }
        return false;
    }
    /**
     * Gets/Sets the selected date.
     *
     *  @example
     * ```html
     * <igx-date-picker [value]="date"></igx-date-picker>
     * ```
     */
    get value() {
        return this._value;
    }
    set value(date) {
        this._value = date;
        this._onChangeCallback(date);
    }
    /**
     * @hidden
     */
    onSpaceClick(event) {
        this.openDialog();
        event.preventDefault();
    }
    /** @hidden @internal */
    writeValue(value) {
        this._value = value;
        // TODO: do we need next call
        this._cdr.markForCheck();
    }
    /** @hidden @internal */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /** @hidden @internal */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /** @hidden @internal */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /** @hidden @internal */
    registerOnValidatorChange(fn) {
        this._onValidatorChange = fn;
    }
    /** @hidden @internal */
    validate() {
        if (!!this.value && this.disabledDates && isDateInRanges(this.value, this.disabledDates)) {
            return { dateIsDisabled: true };
        }
        return null;
    }
    //#endregion
    /** @hidden */
    getEditElement() {
        const inputDirectiveElementRef = this._inputElementRef || this._inputUserTemplateElementRef;
        return (inputDirectiveElementRef) ? inputDirectiveElementRef.nativeElement : null;
    }
    /** @hidden @internal */
    get inputGroupElement() {
        var _a;
        return (_a = this.inputGroup) === null || _a === void 0 ? void 0 : _a.element.nativeElement;
    }
    /** @hidden @internal */
    get inputGroup() {
        return this._inputGroup || this._inputGroupUserTemplate || null;
    }
    /** @hidden @internal */
    get inputDirective() {
        return this._inputDirective || this._inputDirectiveUserTemplates.first || null;
    }
    /** @hidden @internal */
    get labelDirective() {
        return this._labelDirective || this._labelDirectiveUserTemplate || null;
    }
    /** @hidden @internal */
    ngOnInit() {
        this._positionSettings = {
            openAnimation: fadeIn,
            closeAnimation: fadeOut
        };
        this._defaultDropDownOverlaySettings = {
            target: this.inputGroupElement,
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy(this._positionSettings),
            outlet: this.outlet
        };
        this._modalOverlaySettings = {
            closeOnOutsideClick: true,
            modal: true,
            closeOnEscape: true,
            outlet: this.outlet
        };
        this._overlayService.onOpening.pipe(filter((overlay) => overlay.id === this._componentID), takeUntil(this._destroy$)).subscribe((eventArgs) => {
            this._onOpening(eventArgs);
        });
        this._overlayService.onOpened.pipe(filter((overlay) => overlay.id === this._componentID), takeUntil(this._destroy$)).subscribe(() => {
            this._onOpened();
        });
        this._overlayService.onClosed.pipe(filter(overlay => overlay.id === this._componentID), takeUntil(this._destroy$)).subscribe(() => {
            this._onClosed();
        });
        this._overlayService.onClosing.pipe(filter(overlay => overlay.id === this._componentID), takeUntil(this._destroy$)).subscribe((event) => {
            this.onClosing.emit(event);
            // If canceled in a user onClosing handler
            if (event.cancel) {
                return;
            }
            // Do not focus the input if clicking outside in dropdown mode
            const input = this.getEditElement();
            if (input && !(event.event && this.mode === InteractionMode.DropDown)) {
                input.focus();
            }
            else {
                // outside click
                this._updateValidityOnBlur();
            }
        });
        if (this.mode === InteractionMode.DropDown) {
            this.dateFormatParts = DatePickerUtil.parseDateFormat(this.mask, this.locale);
            if (this.mask === undefined) {
                this.mask = DatePickerUtil.getMask(this.dateFormatParts);
            }
            this.inputMask = DatePickerUtil.getInputMask(this.dateFormatParts);
        }
        this._ngControl = this._injector.get(NgControl, null);
    }
    /** @hidden @internal */
    ngAfterViewInit() {
        if (this.mode === InteractionMode.DropDown && this._inputElementRef) {
            fromEvent(this._inputElementRef.nativeElement, 'keydown').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy$)).subscribe((res) => this.onKeyDown(res));
        }
        if (this._ngControl) {
            this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
        }
        this._inputDirectiveUserTemplates.changes.subscribe(() => {
            this.attachTemplateBlur();
        });
        this.attachTemplateBlur();
    }
    ngAfterViewChecked() {
        // If one sets mode at run time this forces initialization of new igxInputGroup
        // As a result a new igxInputDirective is initialized too. In ngAfterViewInit of
        // the new directive isRequired of the igxInputGroup is set again. However
        // ngAfterViewInit of date picker is not called again and we may finish with wrong
        // isRequired in igxInputGroup. This is why we should set it her, only when needed
        if (this.inputGroup && this.inputGroup.isRequired !== this.required) {
            this.inputGroup.isRequired = this.required;
            this._cdr.detectChanges();
        }
        // TODO: persist validation state when dynamically changing 'dropdown' to 'dialog' ot vice versa.
        // For reference -> it is currently persisted if a user template is passed (as template is not recreated)
        if (this.labelDirective) {
            this._renderer.setAttribute(this.inputDirective.nativeElement, 'aria-labelledby', this.labelDirective.id);
        }
    }
    /** @hidden @internal */
    ngOnDestroy() {
        if (this._componentID) {
            this._overlayService.hide(this._componentID);
        }
        if (this._statusChanges$) {
            this._statusChanges$.unsubscribe();
        }
        this._destroy$.next(true);
        this._destroy$.complete();
    }
    /**
     * Selects today's date from calendar.
     *
     *  @remarks
     * Changes the input field value, @calendar.viewDate and @calendar.value.
     *  @example
     * ```typescript
     * this.datePicker.triggerTodaySelection();
     * ```
     */
    triggerTodaySelection() {
        const today = new Date(Date.now());
        this.handleSelection(today);
    }
    /**
     * Change the calendar selection.
     *
     * @remarks
     * Calling this method will emit the @calendar.onSelection event,
     * which will fire @handleSelection method.
     * @example
     * ```typescript
     * this.datePicker.selectDate(this.date);
     * ```
     * @param date passed date that has to be set to the calendar.
     */
    selectDate(date) {
        const oldValue = this.value;
        this.value = date;
        this.emitValueChangeEvent(oldValue, this.value);
        this.onSelection.emit(date);
    }
    /**
     * Deselects the calendar date.
     *
     * @example
     * ```typescript
     * this.datePicker.deselectDate();
     * ```
     */
    deselectDate() {
        const oldValue = this.value;
        this.value = null;
        this.emitValueChangeEvent(oldValue, this.value);
        if (this.calendar) {
            this.calendar.deselectDate();
        }
    }
    /**
     * Opens the date picker drop down or dialog.
     *
     * @param target HTMLElement - the target element to use for positioning the drop down container according to
     * @example
     * ```typescript
     * this.datePicker.openDialog(target);
     * ```
     */
    openDialog() {
        if (!this.collapsed || this.disabled) {
            return;
        }
        switch (this.mode) {
            case InteractionMode.Dialog: {
                this.hasHeader = true;
                const modalOverlay = (this.modalOverlaySettings !== undefined) ? this._modalOverlay : this._modalOverlaySettings;
                this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, modalOverlay, this._moduleRef);
                this._overlayService.show(this._componentID);
                break;
            }
            case InteractionMode.DropDown: {
                this.hasHeader = false;
                const target = this.inputGroupElement;
                if (target) {
                    this.dropDownOverlaySettings.target = target;
                }
                this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, this.dropDownOverlaySettings, this._moduleRef);
                this._overlayService.show(this._componentID);
                break;
            }
        }
    }
    /**
     * Close the calendar.
     *
     * @hidden @internal
     */
    closeCalendar() {
        this._overlayService.hide(this._componentID);
    }
    /**
     * Clear the input field, date picker value and calendar selection.
     *
     * @hidden @internal
     */
    clear() {
        if (!this.disabled) {
            this.isEmpty = true;
            this.invalidDate = '';
            this.deselectDate();
            this._setCursorPosition(0);
        }
    }
    /**
     * Evaluates when @calendar.onSelection event was fired
     * and update the input value.
     *
     * @param event selected value from calendar.
     *
     * @hidden @internal
     */
    handleSelection(date) {
        if (this.value) {
            date.setHours(this.value.getHours());
            date.setMinutes(this.value.getMinutes());
            date.setSeconds(this.value.getSeconds());
            date.setMilliseconds(this.value.getMilliseconds());
        }
        const oldValue = this.value;
        this.value = date;
        this.emitValueChangeEvent(oldValue, this.value);
        this.calendar.viewDate = date;
        this.closeCalendar();
        this.onSelection.emit(date);
    }
    /** @hidden @internal */
    onOpenClick(event) {
        event.stopPropagation();
        this.openDialog();
    }
    /** @hidden @internal */
    onBlur(event, calcDate = true) {
        this._isInEditMode = false;
        if (this.mode === InteractionMode.DropDown && calcDate) {
            this.calculateDate(event.target.value, event.type);
        }
        if (this.collapsed) {
            this._updateValidityOnBlur();
        }
    }
    /** @hidden @internal */
    onFocus() {
        this._isInEditMode = true;
        if (this.value && this.invalidDate === '') {
            this._transformedDate = this._getEditorDate(this.value);
        }
    }
    /** @hidden @internal */
    onKeyDown(event) {
        switch (event.key) {
            case "ArrowUp" /* UP_ARROW */:
            case "Up" /* UP_ARROW_IE */:
                event.preventDefault();
                event.stopPropagation();
                this.spinValue(event.target.value, 1, event.type);
                break;
            case "ArrowDown" /* DOWN_ARROW */:
            case "Down" /* DOWN_ARROW_IE */:
                if (event.altKey) {
                    this.openDialog();
                }
                else {
                    event.preventDefault();
                    event.stopPropagation();
                    this.spinValue(event.target.value, -1, event.type);
                }
                break;
            default:
                break;
        }
    }
    /** @hidden @internal */
    onWheel(event) {
        if (this._isInEditMode) {
            event.preventDefault();
            event.stopPropagation();
            const sign = (event.deltaY > 0) ? -1 : 1;
            this.spinValue(event.target.value, sign, event.type);
        }
    }
    /** @hidden @internal */
    onInput(event) {
        /**
         * Fix for #8165 until refactoring (#6483).
         * The IgxDateTimeEditor will be used to handle all inputs, i.e. this handler will be removed.
         * It extends the IgxMaskDirective which contains logic that handles this issue.
         */
        if (isIE() && !this._isInEditMode && !this.inputGroup.isFocused) {
            return;
        }
        const targetValue = event.target.value;
        const cursorPosition = this._getCursorPosition();
        const checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, targetValue);
        this._isInEditMode = true;
        if (targetValue !== DatePickerUtil.maskToPromptChars(this.inputMask)) {
            this.isEmpty = false;
        }
        // If all date parts are completed, change the date-picker value, stay in edit mode
        if (checkInput === 'complete' && event.inputType !== 'deleteContentBackward') {
            this._transformedDate = targetValue;
            this.calculateDate(targetValue, event.type);
            this._setCursorPosition(cursorPosition);
        }
        else if (checkInput === 'partial') {
            // While editing, if one date part is deleted, date-picker value is set to null, the remaining input stays intact.
            this.deselectDate();
            requestAnimationFrame(() => {
                this.getEditElement().value = targetValue;
                this._setCursorPosition(cursorPosition);
            });
        }
        else if (checkInput === 'empty') {
            // Total clean-up as input is deleted.
            this.isEmpty = true;
            this.deselectDate();
        }
    }
    _updateValidityOnBlur() {
        this._onTouchedCallback();
        const input = this.inputDirective;
        if (input && this._ngControl && !this._ngControl.valid) {
            input.valid = IgxInputState.INVALID;
        }
        else {
            input.valid = IgxInputState.INITIAL;
        }
    }
    onStatusChanged() {
        if ((this._ngControl.control.touched || this._ngControl.control.dirty) &&
            (this.inputDirective && this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {
            if (this.inputGroup.isFocused) {
                this.inputDirective.valid = this._ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
            }
            else {
                this.inputDirective.valid = this._ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
            }
        }
        if (this.inputGroup && this.inputGroup.isRequired !== this.required) {
            this.inputGroup.isRequired = this.required;
        }
    }
    attachTemplateBlur() {
        if (this._templateInputBlur$) {
            this._templateInputBlur$.unsubscribe();
        }
        if (this._inputDirectiveUserTemplates.first) {
            const directive = this._inputDirectiveUserTemplates.first;
            this._templateInputBlur$ = fromEvent(directive.nativeElement, 'blur').pipe(takeUntil(this._destroy$)).subscribe((res) => {
                this.rawDateString = res.target.value;
                this.onBlur(res, false);
            });
            // TODO: Refactor custom template handling.
            // Revise blur handling when custom template is passed
        }
    }
    emitValueChangeEvent(oldValue, newValue) {
        if (!isEqual(oldValue, newValue)) {
            this.valueChange.emit(newValue);
        }
    }
    calculateDate(dateString, invokedByEvent) {
        if (dateString !== '') {
            const prevDateValue = this.value;
            const inputValue = (invokedByEvent === 'blur') ? this.rawDateString : dateString;
            const newDateArray = DatePickerUtil.parseDateArray(this.dateFormatParts, prevDateValue, inputValue);
            if (newDateArray.state === "valid" /* Valid */) {
                const newValue = newDateArray.date;
                // Restore the time part if any
                if (prevDateValue) {
                    newValue.setHours(prevDateValue.getHours());
                    newValue.setMinutes(prevDateValue.getMinutes());
                    newValue.setSeconds(prevDateValue.getSeconds());
                    newValue.setMilliseconds(prevDateValue.getMilliseconds());
                }
                if (this.disabledDates === null
                    || (this.disabledDates !== null && !isDateInRanges(newValue, this.disabledDates))) {
                    const oldValue = this.value;
                    this.value = newValue;
                    this.emitValueChangeEvent(oldValue, this.value);
                    this.invalidDate = '';
                }
                else {
                    const args = {
                        datePicker: this,
                        currentValue: newValue,
                    };
                    this.onDisabledDate.emit(args);
                }
            }
            else {
                const args = {
                    datePicker: this,
                    prevValue: prevDateValue
                };
                this.invalidDate = dateString;
                this.onValidationFailed.emit(args);
            }
        }
    }
    spinValue(inputValue, sign, eventType) {
        this._isInEditMode = true;
        this.isEmpty = false;
        const cursorPosition = this._getCursorPosition();
        const modifiedInputValue = DatePickerUtil.getModifiedDateInput(this.dateFormatParts, inputValue, cursorPosition, this.spinDelta * sign, this.isSpinLoop);
        this.getEditElement().value = modifiedInputValue;
        this._setCursorPosition(cursorPosition);
        const checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, modifiedInputValue);
        if (checkInput === 'complete') {
            this._isInEditMode = true;
            this.calculateDate(modifiedInputValue, eventType);
            this._setCursorPosition(cursorPosition);
        }
    }
    _onOpening(event) {
        this._initializeCalendarContainer(event.componentRef.instance);
        this.collapsed = false;
    }
    _onOpened() {
        this.onOpened.emit(this);
        if (this.calendar) {
            this._focusCalendarDate();
        }
    }
    _onClosed() {
        this.collapsed = true;
        this._componentID = null;
        this.onClosed.emit(this);
    }
    _initializeCalendarContainer(componentInstance) {
        this.calendar = componentInstance.calendar;
        const isVertical = (this.vertical && this.mode === InteractionMode.Dialog);
        this.calendar.hasHeader = this.hasHeader;
        this.calendar.formatOptions = this.formatOptions;
        this.calendar.formatViews = this.formatViews;
        this.calendar.locale = this.locale;
        this.calendar.vertical = isVertical;
        this.calendar.weekStart = this.weekStart;
        this.calendar.specialDates = this.specialDates;
        this.calendar.disabledDates = this.disabledDates;
        this.calendar.headerTemplate = this.headerTemplate;
        this.calendar.subheaderTemplate = this.subheaderTemplate;
        this.calendar.hideOutsideDays = this.hideOutsideDays;
        this.calendar.monthsViewNumber = this.monthsViewNumber;
        this.calendar.showWeekNumbers = this.showWeekNumbers;
        this.calendar.selected.pipe(takeUntil(this._destroy$)).subscribe((ev) => this.handleSelection(ev));
        if (this.value) {
            this.calendar.value = this.value;
            this.calendar.viewDate = this.value;
        }
        componentInstance.mode = this.mode;
        componentInstance.vertical = isVertical;
        componentInstance.cancelButtonLabel = this.cancelButtonLabel;
        componentInstance.todayButtonLabel = this.todayButtonLabel;
        componentInstance.datePickerActions = this.datePickerActionsDirective;
        componentInstance.onClose.pipe(takeUntil(this._destroy$)).subscribe(() => this.closeCalendar());
        componentInstance.onTodaySelection.pipe(takeUntil(this._destroy$)).subscribe(() => this.triggerTodaySelection());
    }
    // Focus a date, after the calendar appearance into DOM.
    _focusCalendarDate() {
        requestAnimationFrame(() => {
            this.calendar.daysView.focusActiveDate();
        });
    }
    _setLocaleToDate(value) {
        if (isIE()) {
            // this is a workaround fixing the following IE11 issue:
            // IE11 has added character code 8206 (mark for RTL) to the output of toLocaleDateString() that
            // precedes each portion that comprises the total date... For more information read this article:
            // eslint-disable-next-line max-len
            // https://www.csgpro.com/blog/2016/08/a-bad-date-with-internet-explorer-11-trouble-with-new-unicode-characters-in-javascript-date-strings/
            const localeDateStrIE = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
            return localeDateStrIE.toLocaleDateString(this.locale);
        }
        return value.toLocaleDateString(this.locale);
    }
    _getCursorPosition() {
        return this.getEditElement().selectionStart;
    }
    _setCursorPosition(start, end = start) {
        requestAnimationFrame(() => {
            this.getEditElement().setSelectionRange(start, end);
        });
    }
    /**
     * Apply custom user formatter upon date.
     *
     * @param formatter custom formatter function.
     * @param date passed date
     */
    _customFormatChecker(formatter, date) {
        return this.formatter ? this.formatter(date) : this._setLocaleToDate(date);
    }
    /*
    * Transforms the date according to the specified format when `IgxDatePickerComponent` is in edit mode
    * using @angular/common formatDate method: https://angular.io/api/common/formatDate
    * @param  value: string | number | Date
    * @returns formatted string
    */
    _getDisplayDate(value) {
        if (this.format && !this.formatter) {
            const locale = this.locale || this.defaultLocale;
            return formatDate(value, this.format, locale);
        }
        else {
            return this._customFormatChecker(this.formatter, value);
        }
    }
    _getEditorDate(value) {
        const locale = this.locale || this.defaultLocale;
        const changedValue = (value) ? formatDate(value, this.mask, locale) : '';
        return DatePickerUtil.addPromptCharsEditMode(this.dateFormatParts, this.value, changedValue);
    }
}
IgxDatePickerComponent.decorators = [
    { type: Component, args: [{
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxDatePickerComponent,
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: IgxDatePickerComponent,
                        multi: true
                    }],
                // eslint-disable-next-line @angular-eslint/component-selector
                selector: 'igx-date-picker',
                template: "<ng-template #labelTemplate>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #readOnlyDatePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\">\n        <ng-container ngProjectAs=\"[igxLabel]\" *ngTemplateOutlet=\"labelTemplate\"></ng-container>\n        <igx-prefix>\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility&&!_labelDirectiveUserTemplate\" igxLabel>{{labelInternal}}</label>\n        <input\n            class=\"igx-date-picker__input-date\"\n            igxInput\n            [value]=\"displayData || ''\"\n            [disabled]=\"disabled\"\n            (blur)=\"onBlur($event)\"\n            [tabindex]='editorTabIndex'\n            readonly\n        />\n    </igx-input-group>\n</ng-template>\n\n<ng-template #editableDatePickerTemplate>\n    <igx-input-group #editableInputGroup>\n        <ng-container ngProjectAs=\"[igxLabel]\" *ngTemplateOutlet=\"labelTemplate\"></ng-container>\n        <igx-prefix (click)=\"onOpenClick($event)\">\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility&&!_labelDirectiveUserTemplate\" igxLabel>{{labelInternal}}</label>\n        <input\n            class=\"igx-date-picker__input-date\"\n            igxInput\n            type=\"text\"\n            [value]=\"transformedDate\"\n            [igxMask]=\"inputMask\"\n            [placeholder]=\"mask\"\n            [igxTextSelection]=\"true\"\n            [disabled]=\"disabled\"\n            [displayValuePipe]=\"displayValuePipe\"\n            [focusedValuePipe]=\"inputValuePipe\"\n            (blur)=\"onBlur($event)\"\n            (wheel)=\"onWheel($event)\"\n            (input)=\"onInput($event)\"\n            (focus)=\"onFocus()\"\n            [tabindex]='editorTabIndex'\n        />\n        <igx-suffix *ngIf=\"!isEmpty\" (click)=\"clear()\">\n            <igx-icon>clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            },] }
];
IgxDatePickerComponent.ctorParameters = () => [
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgModuleRef },
    { type: Injector },
    { type: Renderer2 }
];
IgxDatePickerComponent.propDecorators = {
    label: [{ type: Input }],
    labelVisibility: [{ type: Input }],
    locale: [{ type: Input }],
    editorTabIndex: [{ type: Input }],
    weekStart: [{ type: Input }],
    formatOptions: [{ type: Input }],
    hideOutsideDays: [{ type: Input }],
    monthsViewNumber: [{ type: Input }],
    showWeekNumbers: [{ type: Input }],
    format: [{ type: Input }],
    mask: [{ type: Input }],
    formatViews: [{ type: Input }],
    disabledDates: [{ type: Input }],
    specialDates: [{ type: Input }],
    modalOverlaySettings: [{ type: Input }],
    dropDownOverlaySettings: [{ type: Input }],
    value: [{ type: Input }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    formatter: [{ type: Input }],
    disabled: [{ type: Input }],
    vertical: [{ type: Input }],
    todayButtonLabel: [{ type: Input }],
    cancelButtonLabel: [{ type: Input }],
    mode: [{ type: Input }],
    isSpinLoop: [{ type: Input }],
    outlet: [{ type: Input }],
    onOpened: [{ type: Output }],
    onClosed: [{ type: Output }],
    onClosing: [{ type: Output }],
    onSelection: [{ type: Output }],
    valueChange: [{ type: Output }],
    onDisabledDate: [{ type: Output }],
    onValidationFailed: [{ type: Output }],
    _labelDirectiveUserTemplate: [{ type: ContentChild, args: [IgxLabelDirective,] }],
    headerTemplate: [{ type: ContentChild, args: [IgxCalendarHeaderTemplateDirective, { read: IgxCalendarHeaderTemplateDirective },] }],
    subheaderTemplate: [{ type: ContentChild, args: [IgxCalendarSubheaderTemplateDirective, { read: IgxCalendarSubheaderTemplateDirective },] }],
    datePickerActionsDirective: [{ type: ContentChild, args: [IgxDatePickerActionsDirective, { read: IgxDatePickerActionsDirective },] }],
    readOnlyDatePickerTemplate: [{ type: ViewChild, args: ['readOnlyDatePickerTemplate', { read: TemplateRef, static: true },] }],
    editableDatePickerTemplate: [{ type: ViewChild, args: ['editableDatePickerTemplate', { read: TemplateRef, static: true },] }],
    _inputGroup: [{ type: ViewChild, args: [IgxInputGroupComponent,] }],
    _inputGroupUserTemplate: [{ type: ContentChild, args: [IgxInputGroupComponent,] }],
    _inputUserTemplateElementRef: [{ type: ContentChild, args: [IgxInputDirective, { read: ElementRef },] }],
    _labelDirective: [{ type: ViewChild, args: [IgxLabelDirective,] }],
    datePickerTemplateDirective: [{ type: ContentChild, args: [IgxDatePickerTemplateDirective, { read: IgxDatePickerTemplateDirective },] }],
    _inputElementRef: [{ type: ViewChild, args: [IgxInputDirective, { read: ElementRef },] }],
    _inputDirective: [{ type: ViewChild, args: [IgxInputDirective,] }],
    _inputDirectiveUserTemplates: [{ type: ContentChildren, args: [IgxInputDirective, { descendants: true },] }],
    onSpaceClick: [{ type: HostListener, args: ['keydown.spacebar', ['$event'],] }, { type: HostListener, args: ['keydown.space', ['$event'],] }]
};
__decorate([
    DeprecateProperty(`Use igxLabel inside the date picker to change the label:
    <igx-date-picker>
        <label igxLabel>Custom label</label>
    </igx-date-picker> `)
], IgxDatePickerComponent.prototype, "label", null);
/**
 * @hidden
 */
class IgxDatePickerModule {
}
IgxDatePickerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxDatePickerComponent,
                    IgxCalendarContainerComponent,
                    IgxDatePickerActionsDirective,
                    IgxDatePickerTemplateDirective,
                    DatePickerDisplayValuePipe,
                    DatePickerInputValuePipe
                ],
                entryComponents: [
                    IgxCalendarContainerComponent
                ],
                exports: [
                    IgxDatePickerComponent,
                    IgxDatePickerTemplateDirective,
                    IgxDatePickerActionsDirective,
                    DatePickerDisplayValuePipe,
                    DatePickerInputValuePipe,
                    IgxInputGroupModule
                ],
                imports: [
                    CommonModule,
                    IgxIconModule,
                    IgxInputGroupModule,
                    IgxCalendarModule,
                    IgxButtonModule,
                    IgxRippleModule,
                    IgxMaskModule,
                    IgxTextSelectionModule
                ]
            },] }
];

/**
 * @hidden
 */
class IgxDialogTitleDirective {
    constructor() {
        this.defaultStyle = true;
    }
}
IgxDialogTitleDirective.decorators = [
    { type: Directive, args: [{
                selector: 'igx-dialog-title,[igxDialogTitle]'
            },] }
];
IgxDialogTitleDirective.propDecorators = {
    defaultStyle: [{ type: HostBinding, args: ['class.igx-dialog__window-title',] }]
};
/**
 * @hidden
 */
class IgxDialogActionsDirective {
    constructor() {
        this.defaultClass = true;
    }
}
IgxDialogActionsDirective.decorators = [
    { type: Directive, args: [{
                selector: 'igx-dialog-actions,[igxDialogActions]'
            },] }
];
IgxDialogActionsDirective.propDecorators = {
    defaultClass: [{ type: HostBinding, args: ['class.igx-dialog__window-actions',] }]
};

let DIALOG_ID = 0;
/**
 * **Ignite UI for Angular Dialog Window** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/dialog.html)
 *
 * The Ignite UI Dialog Window presents a dialog window to the user which can simply display messages or display
 * more complicated visuals such as a user sign-in form.  It also provides a right and left button
 * which can be used for custom actions.
 *
 * Example:
 * ```html
 * <button (click)="form.open()">Show Dialog</button>
 * <igx-dialog #form title="Sign In" rightButtonLabel="OK">
 *   <div>
 *     <input type="text" igxInput/>
 *     <label igxLabel>Username</label>
 *   </div>
 *   <div>
 *     <input type="password" igxInput/>
 *     <label igxLabel>Password</label>
 *   </div>
 * </igx-dialog>
 * ```
 */
class IgxDialogComponent {
    constructor(elementRef, navService) {
        this.elementRef = elementRef;
        this.navService = navService;
        /**
         * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-dialog [id]="'igx-dialog-56'" #alert title="Notification"
         *  leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()">
         * </igx-dialog>
         * ```
         */
        this.id = `igx-dialog-${DIALOG_ID++}`;
        /**
         * An @Input property controlling the `title` of the dialog.
         * ```html
         * <igx-dialog title="Notification" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.title = '';
        /**
         *  An @Input property controlling the `message` of the dialog.
         * ```html
         * <igx-dialog message="Your email was sent!" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.message = '';
        /**
         * An @Input property to set the `label` of the left button of the dialog.
         * ```html
         * <igx-dialog leftButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonLabel = '';
        /**
         * An @Input property to set the left button `type`. The types are `flat`, `raised` and `fab`.
         * The `flat` type button is a rectangle and doesn't have a shadow. <br>
         * The `raised` type button is also a rectangle but has a shadow. <br>
         * The `fab` type button is a circle with a shadow. <br>
         * The default value is `flat`.
         * ```html
         * <igx-dialog leftButtonType="raised" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonType = 'flat';
        /**
         * An @Input property to set the left button color. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonColor="yellow" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonColor = '';
        /**
         * An @Input property to set the left button `background-color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonBackgroundColor="black" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonBackgroundColor = '';
        /**
         * An @Input property to set the left button `ripple`. The `ripple` animates a click/tap to a component as a series of fading waves.
         * The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonRipple="green" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonRipple = '';
        /**
         * An @Input property to set the `label` of the right button of the dialog.
         * ```html
         * <igx-dialog rightButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonLabel = '';
        /**
         * An @Input property to set the right button `type`. The types are `flat`, `raised` and `fab`.
         * The `flat` type button is a rectangle and doesn't have a shadow. <br>
         * The `raised` type button is also a rectangle but has a shadow. <br>
         * The `fab` type button is a circle with a shadow. <br>
         * The default value is `flat`.
         * ```html
         * <igx-dialog rightButtonType="fab" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonType = 'flat';
        /**
         * An @Input property to set the right button `color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog rightButtonColor="yellow" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonColor = '';
        /**
         * An @Input property to set the right button `background-color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog rightButtonBackgroundColor="black" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonBackgroundColor = '';
        /**
         * An @Input property to set the right button `ripple`.
         * ```html
         * <igx-dialog rightButtonRipple="green" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonRipple = '';
        /**
         * The default `tabindex` attribute for the component
         *
         * @hidden
         */
        this.tabindex = -1;
        /**
         * An event that is emitted before the dialog is opened.
         * ```html
         * <igx-dialog (onOpen)="onDialogOpenHandler($event)" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */
        this.onOpen = new EventEmitter();
        /**
         * An event that is emitted after the dialog is opened.
         * ```html
         * <igx-dialog (onOpened)="onDialogOpenedHandler($event)" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * An event that is emitted before the dialog is closed.
         * ```html
         * <igx-dialog (onClose)="onDialogCloseHandler($event)" title="Confirmation" leftButtonLabel="Cancel" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */
        this.onClose = new EventEmitter();
        /**
         * An event that is emitted after the dialog is closed.
         * ```html
         * <igx-dialog (onClosed)="onDialogClosedHandler($event)" title="Confirmation" leftButtonLabel="Cancel" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * An event that is emitted when the left button is clicked.
         * ```html
         * <igx-dialog (onLeftButtonSelect)="onDialogOKSelected($event)" #dialog leftButtonLabel="OK" rightButtonLabel="Cancel">
         * </igx-dialog>
         * ```
         */
        this.onLeftButtonSelect = new EventEmitter();
        /**
         * An event that is emitted when the right button is clicked.
         * ```html
         * <igx-dialog (onRightButtonSelect)="onDialogOKSelected($event)"
         * #dialog title="Confirmation" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK"
         * rightButtonRipple="#4CAF50" closeOnOutsideSelect="true">
         * </igx-dialog>
         * ```
         */
        this.onRightButtonSelect = new EventEmitter();
        /**
         * @hidden
         */
        this.isOpenChange = new EventEmitter();
        this.destroy$ = new Subject();
        this._positionSettings = {
            openAnimation: useAnimation(slideInBottom, { params: { fromPosition: 'translateY(100%)' } }),
            closeAnimation: useAnimation(slideOutTop, { params: { toPosition: 'translateY(-100%)' } })
        };
        this._closeOnOutsideSelect = false;
        this._closeOnEscape = true;
        this._isModal = true;
        this._titleId = IgxDialogComponent.NEXT_ID++ + '_title';
        this._overlayDefaultSettings = {
            positionStrategy: new GlobalPositionStrategy(this._positionSettings),
            scrollStrategy: new NoOpScrollStrategy(),
            modal: this.isModal,
            closeOnEscape: this._closeOnEscape,
            closeOnOutsideClick: this.closeOnOutsideSelect
        };
    }
    /**
     * Controls whether the dialog should be shown as modal. Defaults to `true`
     * ```html
     * <igx-dialog [isModal]="false" ></igx-dialog>
     * ```
     */
    get isModal() {
        return this._isModal;
    }
    set isModal(val) {
        this._overlayDefaultSettings.modal = val;
        this._isModal = val;
    }
    /**
     * Controls whether the dialog should close when `Esc` key is pressed. Defaults to `true`
     * ```html
     * <igx-dialog [closeOnEscape]="false" ></igx-dialog>
     * ```
     */
    get closeOnEscape() {
        return this._closeOnEscape;
    }
    set closeOnEscape(val) {
        this._overlayDefaultSettings.closeOnEscape = val;
        this._closeOnEscape = val;
    }
    /**
     * An @Input property that allows you to enable the "close on click outside the dialog". By default it's disabled.
     * ```html
     * <igx-dialog closeOnOutsideSelect="true" leftButtonLabel="Cancel" (onLeftButtonSelect)="dialog.close()"
     * rightButtonLabel="OK" rightButtonRipple="#4CAF50" (onRightButtonSelect)="onDialogOKSelected($event)">
     * </igx-dialog>
     * ```
     */
    get closeOnOutsideSelect() {
        return this._closeOnOutsideSelect;
    }
    set closeOnOutsideSelect(val) {
        this._overlayDefaultSettings.closeOnOutsideClick = val;
        this._closeOnOutsideSelect = val;
    }
    /**
     * Get the position and animation settings used by the dialog.
     * ```typescript
     * @ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
     * let currentPosition: PositionSettings = this.alert.positionSettings
     * ```
     */
    get positionSettings() {
        return this._positionSettings;
    }
    /**
     * Set the position and animation settings used by the dialog.
     * ```typescript
     * import { slideInLeft, slideOutRight } from 'igniteui-angular';
     * ...
     * @ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
     *  public newPositionSettings: PositionSettings = {
     *      openAnimation: useAnimation(slideInTop, { params: { duration: '2000ms' } }),
     *      closeAnimation: useAnimation(slideOutBottom, { params: { duration: '2000ms'} }),
     *      horizontalDirection: HorizontalAlignment.Left,
     *      verticalDirection: VerticalAlignment.Middle,
     *      horizontalStartPoint: HorizontalAlignment.Left,
     *      verticalStartPoint: VerticalAlignment.Middle,
     *      minSize: { height: 100, width: 100 }
     *  };
     * this.alert.positionSettings = this.newPositionSettings;
     * ```
     */
    set positionSettings(settings) {
        this._positionSettings = settings;
        this._overlayDefaultSettings.positionStrategy = new GlobalPositionStrategy(this._positionSettings);
    }
    /**
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * Returns the value of state. Possible state values are "open" or "close".
     * ```typescript
     * @ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *     let dialogState = this.dialog.state;
     * }
     * ```
     */
    get state() {
        return this.isOpen ? 'open' : 'close';
    }
    /**
     * State of the dialog.
     *
     * ```typescript
     * // get
     * let dialogIsOpen = this.dialog.isOpen;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-dialog [isOpen]='false'></igx-dialog>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <!--set-->
     * <igx-dialog [(isOpen)]='model.isOpen'></igx-dialog>
     * ```
     */
    get isOpen() {
        return !this.toggleRef.collapsed;
    }
    set isOpen(value) {
        if (value !== this.isOpen) {
            this.isOpenChange.emit(value);
            if (value) {
                requestAnimationFrame(() => {
                    this.open();
                });
            }
            else {
                this.close();
            }
        }
    }
    get isCollapsed() {
        return this.toggleRef.collapsed;
    }
    /**
     * Returns the value of the role of the dialog. The valid values are `dialog`, `alertdialog`, `alert`.
     * ```typescript
     * @ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *     let dialogRole = this.dialog.role;
     * }
     *  ```
     */
    get role() {
        if (this.leftButtonLabel !== '' && this.rightButtonLabel !== '') {
            return 'dialog';
        }
        else if (this.leftButtonLabel !== '' ||
            this.rightButtonLabel !== '') {
            return 'alertdialog';
        }
        else {
            return 'alert';
        }
    }
    /**
     * Returns the value of the title id.
     * ```typescript
     *  @ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *     let dialogTitle = this.dialog.titleId;
     * }
     * ```
     */
    get titleId() {
        return this._titleId;
    }
    ngAfterContentInit() {
        this.toggleRef.onClosing.pipe(takeUntil(this.destroy$)).subscribe((eventArgs) => this.emitCloseFromDialog(eventArgs));
        this.toggleRef.onClosed.pipe(takeUntil(this.destroy$)).subscribe((eventArgs) => this.emitClosedFromDialog(eventArgs));
        this.toggleRef.onOpened.pipe(takeUntil(this.destroy$)).subscribe((eventArgs) => this.emitOpenedFromDialog(eventArgs));
    }
    /**
     * A method that opens the dialog.
     *
     * @memberOf {@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.open() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     */
    open(overlaySettings = this._overlayDefaultSettings) {
        const eventArgs = { dialog: this, event: null, cancel: false };
        this.onOpen.emit(eventArgs);
        if (!eventArgs.cancel) {
            this.toggleRef.open(overlaySettings);
            this.isOpenChange.emit(true);
            if (!this.leftButtonLabel && !this.rightButtonLabel) {
                this.toggleRef.element.focus();
            }
        }
    }
    /**
     * A method that that closes the dialog.
     *
     *  @memberOf {@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.close() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     */
    close() {
        // `onClose` will emit from `toggleRef.onClosing` subscription
        this.toggleRef.close();
    }
    /**
     * A method that opens/closes the dialog.
     *
     * @memberOf {@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.toggle() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     */
    toggle() {
        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * @hidden
     */
    onDialogSelected(event) {
        event.stopPropagation();
        if (this.isOpen &&
            this.closeOnOutsideSelect &&
            event.target.classList.contains(IgxDialogComponent.DIALOG_CLASS)) {
            this.close();
        }
    }
    /**
     * @hidden
     */
    onInternalLeftButtonSelect(event) {
        this.onLeftButtonSelect.emit({ dialog: this, event });
    }
    /**
     * @hidden
     */
    onInternalRightButtonSelect(event) {
        this.onRightButtonSelect.emit({ dialog: this, event });
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.navService && this.id) {
            this.navService.add(this.id, this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.navService && this.id) {
            this.navService.remove(this.id);
        }
    }
    emitCloseFromDialog(eventArgs) {
        const dialogEventsArgs = { dialog: this, event: eventArgs.event, cancel: eventArgs.cancel };
        this.onClose.emit(dialogEventsArgs);
        eventArgs.cancel = dialogEventsArgs.cancel;
        if (!eventArgs.cancel) {
            this.isOpenChange.emit(false);
        }
    }
    emitClosedFromDialog(eventArgs) {
        this.onClosed.emit({ dialog: this, event: eventArgs.event });
    }
    emitOpenedFromDialog(eventArgs) {
        this.onOpened.emit({ dialog: this, event: eventArgs.event });
    }
}
IgxDialogComponent.NEXT_ID = 1;
IgxDialogComponent.DIALOG_CLASS = 'igx-dialog';
IgxDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-dialog',
                template: "<div tabindex=\"0\" #dialog class=\"igx-dialog\" igxToggle (click)=\"onDialogSelected($event)\">\n    <div #dialogWindow class=\"igx-dialog__window\"  [attr.role]=\"role\" [attr.aria-labelledby]=\"titleId\">\n\n        <div *ngIf=\"title\" [attr.id]=\"titleId\" class=\"igx-dialog__window-title\">\n            {{ title }}\n        </div>\n        <ng-content *ngIf=\"!title\" select=\"igx-dialog-title,[igxDialogTitle]\"></ng-content>\n\n        <div class=\"igx-dialog__window-content\">\n            <span *ngIf=\"message\" class=\"igx-dialog__window-message\">{{ message }}</span>\n            <ng-content *ngIf=\"!message\"></ng-content>\n        </div>\n\n        <div *ngIf=\"leftButtonLabel || rightButtonLabel\" class=\"igx-dialog__window-actions\">\n            <button *ngIf=\"leftButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ leftButtonType }}\" igxButtonColor=\"{{ leftButtonColor }}\" igxButtonBackground=\"{{ leftButtonBackgroundColor }}\"\n                igxRipple=\"{{ leftButtonRipple }}\" (click)=\"onInternalLeftButtonSelect($event)\">\n                {{ leftButtonLabel }}\n            </button>\n            <button *ngIf=\"rightButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ rightButtonType }}\" igxButtonColor=\"{{ rightButtonColor }}\" igxButtonBackground=\"{{ rightButtonBackgroundColor }}\"\n                igxRipple=\"{{ rightButtonRipple }}\" (click)=\"onInternalRightButtonSelect($event)\">\n                {{ rightButtonLabel }}\n            </button>\n        </div>\n        <ng-content *ngIf=\"!leftButtonLabel && !rightButtonLabel\" select=\"igx-dialog-actions,[igxDialogActions]\"></ng-content>\n\n    </div>\n</div>\n"
            },] }
];
IgxDialogComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
IgxDialogComponent.propDecorators = {
    toggleRef: [{ type: ViewChild, args: [IgxToggleDirective, { static: true },] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    isModal: [{ type: Input }],
    closeOnEscape: [{ type: Input }],
    title: [{ type: Input }],
    message: [{ type: Input }],
    leftButtonLabel: [{ type: Input }],
    leftButtonType: [{ type: Input }],
    leftButtonColor: [{ type: Input }],
    leftButtonBackgroundColor: [{ type: Input }],
    leftButtonRipple: [{ type: Input }],
    rightButtonLabel: [{ type: Input }],
    rightButtonType: [{ type: Input }],
    rightButtonColor: [{ type: Input }],
    rightButtonBackgroundColor: [{ type: Input }],
    rightButtonRipple: [{ type: Input }],
    closeOnOutsideSelect: [{ type: Input }],
    positionSettings: [{ type: Input }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    onOpen: [{ type: Output }],
    onOpened: [{ type: Output }],
    onClose: [{ type: Output }],
    onClosed: [{ type: Output }],
    onLeftButtonSelect: [{ type: Output }],
    onRightButtonSelect: [{ type: Output }],
    isOpenChange: [{ type: Output }],
    isOpen: [{ type: Input }],
    isCollapsed: [{ type: HostBinding, args: ['class.igx-dialog--hidden',] }],
    role: [{ type: Input }],
    titleId: [{ type: Input }]
};
/**
 * @hidden
 */
class IgxDialogModule {
}
IgxDialogModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                exports: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                imports: [CommonModule, IgxToggleModule, IgxButtonModule, IgxRippleModule, IgxFocusModule]
            },] }
];

const FilterMode = mkenum({
    quickFilter: 'quickFilter',
    excelStyleFilter: 'excelStyleFilter'
});
const GridSummaryPosition = mkenum({
    top: 'top',
    bottom: 'bottom'
});
const GridSummaryCalculationMode = mkenum({
    rootLevelOnly: 'rootLevelOnly',
    childLevelsOnly: 'childLevelsOnly',
    rootAndChildLevels: 'rootAndChildLevels'
});
const GridSelectionMode = mkenum({
    none: 'none',
    single: 'single',
    multiple: 'multiple',
    multipleCascade: 'multipleCascade'
});
const ColumnDisplayOrder = mkenum({
    Alphabetical: 'Alphabetical',
    DisplayOrder: 'DisplayOrder'
});
var ColumnPinningPosition;
(function (ColumnPinningPosition) {
    ColumnPinningPosition[ColumnPinningPosition["Start"] = 0] = "Start";
    ColumnPinningPosition[ColumnPinningPosition["End"] = 1] = "End";
})(ColumnPinningPosition || (ColumnPinningPosition = {}));
var RowPinningPosition;
(function (RowPinningPosition) {
    RowPinningPosition[RowPinningPosition["Top"] = 0] = "Top";
    RowPinningPosition[RowPinningPosition["Bottom"] = 1] = "Bottom";
})(RowPinningPosition || (RowPinningPosition = {}));
var GridPagingMode;
(function (GridPagingMode) {
    GridPagingMode[GridPagingMode["Local"] = 0] = "Local";
    GridPagingMode[GridPagingMode["Remote"] = 1] = "Remote";
})(GridPagingMode || (GridPagingMode = {}));

/**
 * @hidden
 */
class FilterListItem {
    constructor() {
        this.isSpecial = false;
        this.isBlanks = false;
    }
}
class IgxExcelStyleColumnOperationsTemplateDirective {
    constructor() { }
}
IgxExcelStyleColumnOperationsTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'igx-excel-style-column-operations,[igxExcelStyleColumnOperations]'
            },] }
];
IgxExcelStyleColumnOperationsTemplateDirective.ctorParameters = () => [];
class IgxExcelStyleFilterOperationsTemplateDirective {
    constructor() { }
}
IgxExcelStyleFilterOperationsTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'igx-excel-style-filter-operations,[igxExcelStyleFilterOperations]'
            },] }
];
IgxExcelStyleFilterOperationsTemplateDirective.ctorParameters = () => [];
/**
 * A component used for presenting Excel style filtering UI for a specific column.
 * It is used internally in the Grid, but could also be hosted in a container outside of it.
 *
 * Example:
 * ```html
 * <igx-grid-excel-style-filtering
 *     [column]="grid1.columns[0]">
 * </igx-grid-excel-style-filtering>
 * ```
 */
class IgxGridExcelStyleFilteringComponent {
    constructor(cdr, element, gridAPI) {
        this.cdr = cdr;
        this.element = element;
        this.gridAPI = gridAPI;
        /**
         * @hidden @internal
         */
        this.defaultClass = true;
        /**
         * @hidden @internal
         */
        this.inline = true;
        /**
         * @hidden @internal
         */
        this.loadingStart = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.loadingEnd = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.initialized = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.sortingChanged = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.columnChange = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.listDataLoaded = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.expressionsList = new Array();
        /**
         * @hidden @internal
         */
        this.listData = new Array();
        /**
         * @hidden @internal
         */
        this.uniqueValues = [];
        this.destroy$ = new Subject();
        this.containsNullOrEmpty = false;
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        this.filterValues = new Set();
    }
    /**
     * An @Input property that sets the column.
     */
    set column(value) {
        this._column = value;
        this.listData = new Array();
        this.columnChange.emit(this._column);
        if (this._columnPinning) {
            this._columnPinning.unsubscribe();
        }
        if (this._columnVisibilityChanged) {
            this._columnVisibilityChanged.unsubscribe();
        }
        if (this._sortingChanged) {
            this._sortingChanged.unsubscribe();
        }
        if (this._filteringChanged) {
            this._filteringChanged.unsubscribe();
        }
        if (this._densityChanged) {
            this._densityChanged.unsubscribe();
        }
        if (this._columnMoved) {
            this._columnMoved.unsubscribe();
        }
        if (this._column) {
            this._column.grid.filteringService.registerSVGIcons();
            this.init();
            this.sortingChanged.emit();
            this._columnPinning = this.grid.onColumnPinning.pipe(takeUntil(this.destroy$)).subscribe(() => {
                requestAnimationFrame(() => {
                    if (!this.cdr.destroyed) {
                        this.cdr.detectChanges();
                    }
                });
            });
            this._columnVisibilityChanged = this.grid.onColumnVisibilityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.cdr.detectChanges();
            });
            this._sortingChanged = this.grid.sortingExpressionsChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.sortingChanged.emit();
            });
            this._filteringChanged = this.grid.filteringExpressionsTreeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.init();
            });
            this._densityChanged = this.grid.onDensityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.cdr.detectChanges();
            });
            this._columnMoved = this.grid.onColumnMovingEnd.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.cdr.detectChanges();
            });
        }
    }
    /**
     * Returns the current column.
     */
    get column() {
        return this._column;
    }
    /**
     * @hidden @internal
     */
    get filteringService() {
        return this.grid.filteringService;
    }
    /**
     * Gets the minimum height.
     */
    get minHeight() {
        if (this._minHeight || this._minHeight === 0) {
            return this._minHeight;
        }
        if (!this.inline) {
            let minHeight = 645;
            switch (this.displayDensity) {
                case DisplayDensity.cosy:
                    minHeight = 465;
                    break;
                case DisplayDensity.compact:
                    minHeight = 330;
                    break;
                default: break;
            }
            return `${minHeight}px`;
        }
    }
    /**
     * Sets the minimum height.
     */
    set minHeight(value) {
        this._minHeight = value;
    }
    /**
     * Gets the maximum height.
     */
    get maxHeight() {
        if (this._maxHeight) {
            return this._maxHeight;
        }
        if (!this.inline) {
            let maxHeight = 775;
            switch (this.displayDensity) {
                case DisplayDensity.cosy:
                    maxHeight = 565;
                    break;
                case DisplayDensity.compact:
                    maxHeight = 405;
                    break;
                default: break;
            }
            return `${maxHeight}px`;
        }
    }
    /**
     * Sets the maximum height.
     */
    set maxHeight(value) {
        this._maxHeight = value;
    }
    /**
     * @hidden @internal
     */
    get grid() {
        var _a, _b, _c;
        return (_b = (_a = this.column) === null || _a === void 0 ? void 0 : _a.grid) !== null && _b !== void 0 ? _b : (_c = this.gridAPI) === null || _c === void 0 ? void 0 : _c.grid;
    }
    /**
     * @hidden @internal
     */
    get displayDensity() {
        var _a;
        return (_a = this.grid) === null || _a === void 0 ? void 0 : _a.displayDensity;
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden @internal
     */
    selectedClass() {
        return this.column.selected ? 'igx-excel-filter__actions-selected' : 'igx-excel-filter__actions-select';
    }
    /**
     * @hidden @internal
     */
    initialize(column, overlayService, overlayComponentId) {
        this.inline = false;
        this.column = column;
        this.overlayService = overlayService;
        this.overlayComponentId = overlayComponentId;
        if (this._originalDisplay) {
            this.element.nativeElement.style.display = this._originalDisplay;
        }
        this.initialized.emit();
        this.grid.onColumnMoving.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.closeDropdown();
        });
    }
    /**
     * @hidden @internal
     */
    onPin() {
        this.column.pinned = !this.column.pinned;
        this.closeDropdown();
    }
    /**
     * @hidden @internal
     */
    onSelect() {
        if (!this.column.selected) {
            this.grid.selectionService.selectColumn(this.column.field, this.grid.columnSelection === GridSelectionMode.single);
        }
        else {
            this.grid.selectionService.deselectColumn(this.column.field);
        }
        this.grid.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    columnSelectable() {
        var _a, _b;
        return ((_a = this.grid) === null || _a === void 0 ? void 0 : _a.columnSelection) !== GridSelectionMode.none && ((_b = this.column) === null || _b === void 0 ? void 0 : _b.selectable);
    }
    /**
     * @hidden @internal
     */
    onHideToggle() {
        this.column.toggleVisibility();
        this.closeDropdown();
    }
    /**
     * @hidden @internal
     */
    cancel() {
        if (!this.overlayComponentId) {
            this.init();
        }
        this.closeDropdown();
    }
    /**
     * @hidden @internal
     */
    closeDropdown() {
        if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
            this.overlayComponentId = null;
        }
    }
    /**
     * @hidden @internal
     */
    onKeyDown(eventArgs) {
        if (eventArgs.key === "Escape" /* ESCAPE */ || eventArgs.key === "Esc" /* ESCAPE_IE */ ||
            eventArgs.ctrlKey && eventArgs.shiftKey && eventArgs.key.toLowerCase() === 'l') {
            this.closeDropdown();
        }
        eventArgs.stopPropagation();
    }
    /**
     * @hidden @internal
     */
    hide() {
        this._originalDisplay = document.defaultView.getComputedStyle(this.element.nativeElement).display;
        this.element.nativeElement.style.display = 'none';
    }
    /**
     * @hidden @internal
     */
    detectChanges() {
        this.cdr.detectChanges();
    }
    init() {
        this.expressionsList = new Array();
        this.filteringService.generateExpressionsList(this.column.filteringExpressionsTree, this.grid.filteringLogic, this.expressionsList);
        this.populateColumnData();
    }
    areExpressionsSelectable() {
        if (this.expressionsList.length === 1 &&
            (this.expressionsList[0].expression.condition.name === 'equals' ||
                this.expressionsList[0].expression.condition.name === 'true' ||
                this.expressionsList[0].expression.condition.name === 'false' ||
                this.expressionsList[0].expression.condition.name === 'empty' ||
                this.expressionsList[0].expression.condition.name === 'in')) {
            return true;
        }
        const selectableExpressionsCount = this.expressionsList.filter(exp => (exp.beforeOperator === 1 || exp.afterOperator === 1) &&
            (exp.expression.condition.name === 'equals' ||
                exp.expression.condition.name === 'true' ||
                exp.expression.condition.name === 'false' ||
                exp.expression.condition.name === 'empty' ||
                exp.expression.condition.name === 'in')).length;
        return selectableExpressionsCount === this.expressionsList.length;
    }
    areExpressionsValuesInTheList() {
        if (this.column.dataType === DataType.Boolean) {
            return true;
        }
        if (this.filterValues.size === 1) {
            const firstValue = this.filterValues.values().next().value;
            if (!firstValue && firstValue !== 0) {
                return true;
            }
        }
        for (const expression of this.uniqueValues) {
            const value = this.getExpressionValue(expression);
            if (this.filterValues.has(value)) {
                return true;
            }
        }
        return false;
    }
    populateColumnData() {
        if (this.grid.uniqueColumnValuesStrategy) {
            this.cdr.detectChanges();
            this.renderColumnValuesRemotely();
        }
        else {
            this.renderColumnValuesFromData();
        }
    }
    renderColumnValuesRemotely() {
        this.loadingStart.emit();
        const expressionsTree = this.getColumnFilterExpressionsTree();
        const prevColumn = this.column;
        this.grid.uniqueColumnValuesStrategy(this.column, expressionsTree, (colVals) => {
            if (!this.column || this.column !== prevColumn) {
                return;
            }
            const columnValues = (this.column.dataType === DataType.Date) ?
                colVals.map(value => {
                    const label = this.getFilterItemLabel(value);
                    return { label, value };
                }) : colVals;
            this.renderValues(columnValues);
            this.loadingEnd.emit();
        });
    }
    shouldFormatValues() {
        return this.column.formatter &&
            (this.grid.filterStrategy instanceof FormattedValuesFilteringStrategy ||
                this.grid.filterStrategy instanceof TreeGridFormattedValuesFilteringStrategy) &&
            this.grid.filterStrategy.shouldApplyFormatter(this.column.field);
    }
    renderColumnValuesFromData() {
        const expressionsTree = this.getColumnFilterExpressionsTree();
        const data = this.column.gridAPI.filterDataByExpressions(expressionsTree);
        const shouldFormatValues = this.shouldFormatValues();
        const columnField = this.column.field;
        const columnValues = (this.column.dataType === DataType.Date) ?
            data.map(record => {
                const value = (resolveNestedPath(record, columnField));
                const label = this.getFilterItemLabel(value);
                return { label, value };
            }) : data.map(record => {
            const value = resolveNestedPath(record, columnField);
            return shouldFormatValues ? this.column.formatter(value) : value;
        });
        this.renderValues(columnValues);
    }
    renderValues(columnValues) {
        this.generateUniqueValues(columnValues);
        this.generateFilterValues(this.column.dataType === DataType.Date);
        this.generateListData();
    }
    generateUniqueValues(columnValues) {
        if (this.column.dataType === DataType.String && this.column.filteringIgnoreCase) {
            const filteredUniqueValues = columnValues.map(s => s === null || s === void 0 ? void 0 : s.toString().toLowerCase())
                .reduce((map, val, i) => map.get(val) ? map : map.set(val, columnValues[i]), new Map());
            this.uniqueValues = Array.from(filteredUniqueValues.values());
        }
        else {
            this.uniqueValues = this.column.dataType === DataType.Date ? uniqueDates(columnValues) : Array.from(new Set(columnValues));
        }
    }
    generateFilterValues(isDateColumn = false) {
        if (isDateColumn) {
            this.filterValues = new Set(this.expressionsList.reduce((arr, e) => {
                if (e.expression.condition.name === 'in') {
                    return [...arr, ...Array.from(e.expression.searchVal.values()).map(v => new Date(v).toISOString())];
                }
                return [...arr, ...[e.expression.searchVal ? e.expression.searchVal.toISOString() : e.expression.searchVal]];
            }, []));
        }
        else {
            this.filterValues = new Set(this.expressionsList.reduce((arr, e) => {
                if (e.expression.condition.name === 'in') {
                    return [...arr, ...Array.from(e.expression.searchVal.values())];
                }
                return [...arr, ...[e.expression.searchVal]];
            }, []));
        }
    }
    generateListData() {
        this.listData = new Array();
        const shouldUpdateSelection = this.areExpressionsSelectable() && this.areExpressionsValuesInTheList();
        if (this.column.dataType === DataType.Boolean) {
            this.addBooleanItems();
        }
        else {
            this.addItems(shouldUpdateSelection);
        }
        this.listData.sort((a, b) => this.sortData(a, b));
        if (this.containsNullOrEmpty) {
            this.addBlanksItem(shouldUpdateSelection);
        }
        if (this.listData.length > 0) {
            this.addSelectAllItem();
        }
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
        this.listDataLoaded.emit();
    }
    getColumnFilterExpressionsTree() {
        const gridExpressionsTree = this.grid.filteringExpressionsTree;
        const expressionsTree = new FilteringExpressionsTree(gridExpressionsTree.operator, gridExpressionsTree.fieldName);
        for (const operand of gridExpressionsTree.filteringOperands) {
            if (operand instanceof FilteringExpressionsTree) {
                const columnExprTree = operand;
                if (columnExprTree.fieldName === this.column.field) {
                    break;
                }
            }
            expressionsTree.filteringOperands.push(operand);
        }
        return expressionsTree;
    }
    addBooleanItems() {
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        this.uniqueValues.forEach(element => {
            const filterListItem = new FilterListItem();
            if (element !== undefined && element !== null && element !== '') {
                if (this.column.filteringExpressionsTree) {
                    if (element === true && this.expressionsList.find(exp => exp.expression.condition.name === 'true')) {
                        filterListItem.isSelected = true;
                        filterListItem.isFiltered = true;
                        this.selectAllIndeterminate = true;
                    }
                    else if (element === false && this.expressionsList.find(exp => exp.expression.condition.name === 'false')) {
                        filterListItem.isSelected = true;
                        filterListItem.isFiltered = true;
                        this.selectAllIndeterminate = true;
                    }
                    else {
                        filterListItem.isSelected = false;
                        filterListItem.isFiltered = false;
                    }
                }
                else {
                    filterListItem.isSelected = true;
                    filterListItem.isFiltered = true;
                }
                filterListItem.value = element;
                filterListItem.label = element ?
                    this.grid.resourceStrings.igx_grid_filter_true :
                    this.grid.resourceStrings.igx_grid_filter_false;
                filterListItem.indeterminate = false;
                this.listData.push(filterListItem);
            }
            else {
                this.containsNullOrEmpty = true;
            }
        });
    }
    addItems(shouldUpdateSelection) {
        this.selectAllSelected = true;
        this.containsNullOrEmpty = false;
        this.selectAllIndeterminate = false;
        const applyFormatter = !this.shouldFormatValues();
        this.uniqueValues.forEach(element => {
            const hasValue = (element !== undefined && element !== null && element !== '' && this.column.dataType !== DataType.Date)
                || !!(element && element.label);
            if (hasValue) {
                const filterListItem = new FilterListItem();
                filterListItem.isSelected = true;
                filterListItem.isFiltered = true;
                if (this.column.filteringExpressionsTree) {
                    filterListItem.isSelected = false;
                    filterListItem.isFiltered = false;
                    if (shouldUpdateSelection) {
                        const value = this.getExpressionValue(element);
                        if (this.filterValues.has(value)) {
                            filterListItem.isSelected = true;
                            filterListItem.isFiltered = true;
                        }
                        this.selectAllIndeterminate = true;
                    }
                    else {
                        this.selectAllSelected = false;
                    }
                }
                filterListItem.value = this.getFilterItemValue(element);
                filterListItem.label = this.getFilterItemLabel(element, applyFormatter);
                filterListItem.indeterminate = false;
                this.listData.push(filterListItem);
            }
        });
        this.containsNullOrEmpty = this.uniqueValues.length > this.listData.length;
    }
    addSelectAllItem() {
        const selectAll = new FilterListItem();
        selectAll.isSelected = this.selectAllSelected;
        selectAll.value = this.grid.resourceStrings.igx_grid_excel_select_all;
        selectAll.label = this.grid.resourceStrings.igx_grid_excel_select_all;
        selectAll.indeterminate = this.selectAllIndeterminate;
        selectAll.isSpecial = true;
        selectAll.isFiltered = this.selectAllSelected;
        this.listData.unshift(selectAll);
    }
    addBlanksItem(shouldUpdateSelection) {
        const blanks = new FilterListItem();
        if (this.column.filteringExpressionsTree) {
            if (shouldUpdateSelection) {
                if (this.filterValues.has(null)) {
                    blanks.isSelected = true;
                    blanks.isFiltered = true;
                }
                else {
                    blanks.isSelected = false;
                    blanks.isFiltered = false;
                }
            }
        }
        else {
            blanks.isSelected = true;
            blanks.isFiltered = true;
        }
        blanks.value = null;
        blanks.label = this.grid.resourceStrings.igx_grid_excel_blanks;
        blanks.indeterminate = false;
        blanks.isSpecial = true;
        blanks.isBlanks = true;
        this.listData.unshift(blanks);
    }
    sortData(a, b) {
        let valueA = a.value;
        let valueB = b.value;
        if (typeof (a) === DataType.String) {
            valueA = a.value.toUpperCase();
            valueB = b.value.toUpperCase();
        }
        if (valueA < valueB) {
            return -1;
        }
        else if (valueA > valueB) {
            return 1;
        }
        else {
            return 0;
        }
    }
    getFilterItemLabel(element, applyFormatter = true) {
        if (this.column.dataType === DataType.Date) {
            return element && element.label ? element.label : this.column.formatter ?
                applyFormatter ? this.column.formatter(element) : element :
                this.grid.datePipe.transform(element, this.column.pipeArgs.format, this.column.pipeArgs.timezone, this.grid.locale);
        }
        if (this.column.dataType === DataType.Number) {
            return this.column.formatter ?
                applyFormatter ? this.column.formatter(element) : element :
                this.grid.decimalPipe.transform(element, this.column.pipeArgs.digitsInfo, this.grid.locale);
        }
        if (this.column.dataType === DataType.Currency) {
            return this.column.formatter ?
                applyFormatter ? this.column.formatter(element) : element :
                this.grid.currencyPipe.transform(element, this.column.pipeArgs.currencyCode ?
                    this.column.pipeArgs.currencyCode : getLocaleCurrencyCode(this.grid.locale), this.column.pipeArgs.display, this.column.pipeArgs.digitsInfo, this.grid.locale);
        }
        if (this.column.dataType === DataType.Percent) {
            return this.column.formatter ?
                applyFormatter ? this.column.formatter(element) : element :
                this.grid.percentPipe.transform(element, this.column.pipeArgs.digitsInfo, this.grid.locale);
        }
        return this.column.formatter && applyFormatter ?
            this.column.formatter(element) :
            element;
    }
    getFilterItemValue(element) {
        if (this.column.dataType === DataType.Date) {
            element = parseDate(element.value);
        }
        return element;
    }
    getExpressionValue(element) {
        let value;
        if (this.column.dataType === DataType.Date) {
            value = element && element.value ? new Date(element.value).toISOString() : element.value;
        }
        else {
            value = element;
        }
        return value;
    }
}
IgxGridExcelStyleFilteringComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-excel-style-filtering',
                template: "<ng-template #defaultExcelColumnOperations>\n    <igx-excel-style-header\n        [showHiding]=\"displayDensity !== 'comfortable' && !column?.disableHiding\"\n        [showPinning]=\"displayDensity !== 'comfortable' && !column?.disablePinning\"\n        [showSelecting]=\"displayDensity !== 'comfortable' && columnSelectable()\"\n    >\n    </igx-excel-style-header>\n\n    <igx-excel-style-sorting *ngIf=\"column?.sortable\">\n    </igx-excel-style-sorting>\n\n    <igx-excel-style-moving *ngIf=\"column?.movable\">\n    </igx-excel-style-moving>\n\n    <igx-excel-style-pinning *ngIf=\"!column?.disablePinning && displayDensity==='comfortable'\">\n    </igx-excel-style-pinning>\n\n    <igx-excel-style-hiding *ngIf=\"!column?.disableHiding && displayDensity==='comfortable'\">\n    </igx-excel-style-hiding>\n\n    <igx-excel-style-selecting *ngIf=\"columnSelectable() && displayDensity==='comfortable'\">\n    </igx-excel-style-selecting>\n</ng-template>\n\n<ng-template #defaultExcelFilterOperations>\n    <igx-excel-style-clear-filters>\n    </igx-excel-style-clear-filters>\n\n    <igx-excel-style-conditional-filter>\n    </igx-excel-style-conditional-filter>\n\n    <igx-excel-style-search>\n    </igx-excel-style-search>\n</ng-template>\n\n<article #mainDropdown\n    class=\"igx-excel-filter__menu\"\n    [ngClass]=\"{\n        'igx-excel-filter__menu--cosy': displayDensity === 'cosy',\n        'igx-excel-filter__menu--compact': displayDensity === 'compact'\n    }\"\n    [id]=\"overlayComponentId\"\n    (keydown)=\"onKeyDown($event)\"\n    [style.min-height]=\"minHeight\"\n    [style.max-height]=\"maxHeight\">\n\n    <ng-container *ngIf=\"this.excelColumnOperationsDirective; else defaultExcelColumnOperations\">\n        <ng-content select=\"igx-excel-style-column-operations,[igxExcelStyleColumnOperations]\">\n        </ng-content>\n    </ng-container>\n\n    <ng-container *ngIf=\"this.excelFilterOperationsDirective; else defaultExcelFilterOperations\">\n        <ng-content select=\"igx-excel-style-filter-operations,[igxExcelStyleFilterOperations]\">\n        </ng-content>\n    </ng-container>\n</article>\n"
            },] }
];
IgxGridExcelStyleFilteringComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: GridBaseAPIService, decorators: [{ type: Host }, { type: Optional }] }
];
IgxGridExcelStyleFilteringComponent.propDecorators = {
    defaultClass: [{ type: HostBinding, args: ['class.igx-excel-filter',] }],
    inline: [{ type: HostBinding, args: ['class.igx-excel-filter--inline',] }],
    loadingStart: [{ type: Output }],
    loadingEnd: [{ type: Output }],
    initialized: [{ type: Output }],
    sortingChanged: [{ type: Output }],
    columnChange: [{ type: Output }],
    listDataLoaded: [{ type: Output }],
    mainDropdown: [{ type: ViewChild, args: ['mainDropdown', { read: ElementRef },] }],
    excelColumnOperationsDirective: [{ type: ContentChild, args: [IgxExcelStyleColumnOperationsTemplateDirective, { read: IgxExcelStyleColumnOperationsTemplateDirective },] }],
    excelFilterOperationsDirective: [{ type: ContentChild, args: [IgxExcelStyleFilterOperationsTemplateDirective, { read: IgxExcelStyleFilterOperationsTemplateDirective },] }],
    defaultExcelColumnOperations: [{ type: ViewChild, args: ['defaultExcelColumnOperations', { read: TemplateRef, static: true },] }],
    defaultExcelFilterOperations: [{ type: ViewChild, args: ['defaultExcelFilterOperations', { read: TemplateRef, static: true },] }],
    column: [{ type: Input }],
    minHeight: [{ type: Input }],
    maxHeight: [{ type: Input }, { type: HostBinding, args: ['style.max-height',] }]
};

/**
 * A component used for presenting Excel style clear filters UI.
 */
class IgxExcelStyleClearFiltersComponent {
    constructor(esf) {
        this.esf = esf;
    }
    /**
     * @hidden @internal
     */
    clearFilterClass() {
        if (this.esf.column.filteringExpressionsTree) {
            return 'igx-excel-filter__actions-clear';
        }
        return 'igx-excel-filter__actions-clear--disabled';
    }
    /**
     * @hidden @internal
     */
    clearFilter() {
        this.esf.grid.filteringService.clearFilter(this.esf.column.field);
        this.selectAllFilterItems();
    }
    /**
     * @hidden @internal
     */
    onClearFilterKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.clearFilter();
        }
    }
    selectAllFilterItems() {
        this.esf.listData.forEach(filterListItem => {
            filterListItem.isSelected = true;
            filterListItem.indeterminate = false;
        });
        this.esf.detectChanges();
    }
}
IgxExcelStyleClearFiltersComponent.decorators = [
    { type: Component, args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-clear-filters',
                template: "<div *ngIf=\"esf.column\"\n    tabindex=\"0\"\n    [ngClass]=\"clearFilterClass()\"\n    (keydown)=\"onClearFilterKeyDown($event)\"\n    (click)=\"clearFilter()\">\n    <span>{{ esf.grid.resourceStrings.igx_grid_excel_filter_clear }}</span>\n    <igx-icon>clear</igx-icon>\n</div>\n"
            },] }
];
IgxExcelStyleClearFiltersComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];

/** @hidden */
class ExcelStylePositionStrategy extends AutoPositionStrategy {
    shouldFitInViewPort() {
        return true;
    }
    fitInViewport(element, connectedFit) {
        const heightOverflow = connectedFit.contentElementRect.height - connectedFit.viewPortRect.height;
        if (heightOverflow > 0) {
            element.style.width = 'auto';
            element.style.height = `${connectedFit.viewPortRect.height}px`;
        }
        else {
            element.style.height = `${Math.max(connectedFit.viewPortRect.height - connectedFit.targetRect.bottom - 1, connectedFit.contentElementRect.height)}px`;
        }
        super.fitInViewport(element, connectedFit);
    }
}

/**
 * @hidden
 */
class ExpressionUI {
    constructor() {
        this.isSelected = false;
        this.isVisible = true;
    }
}
/**
 * @hidden
 */
class IgxFilteringService {
    constructor(_moduleRef, iconService, _overlayService) {
        this._moduleRef = _moduleRef;
        this.iconService = iconService;
        this._overlayService = _overlayService;
        this.isFilterRowVisible = false;
        this.filteredColumn = null;
        this.selectedExpression = null;
        this.columnToMoreIconHidden = new Map();
        this.activeFilterCell = 0;
        this.columnsWithComplexFilter = new Set();
        this.areEventsSubscribed = false;
        this.destroy$ = new Subject();
        this.isFiltering = false;
        this.columnToExpressionsMap = new Map();
        this.columnStartIndex = -1;
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    toggleFilterDropdown(element, column, classRef) {
        if (!this._componentOverlayId || (this.column && this.column.field !== column.field)) {
            this.initFilteringSettings();
            this.column = column;
            const filterIcon = this.column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';
            const filterIconTarget = element.querySelector('.' + filterIcon);
            this._filterMenuOverlaySettings.target = filterIconTarget;
            this._filterMenuOverlaySettings.outlet = this.grid.outlet;
            if (this.grid.excelStyleFilteringComponent) {
                this._componentOverlayId =
                    this._overlayService.attach(this.grid.excelStyleFilteringComponent.element, this._filterMenuOverlaySettings);
            }
            else {
                this._componentOverlayId =
                    this._overlayService.attach(classRef, this._filterMenuOverlaySettings, this._moduleRef);
            }
            this._overlayService.show(this._componentOverlayId, this._filterMenuOverlaySettings);
        }
    }
    initFilteringSettings() {
        this._filterMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Bottom,
            openAnimation: useAnimation(fadeIn, { params: { duration: '250ms' } }),
            closeAnimation: null
        };
        this._filterMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new ExcelStylePositionStrategy(this._filterMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        this._overlayService.onOpening.pipe(first$1((overlay) => overlay.id === this._componentOverlayId), takeUntil(this.destroy$)).subscribe((eventArgs) => {
            const instance = this.grid.excelStyleFilteringComponent ?
                this.grid.excelStyleFilteringComponent :
                eventArgs.componentRef.instance;
            if (instance) {
                this.lastActiveNode = this.grid.navigation.activeNode;
                instance.initialize(this.column, this._overlayService, eventArgs.id);
            }
        });
        this._overlayService.onClosed.pipe(first$1((overlay) => overlay.id === this._componentOverlayId), takeUntil(this.destroy$)).subscribe((eventArgs) => {
            const instance = this.grid.excelStyleFilteringComponent ?
                this.grid.excelStyleFilteringComponent :
                eventArgs.componentRef.instance;
            if (instance) {
                instance.column = null;
            }
            this._componentOverlayId = null;
            this.grid.navigation.activeNode = this.lastActiveNode;
            this.grid.theadRow.nativeElement.focus();
        });
    }
    hideExcelFiltering() {
        if (this._componentOverlayId) {
            this._overlayService.hide(this._componentOverlayId);
        }
    }
    /**
     * Subscribe to grid's events.
     */
    subscribeToEvents() {
        if (!this.areEventsSubscribed) {
            this.areEventsSubscribed = true;
            this.grid.onColumnResized.pipe(takeUntil(this.destroy$)).subscribe((eventArgs) => {
                this.updateFilteringCell(eventArgs.column);
            });
            this.grid.parentVirtDir.onChunkLoad.pipe(takeUntil(this.destroy$)).subscribe((eventArgs) => {
                if (eventArgs.startIndex !== this.columnStartIndex) {
                    this.columnStartIndex = eventArgs.startIndex;
                    this.grid.filterCellList.forEach((filterCell) => {
                        filterCell.updateFilterCellArea();
                    });
                }
            });
            this.grid.onColumnMovingEnd.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.grid.filterCellList.forEach((filterCell) => {
                    filterCell.updateFilterCellArea();
                });
            });
        }
    }
    /**
     * Close filtering row if a column is hidden.
     */
    hideFilteringRowOnColumnVisibilityChange(col) {
        const filteringRow = this.grid.filteringRow;
        if (filteringRow && filteringRow.column && filteringRow.column === col) {
            filteringRow.close();
        }
    }
    /**
     * Internal method to create expressionsTree and filter grid used in both filter modes.
     */
    filterInternal(field, expressions = null) {
        this.isFiltering = true;
        let expressionsTree;
        if (expressions instanceof FilteringExpressionsTree) {
            expressionsTree = expressions;
        }
        else {
            expressionsTree = this.createSimpleFilteringTree(field, expressions);
        }
        if (expressionsTree.filteringOperands.length === 0) {
            this.clearFilter(field);
        }
        else {
            this.filter(field, null, expressionsTree);
        }
        this.isFiltering = false;
    }
    /**
     * Execute filtering on the grid.
     */
    filter(field, value, conditionOrExpressionTree, ignoreCase) {
        const grid = this.grid;
        const col = grid.getColumnByName(field);
        const filteringIgnoreCase = ignoreCase || (col ? col.filteringIgnoreCase : false);
        const filteringTree = grid.filteringExpressionsTree;
        const columnFilteringExpressionsTree = grid.filteringExpressionsTree.find(field);
        conditionOrExpressionTree = conditionOrExpressionTree !== null && conditionOrExpressionTree !== void 0 ? conditionOrExpressionTree : columnFilteringExpressionsTree;
        const fieldFilterIndex = filteringTree.findIndex(field);
        if (fieldFilterIndex > -1) {
            filteringTree.filteringOperands.splice(fieldFilterIndex, 1);
        }
        const newFilteringTree = this.prepare_filtering_expression(filteringTree, field, value, conditionOrExpressionTree, filteringIgnoreCase, fieldFilterIndex, true);
        const eventArgs = { owner: grid, filteringExpressions: newFilteringTree.find(field), cancel: false };
        this.grid.filtering.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        if (conditionOrExpressionTree) {
            this.filter_internal(field, value, conditionOrExpressionTree, filteringIgnoreCase);
        }
        else {
            const expressionsTreeForColumn = this.grid.filteringExpressionsTree.find(field);
            if (!expressionsTreeForColumn) {
                throw new Error('Invalid condition or Expression Tree!');
            }
            else if (expressionsTreeForColumn instanceof FilteringExpressionsTree) {
                this.filter_internal(field, value, expressionsTreeForColumn, filteringIgnoreCase);
            }
            else {
                const expressionForColumn = expressionsTreeForColumn;
                this.filter_internal(field, value, expressionForColumn.condition, filteringIgnoreCase);
            }
        }
        const doneEventArgs = this.grid.filteringExpressionsTree.find(field);
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.grid.onFilteringDone.emit(doneEventArgs));
    }
    filter_global(term, condition, ignoreCase) {
        if (!condition) {
            return;
        }
        const grid = this.grid;
        const filteringTree = grid.filteringExpressionsTree;
        grid.endEdit(false);
        if (grid.paging) {
            grid.page = 0;
        }
        filteringTree.filteringOperands = [];
        for (const column of grid.columns) {
            this.prepare_filtering_expression(filteringTree, column.field, term, condition, ignoreCase || column.filteringIgnoreCase);
        }
        grid.filteringExpressionsTree = filteringTree;
    }
    /**
     * Clears the filter of a given column if name is provided. Otherwise clears the filters of all columns.
     */
    clearFilter(field) {
        if (field) {
            const column = this.grid.getColumnByName(field);
            if (!column) {
                return;
            }
        }
        const onFilteringEventArgs = {
            owner: this.grid,
            filteringExpressions: null,
            cancel: false
        };
        this.grid.filtering.emit(onFilteringEventArgs);
        if (onFilteringEventArgs.cancel) {
            return;
        }
        this.isFiltering = true;
        this.clear_filter(field);
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.grid.onFilteringDone.emit(null));
        if (field) {
            const expressions = this.getExpressions(field);
            expressions.length = 0;
        }
        else {
            this.grid.columns.forEach(c => {
                const expressions = this.getExpressions(c.field);
                expressions.length = 0;
            });
        }
        this.isFiltering = false;
    }
    clear_filter(fieldName) {
        const grid = this.grid;
        grid.endEdit(false);
        const filteringState = grid.filteringExpressionsTree;
        const index = filteringState.findIndex(fieldName);
        if (index > -1) {
            filteringState.filteringOperands.splice(index, 1);
        }
        else if (!fieldName) {
            filteringState.filteringOperands = [];
        }
        grid.filteringExpressionsTree = filteringState;
    }
    /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     */
    filterGlobal(value, condition, ignoreCase) {
        if (!condition) {
            return;
        }
        const grid = this.grid;
        const filteringTree = grid.filteringExpressionsTree;
        const newFilteringTree = new FilteringExpressionsTree(filteringTree.operator, filteringTree.fieldName);
        for (const column of grid.columns) {
            this.prepare_filtering_expression(newFilteringTree, column.field, value, condition, ignoreCase || column.filteringIgnoreCase);
        }
        const eventArgs = { owner: grid, filteringExpressions: newFilteringTree, cancel: false };
        grid.filtering.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        grid.endEdit(false);
        if (grid.paging) {
            grid.page = 0;
        }
        grid.filteringExpressionsTree = newFilteringTree;
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.grid.onFilteringDone.emit(this.grid.filteringExpressionsTree));
    }
    /**
     * Register filtering SVG icons in the icon service.
     */
    registerSVGIcons() {
        const editorIcons = editor;
        editorIcons.forEach(icon => this.iconService.addSvgIconFromText(icon.name, icon.value, 'imx-icons'));
        this.iconService.addSvgIconFromText(pinLeft.name, pinLeft.value, 'imx-icons');
        this.iconService.addSvgIconFromText(unpinLeft.name, unpinLeft.value, 'imx-icons');
    }
    /**
     * Returns the ExpressionUI array for a given column.
     */
    getExpressions(columnId) {
        if (!this.columnToExpressionsMap.has(columnId)) {
            const column = this.grid.columns.find((col) => col.field === columnId);
            const expressionUIs = new Array();
            if (column) {
                this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, expressionUIs);
                this.columnToExpressionsMap.set(columnId, expressionUIs);
            }
            return expressionUIs;
        }
        return this.columnToExpressionsMap.get(columnId);
    }
    /**
     * Recreates all ExpressionUIs for all columns. Executed after filtering to refresh the cache.
     */
    refreshExpressions() {
        if (!this.isFiltering) {
            this.columnsWithComplexFilter.clear();
            this.columnToExpressionsMap.forEach((value, key) => {
                const column = this.grid.columns.find((col) => col.field === key);
                if (column) {
                    value.length = 0;
                    this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, value);
                    const isComplex = this.isFilteringTreeComplex(column.filteringExpressionsTree);
                    if (isComplex) {
                        this.columnsWithComplexFilter.add(key);
                    }
                    this.updateFilteringCell(column);
                }
                else {
                    this.columnToExpressionsMap.delete(key);
                }
            });
        }
    }
    /**
     * Remove an ExpressionUI for a given column.
     */
    removeExpression(columnId, indexToRemove) {
        const expressionsList = this.getExpressions(columnId);
        if (indexToRemove === 0 && expressionsList.length > 1) {
            expressionsList[1].beforeOperator = null;
        }
        else if (indexToRemove === expressionsList.length - 1) {
            expressionsList[indexToRemove - 1].afterOperator = null;
        }
        else {
            expressionsList[indexToRemove - 1].afterOperator = expressionsList[indexToRemove + 1].beforeOperator;
            expressionsList[0].beforeOperator = null;
            expressionsList[expressionsList.length - 1].afterOperator = null;
        }
        expressionsList.splice(indexToRemove, 1);
    }
    /**
     * Generate filtering tree for a given column from existing ExpressionUIs.
     */
    createSimpleFilteringTree(columnId, expressionUIList = null) {
        const expressionsList = expressionUIList ? expressionUIList : this.getExpressions(columnId);
        const expressionsTree = new FilteringExpressionsTree(FilteringLogic.Or, columnId);
        let currAndBranch;
        for (const currExpressionUI of expressionsList) {
            if (!currExpressionUI.expression.condition.isUnary && currExpressionUI.expression.searchVal === null) {
                if (currExpressionUI.afterOperator === FilteringLogic.And && !currAndBranch) {
                    currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);
                    expressionsTree.filteringOperands.push(currAndBranch);
                }
                continue;
            }
            if ((currExpressionUI.beforeOperator === undefined || currExpressionUI.beforeOperator === null ||
                currExpressionUI.beforeOperator === FilteringLogic.Or) &&
                currExpressionUI.afterOperator === FilteringLogic.And) {
                currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);
                expressionsTree.filteringOperands.push(currAndBranch);
                currAndBranch.filteringOperands.push(currExpressionUI.expression);
            }
            else if (currExpressionUI.beforeOperator === FilteringLogic.And) {
                currAndBranch.filteringOperands.push(currExpressionUI.expression);
            }
            else {
                expressionsTree.filteringOperands.push(currExpressionUI.expression);
                currAndBranch = null;
            }
        }
        return expressionsTree;
    }
    /**
     * Returns whether a complex filter is applied to a given column.
     */
    isFilterComplex(columnId) {
        if (this.columnsWithComplexFilter.has(columnId)) {
            return true;
        }
        const column = this.grid.columns.find((col) => col.field === columnId);
        const isComplex = column && this.isFilteringTreeComplex(column.filteringExpressionsTree);
        if (isComplex) {
            this.columnsWithComplexFilter.add(columnId);
        }
        return isComplex;
    }
    /**
     * Returns the string representation of the FilteringLogic operator.
     */
    getOperatorAsString(operator) {
        if (operator === 0) {
            return this.grid.resourceStrings.igx_grid_filter_operator_and;
        }
        else {
            return this.grid.resourceStrings.igx_grid_filter_operator_or;
        }
    }
    /**
     * Generate the label of a chip from a given filtering expression.
     */
    getChipLabel(expression) {
        if (expression.condition.isUnary) {
            return this.grid.resourceStrings[`igx_grid_filter_${expression.condition.name}`] || expression.condition.name;
        }
        else if (expression.searchVal instanceof Date) {
            const column = this.grid.getColumnByName(expression.fieldName);
            const formatter = column.formatter;
            if (formatter) {
                return formatter(expression.searchVal);
            }
            const pipeArgs = column.pipeArgs;
            return this.grid.datePipe.transform(expression.searchVal, pipeArgs.format, undefined, this.grid.locale);
        }
        else {
            return expression.searchVal;
        }
    }
    /**
     * Updates the content of a filterCell.
     */
    updateFilteringCell(column) {
        const filterCell = column.filterCell;
        if (filterCell) {
            filterCell.updateFilterCellArea();
        }
    }
    get filteredData() {
        return this.grid.filteredData;
    }
    generateExpressionsList(expressions, operator, expressionsUIs) {
        this.generateExpressionsListRecursive(expressions, operator, expressionsUIs);
        // The beforeOperator of the first expression and the afterOperator of the last expression should be null
        if (expressionsUIs.length) {
            expressionsUIs[expressionsUIs.length - 1].afterOperator = null;
        }
    }
    isFilteringExpressionsTreeEmpty(expressionTree) {
        if (FilteringExpressionsTree.empty(expressionTree)) {
            return true;
        }
        for (const expr of expressionTree.filteringOperands) {
            if ((expr instanceof FilteringExpressionsTree)) {
                const exprTree = expr;
                if (exprTree.filteringOperands && exprTree.filteringOperands.length) {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        return true;
    }
    filter_internal(fieldName, term, conditionOrExpressionsTree, ignoreCase) {
        const grid = this.grid;
        const filteringTree = grid.filteringExpressionsTree;
        this.grid.endEdit(false);
        if (grid.paging) {
            grid.page = 0;
        }
        const fieldFilterIndex = filteringTree.findIndex(fieldName);
        if (fieldFilterIndex > -1) {
            filteringTree.filteringOperands.splice(fieldFilterIndex, 1);
        }
        this.prepare_filtering_expression(filteringTree, fieldName, term, conditionOrExpressionsTree, ignoreCase, fieldFilterIndex);
        grid.filteringExpressionsTree = filteringTree;
    }
    /** Modifies the filteringState object to contain the newly added fitering conditions/expressions.
     * If createNewTree is true, filteringState will not be modified (because it directly affects the grid.filteringExpressionsTree),
     * but a new object is created and returned.
     */
    prepare_filtering_expression(filteringState, fieldName, searchVal, conditionOrExpressionsTree, ignoreCase, insertAtIndex = -1, createNewTree = false) {
        const oldExpressionsTreeIndex = filteringState.findIndex(fieldName);
        const expressionsTree = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
            conditionOrExpressionsTree : null;
        const condition = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
            null : conditionOrExpressionsTree;
        const newExpression = { fieldName, searchVal, condition, ignoreCase };
        const newExpressionsTree = createNewTree ?
            new FilteringExpressionsTree(filteringState.operator, filteringState.fieldName) : filteringState;
        if (oldExpressionsTreeIndex === -1) {
            // no expressions tree found for this field
            if (expressionsTree) {
                if (insertAtIndex > -1) {
                    newExpressionsTree.filteringOperands.splice(insertAtIndex, 0, expressionsTree);
                }
                else {
                    newExpressionsTree.filteringOperands.push(expressionsTree);
                }
            }
            else if (condition) {
                // create expressions tree for this field and add the new expression to it
                const newExprTree = new FilteringExpressionsTree(filteringState.operator, fieldName);
                newExprTree.filteringOperands.push(newExpression);
                newExpressionsTree.filteringOperands.push(newExprTree);
            }
        }
        return newExpressionsTree;
    }
    isFilteringTreeComplex(expressions) {
        if (!expressions) {
            return false;
        }
        if (expressions instanceof FilteringExpressionsTree) {
            const expressionsTree = expressions;
            if (expressionsTree.operator === FilteringLogic.Or) {
                const andOperatorsCount = this.getChildAndOperatorsCount(expressionsTree);
                // having more that 'And' and operator in the sub-tree means that the filter could not be represented without parentheses.
                return andOperatorsCount > 1;
            }
            let isComplex = false;
            for (const operand of expressionsTree.filteringOperands) {
                isComplex = isComplex || this.isFilteringTreeComplex(operand);
            }
            return isComplex;
        }
        return false;
    }
    getChildAndOperatorsCount(expressions) {
        let count = 0;
        let operand;
        for (let i = 0; i < expressions.filteringOperands.length; i++) {
            operand = expressions[i];
            if (operand instanceof FilteringExpressionsTree) {
                if (operand.operator === FilteringLogic.And) {
                    count++;
                }
                count = count + this.getChildAndOperatorsCount(operand);
            }
        }
        return count;
    }
    generateExpressionsListRecursive(expressions, operator, expressionsUIs) {
        if (!expressions) {
            return;
        }
        if (expressions instanceof FilteringExpressionsTree) {
            const expressionsTree = expressions;
            for (const operand of expressionsTree.filteringOperands) {
                this.generateExpressionsListRecursive(operand, expressionsTree.operator, expressionsUIs);
            }
            if (expressionsUIs.length) {
                expressionsUIs[expressionsUIs.length - 1].afterOperator = operator;
            }
        }
        else {
            const exprUI = new ExpressionUI();
            exprUI.expression = expressions;
            exprUI.afterOperator = operator;
            const prevExprUI = expressionsUIs[expressionsUIs.length - 1];
            if (prevExprUI) {
                exprUI.beforeOperator = prevExprUI.afterOperator;
            }
            expressionsUIs.push(exprUI);
        }
    }
}
IgxFilteringService.decorators = [
    { type: Injectable }
];
IgxFilteringService.ctorParameters = () => [
    { type: NgModuleRef },
    { type: IgxIconService },
    { type: IgxOverlayService }
];

class IgxSelectItemComponent extends IgxDropDownItemComponent {
    /**
     * An @Input property that gets/sets the item's text to be displayed in the select component's input when the item is selected.
     *
     * ```typescript
     *  //get
     *  let mySelectedItem = this.dropDown.selectedItem;
     *  let selectedItemText = mySelectedItem.text;
     * ```
     *
     * ```html
     * // set
     * <igx-select-item [text]="'London'"></igx-select-item>
     * ```
     */
    get text() {
        return this._text;
    }
    set text(text) {
        this._text = text;
    }
    /** @hidden @internal */
    get itemText() {
        if (this._text !== undefined) {
            return this._text;
        }
        // If text @Input is undefined, try extract a meaningful item text out of the item template
        return this.elementRef.nativeElement.textContent.trim();
    }
    /**
     * Sets/Gets if the item is the currently selected one in the select
     *
     * ```typescript
     *  let mySelectedItem = this.select.selectedItem;
     *  let isMyItemSelected = mySelectedItem.selected; // true
     * ```
     */
    get selected() {
        return !this.isHeader && !this.disabled && this.selection.is_item_selected(this.dropDown.id, this);
    }
    set selected(value) {
        if (value && !this.isHeader && !this.disabled) {
            this.dropDown.selectItem(this);
        }
    }
    ngDoCheck() {
    }
}
IgxSelectItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-select-item',
                template: '<span class="igx-drop-down__inner"><ng-content></ng-content></span>'
            },] }
];
IgxSelectItemComponent.propDecorators = {
    text: [{ type: Input }]
};

/** @hidden @internal */
class SelectPositioningStrategy extends BaseFitPositionStrategy {
    constructor(select, settings) {
        super();
        this.select = select;
        this._selectDefaultSettings = {
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Top,
            openAnimation: fadeIn,
            closeAnimation: fadeOut
        };
        // Global variables required for cases of !initialCall (page scroll/overlay repositionAll)
        this.global_yOffset = 0;
        this.global_xOffset = 0;
        this.global_styles = {};
        this.settings = Object.assign({}, this._selectDefaultSettings, settings);
    }
    /** @inheritdoc */
    position(contentElement, size, document, initialCall, target) {
        this.select.scrollContainer.scrollTop = 0;
        const targetElement = target || this.settings.target;
        const rects = super.calculateElementRectangles(contentElement, targetElement);
        // selectFit obj, to be used for both cases of initialCall and !initialCall(page scroll/overlay repositionAll)
        const selectFit = {
            verticalOffset: this.global_yOffset,
            horizontalOffset: this.global_xOffset,
            targetRect: rects.targetRect,
            contentElementRect: rects.elementRect,
            styles: this.global_styles,
            scrollContainer: this.select.scrollContainer,
            scrollContainerRect: this.select.scrollContainer.getBoundingClientRect()
        };
        if (initialCall) {
            // Fill in the required selectFit object properties.
            selectFit.viewPortRect = Util.getViewportRect(document);
            selectFit.itemElement = this.getInteractionItemElement();
            selectFit.itemRect = selectFit.itemElement.getBoundingClientRect();
            // Calculate input and selected item elements style related variables
            selectFit.styles = this.calculateStyles(selectFit, targetElement);
            selectFit.scrollAmount = this.calculateScrollAmount(selectFit);
            // Calculate how much to offset the overlay container.
            this.calculateYoffset(selectFit);
            this.calculateXoffset(selectFit);
            super.updateViewPortFit(selectFit);
            // container does not fit in viewPort and is out on Top or Bottom
            if (selectFit.fitVertical.back < 0 || selectFit.fitVertical.forward < 0) {
                this.fitInViewport(contentElement, selectFit);
            }
            this.select.scrollContainer.scrollTop = selectFit.scrollAmount;
        }
        this.setStyles(contentElement, selectFit);
    }
    /**
     * Obtain the selected item if there is such one or otherwise use the first one
     */
    getInteractionItemElement() {
        let itemElement;
        if (this.select.selectedItem) {
            itemElement = this.select.selectedItem.element.nativeElement;
            // D.P. Feb 22 2019, #3921 Force item scroll before measuring in IE11, due to base scrollToItem delay
            if (isIE()) {
                this.select.scrollContainer.scrollTop = this.select.calculateScrollPosition(this.select.selectedItem);
            }
        }
        else {
            itemElement = this.select.getFirstItemElement();
        }
        return itemElement;
    }
    /**
     * Position the items outer container so selected item text is positioned over input text and if header
     * And/OR footer - both header/footer are visible
     *
     * @param selectFit selectFit to use for computation.
     */
    fitInViewport(contentElement, selectFit) {
        const footer = selectFit.scrollContainerRect.bottom - selectFit.contentElementRect.bottom;
        const header = selectFit.scrollContainerRect.top - selectFit.contentElementRect.top;
        const lastItemFitSize = selectFit.targetRect.bottom + selectFit.styles.itemTextToInputTextDiff - footer;
        const firstItemFitSize = selectFit.targetRect.top - selectFit.styles.itemTextToInputTextDiff - header;
        // out of viewPort on Top
        if (selectFit.fitVertical.back < 0) {
            const possibleScrollAmount = selectFit.scrollContainer.scrollHeight -
                selectFit.scrollContainerRect.height - selectFit.scrollAmount;
            if (possibleScrollAmount + selectFit.fitVertical.back > 0 && firstItemFitSize > selectFit.viewPortRect.top) {
                selectFit.scrollAmount -= selectFit.fitVertical.back;
                selectFit.verticalOffset -= selectFit.fitVertical.back;
                this.global_yOffset = selectFit.verticalOffset;
            }
            else {
                selectFit.verticalOffset = 0;
                this.global_yOffset = 0;
            }
            // out of viewPort on Bottom
        }
        else if (selectFit.fitVertical.forward < 0) {
            if (selectFit.scrollAmount + selectFit.fitVertical.forward > 0 && lastItemFitSize < selectFit.viewPortRect.bottom) {
                selectFit.scrollAmount += selectFit.fitVertical.forward;
                selectFit.verticalOffset += selectFit.fitVertical.forward;
                this.global_yOffset = selectFit.verticalOffset;
            }
            else {
                selectFit.verticalOffset = -selectFit.contentElementRect.height + selectFit.targetRect.height;
                this.global_yOffset = selectFit.verticalOffset;
            }
        }
    }
    /**
     * Sets element's style which effectively positions the provided element
     *
     * @param element Element to position
     * @param selectFit selectFit to use for computation.
     * @param initialCall should be true if this is the initial call to the position method calling setStyles
     */
    setStyles(contentElement, selectFit) {
        super.setStyle(contentElement, selectFit.targetRect, selectFit.contentElementRect, selectFit);
        contentElement.style.width = `${selectFit.styles.contentElementNewWidth}px`; // manage container based on paddings?
        this.global_styles.contentElementNewWidth = selectFit.styles.contentElementNewWidth;
    }
    /**
     * Calculate selected item scroll position.
     */
    calculateScrollAmount(selectFit) {
        const itemElementRect = selectFit.itemRect;
        const scrollContainer = selectFit.scrollContainer;
        const scrollContainerRect = selectFit.scrollContainerRect;
        const scrollDelta = scrollContainerRect.top - itemElementRect.top;
        let scrollPosition = scrollContainer.scrollTop - scrollDelta;
        const dropDownHeight = scrollContainer.clientHeight;
        scrollPosition -= dropDownHeight / 2;
        scrollPosition += itemElementRect.height / 2;
        return Math.round(Math.min(Math.max(0, scrollPosition), scrollContainer.scrollHeight - scrollContainerRect.height));
    }
    /**
     * Calculate the necessary input and selected item styles to be used for positioning item text over input text.
     * Calculate & Set default items container width.
     *
     * @param selectFit selectFit to use for computation.
     */
    calculateStyles(selectFit, target) {
        const styles = {};
        const inputElementStyles = window.getComputedStyle(target);
        const itemElementStyles = window.getComputedStyle(selectFit.itemElement);
        const numericInputFontSize = parseFloat(inputElementStyles.fontSize);
        const numericItemFontSize = parseFloat(itemElementStyles.fontSize);
        const inputTextToInputTop = (selectFit.targetRect.bottom - selectFit.targetRect.top - numericInputFontSize) / 2;
        const itemTextToItemTop = (selectFit.itemRect.height - numericItemFontSize) / 2;
        // Adjust for input top padding
        const negateInputPaddings = (parseFloat(inputElementStyles.paddingTop) -
            parseFloat(inputElementStyles.paddingBottom)) / 2;
        styles.itemTextToInputTextDiff = Math.round(itemTextToItemTop - inputTextToInputTop + negateInputPaddings);
        const numericLeftPadding = parseFloat(itemElementStyles.paddingLeft);
        const numericTextIndent = parseFloat(itemElementStyles.textIndent);
        styles.itemTextPadding = numericLeftPadding;
        styles.itemTextIndent = numericTextIndent;
        // 24 is the input's toggle ddl icon width
        styles.contentElementNewWidth = selectFit.targetRect.width + 24 + numericLeftPadding * 2;
        return styles;
    }
    /**
     * Calculate how much to offset the overlay container for Y-axis.
     */
    calculateYoffset(selectFit) {
        selectFit.verticalOffset = -(selectFit.itemRect.top - selectFit.contentElementRect.top +
            selectFit.styles.itemTextToInputTextDiff - selectFit.scrollAmount);
        this.global_yOffset = selectFit.verticalOffset;
    }
    /**
     * Calculate how much to offset the overlay container for X-axis.
     */
    calculateXoffset(selectFit) {
        selectFit.horizontalOffset = selectFit.styles.itemTextIndent - selectFit.styles.itemTextPadding;
        this.global_xOffset = selectFit.horizontalOffset;
    }
}

/** @hidden @internal */
class IgxSelectToggleIconDirective {
}
IgxSelectToggleIconDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxSelectToggleIcon]'
            },] }
];
/** @hidden @internal */
class IgxSelectHeaderDirective {
}
IgxSelectHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxSelectHeader]'
            },] }
];
/** @hidden @internal */
class IgxSelectFooterDirective {
}
IgxSelectFooterDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxSelectFooter]'
            },] }
];
/**
 * **Ignite UI for Angular Select** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/select)
 *
 * The `igxSelect` provides an input with dropdown list allowing selection of a single item.
 *
 * Example:
 * ```html
 * <igx-select #select1 [placeholder]="'Pick One'">
 *   <label igxLabel>Select Label</label>
 *   <igx-select-item *ngFor="let item of items" [value]="item.field">
 *     {{ item.field }}
 *   </igx-select-item>
 * </igx-select>
 * ```
 */
class IgxSelectComponent extends IgxDropDownComponent {
    constructor(elementRef, cdr, selection, _displayDensityOptions, _inputGroupType, _injector) {
        super(elementRef, cdr, selection, _displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this._displayDensityOptions = _displayDensityOptions;
        this._inputGroupType = _inputGroupType;
        this._injector = _injector;
        /**
         * An @Input property that disables the `IgxSelectComponent`.
         * ```html
         * <igx-select [disabled]="'true'"></igx-select>
         * ```
         */
        this.disabled = false;
        /** @hidden @internal */
        this.maxHeight = '256px';
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-select onOpening='handleOpening($event)'></igx-select>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-select (onOpened)='handleOpened()'></igx-select>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-select (onClosing)='handleClosing($event)'></igx-select>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-select (onClosed)='handleClosed()'></igx-select>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * The custom template, if any, that should be used when rendering the select TOGGLE(open/close) button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.select.toggleIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-select #select>
         *      ...
         *      <ng-template igxSelectToggleIcon let-collapsed>
         *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
         *      </ng-template>
         *  </igx-select>
         * ```
         */
        this.toggleIconTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the HEADER for the select items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.select.headerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-select #select>
         *      ...
         *      <ng-template igxSelectHeader>
         *          <div class="select__header">
         *              This is a custom header
         *          </div>
         *      </ng-template>
         *  </igx-select>
         * ```
         */
        this.headerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the FOOTER for the select items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.select.footerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-select #select>
         *      ...
         *      <ng-template igxSelectFooter>
         *          <div class="select__footer">
         *              This is a custom footer
         *          </div>
         *      </ng-template>
         *  </igx-select>
         * ```
         */
        this.footerTemplate = null;
        /** @hidden @internal do not use the drop-down container class */
        this.cssClass = false;
        /** @hidden @internal */
        this.allowItemsFocus = false;
        this.destroy$ = new Subject();
        this.ngControl = null;
        this._type = null;
        this._onChangeCallback = noop;
        this._onTouchedCallback = noop;
        //#region ControlValueAccessor
        /** @hidden @internal */
        this.writeValue = (value) => {
            this.value = value;
        };
    }
    /**
     * An @Input property that gets/sets the component value.
     *
     * ```typescript
     * // get
     * let selectValue = this.select.value;
     * ```
     *
     * ```typescript
     * // set
     * this.select.value = 'London';
     * ```
     * ```html
     * <igx-select [value]="value"></igx-select>
     * ```
     */
    get value() {
        return this._value;
    }
    set value(v) {
        if (this._value === v) {
            return;
        }
        this._value = v;
        this.setSelection(this.items.find(x => x.value === this.value));
    }
    /**
     * An @Input property that sets how the select will be styled.
     * The allowed values are `line`, `box` and `border`. The input-group default is `line`.
     * ```html
     * <igx-select [type]="'box'"></igx-select>
     * ```
     */
    get type() {
        return this._type || this._inputGroupType || 'line';
    }
    set type(val) {
        this._type = val;
    }
    /** @hidden @internal */
    get selectionValue() {
        const selectedItem = this.selectedItem;
        return selectedItem ? selectedItem.itemText : '';
    }
    /** @hidden @internal */
    get selectedItem() {
        return this.selection.first_item(this.id);
    }
    /** @hidden @internal */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /** @hidden @internal */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /** @hidden @internal */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    //#endregion
    /** @hidden @internal */
    getEditElement() {
        return this.input.nativeElement;
    }
    /** @hidden @internal */
    selectItem(newSelection, event) {
        const oldSelection = this.selectedItem;
        if (event) {
            this.toggleDirective.close();
        }
        if (newSelection === null || newSelection === oldSelection || newSelection.disabled || newSelection.isHeader) {
            return;
        }
        const args = { oldSelection, newSelection, cancel: false };
        this.onSelection.emit(args);
        if (args.cancel) {
            return;
        }
        this.setSelection(newSelection);
        this._value = newSelection.value;
        this.cdr.detectChanges();
        this._onChangeCallback(this.value);
    }
    /** @hidden @internal */
    getFirstItemElement() {
        return this.children.first.element.nativeElement;
    }
    /**
     * Opens the select
     *
     * ```typescript
     * this.select.open();
     * ```
     */
    open(overlaySettings) {
        if (this.disabled || this.items.length === 0) {
            return;
        }
        if (!this.selectedItem) {
            this.navigateFirst();
        }
        super.open(Object.assign({}, this._overlayDefaults, this.overlaySettings, overlaySettings));
    }
    inputGroupClick(event, overlaySettings) {
        const targetElement = event.target;
        if (this.hintElement && targetElement.contains(this.hintElement.nativeElement)) {
            return;
        }
        this.toggle(Object.assign({}, this._overlayDefaults, this.overlaySettings, overlaySettings));
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this._overlayDefaults = {
            target: this.getEditElement(),
            modal: false,
            positionStrategy: new SelectPositioningStrategy(this),
            scrollStrategy: new AbsoluteScrollStrategy(),
            excludeFromOutsideClick: [this.inputGroup.element.nativeElement]
        };
        const changes$ = this.children.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.setSelection(this.items.find(x => x.value === this.value));
            this.cdr.detectChanges();
        });
        Promise.resolve().then(() => {
            if (!changes$.closed) {
                this.children.notifyOnChanges();
            }
        });
    }
    /**
     * Event handlers
     *
     * @hidden @internal
     */
    handleOpening(event) {
        const args = { cancel: event.cancel };
        this.onOpening.emit(args);
        event.cancel = args.cancel;
        if (args.cancel) {
            return;
        }
        this.scrollToItem(this.selectedItem);
    }
    /** @hidden @internal */
    handleOpened() {
        this.updateItemFocus();
        this.onOpened.emit();
    }
    /** @hidden @internal */
    handleClosing(event) {
        const args = { cancel: event.cancel };
        this.onClosing.emit(args);
        event.cancel = args.cancel;
    }
    /** @hidden @internal */
    handleClosed() {
        this.focusItem(false);
        this.onClosed.emit();
    }
    /** @hidden @internal */
    onBlur() {
        this._onTouchedCallback();
        if (this.ngControl && this.ngControl.invalid) {
            this.input.valid = IgxInputState.INVALID;
        }
        else {
            this.input.valid = IgxInputState.INITIAL;
        }
    }
    /** @hidden @internal */
    onFocus() {
        this._onTouchedCallback();
    }
    /**
     * @hidden @internal
     */
    ngOnInit() {
        this.ngControl = this._injector.get(NgControl, null);
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        if (this.ngControl) {
            this.ngControl.statusChanges.pipe(takeUntil(this.destroy$)).subscribe(this.onStatusChanged.bind(this));
            this.manageRequiredAsterisk();
        }
        this.cdr.detectChanges();
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
        this.selection.clear(this.id);
    }
    /**
     * @hidden @internal
     * Prevent input blur - closing the items container on Header/Footer Template click.
     */
    mousedownHandler(event) {
        event.preventDefault();
    }
    onStatusChanged() {
        if ((this.ngControl.control.touched || this.ngControl.control.dirty) &&
            (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {
            if (this.inputGroup.isFocused) {
                this.input.valid = this.ngControl.invalid ? IgxInputState.INVALID : IgxInputState.VALID;
            }
            else {
                this.input.valid = this.ngControl.invalid ? IgxInputState.INVALID : IgxInputState.INITIAL;
            }
        }
        this.manageRequiredAsterisk();
    }
    navigate(direction, currentIndex) {
        if (this.collapsed && this.selectedItem) {
            this.navigateItem(this.selectedItem.itemIndex);
        }
        super.navigate(direction, currentIndex);
    }
    manageRequiredAsterisk() {
        const hasRequiredHTMLAttribute = this.elementRef.nativeElement.hasAttribute('required');
        if (this.ngControl && this.ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            const error = this.ngControl.control.validator({});
            this.inputGroup.isRequired = error && error.required;
            this.cdr.markForCheck();
            // If validator is dynamically cleared and no required HTML attribute is set,
            // reset label's required class(asterisk) and IgxInputState #6896
        }
        else if (this.inputGroup.isRequired && this.ngControl && !this.ngControl.control.validator && !hasRequiredHTMLAttribute) {
            this.input.valid = IgxInputState.INITIAL;
            this.inputGroup.isRequired = false;
            this.cdr.markForCheck();
        }
    }
    setSelection(item) {
        if (item && item.value !== undefined && item.value !== null) {
            this.selection.set(this.id, new Set([item]));
        }
        else {
            this.selection.clear(this.id);
        }
    }
}
IgxSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-select',
                template: "<igx-input-group #inputGroup class=\"input-group\" (click)=\"inputGroupClick($event)\" [type]=\"type\" [displayDensity]=\"displayDensity\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n    </ng-container>\n    <input #input class=\"input\" type=\"text\" igxInput [igxSelectItemNavigation]=\"this\"\n        [disabled]=\"disabled\"\n        readonly=\"true\"\n        [attr.placeholder]=\"this.placeholder\"\n        [value]=\"this.selectionValue\"\n        role=\"combobox\"\n        aria-haspopup=\"listbox\"\n        [attr.aria-labelledby]=\"this.label?.id\"\n        [attr.aria-expanded]=\"!this.collapsed\"\n        [attr.aria-owns]=\"this.listId\"\n        [attr.aria-activedescendant]=\"!this.collapsed ? this.focusedItem?.id : null\"\n        (blur)=\"onBlur()\"\n        (focus)=\"onFocus()\"\n    />\n    <ng-container ngProjectAs=\"igx-suffix\">\n            <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n    </ng-container>\n    <igx-suffix>\n        <ng-container *ngIf=\"toggleIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n            </ng-container>\n        <igx-icon *ngIf=\"!toggleIconTemplate\">{{ collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}</igx-icon>\n    </igx-suffix>\n    <ng-container ngProjectAs=\"igx-hint, [igxHint]\" >\n        <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n    </ng-container>\n</igx-input-group>\n<div igxToggle class=\"igx-drop-down__list\" (mousedown)=\"mousedownHandler($event);\" (onOpening)=\"handleOpening($event)\"\n    (onOpened)=\"handleOpened()\" (onClosing)=\"handleClosing($event)\" (onClosed)=\"handleClosed()\">\n\n    <div *ngIf=\"headerTemplate\" class=\"igx-drop-down__select-header\">\n        <ng-content *ngTemplateOutlet=\"headerTemplate\"></ng-content>\n    </div>\n\n    <!-- #7436 LMB scrolling closes items container - unselectable attribute is IE specific  -->\n    <div #scrollContainer class=\"igx-drop-down__list-scroll\" unselectable=\"on\" [style.maxHeight]=\"maxHeight\"\n        [attr.id]=\"this.listId\" role=\"listbox\" [attr.aria-labelledby]=\"this.label?.id\">\n        <ng-content select=\"igx-select-item, igx-select-item-group\"></ng-content>\n    </div>\n\n    <div *ngIf=\"footerTemplate\" class=\"igx-drop-down__select-footer\">\n        <ng-container *ngTemplateOutlet=\"footerTemplate\"></ng-container>\n    </div>\n</div>\n",
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: IgxSelectComponent, multi: true },
                    { provide: IGX_DROPDOWN_BASE, useExisting: IgxSelectComponent }
                ],
                styles: [`
        :host {
            display: block;
        }
    `]
            },] }
];
IgxSelectComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxSelectionAPIService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [IGX_INPUT_GROUP_TYPE,] }] },
    { type: Injector }
];
IgxSelectComponent.propDecorators = {
    inputGroup: [{ type: ViewChild, args: ['inputGroup', { read: IgxInputGroupComponent, static: true },] }],
    input: [{ type: ViewChild, args: ['input', { read: IgxInputDirective, static: true },] }],
    children: [{ type: ContentChildren, args: [forwardRef(() => IgxSelectItemComponent), { descendants: true },] }],
    label: [{ type: ContentChild, args: [forwardRef(() => IgxLabelDirective), { static: true },] }],
    placeholder: [{ type: Input }],
    disabled: [{ type: Input }],
    overlaySettings: [{ type: Input }],
    maxHeight: [{ type: HostBinding, args: ['style.maxHeight',] }],
    onOpening: [{ type: Output }],
    onOpened: [{ type: Output }],
    onClosing: [{ type: Output }],
    onClosed: [{ type: Output }],
    toggleIconTemplate: [{ type: ContentChild, args: [IgxSelectToggleIconDirective, { read: TemplateRef },] }],
    headerTemplate: [{ type: ContentChild, args: [IgxSelectHeaderDirective, { read: TemplateRef, static: false },] }],
    footerTemplate: [{ type: ContentChild, args: [IgxSelectFooterDirective, { read: TemplateRef, static: false },] }],
    hintElement: [{ type: ContentChild, args: [IgxHintDirective, { read: ElementRef },] }],
    value: [{ type: Input }],
    type: [{ type: Input }]
};

/**
 * @hidden
 */
class IgxExcelStyleDefaultExpressionComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.expressionRemoved = new EventEmitter();
        this.logicOperatorChanged = new EventEmitter();
        this.dropDownOverlaySettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: true
        };
    }
    get isLast() {
        return this.expressionsList[this.expressionsList.length - 1] === this.expressionUI;
    }
    get isSingle() {
        return this.expressionsList.length === 1;
    }
    get conditionsPlaceholder() {
        return this.grid.resourceStrings['igx_grid_filter_condition_placeholder'];
    }
    get inputValuePlaceholder() {
        return this.grid.resourceStrings['igx_grid_filter_row_placeholder'];
    }
    get type() {
        switch (this.column.dataType) {
            case DataType.Number:
            case DataType.Currency:
            case DataType.Percent:
                return 'number';
            default:
                return 'text';
        }
    }
    get conditions() {
        return this.column.filters.conditionList();
    }
    get inputValuesElement() {
        return this.inputValuesDirective;
    }
    ngAfterViewInit() {
        this.dropDownOverlaySettings.outlet = this.overlayOutlet;
        this.dropDownOverlaySettings.target = this.dropdownConditions.inputGroup.element.nativeElement;
        this.dropDownOverlaySettings.excludeFromOutsideClick = [this.dropdownConditions.inputGroup.element.nativeElement];
        this.dropDownOverlaySettings.positionStrategy = new ConnectedPositioningStrategy();
    }
    focus() {
        // use requestAnimationFrame to focus the values input because when initializing the component
        // datepicker's input group is not yet fully initialized
        requestAnimationFrame(() => this.inputValuesElement.focus());
    }
    translateCondition(value) {
        return this.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;
    }
    getIconName() {
        if (this.column.dataType === DataType.Boolean && this.expressionUI.expression.condition === null) {
            return this.getCondition(this.conditions[0]).iconName;
        }
        else if (!this.expressionUI.expression.condition) {
            return 'filter_list';
        }
        else {
            return this.expressionUI.expression.condition.iconName;
        }
    }
    isConditionSelected(conditionName) {
        return this.expressionUI.expression.condition && this.expressionUI.expression.condition.name === conditionName;
    }
    onConditionsChanged(eventArgs) {
        const value = eventArgs.newSelection.value;
        this.expressionUI.expression.condition = this.getCondition(value);
        this.focus();
    }
    getCondition(value) {
        return this.column.filters.condition(value);
    }
    onValuesInput(eventArgs) {
        this.expressionUI.expression.searchVal = DataUtil.parseValue(this.column.dataType, eventArgs.target.value);
    }
    onLogicOperatorButtonClicked(eventArgs, buttonIndex) {
        if (this.logicOperatorButtonGroup.selectedButtons.length === 0) {
            eventArgs.stopPropagation();
            this.logicOperatorButtonGroup.selectButton(buttonIndex);
        }
        else {
            this.logicOperatorChanged.emit({
                target: this.expressionUI,
                newValue: buttonIndex
            });
        }
    }
    onLogicOperatorKeyDown(eventArgs, buttonIndex) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.logicOperatorButtonGroup.selectButton(buttonIndex);
            this.logicOperatorChanged.emit({
                target: this.expressionUI,
                newValue: buttonIndex
            });
        }
    }
    onRemoveButtonClick() {
        this.expressionRemoved.emit(this.expressionUI);
    }
    onOutletPointerDown(event) {
        event.preventDefault();
    }
}
IgxExcelStyleDefaultExpressionComponent.decorators = [
    { type: Component, args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-default-expression',
                template: "<igx-select #dropdownConditions\n        type=\"box\"\n        [displayDensity]=\"displayDensity\"\n        [placeholder]=\"conditionsPlaceholder\"\n        (onSelection)=\"onConditionsChanged($event)\"\n        [overlaySettings]=\"dropDownOverlaySettings\">\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" family=\"imx-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n    <igx-select-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <div class=\"igx-grid__filtering-dropdown-items\">\n            <igx-icon family=\"imx-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n            <span class=\"igx-grid__filtering-dropdown-text\">{{translateCondition(condition)}}</span>\n        </div>\n    </igx-select-item>\n</igx-select>\n\n<igx-input-group #inputGroupValues type=\"box\" [displayDensity]=\"displayDensity\">\n    <input\n        #inputValues\n        igxInput\n        [type]=\"type\"\n        tabindex=\"0\"\n        [placeholder]=\"inputValuePlaceholder\"\n        [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"\n        autocomplete=\"off\"\n        [value]=\"expressionUI.expression.searchVal\"\n        (input)=\"onValuesInput($event)\"\n    />\n</igx-input-group>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\">\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #orButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n\n<div #overlayOutlet\n     igxOverlayOutlet\n     (pointerdown)=\"onOutletPointerDown($event)\">\n</div>\n"
            },] }
];
IgxExcelStyleDefaultExpressionComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
IgxExcelStyleDefaultExpressionComponent.propDecorators = {
    column: [{ type: Input }],
    expressionUI: [{ type: Input }],
    expressionsList: [{ type: Input }],
    grid: [{ type: Input }],
    displayDensity: [{ type: Input }],
    expressionRemoved: [{ type: Output }],
    logicOperatorChanged: [{ type: Output }],
    overlayOutlet: [{ type: ViewChild, args: ['overlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    dropdownConditions: [{ type: ViewChild, args: ['dropdownConditions', { read: IgxSelectComponent, static: true },] }],
    logicOperatorButtonGroup: [{ type: ViewChild, args: ['logicOperatorButtonGroup', { read: IgxButtonGroupComponent },] }],
    inputValuesDirective: [{ type: ViewChild, args: ['inputValues', { read: IgxInputDirective, static: true },] }]
};

/**
 * @hidden
 */
class IgxExcelStyleDateExpressionComponent extends IgxExcelStyleDefaultExpressionComponent {
    get inputValuesElement() {
        return this.datePicker.getEditElement();
    }
    get inputDatePlaceholder() {
        return this.grid.resourceStrings['igx_grid_filter_row_date_placeholder'];
    }
}
IgxExcelStyleDateExpressionComponent.decorators = [
    { type: Component, args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-date-expression',
                template: "<igx-select #dropdownConditions\n        type=\"box\"\n        [displayDensity]=\"displayDensity\"\n        [placeholder]=\"conditionsPlaceholder\"\n        (onSelection)=\"onConditionsChanged($event)\"\n        [overlaySettings]=\"dropDownOverlaySettings\">\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" family=\"imx-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n    <igx-select-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <igx-icon family=\"imx-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span>{{translateCondition(condition)}}</span>\n    </igx-select-item>\n</igx-select>\n\n<igx-date-picker #datePicker mode=\"dropdown\" [(ngModel)]=\"expressionUI.expression.searchVal\" [locale]=\"grid.locale\" [outlet]=\"grid.outlet\">\n    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"displayDensity\">\n            <input #input\n                    igxInput\n                    tabindex=\"0\"\n                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                    [placeholder]=\"inputDatePlaceholder\"\n                    autocomplete=\"off\"\n                    [value]=\"\n                        column.formatter\n                        ? (value | columnFormatter:column.formatter)\n                        : (value | date:column.pipeArgs.format:undefined:grid.locale)\n                    \"\n                    [readonly]=\"true\"\n                    [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"/>\n        </igx-input-group>\n    </ng-template>\n</igx-date-picker>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\" >\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        tabindex=\"0\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #orButton\n        tabindex=\"0\"\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n\n<div #overlayOutlet\n     igxOverlayOutlet\n     (pointerdown)=\"onOutletPointerDown($event)\">\n</div>\n"
            },] }
];
IgxExcelStyleDateExpressionComponent.propDecorators = {
    displayDensity: [{ type: Input }],
    datePicker: [{ type: ViewChild, args: ['datePicker', { read: IgxDatePickerComponent, static: true },] }]
};

/**
 * @hidden
 */
class IgxExcelStyleCustomDialogComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.expressionsList = new Array();
        this._customDialogPositionSettings = {
            verticalDirection: VerticalAlignment.Middle,
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle
        };
        this._customDialogOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._customDialogPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
    }
    ngAfterViewInit() {
        this._customDialogOverlaySettings.outlet = this.grid.outlet;
    }
    get template() {
        if (this.column.dataType === DataType.Date) {
            return this.dateExpressionTemplate;
        }
        return this.defaultExpressionTemplate;
    }
    get grid() {
        return this.filteringService.grid;
    }
    onCustomDialogOpening() {
        if (this.selectedOperator) {
            this.createInitialExpressionUIElement();
        }
    }
    onCustomDialogOpened() {
        if (this.expressionComponents.first) {
            this.expressionComponents.first.focus();
        }
    }
    open(esf) {
        this._customDialogOverlaySettings.target =
            this.overlayComponentId ?
                this.grid.rootGrid ? this.grid.rootGrid.nativeElement : this.grid.nativeElement :
                esf;
        this.toggle.open(this._customDialogOverlaySettings);
    }
    onClearButtonClick() {
        this.filteringService.clearFilter(this.column.field);
        this.createInitialExpressionUIElement();
        this.cdr.detectChanges();
    }
    closeDialog() {
        if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
        }
        else {
            this.toggle.close();
        }
    }
    onApplyButtonClick() {
        this.expressionsList = this.expressionsList.filter(element => element.expression.condition &&
            (element.expression.searchVal || element.expression.searchVal === 0 || element.expression.condition.isUnary));
        if (this.expressionsList.length > 0) {
            this.expressionsList[0].beforeOperator = null;
            this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
        }
        this.filteringService.filterInternal(this.column.field, this.expressionsList);
        this.closeDialog();
    }
    onAddButtonClick() {
        const exprUI = new ExpressionUI();
        exprUI.expression = {
            condition: null,
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        this.expressionsList[this.expressionsList.length - 1].afterOperator = FilteringLogic.And;
        exprUI.beforeOperator = this.expressionsList[this.expressionsList.length - 1].afterOperator;
        this.expressionsList.push(exprUI);
        this.markChildrenForCheck();
        this.scrollToBottom();
    }
    onExpressionRemoved(event) {
        const indexToRemove = this.expressionsList.indexOf(event);
        if (indexToRemove === 0 && this.expressionsList.length > 1) {
            this.expressionsList[1].beforeOperator = null;
        }
        else if (indexToRemove === this.expressionsList.length - 1) {
            this.expressionsList[indexToRemove - 1].afterOperator = null;
        }
        else {
            this.expressionsList[indexToRemove - 1].afterOperator = this.expressionsList[indexToRemove + 1].beforeOperator;
            this.expressionsList[0].beforeOperator = null;
            this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
        }
        this.expressionsList.splice(indexToRemove, 1);
        this.cdr.detectChanges();
        this.markChildrenForCheck();
    }
    onLogicOperatorChanged(event) {
        const index = this.expressionsList.indexOf(event.target);
        event.target.afterOperator = event.newValue;
        if (index + 1 < this.expressionsList.length) {
            this.expressionsList[index + 1].beforeOperator = event.newValue;
        }
    }
    onKeyDown(eventArgs) {
        eventArgs.stopPropagation();
    }
    onApplyButtonKeyDown(eventArgs) {
        if (eventArgs.key === "Tab" /* TAB */ && !eventArgs.shiftKey) {
            eventArgs.stopPropagation();
            eventArgs.preventDefault();
        }
    }
    createCondition(conditionName) {
        switch (this.column.dataType) {
            case DataType.Boolean:
                return IgxBooleanFilteringOperand.instance().condition(conditionName);
            case DataType.Number:
            case DataType.Currency:
            case DataType.Percent:
                return IgxNumberFilteringOperand.instance().condition(conditionName);
            case DataType.Date:
                return IgxDateFilteringOperand.instance().condition(conditionName);
            default:
                return IgxStringFilteringOperand.instance().condition(conditionName);
        }
    }
    markChildrenForCheck() {
        this.expressionComponents.forEach(x => x.cdr.markForCheck());
        this.expressionDateComponents.forEach(x => x.cdr.markForCheck());
    }
    createInitialExpressionUIElement() {
        this.expressionsList = [];
        const firstExprUI = new ExpressionUI();
        firstExprUI.expression = {
            condition: this.createCondition(this.selectedOperator),
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        firstExprUI.afterOperator = FilteringLogic.And;
        this.expressionsList.push(firstExprUI);
        const secondExprUI = new ExpressionUI();
        secondExprUI.expression = {
            condition: null,
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        secondExprUI.beforeOperator = FilteringLogic.And;
        this.expressionsList.push(secondExprUI);
    }
    scrollToBottom() {
        requestAnimationFrame(() => {
            this.expressionsContainer.nativeElement.scrollTop = this.expressionsContainer.nativeElement.scrollHeight;
        });
    }
}
IgxExcelStyleCustomDialogComponent.decorators = [
    { type: Component, args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-custom-dialog',
                template: "<article #toggle igxToggle\n    class=\"igx-excel-filter__secondary\"\n    [ngClass]=\"{\n        'igx-excel-filter__secondary--cosy': grid.displayDensity === 'cosy',\n        'igx-excel-filter__secondary--compact': grid.displayDensity === 'compact'\n    }\"\n    (keydown)=\"onKeyDown($event)\"\n    (onOpening)=\"onCustomDialogOpening()\"\n    (onOpened)=\"onCustomDialogOpened()\">\n    <header class=\"igx-excel-filter__secondary-header\">\n        <h4 class=\"igx-typography__h6\">\n            {{ grid.resourceStrings.igx_grid_excel_custom_dialog_header }}{{ column.header || column.field }}\n        </h4>\n    </header>\n\n    <article #expressionsContainer class=\"igx-excel-filter__secondary-main\">\n        <ng-container *ngIf=\"column.dataType === 'date'\">\n            <igx-excel-style-date-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (expressionRemoved)=\"onExpressionRemoved($event)\"\n                (logicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-date-expression>\n        </ng-container>\n\n        <ng-container *ngIf=\"column.dataType !== 'date'\">\n            <igx-excel-style-default-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (expressionRemoved)=\"onExpressionRemoved($event)\"\n                (logicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-default-expression>\n        </ng-container>\n\n        <button igxButton [displayDensity]=\"displayDensity\"\n            class=\"igx-excel-filter__add-filter\"\n            (click)=\"onAddButtonClick()\">\n            <igx-icon>add</igx-icon>\n            <span>{{ grid.resourceStrings.igx_grid_excel_custom_dialog_add }}</span>\n        </button>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick()\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"closeDialog()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick()\" (keydown)=\"onApplyButtonKeyDown($event)\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n"
            },] }
];
IgxExcelStyleCustomDialogComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
IgxExcelStyleCustomDialogComponent.propDecorators = {
    expressionsList: [{ type: Input }],
    column: [{ type: Input }],
    selectedOperator: [{ type: Input }],
    filteringService: [{ type: Input }],
    overlayComponentId: [{ type: Input }],
    overlayService: [{ type: Input }],
    displayDensity: [{ type: Input }],
    toggle: [{ type: ViewChild, args: ['toggle', { read: IgxToggleDirective, static: true },] }],
    defaultExpressionTemplate: [{ type: ViewChild, args: ['defaultExpressionTemplate', { read: TemplateRef },] }],
    dateExpressionTemplate: [{ type: ViewChild, args: ['dateExpressionTemplate', { read: TemplateRef },] }],
    expressionsContainer: [{ type: ViewChild, args: ['expressionsContainer', { static: true },] }],
    expressionComponents: [{ type: ViewChildren, args: [IgxExcelStyleDefaultExpressionComponent,] }],
    expressionDateComponents: [{ type: ViewChildren, args: [IgxExcelStyleDateExpressionComponent,] }]
};

/**
 * A component used for presenting Excel style conditional filter UI.
 */
class IgxExcelStyleConditionalFilterComponent {
    constructor(esf) {
        this.esf = esf;
        this.shouldOpenSubMenu = true;
        this.destroy$ = new Subject();
        this._subMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Top
        };
        this._subMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        this.esf.columnChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (this.esf.grid) {
                this.shouldOpenSubMenu = true;
                this._subMenuOverlaySettings.outlet = this.esf.grid.outlet;
            }
        });
        if (this.esf.grid) {
            this._subMenuOverlaySettings.outlet = this.esf.grid.outlet;
        }
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden @internal
     */
    onTextFilterKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.onTextFilterClick(eventArgs);
        }
    }
    /**
     * @hidden @internal
     */
    onTextFilterClick(eventArgs) {
        if (this.shouldOpenSubMenu) {
            this._subMenuOverlaySettings.target = eventArgs.currentTarget;
            const gridRect = this.esf.grid.nativeElement.getBoundingClientRect();
            const dropdownRect = this.esf.mainDropdown.nativeElement.getBoundingClientRect();
            let x = dropdownRect.left + dropdownRect.width;
            let x1 = gridRect.left + gridRect.width;
            x += window.pageXOffset;
            x1 += window.pageXOffset;
            if (Math.abs(x - x1) < 200) {
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Left;
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Left;
            }
            else {
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Right;
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Right;
            }
            this.subMenu.open(this._subMenuOverlaySettings);
            this.shouldOpenSubMenu = false;
        }
    }
    /**
     * @hidden @internal
     */
    getCondition(value) {
        return this.esf.column.filters.condition(value);
    }
    /**
     * @hidden @internal
     */
    translateCondition(value) {
        return this.esf.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;
    }
    /**
     * @hidden @internal
     */
    onSubMenuSelection(eventArgs) {
        if (this.esf.expressionsList && this.esf.expressionsList.length &&
            this.esf.expressionsList[0].expression.condition.name !== 'in') {
            this.customDialog.expressionsList = this.esf.expressionsList;
        }
        this.customDialog.selectedOperator = eventArgs.newSelection.value;
        eventArgs.cancel = true;
        if (this.esf.overlayComponentId) {
            this.esf.hide();
        }
        this.subMenu.close();
        this.customDialog.open(this.esf.mainDropdown.nativeElement);
    }
    /**
     * @hidden @internal
     */
    onSubMenuClosed() {
        requestAnimationFrame(() => {
            this.shouldOpenSubMenu = true;
        });
    }
    /**
     * @hidden @internal
     */
    showCustomFilterItem() {
        const exprTree = this.esf.column.filteringExpressionsTree;
        return exprTree && exprTree.filteringOperands && exprTree.filteringOperands.length &&
            !(exprTree.filteringOperands[0].condition &&
                exprTree.filteringOperands[0].condition.name === 'in');
    }
    /**
     * @hidden @internal
     */
    get subMenuText() {
        switch (this.esf.column.dataType) {
            case DataType.Boolean:
                return this.esf.grid.resourceStrings.igx_grid_excel_boolean_filter;
            case DataType.Number:
            case DataType.Percent:
                return this.esf.grid.resourceStrings.igx_grid_excel_number_filter;
            case DataType.Date:
                return this.esf.grid.resourceStrings.igx_grid_excel_date_filter;
            case DataType.Currency:
                return this.esf.grid.resourceStrings.igx_grid_excel_currency_filter;
            default:
                return this.esf.grid.resourceStrings.igx_grid_excel_text_filter;
        }
    }
    /**
     * @hidden @internal
     */
    get conditions() {
        return this.esf.column.filters.conditionList();
    }
}
IgxExcelStyleConditionalFilterComponent.decorators = [
    { type: Component, args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-conditional-filter',
                template: "<ng-container *ngIf=\"esf.column\">\n    <div tabindex=\"0\"\n        class=\"igx-excel-filter__actions-filter\"\n        (keydown)=\"onTextFilterKeyDown($event)\"\n        (click)=\"onTextFilterClick($event)\"\n        [igxDropDownItemNavigation]=\"subMenu\">\n        <span>{{ subMenuText }}</span>\n        <igx-icon>keyboard_arrow_right</igx-icon>\n    </div>\n\n    <igx-drop-down\n        #subMenu\n        [maxHeight]=\"'397px'\"\n        [displayDensity]=\"esf.grid.displayDensity\"\n        (onSelection)=\"onSubMenuSelection($event)\"\n        (onClosed)=\"onSubMenuClosed()\">\n        <div>\n            <igx-drop-down-item\n            *ngFor=\"let condition of conditions\"\n            [value]=\"condition\">\n                <div class=\"igx-grid__filtering-dropdown-items\">\n                    <igx-icon family=\"imx-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n                    <span class=\"igx-grid__filtering-dropdown-text\">{{ translateCondition(condition) }}</span>\n                </div>\n            </igx-drop-down-item>\n            <igx-drop-down-item *ngIf=\"showCustomFilterItem()\">\n                <div class=\"igx-grid__filtering-dropdown-items\">\n                    <igx-icon>filter_list</igx-icon>\n                    <span class=\"igx-grid__filtering-dropdown-text\">{{ esf.grid.resourceStrings.igx_grid_excel_custom_filter }}</span>\n                </div>\n            </igx-drop-down-item>\n        </div>\n    </igx-drop-down>\n\n    <igx-excel-style-custom-dialog\n        #customDialog\n        [column]=\"esf.column\"\n        [filteringService]=\"esf.grid.filteringService\"\n        [overlayComponentId]=\"esf.overlayComponentId\"\n        [overlayService]=\"esf.overlayService\"\n        [displayDensity]=\"esf.grid.displayDensity\">\n    </igx-excel-style-custom-dialog>\n</ng-container>\n"
            },] }
];
IgxExcelStyleConditionalFilterComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];
IgxExcelStyleConditionalFilterComponent.propDecorators = {
    customDialog: [{ type: ViewChild, args: ['customDialog', { read: IgxExcelStyleCustomDialogComponent },] }],
    subMenu: [{ type: ViewChild, args: ['subMenu', { read: IgxDropDownComponent },] }]
};

/**
 * A component used for presenting Excel style header UI.
 */
class IgxExcelStyleHeaderComponent {
    constructor(esf) {
        this.esf = esf;
    }
}
IgxExcelStyleHeaderComponent.decorators = [
    { type: Component, args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-header',
                template: "<header *ngIf=\"esf.column\"\r\n        class=\"igx-excel-filter__menu-header\">\r\n    <h4>{{ esf.column.header || esf.column.field }}</h4>\r\n    <div class=\"igx-excel-filter__menu-header-actions\">\r\n        <button *ngIf=\"showSelecting\"\r\n            igxButton=\"icon\"\r\n            (click)=\"esf.onSelect()\"\r\n            [ngClass]=\"esf.selectedClass()\"\r\n        >\r\n            <igx-icon>done</igx-icon>\r\n        </button>\r\n        <button *ngIf=\"showPinning\"\r\n            igxButton=\"icon\"\r\n            (click)=\"esf.onPin()\"\r\n        >\r\n            <igx-icon family=\"imx-icons\" [name]=\"esf.column.pinned ? 'unpin-left' : 'pin-left'\"></igx-icon>\r\n        </button>\r\n        <button *ngIf=\"showHiding\"\r\n            igxButton=\"icon\"\r\n            (click)=\"esf.onHideToggle()\"\r\n        >\r\n            <igx-icon>{{ esf.column.hidden ? 'visibility' : 'visibility_off' }}</igx-icon>\r\n        </button>\r\n    </div>\r\n</header>\r\n"
            },] }
];
IgxExcelStyleHeaderComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];
IgxExcelStyleHeaderComponent.propDecorators = {
    showPinning: [{ type: Input }],
    showSelecting: [{ type: Input }],
    showHiding: [{ type: Input }]
};

/**
 * A component used for presenting Excel style column hiding UI.
 */
class IgxExcelStyleHidingComponent {
    constructor(esf) {
        this.esf = esf;
    }
}
IgxExcelStyleHidingComponent.decorators = [
    { type: Component, args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-hiding',
                template: "<div *ngIf=\"esf.column\"\n    class=\"igx-excel-filter__actions-hide\"\n    tabindex=\"0\"\n    (click)=\"esf.onHideToggle()\">\n    <span>{{ esf.column.hidden ? esf.grid.resourceStrings.igx_grid_excel_show : esf.grid.resourceStrings.igx_grid_excel_hide }}</span>\n    <igx-icon>{{ esf.column.hidden ? 'visibility' : 'visibility_off' }}</igx-icon>\n</div>\n"
            },] }
];
IgxExcelStyleHidingComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];

/**
 * @hidden
 */
function WatchChanges() {
    return (target, key, propDesc) => {
        const privateKey = '_' + key.toString();
        propDesc = propDesc || {
            configurable: true,
            enumerable: true,
        };
        propDesc.get = propDesc.get || (function () {
            return this[privateKey];
        });
        const originalSetter = propDesc.set || (function (val) {
            this[privateKey] = val;
        });
        propDesc.set = function (val) {
            const init = this._init;
            const oldValue = this[key];
            if (val !== oldValue || (typeof val === 'object' && val === oldValue)) {
                originalSetter.call(this, val);
                if (this.ngOnChanges && !init) {
                    // in case wacthed prop changes trigger ngOnChanges manually
                    const changes = {
                        [key]: new SimpleChange(oldValue, val, false)
                    };
                    this.ngOnChanges(changes);
                }
            }
        };
        return propDesc;
    };
}
function WatchColumnChanges() {
    return (target, key, propDesc) => {
        const privateKey = '_' + key.toString();
        propDesc = propDesc || {
            configurable: true,
            enumerable: true,
        };
        propDesc.get = propDesc.get || (function () {
            return this[privateKey];
        });
        const originalSetter = propDesc.set || (function (val) {
            this[privateKey] = val;
        });
        propDesc.set = function (val) {
            const oldValue = this[key];
            originalSetter.call(this, val);
            if (val !== oldValue || (typeof val === 'object' && val === oldValue)) {
                if (this.onColumnChange) {
                    this.onColumnChange.emit();
                }
            }
        };
        return propDesc;
    };
}
function notifyChanges(repaint = false) {
    return (_, key, propDesc) => {
        const privateKey = `__${key}`;
        propDesc = propDesc || {
            enumerable: true,
            configurable: true
        };
        const originalSetter = propDesc ? propDesc.set : null;
        propDesc.get = propDesc.get || (function () {
            return this[privateKey];
        });
        propDesc.set = function (newValue) {
            if (originalSetter) {
                originalSetter.call(this, newValue);
                if (this.grid) {
                    this.grid.notifyChanges(repaint);
                }
            }
            else {
                if (newValue === this[key]) {
                    return;
                }
                this[privateKey] = newValue;
                if (this.grid) {
                    this.grid.notifyChanges(repaint);
                }
            }
        };
        return propDesc;
    };
}

const clear = (el) => el === 0 || Boolean(el);
const ɵ0$4 = clear;
const first = (arr) => arr[0];
const ɵ1$1 = first;
const last = (arr) => arr[arr.length - 1];
const ɵ2 = last;
class IgxSummaryOperand {
    /**
     * Counts all the records in the data source.
     * If filtering is applied, counts only the filtered records.
     * ```typescript
     * IgxSummaryOperand.count(dataSource);
     * ```
     *
     * @memberof IgxSummaryOperand
     */
    static count(data) {
        return data.length;
    }
    /**
     * Executes the static `count` method and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomSummary extends IgxSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "test",
     *       label: "Test",
     *       summaryResult: IgxSummaryOperand.count(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomSummary;
     * ```
     *
     * @memberof IgxSummaryOperand
     */
    operate(data = [], allData = [], fieldName, locale = 'en-US') {
        const pipe = new DecimalPipe(locale);
        return [{
                key: 'count',
                label: 'Count',
                summaryResult: pipe.transform(IgxSummaryOperand.count(data))
            }];
    }
}
// @dynamic
class IgxNumberSummaryOperand extends IgxSummaryOperand {
    /**
     * Returns the minimum numeric value in the provided data records.
     * If filtering is applied, returns the minimum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.min(data);
     * ```
     *
     * @memberof IgxNumberSummaryOperand
     */
    static min(data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => Math.min(a, b)) : 0;
    }
    /**
     * Returns the maximum numeric value in the provided data records.
     * If filtering is applied, returns the maximum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.max(data);
     * ```
     *
     * @memberof IgxNumberSummaryOperand
     */
    static max(data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => Math.max(a, b)) : 0;
    }
    /**
     * Returns the sum of the numeric values in the provided data records.
     * If filtering is applied, returns the sum of the numeric values in the data records.
     * ```typescript
     * IgxNumberSummaryOperand.sum(data);
     * ```
     *
     * @memberof IgxNumberSummaryOperand
     */
    static sum(data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => +a + +b) : 0;
    }
    /**
     * Returns the average numeric value in the data provided data records.
     * If filtering is applied, returns the average numeric value in the filtered data records.
     * ```typescript
     * IgxSummaryOperand.average(data);
     * ```
     *
     * @memberof IgxNumberSummaryOperand
     */
    static average(data) {
        return data.length && data.filter(clear).length ? this.sum(data) / this.count(data) : 0;
    }
    /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomNumberSummary extends IgxNumberSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data: any[], allData: any[], fieldName: string, locale: string, pipeArgs: IColumnPipeArgs): IgxSummaryResult[] {
     *     pipeArgs.digitsInfo = '1.1-2';
     *     const result = super.operate(data, allData, fieldName, locale, pipeArgs);
     *     result.push({
     *       key: "avg",
     *       label: "Avg",
     *       summaryResult: IgxNumberSummaryOperand.average(data)
     *     });
     *     result.push({
     *       key: 'mdn',
     *       label: 'Median',
     *       summaryResult: this.findMedian(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomNumberSummary;
     * ```
     *
     * @memberof IgxNumberSummaryOperand
     */
    operate(data = [], allData = [], fieldName, locale = 'en-US', pipeArgs = {}) {
        const result = super.operate(data, allData, fieldName, locale);
        const pipe = new DecimalPipe(locale);
        result.push({
            key: 'min',
            label: 'Min',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.min(data), pipeArgs.digitsInfo)
        });
        result.push({
            key: 'max',
            label: 'Max',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.max(data), pipeArgs.digitsInfo)
        });
        result.push({
            key: 'sum',
            label: 'Sum',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.sum(data), pipeArgs.digitsInfo)
        });
        result.push({
            key: 'average',
            label: 'Avg',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.average(data), pipeArgs.digitsInfo)
        });
        return result;
    }
}
// @dynamic
class IgxDateSummaryOperand extends IgxSummaryOperand {
    /**
     * Returns the latest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.latest(data);
     * ```
     *
     * @memberof IgxDateSummaryOperand
     */
    static latest(data) {
        return data.length && data.filter(clear).length ?
            first(data.filter(clear).sort((a, b) => new Date(b).valueOf() - new Date(a).valueOf())) : undefined;
    }
    /**
     * Returns the earliest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.earliest(data);
     * ```
     *
     * @memberof IgxDateSummaryOperand
     */
    static earliest(data) {
        return data.length && data.filter(clear).length ?
            last(data.filter(clear).sort((a, b) => new Date(b).valueOf() - new Date(a).valueOf())) : undefined;
    }
    /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomDateSummary extends IgxDateSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data: any[], allData: any[], fieldName: string, locale: string, pipeArgs: IColumnPipeArgs): IgxSummaryResult[] {
     *     pipeArgs = {
     *        format: 'longDate',
     *        timezone: 'UTC'
     *     };
     *     const result = super.operate(data, allData, fieldName, locale, pipeArgs);
     *     result.push({
     *       key: "deadline",
     *       label: "Deadline Date",
     *       summaryResult: this.calculateDeadline(data);
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomDateSummary;
     * ```
     *
     * @memberof IgxDateSummaryOperand
     */
    operate(data = [], allData = [], fieldName, locale = 'en-US', pipeArgs = {}) {
        const result = super.operate(data, allData, fieldName, locale);
        const pipe = new DatePipe(locale);
        result.push({
            key: 'earliest',
            label: 'Earliest',
            summaryResult: pipe.transform(IgxDateSummaryOperand.earliest(data), pipeArgs.format, pipeArgs.timezone)
        });
        result.push({
            key: 'latest',
            label: 'Latest',
            summaryResult: pipe.transform(IgxDateSummaryOperand.latest(data), pipeArgs.format, pipeArgs.timezone)
        });
        return result;
    }
}
class IgxCurrencySummaryOperand extends IgxSummaryOperand {
    operate(data = [], allData = [], fieldName, locale = 'en-US', pipeArgs = {}) {
        const result = super.operate(data, allData, fieldName, locale);
        const currencyCode = pipeArgs.currencyCode ? pipeArgs.currencyCode : getLocaleCurrencyCode(locale);
        const pipe = new CurrencyPipe(locale, currencyCode);
        result.push({
            key: 'min',
            label: 'Min',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.min(data), currencyCode, pipeArgs.display, pipeArgs.digitsInfo)
        });
        result.push({
            key: 'max',
            label: 'Max',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.max(data), currencyCode, pipeArgs.display, pipeArgs.digitsInfo)
        });
        result.push({
            key: 'sum',
            label: 'Sum',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.sum(data), currencyCode, pipeArgs.display, pipeArgs.digitsInfo)
        });
        result.push({
            key: 'average',
            label: 'Avg',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.average(data), currencyCode, pipeArgs.display, pipeArgs.digitsInfo)
        });
        return result;
    }
}
class IgxPercentSummaryOperand extends IgxSummaryOperand {
    operate(data = [], allData = [], fieldName, locale = 'en-US', pipeArgs = {}) {
        const result = super.operate(data, allData, fieldName, locale);
        const pipe = new PercentPipe(locale);
        result.push({
            key: 'min',
            label: 'Min',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.min(data), pipeArgs.digitsInfo)
        });
        result.push({
            key: 'max',
            label: 'Max',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.max(data), pipeArgs.digitsInfo)
        });
        result.push({
            key: 'sum',
            label: 'Sum',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.sum(data), pipeArgs.digitsInfo)
        });
        result.push({
            key: 'average',
            label: 'Avg',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.average(data), pipeArgs.digitsInfo)
        });
        return result;
    }
}

class IgxFilterCellTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxFilterCellTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxFilterCellTemplate]'
            },] }
];
IgxFilterCellTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxCellTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCellTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCell]'
            },] }
];
IgxCellTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxCellHeaderTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCellHeaderTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxHeader]'
            },] }
];
IgxCellHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
class IgxCellFooterTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCellFooterTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxFooter]'
            },] }
];
IgxCellFooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxCellEditorTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCellEditorTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCellEditor]'
            },] }
];
IgxCellEditorTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxCollapsibleIndicatorTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCollapsibleIndicatorTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCollapsibleIndicator]'
            },] }
];
IgxCollapsibleIndicatorTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * This enumeration is used to configure whether the drop position is set before or after
 * the target.
 */
var DropPosition;
(function (DropPosition) {
    DropPosition[DropPosition["BeforeDropTarget"] = 0] = "BeforeDropTarget";
    DropPosition[DropPosition["AfterDropTarget"] = 1] = "AfterDropTarget";
})(DropPosition || (DropPosition = {}));
/**
 * @hidden
 * @internal
 */
class IgxColumnMovingService {
    get column() {
        return this._column;
    }
    set column(val) {
        if (val) {
            this._column = val;
        }
    }
    get icon() {
        return this._icon;
    }
    set icon(val) {
        if (val) {
            this._icon = val;
        }
    }
}
IgxColumnMovingService.ɵprov = ɵɵdefineInjectable({ factory: function IgxColumnMovingService_Factory() { return new IgxColumnMovingService(); }, token: IgxColumnMovingService, providedIn: "root" });
IgxColumnMovingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];

const DEFAULT_DATE_FORMAT = 'mediumDate';
const DEFAULT_DIGITS_INFO = '1.0-3';
/**
 * **Ignite UI for Angular Column** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid#columns-configuration)
 *
 * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
 * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
 * the column using `ng-template` which will be used for all cells within the column.
 */
class IgxColumnComponent {
    constructor(gridAPI, cdr) {
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        /**
         * Sets/gets the `header` value.
         * ```typescript
         * let columnHeader = this.column.header;
         * ```
         * ```html
         * <igx-column [header] = "'ID'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.header = '';
        /**
         * Sets/gets the `title` value.
         * ```typescript
         * let title = this.column.title;
         * ```
         * ```html
         * <igx-column [title] = "'Some column tooltip'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.title = '';
        /**
         * Sets/gets whether the column is sortable.
         * Default value is `false`.
         * ```typescript
         * let isSortable = this.column.sortable;
         * ```
         * ```html
         * <igx-column [sortable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.sortable = false;
        /**
         * Sets/gets whether the column is groupable.
         * Default value is `false`.
         * ```typescript
         * let isGroupable = this.column.groupable;
         * ```
         * ```html
         * <igx-column [groupable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.groupable = false;
        /**
         * Sets/gets whether the column is filterable.
         * Default value is `true`.
         * ```typescript
         * let isFilterable = this.column.filterable;
         * ```
         * ```html
         * <igx-column [filterable] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.filterable = true;
        /**
         * Sets/gets whether the column is resizable.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.resizable = false;
        /**
         * @hidden
         */
        this.hiddenChange = new EventEmitter();
        /** @hidden */
        this.expandedChange = new EventEmitter();
        /** @hidden */
        this.collapsibleChange = new EventEmitter();
        /** @hidden */
        this.visibleWhenCollapsedChange = new EventEmitter();
        /** @hidden */
        this.onColumnChange = new EventEmitter();
        /**
         * Gets whether the hiding is disabled.
         * ```typescript
         * let isHidingDisabled =  this.column.disableHiding;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.disableHiding = false;
        /**
         * Gets whether the pinning is disabled.
         * ```typescript
         * let isPinningDisabled =  this.column.disablePinning;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.disablePinning = false;
        /**
         * Sets/gets whether the column is movable.
         * Default value is `false`.
         * ```typescript
         * let isMovable = this.column.movable;
         * ```
         * ```html
         * <igx-column [movable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.movable = false;
        /**
         * Sets/gets the class selector of the column header.
         * ```typescript
         * let columnHeaderClass = this.column.headerClasses;
         * ```
         * ```html
         * <igx-column [headerClasses] = "'column-header'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerClasses = '';
        /**
         * Sets/gets the class selector of the column group header.
         * ```typescript
         * let columnHeaderClass = this.column.headerGroupClasses;
         * ```
         * ```html
         * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerGroupClasses = '';
        /**
         * Sets conditional style properties on the column cells.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * As with `cellClasses` it accepts a callback function.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') : 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [cellStyles]="styles"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.cellStyles = null;
        /**
         * Sets/gets whether the column filtering should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let filteringIgnoreCase = this.column.filteringIgnoreCase;
         * ```
         * ```html
         * <igx-column [filteringIgnoreCase] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.filteringIgnoreCase = true;
        /**
         * Sets/gets whether the column sorting should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let sortingIgnoreCase = this.column.sortingIgnoreCase;
         * ```
         * ```html
         * <igx-column [sortingIgnoreCase] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.sortingIgnoreCase = true;
        /**
         * Sets/gets whether the column is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.column.searchable';
         * ```
         * ```html
         *  <igx-column [searchable] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.searchable = true;
        /**
         * Sets/gets the data type of the column values.
         * Default value is `string`.
         * ```typescript
         * let columnDataType = this.column.dataType;
         * ```
         * ```html
         * <igx-column [dataType] = "'number'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.dataType = DataType.String;
        /**
         * @hidden
         */
        this.widthChange = new EventEmitter();
        /**
         * @hidden
         */
        this.pinnedChange = new EventEmitter();
        /**
         * Sets/gets the parent column.
         * ```typescript
         * let parentColumn = this.column.parent;
         * ```
         * ```typescript
         * this.column.parent = higherLevelColumn;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.parent = null;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        /**
         * @hidden
         */
        this._applySelectableClass = false;
        this._vIndex = NaN;
        /**
         * @hidden
         */
        this._pinned = false;
        /**
         * @hidden
         */
        this._summaries = null;
        /**
         * @hidden
         */
        this._filters = null;
        /**
         * @hidden
         */
        this._sortStrategy = DefaultSortingStrategy.instance();
        /**
         * @hidden
         */
        this._hidden = false;
        /**
         * @hidden
         */
        this._disablePinning = false;
        /**
         * @hidden
         */
        this._defaultMinWidth = '';
        /**
         * @hidden
         */
        this._hasSummary = false;
        /**
         * @hidden
         */
        this._collapsible = false;
        /**
         * @hidden
         */
        this._expanded = true;
        /**
         * @hidden
         */
        this._selectable = true;
        this._calcWidth = null;
        this._columnPipeArgs = { format: DEFAULT_DATE_FORMAT, digitsInfo: DEFAULT_DIGITS_INFO };
    }
    /**
     * Sets/gets the `field` value.
     * ```typescript
     * let columnField = this.column.field;
     * ```
     * ```html
     * <igx-column [field] = "'ID'"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set field(value) {
        this._field = value;
        this.hasNestedPath = value === null || value === void 0 ? void 0 : value.includes('.');
    }
    get field() {
        return this._field;
    }
    /**
     * Returns if the column is selectable.
     * ```typescript
     * let columnSelectable = this.column.selectable;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get selectable() {
        return this._selectable;
    }
    /**
     * Sets if the column is selectable.
     * Default value is `true`.
     * ```html
     * <igx-column [selectable] = "false"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set selectable(value) {
        this._selectable = value;
    }
    /**
     * Gets whether the column is editable.
     * Default value is `false`.
     * ```typescript
     * let isEditable = this.column.editable;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get editable() {
        // Updating the primary key when grid has transactions (incl. row edit)
        // should not be allowed, as that can corrupt transaction state.
        const rowEditable = this.grid && this.grid.rowEditable;
        const hasTransactions = this.grid && this.grid.transactions.enabled;
        if (this.isPrimaryColumn && (rowEditable || hasTransactions)) {
            return false;
        }
        if (this._editable !== undefined) {
            return this._editable;
        }
        else {
            return rowEditable;
        }
    }
    /**
     * Sets whether the column is editable.
     * ```typescript
     * this.column.editable = true;
     * ```
     * ```html
     * <igx-column [editable] = "true"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set editable(editable) {
        this._editable = editable;
    }
    /**
     * Gets a value indicating whether the summary for the column is enabled.
     * ```typescript
     * let hasSummary = this.column.hasSummary;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get hasSummary() {
        return this._hasSummary;
    }
    /**
     * Sets a value indicating whether the summary for the column is enabled.
     * Default value is `false`.
     * ```html
     * <igx-column [hasSummary] = "true"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set hasSummary(value) {
        this._hasSummary = value;
        if (this.grid) {
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets whether the column is hidden.
     * ```typescript
     * let isHidden = this.column.hidden;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column hidden property.
     * Default value is `false`.
     * ```html
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(hidden)] = "model.isHidden"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set hidden(value) {
        if (this._hidden !== value) {
            this._hidden = value;
            this.hiddenChange.emit(this._hidden);
            if (this.columnLayoutChild && this.parent.hidden !== value) {
                this.parent.hidden = value;
                return;
            }
            if (this.grid) {
                this.grid.endEdit(false);
                this.grid.summaryService.resetSummaryHeight();
                this.grid.filteringService.refreshExpressions();
                this.grid.filteringService.hideFilteringRowOnColumnVisibilityChange(this);
                this.grid.notifyChanges();
            }
        }
    }
    /**
     * Returns if the column is selected.
     * ```typescript
     * let isSelected = this.column.selected;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get selected() {
        return this.grid.selectionService.isColumnSelected(this.field);
    }
    /**
     * Select/deselect a column.
     * Default value is `false`.
     * ```typescript
     * this.column.selected = true;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set selected(value) {
        if (this.selectable && value !== this.selected) {
            if (value) {
                this.grid.selectionService.selectColumnsWithNoEvent([this.field]);
            }
            else {
                this.grid.selectionService.deselectColumnsWithNoEvent([this.field]);
            }
            this.grid.notifyChanges();
        }
    }
    /**
     * Gets the `width` of the column.
     * ```typescript
     * let columnWidth = this.column.width;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get width() {
        return this.widthSetByUser ? this._width : this.defaultWidth;
    }
    /**
     * Sets the `width` of the column.
     * ```html
     * <igx-column [width] = "'25%'"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(width)]="model.columns[0].width"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set width(value) {
        if (value) {
            this._calcWidth = null;
            this.calcPixelWidth = NaN;
            this.widthSetByUser = true;
            // width could be passed as number from the template
            // host bindings are not px affixed so we need to ensure we affix simple number strings
            if (typeof (value) === 'number' || value.match(/^[0-9]*$/)) {
                value = value + 'px';
            }
            this._width = value;
            if (this.grid) {
                this.cacheCalcWidth();
            }
            this.widthChange.emit(this._width);
        }
    }
    /**
     * @hidden
     */
    get calcWidth() {
        return this.getCalcWidth();
    }
    /**
     * @hidden
     */
    get maxWidthPx() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.maxWidth) / 100 * gridAvailableSize : parseFloat(this.maxWidth);
    }
    /**
     * @hidden
     */
    get maxWidthPercent() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.maxWidth) : parseFloat(this.maxWidth) / gridAvailableSize * 100;
    }
    /**
     * @hidden
     */
    get minWidthPx() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.minWidth) / 100 * gridAvailableSize : parseFloat(this.minWidth);
    }
    /**
     * @hidden
     */
    get minWidthPercent() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.minWidth) : parseFloat(this.minWidth) / gridAvailableSize * 100;
    }
    /**
     * Sets/gets the minimum `width` of the column.
     * Default value is `88`;
     * ```typescript
     * let columnMinWidth = this.column.minWidth;
     * ```
     * ```html
     * <igx-column [minWidth] = "'100px'"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set minWidth(value) {
        const minVal = parseFloat(value);
        if (Number.isNaN(minVal)) {
            return;
        }
        this._defaultMinWidth = value;
    }
    get minWidth() {
        return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;
    }
    /**
     * Gets the column index.
     * ```typescript
     * let columnIndex = this.column.index;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get index() {
        return this.grid.columns.indexOf(this);
    }
    /**
     * Gets whether the column is `pinned`.
     * ```typescript
     * let isPinned = this.column.pinned;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get pinned() {
        return this._pinned;
    }
    /**
     * Sets whether the column is pinned.
     * Default value is `false`.
     * ```html
     * <igx-column [pinned] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(pinned)] = "model.columns[0].isPinned"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set pinned(value) {
        if (this._pinned !== value) {
            if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {
                if (value) {
                    this.pin();
                }
                else {
                    this.unpin();
                }
                return;
            }
            /* No grid/width available at initialization. `initPinning` in the grid
               will re-init the group (if present)
            */
            this._pinned = value;
            this.pinnedChange.emit(this._pinned);
        }
    }
    /**
     * Gets the column `summaries`.
     * ```typescript
     * let columnSummaries = this.column.summaries;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column `summaries`.
     * ```typescript
     * this.column.summaries = IgxNumberSummaryOperand;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set summaries(classRef) {
        this._summaries = new classRef();
        if (this.grid) {
            this.grid.summaryService.removeSummariesCachePerColumn(this.field);
            this.grid._summaryPipeTrigger++;
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets the column `filters`.
     * ```typescript
     * let columnFilters = this.column.filters'
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column `filters`.
     * ```typescript
     * this.column.filters = IgxBooleanFilteringOperand.instance().
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set filters(instance) {
        this._filters = instance;
    }
    /**
     * Gets the column `sortStrategy`.
     * ```typescript
     * let sortStrategy = this.column.sortStrategy
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get sortStrategy() {
        return this._sortStrategy;
    }
    /**
     * Sets the column `sortStrategy`.
     * ```typescript
     * this.column.sortStrategy = new CustomSortingStrategy().
     * class CustomSortingStrategy extends SortingStrategy {...}
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set sortStrategy(classRef) {
        this._sortStrategy = classRef;
    }
    /**
     * Gets the function that compares values for grouping.
     * ```typescript
     * let groupingComparer = this.column.groupingComparer'
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get groupingComparer() {
        return this._groupingComparer;
    }
    /**
     * Sets a custom function to compare values for grouping.
     * Subsequent values in the sorted data that the function returns 0 for are grouped.
     * ```typescript
     * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set groupingComparer(funcRef) {
        this._groupingComparer = funcRef;
    }
    /**
     * Gets the default minimum `width` of the column.
     * ```typescript
     * let defaultMinWidth =  this.column.defaultMinWidth;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get defaultMinWidth() {
        if (!this.grid) {
            return '80';
        }
        switch (this.grid.displayDensity) {
            case DisplayDensity.cosy:
                return '64';
            case DisplayDensity.compact:
                return '56';
            default:
                return '80';
        }
    }
    /**
     * The reference to the `igx-grid` owner.
     * ```typescript
     * let gridComponent = this.column.grid;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Returns a reference to the `bodyTemplate`.
     * ```typescript
     * let bodyTemplate = this.column.bodyTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * Sets the body template.
     * ```html
     * <ng-template #bodyTemplate igxCell let-val>
     *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
     *       <span> {{val}} </span>
     *    </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'bodyTemplate'", {read: TemplateRef })
     * public bodyTemplate: TemplateRef<any>;
     * this.column.bodyTemplate = this.bodyTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set bodyTemplate(template) {
        this._bodyTemplate = template;
    }
    /**
     * Returns a reference to the header template.
     * ```typescript
     * let headerTemplate = this.column.headerTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get headerTemplate() {
        return this._headerTemplate;
    }
    /**
     * Sets the header template.
     * Note that the column header height is fixed and any content bigger than it will be cut off.
     * ```html
     * <ng-template #headerTemplate>
     *   <div style = "background-color:black" (click) = "changeColor(val)">
     *       <span style="color:red" >{{column.field}}</span>
     *   </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'headerTemplate'", {read: TemplateRef })
     * public headerTemplate: TemplateRef<any>;
     * this.column.headerTemplate = this.headerTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set headerTemplate(template) {
        this._headerTemplate = template;
    }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.column.inlineEditorTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * Sets the inline editor template.
     * ```html
     * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
     *     <input type="string" [(ngModel)]="cell.value"/>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
     * public inlineEditorTemplate: TemplateRef<any>;
     * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set inlineEditorTemplate(template) {
        this._inlineEditorTemplate = template;
    }
    /**
     * Returns a reference to the `filterCellTemplate`.
     * ```typescript
     * let filterCellTemplate = this.column.filterCellTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filterCellTemplate() {
        return this._filterCellTemplate;
    }
    /**
     * Sets the quick filter template.
     * ```html
     * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
     *    <input (input)="onInput()">
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'filterCellTemplate'", {read: TemplateRef })
     * public filterCellTemplate: TemplateRef<any>;
     * this.column.filterCellTemplate = this.filterCellTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set filterCellTemplate(template) {
        this._filterCellTemplate = template;
    }
    /**
     * Gets the cells of the column.
     * ```typescript
     * let columnCells =  this.column.cells;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get cells() {
        return this.grid.rowList.filter((row) => row instanceof IgxRowDirective)
            .map((row) => {
            if (row.cells) {
                return row.cells.filter((cell) => cell.columnIndex === this.index);
            }
        }).reduce((a, b) => a.concat(b), []);
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => !c.columnGroup);
        const pinnedColumns = this.grid.pinnedColumns.filter(c => !c.columnGroup);
        let col = this;
        let vIndex = -1;
        if (this.columnGroup) {
            col = this.allChildren.filter(c => !c.columnGroup && !c.hidden)[0];
        }
        if (this.columnLayoutChild) {
            return this.parent.childrenVisibleIndexes.find(x => x.column === this).index;
        }
        if (!this.pinned) {
            const indexInCollection = unpinnedColumns.indexOf(col);
            vIndex = indexInCollection === -1 ?
                -1 :
                (this.grid.isPinningToStart ?
                    pinnedColumns.length + indexInCollection :
                    indexInCollection);
        }
        else {
            const indexInCollection = pinnedColumns.indexOf(col);
            vIndex = this.grid.isPinningToStart ?
                indexInCollection :
                unpinnedColumns.length + indexInCollection;
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnGroup() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnLayout() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnLayoutChild =  this.column.columnLayoutChild;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnLayoutChild() {
        return this.parent && this.parent.columnLayout;
    }
    /**
     * Returns the children columns collection.
     * Returns an empty array if the column does not contain children columns.
     * ```typescript
     * let childrenColumns =  this.column.allChildren;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get allChildren() {
        return [];
    }
    /**
     * Returns the level of the column in a column group.
     * Returns `0` if the column doesn't have a `parent`.
     * ```typescript
     * let columnLevel =  this.column.level;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get level() {
        let ptr = this.parent;
        let lvl = 0;
        while (ptr) {
            lvl++;
            ptr = ptr.parent;
        }
        return lvl;
    }
    get isLastPinned() {
        return this.grid.isPinningToStart &&
            this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
    }
    get isFirstPinned() {
        const pinnedCols = this.grid.pinnedColumns.filter(x => !x.columnGroup);
        return !this.grid.isPinningToStart && pinnedCols[0] === this;
    }
    get rightPinnedOffset() {
        return this.pinned && !this.grid.isPinningToStart ?
            -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' :
            null;
    }
    get gridRowSpan() {
        return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
    }
    get gridColumnSpan() {
        return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
    }
    /**
     * Indicates whether the column will be visible when its parent is collapsed.
     * ```html
     * <igx-column-group>
     *   <igx-column [visibleWhenCollapsed]="true"></igx-column>
     * </igx-column-group>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set visibleWhenCollapsed(value) {
        this._visibleWhenCollapsed = value;
        this.visibleWhenCollapsedChange.emit(this._visibleWhenCollapsed);
        if (this.parent) {
            this.parent.setExpandCollapseState();
        }
    }
    get visibleWhenCollapsed() {
        return this._visibleWhenCollapsed;
    }
    /**
     * @remarks
     * Pass optional parameters for DatePipe and/or DecimalPipe to format the display value for date and numeric columns.
     * Accepts an `IColumnPipeArgs` object with any of the `format`, `timezone` and `digitsInfo` properties.
     * For more details see https://angular.io/api/common/DatePipe and https://angular.io/api/common/DecimalPipe
     * @example
     * ```typescript
     * const pipeArgs: IColumnPipeArgs = {
     *      format: 'longDate',
     *      timezone: 'UTC',
     *      digitsInfo: '1.1-2'
     * }
     * ```
     * ```html
     * <igx-column dataType="date" [pipeArgs]="pipeArgs"></igx-column>
     * <igx-column dataType="number" [pipeArgs]="pipeArgs"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set pipeArgs(value) {
        this._columnPipeArgs = Object.assign(this._columnPipeArgs, value);
        this.grid.summaryService.clearSummaryCache();
        this.grid._pipeTrigger++;
        this.grid.notifyChanges();
    }
    get pipeArgs() {
        return this._columnPipeArgs;
    }
    /**
     * @hidden
     * @internal
     */
    get collapsible() {
        return false;
    }
    set collapsible(_value) { }
    /**
     * @hidden
     * @internal
     */
    get expanded() {
        return true;
    }
    set expanded(_value) { }
    /**
     * Returns the filteringExpressionsTree of the column.
     * ```typescript
     * let tree =  this.column.filteringExpressionsTree;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filteringExpressionsTree() {
        return this.grid.filteringExpressionsTree.find(this.field);
    }
    /**
     * @hidden
     */
    get isPrimaryColumn() {
        return this.field !== undefined && this.grid !== undefined && this.field === this.grid.primaryKey;
    }
    /**
     * @hidden
     * @internal
     */
    resetCaches() {
        this._vIndex = NaN;
        if (this.grid) {
            this.cacheCalcWidth();
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.cellTemplate) {
            this._bodyTemplate = this.cellTemplate.template;
        }
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        if (this.editorTemplate) {
            this._inlineEditorTemplate = this.editorTemplate.template;
        }
        if (this.filterCellTemplateDirective) {
            this._filterCellTemplate = this.filterCellTemplateDirective.template;
        }
        if (!this.summaries) {
            switch (this.dataType) {
                case DataType.String:
                case DataType.Boolean:
                    this.summaries = IgxSummaryOperand;
                    break;
                case DataType.Number:
                    this.summaries = IgxNumberSummaryOperand;
                    break;
                case DataType.Date:
                    this.summaries = IgxDateSummaryOperand;
                    break;
                case DataType.Currency:
                    this.summaries = IgxCurrencySummaryOperand;
                    break;
                case DataType.Percent:
                    this.summaries = IgxPercentSummaryOperand;
                    break;
                default:
                    this.summaries = IgxSummaryOperand;
                    break;
            }
        }
        if (!this.filters) {
            switch (this.dataType) {
                case DataType.Boolean:
                    this.filters = IgxBooleanFilteringOperand.instance();
                    break;
                case DataType.Number:
                case DataType.Currency:
                case DataType.Percent:
                    this.filters = IgxNumberFilteringOperand.instance();
                    break;
                case DataType.Date:
                    this.filters = IgxDateFilteringOperand.instance();
                    break;
                case DataType.String:
                default:
                    this.filters = IgxStringFilteringOperand.instance();
                    break;
            }
        }
    }
    /**
     * @hidden
     */
    getGridTemplate(isRow, isIE) {
        if (isRow) {
            const rowsCount = this.grid.multiRowLayoutRowSize;
            return isIE ?
                `(1fr)[${rowsCount}]` :
                `repeat(${rowsCount},1fr)`;
        }
        else {
            return this.getColumnSizesString(this.children);
        }
    }
    getInitialChildColumnSizes(children) {
        const columnSizes = [];
        // find the smallest col spans
        children.forEach(col => {
            if (!col.colStart) {
                return;
            }
            const newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            const newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
            const bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
            const bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            if (columnSizes[col.colStart - 1] === undefined) {
                // If nothing is defined yet take any column at first
                // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (newWidthSet || (newSpanSmaller && ((bothWidthsSet) || (bothWidthsNotSet)))) {
                // If a column is set already it should either not have width defined or have width with bigger span than the new one.
                /**
                 *  If replaced column has bigger span, we want to fill the remaining columns
                 *  that the replacing column does not fill with the old one.
                 */
                if (bothWidthsSet && newSpanSmaller) {
                    // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                    // We have not yet replaced it so we can use it directly from the columnSizes collection.
                    // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                    for (let i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                        if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                            columnSizes[i] = columnSizes[col.colStart - 1];
                        }
                        else {
                            break;
                        }
                    }
                }
                // Replace the old column with the new one.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
                // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
                // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
                // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
                for (let i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {
                    if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                        columnSizes[i] = {
                            ref: col,
                            width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                            colSpan: col.gridColumnSpan,
                            colEnd: col.colStart + col.gridColumnSpan,
                            widthSetByUser: col.widthSetByUser
                        };
                    }
                    else {
                        break;
                    }
                }
            }
        });
        // Flatten columnSizes so there are not columns with colSpan > 1
        for (let i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && columnSizes[i].colSpan > 1) {
                let j = 1;
                // Replace all empty places depending on how much the current column spans starting from next col.
                for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                    if (columnSizes[i + j] &&
                        ((!columnSizes[i].width && columnSizes[i + j].width) ||
                            (!columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan) ||
                            (!!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan))) {
                        // If we reach an already defined column that has width and the current doesn't have or
                        // if the reached column has bigger colSpan we stop.
                        break;
                    }
                    else {
                        const width = columnSizes[i].widthSetByUser ?
                            columnSizes[i].width / columnSizes[i].colSpan :
                            columnSizes[i].width;
                        columnSizes[i + j] = {
                            ref: columnSizes[i].ref,
                            width,
                            colSpan: 1,
                            colEnd: columnSizes[i].colEnd,
                            widthSetByUser: columnSizes[i].widthSetByUser
                        };
                    }
                }
                // Update the current column width so it is divided between all columns it spans and set it to 1.
                columnSizes[i].width = columnSizes[i].widthSetByUser ?
                    columnSizes[i].width / columnSizes[i].colSpan :
                    columnSizes[i].width;
                columnSizes[i].colSpan = 1;
                // Update the index based on how much we have replaced. Subtract 1 because we started from 1.
                i += j - 1;
            }
        }
        return columnSizes;
    }
    getFilledChildColumnSizes(children) {
        const columnSizes = this.getInitialChildColumnSizes(children);
        // fill the gaps if there are any
        const result = [];
        for (const size of columnSizes) {
            if (size && !!size.width) {
                result.push(size.width + 'px');
            }
            else {
                result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
            }
        }
        return result;
    }
    getResizableColUnderEnd() {
        if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {
            return [{ target: this, spanUsed: 1 }];
        }
        const columnSized = this.getInitialChildColumnSizes(this.parent.children);
        const targets = [];
        const colEnd = this.colEnd ? this.colEnd : this.colStart + 1;
        for (let i = 0; i < columnSized.length; i++) {
            if (this.colStart <= i + 1 && i + 1 < colEnd) {
                targets.push({ target: columnSized[i].ref, spanUsed: 1 });
            }
        }
        const targetsSquashed = [];
        for (const target of targets) {
            if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === target.target.field) {
                targetsSquashed[targetsSquashed.length - 1].spanUsed++;
            }
            else {
                targetsSquashed.push(target);
            }
        }
        return targetsSquashed;
    }
    /**
     * Pins the column at the provided index in the pinned area.
     * Defaults to index `0` if not provided, or to the initial index in the pinned area.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     *
     * @memberof IgxColumnComponent
     */
    pin(index) {
        // TODO: Probably should the return type of the old functions
        // should be moved as a event parameter.
        const grid = this.grid;
        if (this._pinned) {
            return false;
        }
        if (this.parent && !this.parent.pinned) {
            return this.topLevelParent.pin(index);
        }
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index > grid.pinnedColumns.length)) {
            return false;
        }
        if (!this.parent && !this.pinnable) {
            return false;
        }
        const rootPinnedCols = grid._pinnedColumns.filter((c) => c.level === 0);
        index = hasIndex ? index : rootPinnedCols.length;
        const args = { column: this, insertAtIndex: index, isPinned: false, cancel: false };
        this.grid.onColumnPinning.emit(args);
        if (args.cancel) {
            return;
        }
        grid.endEdit(false);
        this._pinned = true;
        this.pinnedChange.emit(this._pinned);
        // it is possible that index is the last position, so will need to find target column by [index-1]
        const targetColumn = args.insertAtIndex === grid._pinnedColumns.length ?
            grid._pinnedColumns[args.insertAtIndex - 1] : grid._pinnedColumns[args.insertAtIndex];
        if (grid._pinnedColumns.indexOf(this) === -1) {
            if (!grid.hasColumnGroups) {
                grid._pinnedColumns.splice(args.insertAtIndex, 0, this);
            }
            else {
                // insert based only on root collection
                rootPinnedCols.splice(args.insertAtIndex, 0, this);
                let allPinned = [];
                // re-create hierarchy
                rootPinnedCols.forEach(group => {
                    allPinned.push(group);
                    allPinned = allPinned.concat(group.allChildren);
                });
                grid._pinnedColumns = allPinned;
            }
            if (grid._unpinnedColumns.indexOf(this) !== -1) {
                const childrenCount = this.allChildren.length;
                grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1 + childrenCount);
            }
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.pin());
            grid.reinitPinStates();
        }
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        const eventArgs = { column: this, insertAtIndex: index, isPinned: true };
        this.grid.columnPinned.emit(eventArgs);
        return true;
    }
    /**
     * Unpins the column and place it at the provided index in the unpinned area.
     * Defaults to index `0` if not provided, or to the initial index in the unpinned area.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     *
     * @memberof IgxColumnComponent
     */
    unpin(index) {
        const grid = this.grid;
        if (!this._pinned) {
            return false;
        }
        if (this.parent && this.parent.pinned) {
            return this.topLevelParent.unpin(index);
        }
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index > grid._unpinnedColumns.length)) {
            return false;
        }
        // estimate the exact index at which column will be inserted
        // takes into account initial unpinned index of the column
        if (!hasIndex) {
            const indices = grid.unpinnedColumns.map(col => col.index);
            indices.push(this.index);
            indices.sort((a, b) => a - b);
            index = indices.indexOf(this.index);
        }
        const args = { column: this, insertAtIndex: index, isPinned: true, cancel: false };
        this.grid.onColumnPinning.emit(args);
        if (args.cancel) {
            return;
        }
        this.grid.endEdit(false);
        this._pinned = false;
        this.pinnedChange.emit(this._pinned);
        // it is possible that index is the last position, so will need to find target column by [index-1]
        const targetColumn = args.insertAtIndex === grid._unpinnedColumns.length ?
            grid._unpinnedColumns[args.insertAtIndex - 1] : grid._unpinnedColumns[args.insertAtIndex];
        if (!hasIndex) {
            grid._unpinnedColumns.splice(index, 0, this);
            if (grid._pinnedColumns.indexOf(this) !== -1) {
                grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
            }
        }
        if (hasIndex) {
            grid.moveColumn(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.unpin());
        }
        grid.reinitPinStates();
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        this.grid.columnPinned.emit({ column: this, insertAtIndex: index, isPinned: false });
        return true;
    }
    /**
     * Moves a column to the specified visible index.
     * If passed index is invalid, or if column would receive a different visible index after moving, moving is not performed.
     * If passed index would move the column to a different column group. moving is not performed.
     *
     * @example
     * ```typescript
     * column.move(index);
     * ```
     * @memberof IgxColumnComponent
     */
    move(index) {
        let target;
        const grid = this.grid;
        let columns = grid.columnList.filter(c => c.visibleIndex > -1);
        // grid last visible index
        const li = columns.map(c => c.visibleIndex).reduce((a, b) => Math.max(a, b));
        const parent = this.parent;
        const isPreceding = this.visibleIndex < index;
        if (index === this.visibleIndex || index < 0 || index > li) {
            return;
        }
        if (parent) {
            columns = columns.filter(c => c.level >= this.level && c !== this && c.parent !== this &&
                c.topLevelParent === this.topLevelParent);
        }
        /* eslint-disable max-len */
        // If isPreceding, find a target such that when the current column is placed after it, current colummn will receive a visibleIndex === index. This takes into account visible children of the columns.
        // If !isPreceding, finds a column of the same level and visible index that equals the passed index agument (c.visibleIndex === index). No need to consider the children here.
        /* eslint-enable max-len */
        if (isPreceding) {
            columns = columns.filter(c => c.visibleIndex > this.visibleIndex);
            target = columns.find(c => c.level === this.level && c.visibleIndex + c.calcChildren() - this.calcChildren() === index);
        }
        else {
            columns = columns.filter(c => c.visibleIndex < this.visibleIndex);
            target = columns.find(c => c.level === this.level && c.visibleIndex === index);
        }
        if (!target || (target.pinned && this.disablePinning)) {
            return;
        }
        const pos = isPreceding ? DropPosition.AfterDropTarget : DropPosition.BeforeDropTarget;
        grid.moveColumn(this, target, pos);
    }
    /**
     * No children for the column, so will returns 1 or 0, if the column is hidden.
     *
     * @hidden
     */
    calcChildren() {
        const children = this.hidden ? 0 : 1;
        return children;
    }
    /**
     * Toggles column vibisility and emits the respective event.
     *
     * @hidden
     */
    toggleVisibility(value) {
        const newValue = value !== null && value !== void 0 ? value : !this.hidden;
        const eventArgs = { column: this, newValue, cancel: false };
        this.grid.columnVisibilityChanging.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        this.hidden = newValue;
        this.grid.onColumnVisibilityChanged.emit({ column: this, newValue });
    }
    /**
     * Returns a reference to the top level parent column.
     * ```typescript
     * let topLevelParent =  this.column.topLevelParent;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get topLevelParent() {
        let parent = this.parent;
        while (parent && parent.parent) {
            parent = parent.parent;
        }
        return parent;
    }
    /**
     * Returns a reference to the header of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let headerCell = column.headerCell;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get headerCell() {
        return this.grid.headerCellList.find((header) => header.column === this);
    }
    /**
     * Returns a reference to the filter cell of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let filterell = column.filterell;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filterCell() {
        return this.grid.filterCellList.find((filterCell) => filterCell.column === this);
    }
    /**
     * Returns a reference to the header group of the column.
     *
     * @memberof IgxColumnComponent
     */
    get headerGroup() {
        return this.grid.headerGroupsList.find((headerGroup) => headerGroup.column === this);
    }
    /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     *
     * @memberof IgxColumnComponent
     * @param byHeader Set if column should be autized based only on the header content
     */
    autosize(byHeader = false) {
        if (!this.columnGroup) {
            const size = this.getAutoSize(byHeader);
            this.width = size;
            this.grid.reflow();
        }
    }
    /**
     * @hidden
     */
    getAutoSize(byHeader = false) {
        const size = !byHeader ? this.getLargestCellWidth() :
            (Object.values(this.getHeaderCellWidths()).reduce((a, b) => a + b) + 'px');
        const gridAvailableSize = this.grid.calcWidth;
        let newWidth;
        const isPercentageWidth = this.width && typeof this.width === 'string' && this.width.indexOf('%') !== -1;
        if (isPercentageWidth) {
            const percentageSize = parseFloat(size) / gridAvailableSize * 100;
            newWidth = percentageSize + '%';
        }
        else {
            newWidth = size;
        }
        return newWidth;
    }
    /**
     * @hidden
     */
    getCalcWidth() {
        if (this._calcWidth && !isNaN(this.calcPixelWidth)) {
            return this._calcWidth;
        }
        this.cacheCalcWidth();
        return this._calcWidth;
    }
    /**
     * @hidden
     * Returns the width and padding of a header cell.
     */
    getHeaderCellWidths() {
        const range = this.grid.document.createRange();
        let headerWidth;
        if (this.headerTemplate && this.headerCell.elementRef.nativeElement.children[0].children.length > 0) {
            headerWidth = Math.max(...Array.from(this.headerCell.elementRef.nativeElement.children[0].children)
                .map((child) => getNodeSizeViaRange(range, child)));
        }
        else {
            headerWidth = getNodeSizeViaRange(range, this.headerCell.elementRef.nativeElement.children[0]);
        }
        if (this.sortable || this.filterable) {
            headerWidth += this.headerCell.elementRef.nativeElement.children[1].getBoundingClientRect().width;
        }
        const headerStyle = this.grid.document.defaultView.getComputedStyle(this.headerCell.elementRef.nativeElement);
        const headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) +
            parseFloat(headerStyle.borderRightWidth);
        // Take into consideration the header group element, since column pinning applies borders to it if its not a columnGroup.
        const headerGroupStyle = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement);
        const borderSize = !this.parent ? parseFloat(headerGroupStyle.borderRightWidth) + parseFloat(headerGroupStyle.borderLeftWidth) : 0;
        return { width: Math.ceil(headerWidth), padding: Math.ceil(headerPadding + borderSize) };
    }
    /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * @memberof IgxColumnComponent
     */
    getLargestCellWidth() {
        const range = this.grid.document.createRange();
        const largest = new Map();
        if (this.cells.length > 0) {
            let cellsContentWidths = [];
            if (this.cells[0].nativeElement.children.length > 0) {
                this.cells.forEach((cell) => cellsContentWidths.push(cell.calculateSizeToFit(range)));
            }
            else {
                cellsContentWidths = this.cells.map((cell) => getNodeSizeViaRange(range, cell.nativeElement));
            }
            const index = cellsContentWidths.indexOf(Math.max(...cellsContentWidths));
            const cellStyle = this.grid.document.defaultView.getComputedStyle(this.cells[index].nativeElement);
            const cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) +
                parseFloat(cellStyle.borderLeftWidth) + parseFloat(cellStyle.borderRightWidth);
            largest.set(Math.max(...cellsContentWidths), cellPadding);
        }
        if (this.headerCell) {
            const headerCellWidths = this.getHeaderCellWidths();
            largest.set(headerCellWidths.width, headerCellWidths.padding);
        }
        const largestCell = Math.max(...Array.from(largest.keys()));
        const width = Math.ceil(largestCell + largest.get(largestCell));
        if (Number.isNaN(width)) {
            return this.width;
        }
        else {
            return width + 'px';
        }
    }
    /**
     * @hidden
     */
    getCellWidth() {
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (this.columnLayoutChild) {
            return '';
        }
        if (colWidth && !isPercentageWidth) {
            let cellWidth = colWidth;
            if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
                cellWidth += 'px';
            }
            return cellWidth;
        }
        else {
            return colWidth;
        }
    }
    /**
     * @hidden
     */
    populateVisibleIndexes() { }
    getColumnSizesString(children) {
        const res = this.getFilledChildColumnSizes(children);
        return res.join(' ');
    }
    /**
     * @hidden
     * @internal
     */
    cacheCalcWidth() {
        const grid = this.gridAPI.grid;
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (isPercentageWidth) {
            this._calcWidth = parseFloat(colWidth) / 100 * grid.calcWidth;
        }
        else if (!colWidth) {
            // no width
            this._calcWidth = this.defaultWidth || grid.getPossibleColumnWidth();
        }
        else {
            this._calcWidth = this.width;
        }
        this.calcPixelWidth = parseFloat(this._calcWidth);
    }
    /**
     * @hidden
     * @internal
     */
    setExpandCollapseState() {
        this.children.filter(col => (col.visibleWhenCollapsed !== undefined)).forEach(c => {
            if (!this.collapsible) {
                c.hidden = this.hidden;
                return;
            }
            c.hidden = this._expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
        });
    }
    /**
     * @hidden
     * @internal
     */
    checkCollapsibleState() {
        if (!this.children) {
            return false;
        }
        const cols = this.children.map(child => child.visibleWhenCollapsed);
        return (cols.some(c => c === true) && cols.some(c => c === false));
    }
    /**
     * @hidden
     */
    get pinnable() {
        return this.grid._init || !this.pinned;
    }
    /**
     * @hidden
     */
    get applySelectableClass() {
        return this._applySelectableClass;
    }
    /**
     * @hidden
     */
    set applySelectableClass(value) {
        if (this.selectable) {
            this._applySelectableClass = value;
        }
    }
}
IgxColumnComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-column',
                template: ``
            },] }
];
IgxColumnComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef }
];
IgxColumnComponent.propDecorators = {
    field: [{ type: Input }],
    header: [{ type: Input }],
    title: [{ type: Input }],
    sortable: [{ type: Input }],
    selectable: [{ type: Input }],
    groupable: [{ type: Input }],
    editable: [{ type: Input }],
    filterable: [{ type: Input }],
    resizable: [{ type: Input }],
    hasSummary: [{ type: Input }],
    hidden: [{ type: Input }],
    hiddenChange: [{ type: Output }],
    expandedChange: [{ type: Output }],
    collapsibleChange: [{ type: Output }],
    visibleWhenCollapsedChange: [{ type: Output }],
    onColumnChange: [{ type: Output }],
    disableHiding: [{ type: Input }],
    disablePinning: [{ type: Input }],
    movable: [{ type: Input }],
    width: [{ type: Input }],
    maxWidth: [{ type: Input }],
    headerClasses: [{ type: Input }],
    headerGroupClasses: [{ type: Input }],
    cellClasses: [{ type: Input }],
    cellStyles: [{ type: Input }],
    formatter: [{ type: Input }],
    filteringIgnoreCase: [{ type: Input }],
    sortingIgnoreCase: [{ type: Input }],
    searchable: [{ type: Input }],
    dataType: [{ type: Input }],
    collapsibleIndicatorTemplate: [{ type: Input }],
    rowEnd: [{ type: Input }],
    colEnd: [{ type: Input }],
    rowStart: [{ type: Input }],
    colStart: [{ type: Input }],
    widthChange: [{ type: Output }],
    pinnedChange: [{ type: Output }],
    filterCellTemplateDirective: [{ type: ContentChild, args: [IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective },] }],
    cellTemplate: [{ type: ContentChild, args: [IgxCellTemplateDirective, { read: IgxCellTemplateDirective },] }],
    headTemplate: [{ type: ContentChildren, args: [IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective, descendants: false },] }],
    editorTemplate: [{ type: ContentChild, args: [IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective },] }],
    collapseIndicatorTemplate: [{ type: ContentChild, args: [IgxCollapsibleIndicatorTemplateDirective, { read: IgxCollapsibleIndicatorTemplateDirective, static: false },] }],
    minWidth: [{ type: Input }],
    pinned: [{ type: Input }],
    summaries: [{ type: Input }],
    filters: [{ type: Input }],
    sortStrategy: [{ type: Input }],
    groupingComparer: [{ type: Input }],
    bodyTemplate: [{ type: Input, args: ['cellTemplate',] }],
    headerTemplate: [{ type: Input }],
    inlineEditorTemplate: [{ type: Input, args: ['cellEditorTemplate',] }],
    filterCellTemplate: [{ type: Input, args: ['filterCellTemplate',] }],
    visibleWhenCollapsed: [{ type: Input }],
    pipeArgs: [{ type: Input }]
};
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "header", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "title", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "sortable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "selectable", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "groupable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "editable", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filterable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "resizable", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "hasSummary", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "hidden", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "disableHiding", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "disablePinning", void 0);
__decorate([
    WatchColumnChanges(),
    notifyChanges()
], IgxColumnComponent.prototype, "movable", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "width", null);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "maxWidth", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerGroupClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "cellClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "cellStyles", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "formatter", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filteringIgnoreCase", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "sortingIgnoreCase", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "searchable", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "minWidth", null);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "pinned", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "summaries", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "bodyTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "inlineEditorTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filterCellTemplate", null);
__decorate([
    notifyChanges(true)
], IgxColumnComponent.prototype, "visibleWhenCollapsed", null);

class IgxColumnGroupComponent extends IgxColumnComponent {
    constructor() {
        super(...arguments);
        this.children = new QueryList();
        /**
         * Sets/gets whether the column group is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.columnGroup.searchable;
         * ```
         * ```html
         *  <igx-column-group [searchable] = "false"></igx-column-group>
         * ```
         *
         * @memberof IgxColumnGroupComponent
         */
        this.searchable = true;
        /**
         * @hidden
         */
        this.hiddenChange = new EventEmitter();
    }
    /**
     * Set if the column group is collapsible.
     * Default value is `false`
     * ```html
     *  <igx-column-group [collapsible] = "true"></igx-column-group>
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    set collapsible(value) {
        this._collapsible = value;
        this.collapsibleChange.emit(this._collapsible);
        if (this.children && !this.hidden) {
            if (this._collapsible) {
                this.setExpandCollapseState();
            }
            else {
                this.children.forEach(child => child.hidden = false);
            }
        }
    }
    get collapsible() {
        return this._collapsible && this.checkCollapsibleState();
    }
    /**
     * Set whether the group is expanded or collapsed initially.
     * Applied only if the collapsible property is set to `true`
     * Default value is `true`
     * ```html
     *  const state = false
     *  <igx-column-group [(expand)] = "state"></igx-column-group>
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    set expanded(value) {
        this._expanded = value;
        this.expandedChange.emit(this._expanded);
        if (!this.collapsible) {
            return;
        }
        if (!this.hidden && this.children) {
            this.setExpandCollapseState();
        }
    }
    get expanded() {
        return this._expanded;
    }
    /**
     * Gets the column group `summaries`.
     * ```typescript
     * let columnGroupSummaries = this.columnGroup.summaries;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column group `summaries`.
     * ```typescript
     * this.columnGroup.summaries = IgxNumberSummaryOperand;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    set summaries(classRef) { }
    /**
     * Gets the column group `filters`.
     * ```typescript
     * let columnGroupFilters = this.columnGroup.filters;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column group `filters`.
     * ```typescript
     * this.columnGroup.filters = IgxStringFilteringOperand;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    set filters(classRef) { }
    /**
     * Returns if the column group is selectable
     * ```typescript
     * let columnGroupSelectable = this.columnGroup.selectable;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    get selectable() {
        return this.children && this.children.some(child => child.selectable);
    }
    set selectable(value) { }
    /**
     * Returns a reference to the body template.
     * ```typescript
     * let bodyTemplate = this.columnGroup.bodyTemplate;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * @hidden
     */
    set bodyTemplate(template) { }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.columnGroup.inlineEditorTemplate;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * @hidden
     */
    set inlineEditorTemplate(template) { }
    /**
     * Gets the column group cells.
     * ```typescript
     * let columnCells = this.columnGroup.cells;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    get cells() {
        return [];
    }
    /**
     * Gets whether the column group is hidden.
     * ```typescript
     * let isHidden = this.columnGroup.hidden;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    get hidden() {
        return this.allChildren.every(c => c.hidden);
    }
    /**
     * Sets the column group hidden property.
     * ```html
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     *
     * Two-way data binding
     * ```html
     * <igx-column [(hidden)] = "model.columns[0].isHidden"></igx-column>
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    set hidden(value) {
        this._hidden = value;
        this.hiddenChange.emit(this._hidden);
        if (this._hidden || !this.collapsible) {
            this.children.forEach(child => child.hidden = this._hidden);
        }
        else {
            this.children.forEach(c => {
                if (c.visibleWhenCollapsed === undefined) {
                    c.hidden = false;
                    return;
                }
                c.hidden = this.expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
            });
        }
    }
    /**
     * Returns if the column group is selected.
     * ```typescript
     * let isSelected = this.columnGroup.selected;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    get selected() {
        const selectableChildren = this.allChildren.filter(c => !c.columnGroup && c.selectable && !c.hidden);
        return selectableChildren.length > 0 && selectableChildren.every(c => c.selected);
    }
    /**
     * Select/deselect the column group.
     * ```typescript
     * this.columnGroup.selected = true;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    set selected(value) {
        if (this.selectable) {
            this.children.forEach(c => {
                c.selected = value;
            });
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        /*
            @ContentChildren with descendants still returns the `parent`
            component in the query list.
        */
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        if (this.collapseIndicatorTemplate) {
            this.collapsibleIndicatorTemplate = this.collapseIndicatorTemplate.template;
        }
        // currently only ivy fixes the issue, we have to slice only if the first child is group
        if (this.children.first === this) {
            this.children.reset(this.children.toArray().slice(1));
        }
        this.children.forEach(child => {
            child.parent = this;
        });
        if (this.collapsible) {
            this.setExpandCollapseState();
        }
    }
    /**
     * Returns the children columns collection.
     * ```typescript
     * let columns =  this.columnGroup.allChildren;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    get allChildren() {
        return flatten(this.children.toArray());
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let isColumnGroup =  this.columnGroup.columnGroup
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    get columnGroup() {
        return true;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnLayout() {
        return false;
    }
    /**
     * Gets the width of the column group.
     * ```typescript
     * let columnGroupWidth = this.columnGroup.width;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    get width() {
        const width = `${this.children.reduce((acc, val) => {
            if (val.hidden) {
                return acc;
            }
            return acc + parseInt(val.calcWidth, 10);
        }, 0)}`;
        return width + 'px';
    }
    set width(val) { }
    /**
     * @hidden
     */
    get applySelectableClass() {
        return this._applySelectableClass;
    }
    /**
     * @hidden
     */
    set applySelectableClass(value) {
        if (this.selectable) {
            this._applySelectableClass = value;
            this.children.forEach(c => {
                c.applySelectableClass = value;
            });
        }
    }
    // constructor(public gridAPI: GridBaseAPIService<IgxGridBaseDirective & IGridDataBindable>, public cdr: ChangeDetectorRef) {
    //     // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
    //     super(gridAPI, cdr);
    // }
    /**
     * @hidden
     * Calculates the number of visible columns, based on indexes of first and last visible columns.
     */
    calcChildren() {
        const visibleChildren = this.allChildren.filter(c => c.visibleIndex > -1);
        const fi = visibleChildren[0].visibleIndex;
        const li = visibleChildren[visibleChildren.length - 1].visibleIndex;
        return li - fi + 1;
    }
}
IgxColumnGroupComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: IgxColumnComponent, useExisting: forwardRef(() => IgxColumnGroupComponent) }],
                selector: 'igx-column-group',
                template: ``
            },] }
];
IgxColumnGroupComponent.propDecorators = {
    children: [{ type: ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent },] }],
    collapsible: [{ type: Input }],
    expanded: [{ type: Input }],
    summaries: [{ type: Input }],
    searchable: [{ type: Input }],
    filters: [{ type: Input }],
    collapsibleIndicatorTemplate: [{ type: Input }],
    hidden: [{ type: Input }],
    hiddenChange: [{ type: Output }]
};

/**
 * A component used for presenting Excel style column moving UI.
 */
class IgxExcelStyleMovingComponent {
    constructor(esf) {
        this.esf = esf;
        /**
         * @hidden @internal
         */
        this.defaultClass = true;
    }
    get visibleColumns() {
        return this.esf.grid.visibleColumns.filter(col => !(col instanceof IgxColumnGroupComponent));
    }
    /**
     * @hidden @internal
     */
    get canNotMoveLeft() {
        return this.esf.column.visibleIndex === 0 ||
            (this.esf.grid.unpinnedColumns.indexOf(this.esf.column) === 0 && this.esf.column.disablePinning) ||
            (this.esf.column.level !== 0 && !this.findColumn(0, this.visibleColumns));
    }
    /**
     * @hidden @internal
     */
    get canNotMoveRight() {
        return this.esf.column.visibleIndex === this.visibleColumns.length - 1 ||
            (this.esf.column.level !== 0 && !this.findColumn(1, this.visibleColumns));
    }
    /**
     * @hidden @internal
     */
    onMoveButtonClicked(moveDirection) {
        let targetColumn;
        if (this.esf.column.pinned) {
            if (this.esf.column.isLastPinned && moveDirection === 1 && this.esf.grid.isPinningToStart) {
                targetColumn = this.esf.grid.unpinnedColumns[0];
                moveDirection = 0;
            }
            else if (this.esf.column.isFirstPinned && moveDirection === 0 && !this.esf.grid.isPinningToStart) {
                targetColumn = this.esf.grid.unpinnedColumns[this.esf.grid.unpinnedColumns.length - 1];
                moveDirection = 1;
            }
            else {
                targetColumn = this.findColumn(moveDirection, this.esf.grid.pinnedColumns);
            }
        }
        else if (this.esf.grid.unpinnedColumns.indexOf(this.esf.column) === 0 && moveDirection === 0 &&
            this.esf.grid.isPinningToStart) {
            targetColumn = this.esf.grid.pinnedColumns[this.esf.grid.pinnedColumns.length - 1];
            if (targetColumn.parent) {
                targetColumn = targetColumn.topLevelParent;
            }
            moveDirection = 1;
        }
        else if (this.esf.grid.unpinnedColumns.indexOf(this.esf.column) === this.esf.grid.unpinnedColumns.length - 1 &&
            moveDirection === 1 && !this.esf.grid.isPinningToStart) {
            targetColumn = this.esf.grid.pinnedColumns[0];
            moveDirection = 0;
        }
        else {
            targetColumn = this.findColumn(moveDirection, this.esf.grid.unpinnedColumns);
        }
        this.esf.grid.moveColumn(this.esf.column, targetColumn, moveDirection);
    }
    findColumn(moveDirection, columns) {
        let index = columns.indexOf(this.esf.column);
        if (moveDirection === 0) {
            while (index > 0) {
                index--;
                if (columns[index].level === this.esf.column.level && columns[index].parent === this.esf.column.parent) {
                    return columns[index];
                }
            }
        }
        else {
            while (index < columns.length - 1) {
                index++;
                if (columns[index].level === this.esf.column.level && columns[index].parent === this.esf.column.parent) {
                    return columns[index];
                }
            }
        }
    }
}
IgxExcelStyleMovingComponent.decorators = [
    { type: Component, args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-moving',
                template: "<ng-container *ngIf=\"esf.column\">\n<header>\n    {{ esf.grid.resourceStrings.igx_grid_excel_filter_moving_header }}\n</header>\n<section class=\"igx-excel-filter__move-buttons\">\n    <button [displayDensity]=\"esf.grid.displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveLeft\"\n        (click)=\"onMoveButtonClicked(0)\">\n        <igx-icon>arrow_back</igx-icon>\n        <span>\n            {{ esf.grid.displayDensity==='compact'?\n            esf.grid.resourceStrings.igx_grid_excel_filter_moving_left_short:\n            esf.grid.resourceStrings.igx_grid_excel_filter_moving_left }}\n        </span>\n    </button>\n    <button [displayDensity]=\"esf.grid.displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveRight\"\n        (click)=\"onMoveButtonClicked(1)\">\n        <span>\n            {{ esf.grid.displayDensity==='compact'?\n            esf.grid.resourceStrings.igx_grid_excel_filter_moving_right_short:\n            esf.grid.resourceStrings.igx_grid_excel_filter_moving_right }}\n        </span>\n        <igx-icon>arrow_forwards</igx-icon>\n    </button>\n</section>\n</ng-container>\n"
            },] }
];
IgxExcelStyleMovingComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];
IgxExcelStyleMovingComponent.propDecorators = {
    defaultClass: [{ type: HostBinding, args: ['class.igx-excel-filter__move',] }]
};

/**
 * A component used for presenting Excel style column pinning UI.
 */
class IgxExcelStylePinningComponent {
    constructor(esf) {
        this.esf = esf;
    }
}
IgxExcelStylePinningComponent.decorators = [
    { type: Component, args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-pinning',
                template: "<div *ngIf=\"esf.column\"\n    [ngClass]=\"esf.column.pinned ? 'igx-excel-filter__actions-unpin' : 'igx-excel-filter__actions-pin'\"\n    (click)=\"esf.onPin()\"\n    tabindex=\"0\">\n    <span>{{ esf.column.pinned ? esf.grid.resourceStrings.igx_grid_excel_unpin : esf.grid.resourceStrings.igx_grid_excel_pin }}</span>\n    <igx-icon family=\"imx-icons\" name=\"{{ esf.column.pinned ? 'unpin-left' : 'pin-left' }}\"></igx-icon>\n</div>\n"
            },] }
];
IgxExcelStylePinningComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];

/** @hidden */
class IgxListBaseDirective extends DisplayDensityBase {
    constructor(_displayDensityOptions) {
        super(_displayDensityOptions);
        this._displayDensityOptions = _displayDensityOptions;
    }
}
IgxListBaseDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxListBase]'
            },] }
];
IgxListBaseDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
var IgxListPanState;
(function (IgxListPanState) {
    IgxListPanState[IgxListPanState["NONE"] = 0] = "NONE";
    IgxListPanState[IgxListPanState["LEFT"] = 1] = "LEFT";
    IgxListPanState[IgxListPanState["RIGHT"] = 2] = "RIGHT";
})(IgxListPanState || (IgxListPanState = {}));
class IgxEmptyListTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxEmptyListTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxEmptyList]'
            },] }
];
IgxEmptyListTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxDataLoadingTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxDataLoadingTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDataLoading]'
            },] }
];
IgxDataLoadingTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxListItemLeftPanningTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxListItemLeftPanningTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxListItemLeftPanning]'
            },] }
];
IgxListItemLeftPanningTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxListItemRightPanningTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxListItemRightPanningTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxListItemRightPanning]'
            },] }
];
IgxListItemRightPanningTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

const EVENT_SUFFIX = 'precise';
/**
 * Touch gestures manager based on Hammer.js
 * Use with caution, this will track references for single manager per element. Very TBD. Much TODO.
 *
 * @hidden
 */
class HammerGesturesManager {
    constructor(_zone, doc, platformUtil) {
        this._zone = _zone;
        this.doc = doc;
        this.platformUtil = platformUtil;
        /**
         * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.
         */
        this.hammerOptions = {};
        this._hammerManagers = [];
        this.platformBrowser = this.platformUtil.isBrowser;
        if (this.platformBrowser) {
            this.hammerOptions = {
                // D.P. #447 Force TouchInput due to PointerEventInput bug (https://github.com/hammerjs/hammer.js/issues/1065)
                // see https://github.com/IgniteUI/igniteui-angular/issues/447#issuecomment-324601803
                inputClass: Hammer.TouchInput,
                recognizers: [
                    [Hammer.Pan, { threshold: 0 }],
                    [Hammer.Swipe, { direction: Hammer.DIRECTION_HORIZONTAL }],
                    [Hammer.Tap],
                    [Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']]
                ]
            };
        }
    }
    supports(eventName) {
        return eventName.toLowerCase().endsWith('.' + EVENT_SUFFIX);
    }
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     */
    addEventListener(element, eventName, eventHandler, options = null) {
        if (!this.platformBrowser) {
            return;
        }
        // Creating the manager bind events, must be done outside of angular
        return this._zone.runOutsideAngular(() => {
            let mc = this.getManagerForElement(element);
            if (mc === null) {
                // new Hammer is a shortcut for Manager with defaults
                mc = new Hammer(element, Object.assign(this.hammerOptions, options));
                this.addManagerForElement(element, mc);
            }
            const handler = (eventObj) => this._zone.run(() => eventHandler(eventObj));
            mc.on(eventName, handler);
            return () => mc.off(eventName, handler);
        });
    }
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     *
     * @param target Can be one of either window, body or document(fallback default).
     */
    addGlobalEventListener(target, eventName, eventHandler) {
        if (!this.platformBrowser) {
            return;
        }
        const element = this.getGlobalEventTarget(target);
        // Creating the manager bind events, must be done outside of angular
        return this.addEventListener(element, eventName, eventHandler);
    }
    /**
     * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.
     * Supported: window, document, body. Defaults to document for invalid args.
     *
     * @param target Target name
     */
    getGlobalEventTarget(target) {
        return ɵgetDOM().getGlobalEventTarget(this.doc, target);
    }
    /**
     * Set HammerManager options.
     *
     * @param element The DOM element used to create the manager on.
     *
     * ### Example
     *
     * ```ts
     * manager.setManagerOption(myElem, "pan", { pointers: 1 });
     * ```
     */
    setManagerOption(element, event, options) {
        const manager = this.getManagerForElement(element);
        manager.get(event).set(options);
    }
    /**
     * Add an element and manager map to the internal collection.
     *
     * @param element The DOM element used to create the manager on.
     */
    addManagerForElement(element, manager) {
        this._hammerManagers.push({ element, manager });
    }
    /**
     * Get HammerManager for the element or null
     *
     * @param element The DOM element used to create the manager on.
     */
    getManagerForElement(element) {
        const result = this._hammerManagers.filter((value, index, array) => value.element === element);
        return result.length ? result[0].manager : null;
    }
    /**
     * Destroys the HammerManager for the element, removing event listeners in the process.
     *
     * @param element The DOM element used to create the manager on.
     */
    removeManagerForElement(element) {
        let index = null;
        for (let i = 0; i < this._hammerManagers.length; i++) {
            if (element === this._hammerManagers[i].element) {
                index = i;
                break;
            }
        }
        if (index !== null) {
            const item = this._hammerManagers.splice(index, 1)[0];
            // destroy also
            item.manager.destroy();
        }
    }
    /** Destroys all internally tracked HammerManagers, removing event listeners in the process. */
    destroy() {
        for (const item of this._hammerManagers) {
            item.manager.destroy();
        }
        this._hammerManagers = [];
    }
}
HammerGesturesManager.decorators = [
    { type: Injectable }
];
HammerGesturesManager.ctorParameters = () => [
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: PlatformUtil }
];

/**
 * The Ignite UI List Item component is a container intended for row items in the Ignite UI for Angular List component.
 *
 * Example:
 * ```html
 * <igx-list>
 *   <igx-list-item isHeader="true">Contacts</igx-list-item>
 *   <igx-list-item *ngFor="let contact of contacts">
 *     <span class="name">{{ contact.name }}</span>
 *     <span class="phone">{{ contact.phone }}</span>
 *   </igx-list-item>
 * </igx-list>
 * ```
 */
class IgxListItemComponent {
    constructor(list, elementRef, _renderer) {
        this.list = list;
        this.elementRef = elementRef;
        this._renderer = _renderer;
        /**
         * Sets/gets whether the `list item` is hidden.
         * By default the `hidden` value is `false`.
         * ```html
         * <igx-list-item [hidden] = "true">Hidden Item</igx-list-item>
         * ```
         * ```typescript
         * let isHidden =  this.listItem.hidden;
         * ```
         *
         * @memberof IgxListItemComponent
         */
        this.hidden = false;
        /**
         * Gets the `touch-action` style of the `list item`.
         * ```typescript
         * let touchAction = this.listItem.touchAction;
         * ```
         */
        this.touchAction = 'pan-y';
        /**
         * @hidden
         */
        this._panState = IgxListPanState.NONE;
        /**
         * @hidden
         */
        this.panOffset = 0;
        /**
         * @hidden
         */
        this._index = null;
        /**
         * @hidden
         */
        this.lastPanDir = IgxListPanState.NONE;
    }
    /**
     * Gets the `panState` of a `list item`.
     * ```typescript
     * let itemPanState =  this.listItem.panState;
     * ```
     *
     * @memberof IgxListItemComponent
     */
    get panState() {
        return this._panState;
    }
    /**
     * Gets the `index` of a `list item`.
     * ```typescript
     * let itemIndex =  this.listItem.index;
     * ```
     *
     * @memberof IgxListItemComponent
     */
    get index() {
        return this._index !== null ? this._index : this.list.children.toArray().indexOf(this);
    }
    /**
     * Sets the `index` of the `list item`.
     * ```typescript
     * this.listItem.index = index;
     * ```
     *
     * @memberof IgxListItemComponent
     */
    set index(value) {
        this._index = value;
    }
    /**
     * Returns an element reference to the list item.
     * ```typescript
     * let listItemElement =  this.listItem.element.
     * ```
     *
     * @memberof IgxListItemComponent
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * Returns a reference container which contains the list item's content.
     * ```typescript
     * let listItemContainer =  this.listItem.contentElement.
     * ```
     *
     * @memberof IgxListItemComponent
     */
    get contentElement() {
        const candidates = this.element.getElementsByClassName('igx-list__item-content');
        return (candidates && candidates.length > 0) ? candidates[0] : null;
    }
    /**
     * Returns the `context` object which represents the `template context` binding into the `list item container`
     * by providing the `$implicit` declaration which is the `IgxListItemComponent` itself.
     * ```typescript
     * let listItemComponent = this.listItem.context;
     * ```
     */
    get context() {
        return {
            $implicit: this
        };
    }
    /**
     * Gets the width of a `list item`.
     * ```typescript
     * let itemWidth = this.listItem.width;
     * ```
     *
     * @memberof IgxListItemComponent
     */
    get width() {
        if (this.element) {
            return this.element.offsetWidth;
        }
    }
    /**
     * Gets the maximum left position of the `list item`.
     * ```typescript
     * let maxLeft = this.listItem.maxLeft;
     * ```
     *
     * @memberof IgxListItemComponent
     */
    get maxLeft() {
        return -this.width;
    }
    /**
     * Gets the maximum right position of the `list item`.
     * ```typescript
     * let maxRight = this.listItem.maxRight;
     * ```
     *
     * @memberof IgxListItemComponent
     */
    get maxRight() {
        return this.width;
    }
    /**
     * Gets the `role` attribute of the `list item`.
     * ```typescript
     * let itemRole =  this.listItem.role;
     * ```
     *
     * @memberof IgxListItemComponent
     */
    get role() {
        return this.isHeader ? 'separator' : 'listitem';
    }
    /**
     * Indicates whether `list item` should have header style.
     * ```typescript
     * let headerStyle =  this.listItem.headerStyle;
     * ```
     *
     * @memberof IgxListItemComponent
     */
    get headerStyle() {
        return this.isHeader;
    }
    /**
     * Applies the inner style of the `list item` if the item is not counted as header.
     * ```typescript
     * let innerStyle =  this.listItem.innerStyle;
     * ```
     *
     * @memberof IgxListItemComponent
     */
    get innerStyle() {
        return !this.isHeader;
    }
    /**
     * Returns string value which describes the display mode of the `list item`.
     * ```typescript
     * let isHidden = this.listItem.display;
     * ```
     *
     * @memberof IgxListItemComponent
     */
    get display() {
        return this.hidden ? 'none' : '';
    }
    /**
     * @hidden
     */
    clicked(evt) {
        this.list.itemClicked.emit({ item: this, event: evt, direction: this.lastPanDir });
        this.lastPanDir = IgxListPanState.NONE;
    }
    /**
     * @hidden
     */
    panStart() {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
    }
    /**
     * @hidden
     */
    panMove(ev) {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
        const isPanningToLeft = ev.deltaX < 0;
        if (isPanningToLeft && this.isTrue(this.list.allowLeftPanning)) {
            this.showLeftPanTemplate();
            this.setContentElementLeft(Math.max(this.maxLeft, ev.deltaX));
        }
        else if (!isPanningToLeft && this.isTrue(this.list.allowRightPanning)) {
            this.showRightPanTemplate();
            this.setContentElementLeft(Math.min(this.maxRight, ev.deltaX));
        }
    }
    /**
     * @hidden
     */
    panEnd() {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
        // the translation offset of the current list item content
        const relativeOffset = this.panOffset;
        const widthTriggeringGrip = this.width * this.list.panEndTriggeringThreshold;
        if (relativeOffset === 0) {
            return; // no panning has occured
        }
        const dir = relativeOffset > 0 ? IgxListPanState.RIGHT : IgxListPanState.LEFT;
        this.lastPanDir = dir;
        const oldPanState = this._panState;
        if (Math.abs(relativeOffset) < widthTriggeringGrip) {
            this.setContentElementLeft(0);
            this._panState = IgxListPanState.NONE;
            this.hideLeftAndRightPanTemplates();
            return;
        }
        const args = { item: this, direction: dir, keepItem: false };
        if (dir === IgxListPanState.LEFT) {
            this.list.leftPan.emit(args);
        }
        else {
            this.list.rightPan.emit(args);
        }
        if (args.keepItem === true) {
            this.setContentElementLeft(0);
            this._panState = IgxListPanState.NONE;
        }
        else {
            if (dir === IgxListPanState.LEFT) {
                this.setContentElementLeft(this.maxLeft);
                this._panState = IgxListPanState.LEFT;
            }
            else {
                this.setContentElementLeft(this.maxRight);
                this._panState = IgxListPanState.RIGHT;
            }
        }
        if (oldPanState !== this._panState) {
            const args2 = { oldState: oldPanState, newState: this._panState, item: this };
            this.list.panStateChange.emit(args2);
        }
        this.hideLeftAndRightPanTemplates();
    }
    /**
     * @hidden
     */
    showLeftPanTemplate() {
        this.setLeftAndRightTemplatesVisibility('visible', 'hidden');
    }
    /**
     * @hidden
     */
    showRightPanTemplate() {
        this.setLeftAndRightTemplatesVisibility('hidden', 'visible');
    }
    /**
     * @hidden
     */
    hideLeftAndRightPanTemplates() {
        setTimeout(() => {
            this.setLeftAndRightTemplatesVisibility('hidden', 'hidden');
        }, 500);
    }
    /**
     * @hidden
     */
    setLeftAndRightTemplatesVisibility(leftVisibility, rightVisibility) {
        if (this.leftPanningTemplateElement && this.leftPanningTemplateElement.nativeElement) {
            this.leftPanningTemplateElement.nativeElement.style.visibility = leftVisibility;
        }
        if (this.rightPanningTemplateElement && this.rightPanningTemplateElement.nativeElement) {
            this.rightPanningTemplateElement.nativeElement.style.visibility = rightVisibility;
        }
    }
    /**
     * @hidden
     */
    setContentElementLeft(value) {
        this.panOffset = value;
        this.contentElement.style.transform = 'translateX(' + value + 'px)';
    }
    /**
     * @hidden
     */
    isTrue(value) {
        if (typeof (value) === 'boolean') {
            return value;
        }
        else {
            return value === 'true';
        }
    }
}
IgxListItemComponent.decorators = [
    { type: Component, args: [{
                providers: [HammerGesturesManager],
                selector: 'igx-list-item',
                template: "   \n<div *ngIf=\"!isHeader && list.listItemLeftPanningTemplate != null\" #leftPanningTmpl class=\"igx-list__item-right\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemLeftPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<div *ngIf=\"!isHeader && list.listItemRightPanningTemplate != null\" #rightPanningTmpl class=\"igx-list__item-left\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemRightPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<ng-template #itemsContent>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #itemThumbnails>\n    <div class=\"igx-list__item-thumbnail\">\n        <ng-content select=\"[igxListThumbnail], igx-list__item-thumbnail, igx-avatar\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemLines>\n    <div class=\"igx-list__item-lines\">\n        <ng-content select=\"[igxListLine], .igx-list__item-lines, [igxListLineTitle], [igxListLineSubTitle], .igx-list__item-line-title, .igx-list__item-line-subtitle\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemActions>\n    <div class=\"igx-list__item-actions\">\n        <ng-content select=\"[igxListAction], .igx-list__item-actions\"></ng-content>\n    </div>\n</ng-template>\n\n    \n<ng-container *ngIf=\"isHeader\">\n    <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n</ng-container>\n\n<ng-container *ngIf=\"!isHeader\">\n    <div class=\"igx-list__item-content\">\n        <ng-container *ngTemplateOutlet=\"itemThumbnails\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemLines\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemActions\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n    </div>\n</ng-container>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
IgxListItemComponent.ctorParameters = () => [
    { type: IgxListBaseDirective },
    { type: ElementRef },
    { type: Renderer2 }
];
IgxListItemComponent.propDecorators = {
    leftPanningTemplateElement: [{ type: ViewChild, args: ['leftPanningTmpl',] }],
    rightPanningTemplateElement: [{ type: ViewChild, args: ['rightPanningTmpl',] }],
    isHeader: [{ type: Input }],
    hidden: [{ type: Input }],
    ariaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],
    touchAction: [{ type: HostBinding, args: ['style.touch-action',] }],
    index: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    headerStyle: [{ type: HostBinding, args: ['class.igx-list__header',] }],
    innerStyle: [{ type: HostBinding, args: ['class.igx-list__item-base',] }],
    display: [{ type: HostBinding, args: ['style.display',] }],
    clicked: [{ type: HostListener, args: ['click', ['$event'],] }],
    panStart: [{ type: HostListener, args: ['panstart',] }],
    panMove: [{ type: HostListener, args: ['panmove', ['$event'],] }],
    panEnd: [{ type: HostListener, args: ['panend',] }]
};

let NEXT_ID$i = 0;
/**
 * igxListThumbnail is container for the List media
 * Use it to wrap anything you want to be used as a thumbnail.
 */
class IgxListThumbnailDirective {
}
IgxListThumbnailDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[igxListThumbnail]'
            },] }
];
/**
 * igxListAction is container for the List action
 * Use it to wrap anything you want to be used as a list action: icon, checkbox...
 */
class IgxListActionDirective {
}
IgxListActionDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[igxListAction]'
            },] }
];
/**
 * igxListLine is container for the List text content
 * Use it to wrap anything you want to be used as a plane text.
 */
class IgxListLineDirective {
}
IgxListLineDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[igxListLine]'
            },] }
];
/**
 * igxListLineTitle is a directive that add class to the target element
 * Use it to make anything to look like list Title.
 */
class IgxListLineTitleDirective {
    constructor() {
        this.cssClass = 'igx-list__item-line-title';
    }
}
IgxListLineTitleDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[igxListLineTitle]'
            },] }
];
IgxListLineTitleDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-list__item-line-title',] }]
};
/**
 * igxListLineSubTitle is a directive that add class to the target element
 * Use it to make anything to look like list Subtitle.
 */
class IgxListLineSubTitleDirective {
    constructor() {
        this.cssClass = 'igx-list__item-line-subtitle';
    }
}
IgxListLineSubTitleDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[igxListLineSubTitle]'
            },] }
];
IgxListLineSubTitleDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-list__item-line-subtitle',] }]
};
/**
 * Displays a collection of data items in a templatable list format
 *
 * @igxModule IgxListModule
 *
 * @igxTheme igx-list-theme
 *
 * @igxKeywords list, data
 *
 * @igxGroup Grids & Lists
 *
 * @remarks
 * The Ignite UI List displays rows of items and supports one or more header items as well as search and filtering
 * of list items. Each list item is completely templatable and will support any valid HTML or Angular component.
 *
 * @example
 * ```html
 * <igx-list>
 *   <igx-list-item isHeader="true">Contacts</igx-list-item>
 *   <igx-list-item *ngFor="let contact of contacts">
 *     <span class="name">{{ contact.name }}</span>
 *     <span class="phone">{{ contact.phone }}</span>
 *   </igx-list-item>
 * </igx-list>
 * ```
 */
class IgxListComponent extends IgxListBaseDirective {
    constructor(element, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.element = element;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * Provides a threshold after which the item's panning will be completed automatically.
         *
         * @remarks
         * By default this property is set to 0.5 which is 50% of the list item's width.
         *
         * @example
         * ```html
         * <igx-list [panEndTriggeringThreshold]="0.8"></igx-list>
         * ```
         */
        this.panEndTriggeringThreshold = 0.5;
        /**
         * Sets/gets the `id` of the list.
         *
         * @remarks
         * If not set, the `id` of the first list component will be `"igx-list-0"`.
         *
         * @example
         * ```html
         * <igx-list id="my-first-list"></igx-list>
         * ```
         * ```typescript
         * let listId = this.list.id;
         * ```
         */
        this.id = `igx-list-${NEXT_ID$i++}`;
        /**
         * Sets/gets whether the left panning of an item is allowed.
         *
         * @remarks
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-list [allowLeftPanning]="true"></igx-list>
         * ```
         * ```typescript
         * let isLeftPanningAllowed = this.list.allowLeftPanning;
         * ```
         */
        this.allowLeftPanning = false;
        /**
         * Sets/gets whether the right panning of an item is allowed.
         *
         * @remarks
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-list [allowRightPanning]="true"></igx-list>
         * ```
         * ```typescript
         * let isRightPanningAllowed = this.list.allowRightPanning;
         * ```
         */
        this.allowRightPanning = false;
        /**
         * Sets/gets whether the list is currently loading data.
         *
         * @remarks
         * Set it to display the dataLoadingTemplate while data is being retrieved.
         * Default value is `false`.
         *
         * @example
         * ```html
         *  <igx-list [isLoading]="true"></igx-list>
         * ```
         * ```typescript
         * let isLoading = this.list.isLoading;
         * ```
         */
        this.isLoading = false;
        /**
         * Event emitted when a left pan gesture is executed on a list item.
         *
         * @remarks
         * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
         *
         * @example
         * ```html
         * <igx-list [allowLeftPanning]="true" (leftPan)="leftPan($event)"></igx-list>
         * ```
         */
        this.leftPan = new EventEmitter();
        /**
         * Event emitted when a right pan gesture is executed on a list item.
         *
         * @remarks
         * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
         *
         * @example
         * ```html
         * <igx-list [allowRightPanning]="true" (rightPan)="rightPan($event)"></igx-list>
         * ```
         */
        this.rightPan = new EventEmitter();
        /**
         *
         * Event emitted when a pan gesture is executed on a list item.
         *
         * @remarks
         * Provides references to the `IgxListItemComponent` and `IgxListPanState` as event arguments.
         *
         * @example
         * ```html
         * <igx-list (panStateChange)="panStateChange($event)"></igx-list>
         * ```
         */
        this.panStateChange = new EventEmitter();
        /**
         * Event emitted when a list item is clicked.
         *
         * @remarks
         * Provides references to the `IgxListItemComponent` and `Event` as event arguments.
         *
         * @example
         * ```html
         * <igx-list (itemClicked)="onItemClicked($event)"></igx-list>
         * ```
         */
        this.itemClicked = new EventEmitter();
        this._resourceStrings = CurrentResourceStrings.ListResStrings;
    }
    /**
     * Sets the resource strings.
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * Returns the resource strings.
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /**
     * @hidden
     * @internal
     */
    get sortedChildren() {
        if (this.children !== undefined) {
            return this.children.toArray()
                .sort((a, b) => a.index - b.index);
        }
        return null;
    }
    /**
     * Gets the `role` attribute value.
     *
     * @example
     * ```typescript
     * let listRole =  this.list.role;
     * ```
     */
    get role() {
        return 'list';
    }
    /**
     * Gets a boolean indicating if the list is empty.
     *
     * @example
     * ```typescript
     * let isEmpty =  this.list.isListEmpty;
     * ```
     */
    get isListEmpty() {
        return !this.children || this.children.length === 0;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClass() {
        return !this.isListEmpty && this.displayDensity === DisplayDensity.comfortable;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCompact() {
        return !this.isListEmpty && this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCosy() {
        return !this.isListEmpty && this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * Gets the list `items` excluding the header ones.
     *
     * @example
     * ```typescript
     * let listItems: IgxListItemComponent[] = this.list.items;
     * ```
     */
    get items() {
        const items = [];
        if (this.children !== undefined) {
            for (const child of this.sortedChildren) {
                if (!child.isHeader) {
                    items.push(child);
                }
            }
        }
        return items;
    }
    /**
     * Gets the header list `items`.
     *
     * @example
     * ```typescript
     * let listHeaders: IgxListItemComponent[] =  this.list.headers;
     * ```
     */
    get headers() {
        const headers = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (child.isHeader) {
                    headers.push(child);
                }
            }
        }
        return headers;
    }
    /**
     * Gets the `context` object of the template binding.
     *
     * @remark
     * Gets the `context` object which represents the `template context` binding into the `list container`
     * by providing the `$implicit` declaration which is the `IgxListComponent` itself.
     *
     * @example
     * ```typescript
     * let listComponent =  this.list.context;
     * ```
     */
    get context() {
        return {
            $implicit: this
        };
    }
    /**
     * Gets a `TemplateRef` to the currently used template.
     *
     * @example
     * ```typescript
     * let listTemplate = this.list.template;
     * ```
     */
    get template() {
        if (this.isLoading) {
            return this.dataLoadingTemplate ? this.dataLoadingTemplate.template : this.defaultDataLoadingTemplate;
        }
        else {
            return this.emptyListTemplate ? this.emptyListTemplate.template : this.defaultEmptyListTemplate;
        }
    }
}
IgxListComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-list',
                template: "<ng-content></ng-content>\n\n<ng-template #defaultEmptyList>\n    <article class=\"igx-list__message\">\n        {{resourceStrings.igx_list_no_items}}\n    </article>\n</ng-template>\n\n<ng-template #defaultDataLoading>\n    <article class=\"igx-list__message\">\n        {{resourceStrings.igx_list_loading}}\n    </article>\n</ng-template>\n\n<ng-container *ngIf=\"!children || children.length === 0 || isLoading\">\n    <ng-container *ngTemplateOutlet=\"template; context: context\">\n    </ng-container>\n</ng-container>\n",
                providers: [{ provide: IgxListBaseDirective, useExisting: IgxListComponent }]
            },] }
];
IgxListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxListComponent.propDecorators = {
    children: [{ type: ContentChildren, args: [forwardRef(() => IgxListItemComponent), { descendants: true },] }],
    emptyListTemplate: [{ type: ContentChild, args: [IgxEmptyListTemplateDirective, { read: IgxEmptyListTemplateDirective },] }],
    dataLoadingTemplate: [{ type: ContentChild, args: [IgxDataLoadingTemplateDirective, { read: IgxDataLoadingTemplateDirective },] }],
    listItemLeftPanningTemplate: [{ type: ContentChild, args: [IgxListItemLeftPanningTemplateDirective, { read: IgxListItemLeftPanningTemplateDirective },] }],
    listItemRightPanningTemplate: [{ type: ContentChild, args: [IgxListItemRightPanningTemplateDirective, { read: IgxListItemRightPanningTemplateDirective },] }],
    panEndTriggeringThreshold: [{ type: Input }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    allowLeftPanning: [{ type: Input }],
    allowRightPanning: [{ type: Input }],
    isLoading: [{ type: Input }],
    leftPan: [{ type: Output }],
    rightPan: [{ type: Output }],
    panStateChange: [{ type: Output }],
    itemClicked: [{ type: Output }],
    defaultEmptyListTemplate: [{ type: ViewChild, args: ['defaultEmptyList', { read: TemplateRef, static: true },] }],
    defaultDataLoadingTemplate: [{ type: ViewChild, args: ['defaultDataLoading', { read: TemplateRef, static: true },] }],
    resourceStrings: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    isListEmpty: [{ type: HostBinding, args: ['class.igx-list--empty',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-list',] }],
    cssClassCompact: [{ type: HostBinding, args: ['class.igx-list--compact',] }],
    cssClassCosy: [{ type: HostBinding, args: ['class.igx-list--cosy',] }]
};
/**
 * @hidden
 */
class IgxListModule {
}
IgxListModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxListBaseDirective,
                    IgxListComponent,
                    IgxListItemComponent,
                    IgxListThumbnailDirective,
                    IgxListActionDirective,
                    IgxListLineDirective,
                    IgxListLineTitleDirective,
                    IgxListLineSubTitleDirective,
                    IgxDataLoadingTemplateDirective,
                    IgxEmptyListTemplateDirective,
                    IgxListItemLeftPanningTemplateDirective,
                    IgxListItemRightPanningTemplateDirective
                ],
                exports: [
                    IgxListComponent,
                    IgxListItemComponent,
                    IgxListThumbnailDirective,
                    IgxListActionDirective,
                    IgxListLineDirective,
                    IgxListLineTitleDirective,
                    IgxListLineSubTitleDirective,
                    IgxDataLoadingTemplateDirective,
                    IgxEmptyListTemplateDirective,
                    IgxListItemLeftPanningTemplateDirective,
                    IgxListItemRightPanningTemplateDirective
                ],
                imports: [
                    CommonModule,
                    IgxRippleModule
                ]
            },] }
];

class IgxExcelStyleLoadingValuesTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxExcelStyleLoadingValuesTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxExcelStyleLoading]'
            },] }
];
IgxExcelStyleLoadingValuesTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * A component used for presenting Excel style search UI.
 */
class IgxExcelStyleSearchComponent {
    constructor(cdr, esf) {
        this.cdr = cdr;
        this.esf = esf;
        /**
         * @hidden @internal
         */
        this.defaultClass = true;
        this.destroy$ = new Subject();
        esf.loadingStart.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.displayedListData = [];
            this.isLoading = true;
        });
        esf.loadingEnd.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.isLoading = false;
            this.refreshSize();
        });
        esf.initialized.pipe(takeUntil(this.destroy$)).subscribe(() => {
            requestAnimationFrame(() => {
                this.searchInput.nativeElement.focus();
            });
        });
        esf.columnChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.virtDir.resetScrollPosition();
        });
        esf.listDataLoaded.pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (this.searchValue) {
                this.clearInput();
            }
            else {
                this.filterListData();
            }
            this.cdr.detectChanges();
        });
    }
    /**
     * @hidden @internal
     */
    get addToCurrentFilter() {
        if (!this._addToCurrentFilter) {
            const addToCurrentFilterItem = {
                isSelected: false,
                isFiltered: false,
                indeterminate: false,
                isSpecial: true,
                isBlanks: false,
                value: this.esf.grid.resourceStrings.igx_grid_excel_add_to_filter,
                label: this.esf.grid.resourceStrings.igx_grid_excel_add_to_filter
            };
            this._addToCurrentFilter = addToCurrentFilterItem;
        }
        return this._addToCurrentFilter;
    }
    /**
     * @hidden @internal
     */
    get isLoading() {
        return this._isLoading;
    }
    /**
     * @hidden @internal
     */
    set isLoading(value) {
        this._isLoading = value;
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
    /**
     * @hidden @internal
     */
    get valuesLoadingTemplate() {
        var _a;
        if ((_a = this.esf.grid) === null || _a === void 0 ? void 0 : _a.excelStyleLoadingValuesTemplateDirective) {
            return this.esf.grid.excelStyleLoadingValuesTemplateDirective.template;
        }
        else {
            return this.defaultExcelStyleLoadingValuesTemplate;
        }
    }
    ngAfterViewInit() {
        this.refreshSize();
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden @internal
     */
    refreshSize() {
        requestAnimationFrame(() => {
            var _a;
            (_a = this.virtDir) === null || _a === void 0 ? void 0 : _a.recalcUpdateSizes();
        });
    }
    /**
     * @hidden @internal
     */
    clearInput() {
        this.searchValue = null;
        this.filterListData();
    }
    /**
     * @hidden @internal
     */
    onCheckboxChange(eventArgs) {
        const selectedIndex = this.displayedListData.indexOf(eventArgs.checkbox.value);
        const selectAllBtn = this.displayedListData[0];
        if (selectedIndex === 0) {
            this.displayedListData.forEach(element => {
                if (element === this.addToCurrentFilter) {
                    return;
                }
                element.isSelected = eventArgs.checked;
            });
            selectAllBtn.indeterminate = false;
        }
        else {
            eventArgs.checkbox.value.isSelected = eventArgs.checked;
            const indexToStartSlicing = this.displayedListData.indexOf(this.addToCurrentFilter) > -1 ? 2 : 1;
            const slicedArray = this.displayedListData.slice(indexToStartSlicing, this.displayedListData.length);
            if (!slicedArray.find(el => el.isSelected === false)) {
                selectAllBtn.indeterminate = false;
                selectAllBtn.isSelected = true;
            }
            else if (!slicedArray.find(el => el.isSelected === true)) {
                selectAllBtn.indeterminate = false;
                selectAllBtn.isSelected = false;
            }
            else {
                selectAllBtn.indeterminate = true;
            }
        }
        eventArgs.checkbox.nativeCheckbox.nativeElement.blur();
    }
    /**
     * @hidden @internal
     */
    get itemSize() {
        let itemSize = '40px';
        switch (this.esf.displayDensity) {
            case DisplayDensity.cosy:
                itemSize = '32px';
                break;
            case DisplayDensity.compact:
                itemSize = '24px';
                break;
            default: break;
        }
        return itemSize;
    }
    /**
     * @hidden @internal
     */
    get type() {
        var _a;
        switch ((_a = this.esf.column) === null || _a === void 0 ? void 0 : _a.dataType) {
            case DataType.Number:
            case DataType.Currency:
            case DataType.Percent:
                return 'number';
            default:
                return 'text';
        }
    }
    /**
     * @hidden @internal
     */
    get containerSize() {
        if (this.list) {
            return this.list.element.nativeElement.offsetHeight;
        }
    }
    /**
     * @hidden @internal
     */
    get applyButtonDisabled() {
        return this.esf.listData[0] && !this.esf.listData[0].isSelected && !this.esf.listData[0].indeterminate ||
            this.displayedListData && this.displayedListData.length === 0;
    }
    /**
     * @hidden @internal
     */
    onInputKeyDown(event) {
        switch (event.key) {
            case "Enter" /* ENTER */:
                event.preventDefault();
                this.applyFilter();
                return;
            case "Escape" /* ESCAPE */ || "Esc" /* ESCAPE_IE */:
                if (this.searchValue) {
                    event.stopPropagation();
                    this.clearInput();
                }
                return;
        }
    }
    /**
     * @hidden @internal
     */
    filterListData() {
        if (!this.esf.listData || !this.esf.listData.length) {
            this.displayedListData = [];
            return;
        }
        const searchAllBtn = this.esf.listData[0];
        if (!this.searchValue) {
            const anyFiltered = this.esf.listData.some(i => i.isFiltered);
            const anyUnfiltered = this.esf.listData.some(i => !i.isFiltered);
            if (anyFiltered && anyUnfiltered) {
                searchAllBtn.indeterminate = true;
            }
            this.esf.listData.forEach(i => i.isSelected = i.isFiltered);
            this.displayedListData = this.esf.listData;
            searchAllBtn.label = this.esf.grid.resourceStrings.igx_grid_excel_select_all;
            return;
        }
        const searchVal = this.searchValue.toLowerCase();
        this.displayedListData = this.esf.listData.filter((it, i) => (i === 0 && it.isSpecial) ||
            (it.label !== null && it.label !== undefined) &&
                !it.isBlanks &&
                it.label.toString().toLowerCase().indexOf(searchVal) > -1);
        this.esf.listData.forEach(i => i.isSelected = false);
        this.displayedListData.forEach(i => i.isSelected = true);
        this.displayedListData.splice(1, 0, this.addToCurrentFilter);
        searchAllBtn.indeterminate = false;
        searchAllBtn.label = this.esf.grid.resourceStrings.igx_grid_excel_select_all_search_results;
        if (this.displayedListData.length === 2) {
            this.displayedListData = [];
        }
    }
    /**
     * @hidden @internal
     */
    applyFilter() {
        const filterTree = new FilteringExpressionsTree(FilteringLogic.Or, this.esf.column.field);
        const item = this.displayedListData[1];
        const addToCurrentFilterOptionVisible = item === this.addToCurrentFilter;
        const selectedItems = addToCurrentFilterOptionVisible && item.isSelected ?
            this.esf.listData.slice(1, this.esf.listData.length).filter(el => el.isSelected || el.isFiltered) :
            this.esf.listData.slice(1, this.esf.listData.length).filter(el => el.isSelected);
        const unselectedItem = this.esf.listData.slice(1, this.esf.listData.length).find(el => el.isSelected === false);
        if (unselectedItem) {
            if (selectedItems.length <= IgxExcelStyleSearchComponent.filterOptimizationThreshold) {
                selectedItems.forEach(element => {
                    let condition = null;
                    if (element.value !== null && element.value !== undefined) {
                        if (this.esf.column.dataType === DataType.Boolean) {
                            condition = this.createCondition(element.value.toString());
                        }
                        else {
                            condition = this.createCondition('equals');
                        }
                    }
                    else {
                        condition = this.createCondition('empty');
                    }
                    filterTree.filteringOperands.push({
                        condition,
                        fieldName: this.esf.column.field,
                        ignoreCase: this.esf.column.filteringIgnoreCase,
                        searchVal: element.value
                    });
                });
            }
            else {
                const blanksItemIndex = selectedItems.findIndex(e => e.value === null || e.value === undefined);
                let blanksItem;
                if (blanksItemIndex >= 0) {
                    blanksItem = selectedItems[blanksItemIndex];
                    selectedItems.splice(blanksItemIndex, 1);
                }
                filterTree.filteringOperands.push({
                    condition: this.createCondition('in'),
                    fieldName: this.esf.column.field,
                    ignoreCase: this.esf.column.filteringIgnoreCase,
                    searchVal: new Set(this.esf.column.dataType === DataType.Date ?
                        selectedItems.map(d => d.value.toISOString()) :
                        selectedItems.map(e => e.value))
                });
                if (blanksItem) {
                    filterTree.filteringOperands.push({
                        condition: this.createCondition('empty'),
                        fieldName: this.esf.column.field,
                        ignoreCase: this.esf.column.filteringIgnoreCase,
                        searchVal: blanksItem.value
                    });
                }
            }
            this.esf.grid.filteringService.filterInternal(this.esf.column.field, filterTree);
            this.esf.expressionsList = new Array();
            this.esf.grid.filteringService.generateExpressionsList(this.esf.column.filteringExpressionsTree, this.esf.grid.filteringLogic, this.esf.expressionsList);
        }
        else {
            this.esf.grid.filteringService.clearFilter(this.esf.column.field);
        }
        this.esf.closeDropdown();
    }
    createCondition(conditionName) {
        switch (this.esf.column.dataType) {
            case DataType.Boolean:
                return IgxBooleanFilteringOperand.instance().condition(conditionName);
            case DataType.Number:
            case DataType.Currency:
            case DataType.Percent:
                return IgxNumberFilteringOperand.instance().condition(conditionName);
            case DataType.Date:
                return IgxDateFilteringOperand.instance().condition(conditionName);
            default:
                return IgxStringFilteringOperand.instance().condition(conditionName);
        }
    }
}
IgxExcelStyleSearchComponent.filterOptimizationThreshold = 2;
IgxExcelStyleSearchComponent.decorators = [
    { type: Component, args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-search',
                template: "<igx-input-group\n            type=\"box\"\n            [displayDensity]=\"esf.displayDensity\">\n    <igx-icon igxPrefix>search</igx-icon>\n    <input\n        #input\n        igxInput\n        tabindex=\"0\"\n        [(ngModel)]=\"searchValue\"\n        (ngModelChange)=\"filterListData()\"\n        (keydown)=\"onInputKeyDown($event)\"\n        [placeholder]=\"esf.column?.grid.resourceStrings.igx_grid_excel_search_placeholder\"\n        [type]=\"type\"\n        autocomplete=\"off\"/>\n    <igx-icon\n        igxSuffix\n        *ngIf=\"searchValue || searchValue === 0\"\n        (click)=\"clearInput()\"\n        tabindex=\"0\">\n        clear\n    </igx-icon>\n</igx-input-group>\n\n<igx-list #list [displayDensity]=\"esf.displayDensity\" [isLoading]=\"isLoading\">\n    <div [style.overflow]=\"'hidden'\" [style.position]=\"'relative'\">\n        <igx-list-item\n        *igxFor=\"let item of displayedListData scrollOrientation : 'vertical'; containerSize: containerSize; itemSize: itemSize\">\n            <igx-checkbox\n            [value]=\"item\"\n            tabindex=\"-1\"\n            [checked]=\"item.isSelected\"\n            [disableRipple]=\"true\"\n            [indeterminate]=\"item.indeterminate\"\n            [disableTransitions]=\"true\"\n            (change)=\"onCheckboxChange($event)\">\n                {{ item.label }}\n            </igx-checkbox>\n        </igx-list-item>\n    </div>\n\n    <ng-template igxDataLoading>\n        <div class=\"igx-excel-filter__loading\">\n            <ng-container *ngTemplateOutlet=\"valuesLoadingTemplate\">\n            </ng-container>\n        </div>\n    </ng-template>\n</igx-list>\n\n<ng-template #defaultExcelStyleLoadingValuesTemplate>\n    <igx-circular-bar [indeterminate]=\"true\">\n    </igx-circular-bar>\n</ng-template>\n\n<footer class=\"igx-excel-filter__menu-footer\">\n    <button igxButton [displayDensity]=\"esf.displayDensity\" (click)=\"esf.cancel()\">{{ esf.grid?.resourceStrings.igx_grid_excel_cancel }}</button>\n    <button igxButton=\"raised\" [displayDensity]=\"esf.displayDensity\" [disabled]=\"applyButtonDisabled\" (click)=\"applyFilter()\">{{ esf.grid?.resourceStrings.igx_grid_excel_apply }}</button>\n</footer>\n"
            },] }
];
IgxExcelStyleSearchComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: IgxGridExcelStyleFilteringComponent }
];
IgxExcelStyleSearchComponent.propDecorators = {
    defaultClass: [{ type: HostBinding, args: ['class.igx-excel-filter__menu-main',] }],
    searchInput: [{ type: ViewChild, args: ['input', { read: IgxInputDirective, static: true },] }],
    list: [{ type: ViewChild, args: ['list', { read: IgxListComponent, static: true },] }],
    virtDir: [{ type: ViewChild, args: [IgxForOfDirective, { static: true },] }],
    defaultExcelStyleLoadingValuesTemplate: [{ type: ViewChild, args: ['defaultExcelStyleLoadingValuesTemplate', { read: TemplateRef },] }]
};

/**
 * A component used for presenting Excel style conditional filter UI.
 */
class IgxExcelStyleSelectingComponent {
    constructor(esf) {
        this.esf = esf;
    }
}
IgxExcelStyleSelectingComponent.decorators = [
    { type: Component, args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-selecting',
                template: "<div *ngIf=\"esf.column\"\n    [ngClass]=\"esf.selectedClass()\"\n    tabindex=\"0\"\n    (click)=\"esf.onSelect()\">\n    <span>{{esf.grid.resourceStrings.igx_grid_excel_select }}</span>\n    <igx-icon>done</igx-icon>\n</div>\n"
            },] }
];
IgxExcelStyleSelectingComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];

/**
 * A component used for presenting Excel style column sorting UI.
 */
class IgxExcelStyleSortingComponent {
    constructor(esf, cdr) {
        this.esf = esf;
        this.cdr = cdr;
        /**
         * @hidden @internal
         */
        this.defaultClass = true;
        this.destroy$ = new Subject();
        this.esf.sortingChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.updateSelectedButtons(this.esf.column.field);
        });
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden @internal
     */
    onSortButtonClicked(sortDirection) {
        if (this.sortButtonGroup.selectedIndexes.length === 0) {
            if (this.esf.grid.isColumnGrouped(this.esf.column.field)) {
                this.sortButtonGroup.selectButton(sortDirection - 1);
            }
            else {
                this.esf.grid.clearSort(this.esf.column.field);
            }
        }
        else {
            this.esf.grid.sort({ fieldName: this.esf.column.field, dir: sortDirection, ignoreCase: true });
        }
    }
    updateSelectedButtons(fieldName) {
        const sortIndex = this.esf.grid.sortingExpressions.findIndex(s => s.fieldName === fieldName);
        this.cdr.detectChanges();
        this.sortButtonGroup.buttons.forEach((b, i) => {
            this.sortButtonGroup.deselectButton(i);
        });
        if (sortIndex !== -1) {
            const sortDirection = this.esf.grid.sortingExpressions[sortIndex].dir;
            this.sortButtonGroup.selectButton(sortDirection - 1);
        }
    }
}
IgxExcelStyleSortingComponent.decorators = [
    { type: Component, args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-sorting',
                template: "<ng-container *ngIf=\"esf.column\">\n<header>\n    {{ esf.grid.resourceStrings.igx_grid_excel_filter_sorting_header }}\n</header>\n<igx-buttongroup #sortButtonGroup [multiSelection]=\"false\">\n    <button igxButton\n        [displayDensity]=\"esf.grid.displayDensity\"\n        [attr.data-togglable]=\"true\"\n        (click)=\"onSortButtonClicked(1)\"\n        >\n        <igx-icon>arrow_upwards</igx-icon>\n        <span>\n            {{ esf.grid.displayDensity==='compact'?\n            esf.grid.resourceStrings.igx_grid_excel_filter_sorting_asc_short:\n            esf.grid.resourceStrings.igx_grid_excel_filter_sorting_asc  }}\n        </span>\n    </button>\n\n    <button igxButton\n        [displayDensity]=\"esf.grid.displayDensity\"\n        [attr.data-togglable]=\"true\"\n        (click)=\"onSortButtonClicked(2)\"\n        >\n        <igx-icon>arrow_downwards</igx-icon>\n        <span>\n            {{ esf.grid.displayDensity==='compact'?\n            esf.grid.resourceStrings.igx_grid_excel_filter_sorting_desc_short:\n            esf.grid.resourceStrings.igx_grid_excel_filter_sorting_desc\n        }}\n        </span>\n    </button>\n</igx-buttongroup>\n</ng-container>\n"
            },] }
];
IgxExcelStyleSortingComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent },
    { type: ChangeDetectorRef }
];
IgxExcelStyleSortingComponent.propDecorators = {
    defaultClass: [{ type: HostBinding, args: ['class.igx-excel-filter__sort',] }],
    sortButtonGroup: [{ type: ViewChild, args: ['sortButtonGroup', { read: IgxButtonGroupComponent },] }]
};

/**
 * Providing reference to `IgxGridCellComponent`:
 * ```typescript
 * @ViewChild('grid', { read: IgxGridComponent })
 *  public grid: IgxGridComponent;
 * ```
 * ```typescript
 *  let column = this.grid.columnList.first;
 * ```
 * ```typescript
 *  let cell = column.cells[0];
 * ```
 */
class IgxGridCellComponent {
    constructor(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil) {
        this.selectionService = selectionService;
        this.crudService = crudService;
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.element = element;
        this.zone = zone;
        this.touchManager = touchManager;
        this.platformUtil = platformUtil;
        /**
         * @hidden
         * @internal
         */
        this.lastPinned = false;
        /**
         * @hidden
         * @internal
         */
        this.firstPinned = false;
        /**
         * Returns whether the cell is in edit mode.
         */
        this.editMode = false;
        /**
         * Sets/get the `role` property of the cell.
         * Default value is `"gridcell"`.
         * ```typescript
         * this.cell.role = 'grid-cell';
         * ```
         * ```typescript
         * let cellRole = this.cell.role;
         * ```
         *
         * @memberof IgxGridCellComponent
         */
        this.role = 'gridcell';
        /**
         * Gets the width of the cell.
         * ```typescript
         * let cellWidth = this.cell.width;
         * ```
         *
         * @memberof IgxGridCellComponent
         */
        this.width = '';
        /**
         * @hidden
         */
        this.active = false;
        /**
         * @hidden
         */
        this.displayPinnedChip = false;
        /**
         * Sets/gets the highlight class of the cell.
         * Default value is `"igx-highlight"`.
         * ```typescript
         * let highlightClass = this.cell.highlightClass;
         * ```
         * ```typescript
         * this.cell.highlightClass = 'igx-cell-highlight';
         * ```
         *
         * @memberof IgxGridCellComponent
         */
        this.highlightClass = 'igx-highlight';
        /**
         * Sets/gets the active highlight class class of the cell.
         * Default value is `"igx-highlight__active"`.
         * ```typescript
         * let activeHighlightClass = this.cell.activeHighlightClass;
         * ```
         * ```typescript
         * this.cell.activeHighlightClass = 'igx-cell-highlight_active';
         * ```
         *
         * @memberof IgxGridCellComponent
         */
        this.activeHighlightClass = 'igx-highlight__active';
        /** @hidden @internal @deprecated */
        this.focused = this.active;
        this._cellSelection = GridSelectionMode.multiple;
        this._vIndex = -1;
        /**
         * @hidden
         * @internal
         */
        this.onDoubleClick = (event) => {
            if (event.type === 'doubletap') {
                // prevent double-tap to zoom on iOS
                event.preventDefault();
            }
            if (this.grid.rowEditable && this.row.addRow) {
                this.crudService.enterEditMode(this, event);
            }
            if (this.editable && !this.editMode && !this.row.deleted && !this.crudService.rowEditingBlocked) {
                this.crudService.enterEditMode(this, event);
            }
            this.grid.onDoubleClick.emit({
                cell: this,
                event
            });
        };
        /**
         *
         * @hidden
         * @internal
         */
        this.pointerdown = (event) => {
            if (this.cellSelectionMode !== GridSelectionMode.multiple) {
                this.activate(event);
                return;
            }
            if (!isLeftClick(event)) {
                event.preventDefault();
                this.grid.navigation.setActiveNode({ rowIndex: this.rowIndex, colIndex: this.visibleColumnIndex });
                this.selectionService.addKeyboardRange();
                this.selectionService.initKeyboardState();
                this.selectionService.primaryButton = false;
                // Ensure RMB Click on edited cell does not end cell editing
                if (!this.selected) {
                    this.gridAPI.submit_value(event);
                }
                return;
            }
            this.selectionService.pointerDown(this.selectionNode, event.shiftKey, event.ctrlKey);
            this.activate(event);
        };
        /**
         *
         * @hidden
         * @internal
         */
        this.pointerenter = (event) => {
            const isHierarchicalGrid = this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
            if (isHierarchicalGrid && (!this.grid.navigation.activeNode.gridID || this.grid.navigation.activeNode.gridID !== this.gridID)) {
                return;
            }
            const dragMode = this.selectionService.pointerEnter(this.selectionNode, event);
            if (dragMode) {
                this.grid.cdr.detectChanges();
                if (isIE()) {
                    this.grid.tbody.nativeElement.focus({ preventScroll: true });
                }
            }
        };
        /**
         * @hidden
         * @internal
         */
        this.pointerup = (event) => {
            const isHierarchicalGrid = this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
            if (!isLeftClick(event) || (isHierarchicalGrid && (!this.grid.navigation.activeNode.gridID ||
                this.grid.navigation.activeNode.gridID !== this.gridID))) {
                return;
            }
            if (this.selectionService.pointerUp(this.selectionNode, this.grid.onRangeSelection)) {
                this.grid.cdr.detectChanges();
                if (isIE()) {
                    this.grid.tbody.nativeElement.focus({ preventScroll: true });
                }
            }
        };
    }
    /**
     * @hidden
     * @internal
     */
    get isEmptyAddRowCell() {
        return this.row.addRow && (this.value === undefined || this.value === null);
    }
    /**
     * Gets the cell template context object.
     * ```typescript
     *  let context = this.cell.context();
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get context() {
        return {
            $implicit: this.value,
            cell: this
        };
    }
    /**
     * Gets the cell template.
     * ```typescript
     * let template = this.cell.template;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get template() {
        if (this.editMode) {
            const inlineEditorTemplate = this.column.inlineEditorTemplate;
            return inlineEditorTemplate ? inlineEditorTemplate : this.inlineEditorTemplate;
        }
        if (this.cellTemplate) {
            return this.cellTemplate;
        }
        if (this.grid.rowEditable && this.row.addRow) {
            return this.addRowCellTemplate;
        }
        return this.defaultCellTemplate;
    }
    /**
     * Gets the cell template.
     * ```typescript
     * let template = this.cell.template;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get pinnedIndicatorTemplate() {
        if (this.pinnedIndicator) {
            return this.pinnedIndicator;
        }
        return this.defaultPinnedIndicator;
    }
    /**
     * Gets the `id` of the grid in which the cell is stored.
     * ```typescript
     * let gridId = this.cell.gridID;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get gridID() {
        return this.row.gridID;
    }
    /**
     * Gets the grid of the cell.
     * ```typescript
     * let grid = this.cell.grid;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Gets the `index` of the row where the cell is stored.
     * ```typescript
     * let rowIndex = this.cell.rowIndex;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get rowIndex() {
        return this.row.index;
    }
    /**
     * Gets the `index` of the cell column.
     * ```typescript
     * let columnIndex = this.cell.columnIndex;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get columnIndex() {
        return this.column.index;
    }
    /**
     * Gets the visible `index` of the in which the cell is stored.
     * ```typescript
     * let visibleColumnIndex = this.cell.visibleColumnIndex;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get visibleColumnIndex() {
        return this.column.columnLayoutChild ? this.column.visibleIndex : this._vIndex;
    }
    set visibleColumnIndex(val) {
        this._vIndex = val;
    }
    /**
     * Gets the ID of the cell.
     * ```typescript
     * let cellID = this.cell.cellID;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get cellID() {
        const primaryKey = this.grid.primaryKey;
        const rowID = primaryKey ? this.rowData[primaryKey] : this.rowData;
        return { rowID, columnID: this.columnIndex, rowIndex: this.rowIndex };
    }
    get attrCellID() {
        return `${this.row.gridID}_${this.rowIndex}_${this.visibleColumnIndex}`;
    }
    get title() {
        return this.editMode || this.cellTemplate ? '' : this.column.dataType === DataType.Percent ?
            this.grid.percentPipe.transform(this.value, this.column.pipeArgs.digitsInfo, this.grid.locale) :
            this.column.dataType === DataType.Currency ?
                this.grid.currencyPipe.transform(this.value, this.currencyCode, this.column.pipeArgs.display, this.column.pipeArgs.digitsInfo, this.grid.locale) :
                this.value;
    }
    get booleanClass() {
        return this.column.dataType === 'boolean' && this.value;
    }
    /**
     * Returns a reference to the nativeElement of the cell.
     * ```typescript
     * let cellNativeElement = this.cell.nativeElement;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @internal
     */
    get cellSelectionMode() {
        return this._cellSelection;
    }
    set cellSelectionMode(value) {
        if (this._cellSelection === value) {
            return;
        }
        this.zone.runOutsideAngular(() => {
            if (value === GridSelectionMode.multiple) {
                this.addPointerListeners(value);
            }
            else {
                this.removePointerListeners(this._cellSelection);
            }
        });
        this._cellSelection = value;
    }
    /**
     * @hidden
     * @internal
     */
    set lastSearchInfo(value) {
        this._lastSearchInfo = value;
        this.highlightText(this._lastSearchInfo.searchText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
    }
    /**
     * Gets whether the cell is editable.
     * ```typescript
     * let isCellReadonly = this.cell.readonly;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get readonly() {
        return !this.editable;
    }
    get gridRowSpan() {
        return this.column.gridRowSpan;
    }
    get gridColumnSpan() {
        return this.column.gridColumnSpan;
    }
    get rowEnd() {
        return this.column.rowEnd;
    }
    get colEnd() {
        return this.column.colEnd;
    }
    get rowStart() {
        return this.column.rowStart;
    }
    get colStart() {
        return this.column.colStart;
    }
    get ariaSelected() {
        return this.selected || this.column.selected || this.row.selected;
    }
    /**
     * Gets whether the cell is selected.
     * ```typescript
     * let isSelected = this.cell.selected;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get selected() {
        return this.selectionService.selected(this.selectionNode);
    }
    /**
     * Selects/deselects the cell.
     * ```typescript
     * this.cell.selected = true.
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    set selected(val) {
        const node = this.selectionNode;
        if (val) {
            this.selectionService.add(node);
        }
        else {
            this.selectionService.remove(node);
        }
        this.grid.notifyChanges();
    }
    /**
     * Gets whether the cell column is selected.
     * ```typescript
     * let isCellColumnSelected = this.cell.columnSelected;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get columnSelected() {
        return this.selectionService.isColumnSelected(this.column.field);
    }
    /**
     * Sets the current edit value while a cell is in edit mode.
     * Only for cell editing mode.
     * ```typescript
     * this.cell.editValue = value;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    set editValue(value) {
        if (this.crudService.cellInEditMode) {
            this.crudService.cell.editValue = value;
        }
    }
    /**
     * Gets the current edit value while a cell is in edit mode.
     * Only for cell editing mode.
     * ```typescript
     * let editValue = this.cell.editValue;
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    get editValue() {
        if (this.crudService.cellInEditMode) {
            return this.crudService.cell.editValue;
        }
    }
    /**
     * Returns whether the cell is editable.
     */
    get editable() {
        return this.column.editable && !this.row.disabled;
    }
    set highlight(value) {
        this._highlight = value;
        if (this._highlight && this.grid.lastSearchInfo.searchText) {
            this._highlight.highlight(this.grid.lastSearchInfo.searchText, this.grid.lastSearchInfo.caseSensitive, this.grid.lastSearchInfo.exactMatch);
            this._highlight.activateIfNecessary();
        }
    }
    get highlight() {
        return this._highlight;
    }
    get selectionNode() {
        return {
            row: this.rowIndex,
            column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
            layout: this.column.columnLayoutChild ? {
                rowStart: this.column.rowStart,
                colStart: this.column.colStart,
                rowEnd: this.column.rowEnd,
                colEnd: this.column.colEnd,
                columnVisibleIndex: this.visibleColumnIndex
            } : null
        };
    }
    /** @hidden @internal */
    get step() {
        const digitsInfo = this.column.pipeArgs.digitsInfo;
        if (!digitsInfo) {
            return 1;
        }
        const step = +digitsInfo.substr(digitsInfo.indexOf('.') + 1, 1);
        return 1 / (Math.pow(10, step));
    }
    /** @hidden @internal */
    get currencyCode() {
        return this.column.pipeArgs.currencyCode ?
            this.column.pipeArgs.currencyCode : getLocaleCurrencyCode(this.grid.locale);
    }
    /** @hidden @internal */
    get currencyCodeSymbol() {
        return getCurrencySymbol(this.currencyCode, 'wide', this.grid.locale);
    }
    /**
     * @deprecated
     * Gets whether the cell is selected.
     * ```typescript
     * let isCellSelected = thid.cell.isCellSelected();
     * ```
     * @memberof IgxGridCellComponent
     */
    isCellSelected() {
        return this.selectionService.selected(this.selectionNode);
    }
    /**
     * @hidden
     * @internal
     */
    onClick(event) {
        this.grid.onCellClick.emit({
            cell: this,
            event
        });
    }
    /**
     * @hidden
     * @internal
     */
    onContextMenu(event) {
        this.grid.onContextMenu.emit({
            cell: this,
            event
        });
    }
    /**
     * @hidden
     * @internal
     */
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.addEventListener('pointerdown', this.pointerdown);
            this.addPointerListeners(this.cellSelectionMode);
            // IE 11 workarounds
            if (this.platformUtil.isBrowser && isIE()) { // TODO: Move isIE to platformUtil
                this.compositionStartHandler = () => this.crudService.isInCompositionMode = true;
                this.compositionEndHandler = () => this.crudService.isInCompositionMode = false;
                // Hitting Enter with IME submits and exits from edit mode instead of first closing the IME dialog
                this.nativeElement.addEventListener('compositionstart', this.compositionStartHandler);
                this.nativeElement.addEventListener('compositionend', this.compositionEndHandler);
            }
        });
        if (this.platformUtil.isIOS) {
            this.touchManager.addEventListener(this.nativeElement, 'doubletap', this.onDoubleClick, {
                cssProps: {} /* don't disable user-select, etc */
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.removeEventListener('pointerdown', this.pointerdown);
            this.removePointerListeners(this.cellSelectionMode);
            if (this.platformUtil.isBrowser && isIE()) {
                this.nativeElement.removeEventListener('compositionstart', this.compositionStartHandler);
                this.nativeElement.removeEventListener('compositionend', this.compositionEndHandler);
            }
        });
        this.touchManager.destroy();
    }
    /**
     * @hidden
     * @internal
     */
    _updateCRUDStatus(event) {
        if (this.editMode) {
            return;
        }
        const crud = this.crudService;
        const editableCell = this.crudService.cell;
        const editMode = !!(crud.row || crud.cell);
        if (this.editable && editMode && !this.row.deleted) {
            if (editableCell) {
                if (this.row.addRow) {
                    this.gridAPI.update_add_cell(editableCell, editableCell.editValue, event);
                    this.row.rowData = editableCell.rowData;
                }
                else {
                    this.gridAPI.update_cell(editableCell, editableCell.editValue, event);
                }
                /* This check is related with the following issue #6517:
                 * when edit cell that belongs to a column which is sorted and press tab,
                 * the next cell in edit mode is with wrong value /its context is not updated/;
                 * So we reapply sorting before the next cell enters edit mode.
                 * Also we need to keep the notifyChanges below, because of the current
                 * change detection cycle when we have editing with enabled transactions
                 */
                if (this.grid.sortingExpressions.length && this.grid.sortingExpressions.indexOf(editableCell.column.field)) {
                    this.grid.cdr.detectChanges();
                }
                if (this.crudService.cellEditingBlocked) {
                    return true;
                }
                crud.exitCellEdit(event);
            }
            this.grid.tbody.nativeElement.focus({ preventScroll: true });
            this.grid.notifyChanges();
            crud.enterEditMode(this, event);
            return false;
        }
        if (editableCell && crud.sameRow(this.cellID.rowID)) {
            if (this.row.addRow) {
                this.gridAPI.submit_add_value(event);
                this.row.rowData = editableCell.rowData;
            }
            else {
                this.gridAPI.submit_value(event);
            }
        }
        else if (editMode && !crud.sameRow(this.cellID.rowID)) {
            this.grid.endEdit(true, event);
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnChanges(changes) {
        if (changes.value && !changes.value.firstChange) {
            if (this.highlight) {
                this.highlight.lastSearchInfo.searchedText = this.grid.lastSearchInfo.searchText;
                this.highlight.lastSearchInfo.caseSensitive = this.grid.lastSearchInfo.caseSensitive;
                this.highlight.lastSearchInfo.exactMatch = this.grid.lastSearchInfo.exactMatch;
            }
        }
    }
    /**
     * Starts/ends edit mode for the cell.
     *
     * ```typescript
     * cell.setEditMode(true);
     * ```
     */
    setEditMode(value) {
        if (this.row.deleted) {
            return;
        }
        if (this.editable && value) {
            this.gridAPI.submit_value();
            this.crudService.enterEditMode(this);
        }
        else {
            this.grid.crudService.exitCellEdit();
        }
        this.grid.notifyChanges();
    }
    /**
     * Sets new value to the cell.
     * ```typescript
     * this.cell.update('New Value');
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    // TODO: Refactor
    update(val) {
        if (this.row.deleted) {
            return;
        }
        const cell = this.crudService.createCell(this);
        const args = this.gridAPI.update_cell(cell, val);
        if (this.crudService.cell && this.crudService.sameCell(cell)) {
            if (args.cancel) {
                return;
            }
            this.grid.crudService.exitCellEdit();
        }
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     * @internal
     */
    activate(event) {
        const node = this.selectionNode;
        const shouldEmitSelection = !this.selectionService.isActiveNode(node);
        if (this.selectionService.primaryButton) {
            this._updateCRUDStatus(event);
            const activeElement = this.selectionService.activeElement;
            const row = activeElement ? this.gridAPI.get_row_by_index(activeElement.row) : null;
            if ((this.crudService.rowEditingBlocked && row && this.row.rowID !== row.rowID) ||
                (this.crudService.cell && this.crudService.cellEditingBlocked)) {
                return;
            }
            this.selectionService.activeElement = node;
        }
        else {
            this.selectionService.activeElement = null;
            if (this.crudService.cellInEditMode && !this.editMode) {
                this.gridAPI.submit_value(event);
            }
        }
        this.grid.navigation.setActiveNode({ row: this.rowIndex, column: this.visibleColumnIndex });
        this.selectionService.primaryButton = true;
        if (this.cellSelectionMode === GridSelectionMode.multiple && this.selectionService.activeElement) {
            this.selectionService.add(this.selectionService.activeElement, false); // pointer events handle range generation
            this.selectionService.keyboardStateOnFocus(node, this.grid.onRangeSelection, this.nativeElement);
        }
        if (this.grid.isCellSelectable && shouldEmitSelection) {
            this.grid.onSelection.emit({ cell: this, event });
        }
    }
    /**
     * If the provided string matches the text in the cell, the text gets highlighted.
     * ```typescript
     * this.cell.highlightText('Cell Value', true);
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    highlightText(text, caseSensitive, exactMatch) {
        return this.highlight && this.column.searchable ? this.highlight.highlight(text, caseSensitive, exactMatch) : 0;
    }
    /**
     * Clears the highlight of the text in the cell.
     * ```typescript
     * this.cell.clearHighLight();
     * ```
     *
     * @memberof IgxGridCellComponent
     */
    clearHighlight() {
        if (this.highlight && this.column.searchable) {
            this.highlight.clearHighlight();
        }
    }
    /**
     * @hidden
     * @internal
     */
    calculateSizeToFit(range) {
        return Math.max(...Array.from(this.nativeElement.children)
            .map((child) => getNodeSizeViaRange(range, child)));
    }
    /**
     * @hidden
     * @internal
     */
    get searchMetadata() {
        const meta = new Map();
        meta.set('pinned', this.grid.isRecordPinnedByViewIndex(this.row.index));
        return meta;
    }
    addPointerListeners(selection) {
        if (selection !== GridSelectionMode.multiple) {
            return;
        }
        this.nativeElement.addEventListener('pointerenter', this.pointerenter);
        this.nativeElement.addEventListener('pointerup', this.pointerup);
    }
    removePointerListeners(selection) {
        if (selection !== GridSelectionMode.multiple) {
            return;
        }
        this.nativeElement.removeEventListener('pointerenter', this.pointerenter);
        this.nativeElement.removeEventListener('pointerup', this.pointerup);
    }
}
IgxGridCellComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-grid-cell',
                template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip\n        *ngIf=\"displayPinnedChip\"\n        class=\"igx-grid__td--pinned-chip\"\n        [disabled]=\"true\"\n        [displayDensity]=\"'compact'\"\n        >{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip\n    >\n</ng-template>\n<ng-template #defaultCell>\n    <div *ngIf=\"column.dataType !== 'boolean'\"\n        igxTextHighlight\n        class=\"igx-grid__td-text\"\n        style=\"pointer-events: none;\"\n        [cssClass]=\"highlightClass\"\n        [activeCssClass]=\"activeHighlightClass\"\n        [groupName]=\"gridID\"\n        [value]=\"\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === 'number'\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'date'\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : column.dataType === 'currency'\n                ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'percent'\n                ? (value | percent:column.pipeArgs.digitsInfo:grid.locale)\n                : value\n        \"\n        [row]=\"rowData\"\n        [column]=\"this.column.field\"\n        [containerClass]=\"'igx-grid__td-text'\"\n        [metadata]=\"searchMetadata\"\n    >{{\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === \"number\"\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === \"date\"\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : column.dataType === 'currency'\n                ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'percent'\n                ? (value | percent:column.pipeArgs.digitsInfo:grid.locale)\n                : value\n        }}</div>\n    <igx-icon\n        *ngIf=\"column.dataType === 'boolean'\"\n        [ngClass]=\"{ 'igx-icon--success': value, 'igx-icon--error': !value }\"\n        >{{ value ? \"check\" : \"close\" }}</igx-icon\n    >\n</ng-template>\n<ng-template #addRowCell let-cell=\"cell\">\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n    [cssClass]=\"highlightClass\"\n    [activeCssClass]=\"activeHighlightClass\"\n    [groupName]=\"gridID\"\n    [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ?\n        (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ?\n        (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : column.dataType === 'currency' ?\n        (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'percent' ?\n        (value | percent:column.pipeArgs.digitsInfo:grid.locale) : value\"\n    [row]=\"rowData\"\n    [column]=\"this.column.field\"\n    [containerClass]=\"'igx-grid__td-text'\"\n    [metadata]=\"searchMetadata\">{{\n        !isEmptyAddRowCell ? value : (column.header || column.field)\n    }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox\n            (change)=\"editValue = $event.checked\"\n            [value]=\"editValue\"\n            [checked]=\"editValue\"\n            [igxFocus]=\"true\"\n            [disableRipple]=\"true\"\n        ></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker\n            [style.width.%]=\"100\"\n            [outlet]=\"grid.outlet\"\n            mode=\"dropdown\"\n            [locale]=\"grid.locale\"\n            [(value)]=\"editValue\"\n            [igxFocus]=\"true\"\n            [labelVisibility]=\"false\"\n        >\n        </igx-date-picker>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'currency'\">\n        <igx-input-group displayDensity=\"compact\">\n            <igx-prefix *ngIf=\"grid.currencyPositionLeft\">{{ currencyCodeSymbol }}</igx-prefix>\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n            <igx-suffix *ngIf=\"!grid.currencyPositionLeft\" >{{ currencyCodeSymbol }}</igx-suffix>\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'percent'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n            <igx-suffix> {{ editValue | percent:column.pipeArgs.digitsInfo:grid.locale }} </igx-suffix>\n        </igx-input-group>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n",
                providers: [HammerGesturesManager]
            },] }
];
IgxGridCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];
IgxGridCellComponent.propDecorators = {
    isEmptyAddRowCell: [{ type: HostBinding, args: ['class.igx-grid__td--new',] }],
    column: [{ type: Input }],
    row: [{ type: Input }],
    rowData: [{ type: Input }],
    cellTemplate: [{ type: Input }],
    pinnedIndicator: [{ type: Input }],
    value: [{ type: Input }],
    formatter: [{ type: Input }],
    rowIndex: [{ type: HostBinding, args: ['attr.data-rowIndex',] }],
    visibleColumnIndex: [{ type: HostBinding, args: ['attr.data-visibleIndex',] }, { type: Input }],
    attrCellID: [{ type: HostBinding, args: ['attr.id',] }],
    title: [{ type: HostBinding, args: ['attr.title',] }],
    booleanClass: [{ type: HostBinding, args: ['class.igx-grid__td--bool-true',] }],
    cellSelectionMode: [{ type: Input }],
    lastSearchInfo: [{ type: Input }],
    lastPinned: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid__td--pinned-last',] }],
    firstPinned: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid__td--pinned-first',] }],
    editMode: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid__td--editing',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    readonly: [{ type: HostBinding, args: ['attr.aria-readonly',] }],
    width: [{ type: Input }],
    active: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid__td--active',] }],
    ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
    selected: [{ type: HostBinding, args: ['class.igx-grid__td--selected',] }],
    columnSelected: [{ type: HostBinding, args: ['class.igx-grid__td--column-selected',] }],
    displayPinnedChip: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid__td--row-pinned-first',] }],
    defaultCellTemplate: [{ type: ViewChild, args: ['defaultCell', { read: TemplateRef, static: true },] }],
    defaultPinnedIndicator: [{ type: ViewChild, args: ['defaultPinnedIndicator', { read: TemplateRef, static: true },] }],
    inlineEditorTemplate: [{ type: ViewChild, args: ['inlineEditor', { read: TemplateRef, static: true },] }],
    addRowCellTemplate: [{ type: ViewChild, args: ['addRowCell', { read: TemplateRef, static: true },] }],
    highlight: [{ type: ViewChild, args: [IgxTextHighlightDirective, { read: IgxTextHighlightDirective },] }],
    onDoubleClick: [{ type: HostListener, args: ['dblclick', ['$event'],] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onContextMenu: [{ type: HostListener, args: ['contextmenu', ['$event'],] }]
};
__decorate([
    DeprecateMethod(`'isCellSelected' is deprecated. Use 'selected' property instead.`)
], IgxGridCellComponent.prototype, "isCellSelected", null);

class IgxGridBodyDirective {
}
IgxGridBodyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxGridBody]',
                providers: [IgxForOfSyncService]
            },] }
];
/**
 * @hidden
 */
class RowEditPositionStrategy extends ConnectedPositioningStrategy {
    constructor() {
        super(...arguments);
        this.isTop = false;
        this.isTopInitialPosition = null;
    }
    position(contentElement, size, document, initialCall, target) {
        const container = this.settings.container; // grid.tbody
        const targetElement = target || this.settings.target; // current grid.row
        // Position of the overlay depends on the available space in the grid.
        // If the bottom space is not enough then the the row overlay will show at the top of the row.
        // Once shown, either top or bottom, then this position stays until the overlay is closed (isTopInitialPosition property),
        // which means that when scrolling then overlay may hide, while the row is still visible (UX requirement).
        this.isTop = this.isTopInitialPosition !== null ?
            this.isTopInitialPosition :
            container.getBoundingClientRect().bottom <
                targetElement.getBoundingClientRect().bottom + contentElement.getBoundingClientRect().height;
        // Set width of the row editing overlay to equal row width, otherwise it fits 100% of the grid.
        contentElement.style.width = targetElement.clientWidth + 'px';
        this.settings.verticalStartPoint = this.settings.verticalDirection = this.isTop ? VerticalAlignment.Top : VerticalAlignment.Bottom;
        this.settings.openAnimation = this.isTop ? scaleInVerBottom : scaleInVerTop;
        super.position(contentElement, { width: targetElement.clientWidth, height: targetElement.clientHeight }, document, initialCall, targetElement);
    }
}

// eslint-disable-next-line @angular-eslint/directive-selector
class IgxExcelTextDirective {
}
IgxExcelTextDirective.decorators = [
    { type: Directive, args: [{ selector: '[excelText],excel-text' },] }
];
// eslint-disable-next-line @angular-eslint/directive-selector
class IgxCSVTextDirective {
}
IgxCSVTextDirective.decorators = [
    { type: Directive, args: [{ selector: '[csvText],csv-text' },] }
];
/**
 * Provides a way to template the title portion of the toolbar in the grid.
 *
 * @igxModule IgxGridToolbarModule
 * @igxParent IgxGridToolbarComponent
 *
 * @example
 * ```html
 * <igx-grid-toolbar-title>My custom title</igx-grid-toolbar-title>
 * ```
 */
class IgxGridToolbarTitleDirective {
    constructor() {
        /**
         * Host `class.igx-grid-toolbar__title` binding.
         *
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-grid-toolbar__title';
    }
}
IgxGridToolbarTitleDirective.decorators = [
    { type: Directive, args: [{ selector: '[igxGridToolbarTitle],igx-grid-toolbar-title' },] }
];
IgxGridToolbarTitleDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-grid-toolbar__title',] }]
};
/**
 * Provides a way to template the action portion of the toolbar in the grid.
 *
 * @igxModule IgxGridToolbarModule
 * @igxParent IgxGridToolbarComponent
 *
 * @example
 * ```html
 * <igx-grid-toolbar-actions>
 *  <some-toolbar-action-here />
 * </igx-grid-toolbar-actions>
 * ```
 */
class IgxGridToolbarActionsDirective {
    constructor() {
        /**
         * Host `class.igx-grid-toolbar__actions` binding.
         *
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-grid-toolbar__actions';
    }
}
IgxGridToolbarActionsDirective.decorators = [
    { type: Directive, args: [{ selector: '[igxGridToolbarActions],igx-grid-toolbar-actions' },] }
];
IgxGridToolbarActionsDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-grid-toolbar__actions',] }]
};
class IgxGridToolbarDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxGridToolbarDirective.decorators = [
    { type: Directive, args: [{ selector: '[igxGridToolbar]' },] }
];
IgxGridToolbarDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * Provides a context-aware container component for UI operations for the grid components.
 *
 * @igxModule IgxGridToolbarModule
 *
 */
class IgxGridToolbarComponent extends DisplayDensityBase {
    constructor(_displayDensityOptions, api, iconService, element) {
        super(_displayDensityOptions);
        this._displayDensityOptions = _displayDensityOptions;
        this.api = api;
        this.iconService = iconService;
        this.element = element;
        /**
         * When enabled, shows the indeterminate progress bar.
         *
         * @remarks
         * By default this will be toggled, when the default exporter component is present
         * and an exporting is in progress.
         */
        this.showProgress = false;
        /**
         * @hidden
         * @internal
         */
        this.defaultStyle = true;
        /** @hidden @internal */
        this.width = null;
        this.iconService.addSvgIconFromText(pinLeft.name, pinLeft.value, 'imx-icons');
        this.iconService.addSvgIconFromText(unpinLeft.name, unpinLeft.value, 'imx-icons');
    }
    /**
     * Gets/sets the grid component for the toolbar component.
     *
     * @remarks
     * Usually you should not set this property in the context of the default grid/tree grid.
     * The only grids that demands this to be set are the hierarchical child grids. For additional
     * information check the toolbar topic.
     */
    get grid() {
        if (this._grid) {
            return this._grid;
        }
        return this.api.grid;
    }
    set grid(value) {
        this._grid = value;
    }
    /** Returns the native DOM element of the toolbar component */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @internal
     */
    get cosyStyle() {
        return this.displayDensity === 'cosy';
    }
    /**
     * @hidden
     * @internal
     */
    get compactStyle() {
        return this.displayDensity === 'compact';
    }
    /** @hidden @internal */
    ngOnInit() {
        this.grid.rendered$.pipe(first$1()).subscribe(() => this.width = this.grid.outerWidth);
        this.sub = this.grid.resizeNotify.subscribe(() => this.width = this.grid.outerWidth);
    }
    /** @hidden @internal */
    ngOnDestroy() {
        var _a;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
}
IgxGridToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-grid-toolbar',
                template: "<ng-template #title>\n    <ng-content select=\"[igxGridToolbarTitle],igx-grid-toolbar-title\"></ng-content>\n</ng-template>\n<igx-grid-toolbar-title *ngIf=\"!hasTitle\">{{ grid.toolbarTitle }}</igx-grid-toolbar-title>\n<ng-container *ngTemplateOutlet=\"title\"></ng-container>\n\n<div class=\"igx-grid-toolbar__custom-content\">\n    <ng-content></ng-content>\n</div>\n\n<ng-template #actions>\n    <ng-content select=\"[igxGridToolbarActions],igx-grid-toolbar-actions\"></ng-content>\n</ng-template>\n<igx-grid-toolbar-actions *ngIf=\"!hasActions\">\n    <igx-grid-toolbar-advanced-filtering *ngIf=\"grid.allowAdvancedFiltering\"></igx-grid-toolbar-advanced-filtering>\n    <igx-grid-toolbar-hiding *ngIf=\"grid.columnHiding\"></igx-grid-toolbar-hiding>\n    <igx-grid-toolbar-pinning *ngIf=\"grid.columnPinning\"></igx-grid-toolbar-pinning>\n    <igx-grid-toolbar-exporter *ngIf=\"grid.exportExcel || grid.exportCsv\" (exportStarted)=\"showProgress = true\" (exportEnded)=\"showProgress = false\">\n    </igx-grid-toolbar-exporter>\n</igx-grid-toolbar-actions>\n<ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n\n<div class=\"igx-grid-toolbar__progress-bar\" *ngIf=\"showProgress\">\n    <igx-linear-bar [indeterminate]=\"true\"></igx-linear-bar>\n</div>\n"
            },] }
];
IgxGridToolbarComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: GridBaseAPIService },
    { type: IgxIconService },
    { type: ElementRef }
];
IgxGridToolbarComponent.propDecorators = {
    showProgress: [{ type: Input }],
    grid: [{ type: Input }],
    hasTitle: [{ type: ContentChild, args: [IgxGridToolbarTitleDirective,] }],
    hasActions: [{ type: ContentChild, args: [IgxGridToolbarActionsDirective,] }],
    defaultStyle: [{ type: HostBinding, args: ['class.igx-grid-toolbar',] }],
    cosyStyle: [{ type: HostBinding, args: ['class.igx-grid-toolbar--cosy',] }],
    compactStyle: [{ type: HostBinding, args: ['class.igx-grid-toolbar--compact',] }],
    width: [{ type: HostBinding, args: ['style.max-width.px',] }, { type: HostBinding, args: ['style.flex-basis.px',] }]
};

/** @hidden @internal */
class IgxRowEditTemplateDirective {
}
IgxRowEditTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxRowEdit]'
            },] }
];
/** @hidden @internal */
class IgxRowEditTextDirective {
}
IgxRowEditTextDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxRowEditText]'
            },] }
];
/** @hidden @internal */
class IgxRowEditActionsDirective {
}
IgxRowEditActionsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxRowEditActions]'
            },] }
];
// TODO: Refactor circular ref, deps and logic
/** @hidden @internal */
class IgxRowEditTabStopDirective {
    constructor(api, element) {
        this.api = api;
        this.element = element;
    }
    get grid() {
        return this.api.grid;
    }
    handleTab(event) {
        event.stopPropagation();
        if ((this.grid.rowEditTabs.last === this && !event.shiftKey) ||
            (this.grid.rowEditTabs.first === this && event.shiftKey)) {
            this.move(event);
        }
    }
    handleEscape(event) {
        this.grid.endEdit(false, event);
        this.grid.tbody.nativeElement.focus();
    }
    handleEnter(event) {
        event.stopPropagation();
    }
    /**
     * Moves focus to first/last editable cell in the editable row and put the cell in edit mode.
     * If cell is out of view first scrolls to the cell
     *
     * @param event keyboard event containing information about whether SHIFT key was pressed
     */
    move(event) {
        event.preventDefault();
        this.currentCellIndex = event.shiftKey ? this.grid.lastEditableColumnIndex : this.grid.firstEditableColumnIndex;
        this.grid.navigation.activeNode.row = this.grid.rowInEditMode.index;
        this.grid.navigation.activeNode.column = this.currentCellIndex;
        this.grid.navigateTo(this.grid.rowInEditMode.index, this.currentCellIndex, (obj) => {
            obj.target.activate(event);
            this.grid.cdr.detectChanges();
        });
    }
}
IgxRowEditTabStopDirective.decorators = [
    { type: Directive, args: [{
                selector: `[igxRowEditTabStop]`
            },] }
];
IgxRowEditTabStopDirective.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ElementRef }
];
IgxRowEditTabStopDirective.propDecorators = {
    handleTab: [{ type: HostListener, args: ['keydown.Tab', [`$event`],] }, { type: HostListener, args: ['keydown.Shift.Tab', [`$event`],] }],
    handleEscape: [{ type: HostListener, args: ['keydown.Escape', [`$event`],] }],
    handleEnter: [{ type: HostListener, args: ['keydown.Enter', ['$event'],] }]
};

/** @hidden */
class IgxGridNavigationService {
    constructor() {
        this._activeNode = {};
        this.lastActiveNode = {};
        this.pendingNavigation = false;
    }
    get activeNode() {
        return this._activeNode;
    }
    set activeNode(value) {
        this._activeNode = value;
    }
    handleNavigation(event) {
        const key = event.key.toLowerCase();
        if (this.grid.crudService.cell && NAVIGATION_KEYS.has(key)) {
            return;
        }
        if (event.repeat && SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) {
            event.preventDefault();
        }
        if (event.repeat) {
            setTimeout(() => this.dispatchEvent(event), 1);
        }
        else {
            this.dispatchEvent(event);
        }
    }
    dispatchEvent(event) {
        const key = event.key.toLowerCase();
        if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) &&
            !this.grid.crudService.rowEditingBlocked && !this.grid.rowInEditMode) {
            return;
        }
        const shift = event.shiftKey;
        const ctrl = event.ctrlKey;
        if (NAVIGATION_KEYS.has(key) && this.pendingNavigation) {
            event.preventDefault();
            return;
        }
        const type = this.isDataRow(this.activeNode.row) ? 'dataCell' :
            this.isDataRow(this.activeNode.row, true) ? 'summaryCell' : 'groupRow';
        if (this.emitKeyDown(type, this.activeNode.row, event)) {
            return;
        }
        if (event.altKey) {
            this.handleAlt(key, event);
            return;
        }
        if ([' ', 'spacebar', 'space'].indexOf(key) === -1) {
            this.grid.selectionService.keyboardStateOnKeydown(this.activeNode, shift, shift && key === 'tab');
        }
        const position = this.getNextPosition(this.activeNode.row, this.activeNode.column, key, shift, ctrl, event);
        if (NAVIGATION_KEYS.has(key)) {
            event.preventDefault();
            this.navigateInBody(position.rowIndex, position.colIndex, (obj) => {
                obj.target.activate(event);
                this.grid.cdr.detectChanges();
            });
        }
        this.grid.cdr.detectChanges();
    }
    summaryNav(event) {
        if (this.grid.hasSummarizedColumns) {
            this.horizontalNav(event, event.key.toLowerCase(), this.grid.dataView.length, 'summaryCell');
        }
    }
    headerNavigation(event) {
        const key = event.key.toLowerCase();
        if (!HEADER_KEYS.has(key)) {
            return;
        }
        event.preventDefault();
        const ctrl = event.ctrlKey;
        const shift = event.shiftKey;
        const alt = event.altKey;
        this.performHeaderKeyCombination(this.currentActiveColumn, key, shift, ctrl, alt, event);
        if (shift || alt || (ctrl && (key.includes('down') || key.includes('down')))) {
            return;
        }
        if (this.grid.hasColumnGroups) {
            this.handleMCHeaderNav(key, ctrl);
        }
        else {
            this.horizontalNav(event, key, -1, 'headerCell');
        }
    }
    focusTbody(event) {
        var _a;
        const gridRows = (_a = this.grid.verticalScrollContainer.totalItemCount) !== null && _a !== void 0 ? _a : this.grid.dataView.length;
        if (gridRows < 1) {
            this.activeNode = null;
            return;
        }
        if (!this.activeNode || !Object.keys(this.activeNode).length || this.activeNode.row < 0 || this.activeNode.row > gridRows - 1) {
            const hasLastActiveNode = Object.keys(this.lastActiveNode).length;
            const shouldClearSelection = hasLastActiveNode && (this.lastActiveNode.row < 0 || this.lastActiveNode.row > gridRows - 1);
            this.setActiveNode(this.lastActiveNode.row >= 0 && this.lastActiveNode.row < gridRows ?
                this.firstVisibleNode(this.lastActiveNode.row) : this.firstVisibleNode());
            if (shouldClearSelection || (this.grid.cellSelection !== GridSelectionMode.multiple)) {
                this.grid.clearCellSelection();
                this.grid.navigateTo(this.activeNode.row, this.activeNode.column, (obj) => {
                    var _a;
                    (_a = obj.target) === null || _a === void 0 ? void 0 : _a.activate(event);
                    this.grid.cdr.detectChanges();
                });
            }
            else {
                const range = { rowStart: this.activeNode.row, rowEnd: this.activeNode.row,
                    columnStart: this.activeNode.column, columnEnd: this.activeNode.column };
                this.grid.selectRange(range);
                this.grid.notifyChanges();
            }
        }
    }
    focusFirstCell(header = true) {
        if ((header || this.grid.dataView.length) && this.activeNode &&
            (this.activeNode.row === -1 || this.activeNode.row === this.grid.dataView.length ||
                (!header && !this.grid.hasSummarizedColumns))) {
            return;
        }
        const shouldScrollIntoView = this.lastActiveNode && (header && this.lastActiveNode.row !== -1) ||
            (!header && this.lastActiveNode.row !== this.grid.dataView.length);
        this.setActiveNode(this.firstVisibleNode(header ? -1 : this.grid.dataView.length));
        if (shouldScrollIntoView) {
            this.performHorizontalScrollToCell(this.activeNode.column);
        }
    }
    isColumnFullyVisible(columnIndex) {
        if (columnIndex < 0 || this.isColumnPinned(columnIndex, this.forOfDir())) {
            return true;
        }
        const index = this.getColumnUnpinnedIndex(columnIndex);
        const width = this.forOfDir().getColumnScrollLeft(index + 1) - this.forOfDir().getColumnScrollLeft(index);
        if (this.displayContainerWidth < width && this.displayContainerScrollLeft === this.forOfDir().getColumnScrollLeft(index)) {
            return true;
        }
        return this.displayContainerWidth >= this.forOfDir().getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft &&
            this.displayContainerScrollLeft <= this.forOfDir().getColumnScrollLeft(index);
    }
    shouldPerformHorizontalScroll(visibleColIndex, rowIndex = -1) {
        if (visibleColIndex < 0 || visibleColIndex > this.grid.visibleColumns.length - 1) {
            return false;
        }
        if (rowIndex < 0 || rowIndex > this.grid.dataView.length - 1) {
            return !this.isColumnFullyVisible(visibleColIndex);
        }
        const row = this.grid.dataView[rowIndex];
        return row.expression || row.detailsData ? false : !this.isColumnFullyVisible(visibleColIndex);
    }
    shouldPerformVerticalScroll(targetRowIndex, visibleColIndex) {
        if (this.grid.isRecordPinnedByViewIndex(targetRowIndex)) {
            return false;
        }
        const scrollRowIndex = this.grid.hasPinnedRecords && this.grid.isRowPinningToTop ?
            targetRowIndex - this.grid.pinnedDataView.length : targetRowIndex;
        const targetRow = this.getRowElementByIndex(targetRowIndex);
        const rowHeight = this.grid.verticalScrollContainer.getSizeAt(scrollRowIndex);
        const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        const endTopOffset = targetRow ? targetRow.offsetTop + rowHeight + this.containerTopOffset : containerHeight + rowHeight;
        // this is workaround: endTopOffset - containerHeight > 5 and should be replaced with: containerHeight < endTopOffset
        // when the page is zoomed the grid does not scroll the row completely in the view
        return !targetRow || targetRow.offsetTop < Math.abs(this.containerTopOffset)
            || containerHeight && endTopOffset - containerHeight > 5;
    }
    performVerticalScrollToCell(rowIndex, visibleColIndex = -1, cb) {
        if (!this.shouldPerformVerticalScroll(rowIndex, visibleColIndex)) {
            return;
        }
        this.pendingNavigation = true;
        // Only for top pinning we need to subtract pinned count because virtualization indexing doesn't count pinned rows.
        const scrollRowIndex = this.grid.hasPinnedRecords && this.grid.isRowPinningToTop ?
            rowIndex - this.grid.pinnedDataView.length : rowIndex;
        this.grid.verticalScrollContainer.scrollTo(scrollRowIndex);
        this.grid.verticalScrollContainer.onChunkLoad
            .pipe(first$1()).subscribe(() => {
            this.pendingNavigation = false;
            if (cb) {
                cb();
            }
        });
    }
    performHorizontalScrollToCell(visibleColumnIndex, cb) {
        if (this.grid.rowList < 1 && this.grid.summariesRowList.length < 1 && this.grid.hasColumnGroups) {
            let column = this.grid.getColumnByVisibleIndex(visibleColumnIndex);
            while (column.parent) {
                column = column.parent;
            }
            visibleColumnIndex = this.forOfDir().igxForOf.indexOf(column);
        }
        if (!this.shouldPerformHorizontalScroll(visibleColumnIndex)) {
            return;
        }
        this.pendingNavigation = true;
        this.grid.parentVirtDir.onChunkLoad
            .pipe(first$1())
            .subscribe(() => {
            this.pendingNavigation = false;
            if (cb) {
                cb();
            }
        });
        this.forOfDir().scrollTo(this.getColumnUnpinnedIndex(visibleColumnIndex));
    }
    isDataRow(rowIndex, includeSummary = false) {
        if (rowIndex < 0 || rowIndex > this.grid.dataView.length - 1) {
            return false;
        }
        const curRow = this.grid.dataView[rowIndex];
        return curRow && !this.grid.isGroupByRecord(curRow) && !this.grid.isDetailRecord(curRow)
            && !curRow.childGridsData && (includeSummary || !curRow.summaries);
    }
    isGroupRow(rowIndex) {
        if (rowIndex < 0 || rowIndex > this.grid.dataView.length - 1) {
            return false;
        }
        const curRow = this.grid.dataView[rowIndex];
        return curRow && this.grid.isGroupByRecord(curRow);
    }
    setActiveNode(activeNode) {
        if (!this.isActiveNodeChanged(activeNode)) {
            return;
        }
        if (!this.activeNode) {
            this.activeNode = activeNode;
        }
        Object.assign(this.activeNode, activeNode);
        const currRow = this.grid.dataView[activeNode.row];
        const type = activeNode.row < 0 ? 'headerCell' :
            this.isDataRow(activeNode.row) ? 'dataCell' :
                currRow && this.grid.isGroupByRecord(currRow) ? 'groupRow' :
                    currRow && this.grid.isDetailRecord(currRow) ? 'masterDetailRow' : 'summaryCell';
        const args = {
            row: this.activeNode.row,
            column: this.activeNode.column,
            level: this.activeNode.level,
            tag: type
        };
        this.grid.activeNodeChange.emit(args);
    }
    isActiveNodeChanged(activeNode) {
        let isChanged = false;
        const checkInnerProp = (aciveNode, prop) => {
            if (!aciveNode) {
                isChanged = true;
                return;
            }
            props = Object.getOwnPropertyNames(aciveNode);
            for (const propName of props) {
                if (this.activeNode[prop][propName] !== aciveNode[propName]) {
                    isChanged = true;
                }
            }
        };
        if (!this.activeNode) {
            return isChanged = true;
        }
        let props = Object.getOwnPropertyNames(activeNode);
        for (const propName of props) {
            if (!!this.activeNode[propName] && typeof this.activeNode[propName] === 'object') {
                checkInnerProp(activeNode[propName], propName);
            }
            else if (this.activeNode[propName] !== activeNode[propName]) {
                isChanged = true;
            }
        }
        return isChanged;
    }
    getNextPosition(rowIndex, colIndex, key, shift, ctrl, event) {
        if (!this.isDataRow(rowIndex, true) && (key.indexOf('down') < 0 || key.indexOf('up') < 0) && ctrl) {
            return { rowIndex, colIndex };
        }
        switch (key) {
            case 'pagedown':
            case 'pageup':
                event.preventDefault();
                if (key === 'pagedown') {
                    this.grid.verticalScrollContainer.scrollNextPage();
                }
                else {
                    this.grid.verticalScrollContainer.scrollPrevPage();
                }
                const editCell = this.grid.crudService.cell;
                this.grid.verticalScrollContainer.onChunkLoad
                    .pipe(first$1()).subscribe(() => {
                    if (editCell && this.grid.rowList.map(r => r.index).indexOf(editCell.rowIndex) < 0) {
                        this.grid.tbody.nativeElement.focus({ preventScroll: true });
                    }
                });
                break;
            case 'tab':
                this.handleEditing(shift, event);
                break;
            case 'end':
                rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row;
                colIndex = this.lastColumnIndex;
                break;
            case 'home':
                rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row;
                colIndex = 0;
                break;
            case 'arrowleft':
            case 'left':
                colIndex = ctrl ? 0 : this.activeNode.column - 1;
                break;
            case 'arrowright':
            case 'right':
                colIndex = ctrl ? this.lastColumnIndex : this.activeNode.column + 1;
                break;
            case 'arrowup':
            case 'up':
                if (ctrl && !this.isDataRow(rowIndex) || (this.grid.rowEditable && this.grid.crudService.rowEditingBlocked)) {
                    break;
                }
                colIndex = this.activeNode.column !== undefined ? this.activeNode.column : 0;
                rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row - 1;
                break;
            case 'arrowdown':
            case 'down':
                if ((ctrl && !this.isDataRow(rowIndex)) || (this.grid.rowEditable && this.grid.crudService.rowEditingBlocked)) {
                    break;
                }
                colIndex = this.activeNode.column !== undefined ? this.activeNode.column : 0;
                rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row + 1;
                break;
            case 'enter':
            case 'f2':
                const cell = this.grid.getCellByColumnVisibleIndex(this.activeNode.row, this.activeNode.column);
                if (!this.isDataRow(rowIndex) || !cell.editable) {
                    break;
                }
                this.grid.crudService.enterEditMode(cell, event);
                break;
            case 'escape':
            case 'esc':
                if (!this.isDataRow(rowIndex)) {
                    break;
                }
                if (this.grid.crudService.isInCompositionMode) {
                    return;
                }
                if (this.grid.crudService.cellInEditMode || this.grid.crudService.rowInEditMode) {
                    this.grid.endEdit(false, event);
                    if (isEdge()) {
                        this.grid.cdr.detectChanges();
                    }
                    this.grid.tbody.nativeElement.focus();
                }
                break;
            case ' ':
            case 'spacebar':
            case 'space':
                const rowObj = this.grid.getRowByIndex(this.activeNode.row);
                if (this.grid.isRowSelectable && rowObj) {
                    if (this.isDataRow(rowIndex)) {
                        if (rowObj.selected) {
                            this.grid.selectionService.deselectRow(rowObj.rowID, event);
                        }
                        else {
                            this.grid.selectionService.selectRowById(rowObj.rowID, false, event);
                        }
                    }
                    if (this.isGroupRow(rowIndex)) {
                        rowObj.onGroupSelectorClick(event);
                    }
                }
                break;
            default:
                return;
        }
        return { rowIndex, colIndex };
    }
    horizontalNav(event, key, rowIndex, tag) {
        const ctrl = event.ctrlKey;
        if (!HORIZONTAL_NAV_KEYS.has(event.key.toLowerCase())) {
            return;
        }
        event.preventDefault();
        this.activeNode.row = rowIndex;
        if (rowIndex > 0) {
            if (this.emitKeyDown('summaryCell', this.activeNode.row, event)) {
                return;
            }
        }
        const newActiveNode = {
            column: this.activeNode.column,
            mchCache: {
                level: this.activeNode.level,
                visibleIndex: this.activeNode.column
            }
        };
        if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {
            newActiveNode.column = ctrl || key === 'home' ? 0 : this.activeNode.column - 1;
        }
        if ((key.includes('right') || key === 'end') && this.activeNode.column < this.lastColumnIndex) {
            newActiveNode.column = ctrl || key === 'end' ? this.lastColumnIndex : this.activeNode.column + 1;
        }
        if (tag === 'headerCell') {
            const column = this.grid.getColumnByVisibleIndex(newActiveNode.column);
            newActiveNode.mchCache.level = column.level;
            newActiveNode.mchCache.visibleIndex = column.visibleIndex;
        }
        this.setActiveNode({ row: this.activeNode.row, column: newActiveNode.column, mchCache: newActiveNode.mchCache });
        this.performHorizontalScrollToCell(this.activeNode.column);
    }
    get lastColumnIndex() {
        return Math.max(...this.grid.visibleColumns.map(col => col.visibleIndex));
    }
    get displayContainerWidth() {
        return Math.round(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth);
    }
    get displayContainerScrollLeft() {
        return Math.ceil(this.grid.headerContainer.scrollPosition);
    }
    get containerTopOffset() {
        return parseInt(this.grid.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement.style.top, 10);
    }
    getColumnUnpinnedIndex(visibleColumnIndex) {
        const column = this.grid.unpinnedColumns.find((col) => !col.columnGroup && col.visibleIndex === visibleColumnIndex);
        return this.grid.pinnedColumns.length ? this.grid.unpinnedColumns.filter((c) => !c.columnGroup).indexOf(column) :
            visibleColumnIndex;
    }
    forOfDir() {
        const forOfDir = this.grid.dataRowList.length > 0 ? this.grid.dataRowList.first.virtDirRow : this.grid.summariesRowList.length ?
            this.grid.summariesRowList.first.virtDirRow : this.grid.headerContainer;
        return forOfDir;
    }
    handleAlt(key, event) {
        event.preventDefault();
        const row = this.grid.getRowByIndex(this.activeNode.row);
        if (!(this.isToggleKey(key) || this.isAddKey(key)) || !row) {
            return;
        }
        if (this.isAddKey(key)) {
            if (!this.grid.rowEditable) {
                console.warn('The grid must be in row edit mode to perform row adding!');
                return;
            }
            if (event.shiftKey && row.treeRow !== undefined) {
                this.grid.beginAddRowByIndex(row.rowID, row.index, true, event);
            }
            else if (!event.shiftKey) {
                this.grid.beginAddRowByIndex(row.rowID, row.index, false, event);
            }
        }
        else if (!row.expanded && ROW_EXPAND_KEYS.has(key)) {
            if (row.rowID === undefined) {
                row.toggle();
            }
            else {
                this.grid.gridAPI.set_row_expansion_state(row.rowID, true, event);
            }
        }
        else if (row.expanded && ROW_COLLAPSE_KEYS.has(key)) {
            if (row.rowID === undefined) {
                row.toggle();
            }
            else {
                this.grid.gridAPI.set_row_expansion_state(row.rowID, false, event);
            }
        }
        this.grid.notifyChanges();
    }
    handleEditing(shift, event) {
        var _a;
        const next = shift ? this.grid.getPreviousCell(this.activeNode.row, this.activeNode.column, col => col.editable) :
            this.grid.getNextCell(this.activeNode.row, this.activeNode.column, col => col.editable);
        if (!this.grid.rowInEditMode && this.isActiveNode(next.rowIndex, next.visibleColumnIndex)) {
            this.grid.endEdit(true, event);
            this.grid.tbody.nativeElement.focus();
            return;
        }
        event.preventDefault();
        if ((this.grid.rowInEditMode && this.grid.rowEditTabs.length) &&
            (this.activeNode.row !== next.rowIndex || this.isActiveNode(next.rowIndex, next.visibleColumnIndex))) {
            if ((_a = this.grid.crudService.row) === null || _a === void 0 ? void 0 : _a.isAddRow) {
                this.grid.gridAPI.submit_add_value(event);
                const row = this.grid.rowList.find(r => r.rowID === this.grid.crudService.row.id);
                row.rowData = this.grid.crudService.row.data;
            }
            else {
                this.grid.gridAPI.submit_value(event);
            }
            if (shift) {
                this.grid.rowEditTabs.last.element.nativeElement.focus();
            }
            else {
                this.grid.rowEditTabs.first.element.nativeElement.focus();
            }
            return;
        }
        if (this.grid.rowInEditMode && !this.grid.rowEditTabs.length) {
            if (shift && next.rowIndex === this.activeNode.row && next.visibleColumnIndex === this.activeNode.column) {
                next.visibleColumnIndex = this.grid.lastEditableColumnIndex;
            }
            else if (!shift && next.rowIndex === this.activeNode.row && next.visibleColumnIndex === this.activeNode.column) {
                next.visibleColumnIndex = this.grid.firstEditableColumnIndex;
            }
            else {
                next.rowIndex = this.activeNode.row;
            }
        }
        this.navigateInBody(next.rowIndex, next.visibleColumnIndex, (obj) => {
            obj.target.activate(event);
            this.grid.cdr.detectChanges();
        });
    }
    navigateInBody(rowIndex, visibleColIndex, cb = null) {
        if (!this.isValidPosition(rowIndex, visibleColIndex) || this.isActiveNode(rowIndex, visibleColIndex)) {
            return;
        }
        this.grid.navigateTo(rowIndex, visibleColIndex, cb);
    }
    emitKeyDown(type, rowIndex, event) {
        var _a, _b;
        const row = this.grid.summariesRowList.toArray().concat(this.grid.rowList.toArray()).find(r => r.index === rowIndex);
        if (!row) {
            return;
        }
        const target = type === 'groupRow' ? row :
            type === 'dataCell' ? (_a = row.cells) === null || _a === void 0 ? void 0 : _a.find(c => c.visibleColumnIndex === this.activeNode.column) : (_b = row.summaryCells) === null || _b === void 0 ? void 0 : _b.find(c => c.visibleColumnIndex === this.activeNode.column);
        const keydownArgs = { targetType: type, event, cancel: false, target };
        this.grid.onGridKeydown.emit(keydownArgs);
        if (keydownArgs.cancel && type === 'dataCell') {
            this.grid.selectionService.clear();
            this.grid.selectionService.keyboardState.active = true;
            return keydownArgs.cancel;
        }
    }
    isColumnPinned(columnIndex, forOfDir) {
        var _a;
        const horizontalScroll = forOfDir.getScroll();
        return (!horizontalScroll.clientWidth || ((_a = this.grid.getColumnByVisibleIndex(columnIndex)) === null || _a === void 0 ? void 0 : _a.pinned));
    }
    findFirstDataRowIndex() {
        return this.grid.dataView.findIndex(rec => !this.grid.isGroupByRecord(rec) && !this.grid.isDetailRecord(rec) && !rec.summaries);
    }
    findLastDataRowIndex() {
        if (this.grid.totalItemCount) {
            return this.grid.totalItemCount - 1;
        }
        let i = this.grid.dataView.length;
        while (i--) {
            if (this.isDataRow(i)) {
                return i;
            }
        }
    }
    getRowElementByIndex(index) {
        var _a;
        if (this.grid.hasDetails) {
            const detail = this.grid.nativeElement.querySelector(`[detail="true"][data-rowindex="${index}"]`);
            if (detail) {
                return detail;
            }
        }
        return (_a = this.grid.rowList.toArray().concat(this.grid.summariesRowList.toArray()).find(r => r.index === index)) === null || _a === void 0 ? void 0 : _a.nativeElement;
    }
    isValidPosition(rowIndex, colIndex) {
        var _a;
        const length = (_a = this.grid.totalItemCount) !== null && _a !== void 0 ? _a : this.grid.dataView.length;
        if (rowIndex < 0 || colIndex < 0 || length - 1 < rowIndex || this.lastColumnIndex < colIndex) {
            return false;
        }
        return this.activeNode.column !== colIndex && !this.isDataRow(rowIndex, true) ? false : true;
    }
    performHeaderKeyCombination(column, key, shift, ctrl, alt, event) {
        var _a;
        let direction = (_a = this.grid.sortingExpressions.find(expr => expr.fieldName === column.field)) === null || _a === void 0 ? void 0 : _a.dir;
        if (ctrl && key.includes('up') && column.sortable && !column.columnGroup) {
            direction = direction === SortingDirection.Asc ? SortingDirection.None : SortingDirection.Asc;
            this.grid.sort({ fieldName: column.field, dir: direction, ignoreCase: false });
            return;
        }
        if (ctrl && key.includes('down') && column.sortable && !column.columnGroup) {
            direction = direction === SortingDirection.Desc ? SortingDirection.None : SortingDirection.Desc;
            this.grid.sort({ fieldName: column.field, dir: direction, ignoreCase: false });
            return;
        }
        if (shift && alt && this.isToggleKey(key) && !column.columnGroup && column.groupable) {
            direction = direction ? SortingDirection.Desc : SortingDirection.Asc;
            if (key.includes('right')) {
                this.grid.groupBy({ fieldName: column.field, dir: direction, ignoreCase: false });
            }
            else {
                this.grid.clearGrouping(column.field);
            }
            this.activeNode.column = key.includes('right') && this.grid.hideGroupedColumns &&
                column.visibleIndex === this.lastColumnIndex ? this.lastColumnIndex - 1 : this.activeNode.column;
            return;
        }
        if (alt && (ROW_EXPAND_KEYS.has(key) || ROW_COLLAPSE_KEYS.has(key))) {
            this.handleMCHExpandCollapse(key, column);
            return;
        }
        if ([' ', 'spacebar', 'space'].indexOf(key) !== -1) {
            this.handleColumnSelection(column, event);
        }
        if (alt && (key === 'l' || key === '¬') && this.grid.allowAdvancedFiltering) {
            this.grid.openAdvancedFilteringDialog();
        }
        if (ctrl && shift && key === 'l' && this.grid.allowFiltering && !column.columnGroup && column.filterable) {
            if (this.grid.filterMode === FilterMode.excelStyleFilter) {
                const headerEl = this.grid.nativeElement.querySelector(`.igx-grid__th--active`);
                this.grid.filteringService.toggleFilterDropdown(headerEl, column, IgxGridExcelStyleFilteringComponent);
            }
            else {
                this.performHorizontalScrollToCell(column.visibleIndex);
                this.grid.filteringService.filteredColumn = column;
                this.grid.filteringService.isFilterRowVisible = true;
            }
        }
    }
    firstVisibleNode(rowIndex) {
        var _a, _b, _c, _d;
        const colIndex = this.lastActiveNode.column !== undefined ? this.lastActiveNode.column : (_a = this.grid.visibleColumns.sort((c1, c2) => c1.visibleIndex - c2.visibleIndex)
            .find(c => this.isColumnFullyVisible(c.visibleIndex))) === null || _a === void 0 ? void 0 : _a.visibleIndex;
        const column = this.grid.visibleColumns.find((col) => !col.columnLayout && col.visibleIndex === colIndex);
        const rowInd = rowIndex ? rowIndex : (_b = this.grid.rowList.find(r => !this.shouldPerformVerticalScroll(r.index, colIndex))) === null || _b === void 0 ? void 0 : _b.index;
        const node = { row: rowInd !== null && rowInd !== void 0 ? rowInd : 0,
            column: (_c = column === null || column === void 0 ? void 0 : column.visibleIndex) !== null && _c !== void 0 ? _c : 0, level: (_d = column === null || column === void 0 ? void 0 : column.level) !== null && _d !== void 0 ? _d : 0,
            mchCache: column ? { level: column.level, visibleIndex: column.visibleIndex } : {}, layout: column && column.columnLayoutChild ? { rowStart: column.rowStart, colStart: column.colStart,
                rowEnd: column.rowEnd, colEnd: column.colEnd, columnVisibleIndex: column.visibleIndex } : null };
        return node;
    }
    handleMCHeaderNav(key, ctrl) {
        const newHeaderNode = {
            visibleIndex: this.activeNode.mchCache.visibleIndex,
            level: this.activeNode.mchCache.level
        };
        const activeCol = this.currentActiveColumn;
        const lastGroupIndex = Math.max(...this.grid.visibleColumns.
            filter(c => c.level <= this.activeNode.level).map(col => col.visibleIndex));
        let nextCol = activeCol;
        if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {
            const index = ctrl || key === 'home' ? 0 : this.activeNode.column - 1;
            nextCol = this.getNextColumnMCH(index);
            newHeaderNode.visibleIndex = nextCol.visibleIndex;
        }
        if ((key.includes('right') || key === 'end') && activeCol.visibleIndex < lastGroupIndex) {
            const nextVIndex = activeCol.children ? Math.max(...activeCol.allChildren.map(c => c.visibleIndex)) + 1 :
                activeCol.visibleIndex + 1;
            nextCol = ctrl || key === 'end' ? this.getNextColumnMCH(this.lastColumnIndex) : this.getNextColumnMCH(nextVIndex);
            newHeaderNode.visibleIndex = nextCol.visibleIndex;
        }
        if (!ctrl && key.includes('up') && this.activeNode.level > 0) {
            nextCol = activeCol.parent;
            newHeaderNode.level = nextCol.level;
        }
        if (!ctrl && key.includes('down') && activeCol.children) {
            nextCol = activeCol.children.find(c => c.visibleIndex === newHeaderNode.visibleIndex) ||
                activeCol.children.toArray().sort((a, b) => b.visibleIndex - a.visibleIndex)
                    .filter(col => col.visibleIndex < newHeaderNode.visibleIndex)[0];
            newHeaderNode.level = nextCol.level;
        }
        this.setActiveNode({
            row: this.activeNode.row,
            column: nextCol.visibleIndex,
            level: nextCol.level,
            mchCache: newHeaderNode
        });
        this.performHorizontalScrollToCell(nextCol.visibleIndex);
    }
    handleMCHExpandCollapse(key, column) {
        if (!column.children || !column.collapsible) {
            return;
        }
        if (!column.expanded && ROW_EXPAND_KEYS.has(key)) {
            column.expanded = true;
        }
        else if (column.expanded && ROW_COLLAPSE_KEYS.has(key)) {
            column.expanded = false;
        }
    }
    handleColumnSelection(column, event) {
        if (!column.selectable || this.grid.columnSelection === GridSelectionMode.none) {
            return;
        }
        const clearSelection = this.grid.columnSelection === GridSelectionMode.single;
        const columnsToSelect = !column.children ? [column.field] :
            column.allChildren.filter(c => !c.hidden && c.selectable && !c.columnGroup).map(c => c.field);
        if (column.selected) {
            this.grid.selectionService.deselectColumns(columnsToSelect, event);
        }
        else {
            this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, false, event);
        }
    }
    getNextColumnMCH(visibleIndex) {
        let col = this.grid.getColumnByVisibleIndex(visibleIndex);
        let parent = col.parent;
        while (parent && col.level > this.activeNode.mchCache.level) {
            col = col.parent;
            parent = col.parent;
        }
        return col;
    }
    get currentActiveColumn() {
        return this.grid.visibleColumns.find(c => c.visibleIndex === this.activeNode.column && c.level === this.activeNode.level);
    }
    isActiveNode(rIndex, cIndex) {
        return this.activeNode ? this.activeNode.row === rIndex && this.activeNode.column === cIndex : false;
    }
    isToggleKey(key) {
        return ROW_COLLAPSE_KEYS.has(key) || ROW_EXPAND_KEYS.has(key);
    }
    isAddKey(key) {
        return ROW_ADD_KEYS.has(key);
    }
}
IgxGridNavigationService.decorators = [
    { type: Injectable }
];

/**
 * @hidden
 * @internal
 */
class IgxColumnResizingService {
    constructor(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = null;
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    /**
     * @hidden
     */
    get resizerHeight() {
        let height = this.column.grid.getVisibleContentHeight();
        // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
        let columnHeightMultiplier = 1;
        if (this.column.columnLayoutChild) {
            columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
        }
        if (this.column.level !== 0) {
            height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
        }
        return height;
    }
    /**
     * Returns the minimal possible width to which the column can be resized.
     */
    get restrictResizeMin() {
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const minWidth = this.column.minWidthPx < actualWidth ? this.column.minWidthPx : actualWidth;
        return actualWidth - minWidth;
    }
    /**
     * Returns the maximal possible width to which the column can be resized.
     */
    get restrictResizeMax() {
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const maxWidth = this.column.maxWidthPx;
        if (this.column.maxWidth) {
            return maxWidth - actualWidth;
        }
        else {
            return Number.MAX_SAFE_INTEGER;
        }
    }
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     */
    autosizeColumnOnDblClick() {
        const currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const isPercentageWidth = this.column.width && typeof this.column.width === 'string' && this.column.width.indexOf('%') !== -1;
        let size = this.column.getAutoSize();
        const maxWidth = isPercentageWidth ? this.column.maxWidthPercent : this.column.maxWidthPx;
        const minWidth = isPercentageWidth ? this.column.minWidthPercent : this.column.minWidthPx;
        if (this.column.maxWidth && (parseFloat(size) > maxWidth)) {
            size = isPercentageWidth ? maxWidth + '%' : maxWidth + 'px';
        }
        else if (parseFloat(size) < minWidth) {
            size = isPercentageWidth ? minWidth + '%' : minWidth + 'px';
        }
        this.column.width = size;
        this.zone.run(() => { });
        this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    }
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     */
    resizeColumn(event) {
        this.showResizer = false;
        const diff = event.clientX - this.startResizePos;
        const colWidth = this.column.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        let currentColWidth = parseFloat(colWidth);
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) ? parseFloat(actualWidth) : currentColWidth;
        if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
        }
        else if (isPercentageWidth) {
            this._handlePercentageResize(diff, this.column);
        }
        else {
            this._handlePixelResize(diff, this.column);
        }
        this.zone.run(() => { });
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: isPercentageWidth ? currentColWidth + '%' : currentColWidth + 'px',
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    }
    _handlePixelResize(diff, column) {
        const currentColWidth = parseFloat(column.width);
        const colMinWidth = column.minWidthPx;
        const colMaxWidth = column.maxWidthPx;
        if (currentColWidth + diff < colMinWidth) {
            column.width = colMinWidth + 'px';
        }
        else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
            column.width = colMaxWidth + 'px';
        }
        else {
            column.width = (currentColWidth + diff) + 'px';
        }
    }
    _handlePercentageResize(diff, column) {
        const currentPercentWidth = parseFloat(column.width);
        const gridAvailableSize = column.grid.calcWidth;
        const diffPercentage = (diff / gridAvailableSize) * 100;
        const colMinWidth = column.minWidthPercent;
        const colMaxWidth = column.maxWidthPercent;
        if (currentPercentWidth + diffPercentage < colMinWidth) {
            column.width = colMinWidth + '%';
        }
        else if (colMaxWidth && (currentPercentWidth + diffPercentage > colMaxWidth)) {
            column.width = colMaxWidth + '%';
        }
        else {
            column.width = (currentPercentWidth + diffPercentage) + '%';
        }
    }
    getColMinWidth(column) {
        let currentColWidth = parseFloat(column.width);
        const actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        const actualMinWidth = parseFloat(column.minWidth);
        return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;
    }
    resizeColumnLayoutFor(column, diff) {
        const relativeColumns = column.getResizableColUnderEnd();
        const combinedSpan = relativeColumns.reduce((acc, col) => acc + col.spanUsed, 0);
        // Resize first those who might reach min/max width
        let columnsToResize = [...relativeColumns];
        let updatedDiff = diff;
        let updatedCombinedSpan = combinedSpan;
        let setMinMaxCols = false;
        do {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            let newCombinedSpan = updatedCombinedSpan;
            const newColsToResize = [];
            columnsToResize.forEach((col) => {
                const currentResizeWidth = parseFloat(col.target.calcWidth);
                const resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                const colWidth = col.target.width;
                const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
                const minWidth = col.target.minWidthPx;
                const maxWidth = col.target.maxWidthPx;
                if (currentResizeWidth + resizeScaled < minWidth) {
                    col.target.width = isPercentageWidth ? col.target.minWidthPercent + '%' : minWidth + 'px';
                    updatedDiff += (currentResizeWidth - minWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                    col.target.width = isPercentageWidth ? col.target.maxWidthPercent + '%' : col.target.maxWidthPx + 'px';
                    updatedDiff -= (maxWidth - currentResizeWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else {
                    // Save new ones that can be resized
                    newColsToResize.push(col);
                }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
        } while (setMinMaxCols);
        // Those left that don't reach min/max size resize them normally.
        columnsToResize.forEach((col) => {
            const resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
            const colWidth = col.target.width;
            const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
            if (isPercentageWidth) {
                this._handlePercentageResize(resizeScaled, col.target);
            }
            else {
                this._handlePixelResize(resizeScaled, col.target);
            }
        });
    }
}
IgxColumnResizingService.decorators = [
    { type: Injectable }
];
IgxColumnResizingService.ctorParameters = () => [
    { type: NgZone }
];

/**
 * @hidden
 */
class IgxGridHeaderComponent {
    constructor(gridAPI, colResizingService, cdr, elementRef, zone) {
        this.gridAPI = gridAPI;
        this.colResizingService = colResizingService;
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.zone = zone;
        this.hostRole = 'columnheader';
        this.sortDirection = SortingDirection.None;
        this._destroy$ = new Subject();
    }
    /**
     * Returns the `aria-selected` of the header.
     */
    get ariaSelected() {
        return this.column.selected;
    }
    get styleClasses() {
        const defaultClasses = [
            'igx-grid__th--fw',
            this.column.headerClasses
        ];
        const classList = {
            'igx-grid__th': !this.column.columnGroup,
            asc: this.ascending,
            desc: this.descending,
            'igx-grid__th--number': this.column.dataType === DataType.Number,
            'igx-grid__th--sortable': this.column.sortable,
            'igx-grid__th--selectable': this.selectable,
            'igx-grid__th--filtrable': this.column.filterable && this.grid.filteringService.isFilterRowVisible,
            'igx-grid__th--sorted': this.sorted,
            'igx-grid__th--selected': this.selected
        };
        for (const klass of Object.keys(classList)) {
            if (classList[klass]) {
                defaultClasses.push(klass);
            }
        }
        return defaultClasses.join(' ');
    }
    get height() {
        if (this.grid.hasColumnGroups) {
            return (this.grid.maxLevelHeaderDepth + 1 - this.column.level) * this.grid.defaultRowHeight / this.grid._baseFontSize;
        }
        return null;
    }
    /**
     * @hidden
     */
    get esfIconTemplate() {
        return this.grid.excelStyleHeaderIconTemplate || this.defaultESFHeaderIconTemplate;
    }
    get ascending() {
        return this.sortDirection === SortingDirection.Asc;
    }
    get descending() {
        return this.sortDirection === SortingDirection.Desc;
    }
    get sortingIcon() {
        if (this.sortDirection !== SortingDirection.None) {
            // arrow_downward and arrow_upward
            // are material icons ligature strings
            return this.sortDirection === SortingDirection.Asc ? 'arrow_upward' : 'arrow_downward';
        }
        return 'arrow_upward';
    }
    get sorted() {
        return this.sortDirection !== SortingDirection.None;
    }
    get filterIconClassName() {
        return this.column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';
    }
    get selectable() {
        return this.grid.columnSelection !== GridSelectionMode.none &&
            this.column.applySelectableClass &&
            !this.column.selected &&
            !this.grid.filteringService.isFilterRowVisible;
    }
    get selected() {
        return this.column.selected
            && (!this.grid.filteringService.isFilterRowVisible || this.grid.filteringService.filteredColumn !== this.column);
    }
    get columnTitle() {
        return this.column.title || this.column.header || this.column.field;
    }
    onClick(event) {
        if (!this.colResizingService.isColumnResizing) {
            if (this.grid.filteringService.isFilterRowVisible) {
                if (this.column.filterCellTemplate) {
                    this.grid.filteringRow.close();
                    return;
                }
                if (this.column.filterable && !this.column.columnGroup &&
                    !this.grid.filteringService.isFilterComplex(this.column.field)) {
                    this.grid.filteringService.filteredColumn = this.column;
                }
            }
            else if (this.grid.columnSelection !== GridSelectionMode.none && this.column.selectable) {
                const clearSelection = this.grid.columnSelection === GridSelectionMode.single || !event.ctrlKey;
                const rangeSelection = this.grid.columnSelection === GridSelectionMode.multiple && event.shiftKey;
                if (!this.column.selected || (this.grid.selectionService.getSelectedColumns().length > 1 && clearSelection)) {
                    this.grid.selectionService.selectColumn(this.column.field, clearSelection, rangeSelection, event);
                }
                else {
                    this.grid.selectionService.deselectColumn(this.column.field, event);
                }
            }
        }
        this.grid.theadRow.nativeElement.focus();
    }
    /**
     * @hidden
     */
    onPinterEnter() {
        this.column.applySelectableClass = true;
    }
    /**
     * @hidden
     */
    onPointerLeave() {
        this.column.applySelectableClass = false;
    }
    ngDoCheck() {
        this.getSortDirection();
        this.cdr.markForCheck();
    }
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
        this.grid.filteringService.hideExcelFiltering();
    }
    onFilteringIconClick(event) {
        event.stopPropagation();
        this.grid.filteringService.toggleFilterDropdown(this.elementRef.nativeElement, this.column, IgxGridExcelStyleFilteringComponent);
    }
    get grid() {
        return this.gridAPI.grid;
    }
    onSortingIconClick(event) {
        event.stopPropagation();
        this.triggerSort();
    }
    getSortDirection() {
        const expr = this.gridAPI.grid.sortingExpressions.find((x) => x.fieldName === this.column.field);
        this.sortDirection = expr ? expr.dir : SortingDirection.None;
    }
    triggerSort() {
        const groupingExpr = this.grid.groupingExpressions ?
            this.grid.groupingExpressions.find((expr) => expr.fieldName === this.column.field) : null;
        const sortDir = groupingExpr ?
            this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.Asc : SortingDirection.Desc
            : this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.None : this.sortDirection + 1;
        this.sortDirection = sortDir;
        this.grid.sort({
            fieldName: this.column.field, dir: this.sortDirection, ignoreCase: this.column.sortingIgnoreCase,
            strategy: this.column.sortStrategy
        });
    }
}
IgxGridHeaderComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-header',
                template: "<ng-template #defaultColumn>\n    <span [title]=\"columnTitle\">{{ column.header || column.field }}</span>\n</ng-template>\n\n<ng-template #defaultESFHeaderIconTemplate>\n    <igx-icon>more_vert</igx-icon>\n</ng-template>\n\n<span class=\"igx-grid__th-title\">\n    <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n    </ng-container>\n</span>\n<div class=\"igx-grid__th-icons\" *ngIf=\"!column.columnGroup\">\n    <igx-icon\n        [attr.draggable]=\"false\"\n        [attr.data-sortIndex]=\"column.field | sortingIndex:grid.sortingExpressions\"\n        class=\"sort-icon\"\n        *ngIf=\"column.sortable\"\n        (click)=\"onSortingIconClick($event)\">\n        {{sortingIcon}}\n    </igx-icon>\n\n    <div *ngIf=\"grid.allowFiltering == true && column.filterable && grid.filterMode == 'excelStyleFilter'\"\n         (click)=\"onFilteringIconClick($event)\"\n         (pointerdown)=\"$event.stopPropagation()\"\n         [ngClass]=\"filterIconClassName\">\n\n        <ng-container *ngTemplateOutlet=\"esfIconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n    </div>\n\n</div>\n"
            },] }
];
IgxGridHeaderComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxColumnResizingService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
IgxGridHeaderComponent.propDecorators = {
    hostRole: [{ type: HostBinding, args: ['attr.role',] }],
    column: [{ type: Input }],
    gridID: [{ type: Input }],
    defaultESFHeaderIconTemplate: [{ type: ViewChild, args: ['defaultESFHeaderIconTemplate', { read: TemplateRef, static: true },] }],
    ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
    styleClasses: [{ type: HostBinding, args: ['class',] }],
    height: [{ type: HostBinding, args: ['style.height.rem',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onPinterEnter: [{ type: HostListener, args: ['pointerenter',] }],
    onPointerLeave: [{ type: HostListener, args: ['pointerleave',] }]
};

/**
 * @hidden
 */
class IgxGridFilteringCellComponent {
    constructor(cdr, filteringService) {
        this.cdr = cdr;
        this.filteringService = filteringService;
        this.moreFiltersCount = 0;
        this.baseClass = 'igx-grid__filtering-cell-indicator';
        this.filteringService.subscribeToEvents();
    }
    get styleClasses() {
        let classes = this.column && this.column.selected ?
            'igx-grid__filtering-cell--selected' :
            'igx-grid__filtering-cell';
        switch (this.column.grid.displayDensity) {
            case DisplayDensity.compact:
                classes = classes + ' igx-grid__filtering-cell--compact';
                break;
            case DisplayDensity.cosy:
                classes = classes + ' igx-grid__filtering-cell--cosy';
                break;
        }
        return classes;
    }
    ngOnInit() {
        this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
    }
    ngAfterViewInit() {
        this.updateFilterCellArea();
    }
    ngDoCheck() {
        this.updateFilterCellArea();
    }
    /**
     * Returns whether a chip with a given index is visible or not.
     */
    isChipVisible(index) {
        const expression = this.expressionsList[index];
        return !!(expression && expression.isVisible);
    }
    /**
     * Updates the filtering cell area.
     */
    updateFilterCellArea() {
        this.expressionsList = this.filteringService.getExpressions(this.column.field);
        this.updateVisibleFilters();
    }
    get displayDensity() {
        return this.column.grid.displayDensity === DisplayDensity.comfortable ? DisplayDensity.cosy : this.column.grid.displayDensity;
    }
    get template() {
        if (!this.column.filterable) {
            return null;
        }
        if (this.column.filterCellTemplate) {
            return this.column.filterCellTemplate;
        }
        const expressionTree = this.column.filteringExpressionsTree;
        if (!expressionTree || expressionTree.filteringOperands.length === 0) {
            return this.emptyFilter;
        }
        if (this.filteringService.isFilterComplex(this.column.field)) {
            return this.complexFilter;
        }
        return this.defaultFilter;
    }
    /**
     * Gets the context passed to the filter template.
     *
     * @memberof IgxGridFilteringCellComponent
     */
    get context() {
        return { column: this.column };
    }
    /**
     * Chip clicked event handler.
     */
    onChipClicked(expression) {
        if (expression) {
            this.expressionsList.forEach((item) => {
                item.isSelected = (item.expression === expression);
            });
        }
        else if (this.expressionsList.length > 0) {
            this.expressionsList.forEach((item) => {
                item.isSelected = false;
            });
            this.expressionsList[0].isSelected = true;
        }
        this.filteringService.grid.navigation.performHorizontalScrollToCell(this.column.visibleIndex);
        this.filteringService.filteredColumn = this.column;
        this.filteringService.isFilterRowVisible = true;
        this.filteringService.selectedExpression = expression;
    }
    /**
     * Chip removed event handler.
     */
    onChipRemoved(eventArgs, item) {
        const indexToRemove = this.expressionsList.indexOf(item);
        this.removeExpression(indexToRemove);
        this.filteringService.grid.theadRow.nativeElement.focus();
    }
    /**
     * Clears the filtering.
     */
    clearFiltering() {
        this.filteringService.clearFilter(this.column.field);
        this.cdr.detectChanges();
    }
    /**
     * Returns the filtering indicator class.
     */
    filteringIndicatorClass() {
        return {
            [this.baseClass]: !this.isMoreIconHidden(),
            [`${this.baseClass}--hidden`]: this.isMoreIconHidden()
        };
    }
    removeExpression(indexToRemove) {
        if (indexToRemove === 0 && this.expressionsList.length === 1) {
            this.clearFiltering();
            return;
        }
        this.filteringService.removeExpression(this.column.field, indexToRemove);
        this.updateVisibleFilters();
        this.filteringService.filterInternal(this.column.field);
    }
    isMoreIconHidden() {
        return this.filteringService.columnToMoreIconHidden.get(this.column.field);
    }
    updateVisibleFilters() {
        this.expressionsList.forEach((ex) => ex.isVisible = true);
        if (this.moreIcon) {
            this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
        }
        this.cdr.detectChanges();
        if (this.chipsArea && this.expressionsList.length > 1) {
            const areaWidth = this.chipsArea.element.nativeElement.offsetWidth;
            let viewWidth = 0;
            const chipsAreaElements = this.chipsArea.element.nativeElement.children;
            let visibleChipsCount = 0;
            const moreIconWidth = this.moreIcon.nativeElement.offsetWidth -
                parseInt(document.defaultView.getComputedStyle(this.moreIcon.nativeElement)['margin-left'], 10);
            for (let index = 0; index < chipsAreaElements.length - 1; index++) {
                if (viewWidth + chipsAreaElements[index].offsetWidth < areaWidth) {
                    viewWidth += chipsAreaElements[index].offsetWidth;
                    if (index % 2 === 0) {
                        visibleChipsCount++;
                    }
                    else {
                        viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-left'], 10);
                        viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-right'], 10);
                    }
                }
                else {
                    if (index % 2 !== 0 && viewWidth + moreIconWidth > areaWidth) {
                        visibleChipsCount--;
                    }
                    else if (visibleChipsCount > 0 && viewWidth - chipsAreaElements[index - 1].offsetWidth + moreIconWidth > areaWidth) {
                        visibleChipsCount--;
                    }
                    this.moreFiltersCount = this.expressionsList.length - visibleChipsCount;
                    this.filteringService.columnToMoreIconHidden.set(this.column.field, false);
                    break;
                }
            }
            for (let i = visibleChipsCount; i < this.expressionsList.length; i++) {
                this.expressionsList[i].isVisible = false;
            }
            this.cdr.detectChanges();
        }
    }
}
IgxGridFilteringCellComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-filtering-cell',
                template: "<ng-template #emptyFilter>\n    <igx-chips-area [attr.draggable]=\"false\" class=\"igx-filtering-chips\">\n        <igx-chip #ghostChip [attr.draggable]=\"false\" (click)=\"onChipClicked()\" [displayDensity]=\"displayDensity\" tabIndex=\"-1\">\n            <igx-icon [attr.draggable]=\"false\" igxPrefix>filter_list</igx-icon>\n            <span [attr.draggable]=\"false\">{{filteringService.grid.resourceStrings.igx_grid_filter}}</span>\n        </igx-chip>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #defaultFilter>\n    <igx-chips-area #chipsArea class=\"igx-filtering-chips\">\n        <ng-container *ngFor=\"let item of expressionsList; let last = last; let index = index;\" >\n            <igx-chip *ngIf=\"isChipVisible(index)\"\n                [removable]=\"true\"\n                tabIndex=\"-1\"\n                [displayDensity]=\"displayDensity\"\n                (click)=\"onChipClicked(item.expression)\"\n                (remove)=\"onChipRemoved($event, item)\">\n                <igx-icon igxPrefix\n                    family=\"imx-icons\"\n                    [name]=\"item.expression.condition.iconName\">\n                </igx-icon>\n                <span #label>\n                    {{filteringService.getChipLabel(item.expression)}}\n                </span>\n            </igx-chip>\n            <span class=\"igx-filtering-chips__connector\" *ngIf=\"!last && isChipVisible(index + 1)\">{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n        </ng-container>\n        <div #moreIcon [ngClass]=\"filteringIndicatorClass()\" (click)=\"onChipClicked()\">\n            <igx-icon>filter_list</igx-icon>\n            <igx-badge [value]=\"moreFiltersCount\"></igx-badge>\n        </div>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #complexFilter>\n    <igx-chip #complexChip [removable]=\"true\" [displayDensity]=\"displayDensity\" (remove)=\"clearFiltering()\" tabIndex=\"-1\">\n        <igx-icon igxPrefix>filter_list</igx-icon>\n        <span>{{filteringService.grid.resourceStrings.igx_grid_complex_filter}}</span>\n    </igx-chip>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n"
            },] }
];
IgxGridFilteringCellComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: IgxFilteringService }
];
IgxGridFilteringCellComponent.propDecorators = {
    column: [{ type: Input }],
    emptyFilter: [{ type: ViewChild, args: ['emptyFilter', { read: TemplateRef, static: true },] }],
    defaultFilter: [{ type: ViewChild, args: ['defaultFilter', { read: TemplateRef, static: true },] }],
    complexFilter: [{ type: ViewChild, args: ['complexFilter', { read: TemplateRef, static: true },] }],
    chipsArea: [{ type: ViewChild, args: ['chipsArea', { read: IgxChipsAreaComponent },] }],
    moreIcon: [{ type: ViewChild, args: ['moreIcon', { read: ElementRef },] }],
    ghostChip: [{ type: ViewChild, args: ['ghostChip', { read: IgxChipComponent },] }],
    complexChip: [{ type: ViewChild, args: ['complexChip', { read: IgxChipComponent },] }],
    styleClasses: [{ type: HostBinding, args: ['class',] }]
};

const Z_INDEX = 9999;
/**
 * @hidden
 */
class IgxGridHeaderGroupComponent {
    constructor(cdr, gridAPI, element, colResizingService, filteringService) {
        this.cdr = cdr;
        this.gridAPI = gridAPI;
        this.element = element;
        this.colResizingService = colResizingService;
        this.filteringService = filteringService;
    }
    get gridRowSpan() {
        return this.column.gridRowSpan;
    }
    get gridColumnSpan() {
        return this.column.gridColumnSpan;
    }
    get rowEnd() {
        return this.column.rowEnd;
    }
    get colEnd() {
        return this.column.colEnd;
    }
    get rowStart() {
        return this.column.rowStart;
    }
    get colStart() {
        return this.column.colStart;
    }
    get headerID() {
        return `${this.gridID}_-1_${this.column.level}_${this.column.visibleIndex}`;
    }
    get active() {
        const node = this.grid.navigation.activeNode;
        return node && !this.column.columnGroup ?
            node.row === -1 && node.column === this.column.visibleIndex && node.level === this.column.level : false;
    }
    get activeGroup() {
        const node = this.grid.navigation.activeNode;
        return node ? node.row === -1 && node.column === this.column.visibleIndex && node.level === this.column.level : false;
    }
    /**
     * Gets the width of the header group.
     *
     * @memberof IgxGridHeaderGroupComponent
     */
    get width() {
        return this.grid.getHeaderGroupWidth(this.column);
    }
    /**
     * Gets the style classes of the header group.
     *
     * @memberof IgxGridHeaderGroupComponent
     */
    get styleClasses() {
        const defaultClasses = [
            'igx-grid__thead-item',
            this.column.headerGroupClasses
        ];
        const classList = {
            'igx-grid__th--pinned': this.isPinned,
            'igx-grid__th--pinned-last': this.isLastPinned,
            'igx-grid__th--pinned-first': this.isFirstPinned,
            'igx-grid__drag-col-header': this.isHeaderDragged,
            'igx-grid__th--filtering': this.isFiltered
        };
        for (const className of Object.keys(classList)) {
            if (classList[className]) {
                defaultClasses.push(className);
            }
        }
        return defaultClasses.join(' ');
    }
    /**
     * @hidden
     */
    get zIndex() {
        if (!this.column.pinned) {
            return null;
        }
        return Z_INDEX - this.grid.pinnedColumns.indexOf(this.column);
    }
    /**
     * Gets the grid of the header group.
     *
     * @memberof IgxGridHeaderGroupComponent
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Gets whether the header group belongs to a column that is filtered.
     *
     * @memberof IgxGridHeaderGroupComponent
     */
    get isFiltered() {
        return this.filteringService.filteredColumn === this.column;
    }
    /**
     * Gets whether the header group is stored in the last column in the pinned area.
     *
     * @memberof IgxGridHeaderGroupComponent
     */
    get isLastPinned() {
        return !this.grid.hasColumnLayouts ? this.column.isLastPinned : false;
    }
    /**
     * Gets whether the header group is stored in the first column of the right pinned area.
     */
    get isFirstPinned() {
        return !this.grid.hasColumnLayouts ? this.column.isFirstPinned : false;
    }
    get groupDisplayStyle() {
        return this.grid.hasColumnLayouts && this.column.children && !isIE() ? 'flex' : '';
    }
    /**
     * Gets whether the header group is stored in a pinned column.
     *
     * @memberof IgxGridHeaderGroupComponent
     */
    get isPinned() {
        return this.column.pinned;
    }
    /**
     * Gets whether the header group belongs to a column that is moved.
     *
     * @memberof IgxGridHeaderGroupComponent
     */
    get isHeaderDragged() {
        return this.grid.draggedColumn === this.column;
    }
    /**
     * @hidden
     */
    get hasLastPinnedChildColumn() {
        return this.column.allChildren.some(child => child.isLastPinned);
    }
    /**
     * @hidden
     */
    get hasFirstPinnedChildColumn() {
        return this.column.allChildren.some(child => child.isFirstPinned);
    }
    /**
     * @hidden
     */
    get selectable() {
        const selectableChildren = this.column.allChildren.filter(c => !c.hidden && c.selectable && !c.columnGroup);
        return this.grid.columnSelection !== GridSelectionMode.none &&
            this.column.applySelectableClass
            && !this.selected && selectableChildren.length > 0
            && !this.grid.filteringService.isFilterRowVisible;
    }
    /**
     * @hidden
     */
    get selected() {
        return this.column.selected;
    }
    /**
     * @hidden
     */
    get height() {
        return this.element.nativeElement.getBoundingClientRect().height;
    }
    /**
     * @hidden
     */
    get columnTitle() {
        return this.column.title || this.column.header;
    }
    /**
     * @hidden
     */
    onMouseDown(event) {
        // hack for preventing text selection in IE and Edge while dragging the resizer
        event.preventDefault();
    }
    /**
     * @hidden
     */
    groupClicked(event) {
        const columnsToSelect = this.column.allChildren.filter(c => !c.hidden && c.selectable && !c.columnGroup).map(c => c.field);
        if (this.grid.columnSelection !== GridSelectionMode.none
            && columnsToSelect.length > 0 && !this.grid.filteringService.isFilterRowVisible) {
            const clearSelection = this.grid.columnSelection === GridSelectionMode.single || !event.ctrlKey;
            const rangeSelection = this.grid.columnSelection === GridSelectionMode.multiple && event.shiftKey;
            if (!this.selected) {
                this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, rangeSelection, event);
            }
            else {
                const selectedFields = this.grid.selectionService.getSelectedColumns();
                if ((selectedFields.length === columnsToSelect.length) && selectedFields.every(el => columnsToSelect.includes(el))
                    || !clearSelection) {
                    this.grid.selectionService.deselectColumns(columnsToSelect, event);
                }
                else {
                    this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, rangeSelection, event);
                }
            }
        }
    }
    /**
     * @hidden
     */
    toggleExpandState(event) {
        event.stopPropagation();
        this.column.expanded = !this.column.expanded;
    }
    /**
     * @hidden
     */
    // @HostListener('pointerdown', ['$event'])
    pointerdown(event) {
        event.stopPropagation();
        this.activate();
        this.grid.theadRow.nativeElement.focus();
    }
    /*
     * This method is necessary due to some specifics related with implementation of column moving
     * @hidden
     */
    activate() {
        this.grid.navigation.setActiveNode(this.activeNode);
        this.grid.theadRow.nativeElement.focus();
    }
    ngDoCheck() {
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    onPinterEnter() {
        this.column.applySelectableClass = true;
    }
    /**
     * @hidden
     */
    onPointerLeave() {
        this.column.applySelectableClass = false;
    }
    get activeNode() {
        return { row: -1, column: this.column.visibleIndex, level: this.column.level,
            mchCache: { level: this.column.level, visibleIndex: this.column.visibleIndex },
            layout: this.column.columnLayoutChild ? {
                rowStart: this.column.rowStart,
                colStart: this.column.colStart,
                rowEnd: this.column.rowEnd,
                colEnd: this.column.colEnd,
                columnVisibleIndex: this.column.visibleIndex
            } : null };
    }
}
IgxGridHeaderGroupComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-header-group',
                template: "<ng-container *ngIf=\"grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-group igx-grid__mrl-block\"\n     [ngClass]=\"{\n         'igx-grid__th--pinned-last': hasLastPinnedChildColumn,\n         'igx-grid__th--pinned-first': hasFirstPinnedChildColumn\n        }\"\n     [ngStyle]=\"{'grid-template-rows':column.getGridTemplate(true, false),\n     'grid-template-columns':column.getGridTemplate(false, false),\n     '-ms-grid-rows':column.getGridTemplate(true, true),\n     '-ms-grid-columns':column.getGridTemplate(false, true)}\">\n        <ng-container *ngFor=\"let child of column.children\" >\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                [column]=\"child\"\n                [gridID]=\"child.grid.id\"\n                [igxColumnMovingDrag]=\"child\"\n                [ghostHost]=\"grid.outlet.nativeElement\"\n                [attr.droppable]=\"true\"\n                [igxColumnMovingDrop]=\"child\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n\n<ng-template #defaultColumn>\n    <span class=\"igx-grid__th-group-title\" [title]=\"columnTitle\">{{column.header}}</span>\n</ng-template>\n\n<ng-template #defaultCollapseIndicator>\n    <igx-icon [attr.draggable]=\"false\" >\n            {{column.expanded ? 'expand_more' : 'chevron_right'}} </igx-icon>\n</ng-template>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-title\"\n        role=\"columnheader\"\n        [attr.aria-label]=\"column.header || column.field\"\n        [attr.aria-expanded]=\"column.expanded\"\n        [attr.aria-selected]=\"column.selected\"\n        [ngClass]=\"{\n            'igx-grid__th--pinned-last': hasLastPinnedChildColumn,\n            'igx-grid__th--pinned-first': hasFirstPinnedChildColumn,\n            'igx-grid__th--collapsible': column.collapsible,\n            'igx-grid__th--selectable': selectable,\n            'igx-grid__th--selected': selected,\n            'igx-grid__th--active': activeGroup}\"\n        [igxColumnMovingDrag]=\"column\"\n        [ghostHost]=\"grid.outlet.nativeElement\"\n        [attr.droppable]=\"true\"\n        [igxColumnMovingDrop]=\"column\"\n        (pointerdown)=\"pointerdown($event)\"\n        (click)=\"groupClicked($event)\"\n        (pointerenter)=\"onPinterEnter()\"\n        (pointerleave)=\"onPointerLeave()\"\n        >\n        <ng-container *ngIf=\"column.collapsible\">\n            <div class=\"igx-grid__th-expander\" (click)=\"toggleExpandState($event)\">\n                <ng-container\n                    *ngTemplateOutlet=\"column.collapsibleIndicatorTemplate ? column.collapsibleIndicatorTemplate : defaultCollapseIndicator; context: {$implicit: column, column: column}\">\n                </ng-container>\n            </div>\n        </ng-container>\n        <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n        </ng-container>\n    </div>\n    <div class=\"igx-grid__thead-group\">\n        <ng-container *ngFor=\"let child of column.children\">\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                                [column]=\"child\"\n                                [gridID]=\"child.grid.id\"\n                                [style.min-width]=\"grid.getHeaderGroupWidth(child)\"\n                                [style.flex-basis]=\"grid.getHeaderGroupWidth(child)\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n<ng-container *ngIf=\"!column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <igx-grid-header [igxColumnMovingDrag]=\"column\" [ghostHost]=\"grid.outlet.nativeElement\" [attr.droppable]=\"true\" (pointerdown)=\"activate()\" [igxColumnMovingDrop]=\"column\" [gridID]=\"column.grid.id\" [column]=\"column\"></igx-grid-header>\n    <igx-grid-filtering-cell *ngIf=\"grid.allowFiltering && grid.filterMode == 'quickFilter'\" [column]=\"column\" [attr.draggable]=\"false\"></igx-grid-filtering-cell>\n    <span *ngIf=\"!column.columnGroup && column.resizable\" class=\"igx-grid__th-resize-handle\"\n        [igxResizeHandle]=\"column\"\n        [attr.draggable]=\"false\"\n        [style.cursor]=\"colResizingService.resizeCursor\">\n    </span>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n"
            },] }
];
IgxGridHeaderGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: GridBaseAPIService },
    { type: ElementRef },
    { type: IgxColumnResizingService },
    { type: IgxFilteringService }
];
IgxGridHeaderGroupComponent.propDecorators = {
    gridRowSpan: [{ type: HostBinding, args: ['style.-ms-grid-row-span',] }],
    gridColumnSpan: [{ type: HostBinding, args: ['style.-ms-grid-column-span',] }],
    rowEnd: [{ type: HostBinding, args: ['style.grid-row-end',] }],
    colEnd: [{ type: HostBinding, args: ['style.grid-column-end',] }],
    rowStart: [{ type: HostBinding, args: ['style.-ms-grid-row',] }, { type: HostBinding, args: ['style.grid-row-start',] }],
    colStart: [{ type: HostBinding, args: ['style.-ms-grid-column',] }, { type: HostBinding, args: ['style.grid-column-start',] }],
    headerID: [{ type: HostBinding, args: ['attr.id',] }],
    column: [{ type: Input }],
    gridID: [{ type: Input }],
    active: [{ type: HostBinding, args: ['class.igx-grid__th--active',] }],
    headerCell: [{ type: ViewChild, args: [IgxGridHeaderComponent,] }],
    filterCell: [{ type: ViewChild, args: [IgxGridFilteringCellComponent,] }],
    children: [{ type: ViewChildren, args: [forwardRef(() => IgxGridHeaderGroupComponent), { read: IgxGridHeaderGroupComponent },] }],
    styleClasses: [{ type: HostBinding, args: ['class',] }],
    zIndex: [{ type: HostBinding, args: ['style.z-index',] }],
    groupDisplayStyle: [{ type: HostBinding, args: ['style.display',] }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
};

/** @hidden */
class IgxGridSummaryService {
    constructor() {
        this.rootSummaryID = 'igxGridRootSummary';
        this.summaryHeight = 0;
        this.maxSummariesLenght = 0;
        this.groupingExpressions = [];
        this.retriggerRootPipe = 0;
        this.deleteOperation = false;
        this.summaryCacheMap = new Map();
    }
    recalculateSummaries() {
        this.resetSummaryHeight();
        this.grid.notifyChanges(true);
    }
    clearSummaryCache(args) {
        if (!this.summaryCacheMap.size) {
            return;
        }
        if (!args) {
            this.summaryCacheMap.clear();
            if (this.grid && this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
            return;
        }
        if (args.data) {
            const rowID = this.grid.primaryKey ? args.data[this.grid.primaryKey] : args.data;
            this.removeSummaries(rowID);
        }
        if (args.rowID !== undefined && args.rowID !== null) {
            let columnName = args.cellID ? this.grid.columnList.find(col => col.index === args.cellID.columnID).field : undefined;
            if (columnName && this.grid.rowEditable) {
                return;
            }
            const isGroupedColumn = this.grid.groupingExpressions &&
                this.grid.groupingExpressions.map(expr => expr.fieldName).indexOf(columnName) !== -1;
            if (columnName && isGroupedColumn) {
                columnName = undefined;
            }
            this.removeSummaries(args.rowID, columnName);
        }
    }
    removeSummaries(rowID, columnName) {
        this.deleteSummaryCache(this.rootSummaryID, columnName);
        if (this.summaryCacheMap.size === 1 && this.summaryCacheMap.has(this.rootSummaryID)) {
            return;
        }
        if (this.isTreeGrid) {
            if (this.grid.transactions.enabled && this.deleteOperation) {
                this.deleteOperation = false;
                // TODO: this.removeChildRowSummaries(rowID, columnName);
                this.summaryCacheMap.clear();
                return;
            }
            this.removeAllTreeGridSummaries(rowID, columnName);
        }
        else if (this.isHierarchicalGrid) {
            if (this.grid.transactions.enabled && this.deleteOperation) {
                this.deleteOperation = false;
                this.summaryCacheMap.clear();
            }
        }
        else {
            const summaryIds = this.getSummaryID(rowID, this.grid.groupingExpressions);
            summaryIds.forEach(id => {
                this.deleteSummaryCache(id, columnName);
            });
        }
    }
    removeSummariesCachePerColumn(columnName) {
        this.summaryCacheMap.forEach((cache) => {
            if (cache.get(columnName)) {
                cache.delete(columnName);
            }
        });
        if (this.grid.rootSummariesEnabled) {
            this.retriggerRootPipe++;
        }
    }
    calcMaxSummaryHeight() {
        if (this.summaryHeight) {
            return this.summaryHeight;
        }
        if (!this.grid.data) {
            return this.summaryHeight = 0;
        }
        let maxSummaryLength = 0;
        this.grid.columnList.filter((col) => col.hasSummary && !col.hidden).forEach((column) => {
            const getCurrentSummaryColumn = column.summaries.operate([], [], column.field).length;
            if (getCurrentSummaryColumn) {
                if (maxSummaryLength < getCurrentSummaryColumn) {
                    maxSummaryLength = getCurrentSummaryColumn;
                }
            }
        });
        this.maxSummariesLenght = maxSummaryLength;
        this.summaryHeight = maxSummaryLength * this.grid.defaultSummaryHeight;
        return this.summaryHeight;
    }
    calculateSummaries(rowID, data) {
        let rowSummaries = this.summaryCacheMap.get(rowID);
        if (!rowSummaries) {
            rowSummaries = new Map();
            this.summaryCacheMap.set(rowID, rowSummaries);
        }
        if (!this.hasSummarizedColumns || !data) {
            return rowSummaries;
        }
        this.grid.columnList.filter(col => col.hasSummary).forEach((column) => {
            if (!rowSummaries.get(column.field)) {
                const summaryResult = column.summaries.operate(data.map(r => resolveNestedPath(r, column.field)), data, column.field, this.grid.locale, column.pipeArgs);
                rowSummaries.set(column.field, summaryResult);
            }
        });
        return rowSummaries;
    }
    resetSummaryHeight() {
        this.summaryHeight = 0;
        this.grid._summaryPipeTrigger++;
        if (this.grid.rootSummariesEnabled) {
            this.retriggerRootPipe++;
        }
    }
    updateSummaryCache(groupingArgs) {
        if (this.summaryCacheMap.size === 0 || !this.hasSummarizedColumns) {
            return;
        }
        if (this.groupingExpressions.length === 0) {
            this.groupingExpressions = groupingArgs.expressions.map(record => record.fieldName);
            return;
        }
        if (groupingArgs.length === 0) {
            this.groupingExpressions = [];
            this.clearSummaryCache();
            return;
        }
        this.compareGroupingExpressions(this.groupingExpressions, groupingArgs);
        this.groupingExpressions = groupingArgs.expressions.map(record => record.fieldName);
    }
    get hasSummarizedColumns() {
        const summarizedColumns = this.grid.columnList.filter(col => col.hasSummary && !col.hidden);
        return summarizedColumns.length > 0;
    }
    deleteSummaryCache(id, columnName) {
        if (this.summaryCacheMap.get(id)) {
            const filteringApplied = columnName && this.grid.filteringExpressionsTree &&
                this.grid.filteringExpressionsTree.filteringOperands.map((expr) => expr.fieldName).indexOf(columnName) !== -1;
            if (columnName && this.summaryCacheMap.get(id).get(columnName) && !filteringApplied) {
                this.summaryCacheMap.get(id).delete(columnName);
            }
            else {
                this.summaryCacheMap.delete(id);
            }
            if (id === this.rootSummaryID && this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
        }
    }
    getSummaryID(rowID, groupingExpressions) {
        if (groupingExpressions.length === 0) {
            return [];
        }
        const summaryIDs = [];
        let data = this.grid.data;
        if (this.grid.transactions.enabled) {
            data = DataUtil.mergeTransactions(cloneArray(this.grid.data), this.grid.transactions.getAggregatedChanges(true), this.grid.primaryKey);
        }
        const rowData = this.grid.primaryKey ? data.find(rec => rec[this.grid.primaryKey] === rowID) : rowID;
        let id = '{ ';
        groupingExpressions.forEach(expr => {
            id += `'${expr.fieldName}': '${rowData[expr.fieldName]}'`;
            summaryIDs.push(id.concat(' }'));
            id += ', ';
        });
        return summaryIDs;
    }
    removeAllTreeGridSummaries(rowID, columnName) {
        let row = this.grid.records.get(rowID);
        if (!row) {
            return;
        }
        row = row.children ? row : row.parent;
        while (row) {
            rowID = row.rowID;
            this.deleteSummaryCache(rowID, columnName);
            row = row.parent;
        }
    }
    // TODO: remove only deleted rows
    removeChildRowSummaries(rowID, columnName) {
    }
    compareGroupingExpressions(current, groupingArgs) {
        const newExpressions = groupingArgs.expressions.map(record => record.fieldName);
        const removedCols = groupingArgs.ungroupedColumns;
        if (current.length <= newExpressions.length) {
            const newExpr = newExpressions.slice(0, current.length).toString();
            if (current.toString() !== newExpr) {
                this.clearSummaryCache();
            }
        }
        else {
            const currExpr = current.slice(0, newExpressions.length).toString();
            if (currExpr !== newExpressions.toString()) {
                this.clearSummaryCache();
                return;
            }
            removedCols.map(col => col.field).forEach(colName => {
                this.summaryCacheMap.forEach((cache, id) => {
                    if (id.indexOf(colName) !== -1) {
                        this.summaryCacheMap.delete(id);
                    }
                });
            });
        }
    }
    get isTreeGrid() {
        return this.grid.nativeElement.tagName.toLowerCase() === 'igx-tree-grid';
    }
    get isHierarchicalGrid() {
        return this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
    }
}
IgxGridSummaryService.decorators = [
    { type: Injectable }
];

class IgxSummaryCellComponent {
    constructor(element) {
        this.element = element;
        this.firstCellIndentation = 0;
        this.hasSummary = false;
    }
    get visibleColumnIndex() {
        return this.column.visibleIndex;
    }
    get attrCellID() {
        return `${this.grid.id}_${this.rowIndex}_${this.visibleColumnIndex}`;
    }
    activate() {
        const currNode = this.grid.navigation.activeNode;
        if (currNode && this.rowIndex === currNode.row && this.visibleColumnIndex === currNode.column) {
            return;
        }
        this.grid.navigation.setActiveNode({ row: this.rowIndex, column: this.visibleColumnIndex }, 'summaryCell');
        this.grid.cdr.detectChanges();
    }
    get selectionNode() {
        return {
            row: this.rowIndex,
            column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
            isSummaryRow: true
        };
    }
    get width() {
        return this.column.getCellWidth();
    }
    get nativeElement() {
        return this.element.nativeElement;
    }
    get columnDatatype() {
        return this.column.dataType;
    }
    get itemHeight() {
        return this.column.grid.defaultSummaryHeight;
    }
    /**
     * @hidden
     */
    get grid() {
        return this.column.grid;
    }
    translateSummary(summary) {
        return this.grid.resourceStrings[`igx_grid_summary_${summary.key}`] || summary.label;
    }
}
IgxSummaryCellComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-summary-cell',
                template: "<ng-container *ngIf=\"hasSummary\">\n    <ng-container *ngFor=\"let summary of summaryResults\">\n            <div class=\"igx-grid-summary__item\" [style.height.px]=\"itemHeight\">\n\n                <ng-container *ngIf=\"visibleColumnIndex === 0 && firstCellIndentation >= 0\">\n                    <div class=\"igx-grid__tree-cell--padding-level-{{firstCellIndentation}}\"></div>\n\n                    <div #indicator class=\"igx-grid__tree-grouping-indicator\" style=\"visibility: hidden\">\n                        <igx-icon>chevron_right</igx-icon>\n                    </div>\n                </ng-container>\n\n                <span class=\"igx-grid-summary__label\" [title]=\"summary.label\">{{ translateSummary(summary) }}</span>\n                <span class=\"igx-grid-summary__result\" [title]=\"summary.summaryResult\">\n                    {{ summary.summaryResult }}\n                </span>\n            </div>\n    </ng-container>\n</ng-container>\n"
            },] }
];
IgxSummaryCellComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxSummaryCellComponent.propDecorators = {
    summaryResults: [{ type: Input }],
    column: [{ type: Input }],
    firstCellIndentation: [{ type: Input }],
    hasSummary: [{ type: Input }],
    density: [{ type: Input }],
    active: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid-summary--active',] }],
    rowIndex: [{ type: Input }, { type: HostBinding, args: ['attr.data-rowIndex',] }],
    visibleColumnIndex: [{ type: HostBinding, args: ['attr.data-visibleIndex',] }],
    attrCellID: [{ type: HostBinding, args: ['attr.id',] }],
    activate: [{ type: HostListener, args: ['pointerdown',] }]
};

class IgxSummaryRowComponent {
    constructor(gridAPI, element, cdr) {
        this.gridAPI = gridAPI;
        this.element = element;
        this.cdr = cdr;
        this.firstCellIndentation = -1;
    }
    get dataRowIndex() {
        return this.index;
    }
    get minHeight() {
        return this.grid.summaryService.calcMaxSummaryHeight() - 1;
    }
    get summaryCells() {
        const res = new QueryList();
        if (!this._summaryCells) {
            return res;
        }
        const cList = this._summaryCells.filter(c => c.nativeElement.isConnected);
        res.reset(cList);
        return res;
    }
    set summaryCells(cells) { }
    ngDoCheck() {
        this.cdr.markForCheck();
    }
    get grid() {
        return this.gridAPI.grid;
    }
    get nativeElement() {
        return this.element.nativeElement;
    }
    getColumnSummaries(columnName) {
        if (!this.summaries.get(columnName)) {
            return [];
        }
        return this.summaries.get(columnName);
    }
    /**
     * @hidden
     * @internal
     */
    isCellActive(visibleColumnIndex) {
        const node = this.grid.navigation.activeNode;
        return node ? node.row === this.index && node.column === visibleColumnIndex : false;
    }
    /**
     * @hidden
     */
    get pinnedColumns() {
        return this.grid.pinnedColumns;
    }
    /**
     * @hidden
     */
    get unpinnedColumns() {
        return this.grid.unpinnedColumns;
    }
    getContext(row) {
        return {
            $implicit: row
        };
    }
}
IgxSummaryRowComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-summary-row',
                template: "<ng-container *ngIf=\"summaries.size\">\n    <ng-container *ngIf=\"grid.summariesMargin\">\n        <div\n        class=\"igx-grid__summaries-patch\"\n        [style.min-width.px]=\"grid.summariesMargin\"\n        [style.flex-basis.px]=\"grid.summariesMargin\"\n        (pointerdown)=\"$event.preventDefault()\"\n        ></div>\n    </ng-container>\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n        <ng-container *ngTemplateOutlet=\"summaryCellTemplate; context: getContext(this)\"></ng-container>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\" [igxForSizePropName]='\"calcPixelWidth\"' #igxDirRef>\n        <igx-grid-summary-cell\n            class=\"igx-grid-summary igx-grid-summary--fw\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            role=\"cell\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [class.igx-grid-summary--pinned-last]=\"col.isLastPinned\"\n            [column]=\"col\"\n            [rowIndex]=\"index\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\"\n            [style.min-width]=\"col.getCellWidth()\"\n            [style.max-width]=\"col.getCellWidth()\"\n            [style.flex-basis]=\"col.getCellWidth()\">\n        </igx-grid-summary-cell>\n    </ng-template>\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n        <ng-container *ngTemplateOutlet=\"summaryCellTemplate; context: getContext(this)\"></ng-container>\n    </ng-container>\n</ng-container>\n\n<ng-template #summaryCellTemplate let-col>\n    <igx-grid-summary-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            role=\"cell\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            class=\"igx-grid-summary igx-grid-summary--fw igx-grid-summary--pinned\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [class.igx-grid-summary--pinned-first]=\"col.isFirstPinned\"\n            [class.igx-grid-summary--pinned-last]=\"col.isLastPinned\"\n            [column]=\"col\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [rowIndex]=\"index\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\"\n            [style.min-width]=\"col.getCellWidth()\"\n            [style.max-width]=\"col.getCellWidth()\"\n            [style.flex-basis]=\"col.getCellWidth()\"\n            [style.left]=\"col.rightPinnedOffset\">\n        </igx-grid-summary-cell>\n</ng-template>\n",
                providers: [IgxForOfSyncService]
            },] }
];
IgxSummaryRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxSummaryRowComponent.propDecorators = {
    summaries: [{ type: Input }],
    gridID: [{ type: Input }],
    index: [{ type: Input }],
    firstCellIndentation: [{ type: Input }],
    dataRowIndex: [{ type: HostBinding, args: ['attr.data-rowIndex',] }],
    _summaryCells: [{ type: ViewChildren, args: [IgxSummaryCellComponent, { read: IgxSummaryCellComponent },] }],
    virtDirRow: [{ type: ViewChild, args: ['igxDirRef', { read: IgxGridForOfDirective },] }]
};

var DragScrollDirection;
(function (DragScrollDirection) {
    DragScrollDirection[DragScrollDirection["NONE"] = 0] = "NONE";
    DragScrollDirection[DragScrollDirection["LEFT"] = 1] = "LEFT";
    DragScrollDirection[DragScrollDirection["TOP"] = 2] = "TOP";
    DragScrollDirection[DragScrollDirection["RIGHT"] = 3] = "RIGHT";
    DragScrollDirection[DragScrollDirection["BOTTOM"] = 4] = "BOTTOM";
    DragScrollDirection[DragScrollDirection["TOPLEFT"] = 5] = "TOPLEFT";
    DragScrollDirection[DragScrollDirection["TOPRIGHT"] = 6] = "TOPRIGHT";
    DragScrollDirection[DragScrollDirection["BOTTOMLEFT"] = 7] = "BOTTOMLEFT";
    DragScrollDirection[DragScrollDirection["BOTTOMRIGHT"] = 8] = "BOTTOMRIGHT";
})(DragScrollDirection || (DragScrollDirection = {}));
class IgxGridDragSelectDirective {
    constructor(ref, zone) {
        this.ref = ref;
        this.zone = zone;
        this.onDragStop = new EventEmitter();
        this.onDragScroll = new EventEmitter();
        this.end$ = new Subject();
        this.lastDirection = DragScrollDirection.NONE;
        this.startDragSelection = (ev) => {
            if (!this.activeDrag) {
                return;
            }
            const x = ev.clientX;
            const y = ev.clientY;
            const direction = this._measureDimensions(x, y);
            if (direction === this.lastDirection) {
                return;
            }
            this.unsubscribe();
            this._sub = this._interval$.subscribe(() => this.onDragScroll.emit(direction));
            this.lastDirection = direction;
        };
        this.stopDragSelection = () => {
            if (!this.activeDrag) {
                return;
            }
            this.onDragStop.emit(false);
            this.unsubscribe();
            this.lastDirection = DragScrollDirection.NONE;
        };
        this._interval$ = interval(100).pipe(takeUntil(this.end$), filter(() => this.activeDrag));
    }
    get activeDrag() {
        return this._activeDrag;
    }
    set activeDrag(val) {
        if (val !== this._activeDrag) {
            this.unsubscribe();
            this._activeDrag = val;
        }
    }
    get nativeElement() {
        return this.ref.nativeElement;
    }
    get clientRect() {
        return this.nativeElement.getBoundingClientRect();
    }
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.addEventListener('pointerover', this.startDragSelection);
            this.nativeElement.addEventListener('pointerleave', this.stopDragSelection);
        });
    }
    ngOnDestroy() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.removeEventListener('pointerover', this.startDragSelection);
            this.nativeElement.removeEventListener('pointerleave', this.stopDragSelection);
        });
        this.unsubscribe();
        this.end$.complete();
    }
    _measureDimensions(x, y) {
        let direction;
        const rect = this.clientRect;
        const RATIO = 0.15;
        const offsetX = Math.trunc(x - rect.left);
        const offsetY = Math.trunc(y - rect.top);
        const left = offsetX <= rect.width * RATIO;
        const right = offsetX >= rect.width * (1 - RATIO);
        const top = offsetY <= rect.height * RATIO;
        const bottom = offsetY >= rect.height * (1 - RATIO);
        if (top && left) {
            direction = DragScrollDirection.TOPLEFT;
        }
        else if (top && right) {
            direction = DragScrollDirection.TOPRIGHT;
        }
        else if (bottom && left) {
            direction = DragScrollDirection.BOTTOMLEFT;
        }
        else if (bottom && right) {
            direction = DragScrollDirection.BOTTOMRIGHT;
        }
        else if (top) {
            direction = DragScrollDirection.TOP;
        }
        else if (bottom) {
            direction = DragScrollDirection.BOTTOM;
        }
        else if (left) {
            direction = DragScrollDirection.LEFT;
        }
        else if (right) {
            direction = DragScrollDirection.RIGHT;
        }
        else {
            direction = DragScrollDirection.NONE;
        }
        return direction;
    }
    unsubscribe() {
        if (this._sub) {
            this._sub.unsubscribe();
        }
    }
}
IgxGridDragSelectDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxGridDragSelect]'
            },] }
];
IgxGridDragSelectDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
IgxGridDragSelectDirective.propDecorators = {
    onDragStop: [{ type: Output }],
    onDragScroll: [{ type: Output }],
    activeDrag: [{ type: Input, args: ['igxGridDragSelect',] }]
};

/**
 * @hidden
 */
class IgxTemplateOutletDirective {
    constructor(_viewContainerRef, _zone, cdr) {
        this._viewContainerRef = _viewContainerRef;
        this._zone = _zone;
        this.cdr = cdr;
        this.onViewCreated = new EventEmitter();
        this.onViewMoved = new EventEmitter();
        this.onCachedViewLoaded = new EventEmitter();
        this.onBeforeViewDetach = new EventEmitter();
        /**
         * The embedded views cache. Collection is key-value paired.
         * Key is the template id, value is the embedded view for the related template.
         */
        this._embeddedViewsMap = new Map();
    }
    ngOnChanges(changes) {
        const actionType = this._getActionType(changes);
        switch (actionType) {
            case TemplateOutletAction.CreateView:
                this._recreateView();
                break;
            case TemplateOutletAction.MoveView:
                this._moveView();
                break;
            case TemplateOutletAction.UseCachedView:
                this._useCachedView();
                break;
            case TemplateOutletAction.UpdateViewContext:
                this._updateExistingContext(this.igxTemplateOutletContext);
                break;
        }
    }
    cleanCache() {
        this._embeddedViewsMap.forEach((item) => {
            if (!item.destroyed) {
                item.destroy();
            }
        });
        this._embeddedViewsMap.clear();
    }
    cleanView(tmplID) {
        const embView = this._embeddedViewsMap.get(tmplID);
        if (embView) {
            embView.destroy();
            this._embeddedViewsMap.delete(tmplID);
        }
    }
    _recreateView() {
        const prevIndex = this._viewRef ? this._viewContainerRef.indexOf(this._viewRef) : -1;
        // detach old and create new
        if (prevIndex !== -1) {
            this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
            this._viewContainerRef.detach(prevIndex);
        }
        if (this.igxTemplateOutlet) {
            this._viewRef = this._viewContainerRef.createEmbeddedView(this.igxTemplateOutlet, this.igxTemplateOutletContext);
            this.onViewCreated.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
            const tmplId = this.igxTemplateOutletContext['templateID'];
            if (tmplId) {
                // if context contains a template id, check if we have a view for that template already stored in the cache
                // if not create a copy and add it to the cache in detached state.
                // Note: Views in detached state do not appear in the DOM, however they remain stored in memory.
                const res = this._embeddedViewsMap.get(this.igxTemplateOutletContext['templateID']);
                if (!res) {
                    this._embeddedViewsMap.set(this.igxTemplateOutletContext['templateID'], this._viewRef);
                }
            }
        }
    }
    _moveView() {
        // using external view and inserting it in current view.
        const view = this.igxTemplateOutletContext['moveView'];
        const owner = this.igxTemplateOutletContext['owner'];
        if (view !== this._viewRef) {
            if (owner._viewContainerRef.indexOf(view) !== -1) {
                // detach in case view it is attached somewhere else at the moment.
                this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                owner._viewContainerRef.detach(owner._viewContainerRef.indexOf(view));
            }
            if (this._viewRef && this._viewContainerRef.indexOf(this._viewRef) !== -1) {
                this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
            }
            this._viewRef = view;
            this._viewContainerRef.insert(view, 0);
            this._updateExistingContext(this.igxTemplateOutletContext);
            this.onViewMoved.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
        }
        else {
            this._updateExistingContext(this.igxTemplateOutletContext);
        }
    }
    _useCachedView() {
        // use view for specific template cached in the current template outlet
        const tmplID = this.igxTemplateOutletContext['templateID'];
        const cachedView = tmplID ?
            this._embeddedViewsMap.get(tmplID) :
            null;
        // if view exists, but template has been changed and there is a view in the cache with the related template
        // then detach old view and insert the stored one with the matching template
        // after that update its context.
        if (this._viewContainerRef.length > 0) {
            this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
            this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
        }
        this._viewRef = cachedView;
        const oldContext = this._cloneContext(cachedView.context);
        this._viewContainerRef.insert(this._viewRef, 0);
        this._updateExistingContext(this.igxTemplateOutletContext);
        this.onCachedViewLoaded.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext, oldContext });
    }
    _shouldRecreateView(changes) {
        const ctxChange = changes['igxTemplateOutletContext'];
        return !!changes['igxTemplateOutlet'] || (ctxChange && this._hasContextShapeChanged(ctxChange));
    }
    _hasContextShapeChanged(ctxChange) {
        const prevCtxKeys = Object.keys(ctxChange.previousValue || {});
        const currCtxKeys = Object.keys(ctxChange.currentValue || {});
        if (prevCtxKeys.length === currCtxKeys.length) {
            for (const propName of currCtxKeys) {
                if (prevCtxKeys.indexOf(propName) === -1) {
                    return true;
                }
            }
            return false;
        }
        else {
            return true;
        }
    }
    _updateExistingContext(ctx) {
        for (const propName of Object.keys(ctx)) {
            this._viewRef.context[propName] = this.igxTemplateOutletContext[propName];
        }
    }
    _cloneContext(ctx) {
        const clone = {};
        for (const propName of Object.keys(ctx)) {
            clone[propName] = ctx[propName];
        }
        return clone;
    }
    _getActionType(changes) {
        const movedView = this.igxTemplateOutletContext['moveView'];
        const tmplID = this.igxTemplateOutletContext['templateID'];
        const cachedView = tmplID ?
            this._embeddedViewsMap.get(tmplID) :
            null;
        const shouldRecreate = this._shouldRecreateView(changes);
        if (movedView) {
            // view is moved from external source
            return TemplateOutletAction.MoveView;
        }
        else if (shouldRecreate && cachedView) {
            // should recreate (template or context change) and there is a matching template in cache
            return TemplateOutletAction.UseCachedView;
        }
        else if (!this._viewRef || shouldRecreate) {
            // no view or should recreate
            return TemplateOutletAction.CreateView;
        }
        else if (this.igxTemplateOutletContext) {
            // has context, update context
            return TemplateOutletAction.UpdateViewContext;
        }
    }
}
IgxTemplateOutletDirective.decorators = [
    { type: Directive, args: [{ selector: '[igxTemplateOutlet]' },] }
];
IgxTemplateOutletDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: NgZone },
    { type: ChangeDetectorRef }
];
IgxTemplateOutletDirective.propDecorators = {
    igxTemplateOutletContext: [{ type: Input }],
    igxTemplateOutlet: [{ type: Input }],
    onViewCreated: [{ type: Output }],
    onViewMoved: [{ type: Output }],
    onCachedViewLoaded: [{ type: Output }],
    onBeforeViewDetach: [{ type: Output }]
};
var TemplateOutletAction;
(function (TemplateOutletAction) {
    TemplateOutletAction[TemplateOutletAction["CreateView"] = 0] = "CreateView";
    TemplateOutletAction[TemplateOutletAction["MoveView"] = 1] = "MoveView";
    TemplateOutletAction[TemplateOutletAction["UseCachedView"] = 2] = "UseCachedView";
    TemplateOutletAction[TemplateOutletAction["UpdateViewContext"] = 3] = "UpdateViewContext";
})(TemplateOutletAction || (TemplateOutletAction = {}));
/**
 * @hidden
 */
class IgxTemplateOutletModule {
}
IgxTemplateOutletModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxTemplateOutletDirective],
                entryComponents: [],
                exports: [IgxTemplateOutletDirective],
                imports: [CommonModule]
            },] }
];

/**
 * @hidden
 * @internal
 */
class IgxColumnResizerDirective {
    constructor(element, document, zone) {
        this.element = element;
        this.document = document;
        this.zone = zone;
        this.restrictHResizeMin = Number.MIN_SAFE_INTEGER;
        this.restrictHResizeMax = Number.MAX_SAFE_INTEGER;
        this.resizeEnd = new Subject();
        this.resizeStart = new Subject();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.resize = new Subject();
        this._destroy = new Subject();
        this.resizeStart.pipe(map((event) => event.clientX), takeUntil(this._destroy), switchMap((offset) => this.resize.pipe(map((event) => event.clientX - offset), takeUntil(this.resizeEnd), takeUntil(this._destroy)))).subscribe((pos) => {
            const left = this._left + pos;
            const min = this._left - this.restrictHResizeMin;
            const max = this._left + this.restrictHResizeMax;
            this.left = left < min ? min : left;
            if (left > max) {
                this.left = max;
            }
        });
    }
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            fromEvent(this.document.defaultView, 'mousemove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onMousemove(res));
            fromEvent(this.document.defaultView, 'mouseup').pipe(takeUntil(this._destroy))
                .subscribe((res) => this.onMouseup(res));
        });
    }
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
    }
    set left(val) {
        requestAnimationFrame(() => this.element.nativeElement.style.left = val + 'px');
    }
    set top(val) {
        requestAnimationFrame(() => this.element.nativeElement.style.top = val + 'px');
    }
    onMouseup(event) {
        this.resizeEnd.next(event);
        this.resizeEnd.complete();
    }
    onMousedown(event) {
        event.preventDefault();
        const parent = this.element.nativeElement.parentElement.parentElement;
        this.left = this._left = event.clientX - parent.getBoundingClientRect().left;
        this.top = event.target.getBoundingClientRect().top - parent.getBoundingClientRect().top;
        this.resizeStart.next(event);
    }
    onMousemove(event) {
        event.preventDefault();
        this.resize.next(event);
    }
}
IgxColumnResizerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxResizer]'
            },] }
];
IgxColumnResizerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone }
];
IgxColumnResizerDirective.propDecorators = {
    restrictHResizeMin: [{ type: Input }],
    restrictHResizeMax: [{ type: Input }],
    resizeEnd: [{ type: Output }],
    resizeStart: [{ type: Output }],
    resize: [{ type: Output }]
};

class IgxGridColumnResizerComponent {
    constructor(colResizingService) {
        this.colResizingService = colResizingService;
    }
}
IgxGridColumnResizerComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-column-resizer',
                template: "<div class=\"igx-grid__th-resize-line\"\n    [style.left.px]=\"-99999\" igxResizer\n    [style.height.px]=\"colResizingService.resizerHeight\"\n    [restrictHResizeMax]=\"colResizingService.restrictResizeMax\"\n    [restrictHResizeMin]=\"colResizingService.restrictResizeMin\"\n    (resizeEnd)=\"colResizingService.resizeColumn($event)\">\n</div>\n"
            },] }
];
IgxGridColumnResizerComponent.ctorParameters = () => [
    { type: IgxColumnResizingService }
];
IgxGridColumnResizerComponent.propDecorators = {
    resizer: [{ type: ViewChild, args: [IgxColumnResizerDirective, { static: true },] }]
};

/**
 * @hidden
 */
class IgxGridFilteringRowComponent {
    constructor(filteringService, element, cdr) {
        this.filteringService = filteringService;
        this.element = element;
        this.cdr = cdr;
        this._positionSettings = {
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom
        };
        this._conditionsOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
        };
        this._operatorsOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
        };
        this.chipAreaScrollOffset = 0;
        this._column = null;
        this.isKeyPressed = false;
        this.isComposing = false;
        this._cancelChipClick = false;
    }
    get column() {
        return this._column;
    }
    set column(val) {
        if (this._column) {
            this.expressionsList.forEach(exp => exp.isSelected = false);
        }
        if (val) {
            this._column = val;
            this.expressionsList = this.filteringService.getExpressions(this._column.field);
            this.resetExpression();
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
        }
    }
    get value() {
        return this.expression ? this.expression.searchVal : null;
    }
    set value(val) {
        if (!val && val !== 0) {
            this.expression.searchVal = null;
            this.showHideArrowButtons();
        }
        else {
            this.expression.searchVal = DataUtil.parseValue(this.column.dataType, val);
            if (this.expressionsList.find(item => item.expression === this.expression) === undefined) {
                this.addExpression(true);
            }
        }
        this.filter();
    }
    get displayDensity() {
        return this.column.grid.displayDensity === DisplayDensity.comfortable ? DisplayDensity.cosy : this.column.grid.displayDensity;
    }
    get styleClasses() {
        let classes = 'igx-grid__filtering-row';
        switch (this.column.grid.displayDensity) {
            case DisplayDensity.compact:
                classes = classes + ' igx-grid__filtering-row--compact';
                break;
            case DisplayDensity.cosy:
                classes = classes + ' igx-grid__filtering-row--cosy';
                break;
        }
        return classes;
    }
    onKeydownHandler(evt) {
        if (evt.key === "Escape" /* ESCAPE */ || evt.key === "Esc" /* ESCAPE_IE */ ||
            evt.ctrlKey && evt.shiftKey && evt.key.toLowerCase() === 'l') {
            evt.preventDefault();
            evt.stopPropagation();
            this.close();
        }
    }
    ngAfterViewInit() {
        this._conditionsOverlaySettings.outlet = this.column.grid.outlet;
        this._operatorsOverlaySettings.outlet = this.column.grid.outlet;
        const selectedItem = this.expressionsList.find(expr => expr.isSelected === true);
        if (selectedItem) {
            this.expression = selectedItem.expression;
        }
        this.input.nativeElement.focus();
    }
    get disabled() {
        return !(this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0);
    }
    get template() {
        if (this.column.dataType === DataType.Date) {
            return this.defaultDateUI;
        }
        return this.defaultFilterUI;
    }
    get type() {
        switch (this.column.dataType) {
            case DataType.String:
            case DataType.Boolean:
                return 'text';
            case DataType.Number:
            case DataType.Currency:
                return 'number';
        }
    }
    get conditions() {
        return this.column.filters.conditionList();
    }
    get isUnaryCondition() {
        if (this.expression.condition) {
            return this.expression.condition.isUnary;
        }
        else {
            return true;
        }
    }
    get placeholder() {
        if (this.expression.condition && this.expression.condition.isUnary) {
            return this.filteringService.getChipLabel(this.expression);
        }
        else if (this.column.dataType === DataType.Date) {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_date_placeholder;
        }
        else if (this.column.dataType === DataType.Boolean) {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_boolean_placeholder;
        }
        else {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_placeholder;
        }
    }
    /**
     * Event handler for keydown on the input group's prefix.
     */
    onPrefixKeyDown(event) {
        if ((event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) && this.dropDownConditions.collapsed) {
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
            event.stopImmediatePropagation();
        }
        else if (event.key === "Tab" /* TAB */ && !this.dropDownConditions.collapsed) {
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
        }
    }
    /**
     * Event handler for keydown on the input.
     */
    onInputKeyDown(event) {
        this.isKeyPressed = true;
        event.stopPropagation();
        if (this.column.dataType === DataType.Boolean) {
            if (event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) {
                this.inputGroupPrefix.nativeElement.focus();
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
                return;
            }
        }
        if (event.key === "Enter" /* ENTER */) {
            if (this.isComposing) {
                return;
            }
            this.commitInput();
        }
        else if (event.altKey && (event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */)) {
            this.inputGroupPrefix.nativeElement.focus();
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
        }
        else if (event.key === "Escape" /* ESCAPE */ || event.key === "Esc" /* ESCAPE_IE */ ||
            event.ctrlKey && event.shiftKey && event.key.toLowerCase() === 'l') {
            this.close();
        }
    }
    /**
     * Event handler for keyup on the input.
     */
    onInputKeyUp() {
        this.isKeyPressed = false;
    }
    /**
     * Event handler for input on the input.
     */
    onInput(eventArgs) {
        // The 'iskeyPressed' flag is needed for a case in IE, because the input event is fired on focus and for some reason,
        // when you have a japanese character as a placeholder, on init the value here is empty string .
        const target = eventArgs.target;
        if (isEdge() && target.type !== 'number' || this.isKeyPressed && isIE() || target.value || target.checkValidity()) {
            this.value = target.value;
        }
    }
    /**
     * Event handler for compositionstart on the input.
     */
    onCompositionStart() {
        this.isComposing = true;
    }
    /**
     * Event handler for compositionend on the input.
     */
    onCompositionEnd() {
        this.isComposing = false;
    }
    /**
     * Event handler for input click event.
     */
    onInputClick() {
        if (this.column.dataType === DataType.Boolean && this.dropDownConditions.collapsed) {
            this.inputGroupPrefix.nativeElement.focus();
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
        }
    }
    /**
     * Event handler for datepicker's close.
     */
    datePickerClose() {
        this.input.nativeElement.focus();
    }
    /**
     * Returns the filtering operation condition for a given value.
     */
    getCondition(value) {
        return this.column.filters.condition(value);
    }
    /**
     * Returns the translated condition name for a given value.
     */
    translateCondition(value) {
        return this.filteringService.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;
    }
    /**
     * Returns the icon name of the current condition.
     */
    getIconName() {
        if (this.column.dataType === DataType.Boolean && this.expression.condition === null) {
            return this.getCondition(this.conditions[0]).iconName;
        }
        else {
            return this.expression.condition.iconName;
        }
    }
    /**
     * Returns whether a given condition is selected in dropdown.
     */
    isConditionSelected(conditionName) {
        if (this.expression.condition) {
            return this.expression.condition.name === conditionName;
        }
        else {
            return false;
        }
    }
    /**
     * Clears the current filtering.
     */
    clearFiltering() {
        this.filteringService.clearFilter(this.column.field);
        this.resetExpression();
        if (this.input) {
            this.input.nativeElement.focus();
        }
        this.cdr.detectChanges();
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
    }
    /**
     * Commits the value of the input.
     */
    commitInput() {
        const selectedItem = this.expressionsList.filter(ex => ex.isSelected === true);
        selectedItem.forEach(e => e.isSelected = false);
        let indexToDeselect = -1;
        for (let index = 0; index < this.expressionsList.length; index++) {
            const expression = this.expressionsList[index].expression;
            if (expression.searchVal === null && !expression.condition.isUnary) {
                indexToDeselect = index;
            }
        }
        if (indexToDeselect !== -1) {
            this.removeExpression(indexToDeselect, this.expression);
        }
        this.resetExpression();
        this.scrollChipsWhenAddingExpression();
    }
    /**
     * Clears the value of the input.
     */
    clearInput() {
        this.value = null;
    }
    /**
     * Event handler for keydown on clear button.
     */
    onClearKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            this.clearInput();
            this.input.nativeElement.focus();
        }
    }
    /**
     * Event handler for click on clear button.
     */
    onClearClick() {
        this.clearInput();
        this.input.nativeElement.focus();
    }
    /**
     * Event handler for keydown on commit button.
     */
    onCommitKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            this.commitInput();
            this.input.nativeElement.focus();
        }
    }
    /**
     * Event handler for click on commit button.
     */
    onCommitClick() {
        this.commitInput();
        this.input.nativeElement.focus();
    }
    /**
     * Event handler for focusout on the input group.
     */
    onInputGroupFocusout() {
        if (!this.value && this.value !== 0 &&
            this.expression.condition && !this.expression.condition.isUnary) {
            return;
        }
        requestAnimationFrame(() => {
            const focusedElement = document.activeElement;
            if (focusedElement.classList.contains('igx-chip__remove') || focusedElement.tagName === 'IGX-DAY-ITEM') {
                return;
            }
            if (!(focusedElement && this.inputGroup.nativeElement.contains(focusedElement))
                && this.dropDownConditions.collapsed) {
                this.commitInput();
            }
        });
    }
    /**
     * Closes the filtering edit row.
     */
    close() {
        if (this.expressionsList.length === 1 &&
            this.expressionsList[0].expression.searchVal === null &&
            this.expressionsList[0].expression.condition.isUnary === false) {
            this.filteringService.getExpressions(this.column.field).pop();
            this.filter();
        }
        else {
            const condToRemove = this.expressionsList.filter(ex => ex.expression.searchVal === null && !ex.expression.condition.isUnary);
            if (condToRemove && condToRemove.length > 0) {
                condToRemove.forEach(c => this.filteringService.removeExpression(this.column.field, this.expressionsList.indexOf(c)));
                this.filter();
            }
        }
        this.filteringService.isFilterRowVisible = false;
        this.filteringService.updateFilteringCell(this.column);
        this.filteringService.filteredColumn = null;
        this.filteringService.selectedExpression = null;
        this.filteringService.grid.theadRow.nativeElement.focus();
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
    }
    /**
     *  Event handler for date picker's selection.
     */
    onDateSelected(value) {
        this.value = value;
    }
    /** @hidden @internal */
    inputGroupPrefixClick(event) {
        event.stopPropagation();
        event.currentTarget.focus();
        this.toggleConditionsDropDown(event.currentTarget);
    }
    /**
     * Opens the conditions dropdown.
     */
    toggleConditionsDropDown(target) {
        this._conditionsOverlaySettings.target = target;
        this._conditionsOverlaySettings.excludeFromOutsideClick = [target];
        this.dropDownConditions.toggle(this._conditionsOverlaySettings);
    }
    /**
     * Opens the logic operators dropdown.
     */
    toggleOperatorsDropDown(eventArgs, index) {
        this._operatorsOverlaySettings.target = eventArgs.target.parentElement;
        this._operatorsOverlaySettings.excludeFromOutsideClick = [eventArgs.target.parentElement];
        this.dropDownOperators.toArray()[index].toggle(this._operatorsOverlaySettings);
    }
    /**
     * Event handler for change event in conditions dropdown.
     */
    onConditionsChanged(eventArgs) {
        const value = eventArgs.newSelection.value;
        this.expression.condition = this.getCondition(value);
        if (this.expression.condition.isUnary) {
            // update grid's filtering on the next cycle to ensure the drop-down is closed
            // if the drop-down is not closed this event handler will be invoked multiple times
            requestAnimationFrame(() => this.unaryConditionChangedCallback());
        }
        else {
            requestAnimationFrame(() => this.conditionChangedCallback());
        }
        if (this.input) {
            // Add requestAnimationFrame becasue of an issue in IE, where you are still able to write in the input,
            // if it has been focused and then set to readonly.
            requestAnimationFrame(() => this.input.nativeElement.focus());
        }
    }
    onChipPointerdown(args, chip) {
        const activeElement = document.activeElement;
        this._cancelChipClick = chip.selected && activeElement &&
            this.inputGroup.nativeElement.contains(activeElement);
    }
    onChipClick(args, item) {
        if (this._cancelChipClick) {
            this._cancelChipClick = false;
            return;
        }
        this.expressionsList.forEach(ex => ex.isSelected = false);
        this.toggleChip(item);
    }
    toggleChip(item) {
        item.isSelected = !item.isSelected;
        if (item.isSelected) {
            this.expression = item.expression;
            if (this.input) {
                this.input.nativeElement.focus();
            }
        }
    }
    /**
     * Event handler for chip keydown event.
     */
    onChipKeyDown(eventArgs, item) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            eventArgs.preventDefault();
            this.toggleChip(item);
        }
    }
    /**
     * Scrolls the first chip into view if the tab key is pressed on the left arrow.
     */
    onLeftArrowKeyDown(event) {
        if (event.key === "Tab" /* TAB */) {
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
        }
    }
    /**
     * Event handler for chip removed event.
     */
    onChipRemoved(eventArgs, item) {
        const indexToRemove = this.expressionsList.indexOf(item);
        this.removeExpression(indexToRemove, item.expression);
        this.scrollChipsOnRemove();
    }
    /**
     * Event handler for logic operator changed event.
     */
    onLogicOperatorChanged(eventArgs, expression) {
        if (eventArgs.oldSelection) {
            expression.afterOperator = eventArgs.newSelection.value;
            this.expressionsList[this.expressionsList.indexOf(expression) + 1].beforeOperator = expression.afterOperator;
            // update grid's filtering on the next cycle to ensure the drop-down is closed
            // if the drop-down is not closed this event handler will be invoked multiple times
            requestAnimationFrame(() => this.filter());
        }
    }
    /**
     * Scrolls the chips into the chip area when left or right arrows are pressed.
     */
    scrollChipsOnArrowPress(arrowPosition) {
        let count = 0;
        const chipAraeChildren = this.chipsArea.element.nativeElement.children;
        const containerRect = this.container.nativeElement.getBoundingClientRect();
        if (arrowPosition === 'right') {
            for (const chip of chipAraeChildren) {
                if (Math.ceil(chip.getBoundingClientRect().right) < Math.ceil(containerRect.right)) {
                    count++;
                }
            }
            if (count < chipAraeChildren.length) {
                this.chipAreaScrollOffset -= Math.ceil(chipAraeChildren[count].getBoundingClientRect().right) -
                    Math.ceil(containerRect.right) + 1;
                this.transform(this.chipAreaScrollOffset);
            }
        }
        if (arrowPosition === 'left') {
            for (const chip of chipAraeChildren) {
                if (Math.ceil(chip.getBoundingClientRect().left) < Math.ceil(containerRect.left)) {
                    count++;
                }
            }
            if (count > 0) {
                this.chipAreaScrollOffset += Math.ceil(containerRect.left) -
                    Math.ceil(chipAraeChildren[count - 1].getBoundingClientRect().left) + 1;
                this.transform(this.chipAreaScrollOffset);
            }
        }
    }
    /**
     * @hidden
     * Resets the chips area
     * @memberof IgxGridFilteringRowComponent
     */
    resetChipsArea() {
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
        this.showHideArrowButtons();
    }
    showHideArrowButtons() {
        requestAnimationFrame(() => {
            if (this.filteringService.isFilterRowVisible) {
                const containerWidth = this.container.nativeElement.getBoundingClientRect().width;
                this.chipsAreaWidth = this.chipsArea.element.nativeElement.getBoundingClientRect().width;
                this.showArrows = this.chipsAreaWidth >= containerWidth && this.isColumnFiltered;
                // TODO: revise the cdr.detectChanges() usage here
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
            }
        });
    }
    addExpression(isSelected) {
        const exprUI = new ExpressionUI();
        exprUI.expression = this.expression;
        exprUI.beforeOperator = this.expressionsList.length > 0 ? FilteringLogic.And : null;
        exprUI.isSelected = isSelected;
        this.expressionsList.push(exprUI);
        const length = this.expressionsList.length;
        if (this.expressionsList[length - 2]) {
            this.expressionsList[length - 2].afterOperator = this.expressionsList[length - 1].beforeOperator;
        }
        this.showHideArrowButtons();
    }
    removeExpression(indexToRemove, expression) {
        if (indexToRemove === 0 && this.expressionsList.length === 1) {
            this.clearFiltering();
            return;
        }
        this.filteringService.removeExpression(this.column.field, indexToRemove);
        this.filter();
        if (this.expression === expression) {
            this.resetExpression();
        }
        this.showHideArrowButtons();
    }
    resetExpression() {
        this.expression = {
            fieldName: this.column.field,
            condition: null,
            searchVal: null,
            ignoreCase: this.column.filteringIgnoreCase
        };
        if (this.column.dataType !== DataType.Boolean) {
            this.expression.condition = this.getCondition(this.conditions[0]);
        }
        if (this.column.dataType === DataType.Date && this.input) {
            this.input.nativeElement.value = null;
        }
        this.showHideArrowButtons();
    }
    scrollChipsWhenAddingExpression() {
        const chipAraeChildren = this.chipsArea.element.nativeElement.children;
        if (!chipAraeChildren || chipAraeChildren.length === 0) {
            return;
        }
        const containerRectRight = Math.ceil(this.container.nativeElement.getBoundingClientRect().right);
        const lastChipRectRight = Math.ceil(chipAraeChildren[chipAraeChildren.length - 1].getBoundingClientRect().right);
        if (lastChipRectRight >= containerRectRight) {
            this.chipAreaScrollOffset -= lastChipRectRight - containerRectRight;
            this.transform(this.chipAreaScrollOffset);
        }
    }
    transform(offset) {
        requestAnimationFrame(() => {
            this.chipsArea.element.nativeElement.style.transform = `translate(${offset}px)`;
        });
    }
    scrollChipsOnRemove() {
        let count = 0;
        const chipAraeChildren = this.chipsArea.element.nativeElement.children;
        const containerRect = this.container.nativeElement.getBoundingClientRect();
        for (const chip of chipAraeChildren) {
            if (Math.ceil(chip.getBoundingClientRect().right) < Math.ceil(containerRect.left)) {
                count++;
            }
        }
        if (count <= 2) {
            this.chipAreaScrollOffset = 0;
        }
        else {
            const dif = chipAraeChildren[count].id === 'chip' ? count - 2 : count - 1;
            this.chipAreaScrollOffset += Math.ceil(containerRect.left) - Math.ceil(chipAraeChildren[dif].getBoundingClientRect().left) + 1;
        }
        this.transform(this.chipAreaScrollOffset);
    }
    conditionChangedCallback() {
        if (!!this.expression.searchVal || this.expression.searchVal === 0) {
            this.filter();
        }
        else if (this.value) {
            this.value = null;
        }
    }
    unaryConditionChangedCallback() {
        if (this.value) {
            this.value = null;
        }
        if (this.expressionsList.find(item => item.expression === this.expression) === undefined) {
            this.addExpression(true);
        }
        this.filter();
    }
    filter() {
        this.filteringService.filterInternal(this.column.field);
    }
    get isColumnFiltered() {
        return this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0;
    }
    get isNarrowWidth() {
        return this.element.nativeElement.offsetWidth < 432;
    }
}
IgxGridFilteringRowComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-filtering-row',
                template: "<!-- Have to apply styles inline because of the overlay outlet ... -->\n<igx-drop-down #inputGroupConditions [displayDensity]=\"displayDensity\" [height]=\"'200px'\" (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\"\n        [value]=\"condition\"\n        [selected]=\"isConditionSelected(condition)\">\n        <div class=\"igx-grid__filtering-dropdown-items\">\n            <igx-icon family=\"imx-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n            <span class=\"igx-grid__filtering-dropdown-text\">{{ translateCondition(condition) }}</span>\n        </div>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<ng-template #defaultFilterUI>\n    <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"displayDensity\" (focusout)=\"onInputGroupFocusout()\">\n        <igx-prefix #inputGroupPrefix\n                    (click)=\"inputGroupPrefixClick($event)\"\n                    (keydown)=\"onPrefixKeyDown($event)\"\n                    tabindex=\"0\"\n                    [igxDropDownItemNavigation]=\"inputGroupConditions\">\n            <igx-icon family=\"imx-icons\" [name]=\"getIconName()\"></igx-icon>\n        </igx-prefix>\n        <input\n            #input\n            igxInput\n            tabindex=\"0\"\n            [placeholder]=\"placeholder\"\n            autocomplete=\"off\"\n            [value]=\"value\"\n            (input)=\"onInput($event)\"\n            [type]=\"type\"\n            [readonly]=\"isUnaryCondition\"\n            (click)=\"onInputClick()\"\n            (compositionstart)=\"onCompositionStart()\"\n            (compositionend)=\"onCompositionEnd()\"\n            (keydown)=\"onInputKeyDown($event)\"\n            (keyup)=\"onInputKeyUp()\"/>\n            <igx-suffix *ngIf=\"value || value === 0\" >\n                <igx-icon (keydown)=\"onCommitKeyDown($event)\" (click)=\"onCommitClick()\" tabindex=\"0\">done</igx-icon>\n                <igx-icon (keydown)=\"onClearKeyDown($event)\" (click)=\"onClearClick()\" tabindex=\"0\">clear</igx-icon>\n            </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-template #defaultDateUI>\n    <igx-date-picker\n        tabindex=\"0\"\n        mode=\"dropdown\"\n        [value]=\"value\"\n        [outlet]=\"filteringService.grid.outlet\"\n        [locale]=\"filteringService.grid.locale\"\n        (onSelection)=\"onDateSelected($event)\"\n        (onClosed)=\"datePickerClose()\">\n        <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\">\n            <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"displayDensity\" (focusout)=\"onInputGroupFocusout()\">\n                <igx-prefix #inputGroupPrefix\n                            tabindex=\"0\"\n                            (click)=\"inputGroupPrefixClick($event)\"\n                            (keydown)=\"onPrefixKeyDown($event)\"\n                            [igxDropDownItemNavigation]=\"inputGroupConditions\">\n                    <igx-icon family=\"imx-icons\" [name]=\"expression.condition.iconName\"></igx-icon>\n                </igx-prefix>\n                <input #input\n                       igxInput\n                       tabindex=\"0\"\n                       (click)=\"expression.condition.isUnary ? null : openDialog(inputGroup.element.nativeElement)\"\n                       [placeholder]=\"placeholder\"\n                       autocomplete=\"off\"\n                       [value]=\"\n                            column.formatter\n                            ? (value | columnFormatter:column.formatter)\n                            : (value | date:column.pipeArgs.format:undefined:filteringService.grid.locale)\n                        \"\n                       [readonly]=\"true\"\n                       (keydown)=\"onInputKeyDown($event)\"/>\n                <igx-suffix *ngIf=\"value\">\n                    <igx-icon (keydown)=\"onCommitKeyDown($event)\" (click)=\"onCommitClick()\" tabindex=\"0\">done</igx-icon>\n                    <igx-icon (keydown)=\"onClearKeyDown($event)\" (click)=\"clearInput()\" tabindex=\"0\">clear</igx-icon>\n                </igx-suffix>\n            </igx-input-group>\n            </ng-template>\n    </igx-date-picker>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this }\"></ng-container>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-start\" *ngIf=\"showArrows\" (keydown)=\"onLeftArrowKeyDown($event)\" (click)=\"scrollChipsOnArrowPress('left')\">\n    <igx-icon>navigate_before</igx-icon>\n</button>\n\n<div #container class=\"igx-grid__filtering-row-main\">\n    <div>\n         <igx-chips-area #chipsArea>\n            <ng-container *ngFor=\"let item of expressionsList; index as i; let last = last;\" tabindex=\"0\">\n                <igx-chip #chip id='chip'\n                    (pointerdown)=\"onChipPointerdown($event, chip)\"\n                    (click)=\"onChipClick($event, item)\"\n                    (keydown)=\"onChipKeyDown($event, item)\"\n                    (remove)=\"onChipRemoved($event, item)\"\n                    [selectable]=\"false\"\n                    [selected]=\"item.isSelected\"\n                    [displayDensity]=\"displayDensity\"\n                    [removable]=\"true\">\n                    <igx-icon\n                        igxPrefix\n                        family=\"imx-icons\"\n                        [name]=\"item.expression.condition.iconName\">\n                    </igx-icon>\n                    <span>{{filteringService.getChipLabel(item.expression)}}</span>\n                </igx-chip>\n\n                <span id='operand' *ngIf=\"!last\">\n                    <button igxButton (click)=\"toggleOperatorsDropDown($event, i)\" [igxDropDownItemNavigation]=\"operators\" [displayDensity]=\"column.grid.displayDensity\">\n                        <igx-icon>expand_more</igx-icon>\n                        <span>{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n                    </button>\n                    <igx-drop-down [displayDensity]=\"column.grid.displayDensity\" #operators (onSelection)=\"onLogicOperatorChanged($event, item)\">\n                            <igx-drop-down-item [value]=\"0\" [selected]=\"item.afterOperator === 0\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_and}}</igx-drop-down-item>\n                            <igx-drop-down-item [value]=\"1\" [selected]=\"item.afterOperator === 1\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_or}}</igx-drop-down-item>\n                    </igx-drop-down>\n                </span>\n            </ng-container>\n        </igx-chips-area>\n    </div>\n</div>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-end\" *ngIf=\"showArrows\" (click)=\"scrollChipsOnArrowPress('right')\">\n    <igx-icon>navigate_next</igx-icon>\n</button>\n\n<div #buttonsContainer [ngClass]=\"isNarrowWidth ? 'igx-grid__filtering-row-editing-buttons--small' : 'igx-grid__filtering-row-editing-buttons'\">\n    <button [displayDensity]=\"column.grid.displayDensity\" [igxButton]=\"isNarrowWidth ? 'icon' : 'flat'\" igxRipple (click)=\"clearFiltering()\" [disabled]=\"disabled\" [tabindex]=\"disabled\">\n        <igx-icon>refresh</igx-icon>\n        <span>{{isNarrowWidth ? '' : filteringService.grid.resourceStrings.igx_grid_filter_row_reset}}</span>\n    </button>\n    <button #closeButton [displayDensity]=\"column.grid.displayDensity\" [igxButton]=\"isNarrowWidth ? 'icon' : 'flat'\"  igxRipple (click)=\"close()\">\n        <igx-icon>close</igx-icon>\n        <span>{{isNarrowWidth ? '' : filteringService.grid.resourceStrings.igx_grid_filter_row_close}}</span>\n    </button>\n</div>\n"
            },] }
];
IgxGridFilteringRowComponent.ctorParameters = () => [
    { type: IgxFilteringService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxGridFilteringRowComponent.propDecorators = {
    column: [{ type: Input }],
    value: [{ type: Input }],
    defaultFilterUI: [{ type: ViewChild, args: ['defaultFilterUI', { read: TemplateRef, static: true },] }],
    defaultDateUI: [{ type: ViewChild, args: ['defaultDateUI', { read: TemplateRef, static: true },] }],
    input: [{ type: ViewChild, args: ['input', { read: ElementRef },] }],
    dropDownConditions: [{ type: ViewChild, args: ['inputGroupConditions', { read: IgxDropDownComponent, static: true },] }],
    chipsArea: [{ type: ViewChild, args: ['chipsArea', { read: IgxChipsAreaComponent, static: true },] }],
    dropDownOperators: [{ type: ViewChildren, args: ['operators', { read: IgxDropDownComponent },] }],
    inputGroup: [{ type: ViewChild, args: ['inputGroup', { read: ElementRef },] }],
    inputGroupPrefix: [{ type: ViewChild, args: ['inputGroupPrefix', { read: ElementRef },] }],
    container: [{ type: ViewChild, args: ['container', { static: true },] }],
    operand: [{ type: ViewChild, args: ['operand',] }],
    closeButton: [{ type: ViewChild, args: ['closeButton', { static: true },] }],
    styleClasses: [{ type: HostBinding, args: ['class',] }],
    onKeydownHandler: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * @hidden
 * @internal
 */
class IgxColumnMovingDragDirective extends IgxDragDirective {
    constructor(element, viewContainer, zone, renderer, cdr, cms, _platformUtil) {
        super(cdr, element, viewContainer, zone, renderer, _platformUtil);
        this.element = element;
        this.viewContainer = viewContainer;
        this.zone = zone;
        this.renderer = renderer;
        this.cdr = cdr;
        this.cms = cms;
        this._ghostClass = 'igx-grid__drag-ghost-image';
        this.ghostImgIconClass = 'igx-grid__drag-ghost-image-icon';
        this.ghostImgIconGroupClass = 'igx-grid__drag-ghost-image-icon-group';
        this.columnSelectedClass = 'igx-grid__th--selected';
    }
    get column() {
        return this.data;
    }
    get draggable() {
        return this.column && (this.column.movable || (this.column.groupable && !this.column.columnGroup));
    }
    get icon() {
        return this.cms.icon;
    }
    ngOnDestroy() {
        this._unsubscribe();
    }
    onEscape(event) {
        this.cms.cancelDrop = true;
        this.onPointerUp(event);
    }
    onPointerDown(event) {
        if (!this.draggable || event.target.getAttribute('draggable') === 'false') {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._removeOnDestroy = false;
        this.cms.column = this.column;
        this.ghostClass = this._ghostClass;
        super.onPointerDown(event);
        this.cms.isColumnMoving = true;
        this.column.grid.cdr.detectChanges();
        const args = {
            source: this.column
        };
        this.column.grid.onColumnMovingStart.emit(args);
        this.subscription$ = fromEvent(this.column.grid.document.defaultView, 'keydown').subscribe((ev) => {
            if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                this.onEscape(ev);
            }
        });
    }
    onPointerMove(event) {
        event.preventDefault();
        super.onPointerMove(event);
        if (this._dragStarted && this.ghostElement && !this.column.grid.draggedColumn) {
            this.column.grid.draggedColumn = this.column;
            this.column.grid.cdr.detectChanges();
        }
        if (this.cms.isColumnMoving) {
            const args = {
                source: this.column,
                cancel: false
            };
            this.column.grid.onColumnMoving.emit(args);
            if (args.cancel) {
                this.onEscape(event);
            }
        }
    }
    onPointerUp(event) {
        // Run it explicitly inside the zone because sometimes onPointerUp executes after the code below.
        this.zone.run(() => {
            super.onPointerUp(event);
            this.cms.isColumnMoving = false;
            this.column.grid.draggedColumn = null;
            this.column.grid.cdr.detectChanges();
        });
        this._unsubscribe();
    }
    createGhost(pageX, pageY) {
        super.createGhost(pageX, pageY);
        this.ghostElement.style.height = null;
        this.ghostElement.style.minWidth = null;
        this.ghostElement.style.flexBasis = null;
        this.ghostElement.style.position = null;
        this.renderer.removeClass(this.ghostElement, this.columnSelectedClass);
        const icon = document.createElement('i');
        const text = document.createTextNode('block');
        icon.appendChild(text);
        icon.classList.add('material-icons');
        this.cms.icon = icon;
        if (!this.column.columnGroup) {
            this.renderer.addClass(icon, this.ghostImgIconClass);
            this.ghostElement.insertBefore(icon, this.ghostElement.firstElementChild);
            this.ghostLeft = this._ghostStartX = pageX - ((this.ghostElement.getBoundingClientRect().width / 3) * 2);
            this.ghostTop = this._ghostStartY = pageY - ((this.ghostElement.getBoundingClientRect().height / 3) * 2);
        }
        else {
            this.ghostElement.insertBefore(icon, this.ghostElement.childNodes[0]);
            this.renderer.addClass(icon, this.ghostImgIconGroupClass);
            this.ghostElement.children[0].style.paddingLeft = '0px';
            this.ghostLeft = this._ghostStartX = pageX - ((this.ghostElement.getBoundingClientRect().width / 3) * 2);
            this.ghostTop = this._ghostStartY = pageY - ((this.ghostElement.getBoundingClientRect().height / 3) * 2);
        }
    }
    _unsubscribe() {
        if (this.subscription$) {
            this.subscription$.unsubscribe();
            this.subscription$ = null;
        }
    }
}
IgxColumnMovingDragDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxColumnMovingDrag]',
            },] }
];
IgxColumnMovingDragDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: NgZone },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: IgxColumnMovingService },
    { type: PlatformUtil }
];
IgxColumnMovingDragDirective.propDecorators = {
    data: [{ type: Input, args: ['igxColumnMovingDrag',] }]
};

/**
 * @hidden
 */
class IgxGroupByRowTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxGroupByRowTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxGroupByRow]'
            },] }
];
IgxGroupByRowTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
class IgxGridDetailTemplateDirective {
}
IgxGridDetailTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxGridDetail]'
            },] }
];
/**
 * @hidden
 */
class IgxRowExpandedIndicatorDirective {
}
IgxRowExpandedIndicatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxRowExpandedIndicator]'
            },] }
];
/**
 * @hidden
 */
class IgxRowCollapsedIndicatorDirective {
}
IgxRowCollapsedIndicatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxRowCollapsedIndicator]'
            },] }
];
/**
 * @hidden
 */
class IgxHeaderExpandIndicatorDirective {
}
IgxHeaderExpandIndicatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxHeaderExpandedIndicator]'
            },] }
];
/**
 * @hidden
 */
class IgxHeaderCollapseIndicatorDirective {
}
IgxHeaderCollapseIndicatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxHeaderCollapsedIndicator]'
            },] }
];
/**
 * @hidden
 */
class IgxExcelStyleHeaderIconDirective {
}
IgxExcelStyleHeaderIconDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxExcelStyleHeaderIcon]'
            },] }
];
/**
 * @hidden
 */
class IgxGroupAreaDropDirective extends IgxDropDirective {
    constructor(elementRef, renderer, zone) {
        super(elementRef, renderer, zone);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        this.hovered = false;
    }
    onDragEnter(event) {
        const drag = event.detail.owner;
        const column = drag.column;
        if (!this.columnBelongsToGrid(column)) {
            return;
        }
        const grid = column.grid;
        const isGrouped = grid.groupingExpressions.findIndex((item) => item.fieldName === column.field) !== -1;
        if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {
            drag.icon.innerText = 'group_work';
            this.hovered = true;
        }
        else {
            drag.icon.innerText = 'block';
            this.hovered = false;
        }
    }
    onDragLeave(event) {
        const drag = event.detail.owner;
        const column = drag.column;
        if (!this.columnBelongsToGrid(column)) {
            return;
        }
        event.detail.owner.icon.innerText = 'block';
        this.hovered = false;
    }
    onDragDrop(event) {
        const drag = event.detail.owner;
        if (drag instanceof IgxColumnMovingDragDirective) {
            const column = drag.column;
            if (!this.columnBelongsToGrid(column)) {
                return;
            }
            const grid = column.grid;
            const isGrouped = grid.groupingExpressions.findIndex((item) => item.fieldName === column.field) !== -1;
            if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {
                grid.groupBy({ fieldName: column.field, dir: SortingDirection.Asc, ignoreCase: column.sortingIgnoreCase,
                    strategy: column.sortStrategy, groupingComparer: column.groupingComparer });
            }
        }
    }
    closestParentByAttr(elem, attr) {
        return elem.hasAttribute(attr) ?
            elem :
            this.closestParentByAttr(elem.parentElement, attr);
    }
    columnBelongsToGrid(column) {
        const elem = this.elementRef.nativeElement;
        const closestGridID = this.closestParentByAttr(elem, 'igxGroupAreaDrop').getAttribute('gridId');
        if (!column) {
            return false;
        }
        else {
            const grid = column.grid;
            if (!grid || grid.id !== closestGridID) {
                return false;
            }
            return true;
        }
    }
}
IgxGroupAreaDropDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxGroupAreaDrop]'
            },] }
];
IgxGroupAreaDropDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
IgxGroupAreaDropDirective.propDecorators = {
    hovered: [{ type: HostBinding, args: ['class.igx-drop-area--hover',] }]
};

/**
 * @hidden
 */
class ExpressionItem {
    constructor(parent) {
        this.parent = parent;
    }
}
/**
 * @hidden
 */
class ExpressionGroupItem extends ExpressionItem {
    constructor(operator, parent) {
        super(parent);
        this.operator = operator;
        this.children = [];
    }
}
/**
 * @hidden
 */
class ExpressionOperandItem extends ExpressionItem {
    constructor(expression, parent) {
        super(parent);
        this.expression = expression;
    }
}
/**
 * A component used for presenting advanced filtering UI for a Grid.
 * It is used internally in the Grid, but could also be hosted in a container outside of it.
 *
 * Example:
 * ```html
 * <igx-advanced-filtering-dialog
 *     [grid]="grid1">
 * </igx-advanced-filtering-dialog>
 * ```
 */
class IgxAdvancedFilteringDialogComponent {
    constructor(cdr) {
        this.cdr = cdr;
        /**
         * @hidden @internal
         */
        this.display = 'block';
        /**
         * @hidden @internal
         */
        this.inline = true;
        /**
         * @hidden @internal
         */
        this.selectedExpressions = [];
        /**
         * @hidden @internal
         */
        this.selectedGroups = [];
        /**
         * @hidden @internal
         */
        this.lastActiveNode = {};
        /**
         * @hidden @internal
         */
        this.columnSelectOverlaySettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: false
        };
        /**
         * @hidden @internal
         */
        this.conditionSelectOverlaySettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: false
        };
        this.destroy$ = new Subject();
        this._dblClickDelay = 200;
        this._preventChipClick = false;
        this._positionSettings = {
            horizontalStartPoint: HorizontalAlignment.Right,
            verticalStartPoint: VerticalAlignment.Top
        };
        this._overlaySettings = {
            closeOnOutsideClick: false,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings),
            scrollStrategy: new CloseScrollStrategy()
        };
    }
    /**
     * @hidden @internal
     */
    set editingInputsContainer(value) {
        if ((value && !this._editingInputsContainer) ||
            (value && this._editingInputsContainer && this._editingInputsContainer.nativeElement !== value.nativeElement)) {
            requestAnimationFrame(() => {
                this.scrollElementIntoView(value.nativeElement);
            });
        }
        this._editingInputsContainer = value;
    }
    /**
     * @hidden @internal
     */
    get editingInputsContainer() {
        return this._editingInputsContainer;
    }
    /**
     * @hidden @internal
     */
    set addModeContainer(value) {
        if ((value && !this._addModeContainer) ||
            (value && this._addModeContainer && this._addModeContainer.nativeElement !== value.nativeElement)) {
            requestAnimationFrame(() => {
                this.scrollElementIntoView(value.nativeElement);
            });
        }
        this._addModeContainer = value;
    }
    /**
     * @hidden @internal
     */
    get addModeContainer() {
        return this._addModeContainer;
    }
    /**
     * @hidden @internal
     */
    set currentGroupButtonsContainer(value) {
        if ((value && !this._currentGroupButtonsContainer) ||
            (value && this._currentGroupButtonsContainer && this._currentGroupButtonsContainer.nativeElement !== value.nativeElement)) {
            requestAnimationFrame(() => {
                this.scrollElementIntoView(value.nativeElement);
            });
        }
        this._currentGroupButtonsContainer = value;
    }
    /**
     * @hidden @internal
     */
    get currentGroupButtonsContainer() {
        return this._currentGroupButtonsContainer;
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        this._overlaySettings.outlet = this.overlayOutlet;
        this.columnSelectOverlaySettings.outlet = this.overlayOutlet;
        this.conditionSelectOverlaySettings.outlet = this.overlayOutlet;
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden @internal
     */
    get displayDensity() {
        return this.grid.displayDensity;
    }
    /**
     * @hidden @internal
     */
    get selectedColumn() {
        return this._selectedColumn;
    }
    /**
     * @hidden @internal
     */
    set selectedColumn(value) {
        const oldValue = this._selectedColumn;
        if (this._selectedColumn !== value) {
            this._selectedColumn = value;
            if (oldValue && this._selectedColumn && this._selectedColumn.dataType !== oldValue.dataType) {
                this.selectedCondition = null;
                this.searchValue = null;
                this.cdr.detectChanges();
            }
        }
    }
    /**
     * An @Input property that sets the grid.
     */
    set grid(grid) {
        this._grid = grid;
        if (this._filteringChange) {
            this._filteringChange.unsubscribe();
        }
        if (this._grid) {
            this._grid.filteringService.registerSVGIcons();
            this._filteringChange = this._grid.advancedFilteringExpressionsTreeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.init();
            });
            this.init();
        }
    }
    /**
     * Returns the grid.
     */
    get grid() {
        return this._grid;
    }
    /**
     * @hidden @internal
     */
    get filterableColumns() {
        return this.grid.columns.filter((col) => !col.columnGroup && col.filterable);
    }
    /**
     * @hidden @internal
     */
    dragStart(dragArgs) {
        if (!this._overlayComponentId) {
            dragArgs.cancel = true;
            return;
        }
        if (!this.contextMenuToggle.collapsed) {
            this.contextMenuToggle.element.style.display = 'none';
        }
    }
    /**
     * @hidden @internal
     */
    dragEnd() {
        if (!this.contextMenuToggle.collapsed) {
            this.calculateContextMenuTarget();
            this.contextMenuToggle.reposition();
            this.contextMenuToggle.element.style.display = '';
        }
    }
    /**
     * @hidden @internal
     */
    onDragMove(e) {
        const deltaX = e.nextPageX - e.pageX;
        const deltaY = e.nextPageY - e.pageY;
        e.cancel = true;
        this._overlayService.setOffset(this._overlayComponentId, deltaX, deltaY);
    }
    /**
     * @hidden @internal
     */
    addCondition(parent, afterExpression) {
        this.cancelOperandAdd();
        const operandItem = new ExpressionOperandItem({
            fieldName: null,
            condition: null,
            ignoreCase: true,
            searchVal: null
        }, parent);
        if (afterExpression) {
            const index = parent.children.indexOf(afterExpression);
            parent.children.splice(index + 1, 0, operandItem);
        }
        else {
            parent.children.push(operandItem);
        }
        this.enterExpressionEdit(operandItem);
    }
    /**
     * @hidden @internal
     */
    addAndGroup(parent, afterExpression) {
        this.addGroup(FilteringLogic.And, parent, afterExpression);
    }
    /**
     * @hidden @internal
     */
    addOrGroup(parent, afterExpression) {
        this.addGroup(FilteringLogic.Or, parent, afterExpression);
    }
    /**
     * @hidden @internal
     */
    endGroup(groupItem) {
        this.currentGroup = groupItem.parent;
    }
    /**
     * @hidden @internal
     */
    commitOperandEdit() {
        if (this.editedExpression) {
            this.editedExpression.expression.fieldName = this.selectedColumn.field;
            this.editedExpression.expression.condition = this.selectedColumn.filters.condition(this.selectedCondition);
            this.editedExpression.expression.searchVal = DataUtil.parseValue(this.selectedColumn.dataType, this.searchValue);
            this.editedExpression.columnHeader = this.selectedColumn.header;
            this.editedExpression.inEditMode = false;
            this.editedExpression = null;
        }
    }
    /**
     * @hidden @internal
     */
    cancelOperandAdd() {
        if (this.addModeExpression) {
            this.addModeExpression.inAddMode = false;
            this.addModeExpression = null;
        }
    }
    /**
     * @hidden @internal
     */
    cancelOperandEdit() {
        if (this.editedExpression) {
            this.editedExpression.inEditMode = false;
            if (!this.editedExpression.expression.fieldName) {
                this.deleteItem(this.editedExpression);
            }
            this.editedExpression = null;
        }
    }
    /**
     * @hidden @internal
     */
    operandCanBeCommitted() {
        return this.selectedColumn && this.selectedCondition &&
            (!!this.searchValue || this.selectedColumn.filters.condition(this.selectedCondition).isUnary);
    }
    /**
     * @hidden @internal
     */
    exitOperandEdit() {
        if (!this.editedExpression) {
            return;
        }
        if (this.operandCanBeCommitted()) {
            this.commitOperandEdit();
        }
        else {
            this.cancelOperandEdit();
        }
    }
    /**
     * @hidden @internal
     */
    isExpressionGroup(expression) {
        return expression instanceof ExpressionGroupItem;
    }
    /**
     * @hidden @internal
     */
    onChipRemove(expressionItem) {
        this.deleteItem(expressionItem);
    }
    /**
     * @hidden @internal
     */
    onChipClick(expressionItem) {
        this._clickTimer = setTimeout(() => {
            if (!this._preventChipClick) {
                this.onToggleExpression(expressionItem);
            }
            this._preventChipClick = false;
        }, this._dblClickDelay);
    }
    /**
     * @hidden @internal
     */
    onChipDblClick(expressionItem) {
        clearTimeout(this._clickTimer);
        this._preventChipClick = true;
        this.enterExpressionEdit(expressionItem);
    }
    /**
     * @hidden @internal
     */
    enterExpressionEdit(expressionItem) {
        this.clearSelection();
        this.exitOperandEdit();
        this.cancelOperandAdd();
        if (this.editedExpression) {
            this.editedExpression.inEditMode = false;
        }
        expressionItem.hovered = false;
        this.selectedColumn = expressionItem.expression.fieldName ?
            this.grid.getColumnByName(expressionItem.expression.fieldName) : null;
        this.selectedCondition = expressionItem.expression.condition ?
            expressionItem.expression.condition.name : null;
        this.searchValue = expressionItem.expression.searchVal;
        expressionItem.inEditMode = true;
        this.editedExpression = expressionItem;
        this.cdr.detectChanges();
        this.columnSelectOverlaySettings.target = this.columnSelect.element;
        this.columnSelectOverlaySettings.excludeFromOutsideClick = [this.columnSelect.element];
        this.columnSelectOverlaySettings.positionStrategy = new AutoPositionStrategy();
        this.conditionSelectOverlaySettings.target = this.conditionSelect.element;
        this.conditionSelectOverlaySettings.excludeFromOutsideClick = [this.conditionSelect.element];
        this.conditionSelectOverlaySettings.positionStrategy = new AutoPositionStrategy();
        if (!this.selectedColumn) {
            this.columnSelect.input.nativeElement.focus();
        }
        else if (this.selectedColumn.filters.condition(this.selectedCondition).isUnary) {
            this.conditionSelect.input.nativeElement.focus();
        }
        else {
            this.searchValueInput.nativeElement.focus();
        }
    }
    /**
     * @hidden @internal
     */
    clearSelection() {
        for (const group of this.selectedGroups) {
            group.selected = false;
        }
        this.selectedGroups = [];
        for (const expr of this.selectedExpressions) {
            expr.selected = false;
        }
        this.selectedExpressions = [];
        this.toggleContextMenu();
    }
    /**
     * @hidden @internal
     */
    enterExpressionAdd(expressionItem) {
        this.clearSelection();
        this.exitOperandEdit();
        if (this.addModeExpression) {
            this.addModeExpression.inAddMode = false;
        }
        expressionItem.inAddMode = true;
        this.addModeExpression = expressionItem;
        if (expressionItem.selected) {
            this.toggleExpression(expressionItem);
        }
    }
    /**
     * @hidden @internal
     */
    contextMenuClosed() {
        this.contextualGroup = null;
    }
    /**
     * @hidden @internal
     */
    onKeyDown(eventArgs) {
        eventArgs.stopPropagation();
        const key = eventArgs.key;
        if (!this.contextMenuToggle.collapsed && (key === "Escape" /* ESCAPE */ || key === "Esc" /* ESCAPE_IE */)) {
            this.clearSelection();
        }
        else if (key === "Escape" /* ESCAPE */ || key === "Esc" /* ESCAPE_IE */) {
            this.closeDialog();
        }
    }
    /**
     * @hidden @internal
     */
    createAndGroup() {
        this.createGroup(FilteringLogic.And);
    }
    /**
     * @hidden @internal
     */
    createOrGroup() {
        this.createGroup(FilteringLogic.Or);
    }
    /**
     * @hidden @internal
     */
    deleteFilters() {
        for (const expr of this.selectedExpressions) {
            this.deleteItem(expr);
        }
        this.clearSelection();
    }
    /**
     * @hidden @internal
     */
    onGroupClick(groupItem) {
        this.toggleGroup(groupItem);
    }
    /**
     * @hidden @internal
     */
    ungroup() {
        const selectedGroup = this.contextualGroup;
        const parent = selectedGroup.parent;
        if (parent) {
            const index = parent.children.indexOf(selectedGroup);
            parent.children.splice(index, 1, ...selectedGroup.children);
            for (const expr of selectedGroup.children) {
                expr.parent = parent;
            }
        }
        this.clearSelection();
    }
    /**
     * @hidden @internal
     */
    deleteGroup() {
        const selectedGroup = this.contextualGroup;
        const parent = selectedGroup.parent;
        if (parent) {
            const index = parent.children.indexOf(selectedGroup);
            parent.children.splice(index, 1);
        }
        else {
            this.rootGroup = null;
        }
        this.clearSelection();
    }
    /**
     * @hidden @internal
     */
    selectFilteringLogic(event) {
        this.contextualGroup.operator = event.index;
    }
    /**
     * @hidden @internal
     */
    getConditionFriendlyName(name) {
        return this.grid.resourceStrings[`igx_grid_filter_${name}`] || name;
    }
    /**
     * @hidden @internal
     */
    isDate(value) {
        return value instanceof Date;
    }
    /**
     * @hidden @internal
     */
    onExpressionsScrolled() {
        if (!this.contextMenuToggle.collapsed) {
            this.calculateContextMenuTarget();
            this.contextMenuToggle.reposition();
        }
    }
    /**
     * @hidden @internal
     */
    invokeClick(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            eventArgs.currentTarget.click();
        }
    }
    /**
     * @hidden @internal
     */
    onOutletPointerDown(event) {
        // This prevents closing the select's dropdown when clicking the scroll
        event.preventDefault();
    }
    /**
     * @hidden @internal
     */
    getConditionList() {
        return this.selectedColumn ? this.selectedColumn.filters.conditionList() : [];
    }
    /**
     * @hidden @internal
     */
    initialize(grid, overlayService, overlayComponentId) {
        this.inline = false;
        this.grid = grid;
        this._overlayService = overlayService;
        this._overlayComponentId = overlayComponentId;
    }
    /**
     * @hidden @internal
     */
    getFormatter(field) {
        return this.grid.getColumnByName(field).formatter;
    }
    /**
     * @hidden @internal
     */
    getFormat(field) {
        return this.grid.getColumnByName(field).pipeArgs.format;
    }
    /**
     * @hidden @internal
     */
    getTimezone(field) {
        return this.grid.getColumnByName(field).pipeArgs.timezone;
    }
    /**
     * @hidden @internal
     */
    setAddButtonFocus() {
        if (this.addRootAndGroupButton) {
            this.addRootAndGroupButton.nativeElement.focus();
        }
        else if (this.addConditionButton) {
            this.addConditionButton.nativeElement.focus();
        }
    }
    /**
     * @hidden @internal
     */
    context(expression, afterExpression) {
        return {
            $implicit: expression,
            afterExpression
        };
    }
    /**
     * @hidden @internal
     */
    onClearButtonClick(event) {
        this.grid.endEdit(false, event);
        this.grid.advancedFilteringExpressionsTree = null;
    }
    /**
     * @hidden @internal
     */
    closeDialog() {
        if (this._overlayComponentId) {
            this._overlayService.hide(this._overlayComponentId);
        }
        this.grid.navigation.activeNode = this.lastActiveNode;
        if (this.grid.navigation.activeNode && this.grid.navigation.activeNode.row === -1) {
            this.grid.theadRow.nativeElement.focus();
        }
    }
    /**
     * @hidden @internal
     */
    applyChanges(event) {
        this.grid.endEdit(false, event);
        this.exitOperandEdit();
        this.grid.advancedFilteringExpressionsTree = this.createExpressionsTreeFromGroupItem(this.rootGroup);
    }
    /**
     * @hidden @internal
     */
    cancelChanges() {
        if (!this._overlayComponentId) {
            this.init();
        }
        this.closeDialog();
    }
    /**
     * @hidden @internal
     */
    onApplyButtonClick(event) {
        this.applyChanges(event);
        this.closeDialog();
    }
    /**
     * @hidden @internal
     */
    onChipSelectionEnd() {
        const contextualGroup = this.findSingleSelectedGroup();
        if (contextualGroup || this.selectedExpressions.length > 1) {
            this.contextualGroup = contextualGroup;
            this.calculateContextMenuTarget();
            if (this.contextMenuToggle.collapsed) {
                this.contextMenuToggle.open(this._overlaySettings);
            }
            else {
                this.contextMenuToggle.reposition();
            }
        }
    }
    onToggleExpression(expressionItem) {
        this.exitOperandEdit();
        this.toggleExpression(expressionItem);
        this.toggleContextMenu();
    }
    toggleExpression(expressionItem) {
        expressionItem.selected = !expressionItem.selected;
        if (expressionItem.selected) {
            this.selectedExpressions.push(expressionItem);
        }
        else {
            const index = this.selectedExpressions.indexOf(expressionItem);
            this.selectedExpressions.splice(index, 1);
            this.deselectParentRecursive(expressionItem);
        }
    }
    addGroup(operator, parent, afterExpression) {
        this.cancelOperandAdd();
        const groupItem = new ExpressionGroupItem(operator, parent);
        if (parent) {
            if (afterExpression) {
                const index = parent.children.indexOf(afterExpression);
                parent.children.splice(index + 1, 0, groupItem);
            }
            else {
                parent.children.push(groupItem);
            }
        }
        else {
            this.rootGroup = groupItem;
        }
        this.addCondition(groupItem);
        this.currentGroup = groupItem;
    }
    createExpressionGroupItem(expressionTree, parent) {
        let groupItem;
        if (expressionTree) {
            groupItem = new ExpressionGroupItem(expressionTree.operator, parent);
            for (const expr of expressionTree.filteringOperands) {
                if (expr instanceof FilteringExpressionsTree) {
                    groupItem.children.push(this.createExpressionGroupItem(expr, groupItem));
                }
                else {
                    const filteringExpr = expr;
                    const exprCopy = {
                        fieldName: filteringExpr.fieldName,
                        condition: filteringExpr.condition,
                        searchVal: filteringExpr.searchVal,
                        ignoreCase: filteringExpr.ignoreCase
                    };
                    const operandItem = new ExpressionOperandItem(exprCopy, groupItem);
                    const column = this.grid.getColumnByName(filteringExpr.fieldName);
                    operandItem.columnHeader = column.header;
                    groupItem.children.push(operandItem);
                }
            }
        }
        return groupItem;
    }
    createExpressionsTreeFromGroupItem(groupItem) {
        if (!groupItem) {
            return null;
        }
        const expressionsTree = new FilteringExpressionsTree(groupItem.operator);
        for (const item of groupItem.children) {
            if (item instanceof ExpressionGroupItem) {
                const subTree = this.createExpressionsTreeFromGroupItem(item);
                expressionsTree.filteringOperands.push(subTree);
            }
            else {
                expressionsTree.filteringOperands.push(item.expression);
            }
        }
        return expressionsTree;
    }
    toggleContextMenu() {
        const contextualGroup = this.findSingleSelectedGroup();
        if (contextualGroup || this.selectedExpressions.length > 1) {
            this.contextualGroup = contextualGroup;
            if (contextualGroup) {
                this.filteringLogics = [
                    {
                        label: this.grid.resourceStrings.igx_grid_filter_operator_and,
                        selected: contextualGroup.operator === FilteringLogic.And
                    },
                    {
                        label: this.grid.resourceStrings.igx_grid_filter_operator_or,
                        selected: contextualGroup.operator === FilteringLogic.Or
                    }
                ];
            }
        }
        else if (this.contextMenuToggle) {
            this.contextMenuToggle.close();
        }
    }
    findSingleSelectedGroup() {
        for (const group of this.selectedGroups) {
            const containsAllSelectedExpressions = this.selectedExpressions.every(op => this.isInsideGroup(op, group));
            if (containsAllSelectedExpressions) {
                return group;
            }
        }
        return null;
    }
    isInsideGroup(item, group) {
        if (!item) {
            return false;
        }
        if (item.parent === group) {
            return true;
        }
        return this.isInsideGroup(item.parent, group);
    }
    deleteItem(expressionItem) {
        if (!expressionItem.parent) {
            this.rootGroup = null;
            this.currentGroup = null;
            return;
        }
        if (expressionItem === this.currentGroup) {
            this.currentGroup = this.currentGroup.parent;
        }
        const children = expressionItem.parent.children;
        const index = children.indexOf(expressionItem);
        children.splice(index, 1);
        if (!children.length) {
            this.deleteItem(expressionItem.parent);
        }
    }
    createGroup(operator) {
        const chips = this.chips.toArray();
        const minIndex = this.selectedExpressions.reduce((i, e) => Math.min(i, chips.findIndex(c => c.data === e)), Number.MAX_VALUE);
        const firstExpression = chips[minIndex].data;
        const parent = firstExpression.parent;
        const groupItem = new ExpressionGroupItem(operator, parent);
        const index = parent.children.indexOf(firstExpression);
        parent.children.splice(index, 0, groupItem);
        for (const expr of this.selectedExpressions) {
            this.deleteItem(expr);
            groupItem.children.push(expr);
            expr.parent = groupItem;
        }
        this.clearSelection();
    }
    toggleGroup(groupItem) {
        this.exitOperandEdit();
        if (groupItem.children && groupItem.children.length) {
            this.toggleGroupRecursive(groupItem, !groupItem.selected);
            if (!groupItem.selected) {
                this.deselectParentRecursive(groupItem);
            }
            this.toggleContextMenu();
        }
    }
    toggleGroupRecursive(groupItem, selected) {
        if (groupItem.selected !== selected) {
            groupItem.selected = selected;
            if (groupItem.selected) {
                this.selectedGroups.push(groupItem);
            }
            else {
                const index = this.selectedGroups.indexOf(groupItem);
                this.selectedGroups.splice(index, 1);
            }
        }
        for (const expr of groupItem.children) {
            if (expr instanceof ExpressionGroupItem) {
                this.toggleGroupRecursive(expr, selected);
            }
            else {
                const operandExpression = expr;
                if (operandExpression.selected !== selected) {
                    this.toggleExpression(operandExpression);
                }
            }
        }
    }
    deselectParentRecursive(expressionItem) {
        const parent = expressionItem.parent;
        if (parent) {
            if (parent.selected) {
                parent.selected = false;
                const index = this.selectedGroups.indexOf(parent);
                this.selectedGroups.splice(index, 1);
            }
            this.deselectParentRecursive(parent);
        }
    }
    calculateContextMenuTarget() {
        const containerRect = this.expressionsContainer.nativeElement.getBoundingClientRect();
        const chips = this.chips.filter(c => this.selectedExpressions.indexOf(c.data) !== -1);
        let minTop = chips.reduce((t, c) => Math.min(t, c.elementRef.nativeElement.getBoundingClientRect().top), Number.MAX_VALUE);
        minTop = Math.max(containerRect.top, minTop);
        minTop = Math.min(containerRect.bottom, minTop);
        let maxRight = chips.reduce((r, c) => Math.max(r, c.elementRef.nativeElement.getBoundingClientRect().right), 0);
        maxRight = Math.max(maxRight, containerRect.left);
        maxRight = Math.min(maxRight, containerRect.right);
        this._overlaySettings.target = new Point(maxRight, minTop);
    }
    scrollElementIntoView(target) {
        const container = this.expressionsContainer.nativeElement;
        const targetOffset = target.offsetTop - container.offsetTop;
        const delta = 10;
        if (container.scrollTop + delta > targetOffset) {
            container.scrollTop = targetOffset - delta;
        }
        else if (container.scrollTop + container.clientHeight < targetOffset + target.offsetHeight + delta) {
            container.scrollTop = targetOffset + target.offsetHeight + delta - container.clientHeight;
        }
    }
    init() {
        this.clearSelection();
        this.cancelOperandAdd();
        this.cancelOperandEdit();
        this.rootGroup = this.createExpressionGroupItem(this.grid.advancedFilteringExpressionsTree);
        this.currentGroup = this.rootGroup;
    }
}
IgxAdvancedFilteringDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-advanced-filtering-dialog',
                template: "<article\n    *ngIf=\"grid\"\n    class=\"igx-advanced-filter\"\n    igxDrag\n    [ghost]=\"false\"\n    [dragTolerance]=\"0\"\n    (dragStart)=\"dragStart($event)\"\n    (dragEnd)=\"dragEnd()\"\n    (dragMove)=\"onDragMove($event)\"\n    (keydown)=\"onKeyDown($event)\"\n    [ngClass]=\"{\n        'igx-advanced-filter--cosy': grid.displayDensity === 'cosy',\n        'igx-advanced-filter--compact': grid.displayDensity === 'compact',\n        'igx-advanced-filter--inline': inline\n    }\"\n>\n    <header class=\"igx-advanced-filter__header\" igxDragHandle>\n        <h4 class=\"igx-typography__h6\" style=\"pointer-events: none;\">\n            {{ grid.resourceStrings.igx_grid_advanced_filter_title }}\n        </h4>\n        <div class=\"igx-filter-legend\">\n            <div class=\"igx-filter-legend__item--and\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_and_label }}</span>\n            </div>\n            <div class=\"igx-filter-legend__item--or\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_or_label }}</span>\n            </div>\n        </div>\n    </header>\n\n    <article #expressionsContainer\n             class=\"igx-advanced-filter__main\"\n             (scroll)=\"onExpressionsScrolled()\">\n        <ng-container *ngIf=\"!rootGroup\">\n\n            <button #addRootAndGroupButton\n                igxButton=\"outlined\"\n                [displayDensity]=\"displayDensity\"\n                (click)=\"addAndGroup()\"\n            >\n                <igx-icon>add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\" [displayDensity]=\"displayDensity\" (click)=\"addOrGroup()\">\n                <igx-icon>add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n            <div class=\"igx-filter-empty\">\n                <h6 class=\"igx-filter-empty__title\">\n                    {{grid.resourceStrings.igx_grid_advanced_filter_initial_text}}\n                </h6>\n            </div>\n        </ng-container>\n\n        <ng-template #addExpressionsTemplate let-expressionItem let-afterExpression=\"afterExpression\">\n            <button #addConditionButton\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addCondition(expressionItem, afterExpression)\"\n            >\n                <igx-icon>add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_add_condition}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addAndGroup(expressionItem, afterExpression)\">\n                <igx-icon>add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addOrGroup(expressionItem, afterExpression)\">\n                <igx-icon>add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n        </ng-template>\n\n        <ng-template #filterOperandTemplate let-expressionItem>\n            <div *ngIf=\"!expressionItem.inEditMode\"\n                class=\"igx-filter-tree__expression-item\"\n                (mouseenter)=\"expressionItem.hovered = true\"\n                (mouseleave)=\"expressionItem.hovered = false\"\n                >\n                <igx-chip [data]=\"expressionItem\"\n                          [displayDensity]=\"displayDensity === 'compact' ? 'cosy' : displayDensity\"\n                          [removable]=\"true\"\n                          [selected]=\"expressionItem.selected\"\n                          (keydown)=\"invokeClick($event)\"\n                          (click)=\"onChipClick(expressionItem)\"\n                          (dblclick)=\"onChipDblClick(expressionItem)\"\n                          (remove)=\"onChipRemove(expressionItem)\"\n                          (selectedChanged)=\"onChipSelectionEnd()\"\n                    >\n                    <span igxPrefix class=\"igx-filter-tree__expression-column\">{{ expressionItem.columnHeader || expressionItem.expression.fieldName }}</span>\n                    <igx-prefix>\n                        <igx-icon family=\"imx-icons\" [name]=\"expressionItem.expression.condition.iconName\">\n                    </igx-icon>\n                    </igx-prefix>\n                    <span class=\"igx-filter-tree__expression-condition\">\n                        {{ getConditionFriendlyName(expressionItem.expression.condition.name) }}\n                    </span>\n                    <span igxSuffix *ngIf=\"!expressionItem.expression.condition.isUnary\">\n                        {{\n                            isDate(expressionItem.expression.searchVal)\n                            ? getFormatter(expressionItem.expression.fieldName)\n                                ? (expressionItem.expression.searchVal | columnFormatter:getFormatter(expressionItem.expression.fieldName))\n                                : (expressionItem.expression.searchVal | date:getFormat(expressionItem.expression.fieldName):undefined:grid.locale)\n                            : expressionItem.expression.searchVal\n                        }}\n                    </span>\n                </igx-chip>\n                <div class=\"igx-filter-tree__expression-actions\"\n                *ngIf=\"(expressionItem.selected && selectedExpressions.length === 1) || expressionItem.hovered\">\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionEdit(expressionItem)\">\n                        edit\n                    </igx-icon>\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionAdd(expressionItem)\"\n                        *ngIf=\"!expressionItem.inAddMode && (expressionItem.parent !== currentGroup || expressionItem !== currentGroup.children[currentGroup.children.length - 1])\"\n                    >\n                        add\n                    </igx-icon>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inEditMode\"\n                #editingInputsContainer\n                class=\"igx-filter-tree__inputs\"\n            >\n                <igx-select #columnSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"columnSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_column_placeholder\"\n                            [(ngModel)]=\"selectedColumn\">\n                    <igx-select-item *ngFor=\"let column of filterableColumns\" [value]=\"column\">\n                        {{column.header || column.field}}\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-select #conditionSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"conditionSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_filter_condition_placeholder\"\n                            [(ngModel)]=\"selectedCondition\"\n                            [disabled]=\"!selectedColumn\">\n                    <igx-prefix *ngIf=\"selectedColumn && conditionSelect.value && selectedColumn.filters.condition(conditionSelect.value)\">\n                        <igx-icon family=\"imx-icons\" [name]=\"selectedColumn.filters.condition(conditionSelect.value).iconName\">\n                        </igx-icon>\n                    </igx-prefix>\n                    <igx-select-item *ngFor=\"let condition of getConditionList()\" [value]=\"condition\">\n                        <div class=\"igx-grid__filtering-dropdown-items\">\n                            <igx-icon family=\"imx-icons\"\n                                      [name]=\"selectedColumn.filters.condition(condition).iconName\">\n                            </igx-icon>\n                            <span class=\"igx-grid__filtering-dropdown-text\">{{getConditionFriendlyName(condition)}}</span>\n                        </div>\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-input-group *ngIf=\"!selectedColumn || selectedColumn.dataType !== 'date'\"\n                                 type=\"box\"\n                                 [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"\n                                 [displayDensity]=\"'compact'\">\n                    <input #searchValueInput\n                           igxInput\n                           [type]=\"selectedColumn && selectedColumn.dataType === 'number' ? 'number' : 'text'\"\n                           [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_value_placeholder\"\n                           [(ngModel)]=\"searchValue\"/>\n                </igx-input-group>\n\n                <igx-date-picker *ngIf=\"selectedColumn && selectedColumn.dataType === 'date'\"\n                                 mode=\"dropdown\"\n                                 [(ngModel)]=\"searchValue\"\n                                 [locale]=\"grid.locale\"\n                                 [outlet]=\"grid.outlet\">\n                    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n                        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"'compact'\">\n                            <input #searchValueInput\n                                    igxInput\n                                    tabindex=\"0\"\n                                    (keydown)=\"invokeClick($event)\"\n                                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                                    [placeholder]=\"grid.resourceStrings.igx_grid_filter_row_date_placeholder\"\n                                    autocomplete=\"off\"\n                                    [value]=\"\n                                        selectedColumn.formatter\n                                        ? (value | columnFormatter:selectedColumn.formatter)\n                                        : (value | date:selectedColumn.pipeArgs.format:undefined:grid.locale)\n                                    \"\n                                    [readonly]=\"true\"\n                                    [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"/>\n                        </igx-input-group>\n                    </ng-template>\n                </igx-date-picker>\n\n                <div class=\"igx-filter-tree__inputs-actions\">\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            [disabled]=\"!operandCanBeCommitted()\"\n                            (click)=\"commitOperandEdit()\">\n                        <igx-icon>check</igx-icon>\n                    </button>\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            (click)=\"cancelOperandEdit()\">\n                        <igx-icon>close</igx-icon>\n                    </button>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inAddMode\"\n                #addModeContainer\n                class=\"igx-filter-tree__buttons\"\n            >\n                <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem.parent, expressionItem)\"></ng-container>\n                <button igxButton=\"icon\"\n                        [displayDensity]=\"displayDensity\"\n                        (click)=\"cancelOperandAdd()\">\n                    <igx-icon>close</igx-icon>\n                </button>\n            </div>\n\n        </ng-template>\n\n        <ng-template #expressionTreeTemplate let-expressionItem>\n            <div class=\"igx-filter-tree\">\n                <div tabindex=\"0\"\n                     class=\"igx-filter-tree__line\"\n                     [ngClass]=\"{\n                         'igx-filter-tree__line--and': expressionItem.operator === 0,\n                         'igx-filter-tree__line--or': expressionItem.operator === 1,\n                         'igx-filter-tree__line--selected': expressionItem.selected\n                     }\"\n                     (keydown)=\"invokeClick($event)\"\n                     (click)=\"onGroupClick(expressionItem)\"\n                ></div>\n\n                <div class=\"igx-filter-tree__expression\">\n                    <ng-container *ngFor=\"let expr of expressionItem.children\">\n                        <ng-container *ngTemplateOutlet=\"isExpressionGroup(expr) ? expressionTreeTemplate : filterOperandTemplate; context: context(expr)\"></ng-container>\n                    </ng-container>\n                    <div *ngIf=\"currentGroup === expressionItem\"\n                        #currentGroupButtonsContainer\n                        class=\"igx-filter-tree__buttons\">\n                        <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem)\"></ng-container>\n                        <button igxButton=\"outlined\"\n                                *ngIf=\"expressionItem !== rootGroup\"\n                                [displayDensity]=\"displayDensity\"\n                                [disabled]=\"editedExpression || expressionItem.children.length < 2\"\n                                (click)=\"endGroup(expressionItem)\">\n                            <span>{{grid.resourceStrings.igx_grid_advanced_filter_end_group}}</span>\n                        </button>\n                    </div>\n                </div>\n            </div>\n\n        </ng-template>\n\n        <ng-container *ngIf=\"rootGroup\">\n            <ng-container *ngTemplateOutlet=\"expressionTreeTemplate; context: context(rootGroup)\"></ng-container>\n        </ng-container>\n\n        <div igxToggle\n            class=\"igx-filter-contextual-menu\"\n            (keydown)=\"onKeyDown($event)\"\n            (onClosed)=\"contextMenuClosed()\"\n            [ngClass]=\"{\n                'igx-filter-contextual-menu--cosy': displayDensity === 'cosy',\n                'igx-filter-contextual-menu--compact': displayDensity === 'compact'\n            }\"\n        >\n            <button igxButton=\"icon\"\n                    class=\"igx-filter-contextual-menu__close-btn\"\n                    (click)=\"clearSelection()\"\n            >\n                <igx-icon>close</igx-icon>\n            </button>\n\n            <ng-container *ngIf=\"contextualGroup\">\n                <igx-buttongroup [displayDensity]=\"displayDensity\"\n                                 [multiSelection]=\"false\"\n                                 [values]=\"filteringLogics\"\n                                 type=\"outline\"\n                                 (selected)=\"selectFilteringLogic($event)\">\n                </igx-buttongroup>\n\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"!contextualGroup.parent\"\n                    (click)=\"ungroup()\"\n                >\n                    <igx-icon family=\"imx-icons\" name=\"ungroup\"></igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_ungroup}}</span>\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteGroup()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    <igx-icon>delete</igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_delete}}</span>\n                </button>\n            </ng-container>\n            <ng-container *ngIf=\"!contextualGroup\">\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createAndGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_and_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createOrGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_or_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteFilters()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_delete_filters}}\n                </button>\n            </ng-container>\n        </div>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick($event)\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"cancelChanges()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick($event)\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n<div #overlayOutlet\n     igxOverlayOutlet\n     class=\"igx-advanced-filter__outlet\"\n     (pointerdown)=\"onOutletPointerDown($event)\">\n</div>\n"
            },] }
];
IgxAdvancedFilteringDialogComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
IgxAdvancedFilteringDialogComponent.propDecorators = {
    columnSelect: [{ type: ViewChild, args: ['columnSelect', { read: IgxSelectComponent },] }],
    conditionSelect: [{ type: ViewChild, args: ['conditionSelect', { read: IgxSelectComponent },] }],
    searchValueInput: [{ type: ViewChild, args: ['searchValueInput', { read: ElementRef },] }],
    addRootAndGroupButton: [{ type: ViewChild, args: ['addRootAndGroupButton', { read: ElementRef },] }],
    addConditionButton: [{ type: ViewChild, args: ['addConditionButton', { read: ElementRef },] }],
    editingInputsContainer: [{ type: ViewChild, args: ['editingInputsContainer', { read: ElementRef },] }],
    addModeContainer: [{ type: ViewChild, args: ['addModeContainer', { read: ElementRef },] }],
    currentGroupButtonsContainer: [{ type: ViewChild, args: ['currentGroupButtonsContainer', { read: ElementRef },] }],
    contextMenuToggle: [{ type: ViewChild, args: [IgxToggleDirective,] }],
    chips: [{ type: ViewChildren, args: [IgxChipComponent,] }],
    display: [{ type: HostBinding, args: ['style.display',] }],
    expressionsContainer: [{ type: ViewChild, args: ['expressionsContainer',] }],
    overlayOutlet: [{ type: ViewChild, args: ['overlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    grid: [{ type: Input }]
};

/**
 * @hidden
 * @internal
 */
class IgxRowSelectorDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
IgxRowSelectorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxRowSelector]'
            },] }
];
IgxRowSelectorDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 * @internal
 */
class IgxGroupByRowSelectorDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
IgxGroupByRowSelectorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxGroupByRowSelector]'
            },] }
];
IgxGroupByRowSelectorDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 * @internal
 */
class IgxHeadSelectorDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
IgxHeadSelectorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxHeadSelector]'
            },] }
];
IgxHeadSelectorDirective.ctorParameters = () => [
    { type: TemplateRef }
];

const ghostBackgroundClass = 'igx-grid__tr--ghost';
const gridCellClass = 'igx-grid__td';
const rowSelectedClass = 'igx-grid__tr--selected';
const cellSelectedClass = 'igx-grid__td--selected';
const cellActiveClass = 'igx-grid__td--active';
/**
 * @hidden
 */
class IgxRowDragDirective extends IgxDragDirective {
    constructor() {
        super(...arguments);
        this._rowDragStarted = false;
        this.transitionEndEvent = (evt) => {
            if (this.ghostElement) {
                this.ghostElement.removeEventListener('transitionend', this.transitionEndEvent, false);
            }
            this.endDragging();
        };
    }
    get row() {
        return this.data;
    }
    onPointerDown(event) {
        event.preventDefault();
        this._rowDragStarted = false;
        this._removeOnDestroy = false;
        super.onPointerDown(event);
    }
    onPointerMove(event) {
        super.onPointerMove(event);
        if (this._dragStarted && !this._rowDragStarted) {
            this._rowDragStarted = true;
            const args = {
                dragDirective: this,
                dragData: this.row,
                cancel: false,
                owner: this.row.grid
            };
            this.row.grid.onRowDragStart.emit(args);
            if (args.cancel) {
                this.ghostElement.parentNode.removeChild(this.ghostElement);
                this.ghostElement = null;
                this._dragStarted = false;
                this._clicked = false;
                return;
            }
            this.row.grid.dragRowID = this.row.rowID;
            this.row.grid.rowDragging = true;
            this.row.grid.markForCheck();
            this.subscription$ = fromEvent(this.row.grid.document.defaultView, 'keydown').subscribe((ev) => {
                if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                    this._lastDropArea = false;
                    this.onPointerUp(event);
                }
            });
        }
    }
    onPointerUp(event) {
        if (!this._clicked) {
            return;
        }
        const args = {
            dragDirective: this,
            dragData: this.row,
            animation: false,
            owner: this.row.grid
        };
        this.zone.run(() => {
            this.row.grid.onRowDragEnd.emit(args);
        });
        const dropArea = this._lastDropArea;
        super.onPointerUp(event);
        if (!dropArea && this.ghostElement) {
            this.ghostElement.addEventListener('transitionend', this.transitionEndEvent, false);
        }
        else {
            this.endDragging();
        }
    }
    createGhost(pageX, pageY) {
        this.row.grid.endEdit(false);
        this.row.grid.markForCheck();
        this.ghostContext = {
            $implicit: this.row.rowData,
            data: this.row.rowData,
            grid: this.row.grid
        };
        super.createGhost(pageX, pageY, this.row.nativeElement);
        // check if there is an expander icon and create the ghost at the corresponding position
        if (this.isHierarchicalGrid) {
            const row = this.row;
            if (row.expander) {
                const expanderWidth = row.expander.nativeElement.getBoundingClientRect().width;
                this._ghostHostX += expanderWidth;
            }
        }
        const ghost = this.ghostElement;
        const gridRect = this.row.grid.nativeElement.getBoundingClientRect();
        const rowRect = this.row.nativeElement.getBoundingClientRect();
        ghost.style.overflow = 'hidden';
        ghost.style.width = gridRect.width + 'px';
        ghost.style.height = rowRect.height + 'px';
        this.renderer.addClass(ghost, ghostBackgroundClass);
        this.renderer.removeClass(ghost, rowSelectedClass);
        const ghostCells = ghost.getElementsByClassName(gridCellClass);
        for (const cell of ghostCells) {
            this.renderer.removeClass(cell, cellSelectedClass);
            this.renderer.removeClass(cell, cellActiveClass);
        }
    }
    _unsubscribe() {
        if (this.subscription$ && !this.subscription$.closed) {
            this.subscription$.unsubscribe();
        }
    }
    endDragging() {
        this.onTransitionEnd(null);
        this.row.grid.dragRowID = null;
        this.row.grid.rowDragging = false;
        this.row.grid.markForCheck();
        this._unsubscribe();
    }
    get isHierarchicalGrid() {
        return this.row.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
    }
}
IgxRowDragDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxRowDrag]'
            },] }
];
IgxRowDragDirective.propDecorators = {
    data: [{ type: Input, args: ['igxRowDrag',] }]
};
/**
 * @hidden
 */
class IgxDragIndicatorIconDirective {
}
IgxDragIndicatorIconDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDragIndicatorIcon]'
            },] }
];
/**
 * @hidden
 */
class IgxRowDragGhostDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
IgxRowDragGhostDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxRowDragGhost]'
            },] }
];
IgxRowDragGhostDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxRowDragModule {
}
IgxRowDragModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective],
                entryComponents: [],
                exports: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective],
                imports: []
            },] }
];

let NEXT_ID$j = 0;
/**
 * **Ignite UI for Angular Snackbar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/snackbar.html)
 *
 * The Ignite UI Snack Bar provides feedback about an operation with a single-line message, which can
 * include a link to an action such as Undo.
 *
 * Example:
 * ```html
 * <button (click)="snackbar.show()">Send message</button>
 * <div>
 *   <igx-snackbar #snackbar message="Message sent">
 *   </igx-snackbar>
 * </div>
 * ```
 */
class IgxSnackbarComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the snackbar.
         * If not set, the `id` of the first snackbar component  will be `"igx-snackbar-0"`;
         * ```html
         * <igx-snackbar id = "Snackbar1"></igx-snackbar>
         * ```
         * ```typescript
         * let snackbarId = this.snackbar.id;
         * ```
         *
         * @memberof IgxSnackbarComponent
         */
        this.id = `igx-snackbar-${NEXT_ID$j++}`;
        /**
         * Enables/Disables the visibility of the snackbar.
         * If not set, the `isVisible` attribute will have value `false`.
         * ```html
         * <igx-snackbar [isVisible] = "true"></igx-snackbar>
         * ```
         * ```typescript
         * let isVisible =  this.snackbar.isVisible;
         * ```
         */
        this.isVisible = false;
        /**
         * Sets/gets if the snackbar will be automatically hidden after the `displayTime` is over.
         * Default value is `true`.
         * ```html
         * <igx-snackbar [autoHide] = "false"></igx-snackbar>
         * ```
         * ```typescript
         * let autoHide =  this.snackbar.autoHide;
         * ```
         */
        this.autoHide = true;
        /**
         * Sets/gets the duration of time(in milliseconds) in which the snackbar will be visible after it is being shown.
         * Default value is 4000.
         * ```html
         * <igx-snackbar [displayTime] = "2000"></igx-snackbar>
         * ```
         * ```typescript
         * let displayTime = this.snackbar.displayTime;
         * ```
         */
        this.displayTime = 4000;
        /**
         * An event that will be emitted when the action button is clicked.
         * Provides reference to the `IgxSnackbarComponent` as an argument.
         * ```html
         * <igx-snackbar (clicked)="clickedHandler($event)"></igx-snackbar>
         * ```
         */
        this.clicked = new EventEmitter();
        /**
         * An event that will be emitted when the snackbar animation starts.
         * Provides reference to the `AnimationEvent` interface as an argument.
         * ```html
         * <igx-snackbar (animationStarted) = "animationStarted($event)"></igx-snackbar>
         * ```
         */
        this.animationStarted = new EventEmitter();
        /**
         * An event that will be emitted when the snackbar animation ends.
         * Provides reference to the `AnimationEvent` interface as an argument.
         * ```html
         * <igx-snackbar (animationDone) = "animationDone($event)"></igx-snackbar>
         * ```
         */
        this.animationDone = new EventEmitter();
        /**
         * @hidden
         * @internal
         */
        this.snackbarMessage = '';
    }
    /**
     * Sets/gets the `message` attribute.
     * ```html
     * <igx-snackbar [message] = "'Snackbar Component'"></igx-snackbar>
     * ```
     * ```typescript
     * let message =  this.snackbar.message;
     * ```
     */
    set message(value) {
        this.snackbarMessage = value;
    }
    get message() {
        return this.snackbarMessage;
    }
    /**
     * @deprecated
     * Shows the snackbar and hides it after the `displayTime` is over if `autoHide` is set to `true`.
     * ```typescript
     * this.snackbar.show();
     * ```
     */
    show(message) {
        this.open(message);
    }
    /**
     * @deprecated
     * Hides the snackbar.
     * ```typescript
     * this.snackbar.hide();
     * ```
     */
    hide() {
        this.close();
    }
    /**
     * Shows the snackbar and hides it after the `displayTime` is over if `autoHide` is set to `true`.
     * ```typescript
     * this.snackbar.open();
     * ```
     */
    open(message) {
        clearTimeout(this.timeoutId);
        if (message !== undefined) {
            this.snackbarMessage = message;
        }
        setTimeout(this.timeoutId);
        this.isVisible = true;
        if (this.autoHide) {
            this.timeoutId = setTimeout(() => {
                this.close();
            }, this.displayTime);
        }
    }
    /**
     * Hides the snackbar.
     * ```typescript
     * this.snackbar.close();
     * ```
     */
    close() {
        this.isVisible = false;
        clearTimeout(this.timeoutId);
    }
    /**
     * @hidden
     */
    triggerAction() {
        this.clicked.emit(this);
    }
    /**
     * @hidden
     * @memberof IgxSnackbarComponent
     */
    snackbarAnimationStarted(evt) {
        if (evt.phaseName === 'start') {
            this.animationStarted.emit(evt);
        }
    }
    /**
     * @hidden
     * @memberof IgxSnackbarComponent
     */
    snackbarAnimationDone(evt) {
        if (evt.phaseName === 'done') {
            this.animationDone.emit(evt);
        }
    }
}
IgxSnackbarComponent.decorators = [
    { type: Component, args: [{
                animations: [
                    trigger('slideInOut', [
                        transition('void => *', [
                            useAnimation(slideInBottom, {
                                params: {
                                    duration: '.35s',
                                    easing: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
                                    fromPosition: 'translateY(100%)',
                                    toPosition: 'translateY(0)'
                                }
                            })
                        ]),
                        transition('* => void', [
                            useAnimation(slideOutBottom, {
                                params: {
                                    duration: '.2s',
                                    easing: 'cubic-bezier(0.4, 0.0, 1, 1)',
                                    fromPosition: 'translateY(0)',
                                    toOpacity: 1,
                                    toPosition: 'translateY(100%)'
                                }
                            })
                        ])
                    ]),
                    trigger('fadeInOut', [
                        transition('void => *', [
                            useAnimation(fadeIn, {
                                params: {
                                    duration: '.35s',
                                    easing: 'ease-out'
                                }
                            })
                        ]),
                        transition('* => void', [
                            useAnimation(fadeOut, {
                                params: {
                                    duration: '.2s',
                                    easing: 'ease-out'
                                }
                            })
                        ])
                    ])
                ],
                selector: 'igx-snackbar',
                template: "<div class=\"igx-snackbar\" *ngIf=\"isVisible\" (@slideInOut.start)=\"snackbarAnimationStarted($event)\" (@slideInOut.done)=\"snackbarAnimationDone($event)\"\n    [@slideInOut]=\"isVisible\">\n    <div class=\"igx-snackbar__message\" [@fadeInOut]=\"isVisible\">\n        {{ snackbarMessage }}\n        <ng-content></ng-content>\n    </div>\n    <button class=\"igx-snackbar__button\" igxRipple=\"white\" *ngIf=\"actionText\" [@fadeInOut] (click)=\"triggerAction()\">\n        {{ actionText }}\n    </button>\n</div>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            },] }
];
IgxSnackbarComponent.ctorParameters = () => [];
IgxSnackbarComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    message: [{ type: Input }],
    isVisible: [{ type: Input }],
    autoHide: [{ type: Input }],
    displayTime: [{ type: Input }],
    actionText: [{ type: Input }],
    clicked: [{ type: Output }],
    animationStarted: [{ type: Output }],
    animationDone: [{ type: Output }]
};
__decorate([
    DeprecateProperty(`'message' property is deprecated.
    You can use place the message in the snackbar content or pass a message parameter to the show method instead.`)
], IgxSnackbarComponent.prototype, "message", null);
__decorate([
    DeprecateMethod(`'show' is deprecated. Use 'open' method instead.`)
], IgxSnackbarComponent.prototype, "show", null);
__decorate([
    DeprecateMethod(`'hide' is deprecated. Use 'close' method instead.`)
], IgxSnackbarComponent.prototype, "hide", null);
/**
 * @hidden
 */
class IgxSnackbarModule {
}
IgxSnackbarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxSnackbarComponent],
                exports: [IgxSnackbarComponent],
                imports: [CommonModule]
            },] }
];

let FAKE_ROW_ID = -1;
const MINIMUM_COLUMN_WIDTH = 136;
const FILTER_ROW_HEIGHT = 50;
// By default row editing overlay outlet is inside grid body so that overlay is hidden below grid header when scrolling.
// In cases when grid has 1-2 rows there isn't enough space in grid body and row editing overlay should be shown above header.
// Default row editing overlay height is higher then row height that is why the case is valid also for row with 2 rows.
// More accurate calculation is not possible, cause row editing overlay is still not shown and we don't know its height,
// but in the same time we need to set row editing overlay outlet before opening the overlay itself.
const MIN_ROW_EDITING_COUNT_THRESHOLD = 2;
const IgxGridTransaction = new InjectionToken('IgxGridTransaction');
class IgxGridBaseDirective extends DisplayDensityBase {
    constructor(selectionService, crudService, colResizingService, gridAPI, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId) {
        super(_displayDensityOptions);
        this.selectionService = selectionService;
        this.crudService = crudService;
        this.colResizingService = colResizingService;
        this.gridAPI = gridAPI;
        this._transactions = _transactions;
        this.elementRef = elementRef;
        this.zone = zone;
        this.document = document;
        this.cdr = cdr;
        this.resolver = resolver;
        this.differs = differs;
        this.viewRef = viewRef;
        this.navigation = navigation;
        this.filteringService = filteringService;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        this.localeId = localeId;
        /**
         * Gets/Sets the display time for the row adding snackbar notification.
         *
         * @remarks
         * By default it is 6000ms.
         */
        this.snackbarDisplayTime = 6000;
        /**
         * Gets/Sets whether to autogenerate the columns.
         *
         * @remarks
         * The default value is false. When set to true, it will override all columns declared through code or in markup.
         * @example
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.autoGenerate = false;
        /**
         * Controls the copy behavior of the grid.
         */
        this.clipboardOptions = {
            /**
             * Enables/disables the copy behavior
             */
            enabled: true,
            /**
             * Include the columns headers in the clipboard output.
             */
            copyHeaders: true,
            /**
             * Apply the columns formatters (if any) on the data in the clipboard output.
             */
            copyFormatters: true,
            /**
             * The separator used for formatting the copy output. Defaults to `\t`.
             */
            separator: '\t'
        };
        /**
         * Emitted after filtering is performed.
         *
         * @remarks
         * Returns the filtering expressions tree of the column for which filtering was performed.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
         *              (filteringExpressionsTreeChange)="filteringExprTreeChange($event)"></igx-grid>
         * ```
         */
        this.filteringExpressionsTreeChange = new EventEmitter();
        /**
         * Emitted after advanced filtering is performed.
         *
         * @remarks
         * Returns the advanced filtering expressions tree.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
         *           (advancedFilteringExpressionsTreeChange)="advancedFilteringExprTreeChange($event)"></igx-grid>
         * ```
         */
        this.advancedFilteringExpressionsTreeChange = new EventEmitter();
        /**
         * Emitted when grid is scrolled horizontally/vertically.
         *
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
         *              (onScroll)="onScroll($event)"></igx-grid>
         * ```
         */
        this.onScroll = new EventEmitter();
        /**
         * Emitted after the current page is changed.
         *
         * @example
         * ```html
         * <igx-grid (pageChange)="onPageChange($event)"></igx-grid>
         * ```
         * ```typescript
         * public onPageChange(page: number) {
         *   this.currentPage = page;
         * }
         * ```
         */
        this.pageChange = new EventEmitter();
        /**
         * Emitted when `perPage` property value of the grid is changed.
         *
         * @example
         * ```html
         * <igx-grid #grid (perPageChange)="onPerPageChange($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * public onPerPageChange(perPage: number) {
         *   this.perPage = perPage;
         * }
         * ```
         */
        this.perPageChange = new EventEmitter();
        /**
         * @hidden
         * @internal
         */
        this.class = '';
        /**
         * Gets/Sets the styling classes applied to all even `IgxGridRowComponent`s in the grid.
         *
         * @example
         * ```html
         * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-even-class'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.evenRowCSS = 'igx-grid__tr--even';
        /**
         * Gets/Sets the styling classes applied to all odd `IgxGridRowComponent`s in the grid.
         *
         * @example
         * ```html
         * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-odd-class'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.oddRowCSS = 'igx-grid__tr--odd';
        /**
         * Emitted when `IgxGridCellComponent` is clicked.
         *
         * @remarks
         * Returns the `IgxGridCellComponent`.
         * @example
         * ```html
         * <igx-grid #grid (onCellClick)="onCellClick($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onCellClick = new EventEmitter();
        /**
         * Emitted when `IgxGridCellComponent` is selected.
         *
         * @remarks
         *  Returns the `IgxGridCellComponent`.
         * @example
         * ```html
         * <igx-grid #grid (onSelection)="onCellSelect($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         *  Emitted when `IgxGridRowComponent` is selected.
         *
         * @example
         * ```html
         * <igx-grid #grid (onRowSelectionChange)="onCellClickChange($event)" [data]="localData" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowSelectionChange = new EventEmitter();
        /**
         *  Emitted when `IgxColumnComponent` is selected.
         *
         * @example
         * ```html
         * <igx-grid #grid (onColumnSelectionChange)="onColumnSelectionChange($event)" [data]="localData" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onColumnSelectionChange = new EventEmitter();
        /**
         * Emitted before `IgxColumnComponent` is pinned.
         *
         * @remarks
         * The index at which to insert the column may be changed through the `insertAtIndex` property.
         * @example
         * ```typescript
         * public columnPinning(event) {
         *     if (event.column.field === "Name") {
         *       event.insertAtIndex = 0;
         *     }
         * }
         * ```
         */
        this.onColumnPinning = new EventEmitter();
        /**
         * Emitted after `IgxColumnComponent` is pinned.
         *
         * @remarks
         * The index that the column is inserted at may be changed through the `insertAtIndex` property.
         * @example
         * ```typescript
         * public columnPinning(event) {
         *     if (event.column.field === "Name") {
         *       event.insertAtIndex = 0;
         *     }
         * }
         * ```
         */
        this.columnPinned = new EventEmitter();
        /**
         * Emitted when cell enters edit mode.
         *
         * @remarks
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (cellEditEnter)="editStart($event)" [data]="data" [primaryKey]="'ProductID'">
         * </igx-grid>
         * ```
         */
        this.cellEditEnter = new EventEmitter();
        /**
         * Emitted when cell exits edit mode.
         *
         * @example
         * ```html
         * <igx-grid #grid3 (cellEditExit)="editExit($event)" [data]="data" [primaryKey]="'ProductID'">
         * </igx-grid>
         * ```
         */
        this.cellEditExit = new EventEmitter();
        /**
         * Emitted when cell has been edited.
         *
         * @remarks
         * Event is fired after editing is completed, when the cell is exiting edit mode.
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (cellEdit)="editDone($event)" [data]="data" [primaryKey]="'ProductID'">
         * </igx-grid>
         * ```
         */
        this.cellEdit = new EventEmitter();
        /**
         * Emitted after cell has been edited and editing has been committed.
         *
         * @example
         * ```html
         * <igx-grid #grid3 (cellEditDone)="editDone($event)" [data]="data" [primaryKey]="'ProductID'">
         * </igx-grid>
         * ```
         */
        this.cellEditDone = new EventEmitter();
        /**
         * Emitted when a row enters edit mode.
         *
         * @remarks
         * Emitted when [rowEditable]="true".
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (rowEditEnter)="editStart($event)" [primaryKey]="'ProductID'" [rowEditable]="true">
         * </igx-grid>
         * ```
         */
        this.rowEditEnter = new EventEmitter();
        /**
         * Emitted when exiting edit mode for a row.
         *
         * @remarks
         * Emitted when [rowEditable]="true" & `endEdit(true)` is called.
         * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,
         * performing paging operation, column resizing, pinning, moving or hitting `Done`
         * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (rowEdit)="editDone($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
         * </igx-grid>
         * ```
         */
        this.rowEdit = new EventEmitter();
        /**
         * Emitted after exiting edit mode for a row and editing has been committed.
         *
         * @remarks
         * Emitted when [rowEditable]="true" & `endEdit(true)` is called.
         * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,
         * performing paging operation, column resizing, pinning, moving or hitting `Done`
         * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.
         * @example
         * ```html
         * <igx-grid #grid3 (rowEditDone)="editDone($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
         * </igx-grid>
         * ```
         */
        this.rowEditDone = new EventEmitter();
        /**
         * Emitted when row editing is canceled.
         *
         * @remarks
         * Emits when [rowEditable]="true" & `endEdit(false)` is called.
         * Emitted when changing hitting `Esc` key during cell editing and when click on the `Cancel` button
         * in the row editing overlay.
         * @example
         * ```html
         * <igx-grid #grid3 (rowEditExit)="editExit($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
         * </igx-grid>
         * ```
         */
        this.rowEditExit = new EventEmitter();
        /**
         * Emitted when a column is initialized.
         *
         * @remarks
         * Returns the column object.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [onColumnInit]="initColumns($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onColumnInit = new EventEmitter();
        /**
         * Emitted before sorting expressions are applied.
         *
         * @remarks
         * Returns an `ISortingEventArgs` object. `sortingExpressions` key holds the sorting expressions.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [autoGenerate]="true" (onSorting)="sorting($event)"></igx-grid>
         * ```
         */
        this.sorting = new EventEmitter();
        /**
         * Emitted after sorting is completed.
         *
         * @remarks
         * Returns the sorting expression.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [autoGenerate]="true" (onSortingDone)="sortingDone($event)"></igx-grid>
         * ```
         */
        this.onSortingDone = new EventEmitter();
        /**
         * Emitted before filtering expressions are applied.
         *
         * @remarks
         * Returns an `IFilteringEventArgs` object. `filteringExpressions` key holds the filtering expressions for the column.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (filtering)="filtering($event)"></igx-grid>
         * ```
         */
        this.filtering = new EventEmitter();
        /**
         * Emitted after filtering is performed through the UI.
         *
         * @remarks
         * Returns the filtering expressions tree of the column for which filtering was performed.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onFilteringDone)="filteringDone($event)"></igx-grid>
         * ```
         */
        this.onFilteringDone = new EventEmitter();
        /**
         * Emitted after paging is performed.
         *
         * @remarks
         * Returns an object consisting of the previous and next pages.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onPagingDone)="pagingDone($event)"></igx-grid>
         * ```
         */
        this.onPagingDone = new EventEmitter();
        /**
         * Emitted when a row added through the API.
         *
         * @remarks
         * Returns the data for the new `IgxGridRowComponent` object.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onRowAdded)="rowAdded($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowAdded = new EventEmitter();
        /**
         * Emitted when a row is deleted through API.
         *
         * @remarks
         * Returns an `IRowDataEventArgs` object.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onRowDeleted)="rowDeleted($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowDeleted = new EventEmitter();
        /**
         * Emitted after column is resized.
         *
         * @remarks
         * Returns the `IgxColumnComponent` object's old and new width.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onColumnResized)="resizing($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onColumnResized = new EventEmitter();
        /**
         * Emitted when a cell is right clicked.
         *
         * @remarks
         * Returns the `IgxGridCellComponent` object.
         * ```html
         * <igx-grid #grid [data]="localData" (onContextMenu)="contextMenu($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onContextMenu = new EventEmitter();
        /**
         * Emitted when a cell is double clicked.
         *
         * @remarks
         * Returns the `IgxGridCellComponent` object.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onDoubleClick)="dblClick($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onDoubleClick = new EventEmitter();
        /**
         * Emitted before column visibility is changed.
         *
         * @remarks
         * Args: { column: any, newValue: boolean }
         * @example
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (columnVisibilityChanging)="visibilityChanging($event)"></igx-grid>
         * ```
         */
        this.columnVisibilityChanging = new EventEmitter();
        /**
         * Emitted after column visibility is changed.
         *
         * @remarks
         * Args: { column: IgxColumnComponent, newValue: boolean }
         * @example
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnVisibilityChanged)="visibilityChanged($event)"></igx-grid>
         * ```
         */
        this.onColumnVisibilityChanged = new EventEmitter();
        /**
         * Emitted when column moving starts.
         *
         * @remarks
         * Returns the moved `IgxColumnComponent` object.
         * @example
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingStart)="movingStart($event)"></igx-grid>
         * ```
         */
        this.onColumnMovingStart = new EventEmitter();
        /**
         * Emitted during the column moving operation.
         *
         * @remarks
         * Returns the source and target `IgxColumnComponent` objects. This event is cancelable.
         * @example
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMoving)="moving($event)"></igx-grid>
         * ```
         */
        this.onColumnMoving = new EventEmitter();
        /**
         * Emitted when column moving ends.
         *
         * @remarks
         * Returns the source and target `IgxColumnComponent` objects.
         * @example
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingEnd)="movingEnds($event)"></igx-grid>
         * ```
         */
        this.onColumnMovingEnd = new EventEmitter();
        /**
         * Emitted when keydown is triggered over element inside grid's body.
         *
         * @remarks
         * This event is fired only if the key combination is supported in the grid.
         * Return the target type, target object and the original event. This event is cancelable.
         * @example
         * ```html
         *  <igx-grid (onGridKeydown)="customKeydown($event)"></igx-grid>
         * ```
         */
        this.onGridKeydown = new EventEmitter();
        /**
         * Emitted when start dragging a row.
         *
         * @remarks
         * Return the dragged row.
         */
        this.onRowDragStart = new EventEmitter();
        /**
         * Emitted when dropping a row.
         *
         * @remarks
         * Return the dropped row.
         */
        this.onRowDragEnd = new EventEmitter();
        /**
         * Emitted when a copy operation is executed.
         *
         * @remarks
         * Fired only if copy behavior is enabled through the [`clipboardOptions`]{@link IgxGridBaseDirective#clipboardOptions}.
         */
        this.onGridCopy = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.expansionStatesChange = new EventEmitter();
        /**
         * Emitted when the expanded state of a row gets changed.
         *
         * @example
         * ```html
         * <igx-grid [data]="employeeData" (onRowToggle)="rowToggle($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowToggle = new EventEmitter();
        /**
         * Emitted when the pinned state of a row is changed.
         *
         * @example
         * ```html
         * <igx-grid [data]="employeeData" (onRowPinning)="rowPin($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowPinning = new EventEmitter();
        /**
         * Emmited when the active node is changed.
         *
         * @example
         * ```
         * <igx-grid [data]="data" [autoGenerate]="true" (activeNodeChange)="activeNodeChange($event)"></igx-grid>
         * ```
         */
        this.activeNodeChange = new EventEmitter();
        /**
         * Emitted before sorting is performed.
         *
         * @remarks
         * Returns the sorting expressions.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [autoGenerate]="true" (sortingExpressionsChange)="sortingExprChange($event)"></igx-grid>
         * ```
         */
        this.sortingExpressionsChange = new EventEmitter();
        /**
         * Emitted when an export process is initiated by the user.
         *
         * @example
         * ```typescript
         * toolbarExporting(event: IGridToolbarExportEventArgs){
         *     const toolbarExporting = event;
         * }
         * ```
         */
        this.onToolbarExporting = new EventEmitter();
        /* End of toolbar related definitions */
        /**
         * Emitted when making a range selection.
         *
         * @remarks
         * Range selection can be made either through drag selection or through keyboard selection.
         */
        this.onRangeSelection = new EventEmitter();
        /** Emitted after the ngAfterViewInit hook. At this point the grid exists in the DOM */
        this.rendered = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.columnList = new QueryList();
        /**
         * @hidden @internal
         */
        this.tmpOutlets = new QueryList();
        /**
         * The custom template, if any, that should be used when rendering a row expand indicator.
         */
        this.rowExpandedIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a row collapse indicator.
         */
        this.rowCollapsedIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a header expand indicator.
         */
        this.headerExpandIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a header collapse indicator.
         */
        this.headerCollapseIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a row expand indicator.
         */
        this.excelStyleHeaderIconTemplate = null;
        /**
         * @hidden @internal
         */
        this.tabindex = 0;
        /**
         * @hidden @internal
         */
        this.hostRole = 'grid';
        /**
         * @hidden @internal
         */
        this.cancelAddMode = false;
        /**
         * @hidden
         * @internal
         */
        this.rowDragging = false;
        /**
         * Gets the row ID that is being dragged.
         *
         * @remarks
         * The row ID is either the primaryKey value or the data record instance.
         */
        this.dragRowID = null;
        /**
         * @hidden @interal
         */
        this.addRowParent = null;
        /**
         * @hidden @internal
         */
        this.snackbarActionText = this.resourceStrings.igx_grid_snackbar_addrow_actiontext;
        /**
         * @hidden @internal
         */
        this.snackbarLabel = this.resourceStrings.igx_grid_snackbar_addrow_label;
        /**
         * @hidden @internal
         */
        this.calcHeight = 0;
        /**
         * @hidden @internal
         */
        this.chipsGoupingExpressions = [];
        /**
         * @hidden @internal
         */
        this.disableTransitions = false;
        /**
         * @hidden @internal
         */
        this.lastSearchInfo = {
            searchText: '',
            caseSensitive: false,
            exactMatch: false,
            activeMatchIndex: 0,
            matchInfoCache: []
        };
        /**
         * @hidden @internal
         */
        this.columnWidthSetByUser = false;
        this.rendered$ = this.rendered.asObservable().pipe(shareReplay(1));
        /** @hidden @internal */
        this.resizeNotify = new Subject();
        /**
         * @hidden @internal
         */
        this.paginatorSettings = null;
        this._destroyed = false;
        /**
         * @hidden @internal
         */
        this._totalRecords = -1;
        /**
         * @hidden @internal
         */
        this.columnsWithNoSetWidths = null;
        /**
         * @hidden
         */
        this._perPage = 15;
        /**
         * @hidden
         */
        this._page = 0;
        /**
         * @hidden
         */
        this._paging = false;
        /**
         * @hidden
         */
        this._pagingMode = GridPagingMode.Local;
        /**
         * @hidden
         */
        this._hideRowSelectors = false;
        /**
         * @hidden
         */
        this._rowDrag = false;
        /**
         * @hidden
         */
        this._pipeTrigger = 0;
        /**
         * @hidden
         */
        this._filteringPipeTrigger = 0;
        /**
         * @hidden
         */
        this._summaryPipeTrigger = 0;
        /**
         * @hidden
         */
        this._columns = [];
        /**
         * @hidden
         */
        this._pinnedColumns = [];
        /**
         * @hidden
         */
        this._unpinnedColumns = [];
        /**
         * @hidden
         */
        this._filteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
        /**
         * @hidden
         */
        this._sortingExpressions = [];
        /**
         * @hidden
         */
        this._maxLevelHeaderDepth = null;
        /**
         * @hidden
         */
        this._columnHiding = false;
        /**
         * @hidden
         */
        this._columnPinning = false;
        this._pinnedRecordIDs = [];
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        this._allowFiltering = false;
        this._allowAdvancedFiltering = false;
        this._filterMode = FilterMode.quickFilter;
        this.observer = new ResizeObserver(() => { });
        this._defaultTargetRecordNumber = 10;
        this._expansionStates = new Map();
        this._defaultExpandState = false;
        this._headerFeaturesWidth = NaN;
        this._init = true;
        this._cdrRequestRepaint = false;
        /* Toolbar related definitions */
        this._showToolbar = false;
        this._exportExcel = false;
        this._exportCsv = false;
        this._toolbarTitle = null;
        this._rowEditable = false;
        this._filteredSortedData = null;
        this._cdrRequests = false;
        this._emptyGridMessage = null;
        this._emptyFilteredGridMessage = null;
        this._isLoading = false;
        this.overlayIDs = [];
        this._pinning = { columns: ColumnPinningPosition.Start };
        this._advancedFilteringPositionSettings = {
            verticalDirection: VerticalAlignment.Middle,
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle
        };
        this._advancedFilteringOverlaySettings = {
            closeOnOutsideClick: false,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(this._advancedFilteringPositionSettings),
        };
        this._hiddenColumnsText = '';
        this._pinnedColumnsText = '';
        this._height = '100%';
        this._width = '100%';
        this._horizontalForOfs = [];
        this._multiRowLayoutRowSize = 1;
        // Caches
        this._totalWidth = NaN;
        this._pinnedVisible = [];
        this._unpinnedVisible = [];
        this._pinnedWidth = NaN;
        this._unpinnedWidth = NaN;
        this._visibleColumns = [];
        this._columnGroups = false;
        this._autoGeneratedCols = [];
        this._summaryPosition = GridSummaryPosition.bottom;
        this._summaryCalculationMode = GridSummaryCalculationMode.rootAndChildLevels;
        this._showSummaryOnCollapse = false;
        this._cellSelectionMode = GridSelectionMode.multiple;
        this._rowSelectionMode = GridSelectionMode.none;
        this._selectRowOnClick = true;
        this._columnSelectionMode = GridSelectionMode.none;
        this.rowEditPositioningStrategy = new RowEditPositionStrategy({
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom,
            closeAnimation: null
        });
        this.rowEditSettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: false,
            outlet: this.rowOutletDirective,
            positionStrategy: this.rowEditPositioningStrategy
        };
        /**
         * @hidden @internal
         */
        this.preventContainerScroll = (evt) => {
            if (evt.target.scrollTop !== 0) {
                this.verticalScrollContainer.addScrollTop(evt.target.scrollTop);
                evt.target.scrollTop = 0;
            }
            if (evt.target.scrollLeft !== 0) {
                this.headerContainer.scrollPosition += evt.target.scrollLeft;
                evt.target.scrollLeft = 0;
            }
        };
        this.locale = this.locale || this.localeId;
        this.datePipe = new DatePipe(this.locale);
        this.decimalPipe = new DecimalPipe(this.locale);
        this.currencyPipe = new CurrencyPipe(this.locale);
        this.percentPipe = new PercentPipe(this.locale);
        this.cdr.detach();
    }
    /**
     * Gets/Sets the resource strings.
     *
     * @remarks
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    get resourceStrings() {
        if (!this._resourceStrings) {
            this._resourceStrings = CurrentResourceStrings.GridResStrings;
        }
        return this._resourceStrings;
    }
    /**
     * Gets/Sets the filtering logic of the `IgxGridComponent`.
     *
     * @remarks
     * The default is AND.
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true" [filteringLogic]="filtering"></igx-grid>
     * ```
     */
    get filteringLogic() {
        return this._filteringExpressionsTree.operator;
    }
    set filteringLogic(value) {
        this._filteringExpressionsTree.operator = value;
    }
    /**
     * Gets/Sets the filtering state.
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(filteringExpressionsTree)]="model.filteringExpressions"></igx-grid>
     * ```
     * @remarks
     * Supports two-way binding.
     */
    get filteringExpressionsTree() {
        return this._filteringExpressionsTree;
    }
    set filteringExpressionsTree(value) {
        if (value && value instanceof FilteringExpressionsTree) {
            const val = value;
            for (let index = 0; index < val.filteringOperands.length; index++) {
                if (!(val.filteringOperands[index] instanceof FilteringExpressionsTree)) {
                    const newExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, val.filteringOperands[index].fieldName);
                    newExpressionsTree.filteringOperands.push(val.filteringOperands[index]);
                    val.filteringOperands[index] = newExpressionsTree;
                }
            }
            value.type = FilteringExpressionsTreeType.Regular;
            this._filteringExpressionsTree = value;
            this._filteringPipeTrigger++;
            this.filteringExpressionsTreeChange.emit(this._filteringExpressionsTree);
            if (this.filteringService.isFilteringExpressionsTreeEmpty(this._filteringExpressionsTree) &&
                !this.advancedFilteringExpressionsTree) {
                this.filteredData = null;
            }
            this.filteringService.refreshExpressions();
            this.selectionService.clearHeaderCBState();
            this.summaryService.clearSummaryCache();
            this.notifyChanges();
        }
    }
    /**
     * Gets/Sets the advanced filtering state.
     *
     * @example
     * ```typescript
     * let advancedFilteringExpressionsTree = this.grid.advancedFilteringExpressionsTree;
     * this.grid.advancedFilteringExpressionsTree = logic;
     * ```
     */
    get advancedFilteringExpressionsTree() {
        return this._advancedFilteringExpressionsTree;
    }
    set advancedFilteringExpressionsTree(value) {
        if (value && value instanceof FilteringExpressionsTree) {
            value.type = FilteringExpressionsTreeType.Advanced;
            this._advancedFilteringExpressionsTree = value;
            this._filteringPipeTrigger++;
        }
        else {
            this._advancedFilteringExpressionsTree = null;
        }
        this.advancedFilteringExpressionsTreeChange.emit(this._advancedFilteringExpressionsTree);
        if (this.filteringService.isFilteringExpressionsTreeEmpty(this._advancedFilteringExpressionsTree) &&
            !this.advancedFilteringExpressionsTree) {
            this.filteredData = null;
        }
        this.selectionService.clearHeaderCBState();
        this.summaryService.clearSummaryCache();
        this.notifyChanges();
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.onFilteringDone.emit(this._advancedFilteringExpressionsTree));
    }
    /**
     * Gets/Sets the locale.
     *
     * @remarks
     * If not set, returns browser's language.
     */
    get locale() {
        return this._locale;
    }
    set locale(value) {
        if (value !== this._locale) {
            this._locale = value;
            this._currencyPositionLeft = undefined;
            this.summaryService.clearSummaryCache();
            this._pipeTrigger++;
            this.notifyChanges();
        }
    }
    get pagingMode() {
        return this._pagingMode;
    }
    set pagingMode(val) {
        this._pagingMode = val;
        this._pipeTrigger++;
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets whether the paging feature is enabled.
     *
     * @remarks
     * The default state is disabled (false).
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [paging]="true"></igx-grid>
     * ```
     */
    get paging() {
        return this._paging;
    }
    set paging(value) {
        this._paging = value;
        this._pipeTrigger++;
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets the current page index.
     *
     * @example
     * ```html
     *  <igx-grid #grid [data]="Data" [paging]="true" [(page)]="model.page" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * Supports two-way binding.
     */
    get page() {
        return this._page;
    }
    set page(val) {
        if (val === this._page || val < 0 || val > this.totalPages - 1) {
            return;
        }
        this.selectionService.clear(true);
        this.onPagingDone.emit({ previous: this._page, current: val });
        this._page = val;
        this.pageChange.emit(this._page);
        this.navigateTo(0);
        this.notifyChanges();
    }
    /**
     * Gets/Sets the number of visible items per page.
     *
     * @remarks
     * The default is 15.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [paging]="true" [(perPage)]="model.perPage" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get perPage() {
        return this._perPage;
    }
    set perPage(val) {
        if (val < 0) {
            return;
        }
        this.selectionService.clear(true);
        this._perPage = val;
        this.perPageChange.emit(this._perPage);
        this.page = 0;
        this.endEdit(false);
        this.notifyChanges();
    }
    /**
     * Gets/Sets whether the column hiding UI is enabled.
     *
     * @deprecated
     *
     * @remarks
     * By default it is disabled (false). In order for the UI to work, you need to enable the toolbar as shown in the example below.
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true" [showToolbar]="true" [columnHiding]="true"></igx-grid>
     * ```
     */
    get columnHiding() {
        return this._columnHiding;
    }
    set columnHiding(value) {
        this._columnHiding = value;
        this.notifyChanges();
    }
    /**
     * Gets/Sets if the row selectors are hidden.
     *
     * @remarks
     *  By default row selectors are shown
     */
    get hideRowSelectors() {
        return this._hideRowSelectors;
    }
    set hideRowSelectors(value) {
        this._hideRowSelectors = value;
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets whether rows can be moved.
     *
     * @example
     * ```html
     * <igx-grid #grid [rowDraggable]="true"></igx-grid>
     * ```
     */
    get rowDraggable() {
        return this._rowDrag && this.hasVisibleColumns;
    }
    set rowDraggable(val) {
        this._rowDrag = val;
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets whether the rows are editable.
     *
     * @remarks
     * By default it is set to false.
     * @example
     * ```html
     * <igx-grid #grid [showToolbar]="true" [rowEditable]="true" [primaryKey]="'ProductID'" [columnHiding]="true"></igx-grid>
     * ```
     */
    get rowEditable() {
        return this._rowEditable;
    }
    set rowEditable(val) {
        if (!this._init) {
            this.refreshGridState();
        }
        this._rowEditable = val;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the height.
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get height() {
        return this._height;
    }
    set height(value) {
        if (this._height !== value) {
            this._height = value;
            this.nativeElement.style.height = value;
            this.notifyChanges(true);
        }
    }
    /**
     * @hidden @internal
     */
    get hostWidth() {
        return this._width || this._hostWidth;
    }
    /**
     * Gets/Sets the width of the grid.
     *
     * @example
     * ```typescript
     * let gridWidth = this.grid.width;
     * ```
     */
    get width() {
        return this._width;
    }
    set width(value) {
        if (this._width !== value) {
            this._width = value;
            this.nativeElement.style.width = value;
            this.notifyChanges(true);
        }
    }
    /**
     * Gets the width of the header.
     *
     * @example
     * ```html
     * let gridHeaderWidth = this.grid.headerWidth;
     * ```
     */
    get headerWidth() {
        return parseInt(this.width, 10) - 17;
    }
    /**
     * Gets/Sets the row height.
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [showToolbar]="true" [rowHeight]="100" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get rowHeight() {
        return this._rowHeight ? this._rowHeight : this.defaultRowHeight;
    }
    set rowHeight(value) {
        this._rowHeight = parseInt(value, 10);
    }
    /**
     * Gets/Sets the default width of the columns.
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [showToolbar]="true" [columnWidth]="100" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get columnWidth() {
        return this._columnWidth;
    }
    set columnWidth(value) {
        this._columnWidth = value;
        this.columnWidthSetByUser = true;
        this.notifyChanges(true);
    }
    /**
     * Get/Sets the message displayed when there are no records.
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    set emptyGridMessage(value) {
        this._emptyGridMessage = value;
    }
    get emptyGridMessage() {
        return this._emptyGridMessage || this.resourceStrings.igx_grid_emptyGrid_message;
    }
    /**
     * Gets/Sets whether the grid is going to show a loading indicator.
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [isLoading]="true" [autoGenerate]="true"></igx-grid>
     * ```
     */
    set isLoading(value) {
        if (this._isLoading !== value) {
            this._isLoading = value;
            this.evaluateLoadingState();
        }
        Promise.resolve().then(() => {
            // wait for the current detection cycle to end before triggering a new one.
            this.notifyChanges();
        });
    }
    get isLoading() {
        return this._isLoading;
    }
    /**
     * Gets/Sets the message displayed when there are no records and the grid is filtered.
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    set emptyFilteredGridMessage(value) {
        this._emptyFilteredGridMessage = value;
    }
    get emptyFilteredGridMessage() {
        return this._emptyFilteredGridMessage || this.resourceStrings.igx_grid_emptyFilteredGrid_message;
    }
    /**
     * Gets/Sets the title to be displayed in the built-in column hiding UI.
     *
     * @deprecated
     *
     * @example
     * ```html
     * <igx-grid [showToolbar]="true" [columnHiding]="true" columnHidingTitle="Column Hiding"></igx-grid>
     * ```
     */
    get columnHidingTitle() {
        return this._columnHidingTitle;
    }
    set columnHidingTitle(v) {
        this._columnHidingTitle = v;
    }
    /** @hidden @internal */
    get columnHidingTitleInternal() {
        return this._columnHidingTitle;
    }
    /**
     * Gets/Sets the initial pinning configuration.
     *
     * @remarks
     * Allows to apply pinning the columns to the start or the end.
     * Note that pinning to both sides at a time is not allowed.
     * @example
     * ```html
     * <igx-grid [pinning]="pinningConfig"></igx-grid>
     * ```
     */
    get pinning() {
        return this._pinning;
    }
    set pinning(value) {
        if (value !== this._pinning) {
            this.resetCaches();
        }
        this._pinning = value;
    }
    /**
     * Gets/Sets if the built-in column pinning UI should be shown in the toolbar.
     *
     * @deprecated
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [columnPinning]="'true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get columnPinning() {
        return this._columnPinning;
    }
    set columnPinning(value) {
        this._columnPinning = value;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the title to be displayed in the UI of the column pinning.
     *
     * @deprecated
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [columnPinning]="'true" [columnPinningTitle]="'Column Hiding'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get columnPinningTitle() {
        return this._columnPinningTitle;
    }
    set columnPinningTitle(v) {
        this._columnPinningTitle = v;
    }
    /** @hidden @internal */
    get columnPinningTitleInternal() {
        return this._columnPinningTitle;
    }
    /**
     * Gets/Sets if the filtering is enabled.
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [allowFiltering]="true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get allowFiltering() {
        return this._allowFiltering;
    }
    set allowFiltering(value) {
        if (this._allowFiltering !== value) {
            this._allowFiltering = value;
            this.filteringService.registerSVGIcons();
            if (!this._init) {
                this.calcGridHeadRow();
            }
            this.filteringService.isFilterRowVisible = false;
            this.filteringService.filteredColumn = null;
            this.notifyChanges(true);
        }
    }
    /**
     * Gets/Sets a value indicating whether the advanced filtering is enabled.
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [allowAdvancedFiltering]="true" [showToolbar]="true" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get allowAdvancedFiltering() {
        return this._allowAdvancedFiltering;
    }
    set allowAdvancedFiltering(value) {
        if (this._allowAdvancedFiltering !== value) {
            this._allowAdvancedFiltering = value;
            this.filteringService.registerSVGIcons();
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets the filter mode.
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [filterMode]="'quickFilter'" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default it's set to FilterMode.quickFilter.
     */
    get filterMode() {
        return this._filterMode;
    }
    set filterMode(value) {
        this._filterMode = value;
        if (this.filteringService.isFilterRowVisible) {
            this.filteringRow.close();
        }
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets the summary position.
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" summaryPosition="top" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default it is bottom.
     */
    get summaryPosition() {
        return this._summaryPosition;
    }
    set summaryPosition(value) {
        this._summaryPosition = value;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the summary calculation mode.
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" summaryCalculationMode="rootLevelOnly" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default it is rootAndChildLevels which means the summaries are calculated for the root level and each child level.
     */
    get summaryCalculationMode() {
        return this._summaryCalculationMode;
    }
    set summaryCalculationMode(value) {
        this._summaryCalculationMode = value;
        if (!this._init) {
            this.endEdit(false);
            this.summaryService.resetSummaryHeight();
            this.notifyChanges(true);
        }
    }
    /**
     * Controls whether the summary row is visible when groupBy/parent row is collapsed.
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [showSummaryOnCollapse]="true" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default showSummaryOnCollapse is set to 'false' which means that the summary row is not visible
     * when the groupBy/parent row is collapsed.
     */
    get showSummaryOnCollapse() {
        return this._showSummaryOnCollapse;
    }
    set showSummaryOnCollapse(value) {
        this._showSummaryOnCollapse = value;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the filtering strategy of the grid.
     *
     * @example
     * ```html
     *  <igx-grid #grid [data]="localData" [filterStrategy]="filterStrategy"></igx-grid>
     * ```
     */
    get filterStrategy() {
        return this._filteringStrategy;
    }
    set filterStrategy(classRef) {
        this._filteringStrategy = classRef;
    }
    /**
     * Gets/Sets the sorting strategy of the grid.
     *
     * @example
     * ```html
     *  <igx-grid #grid [data]="localData" [sortStrategy]="sortStrategy"></igx-grid>
     * ```
     */
    get sortStrategy() {
        return this._sortingStrategy;
    }
    set sortStrategy(value) {
        this._sortingStrategy = value;
    }
    /**
     * Gets/Sets the current selection state.
     *
     * @remarks
     * Represents the selected rows' IDs (primary key or rowData)
     * @example
     * ```html
     * <igx-grid [data]="localData" primaryKey="ID" rowSelection="multiple" [selectedRows]="[0, 1, 2]"><igx-grid>
     * ```
     */
    set selectedRows(rowIDs) {
        this.selectRows(rowIDs || [], true);
    }
    get selectedRows() {
        return this.selectionService.getSelectedRows();
    }
    /**
     * @hidden @internal
     */
    get excelStyleFilteringComponent() {
        return this.excelStyleFilteringComponents.first;
    }
    /**
     * A list of all `IgxGridHeaderGroupComponent`.
     *
     * @example
     * ```typescript
     * const headerGroupsList = this.grid.headerGroupsList;
     * ```
     */
    get headerGroupsList() {
        return this.headerGroups ? flatten(this.headerGroups.toArray()) : [];
    }
    /**
     * A list of all `IgxGridHeaderComponent`.
     *
     * @example
     * ```typescript
     * const headers = this.grid.headerCellList;
     * ```
     */
    get headerCellList() {
        return this.headerGroupsList.map((headerGroup) => headerGroup.headerCell).filter((headerCell) => headerCell);
    }
    /**
     * A list of all `IgxGridFilteringCellComponent`.
     *
     * @example
     * ```typescript
     * const filterCells = this.grid.filterCellList;
     * ```
     */
    get filterCellList() {
        return this.headerGroupsList.map((headerGroup) => headerGroup.filterCell).filter((filterCell) => filterCell);
    }
    /**
     * @hidden @internal
     */
    get summariesRowList() {
        const res = new QueryList();
        if (!this._summaryRowList) {
            return res;
        }
        const sumList = this._summaryRowList.filter((item) => item.element.nativeElement.parentElement !== null);
        res.reset(sumList);
        return res;
    }
    /**
     * A list of `IgxGridRowComponent`.
     *
     * @example
     * ```typescript
     * const rowList = this.grid.rowList;
     * ```
     */
    get rowList() {
        const res = new QueryList();
        if (!this._rowList) {
            return res;
        }
        const rList = this._rowList
            .filter((item) => item.element.nativeElement.parentElement !== null)
            .sort((a, b) => a.index - b.index);
        res.reset(rList);
        return res;
    }
    /**
     * A list of currently rendered `IgxGridRowComponent`'s.
     *
     * @example
     * ```typescript
     * const dataList = this.grid.dataRowList;
     * ```
     */
    get dataRowList() {
        const res = new QueryList();
        if (!this._dataRowList) {
            return res;
        }
        const rList = this._dataRowList.filter(item => item.element.nativeElement.parentElement !== null).sort((a, b) => a.index - b.index);
        res.reset(rList);
        return res;
    }
    /**
     * @hidden
     * @internal
     */
    get headSelectorTemplate() {
        if (this.headSelectorsTemplates && this.headSelectorsTemplates.first) {
            return this.headSelectorsTemplates.first.templateRef;
        }
        return null;
    }
    /**
     * @hidden
     * @internal
     */
    get isPinningToStart() {
        return this.pinning.columns !== ColumnPinningPosition.End;
    }
    /**
     * @hidden
     * @internal
     */
    get isRowPinningToTop() {
        return this.pinning.rows !== RowPinningPosition.Bottom;
    }
    /**
     * @hidden
     * @internal
     */
    get rowSelectorTemplate() {
        if (this.rowSelectorsTemplates && this.rowSelectorsTemplates.first) {
            return this.rowSelectorsTemplates.first.templateRef;
        }
        return null;
    }
    /**
     * @hidden @internal
     */
    get rowOutletDirective() {
        return this.rowEditingOutletDirective;
    }
    /**
     * @hidden @internal
     */
    get parentRowOutletDirective() {
        return this.outlet;
    }
    /**
     * @hidden @internal
     */
    get rowEditContainer() {
        return this.rowEditCustom ? this.rowEditCustom : this.defaultRowEditTemplate;
    }
    /**
     * The custom template, if any, that should be used when rendering the row drag indicator icon
     */
    get dragIndicatorIconTemplate() {
        return this._customDragIndicatorIconTemplate || this.dragIndicatorIconTemplates.first;
    }
    set dragIndicatorIconTemplate(val) {
        this._customDragIndicatorIconTemplate = val;
    }
    /**
     * @hidden @internal
     */
    get rowInEditMode() {
        const editRowState = this.crudService.row;
        return editRowState !== null ? this.rowList.find(e => e.rowID === editRowState.id) : null;
    }
    /**
     * @hidden @internal
     */
    get firstEditableColumnIndex() {
        const index = this.visibleColumns.filter(col => col.editable)
            .map(c => c.visibleIndex).sort((a, b) => a - b);
        return index.length ? index[0] : null;
    }
    /**
     * @hidden @internal
     */
    get lastEditableColumnIndex() {
        const index = this.visibleColumns.filter(col => col.editable)
            .map(c => c.visibleIndex).sort((a, b) => a > b ? -1 : 1);
        return index.length ? index[0] : null;
    }
    /**
     * @hidden @internal
     * TODO: Nav service logic doesn't handle 0 results from this querylist
     */
    get rowEditTabs() {
        return this.rowEditTabsCUSTOM.length ? this.rowEditTabsCUSTOM : this.rowEditTabsDEFAULT;
    }
    get activeDescendant() {
        const activeElem = this.navigation.activeNode;
        if (!activeElem || !Object.keys(activeElem).length) {
            return this.id;
        }
        return activeElem.row < 0 ?
            `${this.id}_${activeElem.row}_${activeElem.mchCache.level}_${activeElem.column}` :
            `${this.id}_${activeElem.row}_${activeElem.column}`;
    }
    /**
     * @hidden @internal
     */
    get hostClass() {
        const classes = [this.getComponentDensityClass('igx-grid')];
        // The custom classes should be at the end.
        classes.push(this.class);
        return classes.join(' ');
    }
    get bannerClass() {
        const position = this.rowEditPositioningStrategy.isTop ? 'igx-banner__border-top' : 'igx-banner__border-bottom';
        return `${this.getComponentDensityClass('igx-banner')} ${position}`;
    }
    /**
     * @hidden @internal
     */
    get pipeTrigger() {
        return this._pipeTrigger;
    }
    /**
     * @hidden @internal
     */
    get filteringPipeTrigger() {
        return this._filteringPipeTrigger;
    }
    /**
     * @hidden @internal
     */
    get summaryPipeTrigger() {
        return this._summaryPipeTrigger;
    }
    /**
     * Gets/Sets the sorting state.
     *
     * @remarks
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(sortingExpressions)]="model.sortingExpressions"></igx-grid>
     * ```
     */
    get sortingExpressions() {
        return this._sortingExpressions;
    }
    set sortingExpressions(value) {
        this._sortingExpressions = cloneArray(value);
        this.sortingExpressionsChange.emit(this._sortingExpressions);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    get maxLevelHeaderDepth() {
        if (this._maxLevelHeaderDepth === null) {
            this._maxLevelHeaderDepth = this.hasColumnLayouts ?
                this.columnList.reduce((acc, col) => Math.max(acc, col.rowStart), 0) :
                this.columnList.reduce((acc, col) => Math.max(acc, col.level), 0);
        }
        return this._maxLevelHeaderDepth;
    }
    /**
     * Gets the number of hidden columns.
     *
     * @example
     * ```typescript
     * const hiddenCol = this.grid.hiddenColumnsCount;
     * ``
     */
    get hiddenColumnsCount() {
        return this.columnList.filter((col) => col.columnGroup === false && col.hidden === true).length;
    }
    /**
     * Gets the number of pinned columns.
     */
    get pinnedColumnsCount() {
        return this.pinnedColumns.filter(col => !col.columnLayout).length;
    }
    /**
     * Gets/Sets the text to be displayed inside the toggle button.
     *
     * @deprecated
     *
     * @remarks
     * Used for the built-in column hiding UI of the`IgxColumnComponent`.
     * @example
     * ```html
     * <igx-grid [columnHiding]="true" [showToolbar]="true" [hiddenColumnsText]="'Hidden Columns'"></igx-grid>
     * ```
     */
    // @DeprecateProperty('`hiddenColumnsText` is deprecated')
    get hiddenColumnsText() {
        return this._hiddenColumnsText;
    }
    set hiddenColumnsText(value) {
        this._hiddenColumnsText = value;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the text to be displayed inside the toggle button.
     *
     * @deprecated
     *
     * @remarks
     * Used for the built-in column pinning UI of the`IgxColumnComponent`.
     * @example
     * ```html
     * <igx-grid [pinnedColumnsText]="'PinnedCols Text" [data]="data" [width]="'100%'" [height]="'500px'"></igx-grid>
     * ```
     */
    get pinnedColumnsText() {
        return this._pinnedColumnsText;
    }
    set pinnedColumnsText(value) {
        this._pinnedColumnsText = value;
        this.notifyChanges();
    }
    /** @hidden @internal */
    get pinnedColumnsTextInternal() {
        return this._pinnedColumnsText;
    }
    /**
     * Get transactions service for the grid.
     */
    get transactions() {
        return this._transactions;
    }
    /**
     * @hidden @internal
     */
    get currentRowState() {
        return this._currentRowState;
    }
    /**
     * @hidden @internal
     */
    get currencyPositionLeft() {
        if (this._currencyPositionLeft !== undefined) {
            return this._currencyPositionLeft;
        }
        const format = getLocaleNumberFormat(this.locale, NumberFormatStyle.Currency);
        const formatParts = format.split(',');
        const i = formatParts.indexOf(formatParts.find(c => c.includes('¤')));
        return this._currencyPositionLeft = i < 1;
    }
    /**
     * Gets/Sets whether the toolbar is shown.
     *
     * @deprecated
     *
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" ></igx-grid>
     * ```
     */
    get showToolbar() {
        return this._showToolbar;
    }
    set showToolbar(newValue) {
        this._showToolbar = newValue;
    }
    /**
     * Gets/Sets the toolbar's title.
     *
     * @deprecated
     *
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [toolbarTitle]="'My Grid'"></igx-grid>
     * ```
     */
    get toolbarTitle() {
        return this._toolbarTitle;
    }
    set toolbarTitle(newValue) {
        this._toolbarTitle = newValue;
        this.notifyChanges();
    }
    /**
     * Gets/Sets whether exporting to MS Excel is enabled or disabled.
     *
     * @deprecated
     *
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportExcel]="true"></igx-grid>
     * ```
     */
    get exportExcel() {
        return this.getExportExcel();
    }
    set exportExcel(newValue) {
        this._exportExcel = newValue;
        this.notifyChanges();
    }
    /**
     * Gets/Sets whether the option for exporting to CSV is enabled or disabled.
     *
     * @deprecated
     *
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportCsv]="true"></igx-grid>
     * ```
     */
    get exportCsv() {
        return this.getExportCsv();
    }
    set exportCsv(newValue) {
        this._exportCsv = newValue;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the textual content for the main export button.
     *
     * @deprecated
     *
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
     * ```
     */
    get exportText() {
        return this._exportText;
    }
    set exportText(newValue) {
        this._exportText = newValue;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the textual content for the MS Excel export button.
     *
     * @deprecated
     *
     * ```html
     * <igx-grid [exportExcelText]="'My Excel Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
     * ```
     */
    get exportExcelText() {
        return this._exportExcelText;
    }
    set exportExcelText(newValue) {
        this._exportExcelText = newValue;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the textual content for the CSV export button.
     *
     * @deprecated
     *
     * @example
     * ```html
     * <igx-grid [exportCsvText]="'My Csv Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportExcel]="true"></igx-grid>
     * ```
     */
    get exportCsvText() {
        return this._exportCsvText;
    }
    set exportCsvText(newValue) {
        this._exportCsvText = newValue;
        this.notifyChanges();
    }
    /**
     * Gets/Sets cell selection mode.
     *
     * @remarks
     * By default the cell selection mode is multiple
     * @param selectionMode: GridSelectionMode
     */
    get cellSelection() {
        return this._cellSelectionMode;
    }
    set cellSelection(selectionMode) {
        this._cellSelectionMode = selectionMode;
        if (this.gridAPI.grid) {
            this.selectionService.clear(true);
            this.notifyChanges();
        }
    }
    /**
     * Gets/Sets row selection mode
     *
     * @remarks
     * By default the row selection mode is 'none'
     * Note that in IgxGrid and IgxHierarchicalGrid 'multipleCascade' behaves like 'multiple'
     */
    get rowSelection() {
        return this._rowSelectionMode;
    }
    set rowSelection(selectionMode) {
        this._rowSelectionMode = selectionMode;
        if (!this._init) {
            this.selectionService.clearAllSelectedRows();
            this.notifyChanges(true);
        }
    }
    /**
     * Gets/Sets column selection mode
     *
     * @remarks
     * By default the row selection mode is none
     * @param selectionMode: GridSelectionMode
     */
    get columnSelection() {
        return this._columnSelectionMode;
    }
    set columnSelection(selectionMode) {
        this._columnSelectionMode = selectionMode;
        if (this.gridAPI.grid) {
            this.selectionService.clearAllSelectedColumns();
            this.notifyChanges(true);
        }
    }
    /**
     * @hidden @internal
     */
    get scrollSize() {
        return this.verticalScrollContainer.getScrollNativeSize();
    }
    /**
     * Returns an array containing the filtered sorted data.
     *
     * @example
     * ```typescript
     * const filteredSortedData = this.grid1.filteredSortedData;
     * ```
     */
    get filteredSortedData() {
        return this._filteredSortedData;
    }
    /**
     * @hidden @internal
     */
    get rowChangesCount() {
        if (!this.crudService.row) {
            return 0;
        }
        const f = (obj) => {
            let changes = 0;
            Object.keys(obj).forEach(key => isObject(obj[key]) ? changes += f(obj[key]) : changes++);
            return changes;
        };
        const rowChanges = this.transactions.getAggregatedValue(this.crudService.row.id, false);
        return rowChanges ? f(rowChanges) : 0;
    }
    /**
     * @hidden @internal
     */
    get dataWithAddedInTransactionRows() {
        const result = cloneArray(this.gridAPI.get_all_data());
        if (this.transactions.enabled) {
            result.push(...this.transactions.getAggregatedChanges(true)
                .filter(t => t.type === TransactionType.ADD)
                .map(t => t.newValue));
        }
        return result;
    }
    /**
     * @hidden @internal
     */
    get dataLength() {
        return this.transactions.enabled ? this.dataWithAddedInTransactionRows.length : this.gridAPI.get_all_data().length;
    }
    /**
     * @hidden @internal
     */
    get template() {
        if (this.isLoading && (this.hasZeroResultFilter || this.hasNoData)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
        }
        if (this.hasZeroResultFilter) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
        }
        if (this.hasNoData) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    get hasZeroResultFilter() {
        return this.filteredData && this.filteredData.length === 0;
    }
    /**
     * @hidden @internal
     */
    get hasNoData() {
        return !this.data || this.dataLength === 0;
    }
    /**
     * @hidden @internal
     */
    get shouldOverlayLoading() {
        return this.isLoading && !this.hasNoData && !this.hasZeroResultFilter;
    }
    /**
     * @hidden @internal
     */
    get isMultiRowSelectionEnabled() {
        return this.rowSelection === GridSelectionMode.multiple
            || this.rowSelection === GridSelectionMode.multipleCascade;
    }
    /**
     * @hidden @internal
     */
    get isRowSelectable() {
        return this.rowSelection !== GridSelectionMode.none;
    }
    /**
     * @hidden @internal
     */
    get isCellSelectable() {
        return this.cellSelection !== GridSelectionMode.none;
    }
    /**
     * @hidden
     * @internal
     */
    hideActionStrip() {
        var _a;
        (_a = this.actionStrip) === null || _a === void 0 ? void 0 : _a.hide();
    }
    /**
     * @hidden
     * @internal
     */
    get headerFeaturesWidth() {
        return this._headerFeaturesWidth;
    }
    /**
     * @hidden
     * @internal
     */
    isDetailRecord(rec) {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    isGroupByRecord(rec) {
        return false;
    }
    /**
     * @hidden @internal
     */
    isGhostRecord(record) {
        return record.ghostRecord !== undefined;
    }
    /**
     * @hidden @internal
     */
    isAddRowRecord(record) {
        return record.addRow !== undefined;
    }
    /**
     * @hidden
     * Returns the row index of a row that takes into account the full view data like pinning.
     */
    getDataViewIndex(rowIndex, pinned) {
        if (pinned && !this.isRowPinningToTop) {
            rowIndex = rowIndex + this.unpinnedDataView.length;
        }
        else if (!pinned && this.isRowPinningToTop) {
            rowIndex = rowIndex + this.pinnedDataView.length;
        }
        return rowIndex;
    }
    /**
     * @hidden
     * @internal
     */
    get hasDetails() {
        return false;
    }
    /**
     * Returns the state of the grid virtualization.
     *
     * @remarks
     * Includes the start index and how many records are rendered.
     * @example
     * ```typescript
     * const gridVirtState = this.grid1.virtualizationState;
     * ```
     */
    get virtualizationState() {
        return this.verticalScrollContainer.state;
    }
    /**
     * @hidden
     */
    set virtualizationState(state) {
        this.verticalScrollContainer.state = state;
    }
    /**
     * @hidden
     * @internal
     */
    hideOverlays() {
        this.overlayIDs.forEach(overlayID => {
            this.overlayService.hide(overlayID);
            this.overlayService.onClosed.pipe(filter(o => o.id === overlayID), takeUntil(this.destroy$)).subscribe(() => {
                this.nativeElement.focus();
            });
        });
    }
    /**
     * Returns whether the record is pinned or not.
     *
     * @param rowIndex Index of the record in the `dataView` collection.
     *
     * @hidden
     * @internal
     */
    isRecordPinnedByViewIndex(rowIndex) {
        return this.hasPinnedRecords && (this.isRowPinningToTop && rowIndex < this.pinnedDataView.length) ||
            (!this.isRowPinningToTop && rowIndex >= this.unpinnedDataView.length);
    }
    /**
     * Returns whether the record is pinned or not.
     *
     * @param rowIndex Index of the record in the `filteredSortedData` collection.
     */
    isRecordPinnedByIndex(rowIndex) {
        return this.hasPinnedRecords && (this.isRowPinningToTop && rowIndex < this._filteredSortedPinnedData.length) ||
            (!this.isRowPinningToTop && rowIndex >= this._filteredSortedUnpinnedData.length);
    }
    /**
     * @hidden
     * @internal
     */
    isRecordPinned(rec) {
        return this.getInitialPinnedIndex(rec) !== -1;
    }
    /**
     * @hidden
     * @internal
     * Returns the record index in order of pinning by the user. Does not consider sorting/filtering.
     */
    getInitialPinnedIndex(rec) {
        const id = this.gridAPI.get_row_id(rec);
        return this._pinnedRecordIDs.indexOf(id);
    }
    /**
     * @hidden
     * @internal
     */
    get hasPinnedRecords() {
        return this._pinnedRecordIDs.length > 0;
    }
    /**
     * @hidden
     * @internal
     */
    get pinnedRecordsCount() {
        return this._pinnedRecordIDs.length;
    }
    _setupServices() {
        this.gridAPI.grid = this;
        this.crudService.grid = this;
        this.selectionService.grid = this;
        this.navigation.grid = this;
        this.filteringService.grid = this;
        this.summaryService.grid = this;
    }
    _setupListeners() {
        const destructor = takeUntil(this.destroy$);
        fromEvent(this.nativeElement, 'focusout').pipe(filter(() => !!this.navigation.activeNode), destructor).subscribe((event) => {
            if (this.selectionService.dragMode && isIE()) {
                return;
            }
            if (!this.crudService.cell &&
                !!this.navigation.activeNode &&
                ((event.target === this.tbody.nativeElement && this.navigation.activeNode.row >= 0 &&
                    this.navigation.activeNode.row < this.dataView.length)
                    || (event.target === this.theadRow.nativeElement && this.navigation.activeNode.row === -1)
                    || (event.target === this.tfoot.nativeElement.children[0] &&
                        this.navigation.activeNode.row === this.dataView.length)) &&
                !(this.rowEditable && this.crudService.rowEditingBlocked && this.crudService.rowInEditMode)) {
                this.navigation.lastActiveNode = this.navigation.activeNode;
                this.navigation.activeNode = {};
                this.notifyChanges();
            }
        });
        this.onRowAdded.pipe(destructor).subscribe(args => this.refreshGridState(args));
        this.onRowDeleted.pipe(destructor).subscribe(args => {
            this.summaryService.deleteOperation = true;
            this.summaryService.clearSummaryCache(args);
        });
        this.transactions.onStateUpdate.pipe(destructor).subscribe((event) => {
            let actions = [];
            if (event.origin === TransactionEventOrigin.REDO) {
                actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.DELETE) : [];
            }
            else if (event.origin === TransactionEventOrigin.UNDO) {
                actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.ADD) : [];
            }
            if (actions.length > 0) {
                for (const action of actions) {
                    if (this.selectionService.isRowSelected(action.transaction.id)) {
                        this.selectionService.deselectRow(action.transaction.id);
                    }
                }
            }
            this.selectionService.clearHeaderCBState();
            this.summaryService.clearSummaryCache();
            this._pipeTrigger++;
            this.notifyChanges();
        });
        this.resizeNotify.pipe(destructor, filter(() => !this._init), throttleTime(100, undefined, { leading: true, trailing: true }))
            .subscribe(() => {
            this.zone.run(() => {
                this.notifyChanges(true);
            });
        });
        this.onPagingDone.pipe(destructor).subscribe(() => {
            this.endEdit(false);
            this.selectionService.clear(true);
        });
        this.onColumnMovingEnd.pipe(destructor).subscribe(() => this.endEdit(false));
        this.overlayService.onOpening.pipe(destructor).subscribe((event) => {
            if (this._advancedFilteringOverlayId === event.id) {
                const instance = event.componentRef.instance;
                if (instance) {
                    instance.initialize(this, this.overlayService, event.id);
                }
            }
        });
        this.overlayService.onOpened.pipe(destructor).subscribe((event) => {
            var _a, _b;
            const overlaySettings = (_a = this.overlayService.getOverlayById(event.id)) === null || _a === void 0 ? void 0 : _a.settings;
            // do not hide the advanced filtering overlay on scroll
            if (this._advancedFilteringOverlayId === event.id) {
                const instance = event.componentRef.instance;
                if (instance) {
                    instance.lastActiveNode = this.navigation.activeNode;
                    instance.setAddButtonFocus();
                }
                return;
            }
            // do not hide the overlay if it's attached to a row
            if (((_b = this.rowEditingOverlay) === null || _b === void 0 ? void 0 : _b.overlayId) === event.id) {
                return;
            }
            if ((overlaySettings === null || overlaySettings === void 0 ? void 0 : overlaySettings.outlet) === this.outlet && this.overlayIDs.indexOf(event.id) === -1) {
                this.overlayIDs.push(event.id);
            }
        });
        this.overlayService.onClosed.pipe(destructor, filter(() => !this._init)).subscribe((event) => {
            if (this._advancedFilteringOverlayId === event.id) {
                this._advancedFilteringOverlayId = null;
                return;
            }
            const ind = this.overlayIDs.indexOf(event.id);
            if (ind !== -1) {
                this.overlayIDs.splice(ind, 1);
            }
        });
        this.verticalScrollContainer.onDataChanging.pipe(destructor, filter(() => !this._init)).subscribe(($event) => {
            const shouldRecalcSize = this.isPercentHeight &&
                (!this.calcHeight || this.calcHeight === this.getDataBasedBodyHeight() ||
                    this.calcHeight === this.renderedRowHeight * this._defaultTargetRecordNumber);
            if (shouldRecalcSize) {
                this.calculateGridHeight();
                $event.containerSize = this.calcHeight;
            }
            this.evaluateLoadingState();
        });
        this.verticalScrollContainer.onScrollbarVisibilityChanged.pipe(destructor, filter(() => !this._init)).subscribe(() => {
            // called to recalc all widths that may have changes as a result of
            // the vert. scrollbar showing/hiding
            this.notifyChanges(true);
        });
        this.verticalScrollContainer.onContentSizeChange.pipe(destructor, filter(() => !this._init)).subscribe(($event) => {
            this.calculateGridSizes(false);
        });
        this.onDensityChanged.pipe(destructor).subscribe(() => {
            this.endEdit(false);
            this.summaryService.summaryHeight = 0;
            this.notifyChanges(true);
        });
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this._setupServices();
        this._setupListeners();
        this.rowListDiffer = this.differs.find([]).create(null);
        this.columnListDiffer = this.differs.find([]).create(null);
        this.calcWidth = this.width && this.width.indexOf('%') === -1 ? parseInt(this.width, 10) : 0;
        this.shouldGenerate = this.autoGenerate;
    }
    /**
     * @hidden
     * @internal
     */
    resetColumnsCaches() {
        this.columnList.forEach(column => column.resetCaches());
    }
    /**
     * @hidden @internal
     */
    generateRowID() {
        const primaryColumn = this.columnList.find(col => col.field === this.primaryKey);
        const idType = this.data.length ? typeof (this.data[0][this.primaryKey]) : primaryColumn ? primaryColumn.dataType : 'string';
        return idType === 'string' ? v4() : FAKE_ROW_ID--;
    }
    /**
     * @hidden
     * @internal
     */
    resetForOfCache() {
        const firstVirtRow = this.dataRowList.first;
        if (firstVirtRow) {
            if (this._cdrRequests) {
                firstVirtRow.virtDirRow.cdr.detectChanges();
            }
            firstVirtRow.virtDirRow.assumeMaster();
        }
    }
    /**
     * @hidden
     * @internal
     */
    setFilteredData(data, pinned) {
        if (this.hasPinnedRecords && pinned) {
            this._filteredPinnedData = data || [];
            const filteredUnpinned = this._filteredUnpinnedData || [];
            const filteredData = [...this._filteredPinnedData, ...filteredUnpinned];
            this.filteredData = filteredData.length > 0 ? filteredData : this._filteredUnpinnedData;
        }
        else if (this.hasPinnedRecords && !pinned) {
            this._filteredUnpinnedData = data;
        }
        else {
            this.filteredData = data;
        }
    }
    /**
     * @hidden
     * @internal
     */
    resetColumnCollections() {
        this._visibleColumns.length = 0;
        this._pinnedVisible.length = 0;
        this._unpinnedVisible.length = 0;
    }
    /**
     * @hidden
     * @internal
     */
    resetCachedWidths() {
        this._unpinnedWidth = NaN;
        this._pinnedWidth = NaN;
        this._totalWidth = NaN;
    }
    /**
     * @hidden
     * @internal
     */
    resetCaches(recalcFeatureWidth = true) {
        if (recalcFeatureWidth) {
            this._headerFeaturesWidth = NaN;
        }
        this.resetForOfCache();
        this.resetColumnsCaches();
        this.resetColumnCollections();
        this.resetCachedWidths();
        this.hasVisibleColumns = undefined;
        this._columnGroups = this.columnList.some(col => col.columnGroup);
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.setupColumns();
        this.toolbar.changes.pipe(takeUntil(this.destroy$), filter(() => !this._init)).subscribe(() => this.notifyChanges(true));
        if (this.actionStrip) {
            this.actionStrip.menuOverlaySettings.outlet = this.outlet;
        }
    }
    /**
     * @hidden
     * @internal
     */
    setFilteredSortedData(data, pinned) {
        data = data || [];
        if (this.pinnedRecordsCount > 0 && pinned) {
            this._filteredSortedPinnedData = data;
            this.pinnedRecords = data;
            this._filteredSortedData = this.isRowPinningToTop ? [...this._filteredSortedPinnedData, ...this._filteredSortedUnpinnedData] :
                [...this._filteredSortedUnpinnedData, ...this._filteredSortedPinnedData];
            this.refreshSearch(true, false);
        }
        else if (this.pinnedRecordsCount > 0 && !pinned) {
            this._filteredSortedUnpinnedData = data;
        }
        else {
            this._filteredSortedData = data;
            this.refreshSearch(true, false);
        }
    }
    /**
     * @hidden @internal
     */
    resetHorizontalForOfs() {
        const elementFilter = (item) => this.isDefined(item.nativeElement.parentElement);
        this._horizontalForOfs = [
            ...this._dataRowList.filter(elementFilter).map(item => item.virtDirRow),
            ...this._summaryRowList.filter(elementFilter).map(item => item.virtDirRow)
        ];
    }
    /**
     * @hidden @internal
     */
    _setupRowObservers() {
        const elementFilter = (item) => this.isDefined(item.nativeElement.parentElement);
        const extractForOfs = pipe(map((collection) => collection.filter(elementFilter).map(item => item.virtDirRow)));
        const rowListObserver = extractForOfs(this._dataRowList.changes);
        const summaryRowObserver = extractForOfs(this._summaryRowList.changes);
        rowListObserver.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.resetHorizontalForOfs();
        });
        summaryRowObserver.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.resetHorizontalForOfs();
        });
        this.resetHorizontalForOfs();
    }
    /**
     * @hidden @internal
     */
    _zoneBegoneListeners() {
        this.zone.runOutsideAngular(() => {
            this.verticalScrollContainer.getScroll().addEventListener('scroll', this.verticalScrollHandler.bind(this));
            this.headerContainer.getScroll().addEventListener('scroll', this.horizontalScrollHandler.bind(this));
            this.observer = new ResizeObserver(() => this.resizeNotify.next());
            this.observer.observe(this.nativeElement);
        });
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        var _a;
        this.initPinning();
        this.calculateGridSizes();
        this._init = false;
        this.cdr.reattach();
        this._setupRowObservers();
        this._zoneBegoneListeners();
        this.paginatorSettings = { outlet: this.outlet };
        const vertScrDC = this.verticalScrollContainer.displayContainer;
        vertScrDC.addEventListener('scroll', this.preventContainerScroll.bind(this));
        this._pinnedRowList.changes
            .pipe(takeUntil(this.destroy$))
            .subscribe((change) => {
            this.onPinnedRowsChanged(change);
        });
        (_a = this.addRowSnackbar) === null || _a === void 0 ? void 0 : _a.clicked.subscribe(() => {
            const rec = this.filteredSortedData[this.lastAddedRowIndex];
            this.scrollTo(rec, 0);
            this.addRowSnackbar.close();
        });
        // Keep the stream open for future subscribers
        this.rendered$.pipe(takeUntil(this.destroy$)).subscribe(noop);
        Promise.resolve().then(() => this.rendered.next(true));
    }
    /**
     * @hidden @internal
     */
    notifyChanges(repaint = false) {
        this._cdrRequests = true;
        this._cdrRequestRepaint = repaint;
        this.cdr.markForCheck();
    }
    /**
     * @hidden @internal
     */
    ngDoCheck() {
        super.ngDoCheck();
        if (this._init) {
            return;
        }
        if (this._cdrRequestRepaint) {
            this.resetNotifyChanges();
            this.calculateGridSizes();
            this.refreshSearch(true);
            return;
        }
        if (this._cdrRequests) {
            this.resetNotifyChanges();
            this.cdr.detectChanges();
        }
    }
    /**
     * @hidden
     * @internal
     */
    getDragGhostCustomTemplate() {
        if (this.dragGhostCustomTemplates && this.dragGhostCustomTemplates.first) {
            return this.dragGhostCustomTemplates.first;
        }
        return null;
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.tmpOutlets.forEach((tmplOutlet) => {
            tmplOutlet.cleanCache();
        });
        this.destroy$.next(true);
        this.destroy$.complete();
        this._destroyed = true;
        if (this._advancedFilteringOverlayId) {
            this.overlayService.hide(this._advancedFilteringOverlayId);
        }
        this.zone.runOutsideAngular(() => {
            var _a, _b, _c, _d, _e;
            this.observer.disconnect();
            (_b = (_a = this.verticalScrollContainer) === null || _a === void 0 ? void 0 : _a.getScroll()) === null || _b === void 0 ? void 0 : _b.removeEventListener('scroll', this.verticalScrollHandler);
            (_d = (_c = this.headerContainer) === null || _c === void 0 ? void 0 : _c.getScroll()) === null || _d === void 0 ? void 0 : _d.removeEventListener('scroll', this.horizontalScrollHandler);
            const vertScrDC = (_e = this.verticalScrollContainer) === null || _e === void 0 ? void 0 : _e.displayContainer;
            vertScrDC === null || vertScrDC === void 0 ? void 0 : vertScrDC.removeEventListener('scroll', this.preventContainerScroll);
        });
    }
    /**
     * Toggles the specified column's visibility.
     *
     * @example
     * ```typescript
     * this.grid1.toggleColumnVisibility({
     *       column: this.grid1.columns[0],
     *       newValue: true
     * });
     * ```
     */
    toggleColumnVisibility(args) {
        const col = args.column ? this.columnList.find((c) => c === args.column) : undefined;
        if (!col) {
            return;
        }
        col.toggleVisibility(args.newValue);
    }
    /**
     * Gets/Sets a list of key-value pairs [row ID, expansion state].
     *
     * @remarks
     * Includes only states that differ from the default one.
     * Supports two-way binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="data" [(expansionStates)]="model.expansionStates">
     * </igx-grid>
     * ```
     */
    get expansionStates() {
        return this._expansionStates;
    }
    set expansionStates(value) {
        this._expansionStates = new Map(value);
        this.expansionStatesChange.emit(this._expansionStates);
        this.notifyChanges(true);
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
    }
    /**
     * Expands all rows.
     *
     * @example
     * ```typescript
     * this.grid.expandAll();
     * ```
     */
    expandAll() {
        this._defaultExpandState = true;
        this.expansionStates = new Map();
    }
    /**
     * Collapses all rows.
     *
     * @example
     * ```typescript
     * this.grid.collapseAll();
     * ```
     */
    collapseAll() {
        this._defaultExpandState = false;
        this.expansionStates = new Map();
    }
    /**
     * Expands the row by its id.
     *
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.expandRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     */
    expandRow(rowID) {
        this.gridAPI.set_row_expansion_state(rowID, true);
    }
    /**
     * Collapses the row by its id.
     *
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.collapseRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     */
    collapseRow(rowID) {
        this.gridAPI.set_row_expansion_state(rowID, false);
    }
    /**
     * Toggles the row by its id.
     *
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.toggleRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     */
    toggleRow(rowID) {
        const rec = this.gridAPI.get_rec_by_id(rowID);
        const state = this.gridAPI.get_row_expansion_state(rec);
        this.gridAPI.set_row_expansion_state(rowID, !state);
    }
    /**
     * @hidden
     * @internal
     */
    getDefaultExpandState(rec) {
        return this._defaultExpandState;
    }
    /**
     * Gets the native element.
     *
     * @example
     * ```typescript
     * const nativeEl = this.grid.nativeElement.
     * ```
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * Gets/Sets the outlet used to attach the grid's overlays to.
     *
     * @remark
     * If set, returns the outlet defined outside the grid. Otherwise returns the grid's internal outlet directive.
     */
    get outlet() {
        return this.resolveOutlet();
    }
    set outlet(val) {
        this._userOutletDirective = val;
    }
    /**
     * Gets the default row height.
     *
     * @example
     * ```typescript
     * const rowHeigh = this.grid.defaultRowHeight;
     * ```
     */
    get defaultRowHeight() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 40;
            case DisplayDensity.compact:
                return 32;
            default:
                return 50;
        }
    }
    /**
     * @hidden @internal
     */
    get defaultSummaryHeight() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 30;
            case DisplayDensity.compact:
                return 24;
            default:
                return 36;
        }
    }
    /**
     * Returns the `IgxGridHeaderGroupComponent`'s minimum allowed width.
     *
     * @remarks
     * Used internally for restricting header group component width.
     * The values below depend on the header cell default right/left padding values.
     */
    get defaultHeaderGroupMinWidth() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 32;
            case DisplayDensity.compact:
                return 24;
            default:
                return 48;
        }
    }
    /**
     * @hidden @internal
     */
    paginatorClassName() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 'igx-paginator--cosy';
            case DisplayDensity.compact:
                return 'igx-paginator--compact';
            default:
                return 'igx-paginator';
        }
    }
    /**
     * Gets the current width of the container for the pinned `IgxColumnComponent`s.
     *
     * @example
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth;
     * ```
     */
    get pinnedWidth() {
        if (!isNaN(this._pinnedWidth)) {
            return this._pinnedWidth;
        }
        this._pinnedWidth = this.getPinnedWidth();
        return this._pinnedWidth;
    }
    /**
     * Gets the current width of the container for the unpinned `IgxColumnComponent`s.
     *
     * @example
     * ```typescript
     * const unpinnedWidth = this.grid.getUnpinnedWidth;
     * ```
     */
    get unpinnedWidth() {
        if (!isNaN(this._unpinnedWidth)) {
            return this._unpinnedWidth;
        }
        this._unpinnedWidth = this.getUnpinnedWidth();
        return this._unpinnedWidth;
    }
    /**
     * @hidden @internal
     */
    get isHorizontalScrollHidden() {
        const diff = this.unpinnedWidth - this.totalWidth;
        return this.width === null || diff >= 0;
    }
    /**
     * @hidden @internal
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     */
    featureColumnsWidth(expander) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (Number.isNaN(this._headerFeaturesWidth)) {
            // TODO: platformUtil.isBrowser check
            const rowSelectArea = ((_b = (_a = this.headerSelectorContainer) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect) ?
                this.headerSelectorContainer.nativeElement.getBoundingClientRect().width : 0;
            const rowDragArea = this.rowDraggable && ((_d = (_c = this.headerDragContainer) === null || _c === void 0 ? void 0 : _c.nativeElement) === null || _d === void 0 ? void 0 : _d.getBoundingClientRect) ?
                this.headerDragContainer.nativeElement.getBoundingClientRect().width : 0;
            const groupableArea = ((_f = (_e = this.headerGroupContainer) === null || _e === void 0 ? void 0 : _e.nativeElement) === null || _f === void 0 ? void 0 : _f.getBoundingClientRect) ?
                this.headerGroupContainer.nativeElement.getBoundingClientRect().width : 0;
            const expanderWidth = ((_g = expander === null || expander === void 0 ? void 0 : expander.nativeElement) === null || _g === void 0 ? void 0 : _g.getBoundingClientRect) ? expander.nativeElement.getBoundingClientRect().width : 0;
            this._headerFeaturesWidth = rowSelectArea + rowDragArea + groupableArea + expanderWidth;
        }
        return this._headerFeaturesWidth;
    }
    /**
     * @hidden @internal
     */
    get summariesMargin() {
        return this.featureColumnsWidth();
    }
    /**
     * Gets an array of `IgxColumnComponent`s.
     *
     * @example
     * ```typescript
     * const colums = this.grid.columns.
     * ```
     */
    get columns() {
        return this._columns;
    }
    /**
     * Gets an array of the pinned `IgxColumnComponent`s.
     *
     * @example
     * ```typescript
     * const pinnedColumns = this.grid.pinnedColumns.
     * ```
     */
    get pinnedColumns() {
        if (this._pinnedVisible.length) {
            return this._pinnedVisible;
        }
        this._pinnedVisible = this._pinnedColumns.filter(col => !col.hidden);
        return this._pinnedVisible;
    }
    /**
     * Gets an array of the pinned `IgxRowComponent`s.
     *
     * @example
     * ```typescript
     * const pinnedRow = this.grid.pinnedRows;
     * ```
     */
    get pinnedRows() {
        return this._pinnedRowList.toArray().sort((a, b) => a.index - b.index);
    }
    /**
     * Gets an array of unpinned `IgxColumnComponent`s.
     *
     * @example
     * ```typescript
     * const unpinnedColumns = this.grid.unpinnedColumns.
     * ```
     */
    get unpinnedColumns() {
        if (this._unpinnedVisible.length) {
            return this._unpinnedVisible;
        }
        this._unpinnedVisible = this._unpinnedColumns.filter((col) => !col.hidden);
        return this._unpinnedVisible;
    }
    /**
     * Gets the `width` to be set on `IgxGridHeaderGroupComponent`.
     */
    getHeaderGroupWidth(column) {
        if (this.hasColumnLayouts) {
            return '';
        }
        const colWidth = parseFloat(column.calcWidth);
        const minWidth = this.defaultHeaderGroupMinWidth;
        if (colWidth < minWidth) {
            return minWidth + 'px';
        }
        return colWidth + 'px';
    }
    /**
     * Returns the `IgxColumnComponent` by field name.
     *
     * @example
     * ```typescript
     * const myCol = this.grid1.getColumnByName("ID");
     * ```
     * @param name
     */
    getColumnByName(name) {
        return this.columnList.find((col) => col.field === name);
    }
    getColumnByVisibleIndex(index) {
        return this.visibleColumns.find((col) => !col.columnGroup && !col.columnLayout &&
            col.visibleIndex === index);
    }
    /**
     * Returns the `IgxRowDirective` by index.
     *
     * @example
     * ```typescript
     * const myRow = this.grid1.getRowByIndex(1);
     * ```
     * @param index
     */
    getRowByIndex(index) {
        return this.gridAPI.get_row_by_index(index);
    }
    /**
     * Returns `IgxGridRowComponent` object by the specified primary key .
     *
     * @remarks
     * Requires that the `primaryKey` property is set.
     * @example
     * ```typescript
     * const myRow = this.grid1.getRowByKey("cell5");
     * ```
     * @param keyValue
     */
    getRowByKey(keyValue) {
        return this.gridAPI.get_row_by_key(keyValue);
    }
    /**
     * Returns an array of visible `IgxColumnComponent`s.
     *
     * @example
     * ```typescript
     * const visibleColumns = this.grid.visibleColumns.
     * ```
     */
    get visibleColumns() {
        if (this._visibleColumns.length) {
            return this._visibleColumns;
        }
        this._visibleColumns = this.columnList.filter(c => !c.hidden);
        return this._visibleColumns;
    }
    /**
     * Returns the `IgxGridCellComponent` that matches the conditions.
     *
     * @example
     * ```typescript
     * const myCell = this.grid1.getCellByColumn(2,"UnitPrice");
     * ```
     * @param rowIndex
     * @param columnField
     */
    getCellByColumn(rowIndex, columnField) {
        const columnId = this.columnList.map((column) => column.field).indexOf(columnField);
        if (columnId !== -1) {
            return this.gridAPI.get_cell_by_index(rowIndex, columnId);
        }
    }
    getCellByColumnVisibleIndex(rowIndex, index) {
        return this.gridAPI.get_cell_by_visible_index(rowIndex, index);
    }
    /**
     * Returns an `IgxGridCellComponent` object by the specified primary key and column field.
     *
     * @remarks
     * Requires that the primaryKey property is set.
     * @example
     * ```typescript
     * grid.getCellByKey(1, 'index');
     * ```
     * @param rowSelector match any rowID
     * @param columnField
     */
    getCellByKey(rowSelector, columnField) {
        return this.gridAPI.get_cell_by_key(rowSelector, columnField);
    }
    /**
     * Gets the total number of pages.
     *
     * @example
     * ```typescript
     * const totalPages = this.grid.totalPages;
     * ```
     */
    get totalPages() {
        if (this.pagingState) {
            return this.pagingState.metadata.countPages;
        }
        return this._totalRecords >= 0 ? Math.ceil(this._totalRecords / this.perPage) : -1;
    }
    /**
     * Gets if the current page is the first page.
     *
     * @example
     * ```typescript
     * const firstPage = this.grid.isFirstPage;
     * ```
     */
    get isFirstPage() {
        return this.page === 0;
    }
    /**
     * Goes to the next page, if the grid is not already at the last page.
     *
     * @example
     * ```typescript
     * this.grid1.nextPage();
     * ```
     */
    nextPage() {
        if (!this.isLastPage) {
            this.page += 1;
        }
    }
    /**
     * Goes to the previous page, if the grid is not already at the first page.
     *
     * @example
     * ```typescript
     * this.grid1.previousPage();
     * ```
     */
    previousPage() {
        if (!this.isFirstPage) {
            this.page -= 1;
        }
    }
    /**
     * Returns the total number of records.
     *
     * @remarks
     * Only functions when paging is enabled.
     * @example
     * ```typescript
     * const totalRecords = this.grid.totalRecords;
     * ```
     */
    get totalRecords() {
        var _a;
        return this._totalRecords >= 0 ? this._totalRecords : (_a = this.pagingState) === null || _a === void 0 ? void 0 : _a.metadata.countRecords;
    }
    set totalRecords(total) {
        if (total >= 0) {
            this._totalRecords = total;
            this._pipeTrigger++;
            this.notifyChanges();
        }
    }
    /**
     * Returns if the current page is the last page.
     *
     * @example
     * ```typescript
     * const lastPage = this.grid.isLastPage;
     * ```
     */
    get isLastPage() {
        return this.page + 1 >= this.totalPages;
    }
    /**
     * Returns the total width of the `IgxGridComponent`.
     *
     * @example
     * ```typescript
     * const gridWidth = this.grid.totalWidth;
     * ```
     */
    get totalWidth() {
        if (!isNaN(this._totalWidth)) {
            return this._totalWidth;
        }
        // Take only top level columns
        const cols = this.visibleColumns.filter(col => col.level === 0 && !col.pinned);
        let totalWidth = 0;
        let i = 0;
        for (i; i < cols.length; i++) {
            totalWidth += parseInt(cols[i].calcWidth, 10) || 0;
        }
        this._totalWidth = totalWidth;
        return totalWidth;
    }
    /**
     * @hidden
     * @internal
     */
    get showRowSelectors() {
        return this.isRowSelectable && this.hasVisibleColumns && !this.hideRowSelectors;
    }
    /**
     * @hidden
     * @internal
     */
    get showAddButton() {
        return this.rowEditable && this.dataView.length === 0 && this.columns.length > 0;
    }
    /**
     * @hidden
     * @internal
     */
    get showDragIcons() {
        return this.rowDraggable && this.columns.length > this.hiddenColumnsCount;
    }
    /**
     * Places a column before or after the specified target column.
     *
     * @example
     * ```typescript
     * grid.moveColumn(column, target);
     * ```
     */
    moveColumn(column, target, pos = DropPosition.AfterDropTarget) {
        if (column === target || (column.level !== target.level) ||
            (column.topLevelParent !== target.topLevelParent)) {
            return;
        }
        if (column.level) {
            this._moveChildColumns(column.parent, column, target, pos);
        }
        let columnPinStateChanged;
        // pinning and unpinning will work correctly even without passing index
        // but is easier to calclulate the index here, and later use it in the pinning event args
        if (target.pinned && !column.pinned) {
            const pinnedIndex = this._pinnedColumns.indexOf(target);
            const index = pos === DropPosition.AfterDropTarget ? pinnedIndex + 1 : pinnedIndex;
            columnPinStateChanged = column.pin(index);
        }
        if (!target.pinned && column.pinned) {
            const unpinnedIndex = this._unpinnedColumns.indexOf(target);
            const index = pos === DropPosition.AfterDropTarget ? unpinnedIndex + 1 : unpinnedIndex;
            columnPinStateChanged = column.unpin(index);
        }
        if (target.pinned && column.pinned && !columnPinStateChanged) {
            this._reorderColumns(column, target, pos, this._pinnedColumns);
        }
        if (!target.pinned && !column.pinned && !columnPinStateChanged) {
            this._reorderColumns(column, target, pos, this._unpinnedColumns);
        }
        this._moveColumns(column, target, pos);
        this._columnsReordered(column, target);
        this.onColumnMovingEnd.emit({ source: column, target });
    }
    /**
     * Goes to the desired page index.
     *
     * @example
     * ```typescript
     * this.grid1.paginate(1);
     * ```
     * @param val
     */
    paginate(val) {
        if (val < 0 || val > this.totalPages - 1) {
            return;
        }
        this.page = val;
    }
    /**
     * Manually marks the `IgxGridComponent` for change detection.
     *
     * @example
     * ```typescript
     * this.grid1.markForCheck();
     * ```
     */
    markForCheck() {
        this.cdr.detectChanges();
    }
    /**
     * @hidden @internal
     */
    beginAddRowByIndex(rowID, index, asChild, event) {
        if (!this.rowEditable) {
            console.warn('The grid must use row edit mode to perform row adding! Please set rowEditable to true.');
            return;
        }
        this.endEdit(true, event);
        this.cancelAddMode = false;
        const isInPinnedArea = this.isRecordPinnedByViewIndex(index);
        const pinIndex = this.pinnedRecords.findIndex(x => x[this.primaryKey] === rowID);
        const unpinIndex = this.getUnpinnedIndexById(rowID);
        if (this.expansionStates.get(rowID)) {
            this.collapseRow(rowID);
        }
        this.addRowParent = {
            rowID,
            index: isInPinnedArea ? pinIndex : unpinIndex,
            asChild,
            isPinned: isInPinnedArea
        };
        this._pipeTrigger++;
        this.cdr.detectChanges();
        if (isInPinnedArea) {
            this.calculateGridHeight();
        }
        const newRowIndex = this.addRowParent.index + 1;
        // ensure adding row is in view.
        const shouldScroll = this.navigation.shouldPerformVerticalScroll(newRowIndex, -1);
        if (shouldScroll) {
            this.navigateTo(newRowIndex, -1);
        }
        const row = this.getRowByIndex(index + 1);
        row.animateAdd = true;
        row.onAnimationEnd.pipe(first$1()).subscribe(() => {
            row.animateAdd = false;
            const cell = row.cells.find(c => c.editable);
            if (cell) {
                this.gridAPI.submit_value(event);
                this.crudService.enterEditMode(cell, event);
                cell.activate();
            }
        });
    }
    /**
     * Creates a new `IgxGridRowComponent` and adds the data record to the end of the data source.
     *
     * @example
     * ```typescript
     * this.grid1.addRow(record);
     * ```
     * @param data
     */
    addRow(data) {
        // commit pending states prior to adding a row
        this.endEdit(true);
        this.gridAPI.addRowToData(data);
        this.onRowAdded.emit({ data });
        this._pipeTrigger++;
        this.notifyChanges();
    }
    /**
     * Removes the `IgxGridRowComponent` and the corresponding data record by primary key.
     *
     * @remarks
     * Requires that the `primaryKey` property is set.
     * The method accept rowSelector as a parameter, which is the rowID.
     * @example
     * ```typescript
     * this.grid1.deleteRow(0);
     * ```
     * @param rowSelector
     */
    deleteRow(rowSelector) {
        if (this.primaryKey !== undefined && this.primaryKey !== null) {
            this.deleteRowById(rowSelector);
        }
    }
    /** @hidden */
    deleteRowById(rowId) {
        this.gridAPI.deleteRowById(rowId);
    }
    /**
     * Updates the `IgxGridRowComponent` and the corresponding data record by primary key.
     *
     * @remarks
     * Requires that the `primaryKey` property is set.
     * @example
     * ```typescript
     * this.gridWithPK.updateCell('Updated', 1, 'ProductName');
     * ```
     * @param value the new value which is to be set.
     * @param rowSelector corresponds to rowID.
     * @param column corresponds to column field.
     */
    updateCell(value, rowSelector, column) {
        if (this.isDefined(this.primaryKey)) {
            const col = this.columnList.toArray().find(c => c.field === column);
            if (col) {
                // Simplify
                const rowData = this.gridAPI.getRowData(rowSelector);
                const index = this.gridAPI.get_row_index_in_data(rowSelector);
                // If row passed is invalid
                if (index < 0) {
                    return;
                }
                const id = {
                    rowID: rowSelector,
                    columnID: col.index,
                    rowIndex: index
                };
                const cell = new IgxCell(id, index, col, rowData[col.field], rowData[col.field], rowData, this);
                const args = this.gridAPI.update_cell(cell, value);
                if (this.crudService.cell && this.crudService.sameCell(cell)) {
                    if (args.cancel) {
                        return;
                    }
                    this.crudService.exitCellEdit();
                }
                this.cdr.detectChanges();
            }
        }
    }
    /**
     * Updates the `IgxGridRowComponent`
     *
     * @remarks
     * The row is specified by
     * rowSelector parameter and the data source record with the passed value.
     * This method will apply requested update only if primary key is specified in the grid.
     * @example
     * ```typescript
     * grid.updateRow({
     *       ProductID: 1, ProductName: 'Spearmint', InStock: true, UnitsInStock: 1, OrderDate: new Date('2005-03-21')
     *   }, 1);
     * ```
     * @param value
     * @param rowSelector correspond to rowID
     */
    updateRow(value, rowSelector) {
        if (this.isDefined(this.primaryKey)) {
            const editableCell = this.crudService.cell;
            if (editableCell && editableCell.id.rowID === rowSelector) {
                this.crudService.exitCellEdit();
            }
            const row = new IgxRow(rowSelector, -1, this.gridAPI.getRowData(rowSelector), this);
            this.gridAPI.update_row(row, value);
            // TODO: fix for #5934 and probably break for #5763
            // consider adding of third optional boolean parameter in updateRow.
            // If developer set this parameter to true we should call notifyChanges(true), and
            // vise-versa if developer set it to false we should call notifyChanges(false).
            // The parameter should default to false
            this.notifyChanges();
        }
    }
    /**
     * Returns the data that is contained in the row component.
     *
     * @remarks
     * If the primary key is not specified the row selector match the row data.
     * @example
     * ```typescript
     * const data = grid.getRowData(94741);
     * ```
     * @param rowSelector correspond to rowID
     */
    getRowData(rowSelector) {
        if (!this.primaryKey) {
            return rowSelector;
        }
        const data = this.gridAPI.get_all_data(this.transactions.enabled);
        const index = this.gridAPI.get_row_index_in_data(rowSelector);
        return index < 0 ? {} : data[index];
    }
    /**
     * Sort a single `IgxColumnComponent`.
     *
     * @remarks
     * Sort the `IgxGridComponent`'s `IgxColumnComponent` based on the provided array of sorting expressions.
     * @example
     * ```typescript
     * this.grid.sort({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * ```
     */
    sort(expression) {
        const sortingState = cloneArray(this.sortingExpressions);
        if (expression instanceof Array) {
            for (const each of expression) {
                if (each.dir === SortingDirection.None) {
                    this.gridAPI.remove_grouping_expression(each.fieldName);
                }
                this.gridAPI.prepare_sorting_expression([sortingState], each);
            }
        }
        else {
            if (expression.dir === SortingDirection.None) {
                this.gridAPI.remove_grouping_expression(expression.fieldName);
            }
            this.gridAPI.prepare_sorting_expression([sortingState], expression);
        }
        const eventArgs = { owner: this, sortingExpressions: sortingState, cancel: false };
        this.sorting.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        this.endEdit(false);
        if (expression instanceof Array) {
            this.gridAPI.sort_multiple(expression);
        }
        else {
            this.gridAPI.sort(expression);
        }
        requestAnimationFrame(() => this.onSortingDone.emit(expression));
    }
    /**
     * Filters a single `IgxColumnComponent`.
     *
     * @example
     * ```typescript
     * public filter(term) {
     *      this.grid.filter("ProductName", term, IgxStringFilteringOperand.instance().condition("contains"));
     * }
     * ```
     * @param name
     * @param value
     * @param conditionOrExpressionTree
     * @param ignoreCase
     */
    filter(name, value, conditionOrExpressionTree, ignoreCase) {
        this.filteringService.filter(name, value, conditionOrExpressionTree, ignoreCase);
    }
    /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     *
     * @example
     * ```typescript
     * grid.filterGlobal('some', IgxStringFilteringOperand.instance().condition('contains'));
     * ```
     * @param value
     * @param condition
     * @param ignoreCase
     */
    filterGlobal(value, condition, ignoreCase) {
        this.filteringService.filterGlobal(value, condition, ignoreCase);
    }
    /**
     * Enables summaries for the specified column and applies your customSummary.
     *
     * @remarks
     * If you do not provide the customSummary, then the default summary for the column data type will be applied.
     * @example
     * ```typescript
     * grid.enableSummaries([{ fieldName: 'ProductName' }, { fieldName: 'ID' }]);
     * ```
     * Enable summaries for the listed columns.
     * @example
     * ```typescript
     * grid.enableSummaries('ProductName');
     * ```
     * @param rest
     */
    enableSummaries(...rest) {
        if (rest.length === 1 && Array.isArray(rest[0])) {
            this._multipleSummaries(rest[0], true);
        }
        else {
            this._summaries(rest[0], true, rest[1]);
        }
    }
    /**
     * Disable summaries for the specified column.
     *
     * @example
     * ```typescript
     * grid.disableSummaries('ProductName');
     * ```
     * @remarks
     * Disable summaries for the listed columns.
     * @example
     * ```typescript
     * grid.disableSummaries([{ fieldName: 'ProductName' }]);
     * ```
     */
    disableSummaries(...rest) {
        if (rest.length === 1 && Array.isArray(rest[0])) {
            this._disableMultipleSummaries(rest[0]);
        }
        else {
            this._summaries(rest[0], false);
        }
    }
    /**
     * If name is provided, clears the filtering state of the corresponding `IgxColumnComponent`.
     *
     * @remarks
     * Otherwise clears the filtering state of all `IgxColumnComponent`s.
     * @example
     * ```typescript
     * this.grid.clearFilter();
     * ```
     * @param name
     */
    clearFilter(name) {
        this.filteringService.clearFilter(name);
    }
    /**
     * If name is provided, clears the sorting state of the corresponding `IgxColumnComponent`.
     *
     * @remarks
     * otherwise clears the sorting state of all `IgxColumnComponent`.
     * @example
     * ```typescript
     * this.grid.clearSort();
     * ```
     * @param name
     */
    clearSort(name) {
        if (!name) {
            this.sortingExpressions = [];
            return;
        }
        if (!this.gridAPI.get_column_by_name(name)) {
            return;
        }
        this.gridAPI.clear_sort(name);
    }
    /**
     * @hidden @internal
     */
    refreshGridState(args) {
        this.endEdit(true);
        this.selectionService.clearHeaderCBState();
        this.summaryService.clearSummaryCache();
        this.cdr.detectChanges();
    }
    // TODO: We have return values here. Move them to event args ??
    /**
     * Pins a column by field name.
     *
     * @remarks
     * Returns whether the operation is successful.
     * @example
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * @param columnName
     * @param index
     */
    pinColumn(columnName, index) {
        const col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
        return col.pin(index);
    }
    /**
     * Unpins a column by field name. Returns whether the operation is successful.
     *
     * @example
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * @param columnName
     * @param index
     */
    unpinColumn(columnName, index) {
        const col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
        return col.unpin(index);
    }
    /**
     * Pin the row by its id.
     *
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.pinRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     * @param index The index at which to insert the row in the pinned collection.
     */
    pinRow(rowID, index) {
        if (this._pinnedRecordIDs.indexOf(rowID) !== -1) {
            return false;
        }
        const row = this.gridAPI.get_row_by_key(rowID);
        const eventArgs = {
            insertAtIndex: index,
            isPinned: true,
            rowID,
            row
        };
        this.onRowPinning.emit(eventArgs);
        this.endEdit(false);
        const insertIndex = typeof eventArgs.insertAtIndex === 'number' ? eventArgs.insertAtIndex : this._pinnedRecordIDs.length;
        this._pinnedRecordIDs.splice(insertIndex, 0, rowID);
        this._pipeTrigger++;
        if (this.gridAPI.grid) {
            this.notifyChanges();
        }
    }
    /**
     * Unpin the row by its id.
     *
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.unpinRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     */
    unpinRow(rowID) {
        const index = this._pinnedRecordIDs.indexOf(rowID);
        if (index === -1) {
            return false;
        }
        const row = this.gridAPI.get_row_by_key(rowID);
        const eventArgs = {
            isPinned: false,
            rowID,
            row
        };
        this.onRowPinning.emit(eventArgs);
        this.endEdit(false);
        this._pinnedRecordIDs.splice(index, 1);
        this._pipeTrigger++;
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
        return true;
    }
    get pinnedRowHeight() {
        const containerHeight = this.pinContainer ? this.pinContainer.nativeElement.offsetHeight : 0;
        return this.hasPinnedRecords ? containerHeight : 0;
    }
    get totalHeight() {
        return this.calcHeight ? this.calcHeight + this.pinnedRowHeight : this.calcHeight;
    }
    /**
     * Recalculates grid width/height dimensions.
     *
     * @remarks
     * Should be run when changing DOM elements dimentions manually that affect the grid's size.
     * @example
     * ```typescript
     * this.grid.reflow();
     * ```
     */
    reflow() {
        this.calculateGridSizes();
    }
    /**
     * Finds the next occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     *
     * @remarks
     * Returns how many times the grid contains the string.
     * @example
     * ```typescript
     * this.grid.findNext("financial");
     * ```
     * @param text the string to search.
     * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param exactMatch optionally, if the text should match the entire value  (defaults to false).
     */
    findNext(text, caseSensitive, exactMatch) {
        return this.find(text, 1, caseSensitive, exactMatch);
    }
    /**
     * Finds the previous occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     *
     * @remarks
     * Returns how many times the grid contains the string.
     * @example
     * ```typescript
     * this.grid.findPrev("financial");
     * ```
     * @param text the string to search.
     * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param exactMatch optionally, if the text should match the entire value (defaults to false).
     */
    findPrev(text, caseSensitive, exactMatch) {
        return this.find(text, -1, caseSensitive, exactMatch);
    }
    /**
     * Reapplies the existing search.
     *
     * @remarks
     * Returns how many times the grid contains the last search.
     * @example
     * ```typescript
     * this.grid.refreshSearch();
     * ```
     * @param updateActiveInfo
     */
    refreshSearch(updateActiveInfo, endEdit = true) {
        if (this.lastSearchInfo.searchText) {
            this.rebuildMatchCache();
            if (updateActiveInfo) {
                const activeInfo = IgxTextHighlightDirective.highlightGroupsMap.get(this.id);
                this.lastSearchInfo.matchInfoCache.forEach((match, i) => {
                    if (match.column === activeInfo.column &&
                        match.row === activeInfo.row &&
                        match.index === activeInfo.index &&
                        compareMaps(match.metadata, activeInfo.metadata)) {
                        this.lastSearchInfo.activeMatchIndex = i;
                    }
                });
            }
            return this.find(this.lastSearchInfo.searchText, 0, this.lastSearchInfo.caseSensitive, this.lastSearchInfo.exactMatch, false, endEdit);
        }
        else {
            return 0;
        }
    }
    /**
     * Removes all the highlights in the cell.
     *
     * @example
     * ```typescript
     * this.grid.clearSearch();
     * ```
     */
    clearSearch() {
        this.lastSearchInfo = {
            searchText: '',
            caseSensitive: false,
            exactMatch: false,
            activeMatchIndex: 0,
            matchInfoCache: []
        };
        this.rowList.forEach((row) => {
            if (row.cells) {
                row.cells.forEach((c) => {
                    c.clearHighlight();
                });
            }
        });
    }
    /**
     * Returns if the `IgxGridComponent` has sortable columns.
     *
     * @example
     * ```typescript
     * const sortableGrid = this.grid.hasSortableColumns;
     * ```
     */
    get hasSortableColumns() {
        return this.columnList.some((col) => col.sortable);
    }
    /**
     * Returns if the `IgxGridComponent` has editable columns.
     *
     * @example
     * ```typescript
     * const editableGrid = this.grid.hasEditableColumns;
     * ```
     */
    get hasEditableColumns() {
        return this.columnList.some((col) => col.editable);
    }
    /**
     * Returns if the `IgxGridComponent` has filterable columns.
     *
     * @example
     * ```typescript
     * const filterableGrid = this.grid.hasFilterableColumns;
     * ```
     */
    get hasFilterableColumns() {
        return this.columnList.some((col) => col.filterable);
    }
    /**
     * Returns if the `IgxGridComponent` has summarized columns.
     *
     * @example
     * ```typescript
     * const summarizedGrid = this.grid.hasSummarizedColumns;
     * ```
     */
    get hasSummarizedColumns() {
        return this.summaryService.hasSummarizedColumns;
    }
    /**
     * @hidden @internal
     */
    get rootSummariesEnabled() {
        return this.summaryCalculationMode !== GridSummaryCalculationMode.childLevelsOnly;
    }
    /**
     * @hidden @internal
     */
    get hasVisibleColumns() {
        if (this._hasVisibleColumns === undefined) {
            return this.columnList ? this.columnList.some(c => !c.hidden) : false;
        }
        return this._hasVisibleColumns;
    }
    set hasVisibleColumns(value) {
        this._hasVisibleColumns = value;
    }
    /**
     * Returns if the `IgxGridComponent` has moveable columns.
     *
     * @example
     * ```typescript
     * const movableGrid = this.grid.hasMovableColumns;
     * ```
     */
    get hasMovableColumns() {
        return this.columnList && this.columnList.some((col) => col.movable);
    }
    /**
     * Returns if the `IgxGridComponent` has column groups.
     *
     * @example
     * ```typescript
     * const groupGrid = this.grid.hasColumnGroups;
     * ```
     */
    get hasColumnGroups() {
        return this._columnGroups;
    }
    /**
     * Returns if the `IgxGridComponent` has column layouts for multi-row layout definition.
     *
     * @example
     * ```typescript
     * const layoutGrid = this.grid.hasColumnLayouts;
     * ```
     */
    get hasColumnLayouts() {
        return !!this.columnList.some(col => col.columnLayout);
    }
    /**
     * Returns an array of the selected `IgxGridCellComponent`s.
     *
     * @example
     * ```typescript
     * const selectedCells = this.grid.selectedCells;
     * ```
     */
    get selectedCells() {
        if (this.dataRowList) {
            return this.dataRowList.map((row) => row.cells.filter((cell) => cell.selected))
                .reduce((a, b) => a.concat(b), []);
        }
        return [];
    }
    /**
     * @hidden @internal
     */
    get multiRowLayoutRowSize() {
        return this._multiRowLayoutRowSize;
    }
    /**
     * @hidden
     */
    get rowBasedHeight() {
        return this.dataLength * this.rowHeight;
    }
    /**
     * @hidden
     */
    get isPercentWidth() {
        return this.width && this.width.indexOf('%') !== -1;
    }
    /**
     * @hidden @internal
     */
    get isPercentHeight() {
        return this._height && this._height.indexOf('%') !== -1;
    }
    /**
     * @hidden
     */
    get defaultTargetBodyHeight() {
        const allItems = this.dataLength;
        return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
    }
    /**
     * @hidden @internal
     * The rowHeight input is bound to min-height css prop of rows that adds a 1px border in all cases
     */
    get renderedRowHeight() {
        return this.rowHeight + 1;
    }
    /**
     * @hidden @internal
     */
    get outerWidth() {
        return this.hasVerticalScroll() ? this.calcWidth + this.scrollSize : this.calcWidth;
    }
    /**
     * @hidden @internal
     * Gets the visible content height that includes header + tbody + footer.
     */
    getVisibleContentHeight() {
        let height = this.theadRow.nativeElement.clientHeight + this.tbody.nativeElement.clientHeight;
        if (this.hasSummarizedColumns) {
            height += this.tfoot.nativeElement.clientHeight;
        }
        return height;
    }
    /**
     * @hidden @internal
     */
    getPossibleColumnWidth(baseWidth = null) {
        let computedWidth;
        if (baseWidth !== null) {
            computedWidth = baseWidth;
        }
        else {
            computedWidth = this.calcWidth ||
                parseInt(this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width'), 10);
        }
        computedWidth -= this.featureColumnsWidth();
        const visibleChildColumns = this.visibleColumns.filter(c => !c.columnGroup);
        // Column layouts related
        let visibleCols = [];
        const columnBlocks = this.visibleColumns.filter(c => c.columnGroup);
        const colsPerBlock = columnBlocks.map(block => block.getInitialChildColumnSizes(block.children));
        const combinedBlocksSize = colsPerBlock.reduce((acc, item) => acc + item.length, 0);
        colsPerBlock.forEach(blockCols => visibleCols = visibleCols.concat(blockCols));
        //
        const columnsWithSetWidths = this.hasColumnLayouts ?
            visibleCols.filter(c => c.widthSetByUser) :
            visibleChildColumns.filter(c => c.widthSetByUser);
        const columnsToSize = this.hasColumnLayouts ?
            combinedBlocksSize - columnsWithSetWidths.length :
            visibleChildColumns.length - columnsWithSetWidths.length;
        const sumExistingWidths = columnsWithSetWidths
            .reduce((prev, curr) => {
            const colWidth = curr.width;
            const widthValue = parseInt(colWidth, 10);
            const currWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1 ?
                widthValue / 100 * computedWidth :
                widthValue;
            return prev + currWidth;
        }, 0);
        // When all columns are hidden, return 0px width
        if (!sumExistingWidths && !columnsToSize) {
            return '0px';
        }
        const columnWidth = Math.floor(!Number.isFinite(sumExistingWidths) ?
            Math.max(computedWidth / columnsToSize, MINIMUM_COLUMN_WIDTH) :
            Math.max((computedWidth - sumExistingWidths) / columnsToSize, MINIMUM_COLUMN_WIDTH));
        return columnWidth + 'px';
    }
    /**
     * @hidden @internal
     */
    hasVerticalScroll() {
        if (this._init) {
            return false;
        }
        const isScrollable = this.verticalScrollContainer ? this.verticalScrollContainer.isScrollable() : false;
        return !!(this.calcWidth && this.dataView && this.dataView.length > 0 && isScrollable);
    }
    /**
     * Gets calculated width of the pinned area.
     *
     * @example
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth();
     * ```
     * @param takeHidden If we should take into account the hidden columns in the pinned area.
     */
    getPinnedWidth(takeHidden = false) {
        const fc = takeHidden ? this._pinnedColumns : this.pinnedColumns;
        let sum = 0;
        for (const col of fc) {
            if (col.level === 0) {
                sum += parseInt(col.calcWidth, 10);
            }
        }
        if (this.isPinningToStart) {
            sum += this.featureColumnsWidth();
        }
        return sum;
    }
    /**
     * @hidden
     */
    onlyTopLevel(arr) {
        return arr.filter(c => c.level === 0);
    }
    /**
     * @hidden @internal
     */
    isColumnGrouped(fieldName) {
        return false;
    }
    /**
     * @hidden @internal
     */
    onHeaderSelectorClick(event) {
        if (!this.isMultiRowSelectionEnabled) {
            return;
        }
        if (this.selectionService.areAllRowSelected()) {
            this.selectionService.clearRowSelection(event);
        }
        else {
            this.selectionService.selectAllRows(event);
        }
    }
    /**
     * @hidden @internal
     */
    get headSelectorBaseAriaLabel() {
        if (this._filteringExpressionsTree.filteringOperands.length > 0) {
            return this.selectionService.areAllRowSelected() ? 'Deselect all filtered' : 'Select all filtered';
        }
        return this.selectionService.areAllRowSelected() ? 'Deselect all' : 'Select all';
    }
    /**
     * @hidden
     * @internal
     */
    get totalRowsCountAfterFilter() {
        if (this.data) {
            return this.selectionService.allData.length;
        }
        return 0;
    }
    /**
     * Returns the currently transformed paged/filtered/sorted/grouped pinned row data, displayed in the grid.
     *
     * @example
     * ```typescript
     *      const pinnedDataView = this.grid.pinnedDataView;
     * ```
     */
    get pinnedDataView() {
        return this.pinnedRecords ? this.pinnedRecords : [];
    }
    /**
     * Returns currently transformed paged/filtered/sorted/grouped unpinned row data, displayed in the grid.
     *
     * @example
     * ```typescript
     *      const pinnedDataView = this.grid.pinnedDataView;
     * ```
     */
    get unpinnedDataView() {
        return this.unpinnedRecords ? this.unpinnedRecords : this.verticalScrollContainer.igxForOf || [];
    }
    /**
     * Returns the currently transformed paged/filtered/sorted/grouped/pinned/unpinned row data, displayed in the grid.
     *
     * @example
     * ```typescript
     *      const dataView = this.grid.dataView;
     * ```
     */
    get dataView() {
        return this.isRowPinningToTop ?
            [...this.pinnedDataView, ...this.unpinnedDataView] :
            [...this.unpinnedDataView, ...this.pinnedDataView];
    }
    /**
     * Gets/Sets whether clicking over a row should select/deselect it
     *
     * @remarks
     * By default it is set to true
     * @param enabled: boolean
     */
    get selectRowOnClick() {
        return this._selectRowOnClick;
    }
    set selectRowOnClick(enabled) {
        this._selectRowOnClick = enabled;
    }
    /**
     * Select specified rows by ID.
     *
     * @example
     * ```typescript
     * this.grid.selectRows([1,2,5], true);
     * ```
     * @param rowIDs
     * @param clearCurrentSelection if true clears the current selection
     */
    selectRows(rowIDs, clearCurrentSelection) {
        this.selectionService.selectRowsWithNoEvent(rowIDs, clearCurrentSelection);
        this.notifyChanges();
    }
    /**
     * Deselect specified rows by ID.
     *
     * @example
     * ```typescript
     * this.grid.deselectRows([1,2,5]);
     * ```
     * @param rowIDs
     */
    deselectRows(rowIDs) {
        this.selectionService.deselectRowsWithNoEvent(rowIDs);
        this.notifyChanges();
    }
    /**
     * Selects all rows
     *
     * @remarks
     * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * If you set the parameter onlyFilterData to false that will select all rows in the grid exept deleted rows.
     * @example
     * ```typescript
     * this.grid.selectAllRows();
     * this.grid.selectAllRows(false);
     * ```
     * @param onlyFilterData
     */
    selectAllRows(onlyFilterData = true) {
        const data = onlyFilterData && this.filteredData ? this.filteredData : this.gridAPI.get_all_data(true);
        const rowIDs = this.selectionService.getRowIDs(data).filter(rID => !this.gridAPI.row_deleted_transaction(rID));
        this.selectRows(rowIDs);
    }
    /**
     * Deselects all rows
     *
     * @remarks
     * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * If you set the parameter onlyFilterData to false that will deselect all rows in the grid exept deleted rows.
     * @example
     * ```typescript
     * this.grid.deselectAllRows();
     * ```
     * @param onlyFilterData
     */
    deselectAllRows(onlyFilterData = true) {
        if (onlyFilterData && this.filteredData && this.filteredData.length > 0) {
            this.deselectRows(this.selectionService.getRowIDs(this.filteredData));
        }
        else {
            this.selectionService.clearAllSelectedRows();
            this.notifyChanges();
        }
    }
    /**
     * @hidden @internal
     */
    clearCellSelection() {
        this.selectionService.clear(true);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    dragScroll(dir) {
        const scrollDelta = 48;
        const horizontal = this.headerContainer.getScroll();
        const vertical = this.verticalScrollContainer.getScroll();
        switch (dir) {
            case DragScrollDirection.LEFT:
                horizontal.scrollLeft -= scrollDelta;
                break;
            case DragScrollDirection.RIGHT:
                horizontal.scrollLeft += scrollDelta;
                break;
            case DragScrollDirection.TOP:
                vertical.scrollTop -= scrollDelta;
                break;
            case DragScrollDirection.BOTTOM:
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.BOTTOMLEFT:
                horizontal.scrollLeft -= scrollDelta;
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.BOTTOMRIGHT:
                horizontal.scrollLeft += scrollDelta;
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.TOPLEFT:
                horizontal.scrollLeft -= scrollDelta;
                vertical.scrollTop -= scrollDelta;
                break;
            case DragScrollDirection.TOPRIGHT:
                horizontal.scrollLeft += scrollDelta;
                vertical.scrollTop -= scrollDelta;
                break;
            default:
                return;
        }
    }
    /**
     * @hidden @internal
     */
    isDefined(arg) {
        return arg !== undefined && arg !== null;
    }
    /**
     * @hidden @internal
     */
    selectRange(arg) {
        if (!this.isDefined(arg)) {
            this.clearCellSelection();
            return;
        }
        if (arg instanceof Array) {
            arg.forEach(range => this.setSelection(range));
        }
        else {
            this.setSelection(arg);
        }
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    columnToVisibleIndex(field) {
        const visibleColumns = this.visibleColumns;
        if (typeof field === 'number') {
            return field;
        }
        return visibleColumns.find(column => column.field === field).visibleIndex;
    }
    /**
     * @hidden @internal
     */
    setSelection(range) {
        const startNode = { row: range.rowStart, column: this.columnToVisibleIndex(range.columnStart) };
        const endNode = { row: range.rowEnd, column: this.columnToVisibleIndex(range.columnEnd) };
        this.selectionService.pointerState.node = startNode;
        this.selectionService.selectRange(endNode, this.selectionService.pointerState);
        this.selectionService.addRangeMeta(endNode, this.selectionService.pointerState);
        this.selectionService.initPointerState();
    }
    /**
     * @hidden @internal
     */
    getSelectedRanges() {
        return this.selectionService.ranges;
    }
    /**
     *
     * Returns an array of the current cell selection in the form of `[{ column.field: cell.value }, ...]`.
     *
     * @remarks
     * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
     * If `headers` is enabled, it will use the column header (if any) instead of the column field.
     */
    getSelectedData(formatters = false, headers = false) {
        const source = this.filteredSortedData;
        return this.extractDataFromSelection(source, formatters, headers);
    }
    /**
     * Get current selected columns.
     *
     * @example
     * Returns an array with selected columns
     * ```typescript
     * const selectedColumns = this.grid.selectedColumns();
     * ```
     */
    selectedColumns() {
        const fields = this.selectionService.getSelectedColumns();
        return fields.map(field => this.getColumnByName(field)).filter(field => field);
    }
    /**
     * Select specified columns.
     *
     * @example
     * ```typescript
     * this.grid.selectColumns(['ID','Name'], true);
     * ```
     * @param columns
     * @param clearCurrentSelection if true clears the current selection
     */
    selectColumns(columns, clearCurrentSelection) {
        let fieldToSelect = [];
        if (columns.length === 0 || typeof columns[0] === 'string') {
            fieldToSelect = columns;
        }
        else {
            columns.forEach(col => {
                if (col.columnGroup) {
                    const children = col.allChildren.filter(c => !c.columnGroup).map(c => c.field);
                    fieldToSelect = [...fieldToSelect, ...children];
                }
                else {
                    fieldToSelect.push(col.field);
                }
            });
        }
        this.selectionService.selectColumnsWithNoEvent(fieldToSelect, clearCurrentSelection);
        this.notifyChanges();
    }
    /**
     * Deselect specified columns by filed.
     *
     * @example
     * ```typescript
     * this.grid.deselectColumns(['ID','Name']);
     * ```
     * @param columns
     */
    deselectColumns(columns) {
        let fieldToDeselect = [];
        if (columns.length === 0 || typeof columns[0] === 'string') {
            fieldToDeselect = columns;
        }
        else {
            columns.forEach(col => {
                if (col.columnGroup) {
                    const children = col.allChildren.filter(c => !c.columnGroup).map(c => c.field);
                    fieldToDeselect = [...fieldToDeselect, ...children];
                }
                else {
                    fieldToDeselect.push(col.field);
                }
            });
        }
        this.selectionService.deselectColumnsWithNoEvent(fieldToDeselect);
        this.notifyChanges();
    }
    /**
     * Deselects all columns
     *
     * @example
     * ```typescript
     * this.grid.deselectAllColumns();
     * ```
     */
    deselectAllColumns() {
        this.selectionService.clearAllSelectedColumns();
        this.notifyChanges();
    }
    /**
     * Selects all columns
     *
     * @example
     * ```typescript
     * this.grid.deselectAllColumns();
     * ```
     */
    selectAllColumns() {
        this.selectColumns(this.columnList.filter(c => !c.columnGroup));
    }
    /**
     *
     * Returns an array of the current columns selection in the form of `[{ column.field: cell.value }, ...]`.
     *
     * @remarks
     * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
     * If `headers` is enabled, it will use the column header (if any) instead of the column field.
     */
    getSelectedColumnsData(formatters = false, headers = false) {
        const source = this.filteredSortedData ? this.filteredSortedData : this.data;
        return this.extractDataFromColumnsSelection(source, formatters, headers);
    }
    combineSelectedCellAndColumnData(columnData, formatters = false, headers = false) {
        const source = this.filteredSortedData;
        return this.extractDataFromSelection(source, formatters, headers, columnData);
    }
    /**
     * @hidden
     * @internal
     */
    copyHandler(event) {
        const selectedColumns = this.gridAPI.grid.selectedColumns();
        const columnData = this.getSelectedColumnsData(this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);
        const selectedData = this.getSelectedData(this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);
        let data = [];
        let result;
        if (event.code === 'KeyC' && (event.ctrlKey || event.metaKey) && event.currentTarget.className === 'igx-grid__thead-wrapper') {
            if (selectedData.length) {
                if (columnData.length === 0) {
                    result = this.prepareCopyData(event, selectedData);
                }
                else {
                    data = this.combineSelectedCellAndColumnData(columnData, this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);
                    result = this.prepareCopyData(event, data[0], data[1]);
                }
            }
            else {
                data = columnData;
                result = this.prepareCopyData(event, data);
            }
            if (isIE()) {
                window.clipboardData.setData('Text', result);
                return;
            }
            navigator.clipboard.writeText(result).then().catch(e => console.error(e));
        }
        else if (!this.clipboardOptions.enabled || this.crudService.cellInEditMode || (!isIE() && event.type === 'keydown')) {
            return;
        }
        else {
            if (selectedColumns.length) {
                data = this.combineSelectedCellAndColumnData(columnData, this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);
                result = this.prepareCopyData(event, data[0], data[1]);
            }
            else {
                data = selectedData;
                result = this.prepareCopyData(event, data);
            }
            if (isIE()) {
                window.clipboardData.setData('Text', result);
                return;
            }
            event.clipboardData.setData('text/plain', result);
        }
    }
    /**
     * @hidden @internal
     */
    prepareCopyData(event, data, keys) {
        const ev = { data, cancel: false };
        this.onGridCopy.emit(ev);
        if (ev.cancel) {
            return;
        }
        const transformer = new CharSeparatedValueData(ev.data, this.clipboardOptions.separator);
        let result = keys ? transformer.prepareData(keys) : transformer.prepareData();
        if (!this.clipboardOptions.copyHeaders) {
            result = result.substring(result.indexOf('\n') + 1);
        }
        event.preventDefault();
        /* Necessary for the hiearachical case but will probably have to
           change how getSelectedData is propagated in the hiearachical grid
        */
        event.stopPropagation();
        return result;
    }
    /**
     * @hidden @internal
     */
    showSnackbarFor(index) {
        this.addRowSnackbar.actionText = index === -1 ? '' : this.snackbarActionText;
        this.lastAddedRowIndex = index;
        this.addRowSnackbar.open();
    }
    /**
     * Navigates to a position in the grid based on provided `rowindex` and `visibleColumnIndex`.
     *
     * @remarks
     * Also can execute a custom logic over the target element,
     * through a callback function that accepts { targetType: GridKeydownTargetType, target: Object }
     * @example
     * ```typescript
     *  this.grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); });
     * ```
     */
    navigateTo(rowIndex, visibleColIndex = -1, cb = null) {
        var _a;
        const totalItems = (_a = this.totalItemCount) !== null && _a !== void 0 ? _a : this.dataView.length - 1;
        if (rowIndex < 0 || rowIndex > totalItems || (visibleColIndex !== -1
            && this.columnList.map(col => col.visibleIndex).indexOf(visibleColIndex) === -1)) {
            return;
        }
        if (this.dataView.slice(rowIndex, rowIndex + 1).find(rec => rec.expression || rec.childGridsData)) {
            visibleColIndex = -1;
        }
        // If the target row is pinned no need to scroll as well.
        const shouldScrollVertically = this.navigation.shouldPerformVerticalScroll(rowIndex, visibleColIndex);
        const shouldScrollHorizontally = this.navigation.shouldPerformHorizontalScroll(visibleColIndex, rowIndex);
        if (shouldScrollVertically) {
            this.navigation.performVerticalScrollToCell(rowIndex, visibleColIndex, () => {
                if (shouldScrollHorizontally) {
                    this.navigation.performHorizontalScrollToCell(visibleColIndex, () => this.executeCallback(rowIndex, visibleColIndex, cb));
                }
                else {
                    this.executeCallback(rowIndex, visibleColIndex, cb);
                }
            });
        }
        else if (shouldScrollHorizontally) {
            this.navigation.performHorizontalScrollToCell(visibleColIndex, () => {
                if (shouldScrollVertically) {
                    this.navigation.performVerticalScrollToCell(rowIndex, visibleColIndex, () => this.executeCallback(rowIndex, visibleColIndex, cb));
                }
                else {
                    this.executeCallback(rowIndex, visibleColIndex, cb);
                }
            });
        }
        else {
            this.executeCallback(rowIndex, visibleColIndex, cb);
        }
    }
    /**
     * Returns `ICellPosition` which defines the next cell,
     * according to the current position, that match specific criteria.
     *
     * @remarks
     * You can pass callback function as a third parameter of `getPreviousCell` method.
     * The callback function accepts IgxColumnComponent as a param
     * @example
     * ```typescript
     *  const nextEditableCellPosition = this.grid.getNextCell(0, 3, (column) => column.editable);
     * ```
     */
    getNextCell(currRowIndex, curVisibleColIndex, callback = null) {
        const columns = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0);
        if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
            return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
        }
        const colIndexes = callback ? columns.filter((col) => callback(col)).map(editCol => editCol.visibleIndex).sort((a, b) => a - b) :
            columns.map(editCol => editCol.visibleIndex).sort((a, b) => a - b);
        const nextCellIndex = colIndexes.find(index => index > curVisibleColIndex);
        if (this.dataView.slice(currRowIndex, currRowIndex + 1)
            .find(rec => !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData) && nextCellIndex !== undefined) {
            return { rowIndex: currRowIndex, visibleColumnIndex: nextCellIndex };
        }
        else {
            if (colIndexes.length === 0 || this.getNextDataRowIndex(currRowIndex) === currRowIndex) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            else {
                return { rowIndex: this.getNextDataRowIndex(currRowIndex), visibleColumnIndex: colIndexes[0] };
            }
        }
    }
    /**
     * Returns `ICellPosition` which defines the previous cell,
     * according to the current position, that match specific criteria.
     *
     * @remarks
     * You can pass callback function as a third parameter of `getPreviousCell` method.
     * The callback function accepts IgxColumnComponent as a param
     * @example
     * ```typescript
     *  const previousEditableCellPosition = this.grid.getPreviousCell(0, 3, (column) => column.editable);
     * ```
     */
    getPreviousCell(currRowIndex, curVisibleColIndex, callback = null) {
        const columns = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0);
        if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
            return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
        }
        const colIndexes = callback ? columns.filter((col) => callback(col)).map(editCol => editCol.visibleIndex).sort((a, b) => b - a) :
            columns.map(editCol => editCol.visibleIndex).sort((a, b) => b - a);
        const prevCellIndex = colIndexes.find(index => index < curVisibleColIndex);
        if (this.dataView.slice(currRowIndex, currRowIndex + 1)
            .find(rec => !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData) && prevCellIndex !== undefined) {
            return { rowIndex: currRowIndex, visibleColumnIndex: prevCellIndex };
        }
        else {
            if (colIndexes.length === 0 || this.getNextDataRowIndex(currRowIndex, true) === currRowIndex) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            else {
                return { rowIndex: this.getNextDataRowIndex(currRowIndex, true), visibleColumnIndex: colIndexes[0] };
            }
        }
    }
    /**
     * @hidden @internal
     */
    trackColumnChanges(index, col) {
        return col.field + col._calcWidth;
    }
    /**
     * @hidden
     */
    isExpandedGroup(_group) {
        return undefined;
    }
    /**
     * @hidden @internal
     */
    openRowOverlay(id) {
        this.configureRowEditingOverlay(id, this.rowList.length <= MIN_ROW_EDITING_COUNT_THRESHOLD);
        this.rowEditingOverlay.open(this.rowEditSettings);
        this.rowEditingOverlay.element.addEventListener('wheel', this.rowEditingWheelHandler.bind(this));
    }
    /**
     * @hidden @internal
     */
    closeRowEditingOverlay() {
        this.rowEditingOverlay.element.removeEventListener('wheel', this.rowEditingWheelHandler);
        this.rowEditPositioningStrategy.isTopInitialPosition = null;
        this.rowEditingOverlay.close();
        this.rowEditingOverlay.element.parentElement.style.display = '';
    }
    /**
     * @hidden @internal
     */
    toggleRowEditingOverlay(show) {
        const rowStyle = this.rowEditingOverlay.element.style;
        if (show) {
            rowStyle.display = 'block';
        }
        else {
            rowStyle.display = 'none';
        }
    }
    /**
     * @hidden @internal
     */
    repositionRowEditingOverlay(row) {
        if (row && !this.rowEditingOverlay.collapsed) {
            const rowStyle = this.rowEditingOverlay.element.parentElement.style;
            if (row) {
                rowStyle.display = '';
                this.configureRowEditingOverlay(row.rowID);
                this.rowEditingOverlay.reposition();
            }
            else {
                rowStyle.display = 'none';
            }
        }
    }
    /**
     * @hidden @internal
     */
    cachedViewLoaded(args) {
        if (this.hasHorizontalScroll()) {
            const tmplId = args.context.templateID;
            const index = args.context.index;
            args.view.detectChanges();
            this.zone.onStable.pipe(first$1()).subscribe(() => {
                const row = tmplId === 'dataRow' ? this.getRowByIndex(index) : null;
                const summaryRow = tmplId === 'summaryRow' ? this.summariesRowList.find((sr) => sr.dataRowIndex === index) : null;
                if (row && row instanceof IgxRowDirective) {
                    this._restoreVirtState(row);
                }
                else if (summaryRow) {
                    this._restoreVirtState(summaryRow);
                }
            });
        }
    }
    /**
     * Opens the advanced filtering dialog.
     */
    openAdvancedFilteringDialog() {
        if (!this._advancedFilteringOverlayId) {
            this._advancedFilteringOverlaySettings.target =
                this.rootGrid ? this.rootGrid.nativeElement : this.nativeElement;
            this._advancedFilteringOverlaySettings.outlet = this.outlet;
            this._advancedFilteringOverlayId = this.overlayService.attach(IgxAdvancedFilteringDialogComponent, this._advancedFilteringOverlaySettings, {
                injector: this.viewRef.injector,
                componentFactoryResolver: this.resolver
            });
            this.overlayService.show(this._advancedFilteringOverlayId, this._advancedFilteringOverlaySettings);
        }
    }
    /**
     * Closes the advanced filtering dialog.
     *
     * @param applyChanges indicates whether the changes should be applied
     */
    closeAdvancedFilteringDialog(applyChanges) {
        if (this._advancedFilteringOverlayId) {
            const advancedFilteringOverlay = this.overlayService.getOverlayById(this._advancedFilteringOverlayId);
            const advancedFilteringDialog = advancedFilteringOverlay.componentRef.instance;
            if (applyChanges) {
                advancedFilteringDialog.applyChanges();
            }
            advancedFilteringDialog.closeDialog();
        }
    }
    getEmptyRecordObjectFor(rec) {
        const row = Object.assign({}, rec);
        Object.keys(row).forEach(key => row[key] = undefined);
        row[this.primaryKey] = this.generateRowID();
        return row;
    }
    /**
     * @hidden @internal
     */
    hasHorizontalScroll() {
        return this.totalWidth - this.unpinnedWidth > 0;
    }
    /**
     * @hidden @internal
     */
    isSummaryRow(rowData) {
        return rowData.summaries && (rowData.summaries instanceof Map);
    }
    /**
     * @hidden @internal
     */
    endRowTransaction(commit, row, event) {
        row.newData = this.transactions.getAggregatedValue(row.id, true);
        let rowEditArgs = row.createEditEventArgs(true, event);
        if (!commit) {
            this.transactions.endPending(false);
        }
        else {
            rowEditArgs = this.gridAPI.update_row(row, row.newData, event);
            if (rowEditArgs === null || rowEditArgs === void 0 ? void 0 : rowEditArgs.cancel) {
                return true;
            }
        }
        this.crudService.endRowEdit();
        const nonCancelableArgs = row.createDoneEditEventArgs(rowEditArgs.oldValue, event);
        this.rowEditExit.emit(nonCancelableArgs);
        this.closeRowEditingOverlay();
    }
    // TODO: Refactor
    /**
     * Finishes the row transactions on the current row.
     *
     * @remarks
     * If `commit === true`, passes them from the pending state to the data (or transaction service)
     * @example
     * ```html
     * <button igxButton (click)="grid.endEdit(true)">Commit Row</button>
     * ```
     * @param commit
     */
    endEdit(commit = true, event) {
        const row = this.crudService.row;
        const cell = this.crudService.cell;
        let canceled = false;
        // TODO: Merge the crudService with with BaseAPI service
        if (!row && !cell) {
            return;
        }
        if (row === null || row === void 0 ? void 0 : row.isAddRow) {
            canceled = this.endAdd(commit, event);
            return canceled;
        }
        if (commit) {
            canceled = this.gridAPI.submit_value(event);
            if (canceled) {
                return true;
            }
        }
        else {
            this.crudService.exitCellEdit(event);
        }
        canceled = this.crudService.exitRowEdit(commit, event);
        this.crudService.rowEditingBlocked = canceled;
        if (canceled) {
            return true;
        }
        const activeCell = this.selectionService.activeElement;
        if (event && activeCell) {
            const rowIndex = activeCell.row;
            const visibleColIndex = activeCell.layout ? activeCell.layout.columnVisibleIndex : activeCell.column;
            this.navigateTo(rowIndex, visibleColIndex);
        }
        return false;
    }
    endAdd(commit = true, event) {
        const row = this.crudService.row;
        const cell = this.crudService.cell;
        const cachedRowData = Object.assign({}, row.data);
        let cancelable = false;
        if (!row && !cell) {
            return;
        }
        if (commit) {
            this.onRowAdded.pipe(first$1()).subscribe((args) => {
                const rowData = args.data;
                const pinnedIndex = this.pinnedRecords.findIndex(x => x[this.primaryKey] === rowData[this.primaryKey]);
                // A check whether the row is in the current view
                const viewIndex = pinnedIndex !== -1 ? pinnedIndex : this.findRecordIndexInView(rowData);
                const dataIndex = this.filteredSortedData.findIndex(data => data[this.primaryKey] === rowData[this.primaryKey]);
                const isInView = viewIndex !== -1 && !this.navigation.shouldPerformVerticalScroll(viewIndex, 0);
                const showIndex = isInView ? -1 : dataIndex;
                this.showSnackbarFor(showIndex);
            });
            cancelable = this.gridAPI.submit_add_value(event);
            if (!cancelable) {
                const args = row.createEditEventArgs(true, event);
                this.rowEdit.emit(args);
                if (args.cancel) {
                    return args.cancel;
                }
                const parentId = this._getParentRecordId();
                this.gridAPI.addRowToData(row.data, parentId);
                const doneArgs = row.createDoneEditEventArgs(cachedRowData, event);
                this.rowEditDone.emit(doneArgs);
                this.crudService.endRowEdit();
                if (this.addRowParent.isPinned) {
                    this.pinRow(row.id);
                }
            }
            this.addRowParent = null;
            this.cancelAddMode = cancelable;
        }
        else {
            this.crudService.exitCellEdit(event);
            this.cancelAddMode = true;
        }
        this.crudService.endRowEdit();
        this.closeRowEditingOverlay();
        this._pipeTrigger++;
        if (!this.cancelAddMode) {
            this.cdr.detectChanges();
            this.onRowAdded.emit({ data: row.data });
        }
        const nonCancelableArgs = row.createDoneEditEventArgs(cachedRowData, event);
        this.rowEditExit.emit(nonCancelableArgs);
        return this.cancelAddMode;
    }
    /**
     * @hidden
     * @internal
     */
    endRowEdit(commit = true, event) {
        const canceled = this.endEdit(commit, event);
        if (canceled) {
            return true;
        }
        const activeCell = this.navigation.activeNode;
        if (activeCell && activeCell.row !== -1) {
            this.tbody.nativeElement.focus();
        }
    }
    /**
     * @hidden @internal
     */
    triggerPipes() {
        this._pipeTrigger++;
        this.cdr.detectChanges();
    }
    /**
     * @hidden @internal
     */
    endAddRow() {
        this.cancelAddMode = true;
        this.triggerPipes();
    }
    writeToData(rowIndex, value) {
        mergeObjects(this.gridAPI.get_all_data()[rowIndex], value);
    }
    /**
     * @hidden
     * @internal
     */
    _getParentRecordId() {
        return this.addRowParent.asChild ? this.addRowParent.rowID : undefined;
    }
    findRecordIndexInView(rec) {
        return this.dataView.findIndex(data => data[this.primaryKey] === rec[this.primaryKey]);
    }
    getUnpinnedIndexById(id) {
        return this.unpinnedRecords.findIndex(x => x[this.primaryKey] === id);
    }
    _restoreVirtState(row) {
        // check virtualization state of data record added from cache
        // in case state is no longer valid - update it.
        const rowForOf = row.virtDirRow;
        const gridScrLeft = rowForOf.getScroll().scrollLeft;
        const left = -parseInt(rowForOf.dc.instance._viewContainer.element.nativeElement.style.left, 10);
        const actualScrollLeft = left + rowForOf.getColumnScrollLeft(rowForOf.state.startIndex);
        if (gridScrLeft !== actualScrollLeft) {
            rowForOf.onHScroll(gridScrLeft);
            rowForOf.cdr.detectChanges();
        }
    }
    /**
     * @hidden
     */
    getExportExcel() {
        return this._exportExcel;
    }
    /**
     * @hidden
     */
    getExportCsv() {
        return this._exportCsv;
    }
    changeRowEditingOverlayStateOnScroll(row) {
        if (!this.rowEditable || !this.rowEditingOverlay || this.rowEditingOverlay.collapsed) {
            return;
        }
        if (!row) {
            this.toggleRowEditingOverlay(false);
        }
        else {
            this.repositionRowEditingOverlay(row);
        }
    }
    /**
     * Should be called when data and/or isLoading input changes so that the overlay can be
     * hidden/shown based on the current value of shouldOverlayLoading
     */
    evaluateLoadingState() {
        if (this.shouldOverlayLoading) {
            // a new overlay should be shown
            const overlaySettings = {
                outlet: this.loadingOutlet,
                closeOnOutsideClick: false,
                positionStrategy: new ContainerPositionStrategy()
            };
            this.loadingOverlay.open(overlaySettings);
        }
        else {
            this.loadingOverlay.close();
        }
    }
    /**
     * @hidden
     * Sets grid width i.e. this.calcWidth
     */
    calculateGridWidth() {
        let width;
        if (this.isPercentWidth) {
            /* width in %*/
            const computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width');
            width = computed.indexOf('%') === -1 ? parseInt(computed, 10) : null;
        }
        else {
            width = parseInt(this.width, 10);
        }
        if (!width && this.nativeElement) {
            width = this.nativeElement.offsetWidth;
        }
        if (this.width === null || !width) {
            width = this.getColumnWidthSum();
        }
        if (this.hasVerticalScroll() && this.width !== null) {
            width -= this.scrollSize;
        }
        if ((Number.isFinite(width) || width === null) && width !== this.calcWidth) {
            this.calcWidth = width;
        }
        this._derivePossibleWidth();
    }
    /**
     * @hidden
     * Sets columns defaultWidth property
     */
    _derivePossibleWidth() {
        if (!this.columnWidthSetByUser) {
            this._columnWidth = this.width !== null ? this.getPossibleColumnWidth() : MINIMUM_COLUMN_WIDTH + 'px';
        }
        this.columnList.forEach((column) => {
            if (this.hasColumnLayouts && parseInt(this._columnWidth, 10)) {
                const columnWidthCombined = parseInt(this._columnWidth, 10) * (column.colEnd ? column.colEnd - column.colStart : 1);
                column.defaultWidth = columnWidthCombined + 'px';
            }
            else {
                // D.K. March 29th, 2021 #9145 Consider min/max width when setting defaultWidth property
                column.defaultWidth = this.getExtremumBasedColWidth(column);
                column.resetCaches();
            }
        });
        this.resetCachedWidths();
    }
    /**
     * @hidden
     * @internal
     */
    getExtremumBasedColWidth(column) {
        let width = this._columnWidth;
        if (width && typeof width !== 'string') {
            width = String(width);
        }
        const minWidth = width.indexOf('%') === -1 ? column.minWidthPx : column.minWidthPercent;
        const maxWidth = width.indexOf('%') === -1 ? column.maxWidthPx : column.maxWidthPercent;
        if (column.hidden) {
            return width;
        }
        if (minWidth > parseFloat(width)) {
            width = String(column.minWidth);
        }
        else if (maxWidth < parseFloat(width)) {
            width = String(column.maxWidth);
        }
        // if no px or % are defined in maxWidth/minWidth consider it px
        if (width.indexOf('%') === -1 && width.indexOf('px') === -1) {
            width += 'px';
        }
        return width;
    }
    resetNotifyChanges() {
        this._cdrRequestRepaint = false;
        this._cdrRequests = false;
    }
    resolveOutlet() {
        return this._userOutletDirective ? this._userOutletDirective : this._outletDirective;
    }
    /**
     * Reorder columns in the main columnList and _columns collections.
     *
     * @hidden
     */
    _moveColumns(from, to, pos) {
        const list = this.columnList.toArray();
        this._reorderColumns(from, to, pos, list);
        const newList = this._resetColumnList(list);
        this.columnList.reset(newList);
        this.columnList.notifyOnChanges();
        this._columns = this.columnList.toArray();
    }
    /**
     * @hidden
     */
    _resetColumnList(list) {
        if (!list) {
            list = this.columnList.toArray();
        }
        let newList = [];
        list.filter(c => c.level === 0).forEach(p => {
            newList.push(p);
            if (p.columnGroup) {
                newList = newList.concat(p.allChildren);
            }
        });
        return newList;
    }
    /**
     * Reorders columns inside the passed column collection.
     * When reordering column group collection, the collection is not flattened.
     * In all other cases, the columns collection is flattened, this is why adittional calculations on the dropIndex are done.
     *
     * @hidden
     */
    _reorderColumns(from, to, position, columnCollection, inGroup = false) {
        const fromIndex = columnCollection.indexOf(from);
        const childColumnsCount = inGroup ? 1 : from.allChildren.length + 1;
        columnCollection.splice(fromIndex, childColumnsCount);
        let dropIndex = columnCollection.indexOf(to);
        if (position === DropPosition.AfterDropTarget) {
            dropIndex++;
            if (!inGroup && to.columnGroup) {
                dropIndex += to.allChildren.length;
            }
        }
        columnCollection.splice(dropIndex, 0, from);
    }
    /**
     * Reorder column group collection.
     *
     * @hidden
     */
    _moveChildColumns(parent, from, to, pos) {
        const buffer = parent.children.toArray();
        this._reorderColumns(from, to, pos, buffer, true);
        parent.children.reset(buffer);
    }
    setupColumns() {
        if (this.autoGenerate) {
            this.autogenerateColumns();
        }
        this.initColumns(this.columnList, (col) => this.onColumnInit.emit(col));
        this.columnListDiffer.diff(this.columnList);
        this.columnList.changes
            .pipe(takeUntil(this.destroy$))
            .subscribe((change) => {
            this.onColumnsChanged(change);
        });
    }
    /**
     * @hidden
     */
    deleteRowFromData(rowID, index) {
        //  if there is a row (index !== 0) delete it
        //  if there is a row in ADD or UPDATE state change it's state to DELETE
        if (index !== -1) {
            if (this.transactions.enabled) {
                const transaction = { id: rowID, type: TransactionType.DELETE, newValue: null };
                this.transactions.add(transaction, this.data[index]);
            }
            else {
                this.data.splice(index, 1);
            }
        }
        else {
            const state = this.transactions.getState(rowID);
            this.transactions.add({ id: rowID, type: TransactionType.DELETE, newValue: null }, state && state.recordRef);
        }
    }
    /**
     * @hidden @internal
     */
    getDataBasedBodyHeight() {
        return !this.data || (this.data.length < this._defaultTargetRecordNumber) ?
            0 : this.defaultTargetBodyHeight;
    }
    /**
     * @hidden @internal
     */
    onPinnedRowsChanged(change) {
        const diff = this.rowListDiffer.diff(change);
        if (diff) {
            this.notifyChanges(true);
        }
    }
    /**
     * @hidden
     */
    onColumnsChanged(change) {
        const diff = this.columnListDiffer.diff(change);
        if (this.autoGenerate && this.columnList.length === 0 && this._autoGeneratedCols.length > 0) {
            // In Ivy if there are nested conditional templates the content children are re-evaluated
            // hence autogenerated columns are cleared and need to be reset.
            this.columnList.reset(this._autoGeneratedCols);
            return;
        }
        if (diff) {
            let added = false;
            let removed = false;
            diff.forEachAddedItem((record) => {
                this.onColumnInit.emit(record.item);
                added = true;
                if (record.item.pinned) {
                    this._pinnedColumns.push(record.item);
                }
                else {
                    this._unpinnedColumns.push(record.item);
                }
            });
            this.initColumns(this.columnList);
            diff.forEachRemovedItem((record) => {
                const isColumnGroup = record.item instanceof IgxColumnGroupComponent;
                if (!isColumnGroup) {
                    // Clear Grouping
                    this.gridAPI.clear_groupby(record.item.field);
                    // Clear Filtering
                    this.filteringService.clear_filter(record.item.field);
                    // Close filter row
                    if (this.filteringService.isFilterRowVisible
                        && this.filteringService.filteredColumn
                        && this.filteringService.filteredColumn.field === record.item.field) {
                        this.filteringRow.close();
                    }
                    // Clear Sorting
                    this.gridAPI.clear_sort(record.item.field);
                    // Remove column selection
                    this.selectionService.deselectColumnsWithNoEvent([record.item.field]);
                }
                removed = true;
            });
            this.resetCaches();
            if (added || removed) {
                this.summaryService.clearSummaryCache();
                Promise.resolve().then(() => {
                    // `onColumnsChanged` can be executed midway a current detectChange cycle and markForCheck will be ignored then.
                    // This ensures that we will wait for the current cycle to end so we can trigger a new one and ngDoCheck to fire.
                    this.notifyChanges(true);
                });
            }
        }
    }
    /**
     * @hidden
     */
    calculateGridSizes(recalcFeatureWidth = true) {
        /*
            TODO: (R.K.) This layered lasagne should be refactored
            ASAP. The reason I have to reset the caches so many times is because
            after teach `detectChanges` call they are filled with invalid
            state. Of course all of this happens midway through the grid
            sizing process which of course, uses values from the caches, thus resulting
            in a broken layout.
        */
        this.resetCaches(recalcFeatureWidth);
        this.cdr.detectChanges();
        const hasScroll = this.hasVerticalScroll();
        this.calculateGridWidth();
        this.resetCaches(recalcFeatureWidth);
        this.cdr.detectChanges();
        this.calculateGridHeight();
        if (this.rowEditable) {
            this.repositionRowEditingOverlay(this.rowInEditMode);
        }
        if (this.filteringService.isFilterRowVisible) {
            this.filteringRow.resetChipsArea();
        }
        this.cdr.detectChanges();
        // in case scrollbar has appeared recalc to size correctly.
        if (hasScroll !== this.hasVerticalScroll()) {
            this.calculateGridWidth();
            this.cdr.detectChanges();
        }
        if (this.zone.isStable) {
            this.zone.run(() => {
                this._applyWidthHostBinding();
                this.cdr.detectChanges();
            });
        }
        else {
            this.zone.onStable.pipe(first$1()).subscribe(() => {
                this.zone.run(() => {
                    this._applyWidthHostBinding();
                });
            });
        }
        this.resetCaches(recalcFeatureWidth);
    }
    /**
     * @hidden
     * @internal
     */
    calcGridHeadRow() {
        if (this.maxLevelHeaderDepth) {
            this._baseFontSize = parseFloat(getComputedStyle(this.document.documentElement).getPropertyValue('font-size'));
            let minSize = (this.maxLevelHeaderDepth + 1) * this.defaultRowHeight / this._baseFontSize;
            if (this._allowFiltering && this._filterMode === FilterMode.quickFilter) {
                minSize += (FILTER_ROW_HEIGHT + 1) / this._baseFontSize;
            }
            this.theadRow.nativeElement.style.minHeight = `${minSize}rem`;
        }
    }
    /**
     * @hidden
     * Sets TBODY height i.e. this.calcHeight
     */
    calculateGridHeight() {
        this.calcGridHeadRow();
        this.summariesHeight = 0;
        if (this.hasSummarizedColumns && this.rootSummariesEnabled) {
            this.summariesHeight = this.summaryService.calcMaxSummaryHeight();
        }
        this.calcHeight = this._calculateGridBodyHeight();
        if (this.pinnedRowHeight && this.calcHeight) {
            this.calcHeight -= this.pinnedRowHeight;
        }
    }
    /**
     * @hidden
     */
    getGroupAreaHeight() {
        return 0;
    }
    /**
     * @hidden
     */
    getComputedHeight(elem) {
        return elem.offsetHeight ? parseFloat(this.document.defaultView.getComputedStyle(elem).getPropertyValue('height')) : 0;
    }
    /**
     * @hidden
     */
    getFooterHeight() {
        return this.summariesHeight || this.getComputedHeight(this.tfoot.nativeElement);
    }
    /**
     * @hidden
     */
    getTheadRowHeight() {
        const height = this.getComputedHeight(this.theadRow.nativeElement);
        return (!this.allowFiltering || (this.allowFiltering && this.filterMode !== FilterMode.quickFilter)) ?
            height - this.getFilterCellHeight() :
            height;
    }
    /**
     * @hidden
     */
    getToolbarHeight() {
        let toolbarHeight = 0;
        if (this.toolbar.first) {
            toolbarHeight = this.getComputedHeight(this.toolbar.first.nativeElement);
        }
        return toolbarHeight;
    }
    /**
     * @hidden
     */
    getPagingFooterHeight() {
        let pagingHeight = 0;
        if (this.footer) {
            const height = this.getComputedHeight(this.footer.nativeElement);
            pagingHeight = this.footer.nativeElement.firstElementChild ?
                height : 0;
        }
        return pagingHeight;
    }
    /**
     * @hidden
     */
    getFilterCellHeight() {
        const headerGroupNativeEl = (this.headerGroupsList.length !== 0) ?
            this.headerGroupsList[0].element.nativeElement : null;
        const filterCellNativeEl = (headerGroupNativeEl) ?
            headerGroupNativeEl.querySelector('igx-grid-filtering-cell') : null;
        return (filterCellNativeEl) ? filterCellNativeEl.offsetHeight : 0;
    }
    /**
     * @hidden
     */
    _calculateGridBodyHeight() {
        if (!this._height) {
            return null;
        }
        const actualTheadRow = this.getTheadRowHeight();
        const footerHeight = this.getFooterHeight();
        const toolbarHeight = this.getToolbarHeight();
        const pagingHeight = this.getPagingFooterHeight();
        const groupAreaHeight = this.getGroupAreaHeight();
        const scrHeight = this.getComputedHeight(this.scr.nativeElement);
        const renderedHeight = toolbarHeight + actualTheadRow +
            footerHeight + pagingHeight + groupAreaHeight +
            scrHeight;
        let gridHeight = 0;
        if (this.isPercentHeight) {
            const computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('height');
            const autoSize = this._shouldAutoSize(renderedHeight);
            if (autoSize || computed.indexOf('%') !== -1) {
                const bodyHeight = this.getDataBasedBodyHeight();
                return bodyHeight > 0 ? bodyHeight : null;
            }
            gridHeight = parseFloat(computed);
        }
        else {
            gridHeight = parseInt(this._height, 10);
        }
        const height = Math.abs(gridHeight - renderedHeight);
        if (Math.round(height) === 0 || isNaN(gridHeight)) {
            const bodyHeight = this.defaultTargetBodyHeight;
            return bodyHeight > 0 ? bodyHeight : null;
        }
        return height;
    }
    checkContainerSizeChange() {
        const origHeight = this.nativeElement.parentElement.offsetHeight;
        this.nativeElement.style.display = 'none';
        const height = this.nativeElement.parentElement.offsetHeight;
        this.nativeElement.style.display = '';
        return origHeight !== height;
    }
    _shouldAutoSize(renderedHeight) {
        this.tbody.nativeElement.style.display = 'none';
        let res = !this.nativeElement.parentElement ||
            this.nativeElement.parentElement.clientHeight === 0 ||
            this.nativeElement.parentElement.clientHeight === renderedHeight;
        if (!isChromium()) {
            // If grid causes the parent container to extend (for example when container is flex)
            // we should always auto-size since the actual size of the container will continuously change as the grid renders elements.
            res = this.checkContainerSizeChange();
        }
        this.tbody.nativeElement.style.display = '';
        return res;
    }
    /**
     * @hidden
     * Gets calculated width of the unpinned area
     * @param takeHidden If we should take into account the hidden columns in the pinned area.
     */
    getUnpinnedWidth(takeHidden = false) {
        let width = this.isPercentWidth ?
            this.calcWidth :
            parseInt(this.width, 10) || parseInt(this.hostWidth, 10) || this.calcWidth;
        if (this.hasVerticalScroll() && !this.isPercentWidth) {
            width -= this.scrollSize;
        }
        if (!this.isPinningToStart) {
            width -= this.featureColumnsWidth();
        }
        return width - this.getPinnedWidth(takeHidden);
    }
    /**
     * @hidden
     */
    _summaries(fieldName, hasSummary, summaryOperand) {
        const column = this.gridAPI.get_column_by_name(fieldName);
        if (column) {
            column.hasSummary = hasSummary;
            if (summaryOperand) {
                if (this.rootSummariesEnabled) {
                    this.summaryService.retriggerRootPipe++;
                }
                column.summaries = summaryOperand;
            }
        }
    }
    /**
     * @hidden
     */
    _multipleSummaries(expressions, hasSummary) {
        expressions.forEach((element) => {
            this._summaries(element.fieldName, hasSummary, element.customSummary);
        });
    }
    /**
     * @hidden
     */
    _disableMultipleSummaries(expressions) {
        expressions.forEach((column) => {
            const columnName = column && column.fieldName ? column.fieldName : column;
            this._summaries(columnName, false);
        });
    }
    /**
     * @hidden
     */
    resolveDataTypes(rec) {
        if (typeof rec === 'number') {
            return DataType.Number;
        }
        else if (typeof rec === 'boolean') {
            return DataType.Boolean;
        }
        else if (typeof rec === 'object' && rec instanceof Date) {
            return DataType.Date;
        }
        return DataType.String;
    }
    /**
     * @hidden
     */
    autogenerateColumns() {
        const data = this.gridAPI.get_data();
        const factory = this.resolver.resolveComponentFactory(IgxColumnComponent);
        const fields = this.generateDataFields(data);
        const columns = [];
        fields.forEach((field) => {
            const ref = factory.create(this.viewRef.injector);
            ref.instance.field = field;
            ref.instance.dataType = this.resolveDataTypes(data[0][field]);
            ref.changeDetectorRef.detectChanges();
            columns.push(ref.instance);
        });
        this._autoGeneratedCols = columns;
        this.columnList.reset(columns);
        if (data && data.length > 0) {
            this.shouldGenerate = false;
        }
    }
    generateDataFields(data) {
        return Object.keys(data && data.length !== 0 ? data[0] : []);
    }
    /**
     * @hidden
     */
    initColumns(collection, cb = null) {
        this._columnGroups = this.columnList.some(col => col.columnGroup);
        if (this.hasColumnLayouts) {
            // Set overall row layout size
            this.columnList.forEach((col) => {
                if (col.columnLayout) {
                    const layoutSize = col.children ?
                        col.children.reduce((acc, val) => Math.max(val.rowStart + val.gridRowSpan - 1, acc), 1) :
                        1;
                    this._multiRowLayoutRowSize = Math.max(layoutSize, this._multiRowLayoutRowSize);
                }
            });
        }
        if (this.hasColumnLayouts && this.hasColumnGroups) {
            // invalid configuration - multi-row and column groups
            // remove column groups
            const columnLayoutColumns = this.columnList.filter((col) => col.columnLayout || col.columnLayoutChild);
            this.columnList.reset(columnLayoutColumns);
        }
        this._maxLevelHeaderDepth = null;
        this._columns = this.columnList.toArray();
        collection.forEach((column) => {
            column.defaultWidth = this.columnWidthSetByUser ? this._columnWidth : column.defaultWidth ? column.defaultWidth : '';
            if (cb) {
                cb(column);
            }
        });
        this.reinitPinStates();
        if (this.hasColumnLayouts) {
            collection.forEach((column) => {
                column.populateVisibleIndexes();
            });
        }
    }
    /**
     * @hidden
     */
    reinitPinStates() {
        this._pinnedColumns = this.columnList
            .filter((c) => c.pinned).sort((a, b) => this._pinnedColumns.indexOf(a) - this._pinnedColumns.indexOf(b));
        this._unpinnedColumns = this.hasColumnGroups ? this.columnList.filter((c) => !c.pinned) :
            this.columnList.filter((c) => !c.pinned)
                .sort((a, b) => a.index - b.index);
    }
    extractDataFromSelection(source, formatters = false, headers = false, columnData) {
        var _a;
        let columnsArray;
        let record = {};
        let selectedData = [];
        let keys = [];
        const keysAndData = [];
        const activeEl = this.selectionService.activeElement;
        const totalItems = (_a = this.totalItemCount) !== null && _a !== void 0 ? _a : 0;
        const isRemote = totalItems && totalItems > this.dataView.length;
        const selectionMap = isRemote ? Array.from(this.selectionService.selection) :
            Array.from(this.selectionService.selection).filter((tuple) => tuple[0] < source.length);
        if (this.cellSelection === GridSelectionMode.single && activeEl) {
            selectionMap.push([activeEl.row, new Set().add(activeEl.column)]);
        }
        if (this.cellSelection === GridSelectionMode.none && activeEl) {
            selectionMap.push([activeEl.row, new Set().add(activeEl.column)]);
        }
        if (columnData) {
            selectedData = columnData;
        }
        // eslint-disable-next-line prefer-const
        for (let [row, set] of selectionMap) {
            row = this.paging ? row + (this.perPage * this.page) : row;
            row = isRemote ? row - this.virtualizationState.startIndex : row;
            if (!source[row] || source[row].detailsData !== undefined) {
                continue;
            }
            const temp = Array.from(set);
            for (const each of temp) {
                columnsArray = this.getSelectableColumnsAt(each);
                columnsArray.forEach((col) => {
                    if (col) {
                        const key = headers ? col.header || col.field : col.field;
                        const value = source[row].ghostRecord ?
                            resolveNestedPath(source[row].recordRef, col.field) : resolveNestedPath(source[row], col.field);
                        record[key] = formatters && col.formatter ? col.formatter(value) : value;
                        if (columnData) {
                            if (!record[key]) {
                                record[key] = '';
                            }
                            record[key] = record[key].toString().concat('recordRow-' + row);
                        }
                    }
                });
            }
            if (Object.keys(record).length) {
                if (columnData) {
                    if (!keys.length) {
                        keys = Object.keys(columnData[0]);
                    }
                    for (const [key, value] of Object.entries(record)) {
                        if (!keys.includes(key)) {
                            keys.push(key);
                        }
                        let c = value;
                        const rowNumber = +c.split('recordRow-')[1];
                        c = c.split('recordRow-')[0];
                        record[key] = c;
                        const mergedObj = Object.assign(selectedData[rowNumber], record);
                        selectedData[rowNumber] = mergedObj;
                    }
                }
                else {
                    selectedData.push(record);
                }
            }
            record = {};
        }
        if (keys.length) {
            keysAndData.push(selectedData);
            keysAndData.push(keys);
            return keysAndData;
        }
        else {
            return selectedData;
        }
    }
    getSelectableColumnsAt(index) {
        if (this.hasColumnLayouts) {
            const visibleLayoutColumns = this.visibleColumns
                .filter(col => col.columnLayout)
                .sort((a, b) => a.visibleIndex - b.visibleIndex);
            const colLayout = visibleLayoutColumns[index];
            return colLayout ? colLayout.children.toArray() : [];
        }
        else {
            const visibleColumns = this.visibleColumns
                .filter(col => !col.columnGroup)
                .sort((a, b) => a.visibleIndex - b.visibleIndex);
            return [visibleColumns[index]];
        }
    }
    extractDataFromColumnsSelection(source, formatters = false, headers = false) {
        let record = {};
        const selectedData = [];
        const selectedColumns = this.selectedColumns();
        if (selectedColumns.length === 0) {
            return [];
        }
        for (const data of source) {
            selectedColumns.forEach((col) => {
                const key = headers ? col.header || col.field : col.field;
                record[key] = formatters && col.formatter ? col.formatter(data[col.field])
                    : data[col.field];
            });
            if (Object.keys(record).length) {
                selectedData.push(record);
            }
            record = {};
        }
        return selectedData;
    }
    /**
     * @hidden
     */
    initPinning() {
        const pinnedColumns = [];
        const unpinnedColumns = [];
        this.calculateGridWidth();
        this.resetCaches();
        // When a column is a group or is inside a group, pin all related.
        this._pinnedColumns.forEach(col => {
            if (col.parent) {
                col.parent.pinned = true;
            }
            if (col.columnGroup) {
                col.children.forEach(child => child.pinned = true);
            }
        });
        // Make sure we don't exceed unpinned area min width and get pinned and unpinned col collections.
        // We take into account top level columns (top level groups and non groups).
        // If top level is unpinned the pinning handles all children to be unpinned as well.
        for (const column of this._columns) {
            if (column.pinned && !column.parent) {
                pinnedColumns.push(column);
            }
            else if (column.pinned && column.parent) {
                if (column.topLevelParent.pinned) {
                    pinnedColumns.push(column);
                }
                else {
                    column.pinned = false;
                    unpinnedColumns.push(column);
                }
            }
            else {
                unpinnedColumns.push(column);
            }
        }
        // Assign the applicaple collections.
        this._pinnedColumns = pinnedColumns;
        this._unpinnedColumns = unpinnedColumns;
        this.notifyChanges();
    }
    /**
     * @hidden
     */
    scrollTo(row, column, inCollection = this._filteredSortedUnpinnedData) {
        let delayScrolling = false;
        if (this.paging && typeof (row) !== 'number') {
            const rowIndex = inCollection.indexOf(row);
            const page = Math.floor(rowIndex / this.perPage);
            if (this.page !== page) {
                delayScrolling = true;
                this.page = page;
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(first$1()).subscribe(() => {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(row));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(row));
        }
        this.scrollToHorizontally(column);
    }
    /**
     * @hidden
     */
    scrollToHorizontally(column) {
        let columnIndex = typeof column === 'number' ? column : this.getColumnByName(column).visibleIndex;
        const scrollRow = this.rowList.find(r => r.virtDirRow);
        const virtDir = scrollRow ? scrollRow.virtDirRow : null;
        if (this.isPinningToStart && this.pinnedColumns.length) {
            if (columnIndex >= this.pinnedColumns.length) {
                columnIndex -= this.pinnedColumns.length;
                this.scrollDirective(virtDir, columnIndex);
            }
        }
        else {
            this.scrollDirective(virtDir, columnIndex);
        }
    }
    /**
     * @hidden
     */
    scrollDirective(directive, goal) {
        if (!directive) {
            return;
        }
        directive.scrollTo(goal);
    }
    getColumnWidthSum() {
        let colSum = 0;
        const cols = this.hasColumnLayouts ?
            this.visibleColumns.filter(x => x.columnLayout) : this.visibleColumns.filter(x => !x.columnGroup);
        cols.forEach((item) => {
            colSum += parseInt((item.calcWidth || item.defaultWidth), 10) || MINIMUM_COLUMN_WIDTH;
        });
        if (!colSum) {
            return null;
        }
        this.cdr.detectChanges();
        colSum += this.featureColumnsWidth();
        return colSum;
    }
    /**
     * Notiy changes, reset cache and populateVisibleIndexes.
     *
     * @hidden
     */
    _columnsReordered(column, target) {
        this.notifyChanges();
        if (this.hasColumnLayouts) {
            this.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        // after reordering is done reset cached column collections.
        this.resetColumnCollections();
        column.resetCaches();
    }
    _applyWidthHostBinding() {
        let width = this._width;
        if (width === null) {
            let currentWidth = this.calcWidth;
            if (this.hasVerticalScroll()) {
                currentWidth += this.scrollSize;
            }
            width = currentWidth + 'px';
            this.resetCaches();
        }
        this._hostWidth = width;
        this.cdr.markForCheck();
    }
    verticalScrollHandler(event) {
        var _a;
        this.verticalScrollContainer.onScroll(event);
        this.disableTransitions = true;
        this.zone.run(() => {
            this.zone.onStable.pipe(first$1()).subscribe(() => {
                this.verticalScrollContainer.onChunkLoad.emit(this.verticalScrollContainer.state);
                if (this.rowEditable) {
                    this.changeRowEditingOverlayStateOnScroll(this.rowInEditMode);
                }
            });
        });
        this.disableTransitions = false;
        this.hideOverlays();
        (_a = this.actionStrip) === null || _a === void 0 ? void 0 : _a.hide();
        const args = {
            direction: 'vertical',
            event,
            scrollPosition: this.verticalScrollContainer.scrollPosition
        };
        this.onScroll.emit(args);
    }
    horizontalScrollHandler(event) {
        const scrollLeft = event.target.scrollLeft;
        this.headerContainer.onHScroll(scrollLeft);
        this._horizontalForOfs.forEach(vfor => vfor.onHScroll(scrollLeft));
        this.cdr.markForCheck();
        this.zone.run(() => {
            this.zone.onStable.pipe(first$1()).subscribe(() => {
                this.parentVirtDir.onChunkLoad.emit(this.headerContainer.state);
            });
        });
        this.hideOverlays();
        const args = { direction: 'horizontal', event, scrollPosition: this.headerContainer.scrollPosition };
        this.onScroll.emit(args);
    }
    executeCallback(rowIndex, visibleColIndex = -1, cb = null) {
        if (!cb) {
            return;
        }
        let row = this.summariesRowList.filter(s => s.index !== 0).concat(this.rowList.toArray()).find(r => r.index === rowIndex);
        if (!row) {
            if (this.totalItemCount) {
                this.verticalScrollContainer.onDataChanged.pipe(first$1()).subscribe(() => {
                    this.cdr.detectChanges();
                    row = this.summariesRowList.filter(s => s.index !== 0).concat(this.rowList.toArray()).find(r => r.index === rowIndex);
                    const cbArgs = this.getNavigationArguments(row, visibleColIndex);
                    cb(cbArgs);
                });
            }
            if (this.dataView[rowIndex].detailsData) {
                this.navigation.setActiveNode({ row: rowIndex });
                this.cdr.detectChanges();
            }
            return;
        }
        const args = this.getNavigationArguments(row, visibleColIndex);
        cb(args);
    }
    getNavigationArguments(row, visibleColIndex) {
        let targetType;
        let target;
        switch (row.nativeElement.tagName.toLowerCase()) {
            case 'igx-grid-groupby-row':
                targetType = 'groupRow';
                target = row;
                break;
            case 'igx-grid-summary-row':
                targetType = 'summaryCell';
                target = visibleColIndex !== -1 ?
                    row.summaryCells.find(c => c.visibleColumnIndex === visibleColIndex) : row.summaryCells.first;
                break;
            case 'igx-child-grid-row':
                targetType = 'hierarchicalRow';
                target = row;
                break;
            default:
                targetType = 'dataCell';
                target = visibleColIndex !== -1 ? row.cells.find(c => c.visibleColumnIndex === visibleColIndex) : row.cells.first;
                break;
        }
        return { targetType, target };
    }
    getNextDataRowIndex(currentRowIndex, previous = false) {
        if (currentRowIndex < 0 || (currentRowIndex === 0 && previous) || (currentRowIndex >= this.dataView.length - 1 && !previous)) {
            return currentRowIndex;
        }
        // find next/prev record that is editable.
        const nextRowIndex = previous ? this.findPrevEditableDataRowIndex(currentRowIndex) :
            this.dataView.findIndex((rec, index) => index > currentRowIndex && this.isEditableDataRecordAtIndex(index));
        return nextRowIndex !== -1 ? nextRowIndex : currentRowIndex;
    }
    /**
     * Returns the previous editable row index or -1 if no such row is found.
     *
     * @param currentIndex The index of the current editable record.
     */
    findPrevEditableDataRowIndex(currentIndex) {
        let i = this.dataView.length;
        while (i--) {
            if (i < currentIndex && this.isEditableDataRecordAtIndex(i)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Returns if the record at the specified data view index is a an editable data record.
     * If record is group rec, summary rec, child rec, ghost rec. etc. it is not editable.
     *
     * @param dataViewIndex The index of that record in the data view.
     */
    isEditableDataRecordAtIndex(dataViewIndex) {
        const rec = this.dataView[dataViewIndex];
        return !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData &&
            !this.isGhostRecordAtIndex(dataViewIndex);
    }
    /**
     * Returns if the record at the specified data view index is a ghost.
     * If record is pinned but is not in pinned area then it is a ghost record.
     *
     * @param dataViewIndex The index of that record in the data view.
     */
    isGhostRecordAtIndex(dataViewIndex) {
        const isPinned = this.isRecordPinned(this.dataView[dataViewIndex]);
        const isInPinnedArea = this.isRecordPinnedByViewIndex(dataViewIndex);
        return isPinned && !isInPinnedArea;
    }
    isValidPosition(rowIndex, colIndex) {
        const rows = this.summariesRowList.filter(s => s.index !== 0).concat(this.rowList.toArray()).length;
        const cols = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0 && !col.hidden).length;
        if (rows < 1 || cols < 1) {
            return false;
        }
        if (rowIndex > -1 && rowIndex < this.dataView.length &&
            colIndex > -1 && colIndex <= Math.max(...this.visibleColumns.map(c => c.visibleIndex))) {
            return true;
        }
        return false;
    }
    find(text, increment, caseSensitive, exactMatch, scroll, endEdit = true) {
        if (!this.rowList) {
            return 0;
        }
        if (endEdit) {
            this.endEdit(false);
        }
        if (!text) {
            this.clearSearch();
            return 0;
        }
        const caseSensitiveResolved = caseSensitive ? true : false;
        const exactMatchResolved = exactMatch ? true : false;
        let rebuildCache = false;
        if (this.lastSearchInfo.searchText !== text ||
            this.lastSearchInfo.caseSensitive !== caseSensitiveResolved ||
            this.lastSearchInfo.exactMatch !== exactMatchResolved) {
            this.lastSearchInfo = {
                searchText: text,
                activeMatchIndex: 0,
                caseSensitive: caseSensitiveResolved,
                exactMatch: exactMatchResolved,
                matchInfoCache: []
            };
            rebuildCache = true;
        }
        else {
            this.lastSearchInfo.activeMatchIndex += increment;
        }
        if (rebuildCache) {
            this.rowList.forEach((row) => {
                if (row.cells) {
                    row.cells.forEach((c) => {
                        c.highlightText(text, caseSensitiveResolved, exactMatchResolved);
                    });
                }
            });
            this.rebuildMatchCache();
        }
        if (this.lastSearchInfo.activeMatchIndex >= this.lastSearchInfo.matchInfoCache.length) {
            this.lastSearchInfo.activeMatchIndex = 0;
        }
        else if (this.lastSearchInfo.activeMatchIndex < 0) {
            this.lastSearchInfo.activeMatchIndex = this.lastSearchInfo.matchInfoCache.length - 1;
        }
        if (this.lastSearchInfo.matchInfoCache.length) {
            const matchInfo = this.lastSearchInfo.matchInfoCache[this.lastSearchInfo.activeMatchIndex];
            this.lastSearchInfo = Object.assign({}, this.lastSearchInfo);
            if (scroll !== false) {
                this.scrollTo(matchInfo.row, matchInfo.column);
            }
            IgxTextHighlightDirective.setActiveHighlight(this.id, {
                column: matchInfo.column,
                row: matchInfo.row,
                index: matchInfo.index,
                metadata: matchInfo.metadata,
            });
        }
        else {
            IgxTextHighlightDirective.clearActiveHighlight(this.id);
        }
        return this.lastSearchInfo.matchInfoCache.length;
    }
    rebuildMatchCache() {
        this.lastSearchInfo.matchInfoCache = [];
        const caseSensitive = this.lastSearchInfo.caseSensitive;
        const exactMatch = this.lastSearchInfo.exactMatch;
        const searchText = caseSensitive ? this.lastSearchInfo.searchText : this.lastSearchInfo.searchText.toLowerCase();
        const data = this.filteredSortedData;
        const columnItems = this.visibleColumns.filter((c) => !c.columnGroup).sort((c1, c2) => c1.visibleIndex - c2.visibleIndex);
        data.forEach((dataRow, rowIndex) => {
            columnItems.forEach((c) => {
                const pipeArgs = this.getColumnByName(c.field).pipeArgs;
                const value = c.formatter ? c.formatter(resolveNestedPath(dataRow, c.field)) :
                    c.dataType === 'number' ? this.decimalPipe.transform(resolveNestedPath(dataRow, c.field), pipeArgs.digitsInfo, this.locale) :
                        c.dataType === 'date' ? this.datePipe.transform(resolveNestedPath(dataRow, c.field), pipeArgs.format, pipeArgs.timezone, this.locale)
                            : resolveNestedPath(dataRow, c.field);
                if (value !== undefined && value !== null && c.searchable) {
                    let searchValue = caseSensitive ? String(value) : String(value).toLowerCase();
                    if (exactMatch) {
                        if (searchValue === searchText) {
                            const metadata = new Map();
                            metadata.set('pinned', this.isRecordPinnedByIndex(rowIndex));
                            this.lastSearchInfo.matchInfoCache.push({
                                row: dataRow,
                                column: c.field,
                                index: 0,
                                metadata,
                            });
                        }
                    }
                    else {
                        let occurenceIndex = 0;
                        let searchIndex = searchValue.indexOf(searchText);
                        while (searchIndex !== -1) {
                            const metadata = new Map();
                            metadata.set('pinned', this.isRecordPinnedByIndex(rowIndex));
                            this.lastSearchInfo.matchInfoCache.push({
                                row: dataRow,
                                column: c.field,
                                index: occurenceIndex++,
                                metadata,
                            });
                            searchValue = searchValue.substring(searchIndex + searchText.length);
                            searchIndex = searchValue.indexOf(searchText);
                        }
                    }
                }
            });
        });
    }
    configureRowEditingOverlay(rowID, useOuter = false) {
        let settings = this.rowEditSettings;
        const overlay = this.overlayService.getOverlayById(this.rowEditingOverlay.overlayId);
        if (overlay) {
            settings = overlay.settings;
        }
        settings.outlet = useOuter ? this.parentRowOutletDirective : this.rowOutletDirective;
        this.rowEditPositioningStrategy.settings.container = this.tbody.nativeElement;
        const pinned = this._pinnedRecordIDs.indexOf(rowID) !== -1;
        const targetRow = !pinned ? this.gridAPI.get_row_by_key(rowID) : this.pinnedRows.find(x => x.rowID === rowID);
        if (!targetRow) {
            return;
        }
        settings.target = targetRow.element.nativeElement;
        this.toggleRowEditingOverlay(true);
    }
    /**
     * @hidden
     */
    rowEditingWheelHandler(event) {
        if (event.deltaY > 0) {
            this.verticalScrollContainer.scrollNext();
        }
        else {
            this.verticalScrollContainer.scrollPrev();
        }
    }
}
IgxGridBaseDirective.decorators = [
    { type: Directive }
];
IgxGridBaseDirective.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: IgxColumnResizingService },
    { type: GridBaseAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
    { type: ElementRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: IterableDiffers },
    { type: ViewContainerRef },
    { type: IgxGridNavigationService },
    { type: IgxFilteringService },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxGridSummaryService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
IgxGridBaseDirective.propDecorators = {
    snackbarDisplayTime: [{ type: Input }],
    autoGenerate: [{ type: Input }],
    emptyGridTemplate: [{ type: Input }],
    addRowEmptyTemplate: [{ type: Input }],
    loadingGridTemplate: [{ type: Input }],
    clipboardOptions: [{ type: Input }],
    filteringExpressionsTreeChange: [{ type: Output }],
    advancedFilteringExpressionsTreeChange: [{ type: Output }],
    onScroll: [{ type: Output }],
    pageChange: [{ type: Output }],
    perPageChange: [{ type: Output }],
    paginationTemplate: [{ type: Input }],
    class: [{ type: Input }],
    evenRowCSS: [{ type: Input }],
    oddRowCSS: [{ type: Input }],
    primaryKey: [{ type: Input }],
    uniqueColumnValuesStrategy: [{ type: Input }],
    excelStyleFilteringComponents: [{ type: ContentChildren, args: [IgxGridExcelStyleFilteringComponent, { read: IgxGridExcelStyleFilteringComponent, descendants: false },] }],
    headerGroups: [{ type: ViewChildren, args: [IgxGridHeaderGroupComponent, { read: IgxGridHeaderGroupComponent },] }],
    onCellClick: [{ type: Output }],
    onSelection: [{ type: Output }],
    onRowSelectionChange: [{ type: Output }],
    onColumnSelectionChange: [{ type: Output }],
    onColumnPinning: [{ type: Output }],
    columnPinned: [{ type: Output }],
    cellEditEnter: [{ type: Output }],
    cellEditExit: [{ type: Output }],
    cellEdit: [{ type: Output }],
    cellEditDone: [{ type: Output }],
    rowEditEnter: [{ type: Output }],
    rowEdit: [{ type: Output }],
    rowEditDone: [{ type: Output }],
    rowEditExit: [{ type: Output }],
    onColumnInit: [{ type: Output }],
    sorting: [{ type: Output }],
    onSortingDone: [{ type: Output }],
    filtering: [{ type: Output }],
    onFilteringDone: [{ type: Output }],
    onPagingDone: [{ type: Output }],
    onRowAdded: [{ type: Output }],
    onRowDeleted: [{ type: Output }],
    onColumnResized: [{ type: Output }],
    onContextMenu: [{ type: Output }],
    onDoubleClick: [{ type: Output }],
    columnVisibilityChanging: [{ type: Output }],
    onColumnVisibilityChanged: [{ type: Output }],
    onColumnMovingStart: [{ type: Output }],
    onColumnMoving: [{ type: Output }],
    onColumnMovingEnd: [{ type: Output }],
    onGridKeydown: [{ type: Output }],
    onRowDragStart: [{ type: Output }],
    onRowDragEnd: [{ type: Output }],
    onGridCopy: [{ type: Output }],
    expansionStatesChange: [{ type: Output }],
    onRowToggle: [{ type: Output }],
    onRowPinning: [{ type: Output }],
    activeNodeChange: [{ type: Output }],
    sortingExpressionsChange: [{ type: Output }],
    onToolbarExporting: [{ type: Output }],
    onRangeSelection: [{ type: Output }],
    rendered: [{ type: Output }],
    addRowSnackbar: [{ type: ViewChild, args: [IgxSnackbarComponent,] }],
    resizeLine: [{ type: ViewChild, args: [IgxGridColumnResizerComponent,] }],
    loadingOverlay: [{ type: ViewChild, args: ['loadingOverlay', { read: IgxToggleDirective, static: true },] }],
    loadingOutlet: [{ type: ViewChild, args: ['igxLoadingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    columnList: [{ type: ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: true },] }],
    actionStrip: [{ type: ContentChild, args: [IgxActionStripComponent,] }],
    excelStyleLoadingValuesTemplateDirective: [{ type: ContentChild, args: [IgxExcelStyleLoadingValuesTemplateDirective, { read: IgxExcelStyleLoadingValuesTemplateDirective, static: true },] }],
    emptyFilteredGridTemplate: [{ type: ViewChild, args: ['emptyFilteredGrid', { read: TemplateRef, static: true },] }],
    emptyGridDefaultTemplate: [{ type: ViewChild, args: ['defaultEmptyGrid', { read: TemplateRef, static: true },] }],
    loadingGridDefaultTemplate: [{ type: ViewChild, args: ['defaultLoadingGrid', { read: TemplateRef, static: true },] }],
    parentVirtDir: [{ type: ViewChild, args: ['scrollContainer', { read: IgxGridForOfDirective, static: true },] }],
    headSelectorsTemplates: [{ type: ContentChildren, args: [IgxHeadSelectorDirective, { read: IgxHeadSelectorDirective, descendants: false },] }],
    rowSelectorsTemplates: [{ type: ContentChildren, args: [IgxRowSelectorDirective, { read: IgxRowSelectorDirective, descendants: false },] }],
    dragGhostCustomTemplates: [{ type: ContentChildren, args: [IgxRowDragGhostDirective, { read: TemplateRef, descendants: false },] }],
    verticalScrollContainer: [{ type: ViewChild, args: ['verticalScrollContainer', { read: IgxGridForOfDirective, static: true },] }],
    verticalScroll: [{ type: ViewChild, args: ['verticalScrollHolder', { read: IgxGridForOfDirective, static: true },] }],
    scr: [{ type: ViewChild, args: ['scr', { read: ElementRef, static: true },] }],
    footer: [{ type: ViewChild, args: ['footer', { read: ElementRef },] }],
    headerContainer: [{ type: ViewChild, args: ['hContainer', { read: IgxGridForOfDirective, static: true },] }],
    headerSelectorContainer: [{ type: ViewChild, args: ['headerSelectorContainer',] }],
    headerDragContainer: [{ type: ViewChild, args: ['headerDragContainer',] }],
    headerGroupContainer: [{ type: ViewChild, args: ['headerGroupContainer',] }],
    filteringRow: [{ type: ViewChild, args: ['filteringRow', { read: IgxGridFilteringRowComponent },] }],
    theadRow: [{ type: ViewChild, args: ['theadRow', { static: true },] }],
    tbody: [{ type: ViewChild, args: ['tbody', { static: true },] }],
    pinContainer: [{ type: ViewChild, args: ['pinContainer', { read: ElementRef },] }],
    tfoot: [{ type: ViewChild, args: ['tfoot', { static: true },] }],
    rowEditingOutletDirective: [{ type: ViewChild, args: ['igxRowEditingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    tmpOutlets: [{ type: ViewChildren, args: [IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective },] }],
    dragIndicatorIconBase: [{ type: ViewChild, args: ['dragIndicatorIconBase', { read: TemplateRef, static: true },] }],
    rowEditCustom: [{ type: ContentChild, args: [IgxRowEditTemplateDirective, { read: TemplateRef },] }],
    rowEditText: [{ type: ContentChild, args: [IgxRowEditTextDirective, { read: TemplateRef },] }],
    rowEditActions: [{ type: ContentChild, args: [IgxRowEditActionsDirective, { read: TemplateRef },] }],
    rowExpandedIndicatorTemplate: [{ type: ContentChild, args: [IgxRowExpandedIndicatorDirective, { read: TemplateRef },] }],
    rowCollapsedIndicatorTemplate: [{ type: ContentChild, args: [IgxRowCollapsedIndicatorDirective, { read: TemplateRef },] }],
    headerExpandIndicatorTemplate: [{ type: ContentChild, args: [IgxHeaderExpandIndicatorDirective, { read: TemplateRef },] }],
    headerCollapseIndicatorTemplate: [{ type: ContentChild, args: [IgxHeaderCollapseIndicatorDirective, { read: TemplateRef },] }],
    excelStyleHeaderIconTemplate: [{ type: ContentChild, args: [IgxExcelStyleHeaderIconDirective, { read: TemplateRef },] }],
    dragIndicatorIconTemplates: [{ type: ContentChildren, args: [IgxDragIndicatorIconDirective, { read: TemplateRef, descendants: false },] }],
    rowEditTabsDEFAULT: [{ type: ViewChildren, args: [IgxRowEditTabStopDirective,] }],
    rowEditTabsCUSTOM: [{ type: ContentChildren, args: [IgxRowEditTabStopDirective, { descendants: true },] }],
    rowEditingOverlay: [{ type: ViewChild, args: ['rowEditingOverlay', { read: IgxToggleDirective },] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }],
    toolbar: [{ type: ContentChildren, args: [IgxGridToolbarComponent,] }],
    _outletDirective: [{ type: ViewChild, args: ['igxFilteringOverlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    defaultExpandedTemplate: [{ type: ViewChild, args: ['defaultExpandedTemplate', { read: TemplateRef, static: true },] }],
    defaultCollapsedTemplate: [{ type: ViewChild, args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true },] }],
    defaultESFHeaderIconTemplate: [{ type: ViewChild, args: ['defaultESFHeaderIcon', { read: TemplateRef, static: true },] }],
    _summaryRowList: [{ type: ViewChildren, args: ['summaryRow', { read: IgxSummaryRowComponent },] }],
    _rowList: [{ type: ViewChildren, args: ['row',] }],
    _pinnedRowList: [{ type: ViewChildren, args: ['pinnedRow',] }],
    defaultRowEditTemplate: [{ type: ViewChild, args: ['defaultRowEditTemplate', { read: TemplateRef, static: true },] }],
    _dataRowList: [{ type: ViewChildren, args: [IgxRowDirective, { read: IgxRowDirective },] }],
    resourceStrings: [{ type: Input }],
    filteringLogic: [{ type: Input }],
    filteringExpressionsTree: [{ type: Input }],
    advancedFilteringExpressionsTree: [{ type: Input }],
    locale: [{ type: Input }],
    pagingMode: [{ type: Input }],
    paging: [{ type: Input }],
    page: [{ type: Input }],
    perPage: [{ type: Input }],
    columnHiding: [{ type: Input }],
    hideRowSelectors: [{ type: Input }],
    rowDraggable: [{ type: Input }],
    rowEditable: [{ type: Input }],
    height: [{ type: HostBinding, args: ['style.height',] }, { type: Input }],
    hostWidth: [{ type: HostBinding, args: ['style.width',] }],
    width: [{ type: Input }],
    rowHeight: [{ type: Input }],
    columnWidth: [{ type: Input }],
    emptyGridMessage: [{ type: Input }],
    isLoading: [{ type: Input }],
    emptyFilteredGridMessage: [{ type: Input }],
    columnHidingTitle: [{ type: Input }],
    pinning: [{ type: Input }],
    columnPinning: [{ type: Input }],
    columnPinningTitle: [{ type: Input }],
    allowFiltering: [{ type: Input }],
    allowAdvancedFiltering: [{ type: Input }],
    filterMode: [{ type: Input }],
    summaryPosition: [{ type: Input }],
    summaryCalculationMode: [{ type: Input }],
    showSummaryOnCollapse: [{ type: Input }],
    filterStrategy: [{ type: Input }],
    sortStrategy: [{ type: Input }],
    selectedRows: [{ type: Input }],
    hostClass: [{ type: HostBinding, args: ['attr.class',] }],
    sortingExpressions: [{ type: Input }],
    hiddenColumnsText: [{ type: Input }],
    pinnedColumnsText: [{ type: Input }],
    showToolbar: [{ type: Input }],
    toolbarTitle: [{ type: Input }],
    exportExcel: [{ type: Input }],
    exportCsv: [{ type: Input }],
    exportText: [{ type: Input }],
    exportExcelText: [{ type: Input }],
    exportCsvText: [{ type: Input }],
    cellSelection: [{ type: Input }],
    rowSelection: [{ type: Input }],
    columnSelection: [{ type: Input }],
    hideActionStrip: [{ type: HostListener, args: ['mouseleave',] }],
    expansionStates: [{ type: Input }],
    outlet: [{ type: Input }],
    totalRecords: [{ type: Input }],
    selectRowOnClick: [{ type: Input }]
};
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "primaryKey", void 0);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "filteringLogic", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "filteringExpressionsTree", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "advancedFilteringExpressionsTree", null);
__decorate([
    DeprecateProperty('`columnHiding` is deprecated.')
], IgxGridBaseDirective.prototype, "columnHiding", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "hideRowSelectors", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "rowEditable", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "height", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "width", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "rowHeight", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "columnWidth", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "isLoading", null);
__decorate([
    DeprecateProperty('`columnHidingTitle` is deprecated')
], IgxGridBaseDirective.prototype, "columnHidingTitle", null);
__decorate([
    DeprecateProperty('`columnPinning` is deprecated')
], IgxGridBaseDirective.prototype, "columnPinning", null);
__decorate([
    DeprecateProperty('`columnPinningTitle` is deprecated')
], IgxGridBaseDirective.prototype, "columnPinningTitle", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "sortingExpressions", null);
__decorate([
    DeprecateProperty('`pinnedColumnsText` is deprecated')
], IgxGridBaseDirective.prototype, "pinnedColumnsText", null);
__decorate([
    DeprecateProperty('`showToolbar` is deprecated')
], IgxGridBaseDirective.prototype, "showToolbar", null);
__decorate([
    DeprecateProperty('`toolbarTitle` is deprecated')
], IgxGridBaseDirective.prototype, "toolbarTitle", null);
__decorate([
    DeprecateProperty('`exportExcel` is deprecated')
], IgxGridBaseDirective.prototype, "exportExcel", null);
__decorate([
    DeprecateProperty('`exportCsv` is deprecated')
], IgxGridBaseDirective.prototype, "exportCsv", null);
__decorate([
    DeprecateProperty('`exportText` is deprecated')
], IgxGridBaseDirective.prototype, "exportText", null);
__decorate([
    DeprecateProperty('`exportExcelText` is deprecated')
], IgxGridBaseDirective.prototype, "exportExcelText", null);
__decorate([
    DeprecateProperty('`exportCsvText` is deprecated')
], IgxGridBaseDirective.prototype, "exportCsvText", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "cellSelection", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "rowSelection", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "columnSelection", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "selectRowOnClick", null);

class IgxGridFooterComponent {
}
IgxGridFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-grid-footer',
                template: '<ng-content></ng-content>'
            },] }
];

/**
 * The `<igx-select-item>` is a container intended for row items in
 * a `<igx-select>` container.
 */
class IgxSelectGroupComponent extends IgxDropDownGroupComponent {
}
IgxSelectGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-select-item-group',
                template: `
        <label id="{{labelId}}">{{ label }}</label>
        <ng-content select="igx-select-item"></ng-content>
    `
            },] }
];

/** @hidden @internal */
class IgxSelectItemNavigationDirective extends IgxDropDownItemNavigationDirective {
    constructor() {
        super(null);
        this._target = null;
        /* eslint-disable @typescript-eslint/member-ordering */
        this.inputStream = '';
        this.clearStream$ = Subscription.EMPTY;
    }
    get target() {
        return this._target;
    }
    set target(target) {
        this._target = target ? target : this.dropdown;
    }
    /** Captures keydown events and calls the appropriate handlers on the target component */
    handleKeyDown(event) {
        if (!event) {
            return;
        }
        const key = event.key.toLowerCase();
        if (event.altKey && (key === 'arrowdown' || key === 'arrowup' || key === 'down' || key === 'up')) {
            this.target.toggle();
            return;
        }
        if (this.target.collapsed) {
            switch (key) {
                case 'space':
                case 'spacebar':
                case ' ':
                case 'enter':
                    event.preventDefault();
                    this.target.open();
                    return;
                case 'arrowdown':
                case 'down':
                    this.target.navigateNext();
                    this.target.selectItem(this.target.focusedItem);
                    event.preventDefault();
                    return;
                case 'arrowup':
                case 'up':
                    this.target.navigatePrev();
                    this.target.selectItem(this.target.focusedItem);
                    event.preventDefault();
                    return;
                default:
                    break;
            }
        }
        else if (key === 'tab' || event.shiftKey && key === 'tab') {
            this.target.close();
        }
        super.handleKeyDown(event);
        this.captureKey(event);
    }
    captureKey(event) {
        // relying only on key, available on all major browsers:
        // https://caniuse.com/#feat=keyboardevent-key (IE/Edge quirk doesn't affect letter typing)
        if (!event || !event.key || event.key.length > 1 || event.key === ' ' || event.key === 'spacebar') {
            // ignore longer keys ('Alt', 'ArrowDown', etc) AND spacebar (used of open/close)
            return;
        }
        this.clearStream$.unsubscribe();
        this.clearStream$ = timer(500).subscribe(() => {
            this.inputStream = '';
        });
        this.inputStream += event.key;
        const focusedItem = this.target.focusedItem;
        // select the item
        if (focusedItem && this.inputStream.length > 1 && focusedItem.itemText.toLowerCase().startsWith(this.inputStream.toLowerCase())) {
            return;
        }
        this.activateItemByText(this.inputStream);
    }
    activateItemByText(text) {
        const items = this.target.items;
        // ^ this is focused OR selected if the dd is closed
        let nextItem = this.findNextItem(items, text);
        // If there is no such an item starting with the current text input stream AND the last Char in the input stream
        // is the same as the first one, find next item starting with the same first Char.
        // Covers cases of holding down the same key Ex: "pppppp" that iterates trough list items starting with "p".
        if (!nextItem && text.charAt(0) === text.charAt(text.length - 1)) {
            text = text.slice(0, 1);
            nextItem = this.findNextItem(items, text);
        }
        // If there is no other item to be found, do not change the active item.
        if (!nextItem) {
            return;
        }
        if (this.target.collapsed) {
            this.target.selectItem(nextItem);
        }
        this.target.navigateItem(items.indexOf(nextItem));
    }
    findNextItem(items, text) {
        const activeItemIndex = items.indexOf(this.target.focusedItem) || 0;
        // Match next item in ddl items and wrap around if needed
        return items.slice(activeItemIndex + 1).find(x => !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase()))) ||
            items.slice(0, activeItemIndex).find(x => !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase())));
    }
    ngOnDestroy() {
        this.clearStream$.unsubscribe();
    }
}
IgxSelectItemNavigationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxSelectItemNavigation]'
            },] }
];
IgxSelectItemNavigationDirective.ctorParameters = () => [];
IgxSelectItemNavigationDirective.propDecorators = {
    target: [{ type: Input, args: ['igxSelectItemNavigation',] }]
};

/** @hidden */
class IgxSelectModule {
}
IgxSelectModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxSelectComponent,
                    IgxSelectFooterDirective,
                    IgxSelectGroupComponent,
                    IgxSelectHeaderDirective,
                    IgxSelectItemComponent,
                    IgxSelectItemNavigationDirective,
                    IgxSelectToggleIconDirective
                ],
                exports: [
                    IgxSelectComponent,
                    IgxSelectFooterDirective,
                    IgxSelectGroupComponent,
                    IgxSelectHeaderDirective,
                    IgxSelectItemComponent,
                    IgxSelectItemNavigationDirective,
                    IgxSelectToggleIconDirective,
                    IgxInputGroupModule
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    IgxButtonModule,
                    IgxDropDownModule,
                    IgxIconModule,
                    IgxInputGroupModule,
                    IgxRippleModule,
                    IgxToggleModule,
                    ReactiveFormsModule
                ],
                providers: []
            },] }
];

class IgxPaginatorComponent extends DisplayDensityBase {
    constructor(_displayDensityOptions) {
        super(_displayDensityOptions);
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * An @Input property that sets if the pager in the paginator should be enabled.
         * ```html
         * <igx-paginator [pagerEnabled]="true"></igx-paginator>
         * ```
         *
         * @memberof IgxPaginatorComponent
         */
        this.pagerEnabled = true;
        /**
         * An @Input property that sets if the pager in the paginator should be hidden.
         * ```html
         * <igx-paginator [pagerHidden]="true"></igx-paginator>
         * ```
         *
         * @memberof IgxPaginatorComponent
         */
        this.pagerHidden = false;
        /**
         * An @Input property that sets if the dropdown in the paginator should be enabled.
         * ```html
         * <igx-paginator [dropdownEnabled]="true"></igx-paginator>
         * ```
         *
         * @memberof IgxPaginatorComponent
         */
        this.dropdownEnabled = true;
        /**
         * An @Input property that sets if the dropdown in the paginator should be hidden.
         * ```html
         * <igx-paginator [dropdownHidden]="true"></igx-paginator>
         * ```
         *
         * @memberof IgxPaginatorComponent
         */
        this.dropdownHidden = false;
        /**
         * Emitted when `perPage` property value of the paginator is changed.
         *
         * @example
         * ```html
         * <igx-paginator (perPageChange)="onPerPageChange($event)"></igx-paginator>
         * ```
         * ```typescript
         * public onPerPageChange(perPage: number) {
         *   this.perPage = perPage;
         * }
         * ```
         */
        this.perPageChange = new EventEmitter();
        /**
         * Emitted after the current page is changed.
         *
         * @example
         * ```html
         * <igx-paginator (pageChange)="onPageChange($event)"></igx-paginator>
         * ```
         * ```typescript
         * public onPageChange(page: number) {
         *   this.currentPage = page;
         * }
         * ```
         */
        this.pageChange = new EventEmitter();
        this._page = 0;
        this._perPage = 15;
        this._resourceStrings = CurrentResourceStrings.PaginatorResStrings;
        this._overlaySettings = {};
        this.defaultSelectValues = [5, 10, 15, 25, 50, 100, 500];
    }
    /**
     * Sets the class of the IgxPaginatorComponent based
     * on the provided displayDensity.
     */
    get classCosy() {
        return this.displayDensity === DisplayDensity.cosy;
    }
    get classCompact() {
        return this.displayDensity === DisplayDensity.compact;
    }
    get classComfortable() {
        return this.displayDensity === DisplayDensity.comfortable;
    }
    /**
     * An @Input property, sets current page of the `IgxPaginatorComponent`.
     * The default is 0.
     * ```typescript
     * let page = this.paginator.page;
     * ```
     *
     * @memberof IgxPaginatorComponent
     */
    get page() {
        return this._page;
    }
    set page(value) {
        this._page = value;
        this.pageChange.emit(this._page);
    }
    /**
     * An @Input property, sets number of visible items per page in the `IgxPaginatorComponent`.
     * The default is 15.
     * ```typescript
     * let itemsPerPage = this.paginator.perPage;
     * ```
     *
     * @memberof IgxPaginatorComponent
     */
    get perPage() {
        return this._perPage;
    }
    set perPage(value) {
        this._perPage = Number(value);
        this.perPageChange.emit(this._perPage);
        this._selectOptions = this.sortUniqueOptions(this.defaultSelectValues, this._perPage);
        this.totalPages = Math.ceil(this.totalRecords / this._perPage);
        if (this.totalPages !== 0 && this.page >= this.totalPages) {
            this.page = this.totalPages - 1;
        }
    }
    /**
     * An @Input property that sets the total records.
     * ```typescript
     * let totalRecords = this.paginator.totalRecords;
     * ```
     *
     * @memberof IgxPaginatorComponent
     */
    get totalRecords() {
        return this._totalRecords;
    }
    set totalRecords(value) {
        this._totalRecords = value;
        this.totalPages = Math.ceil(this.totalRecords / this.perPage);
    }
    /**
     * An @Input property that sets custom options in the select of the paginator
     * ```typescript
     * let options = this.paginator.selectOptions;
     * ```
     *
     * @memberof IgxPaginatorComponent
     */
    get selectOptions() {
        return this._selectOptions;
    }
    set selectOptions(value) {
        this._selectOptions = this.sortUniqueOptions(value, this._perPage);
        this.defaultSelectValues = [...value];
    }
    /**
     * An @Input property that sets custom OverlaySettings.
     * ```html
     * <igx-paginator [overlaySettings] = "customOverlaySettings"></igx-paginator>
     * ```
     */
    get overlaySettings() {
        return this._overlaySettings;
    }
    set overlaySettings(value) {
        this._overlaySettings = Object.assign({}, this._overlaySettings, value);
    }
    /**
     * An accessor that sets the resource strings.
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /**
     * Returns if the current page is the last page.
     * ```typescript
     * const lastPage = this.paginator.isLastPage;
     * ```
     */
    get isLastPage() {
        return this.page + 1 >= this.totalPages;
    }
    /**
     * Returns if the current page is the first page.
     * ```typescript
     * const lastPage = this.paginator.isFirstPage;
     * ```
     */
    get isFirstPage() {
        return this.page === 0;
    }
    /**
     * Returns if the first pager buttons should be disabled
     */
    get isFirstPageDisabled() {
        return this.isFirstPage || !this.pagerEnabled;
    }
    /**
     * Returns if the last pager buttons should be disabled
     */
    get isLastPageDisabled() {
        return this.isLastPage || !this.pagerEnabled;
    }
    /**
     * Sets DisplayDensity for the <select> inside the paginator
     *
     * @hidden
     */
    paginatorSelectDisplayDensity() {
        if (this.displayDensity === DisplayDensity.comfortable) {
            return DisplayDensity.cosy;
        }
        return DisplayDensity.compact;
    }
    /**
     * Goes to the next page of the `IgxPaginatorComponent`, if the paginator is not already at the last page.
     * ```typescript
     * this.paginator.nextPage();
     * ```
     *
     * @memberof IgxPaginatorComponent
     */
    nextPage() {
        if (!this.isLastPage) {
            this.page += 1;
        }
    }
    /**
     * Goes to the previous page of the `IgxPaginatorComponent`, if the paginator is not already at the first page.
     * ```typescript
     * this.paginator.previousPage();
     * ```
     *
     * @memberof IgxPaginatorComponent
     */
    previousPage() {
        if (!this.isFirstPage) {
            this.page -= 1;
        }
    }
    /**
     * Goes to the desired page index.
     * ```typescript
     * this.paginator.paginate(1);
     * ```
     *
     * @param val
     * @memberof IgxPaginatorComponent
     */
    paginate(val) {
        if (val < 0 || val > this.totalPages - 1) {
            return;
        }
        this.page = val;
    }
    sortUniqueOptions(values, newOption) {
        return Array.from(new Set([...values, newOption])).sort((a, b) => a - b);
    }
}
IgxPaginatorComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-paginator',
                template: "<div class=\"igx-paginator__select\" [hidden]=\"dropdownHidden\">\n    <label class=\"igx-paginator__label\">{{ resourceStrings.igx_paginator_label }}</label>\n    <div class=\"igx-paginator__select-input\">\n        <igx-select [overlaySettings]=\"overlaySettings\" [(ngModel)]=\"perPage\" [displayDensity]=\"paginatorSelectDisplayDensity()\" type=\"border\"\n            [disabled]=\"!dropdownEnabled\">\n            <label igxLabel [hidden]=\"true\">{{ resourceStrings.igx_paginator_label }}</label>\n            <igx-select-item [value]=\"val\" *ngFor=\"let val of selectOptions\">\n                {{val}}\n            </igx-select-item>\n        </igx-select>\n    </div>\n</div>\n<div class=\"igx-paginator__pager\" [hidden]=\"pagerHidden\" role=\"navigation\">\n    <button [title]=\"resourceStrings.igx_paginator_first_page_button_text\" [disabled]=\"isFirstPageDisabled\" [attr.aria-disabled]=\"isFirstPageDisabled\" (click)=\"paginate(0)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon>first_page</igx-icon>\n    </button>\n    <button [title]=\"resourceStrings.igx_paginator_previous_page_button_text\" [disabled]=\"isFirstPageDisabled\" [attr.aria-disabled]=\"isFirstPageDisabled\" (click)=\"previousPage()\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon>chevron_left</igx-icon>\n    </button>\n    <div class='igx-paginator__pager-text' aria-current=\"page\">\n        <span>{{ page + 1 }}</span>\n        <span>&nbsp;{{ resourceStrings.igx_paginator_pager_text }}&nbsp;</span>\n        <span>{{ totalPages }}</span>\n    </div>\n    <button [title]=\"resourceStrings.igx_paginator_next_page_button_text\" [disabled]=\"isLastPageDisabled\" [attr.aria-disabled]=\"isLastPageDisabled\" (click)=\"nextPage()\" igxRipple igxRippleCentered=\"true\" igxButton=\"icon\">\n        <igx-icon>chevron_right</igx-icon>\n    </button>\n    <button [title]=\"resourceStrings.igx_paginator_last_page_button_text\" [disabled]=\"isLastPageDisabled\" [attr.aria-disabled]=\"isLastPageDisabled\" (click)=\"paginate(totalPages - 1)\" igxButton=\"icon\" igxRipple\n        igxRippleCentered=\"true\">\n        <igx-icon>last_page</igx-icon>\n    </button>\n</div>\n"
            },] }
];
IgxPaginatorComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxPaginatorComponent.propDecorators = {
    pagerEnabled: [{ type: Input }],
    pagerHidden: [{ type: Input }],
    dropdownEnabled: [{ type: Input }],
    dropdownHidden: [{ type: Input }],
    selectLabel: [{ type: Input }],
    prepositionPage: [{ type: Input }],
    perPageChange: [{ type: Output }],
    pageChange: [{ type: Output }],
    classCosy: [{ type: HostBinding, args: ['class.igx-paginator--cosy',] }],
    classCompact: [{ type: HostBinding, args: ['class.igx-paginator--compact',] }],
    classComfortable: [{ type: HostBinding, args: ['class.igx-paginator',] }],
    page: [{ type: Input }],
    perPage: [{ type: Input }],
    totalRecords: [{ type: Input }],
    selectOptions: [{ type: Input }],
    overlaySettings: [{ type: Input }],
    resourceStrings: [{ type: Input }]
};
__decorate([
    DeprecateProperty(`'selectLabel' property is deprecated. Use 'resourceStrings' instead.`)
], IgxPaginatorComponent.prototype, "selectLabel", void 0);
__decorate([
    DeprecateProperty(`'prepositionPage' property is deprecated. Use 'resourceStrings' instead.`)
], IgxPaginatorComponent.prototype, "prepositionPage", void 0);
class IgxPaginatorModule {
}
IgxPaginatorModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxPaginatorComponent],
                exports: [IgxPaginatorComponent],
                imports: [CommonModule, IgxSelectModule, FormsModule, IgxIconModule, IgxButtonModule, IgxRippleModule, IgxInputGroupModule]
            },] }
];

let NEXT_ID$k = 0;
/**
 * Providing reference to `IgxColumnActionsComponent`:
 * ```typescript
 *  @ViewChild('columnActions', { read: IgxColumnActionsComponent })
 *  public columnActions: IgxColumnActionsComponent;
 */
class IgxColumnActionsComponent {
    constructor(differs) {
        this.differs = differs;
        /**
         * Gets/sets the indentation of columns in the column list based on their hierarchy level.
         *
         * @example
         * ```
         * <igx-column-actions [indentation]="15"></igx-column-actions>
         * ```
         */
        this.indentation = 30;
        /**
         * Sets/Gets the css class selector.
         * By default the value of the `class` attribute is `"igx-column-actions"`.
         * ```typescript
         * let cssCLass =  this.columnHidingUI.cssClass;
         * ```
         * ```typescript
         * this.columnHidingUI.cssClass = 'column-chooser';
         * ```
         */
        this.cssClass = 'igx-column-actions';
        /**
         * Gets/sets the max height of the columns area.
         *
         * @remarks
         * The default max height is 100%.
         * @example
         * ```html
         * <igx-column-actions [columnsAreaMaxHeight]="200px"></igx-column-actions>
         * ```
         */
        this.columnsAreaMaxHeight = '100%';
        /**
         * Shows/hides the columns filtering input from the UI.
         *
         * @example
         * ```html
         *  <igx-column-actions [hideFilter]="true"></igx-column-actions>
         * ```
         */
        this.hideFilter = false;
        /**
         * Gets/sets the title of the column actions component.
         *
         * @example
         * ```html
         * <igx-column-actions [title]="'Pin Columns'"></igx-column-actions>
         * ```
         */
        this.title = '';
        /**
         * An event that is emitted after a column's checked state is changed.
         * Provides references to the `column` and the `checked` properties as event arguments.
         * ```html
         *  <igx-column-actions (onColumnToggled)="onColumnToggled($event)"></igx-column-actions>
         * ```
         */
        this.onColumnToggled = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.actionableColumns = [];
        /**
         * @hidden @internal
         */
        this.filteredColumns = [];
        /**
         * @hidden @internal
         */
        this.pipeTrigger = 0;
        this._differ = null;
        /**
         * @hidden @internal
         */
        this._filterColumnsPrompt = '';
        /**
         * @hidden @internal
         */
        this._filterCriteria = '';
        /**
         * @hidden @internal
         */
        this._columnDisplayOrder = ColumnDisplayOrder.DisplayOrder;
        /**
         * @hidden @internal
         */
        this._id = `igx-column-actions-${NEXT_ID$k++}`;
        /**
         * @hidden @internal
         */
        this.trackChanges = (index, col) => col.field + '_' + this.actionsDirective.actionEnabledColumnsFilter(col, index, []);
        this._differ = this.differs.find([]).create(this.trackChanges);
    }
    /**
     * Gets the grid columns to provide an action for.
     *
     * @deprecated
     * @example
     * ```typescript
     * let gridColumns = this.columnActions.columns;
     * ```
     */
    get columns() {
        var _a;
        return (_a = this.grid) === null || _a === void 0 ? void 0 : _a.columns;
    }
    set columns(value) {
        if (value && value.length > 0) {
            this.grid = value[0].grid;
        }
    }
    /**
     * Gets the prompt that is displayed in the filter input.
     *
     * @example
     * ```typescript
     * let filterColumnsPrompt = this.columnActions.filterColumnsPrompt;
     * ```
     */
    get filterColumnsPrompt() {
        return this._filterColumnsPrompt;
    }
    /**
     * Sets the prompt that is displayed in the filter input.
     *
     * @example
     * ```html
     * <igx-column-actions [filterColumnsPrompt]="'Type here to search'"></igx-column-actions>
     * ```
     */
    set filterColumnsPrompt(value) {
        this._filterColumnsPrompt = value || '';
    }
    /**
     * Gets the value which filters the columns list.
     *
     * @example
     * ```typescript
     * let filterCriteria =  this.columnActions.filterCriteria;
     * ```
     */
    get filterCriteria() {
        return this._filterCriteria;
    }
    /**
     * Sets the value which filters the columns list.
     *
     * @example
     * ```html
     *  <igx-column-actions [filterCriteria]="'ID'"></igx-column-actions>
     * ```
     */
    set filterCriteria(value) {
        value = value || '';
        if (value !== this._filterCriteria) {
            this._filterCriteria = value;
            this.pipeTrigger++;
        }
    }
    /**
     * Gets the display order of the columns.
     *
     * @example
     * ```typescript
     * let columnDisplayOrder = this.columnActions.columnDisplayOrder;
     * ```
     */
    get columnDisplayOrder() {
        return this._columnDisplayOrder;
    }
    /**
     * Sets the display order of the columns.
     *
     * @example
     * ```typescript
     * this.columnActions.columnDisplayOrder = ColumnDisplayOrder.Alphabetical;
     * ```
     */
    set columnDisplayOrder(value) {
        if (value && value !== this._columnDisplayOrder) {
            this._columnDisplayOrder = value;
            this.pipeTrigger++;
        }
    }
    /**
     * Gets the text of the button that unchecks all columns.
     *
     * @remarks
     * If unset it is obtained from the IgxColumnActionsBased derived directive applied.
     * @example
     * ```typescript
     * let uncheckAllText = this.columnActions.uncheckAllText;
     * ```
     */
    get uncheckAllText() {
        return this._uncheckAllText || this.actionsDirective.uncheckAllLabel;
    }
    /**
     * Sets the text of the button that unchecks all columns.
     *
     * @example
     * ```html
     * <igx-column-actions [uncheckAllText]="'Show All'"></igx-column-actions>
     * ```
     */
    set uncheckAllText(value) {
        this._uncheckAllText = value;
    }
    /**
     * Gets the text of the button that checks all columns.
     *
     * @remarks
     * If unset it is obtained from the IgxColumnActionsBased derived directive applied.
     * @example
     * ```typescript
     * let uncheckAllText = this.columnActions.uncheckAllText;
     * ```
     */
    get checkAllText() {
        return this._checkAllText || this.actionsDirective.checkAllLabel;
    }
    /**
     * Sets the text of the button that checks all columns.
     *
     * @remarks
     * If unset it is obtained from the IgxColumnActionsBased derived directive applied.
     * @example
     * ```html
     * <igx-column-actions [checkAllText]="'Hide All'"></igx-column-actions>
     * ```
     */
    set checkAllText(value) {
        this._checkAllText = value;
    }
    /**
     * @hidden @internal
     */
    get checkAllDisabled() {
        return this.actionsDirective.allUnchecked;
    }
    /**
     * @hidden @internal
     */
    get uncheckAllDisabled() {
        return this.actionsDirective.allChecked;
    }
    /**
     * Gets/Sets the value of the `id` attribute.
     *
     * @remarks
     * If not provided it will be automatically generated.
     * @example
     * ```html
     * <igx-column-actions [id]="'igx-actions-1'"></igx-column-actions>
     * ```
     */
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    /**
     * @hidden @internal
     */
    get titleID() {
        return this.id + '_title';
    }
    /**
     * @hidden @internal
     */
    ngDoCheck() {
        var _a;
        if (this._differ) {
            const changes = this._differ.diff((_a = this.grid) === null || _a === void 0 ? void 0 : _a.columns);
            if (changes) {
                this.pipeTrigger++;
            }
        }
    }
    /**
     * Unchecks all columns and performs the appropriate action.
     *
     * @example
     * ```typescript
     * this.columnActions.uncheckAllColumns();
     * ```
     */
    uncheckAllColumns() {
        this.actionsDirective.uncheckAll();
    }
    /**
     * Checks all columns and performs the appropriate action.
     *
     * @example
     * ```typescript
     * this.columnActions.checkAllColumns();
     * ```
     */
    checkAllColumns() {
        this.actionsDirective.checkAll();
    }
    /**
     * @hidden @internal
     */
    toggleColumn(column) {
        this.actionsDirective.toggleColumn(column);
        this.onColumnToggled.emit({ column, checked: this.actionsDirective.columnChecked(column) });
    }
}
IgxColumnActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-column-actions',
                template: "<div class=\"igx-column-actions__header\">\n    <h4 [attr.id]='titleID' class=\"igx-column-actions__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-actions__header-input\" *ngIf=\"!hideFilter\">\n        <input igxInput\n            type=\"text\"\n            [attr.aria-describedby]='titleID'\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-actions__columns\" tabindex=\"0\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox\n        *ngFor=\"let column of grid?.columns\n            | columnActionEnabled:actionsDirective.actionEnabledColumnsFilter:pipeTrigger\n            | filterActionColumns:filterCriteria:pipeTrigger\n            | sortActionColumns:columnDisplayOrder:pipeTrigger;\"\n        class=\"igx-column-actions__columns-item\"\n        [readonly]=\"true\"\n        (click)=\"toggleColumn(column)\"\n        [checked]=\"actionsDirective.columnChecked(column)\"\n        [style.margin-left.px]=\"column.level * indentation\">\n        {{ column.header || column.field }}\n    </igx-checkbox>\n</div>\n\n<div class=\"igx-column-actions__buttons\">\n    <button igxButton igxRipple (click)=\"uncheckAllColumns()\" [disabled]=\"uncheckAllDisabled\">{{ uncheckAllText }}</button>\n    <button igxButton igxRipple (click)=\"checkAllColumns()\" [disabled]=\"checkAllDisabled\">{{ checkAllText }}</button>\n</div>\n"
            },] }
];
IgxColumnActionsComponent.ctorParameters = () => [
    { type: IterableDiffers }
];
IgxColumnActionsComponent.propDecorators = {
    grid: [{ type: Input }],
    indentation: [{ type: Input }],
    cssClass: [{ type: HostBinding, args: ['attr.class',] }],
    columnsAreaMaxHeight: [{ type: Input }],
    hideFilter: [{ type: Input }],
    columnItems: [{ type: ViewChildren, args: [IgxCheckboxComponent,] }],
    title: [{ type: Input }],
    onColumnToggled: [{ type: Output }],
    columns: [{ type: Input }],
    filterColumnsPrompt: [{ type: Input }],
    filterCriteria: [{ type: Input }],
    columnDisplayOrder: [{ type: Input }],
    uncheckAllText: [{ type: Input }],
    checkAllText: [{ type: Input }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }]
};
__decorate([
    DeprecateProperty(`Deprecated. Use 'grid' input instead.`)
], IgxColumnActionsComponent.prototype, "columns", null);

/**
 * @hidden
 * @internal
 */
class IgxGridCellStyleClassesPipe {
    transform(cssClasses, _, data, field, index, __) {
        if (!cssClasses) {
            return '';
        }
        const result = [];
        for (const cssClass of Object.keys(cssClasses)) {
            const callbackOrValue = cssClasses[cssClass];
            const apply = typeof callbackOrValue === 'function' ?
                callbackOrValue(data, field, resolveNestedPath(data, field), index) : callbackOrValue;
            if (apply) {
                result.push(cssClass);
            }
        }
        return result.join(' ');
    }
}
IgxGridCellStyleClassesPipe.decorators = [
    { type: Pipe, args: [{
                name: 'igxCellStyleClasses'
            },] }
];
/**
 * @hidden
 * @internal
 */
class IgxGridCellStylesPipe {
    transform(styles, _, data, field, index, __) {
        const css = {};
        if (!styles) {
            return css;
        }
        for (const prop of Object.keys(styles)) {
            const res = styles[prop];
            css[prop] = typeof res === 'function' ? res(data, field, resolveNestedPath(data, field), index) : res;
        }
        return css;
    }
}
IgxGridCellStylesPipe.decorators = [
    { type: Pipe, args: [{
                name: 'igxCellStyles'
            },] }
];
/**
 * @hidden
 * @internal
 */
class IgxGridNotGroupedPipe {
    transform(value) {
        return value.filter(item => !item.columnGroup);
    }
}
IgxGridNotGroupedPipe.decorators = [
    { type: Pipe, args: [{
                name: 'igxNotGrouped'
            },] }
];
/**
 * @hidden
 * @internal
 */
class IgxGridTopLevelColumns {
    transform(value) {
        return value.filter(item => item.level === 0);
    }
}
IgxGridTopLevelColumns.decorators = [
    { type: Pipe, args: [{
                name: 'igxTopLevel'
            },] }
];
/**
 * @hidden
 * @internal
 */
class IgxGridFilterConditionPipe {
    transform(value) {
        return value.split(/(?=[A-Z])/).join(' ');
    }
}
IgxGridFilterConditionPipe.decorators = [
    { type: Pipe, args: [{
                name: 'filterCondition',
                pure: true
            },] }
];
/**
 * @hidden
 * @internal
 */
class IgxGridTransactionPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, id, pipeTrigger) {
        const grid = this.gridAPI.grid;
        if (grid.transactions.enabled) {
            const result = DataUtil.mergeTransactions(cloneArray(collection), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
            return result;
        }
        return collection;
    }
}
IgxGridTransactionPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridTransaction',
                pure: true
            },] }
];
IgxGridTransactionPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 * @internal
 */
class IgxGridPaginatorOptionsPipe {
    transform(values) {
        return Array.from(new Set([...values])).sort((a, b) => a - b);
    }
}
IgxGridPaginatorOptionsPipe.decorators = [
    { type: Pipe, args: [{
                name: 'paginatorOptions',
                pure: true,
            },] }
];
/**
 * @hidden
 * @internal
 */
class IgxHasVisibleColumnsPipe {
    transform(values, hasVisibleColumns) {
        if (!(values && values.length)) {
            return values;
        }
        return hasVisibleColumns ? values : [];
    }
}
IgxHasVisibleColumnsPipe.decorators = [
    { type: Pipe, args: [{
                name: 'visibleColumns',
                pure: true
            },] }
];
/**
 * @hidden
 */
class IgxGridRowPinningPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, id, isPinned = false, pipeTrigger) {
        const grid = this.gridAPI.grid;
        if (grid.hasPinnedRecords && isPinned) {
            const result = collection.filter(rec => grid.isRecordPinned(rec));
            result.sort((rec1, rec2) => grid.getInitialPinnedIndex(rec1) - grid.getInitialPinnedIndex(rec2));
            return result;
        }
        grid.unpinnedRecords = collection;
        if (!grid.hasPinnedRecords) {
            grid.pinnedRecords = [];
            return isPinned ? [] : collection;
        }
        return collection.map((rec) => grid.isRecordPinned(rec) ? { recordRef: rec, ghostRecord: true } : rec);
    }
}
IgxGridRowPinningPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridRowPinning',
                pure: true
            },] }
];
IgxGridRowPinningPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
class IgxColumnActionEnabledPipe {
    constructor(columnActions) {
        this.columnActions = columnActions;
    }
    transform(collection, actionFilter, pipeTrigger) {
        if (!collection) {
            return collection;
        }
        let copy = collection.slice(0);
        if (copy.length && copy[0].grid.hasColumnLayouts) {
            copy = copy.filter(c => c.columnLayout);
        }
        if (actionFilter) {
            copy = copy.filter(actionFilter);
        }
        // Preserve the actionable collection for use in the component
        this.columnActions.actionableColumns = copy;
        return copy;
    }
}
IgxColumnActionEnabledPipe.decorators = [
    { type: Pipe, args: [{
                name: 'columnActionEnabled',
                pure: true
            },] }
];
IgxColumnActionEnabledPipe.ctorParameters = () => [
    { type: IgxColumnActionsComponent, decorators: [{ type: Inject, args: [IgxColumnActionsComponent,] }] }
];
class IgxFilterActionColumnsPipe {
    constructor(columnActions) {
        this.columnActions = columnActions;
    }
    transform(collection, filterCriteria, pipeTrigger) {
        if (!collection) {
            return collection;
        }
        let copy = collection.slice(0);
        if (filterCriteria && filterCriteria.length > 0) {
            const filterFunc = (c) => {
                var _a, _b;
                const filterText = c.header || c.field;
                if (!filterText) {
                    return false;
                }
                return filterText.toLocaleLowerCase().indexOf(filterCriteria.toLocaleLowerCase()) >= 0 ||
                    ((_b = (_a = c.children) === null || _a === void 0 ? void 0 : _a.some(filterFunc)) !== null && _b !== void 0 ? _b : false);
            };
            copy = collection.filter(filterFunc);
        }
        // Preserve the filtered collection for use in the component
        this.columnActions.filteredColumns = copy;
        return copy;
    }
}
IgxFilterActionColumnsPipe.decorators = [
    { type: Pipe, args: [{
                name: 'filterActionColumns',
                pure: true
            },] }
];
IgxFilterActionColumnsPipe.ctorParameters = () => [
    { type: IgxColumnActionsComponent, decorators: [{ type: Inject, args: [IgxColumnActionsComponent,] }] }
];
class IgxSortActionColumnsPipe {
    transform(collection, displayOrder, pipeTrigger) {
        if (displayOrder === ColumnDisplayOrder.Alphabetical) {
            return collection.sort((a, b) => (a.header || a.field).localeCompare(b.header || b.field));
        }
        return collection;
    }
}
IgxSortActionColumnsPipe.decorators = [
    { type: Pipe, args: [{
                name: 'sortActionColumns',
                pure: true
            },] }
];
class IgxGridDataMapperPipe {
    transform(data, field, _, val, isNestedPath) {
        return isNestedPath ? resolveNestedPath(data, field) : val;
    }
}
IgxGridDataMapperPipe.decorators = [
    { type: Pipe, args: [{ name: 'dataMapper' },] }
];
class IgxStringReplacePipe {
    transform(value, search, replacement) {
        return value.replace(search, replacement);
    }
}
IgxStringReplacePipe.decorators = [
    { type: Pipe, args: [{ name: 'igxStringReplace' },] }
];
class IgxGridTransactionStatePipe {
    transform(row_id, field, rowEditable, transactions, _, __, ___) {
        var _a;
        if (rowEditable) {
            const rowCurrentState = transactions.getAggregatedValue(row_id, false);
            if (rowCurrentState) {
                const value = resolveNestedPath(rowCurrentState, field);
                return value !== undefined && value !== null;
            }
        }
        else {
            const transaction = transactions.getState(row_id);
            const value = resolveNestedPath((_a = transaction === null || transaction === void 0 ? void 0 : transaction.value) !== null && _a !== void 0 ? _a : {}, field);
            return transaction && transaction.value && (value || value === 0 || value === false);
        }
    }
}
IgxGridTransactionStatePipe.decorators = [
    { type: Pipe, args: [{ name: 'transactionState' },] }
];
class IgxColumnFormatterPipe {
    transform(value, formatter) {
        return formatter(value);
    }
}
IgxColumnFormatterPipe.decorators = [
    { type: Pipe, args: [{ name: 'columnFormatter' },] }
];
class IgxGridAddRowPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, isPinned = false, pipeTrigger) {
        const grid = this.gridAPI.grid;
        if (!grid.rowEditable || !grid.addRowParent || grid.cancelAddMode || isPinned !== grid.addRowParent.isPinned) {
            return collection;
        }
        const copy = collection.slice(0);
        const parentIndex = grid.addRowParent.index;
        const row = grid.getEmptyRecordObjectFor(collection[parentIndex]);
        const rec = {
            recordRef: row,
            addRow: true
        };
        copy.splice(parentIndex + 1, 0, rec);
        if (isPinned) {
            grid.pinnedRecords = copy;
        }
        else {
            grid.unpinnedRecords = copy;
        }
        return copy;
    }
}
IgxGridAddRowPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridAddRow',
                pure: true
            },] }
];
IgxGridAddRowPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

class IgxGridPipesModule {
}
IgxGridPipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxGridFilterConditionPipe,
                    IgxGridTransactionPipe,
                    IgxGridNotGroupedPipe,
                    IgxGridTopLevelColumns,
                    IgxGridCellStylesPipe,
                    IgxGridCellStyleClassesPipe,
                    IgxGridPaginatorOptionsPipe,
                    IgxHasVisibleColumnsPipe,
                    IgxGridRowPinningPipe,
                    IgxColumnActionEnabledPipe,
                    IgxFilterActionColumnsPipe,
                    IgxSortActionColumnsPipe,
                    IgxGridDataMapperPipe,
                    IgxStringReplacePipe,
                    IgxGridTransactionStatePipe,
                    IgxGridAddRowPipe,
                    IgxColumnFormatterPipe
                ],
                exports: [
                    IgxGridFilterConditionPipe,
                    IgxGridTransactionPipe,
                    IgxGridNotGroupedPipe,
                    IgxGridTopLevelColumns,
                    IgxGridCellStylesPipe,
                    IgxGridCellStyleClassesPipe,
                    IgxGridPaginatorOptionsPipe,
                    IgxHasVisibleColumnsPipe,
                    IgxGridRowPinningPipe,
                    IgxColumnActionEnabledPipe,
                    IgxFilterActionColumnsPipe,
                    IgxSortActionColumnsPipe,
                    IgxGridDataMapperPipe,
                    IgxStringReplacePipe,
                    IgxGridTransactionStatePipe,
                    IgxGridAddRowPipe,
                    IgxColumnFormatterPipe
                ],
                imports: [
                    CommonModule
                ]
            },] }
];

class IgxProcessBarTextTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxProcessBarTextTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxProcessBarText]'
            },] }
];
IgxProcessBarTextTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxProgressBarGradientDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxProgressBarGradientDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxProgressBarGradient]'
            },] }
];
IgxProgressBarGradientDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * @hidden
 */
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function DIR_DOCUMENT_FACTORY() {
    return inject(DOCUMENT);
}
/**
 * Injection token is used to inject the document into Directionality
 * which factory could be faked for testing purposes.
 *
 * We can't provide and mock the DOCUMENT token from platform-browser because configureTestingModule
 * allows override of the default providers, directive, pipes, modules of the test injector
 * which causes errors.
 *
 * @hidden
 */
const DIR_DOCUMENT = new InjectionToken('dir-doc', {
    providedIn: 'root',
    factory: DIR_DOCUMENT_FACTORY
});
/**
 * @hidden
 *
 * Bidirectional service that extracts the value of the direction attribute on the body or html elements.
 *
 * The dir attribute over the body element takes precedence.
 */
class IgxDirectionality {
    constructor(document) {
        this._document = document;
        const bodyDir = this._document.body ? this._document.body.dir : null;
        const htmlDir = this._document.documentElement ? this._document.documentElement.dir : null;
        const extractedDir = bodyDir || htmlDir;
        this._dir = (extractedDir === 'ltr' || extractedDir === 'rtl') ? extractedDir : 'ltr';
    }
    get value() {
        return this._dir;
    }
    get document() {
        return this._document;
    }
    get rtl() {
        return this._dir === 'rtl';
    }
}
IgxDirectionality.ɵprov = ɵɵdefineInjectable({ factory: function IgxDirectionality_Factory() { return new IgxDirectionality(ɵɵinject(DIR_DOCUMENT)); }, token: IgxDirectionality, providedIn: "root" });
IgxDirectionality.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
IgxDirectionality.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DIR_DOCUMENT,] }] }
];

const ONE_PERCENT = 0.01;
const MIN_VALUE = 0;
const IgxTextAlign = mkenum({
    START: 'start',
    CENTER: 'center',
    END: 'end'
});
const IgxProgressType = mkenum({
    ERROR: 'error',
    INFO: 'info',
    WARNING: 'warning',
    SUCCESS: 'success'
});
/**
 * @hidden
 */
class BaseProgressDirective {
    constructor() {
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *     alert("Progress made!");
         * }
         *  //...
         * ```
         * ```html
         * <igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
         * <igx-linear-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-linear-bar>
         * ```
         */
        this.onProgressChanged = new EventEmitter();
        this._initValue = 0;
        this._contentInit = false;
        this._valueInPercent = MIN_VALUE;
        this._max = 100;
        this._value = MIN_VALUE;
        this._newVal = MIN_VALUE;
        this._animate = true;
        this.requestAnimationId = undefined;
    }
    /**
     * Returns the value which update the progress indicator of the `progress bar`.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public stepValue(event) {
     *     let step = this.progressBar.step;
     *     alert(step);
     * }
     * ```
     */
    get step() {
        if (this._step) {
            return this._step;
        }
        return this._max * ONE_PERCENT;
    }
    /**
     * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0" [step]="1"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0" [step]="1"></igx-circular-bar>
     * ```
     */
    set step(val) {
        this._step = Number(val);
    }
    /**
     * Animating the progress. By default it is set to true.
     * ```html
     * <igx-linear-bar [animate]="false" [max]="200" [value]="50"></igx-linear-bar>
     * <igx-circular-bar [animate]="false" [max]="200" [value]="50"></igx-circular-bar>
     * ```
     */
    set animate(animate) {
        this._animate = animate;
    }
    /**
     * Returns whether the `progress bar` has animation true/false.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public animationStatus(event) {
     *     let animationStatus = this.progressBar.animate;
     *     alert(animationStatus);
     * }
     * ```
     */
    get animate() {
        return this._animate;
    }
    /**
     * Set maximum value that can be passed. By default it is set to 100.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
     * ```
     */
    set max(maxNum) {
        this._max = maxNum;
    }
    /**
     * Returns the the maximum progress value of the `progress bar`.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public maxValue(event) {
     *     let max = this.progressBar.max;
     *     alert(max);
     * }
     * ```
     */
    get max() {
        return this._max;
    }
    /**
     * Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     *     public setValue(event){
     *     this.progressBar.valueInPercent = 56;
     * }
     * ```
     */
    set valueInPercent(value) {
        this._valueInPercent = value;
    }
    /**
     * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     * public valuePercent(event){
     *     let percentValue = this.progressBar.valueInPercent;
     *     alert(percentValue);
     * }
     * ```
     */
    get valueInPercent() {
        return this._valueInPercent;
    }
    triggerProgressTransition(oldVal, newVal) {
        if (oldVal === newVal) {
            return;
        }
        const changedValues = {
            currentValue: newVal,
            previousValue: oldVal
        };
        const stepDirection = this.directionFlow(oldVal, newVal);
        if (this._animate) {
            this.runAnimation(newVal, stepDirection);
        }
        else {
            this.updateProgressDirectly(newVal);
        }
        this.onProgressChanged.emit(changedValues);
    }
    /**
     * @hidden
     */
    runAnimation(val, step) {
        this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
    }
    /**
     * @hidden
     */
    updateProgressSmoothly(val, step) {
        this._value = valueInRange(this._value, this._max) + step;
        const passedValue = toPercent(val, this._max);
        const progressValue = toPercent(this._value, this._max);
        if (this.valueInPercent === passedValue) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else if (this.isInLimitRange(progressValue, passedValue, step)) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else {
            this.valueInPercent = progressValue;
            this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
        }
    }
    /**
     * @hidden
     */
    updateProgressDirectly(val) {
        this._value = valueInRange(val, this._max);
        this.valueInPercent = toPercent(this._value, this._max);
    }
    /**
     * @hidden
     */
    directionFlow(currentValue, prevValue) {
        return currentValue < prevValue ? this.step : -this.step;
    }
    /**
     * @hidden
     */
    isInLimitRange(val, comparator, step) {
        return this.isExceedingUpperLimit(val, comparator, step) || this.isExceedingLowerLimit(val, comparator, step);
    }
    /**
     * @hidden
     *
     *
     * @param val
     * @param comparator
     * @param step
     */
    isExceedingUpperLimit(val, comparator, step) {
        return val > comparator && step > 0;
    }
    /**
     * @hidden
     *
     * @param val
     * @param comparator
     * @param step
     */
    isExceedingLowerLimit(val, comparator, step) {
        return val < comparator && step < 0;
    }
    /**
     * @hidden
     * @param step
     */
    updateProgress(val) {
        this._value = valueInRange(val, this._max);
        this.valueInPercent = toPercent(this._value, this._max);
    }
}
BaseProgressDirective.decorators = [
    { type: Directive }
];
BaseProgressDirective.propDecorators = {
    onProgressChanged: [{ type: Output }],
    step: [{ type: Input }],
    animate: [{ type: Input }],
    max: [{ type: HostBinding, args: ['attr.aria-valuemax',] }, { type: Input }]
};
let NEXT_LINEAR_ID = 0;
let NEXT_CIRCULAR_ID = 0;
let NEXT_GRADIENT_ID = 0;
class IgxLinearProgressBarComponent extends BaseProgressDirective {
    constructor() {
        super();
        this.valueMin = 0;
        this.cssClass = 'igx-linear-bar';
        /**
         * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         * ```html
         * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.striped = false;
        /**
         * Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * An @Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
         * ```html
         * <igx-linear-bar role="progressbar"></igx-linear-bar>
         * ```
         */
        this.role = 'progressbar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.id = `igx-linear-bar-${NEXT_LINEAR_ID++}`;
        /**
         * Set the position that defines where the text is aligned.
         * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         * ```typescript
         * public positionCenter: IgxTextAlign;
         * public ngOnInit() {
         *     this.positionCenter = IgxTextAlign.CENTER;
         * }
         *  //...
         * ```
         *  ```html
         * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         * ```
         */
        this.textAlign = IgxTextAlign.START;
        /**
         * Set the text to be visible. By default it is set to true.
         * ```html
         *  <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         * ```html
         *  <igx-linear-bar type="error" [textTop]="true"></igx-linear-bar>
         * ```
         */
        this.textTop = false;
        /**
         * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="error"></igx-linear-bar>
         * ```
         */
        this.type = 'default';
    }
    /**
     * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public getValue(event) {
     *     let value = this.progressBar.value;
     *     alert(value);
     * }
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     */
    set value(val) {
        const valInRange = valueInRange(val, this.max);
        if (isNaN(valInRange) || this._value === val || this.indeterminate) {
            return;
        }
        if (this._contentInit) {
            this.triggerProgressTransition(this._value, valInRange);
        }
        else {
            this._initValue = valInRange;
        }
    }
    /**
     * @hidden
     */
    get error() {
        return this.type === IgxProgressType.ERROR;
    }
    /**
     * @hidden
     */
    get info() {
        return this.type === IgxProgressType.INFO;
    }
    /**
     * @hidden
     */
    get warning() {
        return this.type === IgxProgressType.WARNING;
    }
    /**
     * @hidden
     */
    get success() {
        return this.type === IgxProgressType.SUCCESS;
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
}
IgxLinearProgressBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-linear-bar',
                template: "<div class=\"igx-linear-bar__base\">\n    <div class=\"igx-linear-bar__indicator\" [style.width.%]=\"valueInPercent\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n"
            },] }
];
IgxLinearProgressBarComponent.ctorParameters = () => [];
IgxLinearProgressBarComponent.propDecorators = {
    valueMin: [{ type: HostBinding, args: ['attr.aria-valuemin',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-linear-bar',] }],
    striped: [{ type: HostBinding, args: ['class.igx-linear-bar--striped',] }, { type: Input }],
    indeterminate: [{ type: HostBinding, args: ['class.igx-linear-bar--indeterminate',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    textAlign: [{ type: Input }],
    textVisibility: [{ type: Input }],
    textTop: [{ type: Input }],
    text: [{ type: Input }],
    type: [{ type: Input }],
    value: [{ type: HostBinding, args: ['attr.aria-valuenow',] }, { type: Input }],
    error: [{ type: HostBinding, args: ['class.igx-linear-bar--danger',] }],
    info: [{ type: HostBinding, args: ['class.igx-linear-bar--info',] }],
    warning: [{ type: HostBinding, args: ['class.igx-linear-bar--warning',] }],
    success: [{ type: HostBinding, args: ['class.igx-linear-bar--success',] }]
};
class IgxCircularProgressBarComponent extends BaseProgressDirective {
    constructor(renderer, _directionality) {
        super();
        this.renderer = renderer;
        this._directionality = _directionality;
        /** @hidden */
        this.cssClass = 'igx-circular-bar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         * ```
         */
        this.id = `igx-circular-bar-${NEXT_CIRCULAR_ID++}`;
        /**
         * An @Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
         * ```html
         * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * Sets the text visibility. By default it is set to true.
         * ```html
         * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * @hidden
         */
        this.gradientId = `igx-circular-gradient-${NEXT_GRADIENT_ID++}`;
        this._circleRadius = 46;
        this._circumference = 2 * Math.PI * this._circleRadius;
        this.STROKE_OPACITY_DVIDER = 100;
        this.STROKE_OPACITY_ADDITION = .2;
    }
    /**
     * @hidden
     */
    get context() {
        return {
            $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
        };
    }
    /**
     * Returns value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public getValue(event) {
     *     let value = this.progressBar.value;
     *     alert(value);
     * }
     * ```
     * ```html
     * <button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```html
     * <igx-circular-bar [value]="50"></igx-circular-bar>
     * ```
     */
    set value(val) {
        const valInRange = valueInRange(val, this.max);
        if (isNaN(valInRange) || this._value === val || this.indeterminate) {
            return;
        }
        if (this._contentInit) {
            this.triggerProgressTransition(this._value, valInRange);
        }
        else {
            this._initValue = valInRange;
        }
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
    ngAfterViewInit() {
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke', `url(#${this.gradientId})`);
    }
    /**
     * @hidden
     */
    updateProgressSmoothly(val, step) {
        // Set frames for the animation
        const FRAMES = [{
                strokeDashoffset: this.getProgress(this._value),
                strokeOpacity: (this._value / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }, {
                strokeDashoffset: this.getProgress(this.valueInPercent),
                strokeOpacity: (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }];
        this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards'
        });
        super.updateProgressSmoothly(val, step);
    }
    /**
     * @hidden
     */
    get textContent() {
        return this.text;
    }
    /**
     * @hidden
     */
    updateProgressDirectly(val) {
        super.updateProgressDirectly(val);
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-dashoffset', this.getProgress(this.valueInPercent));
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-opacity', (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION);
    }
    getProgress(percentage) {
        return this._directionality.rtl ?
            this._circumference + (percentage * this._circumference / 100) :
            this._circumference - (percentage * this._circumference / 100);
    }
}
IgxCircularProgressBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-circular-bar',
                template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:text *ngIf=\"textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n        </ng-container>\n    </svg:text>\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultTextTemplate>\n        <svg:tspan class=\"igx-circular-bar__text\">\n            {{textContent ? textContent: valueInPercent + '%'}}\n        </svg:tspan>\n    </ng-template>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n"
            },] }
];
IgxCircularProgressBarComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: IgxDirectionality }
];
IgxCircularProgressBarComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-circular-bar',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    indeterminate: [{ type: HostBinding, args: ['class.igx-circular-bar--indeterminate',] }, { type: Input }],
    textVisibility: [{ type: Input }],
    text: [{ type: Input }],
    textTemplate: [{ type: ContentChild, args: [IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective },] }],
    gradientTemplate: [{ type: ContentChild, args: [IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective },] }],
    _svgCircle: [{ type: ViewChild, args: ['circle', { static: true },] }],
    value: [{ type: Input }]
};
const valueInRange = (value, max, min = 0) => Math.max(Math.min(value, max), min);
const toPercent = (value, max) => Math.floor(100 * value / max);
/**
 * @hidden
 */
class IgxProgressBarModule {
}
IgxProgressBarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxLinearProgressBarComponent,
                    IgxCircularProgressBarComponent,
                    IgxProcessBarTextTemplateDirective,
                    IgxProgressBarGradientDirective,
                ],
                exports: [
                    IgxLinearProgressBarComponent,
                    IgxCircularProgressBarComponent,
                    IgxProcessBarTextTemplateDirective,
                    IgxProgressBarGradientDirective,
                ],
                imports: [CommonModule]
            },] }
];

/**
 * @hidden
 */
class IgxGridExcelStyleFilteringModule {
}
IgxGridExcelStyleFilteringModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxGridExcelStyleFilteringComponent,
                    IgxExcelStyleHeaderComponent,
                    IgxExcelStyleSortingComponent,
                    IgxExcelStylePinningComponent,
                    IgxExcelStyleHidingComponent,
                    IgxExcelStyleSelectingComponent,
                    IgxExcelStyleClearFiltersComponent,
                    IgxExcelStyleConditionalFilterComponent,
                    IgxExcelStyleMovingComponent,
                    IgxExcelStyleSearchComponent,
                    IgxExcelStyleCustomDialogComponent,
                    IgxExcelStyleDefaultExpressionComponent,
                    IgxExcelStyleDateExpressionComponent,
                    IgxExcelStyleColumnOperationsTemplateDirective,
                    IgxExcelStyleFilterOperationsTemplateDirective,
                    IgxExcelStyleLoadingValuesTemplateDirective
                ],
                exports: [
                    IgxGridExcelStyleFilteringComponent,
                    IgxExcelStyleColumnOperationsTemplateDirective,
                    IgxExcelStyleFilterOperationsTemplateDirective,
                    IgxExcelStyleLoadingValuesTemplateDirective,
                    IgxExcelStyleDateExpressionComponent,
                    IgxExcelStyleHeaderComponent,
                    IgxExcelStyleSortingComponent,
                    IgxExcelStylePinningComponent,
                    IgxExcelStyleHidingComponent,
                    IgxExcelStyleSelectingComponent,
                    IgxExcelStyleClearFiltersComponent,
                    IgxExcelStyleConditionalFilterComponent,
                    IgxExcelStyleMovingComponent,
                    IgxExcelStyleSearchComponent,
                    IgxExcelStyleHeaderComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    IgxGridPipesModule,
                    IgxButtonModule,
                    IgxButtonGroupModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxDropDownModule,
                    IgxForOfModule,
                    IgxCheckboxModule,
                    IgxFilterModule,
                    IgxToggleModule,
                    IgxListModule,
                    IgxProgressBarModule,
                    IgxSelectModule,
                ],
                entryComponents: [
                    IgxGridExcelStyleFilteringComponent
                ],
                providers: [
                    IgxSelectionAPIService
                ]
            },] }
];

class IgxGridSelectionModule {
}
IgxGridSelectionModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxRowSelectorDirective,
                    IgxGroupByRowSelectorDirective,
                    IgxHeadSelectorDirective,
                    IgxGridDragSelectDirective
                ],
                exports: [
                    IgxRowSelectorDirective,
                    IgxGroupByRowSelectorDirective,
                    IgxHeadSelectorDirective,
                    IgxGridDragSelectDirective
                ]
            },] }
];

/**
 * @hidden
 * @internal
 */
class IgxResizeHandleDirective {
    constructor(zone, element, colResizingService) {
        this.zone = zone;
        this.element = element;
        this.colResizingService = colResizingService;
        /**
         * @hidden
         */
        this._dblClick = false;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        this.DEBOUNCE_TIME = 200;
    }
    /**
     * @hidden
     */
    onMouseOver() {
        this.colResizingService.resizeCursor = 'col-resize';
    }
    /**
     * @hidden
     */
    onDoubleClick() {
        this._dblClick = true;
        this.colResizingService.column = this.column;
        this.colResizingService.autosizeColumnOnDblClick();
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        if (!this.column.columnGroup && this.column.resizable) {
            this.zone.runOutsideAngular(() => {
                fromEvent(this.element.nativeElement, 'mousedown').pipe(debounceTime(this.DEBOUNCE_TIME), takeUntil(this.destroy$)).subscribe((event) => {
                    if (this._dblClick) {
                        this._dblClick = false;
                        return;
                    }
                    if (event.button === 0) {
                        this._onResizeAreaMouseDown(event);
                        this.column.grid.resizeLine.resizer.onMousedown(event);
                    }
                });
            });
            fromEvent(this.element.nativeElement, 'mouseup').pipe(debounceTime(this.DEBOUNCE_TIME), takeUntil(this.destroy$)).subscribe(() => {
                this.colResizingService.isColumnResizing = false;
                this.colResizingService.showResizer = false;
                this.column.grid.cdr.detectChanges();
            });
        }
    }
    /**
     * @hidden
     */
    _onResizeAreaMouseDown(event) {
        this.colResizingService.column = this.column;
        this.colResizingService.isColumnResizing = true;
        this.colResizingService.startResizePos = event.clientX;
        this.colResizingService.showResizer = true;
        this.column.grid.cdr.detectChanges();
    }
}
IgxResizeHandleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxResizeHandle]'
            },] }
];
IgxResizeHandleDirective.ctorParameters = () => [
    { type: NgZone },
    { type: ElementRef },
    { type: IgxColumnResizingService }
];
IgxResizeHandleDirective.propDecorators = {
    column: [{ type: Input, args: ['igxResizeHandle',] }],
    onMouseOver: [{ type: HostListener, args: ['mouseover',] }],
    onDoubleClick: [{ type: HostListener, args: ['dblclick',] }]
};

class IgxGridResizingModule {
}
IgxGridResizingModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxGridColumnResizerComponent,
                    IgxResizeHandleDirective,
                    IgxColumnResizerDirective
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    IgxGridColumnResizerComponent,
                    IgxResizeHandleDirective,
                    IgxColumnResizerDirective
                ],
                providers: [
                    IgxColumnResizingService
                ]
            },] }
];

class IgxColumnMovingDropDirective extends IgxDropDirective {
    constructor(elementRef, renderer, zone, cms) {
        super(elementRef, renderer, zone);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        this.cms = cms;
        this._dropIndicator = null;
        this._lastDropIndicator = null;
        this._dragLeave = new Subject();
        this._dropIndicatorClass = 'igx-grid__th-drop-indicator--active';
    }
    set data(val) {
        if (val instanceof IgxColumnComponent) {
            this._column = val;
        }
        if (val instanceof IgxGridForOfDirective) {
            this._hVirtDir = val;
        }
    }
    get column() {
        return this._column;
    }
    get isDropTarget() {
        return this._column && this._column.grid.hasMovableColumns && this.cms.column.movable &&
            ((!this._column.pinned && this.cms.column.disablePinning) || !this.cms.column.disablePinning);
    }
    get horizontalScroll() {
        if (this._hVirtDir) {
            return this._hVirtDir;
        }
    }
    ngOnDestroy() {
        this._dragLeave.next(true);
        this._dragLeave.complete();
    }
    onDragOver(event) {
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.isDropTarget &&
            this.cms.column !== this.column &&
            this.cms.column.level === this.column.level &&
            this.cms.column.parent === this.column.parent) {
            if (this._lastDropIndicator) {
                this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
            }
            const clientRect = this.elementRef.nativeElement.getBoundingClientRect();
            const pos = clientRect.left + clientRect.width / 2;
            const parent = this.elementRef.nativeElement.parentElement;
            if (event.detail.pageX < pos) {
                this._dropPos = DropPosition.BeforeDropTarget;
                this._lastDropIndicator = this._dropIndicator = parent.firstElementChild;
            }
            else {
                this._dropPos = DropPosition.AfterDropTarget;
                this._lastDropIndicator = this._dropIndicator = parent.lastElementChild;
            }
            if (this.cms.icon.innerText !== 'block') {
                this.renderer.addClass(this._dropIndicator, this._dropIndicatorClass);
            }
        }
    }
    onDragEnter(event) {
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.column && this.cms.column.grid.id !== this.column.grid.id) {
            this.cms.icon.innerText = 'block';
            return;
        }
        if (this.isDropTarget &&
            this.cms.column !== this.column &&
            this.cms.column.level === this.column.level &&
            this.cms.column.parent === this.column.parent) {
            if (!this.column.pinned || (this.column.pinned && this.cms.column.pinned)) {
                this.cms.icon.innerText = 'swap_horiz';
            }
            this.cms.icon.innerText = 'lock';
        }
        else {
            this.cms.icon.innerText = 'block';
        }
        if (this.horizontalScroll) {
            this.cms.icon.innerText = event.target.id === 'right' ? 'arrow_forward' : 'arrow_back';
            interval(100).pipe(takeUntil(this._dragLeave)).subscribe(() => {
                if (event.target.id === 'right') {
                    this.horizontalScroll.scrollPosition += 15;
                }
                else {
                    this.horizontalScroll.scrollPosition -= 15;
                }
            });
        }
    }
    onDragLeave(event) {
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        this.cms.icon.innerText = 'block';
        if (this._dropIndicator) {
            this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
        }
        if (this.horizontalScroll) {
            this._dragLeave.next(true);
        }
    }
    onDragDrop(event) {
        event.preventDefault();
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.column && (this.cms.column.grid.id !== this.column.grid.id)) {
            return;
        }
        if (this.horizontalScroll) {
            this._dragLeave.next(true);
        }
        if (this.isDropTarget) {
            const args = {
                source: this.cms.column,
                target: this.column
            };
            this.column.grid.moveColumn(this.cms.column, this.column, this._dropPos);
            this.column.grid.draggedColumn = null;
            this.column.grid.cdr.detectChanges();
        }
    }
}
IgxColumnMovingDropDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxColumnMovingDrop]'
            },] }
];
IgxColumnMovingDropDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone },
    { type: IgxColumnMovingService }
];
IgxColumnMovingDropDirective.propDecorators = {
    data: [{ type: Input, args: ['igxColumnMovingDrop',] }]
};

class IgxColumnMovingModule {
}
IgxColumnMovingModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxColumnMovingDropDirective,
                    IgxColumnMovingDragDirective
                ],
                exports: [
                    IgxColumnMovingDropDirective,
                    IgxColumnMovingDragDirective
                ]
            },] }
];

class IgxGridAPIService extends GridBaseAPIService {
    groupBy(expression) {
        const groupingState = cloneArray(this.grid.groupingExpressions);
        const sortingState = cloneArray(this.grid.sortingExpressions);
        this.prepare_sorting_expression([sortingState, groupingState], expression);
        this.grid.groupingExpressions = groupingState;
        this.arrange_sorting_expressions();
    }
    groupBy_multiple(expressions) {
        const groupingState = cloneArray(this.grid.groupingExpressions);
        const sortingState = cloneArray(this.grid.sortingExpressions);
        for (const each of expressions) {
            this.prepare_sorting_expression([sortingState, groupingState], each);
        }
        this.grid.groupingExpressions = groupingState;
        this.arrange_sorting_expressions();
    }
    clear_groupby(name) {
        const groupingState = cloneArray(this.grid.groupingExpressions);
        const sortingState = cloneArray(this.grid.sortingExpressions);
        if (name) {
            const names = typeof name === 'string' ? [name] : name;
            const groupedCols = groupingState.filter((state) => names.indexOf(state.fieldName) < 0);
            const newSortingExpr = sortingState.filter((state) => names.indexOf(state.fieldName) < 0);
            this.grid.groupingExpressions = groupedCols;
            this.grid.sortingExpressions = newSortingExpr;
            names.forEach((colName) => {
                const grExprIndex = groupingState.findIndex((exp) => exp.fieldName === colName);
                const grpExpandState = this.grid.groupingExpansionState;
                /* remove expansion states related to the cleared group
                   and all with deeper hierarchy than the cleared group */
                const newExpandState = grpExpandState.filter((val) => val.hierarchy && val.hierarchy.length <= grExprIndex);
                /* Do not set the new instance produced by filter
                    when there are no differences between expansion states */
                if (newExpandState.length !== grpExpandState.length) {
                    this.grid.groupingExpansionState = newExpandState;
                }
            });
        }
        else {
            // clear all
            this.grid.groupingExpressions = [];
            this.grid.groupingExpansionState = [];
            for (const grExpr of groupingState) {
                const sortExprIndex = sortingState.findIndex((exp) => exp.fieldName === grExpr.fieldName);
                if (sortExprIndex > -1) {
                    sortingState.splice(sortExprIndex, 1);
                }
            }
            this.grid.sortingExpressions = sortingState;
        }
    }
    groupBy_get_expanded_for_group(groupRow) {
        const grState = this.grid.groupingExpansionState;
        const hierarchy = DataUtil.getHierarchy(groupRow);
        return grState.find((state) => DataUtil.isHierarchyMatch(state.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy));
    }
    groupBy_is_row_in_group(groupRow, rowID) {
        const grid = this.grid;
        let rowInGroup = false;
        groupRow.records.forEach(row => {
            if (grid.primaryKey ? row[grid.primaryKey] === rowID : row === rowID) {
                rowInGroup = true;
            }
        });
        return rowInGroup;
    }
    groupBy_toggle_group(groupRow) {
        const grid = this.grid;
        if (grid.crudService.cellInEditMode) {
            grid.endEdit(false);
        }
        const expansionState = grid.groupingExpansionState;
        const state = this.groupBy_get_expanded_for_group(groupRow);
        if (state) {
            state.expanded = !state.expanded;
        }
        else {
            expansionState.push({
                expanded: !grid.groupsExpanded,
                hierarchy: DataUtil.getHierarchy(groupRow)
            });
        }
        this.grid.groupingExpansionState = [...expansionState];
        if (grid.rowEditable) {
            grid.repositionRowEditingOverlay(grid.rowInEditMode);
        }
    }
    groupBy_fully_expand_group(groupRow) {
        const state = this.groupBy_get_expanded_for_group(groupRow);
        const expanded = state ? state.expanded : this.grid.groupsExpanded;
        if (!expanded) {
            this.groupBy_toggle_group(groupRow);
        }
        if (groupRow.groupParent) {
            this.groupBy_fully_expand_group(groupRow.groupParent);
        }
    }
    groupBy_select_all_rows_in_group(groupRow, clearPrevSelection) {
        this.grid.selectionService.selectRowsWithNoEvent(this.grid.primaryKey ?
            groupRow.records.map(x => x[this.grid.primaryKey]) : groupRow.records, clearPrevSelection);
    }
    groupBy_deselect_all_rows_in_group(groupRow) {
        this.grid.selectionService.deselectRowsWithNoEvent(this.grid.primaryKey ?
            groupRow.records.map(x => x[this.grid.primaryKey]) : groupRow.records);
    }
    arrange_sorting_expressions() {
        const groupingState = this.grid.groupingExpressions;
        this.grid.sortingExpressions.sort((a, b) => {
            const groupExprA = groupingState.find((expr) => expr.fieldName === a.fieldName);
            const groupExprB = groupingState.find((expr) => expr.fieldName === b.fieldName);
            if (groupExprA && groupExprB) {
                return groupingState.indexOf(groupExprA) > groupingState.indexOf(groupExprB) ? 1 : -1;
            }
            else if (groupExprA) {
                return -1;
            }
            else if (groupExprB) {
                return 1;
            }
            else {
                return 0;
            }
        });
    }
    get_groupBy_record_id(gRow) {
        let recordId = '{ ';
        const hierrarchy = DataUtil.getHierarchy(gRow);
        for (let i = 0; i < hierrarchy.length; i++) {
            const groupByKey = hierrarchy[i];
            recordId += `'${groupByKey.fieldName}': '${groupByKey.value}'`;
            if (i < hierrarchy.length - 1) {
                recordId += ', ';
            }
        }
        recordId += ' }';
        return recordId;
    }
    remove_grouping_expression(fieldName) {
        const groupingExpressions = this.grid.groupingExpressions;
        const index = groupingExpressions.findIndex((expr) => expr.fieldName === fieldName);
        if (index !== -1) {
            groupingExpressions.splice(index, 1);
        }
    }
}
IgxGridAPIService.decorators = [
    { type: Injectable }
];

class IgxGridGroupByRowComponent {
    constructor(gridAPI, gridSelection, element, cdr, filteringService) {
        this.gridAPI = gridAPI;
        this.gridSelection = gridSelection;
        this.element = element;
        this.cdr = cdr;
        this.filteringService = filteringService;
        /**
         * @hidden
         */
        this.isFocused = false;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        /**
         * @hidden
         */
        this.defaultCssClass = 'igx-grid__group-row';
        /**
         * @hidden
         */
        this.paddingIndentationCssClass = 'igx-grid__group-row--padding-level';
        this.gridSelection.selectedRowsChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.cdr.markForCheck();
        });
    }
    /**
     * Returns whether the row is focused.
     * ```
     * let gridRowFocused = this.grid1.rowList.first.focused;
     * ```
     */
    get focused() {
        return this.isActive();
    }
    activate() {
        this.grid.navigation.setActiveNode({ row: this.index });
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * Returns whether the group row is expanded.
     * ```typescript
     * const groupRowExpanded = this.grid1.rowList.first.expanded;
     * ```
     */
    get expanded() {
        return this.grid.isExpandedGroup(this.groupRow);
    }
    /**
     * @hidden
     */
    get describedBy() {
        const grRowExpr = this.groupRow.expression !== undefined ? this.groupRow.expression.fieldName : '';
        return this.gridID + '_' + grRowExpr;
    }
    get dataRowIndex() {
        return this.index;
    }
    /**
     * Returns a reference to the underlying HTML element.
     * ```typescript
     * const groupRowElement = this.nativeElement;
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    get attrCellID() {
        return `${this.gridID}_${this.index}`;
    }
    /**
     * Returns the style classes applied to the group rows.
     * ```typescript
     * const groupCssStyles = this.grid1.rowList.first.styleClasses;
     * ```
     */
    get styleClasses() {
        return `${this.defaultCssClass} ` + `${this.paddingIndentationCssClass}-` + this.groupRow.level +
            (this.isActive() ? ` ${this.defaultCssClass}--active` : '');
    }
    isActive() {
        return this.grid.navigation.activeNode ? this.grid.navigation.activeNode.row === this.index : false;
    }
    /**
     * @hidden @internal
     */
    getRowID(rowData) {
        return this.grid.primaryKey ? rowData[this.grid.primaryKey] : rowData;
    }
    /**
     * @hidden @internal
     */
    onGroupSelectorClick(event) {
        if (!this.grid.isMultiRowSelectionEnabled) {
            return;
        }
        event.stopPropagation();
        if (this.areAllRowsInTheGroupSelected) {
            this.groupRow.records.forEach(row => {
                this.gridSelection.deselectRow(this.getRowID(row), event);
            });
        }
        else {
            this.groupRow.records.forEach(row => {
                this.gridSelection.selectRowById(this.getRowID(row), false, event);
            });
        }
    }
    /**
     * Toggles the group row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     */
    toggle() {
        this.grid.toggleGroup(this.groupRow);
    }
    get iconTemplate() {
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultGroupByExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultGroupByCollapsedTemplate;
        }
    }
    get selectionNode() {
        return {
            row: this.index,
            column: this.gridSelection.activeElement ? this.gridSelection.activeElement.column : 0
        };
    }
    /**
     * Returns a reference to the `IgxGridComponent` the `IgxGridGroupByRowComponent` belongs to.
     * ```typescript
     * this.grid1.rowList.first.grid;
     * ```
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * @hidden
     */
    get dataType() {
        const column = this.groupRow.column;
        return (column && column.dataType) || DataType.String;
    }
    /**
     * @hidden @internal
     */
    get areAllRowsInTheGroupSelected() {
        return this.groupRow.records.every(x => this.gridSelection.isRowSelected(this.getRowID(x)));
    }
    /**
     * @hidden @internal
     */
    get selectedRowsInTheGroup() {
        return this.groupRow.records.filter(rowID => this.gridSelection.filteredSelectedRowIds.indexOf(this.getRowID(rowID)) > -1);
    }
    /**
     * @hidden @internal
     */
    get groupByRowCheckboxIndeterminateState() {
        if (this.selectedRowsInTheGroup.length > 0) {
            return !this.areAllRowsInTheGroupSelected;
        }
        return false;
    }
    /**
     * @hidden @internal
     */
    get groupByRowSelectorBaseAriaLabel() {
        const ariaLabel = this.areAllRowsInTheGroupSelected ?
            this.grid.resourceStrings.igx_grid_groupByArea_deselect_message : this.grid.resourceStrings.igx_grid_groupByArea_select_message;
        return ariaLabel.replace('{0}', this.groupRow.expression.fieldName).replace('{1}', this.groupRow.value);
    }
    /**
     * @hidden @internal
     */
    get showRowSelectors() {
        return this.grid.rowSelection !== GridSelectionMode.none && !this.hideGroupRowSelectors;
    }
}
IgxGridGroupByRowComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-groupby-row',
                template: "<ng-container #defaultGroupRow>\n\n    <ng-container *ngIf=\"rowDraggable\">\n        <div class=\"igx-grid__drag-indicator igx-grid__tr-action\">\n            <igx-icon [style.visibility]=\"'hidden'\">drag_indicator</igx-icon>\n        </div>\n    </ng-container>\n\n    <ng-container *ngIf=\"showRowSelectors\">\n        <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" style=\"background: none;\" (pointerdown)=\"$event.preventDefault()\"\n            (click)=\"onGroupSelectorClick($event)\">\n            <ng-template #groupByRowSelector *ngTemplateOutlet=\"\n                this.grid.groupByRowSelectorTemplate ? this.grid.groupByRowSelectorTemplate : groupByRowSelectorBaseTemplate;\n                context: { $implicit: {\n                    selectedCount: selectedRowsInTheGroup.length,\n                    totalCount: this.groupRow.records.length,\n                    groupRow: this.groupRow }}\">\n            </ng-template>\n        </div>\n    </ng-container>\n\n    <div (click)=\"toggle()\" class=\"igx-grid__grouping-indicator\">\n        <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n        </ng-container>\n    </div>\n\n    <div class=\"igx-grid__group-content\" #groupContent>\n        <ng-container\n            *ngTemplateOutlet=\"grid.groupRowTemplate ? grid.groupRowTemplate : defaultGroupByTemplate; context: { $implicit: groupRow }\">\n        </ng-container>\n    </div>\n\n    <ng-template #defaultGroupByExpandedTemplate>\n        <igx-icon>expand_more</igx-icon>\n    </ng-template>\n\n    <ng-template #defaultGroupByCollapsedTemplate>\n        <igx-icon>chevron_right</igx-icon>\n    </ng-template>\n\n\n    <ng-template #defaultGroupByTemplate>\n        <div class=\"igx-group-label\">\n            <igx-icon class=\"igx-group-label__icon\">group_work</igx-icon>\n            <span class=\"igx-group-label__column-name\">\n                {{ groupRow.column && groupRow.column.header ?\n                groupRow.column.header :\n                (groupRow.expression ? groupRow.expression.fieldName : '') }}:\n            </span>\n\n            <ng-container *ngIf=\"dataType === 'boolean' || dataType === 'string'; else default\">\n                <span class=\"igx-group-label__text\">{{ groupRow.value }}</span>\n            </ng-container>\n            <ng-template #default>\n                <ng-container *ngIf=\"dataType === 'number'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | number }}</span>\n                </ng-container>\n                <ng-container *ngIf=\"dataType === 'date'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | date }}</span>\n                </ng-container>\n            </ng-template>\n\n            <igx-badge [value]=\"groupRow.records ? groupRow.records.length : 0\" class='igx-group-label__count-badge'>\n            </igx-badge>\n        </div>\n    </ng-template>\n    <ng-template #groupByRowSelectorBaseTemplate let-context>\n        <div class=\"igx-grid__cbx-padding\">\n            <igx-checkbox [tabindex]=\"-1\" [readonly]=\"true\" [checked]=\"areAllRowsInTheGroupSelected\"\n                disableRipple=\"true\" [indeterminate]=\"groupByRowCheckboxIndeterminateState\"\n                [disabled]=\"this.grid.rowSelection === 'single'\" [aria-label]=\"groupByRowSelectorBaseAriaLabel\"\n                #groupByRowCheckbox>\n            </igx-checkbox>\n        </div>\n    </ng-template>\n</ng-container>\n"
            },] }
];
IgxGridGroupByRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxGridSelectionService },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxFilteringService }
];
IgxGridGroupByRowComponent.propDecorators = {
    hideGroupRowSelectors: [{ type: Input }],
    rowDraggable: [{ type: Input }],
    index: [{ type: Input }],
    gridID: [{ type: Input }],
    groupRow: [{ type: Input }],
    groupContent: [{ type: ViewChild, args: ['groupContent', { static: true },] }],
    isFocused: [{ type: Input }],
    defaultGroupByExpandedTemplate: [{ type: ViewChild, args: ['defaultGroupByExpandedTemplate', { read: TemplateRef, static: true },] }],
    defaultGroupByCollapsedTemplate: [{ type: ViewChild, args: ['defaultGroupByCollapsedTemplate', { read: TemplateRef, static: true },] }],
    activate: [{ type: HostListener, args: ['pointerdown',] }],
    expanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
    describedBy: [{ type: HostBinding, args: ['attr.aria-describedby',] }],
    dataRowIndex: [{ type: HostBinding, args: ['attr.data-rowIndex',] }],
    attrCellID: [{ type: HostBinding, args: ['attr.id',] }],
    styleClasses: [{ type: HostBinding, args: ['class',] }]
};

/** @hidden */
class IgxGridMRLNavigationService extends IgxGridNavigationService {
    isValidPosition(rowIndex, colIndex) {
        if (rowIndex < 0 || colIndex < 0 || this.grid.dataView.length - 1 < rowIndex ||
            Math.max(...this.grid.visibleColumns.map(col => col.visibleIndex)) < colIndex ||
            (this.activeNode.column !== colIndex && !this.isDataRow(rowIndex, true))) {
            return false;
        }
        return true;
    }
    shouldPerformVerticalScroll(targetRowIndex, visibleColIndex) {
        if (!super.shouldPerformVerticalScroll(targetRowIndex, visibleColIndex)) {
            return false;
        }
        if (!this.isDataRow(targetRowIndex) || visibleColIndex < 0) {
            return super.shouldPerformVerticalScroll(targetRowIndex, visibleColIndex);
        }
        const targetRow = super.getRowElementByIndex(targetRowIndex);
        const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        const scrollPos = this.getVerticalScrollPositions(targetRowIndex, visibleColIndex);
        return (!targetRow || targetRow.offsetTop + scrollPos.topOffset < Math.abs(this.containerTopOffset)
            || containerHeight && containerHeight < scrollPos.rowBottom - Math.ceil(this.scrollTop));
    }
    isColumnFullyVisible(visibleColIndex) {
        const targetCol = this.grid.getColumnByVisibleIndex(visibleColIndex);
        if (this.isParentColumnFullyVisible(targetCol === null || targetCol === void 0 ? void 0 : targetCol.parent) || super.isColumnPinned(visibleColIndex, this.forOfDir())) {
            return true;
        }
        const scrollPos = this.getChildColumnScrollPositions(visibleColIndex);
        const colWidth = scrollPos.rightScroll - scrollPos.leftScroll;
        if (this.displayContainerWidth < colWidth && this.displayContainerScrollLeft === scrollPos.leftScroll) {
            return true;
        }
        return this.displayContainerWidth >= scrollPos.rightScroll - this.displayContainerScrollLeft &&
            this.displayContainerScrollLeft <= scrollPos.leftScroll;
    }
    getVerticalScrollPositions(rowIndex, visibleIndex) {
        const targetCol = this.grid.getColumnByVisibleIndex(visibleIndex);
        const rowSpan = targetCol.rowEnd && targetCol.rowEnd - targetCol.rowStart ? targetCol.rowEnd - targetCol.rowStart : 1;
        const topOffset = this.grid.defaultRowHeight * (targetCol.rowStart - 1);
        const rowTop = this.grid.verticalScrollContainer.sizesCache[rowIndex] + topOffset;
        return { topOffset, rowTop, rowBottom: rowTop + (this.grid.defaultRowHeight * rowSpan) };
    }
    performHorizontalScrollToCell(visibleColumnIndex, cb) {
        if (!this.shouldPerformHorizontalScroll(visibleColumnIndex)) {
            return;
        }
        const scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);
        const startScroll = scrollPos.rightScroll - this.displayContainerScrollLeft;
        const nextScroll = !(this.displayContainerScrollLeft <= scrollPos.leftScroll) && this.displayContainerWidth >= startScroll ?
            scrollPos.leftScroll : scrollPos.rightScroll - this.displayContainerWidth;
        this.forOfDir().getScroll().scrollLeft = nextScroll;
        this.grid.parentVirtDir.onChunkLoad
            .pipe(first$1())
            .subscribe(() => {
            if (cb) {
                cb();
            }
        });
    }
    performVerticalScrollToCell(rowIndex, visibleColIndex, cb) {
        var _a;
        const children = (_a = this.parentByChildIndex(visibleColIndex || 0)) === null || _a === void 0 ? void 0 : _a.children;
        if (!super.isDataRow(rowIndex) || (children && children.length < 2) || visibleColIndex < 0) {
            return super.performVerticalScrollToCell(rowIndex, visibleColIndex, cb);
        }
        const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        const pos = this.getVerticalScrollPositions(rowIndex, visibleColIndex);
        const row = super.getRowElementByIndex(rowIndex);
        if ((this.scrollTop > pos.rowTop) && (!row || row.offsetTop + pos.topOffset < Math.abs(this.containerTopOffset))) {
            if (pos.topOffset === 0) {
                this.grid.verticalScrollContainer.scrollTo(rowIndex);
            }
            else {
                this.grid.verticalScrollContainer.scrollPosition = pos.rowTop;
            }
        }
        else {
            this.grid.verticalScrollContainer.addScrollTop(Math.abs(pos.rowBottom - this.scrollTop - containerHeight));
        }
        this.grid.verticalScrollContainer.onChunkLoad
            .pipe(first$1()).subscribe(() => {
            if (cb) {
                cb();
            }
        });
    }
    getNextHorizontalCellPosition(previous = false) {
        const parent = this.parentByChildIndex(this.activeNode.column);
        if (!this.hasNextHorizontalPosition(previous, parent)) {
            return { row: this.activeNode.row, column: this.activeNode.column };
        }
        const columns = previous ? parent.children.filter(c => c.rowStart <= this.activeNode.layout.rowStart)
            .sort((a, b) => b.visibleIndex - a.visibleIndex) : parent.children.filter(c => c.rowStart <= this.activeNode.layout.rowStart);
        let column = columns.find((col) => previous ?
            col.visibleIndex < this.activeNode.column && this.rowEnd(col) > this.activeNode.layout.rowStart :
            col.visibleIndex > this.activeNode.column && col.colStart > this.activeNode.layout.colStart);
        if (!column || (previous && this.activeNode.layout.colStart === 1)) {
            const index = previous ? parent.visibleIndex - 1 : parent.visibleIndex + 1;
            const children = this.grid.columnList.find(cols => cols.columnLayout && cols.visibleIndex === index).children;
            column = previous ? children.toArray().reverse().find(child => child.rowStart <= this.activeNode.layout.rowStart) :
                children.find(child => this.rowEnd(child) > this.activeNode.layout.rowStart && child.colStart === 1);
        }
        return { row: this.activeNode.row, column: column.visibleIndex };
    }
    getNextVerticalPosition(previous = false) {
        this.activeNode.column = this.activeNode.column || 0;
        if (!this.hasNextVerticalPosition(previous)) {
            return { row: this.activeNode.row, column: this.activeNode.column };
        }
        const currentRowStart = this.grid.getColumnByVisibleIndex(this.activeNode.column).rowStart;
        const nextBlock = !this.isDataRow(this.activeNode.row) ||
            (previous ? currentRowStart === 1 : currentRowStart === this.lastRowStartPerBlock());
        const nextRI = previous ? this.activeNode.row - 1 : this.activeNode.row + 1;
        if (nextBlock && !this.isDataRow(nextRI)) {
            return { row: nextRI, column: this.activeNode.column };
        }
        const children = this.parentByChildIndex(this.activeNode.column).children;
        const col = previous ? this.getPreviousRowIndex(children, nextBlock) : this.getNextRowIndex(children, nextBlock);
        return { row: nextBlock ? nextRI : this.activeNode.row, column: col.visibleIndex };
    }
    headerNavigation(event) {
        const key = event.key.toLowerCase();
        if (!HEADER_KEYS.has(key)) {
            return;
        }
        event.preventDefault();
        if (!this.activeNode.layout) {
            this.activeNode.layout = this.layout(this.activeNode.column || 0);
        }
        const alt = event.altKey;
        const ctrl = event.ctrlKey;
        this.performHeaderKeyCombination(this.grid.getColumnByVisibleIndex(this.activeNode.column), key, event.shiftKey, ctrl, alt, event);
        if (!ctrl && !alt && (key.includes('down') || key.includes('up'))) {
            const children = this.parentByChildIndex(this.activeNode.column).children;
            const col = key.includes('down') ? this.getNextRowIndex(children, false) : this.getPreviousRowIndex(children, false);
            if (!col) {
                return;
            }
            this.activeNode.column = col.visibleIndex;
            const layout = this.layout(this.activeNode.column);
            const nextLayout = Object.assign(Object.assign({}, this.activeNode.layout), { rowStart: layout.rowStart, rowEnd: layout.rowEnd });
            this.setActiveNode({ row: this.activeNode.row, layout: nextLayout });
            return;
        }
        this.horizontalNav(event, key, -1, 'headerCell');
    }
    /**
     * @hidden
     * @internal
     */
    layout(visibleIndex) {
        const column = this.grid.getColumnByVisibleIndex(visibleIndex);
        return { colStart: column.colStart, rowStart: column.rowStart,
            colEnd: column.colEnd, rowEnd: column.rowEnd, columnVisibleIndex: column.visibleIndex };
    }
    getNextPosition(rowIndex, colIndex, key, shift, ctrl, event) {
        if (!this.activeNode.layout) {
            this.activeNode.layout = this.layout(this.activeNode.column || 0);
        }
        switch (key) {
            case 'tab':
            case ' ':
            case 'spacebar':
            case 'space':
            case 'escape':
            case 'esc':
            case 'enter':
            case 'f2':
                super.getNextPosition(rowIndex, colIndex, key, shift, ctrl, event);
                break;
            case 'end':
                rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row;
                colIndex = ctrl ? this.lastColIndexPerMRLBlock(this.lastIndexPerRow) : this.lastIndexPerRow;
                break;
            case 'home':
                rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row;
                colIndex = ctrl ? 0 : this.firstIndexPerRow;
                break;
            case 'arrowleft':
            case 'left':
                colIndex = ctrl ? this.firstIndexPerRow : this.getNextHorizontalCellPosition(true).column;
                break;
            case 'arrowright':
            case 'right':
                colIndex = ctrl ? this.lastIndexPerRow : this.getNextHorizontalCellPosition().column;
                break;
            case 'arrowup':
            case 'up':
                const prevPos = this.getNextVerticalPosition(true);
                colIndex = ctrl ? this.activeNode.column : prevPos.column;
                rowIndex = ctrl ? this.findFirstDataRowIndex() : prevPos.row;
                break;
            case 'arrowdown':
            case 'down':
                const nextPos = this.getNextVerticalPosition();
                colIndex = ctrl ? this.activeNode.column : nextPos.column;
                rowIndex = ctrl ? this.findLastDataRowIndex() : nextPos.row;
                break;
            default:
                return;
        }
        const nextLayout = this.layout(colIndex);
        const newLayout = key.includes('up') || key.includes('down') ? { rowStart: nextLayout.rowStart } : { colStart: nextLayout.colStart };
        Object.assign(this.activeNode.layout, newLayout, { rowEnd: nextLayout.rowEnd });
        if (ctrl && (key === 'home' || key === 'end')) {
            this.activeNode.layout = nextLayout;
        }
        return { rowIndex, colIndex };
    }
    horizontalNav(event, key, rowIndex, tag) {
        const ctrl = event.ctrlKey;
        if (!HORIZONTAL_NAV_KEYS.has(key) || event.altKey) {
            return;
        }
        this.activeNode.row = rowIndex;
        const newActiveNode = {
            column: this.activeNode.column,
            mchCache: {
                level: this.activeNode.level,
                visibleIndex: this.activeNode.column
            }
        };
        if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {
            newActiveNode.column = ctrl || key === 'home' ? this.firstIndexPerRow : this.getNextHorizontalCellPosition(true).column;
        }
        if ((key.includes('right') || key === 'end') && this.activeNode.column !== this.lastIndexPerRow) {
            newActiveNode.column = ctrl || key === 'end' ? this.lastIndexPerRow : this.getNextHorizontalCellPosition().column;
        }
        if (tag === 'headerCell') {
            const column = this.grid.getColumnByVisibleIndex(newActiveNode.column);
            newActiveNode.mchCache.level = column.level;
            newActiveNode.mchCache.visibleIndex = column.visibleIndex;
        }
        const layout = this.layout(newActiveNode.column);
        const newLayout = Object.assign(Object.assign({}, this.activeNode.layout), { colStart: layout.colStart, rowEnd: layout.rowEnd });
        this.setActiveNode({ row: this.activeNode.row, column: newActiveNode.column,
            layout: newLayout, mchCache: newActiveNode.mchCache });
        this.performHorizontalScrollToCell(newActiveNode.column);
    }
    isParentColumnFullyVisible(parent) {
        if (!this.forOfDir().getScroll().clientWidth || (parent === null || parent === void 0 ? void 0 : parent.pinned)) {
            return true;
        }
        const index = this.forOfDir().igxForOf.indexOf(parent);
        return this.displayContainerWidth >= this.forOfDir().getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft &&
            this.displayContainerScrollLeft <= this.forOfDir().getColumnScrollLeft(index);
    }
    getChildColumnScrollPositions(visibleColIndex) {
        const targetCol = this.grid.getColumnByVisibleIndex(visibleColIndex);
        const parentVIndex = this.forOfDir().igxForOf.indexOf(targetCol.parent);
        let leftScroll = this.forOfDir().getColumnScrollLeft(parentVIndex);
        let rightScroll = this.forOfDir().getColumnScrollLeft(parentVIndex + 1);
        targetCol.parent.children.forEach((c) => {
            if (c.rowStart >= targetCol.rowStart && c.visibleIndex < targetCol.visibleIndex) {
                leftScroll += parseInt(c.width, 10);
            }
            if (c.rowStart <= targetCol.rowStart && c.visibleIndex > targetCol.visibleIndex) {
                rightScroll -= parseInt(c.width, 10);
            }
        });
        return { leftScroll, rightScroll };
    }
    getNextRowIndex(children, next) {
        const rowStart = next ? 1 : this.rowEnd(this.grid.getColumnByVisibleIndex(this.activeNode.column));
        const col = children.filter(c => c.rowStart === rowStart);
        return col.find(co => co.colStart === this.activeNode.layout.colStart) ||
            col.sort((a, b) => b.visibleIndex - a.visibleIndex).find(co => co.colStart <= this.activeNode.layout.colStart);
    }
    getPreviousRowIndex(children, prev) {
        const end = prev ? Math.max(...children.map(c => this.rowEnd(c))) :
            this.grid.getColumnByVisibleIndex(this.activeNode.column).rowStart;
        const col = children.filter(c => this.rowEnd(c) === end);
        return col.find(co => co.colStart === this.activeNode.layout.colStart) ||
            col.sort((a, b) => b.visibleIndex - a.visibleIndex).find(co => co.colStart <= this.activeNode.layout.colStart);
    }
    get lastIndexPerRow() {
        const children = this.grid.visibleColumns.find(c => c.visibleIndex === this.lastLayoutIndex && c.columnLayout)
            .children.toArray().reverse();
        const column = children.find(co => co.rowStart === this.activeNode.layout.rowStart) ||
            children.find(co => co.rowStart <= this.activeNode.layout.rowStart);
        return column.visibleIndex;
    }
    get firstIndexPerRow() {
        const children = this.grid.visibleColumns.find(c => c.visibleIndex === 0 && c.columnLayout).children;
        const column = children.find(co => co.rowStart === this.activeNode.layout.rowStart) ||
            children.find(co => co.rowStart <= this.activeNode.layout.rowStart);
        return column.visibleIndex;
    }
    get lastLayoutIndex() {
        return Math.max(...this.grid.visibleColumns.filter(c => c.columnLayout).map(col => col.visibleIndex));
    }
    get scrollTop() {
        return Math.abs(this.grid.verticalScrollContainer.getScroll().scrollTop);
    }
    lastColIndexPerMRLBlock(visibleIndex = this.activeNode.column) {
        return this.parentByChildIndex(visibleIndex).children.last.visibleIndex;
    }
    lastRowStartPerBlock(visibleIndex = this.activeNode.column) {
        return Math.max(...this.parentByChildIndex(visibleIndex).children.map(c => c.rowStart));
    }
    rowEnd(column) {
        return column.rowEnd && column.rowEnd - column.rowStart ? column.rowStart + column.rowEnd - column.rowStart : column.rowStart + 1;
    }
    parentByChildIndex(visibleIndex) {
        var _a;
        return (_a = this.grid.getColumnByVisibleIndex(visibleIndex)) === null || _a === void 0 ? void 0 : _a.parent;
    }
    hasNextHorizontalPosition(previous = false, parent) {
        if (previous && parent.visibleIndex === 0 && this.activeNode.layout.colStart === 1 ||
            !previous && parent.visibleIndex === this.lastLayoutIndex && this.activeNode.column === this.lastIndexPerRow) {
            return false;
        }
        return true;
    }
    hasNextVerticalPosition(prev = false) {
        if ((prev && this.activeNode.row === 0 && (!this.isDataRow(this.activeNode.row) || this.activeNode.layout.rowStart === 1)) ||
            (!prev && this.activeNode.row >= this.grid.dataView.length - 1 && this.activeNode.column === this.lastColIndexPerMRLBlock())) {
            return false;
        }
        return true;
    }
}
IgxGridMRLNavigationService.decorators = [
    { type: Injectable }
];

let NEXT_ID$l = 0;
/**
 * Grid provides a way to present and manipulate tabular data.
 *
 * @igxModule IgxGridModule
 * @igxGroup Grids & Lists
 * @igxKeywords grid, table
 * @igxTheme igx-grid-theme
 * @remarks
 * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
 * has been bound, it can be manipulated through filtering, sorting & editing operations.
 * @example
 * ```html
 * <igx-grid [data]="employeeData" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-grid>
 * ```
 */
class IgxGridComponent extends IgxGridBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Emitted when a new chunk of data is loaded from virtualization.
         *
         * @example
         * ```typescript
         *  <igx-grid #grid [data]="localData" [autoGenerate]="true" (onDataPreLoad)='handleDataPreloadEvent()'></igx-grid>
         * ```
         */
        this.onDataPreLoad = new EventEmitter();
        /**
         * @hidden
         */
        this.groupingExpressionsChange = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.groupingExpansionStateChange = new EventEmitter();
        /**
         * Emitted when columns are grouped/ungrouped.
         *
         * @remarks
         * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
         * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
         * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
         * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
         * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
         * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
         * columns.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onGroupingDone = new EventEmitter();
        /**
         * Gets/Sets whether created groups are rendered expanded or collapsed.
         *
         * @remarks
         * The default rendered state is expanded.
         * @example
         * ```html
         * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.groupsExpanded = true;
        /**
         * @hidden @internal
         */
        this.detailTemplate = null;
        /**
         * @hidden @internal
         */
        this.role = 'grid';
        /**
         * Gets/Sets the value of the `id` attribute.
         *
         * @remarks
         * If not provided it will be automatically generated.
         * @example
         * ```html
         * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.id = `igx-grid-${NEXT_ID$l++}`;
        /**
         * Gets the hierarchical representation of the group by records.
         *
         * @example
         * ```typescript
         * let groupRecords = this.grid.groupsRecords;
         * ```
         */
        this.groupsRecords = [];
        /**
         * @hidden
         */
        this._groupingExpressions = [];
        /**
         * @hidden
         */
        this._groupingExpandState = [];
        this._hideGroupedColumns = false;
        this._dropAreaMessage = null;
        this._showGroupArea = true;
        this._filteredData = null;
        this.childDetailTemplates = new Map();
    }
    /**
     * Gets/Sets the array of data that populates the `IgxGridComponent`.
     *
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get data() {
        return this._data;
    }
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
        }
        this.cdr.markForCheck();
    }
    /**
     * Gets/Sets an array of objects containing the filtered data.
     *
     * @example
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * this.grid.filteredData = [...];
     * ```
     */
    get filteredData() {
        return this._filteredData;
    }
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Gets/Sets the total number of records in the data source.
     *
     * @remarks
     * This property is required for remote grid virtualization to function when it is bound to remote data.
     * @example
     * ```typescript
     * const itemCount = this.grid1.totalItemCount;
     * this.grid1.totalItemCount = 55;
     * ```
     */
    set totalItemCount(count) {
        this.verticalScrollContainer.totalItemCount = count;
        this.cdr.detectChanges();
    }
    get totalItemCount() {
        return this.verticalScrollContainer.totalItemCount;
    }
    get _gridAPI() {
        return this.gridAPI;
    }
    /**
     * Gets/Sets the group by state.
     *
     * @example
     * ```typescript
     * let groupByState = this.grid.groupingExpressions;
     * this.grid.groupingExpressions = [...];
     * ```
     * @remarks
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpressions)]="model.groupingExpressions"></igx-grid>
     * ```
     */
    get groupingExpressions() {
        return this._groupingExpressions;
    }
    set groupingExpressions(value) {
        if (this.groupingExpressions === value) {
            return;
        }
        if (value && value.length > 10) {
            throw Error('Maximum amount of grouped columns is 10.');
        }
        const oldExpressions = this.groupingExpressions;
        const newExpressions = value;
        this._groupingExpressions = cloneArray(value);
        this.groupingExpressionsChange.emit(this._groupingExpressions);
        this.chipsGoupingExpressions = cloneArray(value);
        if (this._gridAPI.grid) {
            /* grouping should work in conjunction with sorting
            and without overriding separate sorting expressions */
            this._applyGrouping();
            this._gridAPI.arrange_sorting_expressions();
            this.notifyChanges();
        }
        else {
            // setter called before grid is registered in grid API service
            this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);
        }
        if (!this._init && JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {
            const groupedCols = [];
            const ungroupedCols = [];
            const groupedColsArr = newExpressions.filter((obj) => !oldExpressions.some((obj2) => obj.fieldName === obj2.fieldName));
            groupedColsArr.forEach((elem) => {
                groupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            const ungroupedColsArr = oldExpressions.filter((obj) => !newExpressions.some((obj2) => obj.fieldName === obj2.fieldName));
            ungroupedColsArr.forEach((elem) => {
                ungroupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            this.notifyChanges();
            const groupingDoneArgs = {
                expressions: newExpressions,
                groupedColumns: groupedCols,
                ungroupedColumns: ungroupedCols
            };
            this.onGroupingDone.emit(groupingDoneArgs);
        }
    }
    /**
     * Gets/Sets a list of expansion states for group rows.
     *
     * @remarks
     * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
     * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpansionState)]="model.groupingExpansionState"></igx-grid>
     * ```
     */
    get groupingExpansionState() {
        return this._groupingExpandState;
    }
    set groupingExpansionState(value) {
        if (value !== this._groupingExpandState) {
            this.groupingExpansionStateChange.emit(value);
        }
        this._groupingExpandState = value;
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
    }
    /**
     * Gets/Sets whether the grouped columns should be hidden.
     *
     * @remarks
     * The default value is "false"
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get hideGroupedColumns() {
        return this._hideGroupedColumns;
    }
    set hideGroupedColumns(value) {
        if (value) {
            this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
        }
        else {
            this.groupingDiffer = null;
        }
        if (this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(value);
        }
        this._hideGroupedColumns = value;
    }
    /**
     * Gets/Sets the message displayed inside the GroupBy drop area where columns can be dragged on.
     *
     * @remarks
     * The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
     * @example
     * ```html
     * <igx-grid dropAreaMessage="Drop here to group!">
     *      <igx-column [groupable]="true" field="ID"></igx-column>
     * </igx-grid>
     * ```
     */
    set dropAreaMessage(value) {
        this._dropAreaMessage = value;
        this.notifyChanges();
    }
    get dropAreaMessage() {
        return this._dropAreaMessage || this.resourceStrings.igx_grid_groupByArea_message;
    }
    /**
     * Gets the list of group rows.
     *
     * @example
     * ```typescript
     * const groupList = this.grid.groupsRowList;
     * ```
     */
    get groupsRowList() {
        const res = new QueryList();
        if (!this._groupsRowList) {
            return res;
        }
        const rList = this._groupsRowList.filter(item => item.element.nativeElement.parentElement !== null)
            .sort((item1, item2) => item1.index - item2.index);
        res.reset(rList);
        return res;
    }
    /**
     * @hidden
     * @internal
     */
    get groupByRowSelectorTemplate() {
        if (this.groupByRowSelectorsTemplates && this.groupByRowSelectorsTemplates.first) {
            return this.groupByRowSelectorsTemplates.first.templateRef;
        }
        return null;
    }
    /**
     * @hidden @internal
     */
    getDetailsContext(rowData, index) {
        return {
            $implicit: rowData,
            index
        };
    }
    /**
     * @hidden @internal
     */
    trackChanges(index, rec) {
        if (rec.detailsData !== undefined) {
            return rec.detailsData;
        }
        return rec;
    }
    /**
     * @hidden @internal
     */
    detailsViewFocused(container, rowIndex) {
        this.navigation.setActiveNode({ row: rowIndex });
    }
    /**
     * @hidden @internal
     */
    get hasDetails() {
        return !!this.gridDetailsTemplate;
    }
    /**
     * @hidden @internal
     */
    getRowTemplate(rowData) {
        if (this.isGroupByRecord(rowData)) {
            return this.defaultGroupTemplate;
        }
        else if (this.isSummaryRow(rowData)) {
            return this.summaryTemplate;
        }
        else if (this.hasDetails && this.isDetailRecord(rowData)) {
            return this.detailTemplateContainer;
        }
        else {
            return this.recordTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    isDetailRecord(record) {
        return record.detailsData !== undefined;
    }
    /**
     * @hidden @internal
     */
    isDetailActive(rowIndex) {
        return this.navigation.activeNode ? this.navigation.activeNode.row === rowIndex : false;
    }
    /**
     * @hidden @internal
     */
    get groupAreaHostClass() {
        return this.getComponentDensityClass('igx-drop-area');
    }
    /**
     * Gets/Sets the template reference for the group row.
     *
     * @example
     * ```
     * const groupRowTemplate = this.grid.groupRowTemplate;
     * this.grid.groupRowTemplate = myRowTemplate;
     * ```
     */
    get groupRowTemplate() {
        return this._groupRowTemplate;
    }
    set groupRowTemplate(template) {
        this._groupRowTemplate = template;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the template reference of the `IgxGridComponent`'s group area.
     *
     * @example
     * ```typescript
     * const groupAreaTemplate = this.grid.groupAreaTemplate;
     * this.grid.groupAreaTemplate = myAreaTemplate.
     * ```
     */
    get groupAreaTemplate() {
        return this._groupAreaTemplate;
    }
    set groupAreaTemplate(template) {
        this._groupAreaTemplate = template;
        this.notifyChanges();
    }
    /**
     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
     *
     * @remarks
     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
     * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
     * @example
     * ```typescript
     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * this.grid.groupBy([
     *     { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
     *     { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
     *     { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
     * ]);
     * ```
     */
    groupBy(expression) {
        if (this.checkIfNoColumnField(expression)) {
            return;
        }
        this.endEdit(false);
        if (expression instanceof Array) {
            this._gridAPI.groupBy_multiple(expression);
        }
        else {
            this._gridAPI.groupBy(expression);
        }
        this.notifyChanges(true);
    }
    /**
     * Clears grouping for particular column, array of columns or all columns.
     *
     * @remarks
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * @example
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     * @param name Name of column or array of column names to be ungrouped.
     */
    clearGrouping(name) {
        this._gridAPI.clear_groupby(name);
        this.notifyChanges(true);
    }
    preventHeaderScroll(args) {
        if (args.target.scrollLeft !== 0) {
            this.navigation.forOfDir().getScroll().scrollLeft = args.target.scrollLeft;
            args.target.scrollLeft = 0;
        }
    }
    /**
     * Returns if a group is expanded or not.
     *
     * @param group The group record.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     */
    isExpandedGroup(group) {
        const state = this._getStateForGroupRow(group);
        return state ? state.expanded : this.groupsExpanded;
    }
    /**
     * Toggles the expansion state of a group.
     *
     * @param groupRow The group record to toggle.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     */
    toggleGroup(groupRow) {
        this._toggleGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * Select all rows within a group.
     *
     * @param groupRow: The group record which rows would be selected.
     * @param clearCurrentSelection if true clears the current selection
     * @example
     * ```typescript
     * this.grid.selectRowsInGroup(this.groupRow, true);
     * ```
     */
    selectRowsInGroup(groupRow, clearPrevSelection) {
        this._gridAPI.groupBy_select_all_rows_in_group(groupRow, clearPrevSelection);
        this.notifyChanges();
    }
    /**
     * Deselect all rows within a group.
     *
     * @param groupRow The group record which rows would be deselected.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * this.grid.deselectRowsInGroup(this.groupRow);
     * ```
     */
    deselectRowsInGroup(groupRow) {
        this._gridAPI.groupBy_deselect_all_rows_in_group(groupRow);
        this.notifyChanges();
    }
    /**
     * Expands the specified group and all of its parent groups.
     *
     * @param groupRow The group record to fully expand.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * this.grid.fullyExpandGroup(this.groupRow);
     * ```
     */
    fullyExpandGroup(groupRow) {
        this._fullyExpandGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    isGroupByRecord(record) {
        // return record.records instance of GroupedRecords fails under Webpack
        return record.records && record.records.length;
    }
    /**
     * Toggles the expansion state of all group rows recursively.
     *
     * @example
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     */
    toggleAllGroupRows() {
        this.groupingExpansionState = [];
        this.groupsExpanded = !this.groupsExpanded;
        this.notifyChanges();
    }
    /**
     * Returns if the `IgxGridComponent` has groupable columns.
     *
     * @example
     * ```typescript
     * const groupableGrid = this.grid.hasGroupableColumns;
     * ```
     */
    get hasGroupableColumns() {
        return this.columnList.some((col) => col.groupable && !col.columnGroup);
    }
    /**
     * Returns whether the `IgxGridComponent` has group area.
     *
     * @example
     * ```typescript
     * let isGroupAreaVisible = this.grid.showGroupArea;
     * ```
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [showGroupArea]="false"></igx-grid>
     * ```
     */
    get showGroupArea() {
        return this._showGroupArea;
    }
    set showGroupArea(value) {
        this._showGroupArea = value;
        this.notifyChanges(true);
    }
    /**
     * Gets if the grid's group by drop area is visible.
     *
     * @example
     * ```typescript
     * const dropVisible = this.grid.dropAreaVisible;
     * ```
     */
    get dropAreaVisible() {
        return (this.draggedColumn && this.draggedColumn.groupable) ||
            !this.chipsGoupingExpressions.length;
    }
    /**
     * @hidden @internal
     */
    isColumnGrouped(fieldName) {
        return this.groupingExpressions.find(exp => exp.fieldName === fieldName) ? true : false;
    }
    /**
     * @hidden @internal
     */
    getContext(rowData, rowIndex, pinned) {
        if (this.isDetailRecord(rowData)) {
            const cachedData = this.childDetailTemplates.get(rowData.detailsData);
            const rowID = this.primaryKey ? rowData.detailsData[this.primaryKey] : this.data.indexOf(rowData.detailsData);
            if (cachedData) {
                const view = cachedData.view;
                const tmlpOutlet = cachedData.owner;
                return {
                    $implicit: rowData.detailsData,
                    moveView: view,
                    owner: tmlpOutlet,
                    index: this.dataView.indexOf(rowData),
                    templateID: 'detailRow-' + rowID
                };
            }
            else {
                // child rows contain unique grids, hence should have unique templates
                return {
                    $implicit: rowData.detailsData,
                    templateID: 'detailRow-' + rowID,
                    index: this.dataView.indexOf(rowData)
                };
            }
        }
        return {
            $implicit: this.isGhostRecord(rowData) || this.isAddRowRecord(rowData) ? rowData.recordRef : rowData,
            index: this.getDataViewIndex(rowIndex, pinned),
            templateID: this.isGroupByRecord(rowData) ? 'groupRow' : this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',
            disabled: this.isGhostRecord(rowData),
            addRow: this.isAddRowRecord(rowData) ? rowData.addRow : false
        };
    }
    /**
     * @hidden @internal
     */
    viewCreatedHandler(args) {
        if (args.context.templateID.indexOf('detailRow') !== -1) {
            this.childDetailTemplates.set(args.context.$implicit, args);
        }
    }
    /**
     * @hidden @internal
     */
    viewMovedHandler(args) {
        if (args.context.templateID.indexOf('detailRow') !== -1) {
            // view was moved, update owner in cache
            const key = args.context.$implicit;
            const cachedData = this.childDetailTemplates.get(key);
            cachedData.owner = args.owner;
        }
    }
    /**
     * @hidden @internal
     */
    onChipRemoved(event) {
        this.clearGrouping(event.owner.id);
    }
    /**
     * @hidden @internal
     */
    chipsOrderChanged(event) {
        const newGrouping = [];
        for (const chip of event.chipsArray) {
            const expr = this.groupingExpressions.filter((item) => item.fieldName === chip.id)[0];
            if (!this.getColumnByName(expr.fieldName).groupable) {
                // disallow changing order if there are columns with groupable: false
                return;
            }
            newGrouping.push(expr);
        }
        this.groupingExpansionState = [];
        this.chipsGoupingExpressions = newGrouping;
        if (event.originalEvent instanceof KeyboardEvent) {
            // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
            this.groupingExpressions = this.chipsGoupingExpressions;
        }
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    chipsMovingEnded() {
        this.groupingExpressions = this.chipsGoupingExpressions;
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    onChipClicked(event) {
        const sortingExpr = this.sortingExpressions;
        const columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
        columnExpr.dir = 3 - columnExpr.dir;
        this.sort(columnExpr);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    onChipKeyDown(event) {
        if (event.originalEvent.key === ' ' || event.originalEvent.key === 'Spacebar' || event.originalEvent.key === 'Enter') {
            const sortingExpr = this.sortingExpressions;
            const columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
            columnExpr.dir = 3 - columnExpr.dir;
            this.sort(columnExpr);
            this.notifyChanges();
        }
    }
    /**
     * @hidden @internal
     */
    get dropAreaTemplateResolved() {
        if (this.dropAreaTemplate) {
            return this.dropAreaTemplate;
        }
        else {
            return this.defaultDropAreaTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    getGroupByChipTitle(expression) {
        const column = this.getColumnByName(expression.fieldName);
        return (column && column.header) || expression.fieldName;
    }
    /**
     * @hidden @internal
     */
    get iconTemplate() {
        if (this.groupsExpanded) {
            return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    getColumnGroupable(fieldName) {
        const column = this.getColumnByName(fieldName);
        return column && column.groupable;
    }
    /**
     * @hidden @internal
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (this.allowFiltering && this.hasColumnLayouts) {
            this.filterMode = FilterMode.excelStyleFilter;
        }
        if (this.groupTemplate) {
            this._groupRowTemplate = this.groupTemplate.template;
        }
        if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(this.hideGroupedColumns);
        }
        this._setupNavigationService();
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.verticalScrollContainer.onBeforeViewDestroyed.pipe(takeUntil(this.destroy$)).subscribe((view) => {
            const rowData = view.context.$implicit;
            if (this.isDetailRecord(rowData)) {
                const cachedData = this.childDetailTemplates.get(rowData.detailsData);
                if (cachedData) {
                    const tmlpOutlet = cachedData.owner;
                    tmlpOutlet._viewContainerRef.detach(0);
                }
            }
        });
    }
    /**
     * @hidden @internal
     */
    ngOnInit() {
        super.ngOnInit();
        this.onGroupingDone.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.endEdit(false);
            this.summaryService.updateSummaryCache(args);
            this._headerFeaturesWidth = NaN;
        });
    }
    /**
     * @hidden @internal
     */
    ngDoCheck() {
        if (this.groupingDiffer && this.columnList && !this.hasColumnLayouts) {
            const changes = this.groupingDiffer.diff(this.groupingExpressions);
            if (changes && this.columnList.length > 0) {
                changes.forEachAddedItem((rec) => {
                    const col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = true;
                });
                changes.forEachRemovedItem((rec) => {
                    const col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
        super.ngDoCheck();
    }
    /**
     * @hidden @internal
     */
    dataLoading(event) {
        this.onDataPreLoad.emit(event);
    }
    /**
     * @inheritdoc
     */
    getSelectedData(formatters = false, headers = false) {
        if (this.groupingExpressions.length || this.hasDetails) {
            const source = [];
            const process = (record) => {
                if (record.expression || record.summaries || this.isDetailRecord(record)) {
                    source.push(null);
                    return;
                }
                source.push(record);
            };
            this.dataView.forEach(process);
            return this.extractDataFromSelection(source, formatters, headers);
        }
        else {
            return super.getSelectedData(formatters, headers);
        }
    }
    /**
     * @hidden @internal
     */
    get defaultTargetBodyHeight() {
        const allItems = this.totalItemCount || this.dataLength;
        return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
    }
    /**
     * @hidden @internal
     */
    getGroupAreaHeight() {
        return this.groupArea ? this.getComputedHeight(this.groupArea.nativeElement) : 0;
    }
    /**
     * @hidden @internal
     */
    scrollTo(row, column) {
        if (this.groupingExpressions && this.groupingExpressions.length
            && typeof (row) !== 'number') {
            const rowIndex = this.groupingResult.indexOf(row);
            const groupByRecord = this.groupingMetadata[rowIndex];
            if (groupByRecord) {
                this._fullyExpandGroup(groupByRecord);
            }
        }
        super.scrollTo(row, column, this.groupingFlatResult);
    }
    /**
     * @hidden @internal
     */
    _getStateForGroupRow(groupRow) {
        return this._gridAPI.groupBy_get_expanded_for_group(groupRow);
    }
    /**
     * @hidden
     */
    _toggleGroup(groupRow) {
        this._gridAPI.groupBy_toggle_group(groupRow);
    }
    /**
     * @hidden @internal
     */
    _fullyExpandGroup(groupRow) {
        this._gridAPI.groupBy_fully_expand_group(groupRow);
    }
    /**
     * @hidden @internal
     */
    _applyGrouping() {
        this._gridAPI.sort_multiple(this._groupingExpressions);
    }
    _setupNavigationService() {
        if (this.hasColumnLayouts) {
            this.navigation = new IgxGridMRLNavigationService();
            this.navigation.grid = this;
        }
    }
    checkIfNoColumnField(expression) {
        if (expression instanceof Array) {
            for (const singleExpression of expression) {
                if (!singleExpression.fieldName) {
                    return true;
                }
            }
            return false;
        }
        return !expression.fieldName;
    }
    _setGroupColsVisibility(value) {
        if (this.columnList.length > 0 && !this.hasColumnLayouts) {
            this.groupingExpressions.forEach((expr) => {
                const col = this.getColumnByName(expr.fieldName);
                col.hidden = value;
            });
        }
    }
}
IgxGridComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                providers: [
                    IgxGridNavigationService,
                    IgxGridSummaryService,
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    { provide: GridBaseAPIService, useClass: IgxGridAPIService },
                    { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxGridComponent) },
                    IgxFilteringService,
                    IgxColumnResizingService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService
                ],
                selector: 'igx-grid',
                template: "<ng-content select=\"igx-grid-toolbar\"></ng-content>\n\n<div [style.flex-basis.px]='outerWidth' class=\"igx-grid__grouparea\"\n    *ngIf=\"showGroupArea && (groupingExpressions.length > 0 || hasGroupableColumns)\" #groupArea>\n    <igx-chips-area (reorder)=\"chipsOrderChanged($event)\" (moveEnd)=\"chipsMovingEnded()\">\n        <ng-container *ngFor=\"let expr of chipsGoupingExpressions; let last = last;\">\n            <igx-chip [id]=\"expr.fieldName\" [title]=\"getGroupByChipTitle(expr)\"\n                [removable]=\"getColumnGroupable(expr.fieldName)\"\n                [draggable]=\"getColumnGroupable(expr.fieldName)\" [displayDensity]=\"displayDensity\"\n                (keyDown)=\"onChipKeyDown($event)\" (remove)=\"onChipRemoved($event)\"\n                (chipClick)=\"getColumnGroupable(expr.fieldName) ? onChipClicked($event): null\"\n                [disabled]='!getColumnGroupable(expr.fieldName)'>\n                <span>{{ getGroupByChipTitle(expr) }}</span>\n                <igx-icon igxSuffix>{{ expr.dir == 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n            </igx-chip>\n            <span class=\"igx-grid__grouparea-connector\">\n                <igx-icon [style.visibility]=\"(!last || dropAreaVisible) ? 'visible' : 'hidden'\">arrow_forward\n                </igx-icon>\n            </span>\n        </ng-container>\n        <div igxGroupAreaDrop [style.visibility]=\"dropAreaVisible ? 'visible' : 'hidden'\" [class]=\"groupAreaHostClass\"\n            [attr.gridId]='this.id'>\n            <ng-container *ngTemplateOutlet=\"dropAreaTemplateResolved\"></ng-container>\n        </div>\n    </igx-chips-area>\n</div>\n\n<div class=\"igx-grid__thead\" role=\"rowgroup\">\n    <div class=\"igx-grid__thead-wrapper\" (keydown.meta.c)=\"copyHandler($event)\" (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" \n    [class.igx-grid__tr--mrl]='hasColumnLayouts' (focus)=\"navigation.focusFirstCell()\" [attr.aria-activedescendant]=\"activeDescendant\"\n    [style.width.px]='calcWidth' tabindex=\"0\" (keydown)=\"navigation.headerNavigation($event)\" (scroll)=\"preventHeaderScroll($event)\" #theadRow>\n    <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"pinnedWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator igx-grid__tr-action\" [ngClass]=\"{\n                    'igx-grid__drag-indicator--header': !isRowSelectable\n                }\" (pointerdown)=\"$event.preventDefault()\"  #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                }\" (pointerdown)=\"$event.preventDefault()\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"groupingExpressions.length > 0\">\n                <div class=\"igx-grid__header-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"\n                    #headerGroupContainer  (click)=\"toggleAllGroupRows()\" (pointerdown)=\"$event.preventDefault()\">\n\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\" [style.left]=\"col.rightPinnedOffset\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollSize\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\" role=\"rowgroup\">\n    <div class=\"igx-grid__tbody-content\" tabindex=\"0\" (keydown)=\"navigation.handleNavigation($event)\" (focus)=\"navigation.focusTbody($event)\"\n        (onDragStop)=\"selectionService.dragMode = $event\" (scroll)='preventContainerScroll($event)'\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth || null' #tbody [attr.aria-activedescendant]=\"activeDescendant\">\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n    <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\">\n    </ng-container>\n    <ng-template #pinnedRecordsTemplate>\n        <ng-container *ngIf='data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridRowPinning:id:true:pipeTrigger\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger:true\n        | gridAddRow:true:pipeTrigger as pinnedData'>\n            <div #pinContainer *ngIf='pinnedData.length > 0'\n                [ngClass]=\"{\n                    'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                    'igx-grid__tr--pinned-top': isRowPinningToTop\n                }\"\n                class='igx-grid__tr--pinned' [style.width.px]='calcWidth'>\n                <ng-container *ngFor=\"let rowData of pinnedData; let rowIndex = index\">\n                    <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                    </ng-container>\n                </ng-container>\n            </div>\n        </ng-container>\n    </ng-template>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger\n        | gridGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:groupsRecords:pipeTrigger\n        | gridPaging:page:perPage:id:pipeTrigger\n        | gridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:showSummaryOnCollapse:pipeTrigger:summaryPipeTrigger\n        | gridDetails:hasDetails:expansionStates:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\n        | gridAddRow:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight'\n            [igxForItemSize]=\"hasColumnLayouts ? rowHeight * multiRowLayoutRowSize + 1 : renderedRowHeight\"\n            [igxForTrackBy]='trackChanges'\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template\n                [igxTemplateOutlet]='getRowTemplate(rowData)'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'\n                (onViewCreated)='viewCreatedHandler($event)'\n                (onViewMoved)='viewMovedHandler($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-rowData let-disabledRow=\"disabled\" let-isAddRow=\"addRow\">\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" [disabled]=\"disabledRow\" [addRow]=\"isAddRow\" #row>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData let-isAddRow=\"addRow\">\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" [addRow]=\"isAddRow\" #row #pinnedRow>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #group_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" [hideGroupRowSelectors]=\"hideRowSelectors\" [rowDraggable]=\"rowDraggable\" #row>\n            </igx-grid-groupby-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row role=\"row\" [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-template #detail_template_container let-rowIndex=\"index\" let-rowData>\n            <div detail='true' style=\"overflow: auto; width: 100%;\" id=\"{{id}}_{{rowIndex}}\" (pointerdown)='detailsViewFocused(detailsContainer, rowIndex)' #detailsContainer [attr.data-rowindex]='rowIndex'\n                [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr-container--active': isDetailActive(rowIndex)\n            }\">\n                <div class=\"igx-grid__hierarchical-indent\" style='display: flex;'>\n                        <ng-container *ngIf=\"this.groupingExpressions.length > 0\">\n                                <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"></div>\n                        </ng-container>\n                        <ng-template\n                    [ngTemplateOutlet]='detailTemplate'\n                    [ngTemplateOutletContext]='getDetailsContext(rowData, rowIndex)'>\n                    </ng-template>\n                </div>\n            </div>\n        </ng-template>\n\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <div igxToggle #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\" (pointerdown)=\"$event.preventDefault()\">\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [actionText]=\"snackbarActionText\" [displayTime]='snackbarDisplayTime'>{{snackbarLabel}}</igx-snackbar>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <div tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\" (keydown)=\"navigation.summaryNav($event)\" [attr.aria-activedescendant]=\"activeDescendant\">\n        <igx-grid-summary-row [style.width.px]='calcWidth'  [style.height.px]='summariesHeight'\n            *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n            [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n            class=\"igx-grid__summaries\" #summaryRow>\n        </igx-grid-summary-row>\n        <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n            [style.width.px]=\"scrollSize\"></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\" (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [overlaySettings]=\"paginatorSettings\" [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button igxButton=\"raised\" igxRipple (click)='beginAddRowByIndex(null, -1, $event)'>\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultDropArea>\n    <igx-icon class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{dropAreaMessage}}</span>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n   [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_less</igx-icon>\n</ng-template>\n\n <ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n    [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_more</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle #rowEditingOverlay>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\" *ngIf=\"!this.crudService.row?.isAddRow\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon>drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n"
            },] }
];
IgxGridComponent.propDecorators = {
    onDataPreLoad: [{ type: Output }],
    groupingExpressionsChange: [{ type: Output }],
    groupingExpansionStateChange: [{ type: Output }],
    onGroupingDone: [{ type: Output }],
    groupsExpanded: [{ type: Input }],
    dropAreaTemplate: [{ type: Input }],
    detailTemplate: [{ type: ContentChild, args: [IgxGridDetailTemplateDirective, { read: TemplateRef, static: false },] }],
    defaultDropAreaTemplate: [{ type: ViewChild, args: ['defaultDropArea', { read: TemplateRef, static: true },] }],
    groupArea: [{ type: ViewChild, args: ['groupArea',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    recordTemplate: [{ type: ViewChild, args: ['record_template', { read: TemplateRef, static: true },] }],
    detailTemplateContainer: [{ type: ViewChild, args: ['detail_template_container', { read: TemplateRef, static: true },] }],
    defaultGroupTemplate: [{ type: ViewChild, args: ['group_template', { read: TemplateRef, static: true },] }],
    summaryTemplate: [{ type: ViewChild, args: ['summary_template', { read: TemplateRef, static: true },] }],
    groupTemplate: [{ type: ContentChild, args: [IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective },] }],
    gridDetailsTemplate: [{ type: ContentChild, args: [IgxGridDetailTemplateDirective, { read: IgxGridDetailTemplateDirective, static: false },] }],
    groupByRowSelectorsTemplates: [{ type: ContentChildren, args: [IgxGroupByRowSelectorDirective, { read: IgxGroupByRowSelectorDirective, descendants: false },] }],
    _groupsRowList: [{ type: ViewChildren, args: [IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent },] }],
    data: [{ type: Input }],
    groupingExpressions: [{ type: Input }],
    groupingExpansionState: [{ type: Input }],
    hideGroupedColumns: [{ type: Input }],
    dropAreaMessage: [{ type: Input }],
    showGroupArea: [{ type: Input }]
};

class IgxGridStateDirective {
    /**
     * @hidden
     */
    constructor(grid, resolver, viewRef) {
        this.grid = grid;
        this.resolver = resolver;
        this.viewRef = viewRef;
        this.featureKeys = [];
        this._options = {
            columns: true,
            filtering: true,
            advancedFiltering: true,
            sorting: true,
            groupBy: true,
            paging: true,
            cellSelection: true,
            rowSelection: true,
            columnSelection: true,
            rowPinning: true,
            expansion: true,
            rowIslands: true
        };
        this.FEATURES = {
            sorting: {
                getFeatureState: (context) => {
                    const sortingState = context.currGrid.sortingExpressions;
                    sortingState.forEach(s => {
                        delete s.strategy;
                        delete s.owner;
                    });
                    return { sorting: sortingState };
                },
                restoreFeatureState: (context, state) => {
                    context.currGrid.sortingExpressions = state;
                }
            },
            filtering: {
                getFeatureState: (context) => {
                    const filteringState = context.currGrid.filteringExpressionsTree;
                    if (filteringState) {
                        delete filteringState.owner;
                        for (const item of filteringState.filteringOperands) {
                            delete item.owner;
                        }
                    }
                    return { filtering: filteringState };
                },
                restoreFeatureState: (context, state) => {
                    const filterTree = context.createExpressionsTreeFromObject(state);
                    context.currGrid.filteringExpressionsTree = filterTree;
                }
            },
            advancedFiltering: {
                getFeatureState: (context) => {
                    const filteringState = context.currGrid.advancedFilteringExpressionsTree;
                    let advancedFiltering;
                    if (filteringState) {
                        delete filteringState.owner;
                        for (const item of filteringState.filteringOperands) {
                            delete item.owner;
                        }
                        advancedFiltering = filteringState;
                    }
                    else {
                        advancedFiltering = {};
                    }
                    return { advancedFiltering };
                },
                restoreFeatureState: (context, state) => {
                    const filterTree = context.createExpressionsTreeFromObject(state);
                    context.currGrid.advancedFilteringExpressionsTree = filterTree;
                }
            },
            columns: {
                getFeatureState: (context) => {
                    const gridColumns = context.currGrid.columns.map((c) => ({
                        pinned: c.pinned,
                        sortable: c.sortable,
                        filterable: c.filterable,
                        editable: c.editable,
                        sortingIgnoreCase: c.sortingIgnoreCase,
                        filteringIgnoreCase: c.filteringIgnoreCase,
                        headerClasses: c.headerClasses,
                        headerGroupClasses: c.headerGroupClasses,
                        maxWidth: c.maxWidth,
                        groupable: c.groupable,
                        movable: c.movable,
                        hidden: c.hidden,
                        dataType: c.dataType,
                        hasSummary: c.hasSummary,
                        field: c.field,
                        width: c.width,
                        header: c.header,
                        resizable: c.resizable,
                        searchable: c.searchable,
                        selectable: c.selectable
                    }));
                    return { columns: gridColumns };
                },
                restoreFeatureState: (context, state) => {
                    const newColumns = [];
                    const factory = context.resolver.resolveComponentFactory(IgxColumnComponent);
                    state.forEach((colState) => {
                        const ref = factory.create(context.viewRef.injector);
                        Object.assign(ref.instance, colState);
                        ref.changeDetectorRef.detectChanges();
                        newColumns.push(ref.instance);
                    });
                    context.currGrid.columnList.reset(newColumns);
                    context.currGrid.columnList.notifyOnChanges();
                }
            },
            groupBy: {
                getFeatureState: (context) => {
                    const grid = context.currGrid;
                    const groupingExpressions = grid.groupingExpressions;
                    groupingExpressions.forEach(expr => {
                        delete expr.strategy;
                    });
                    const expansionState = grid.groupingExpansionState;
                    const groupsExpanded = grid.groupsExpanded;
                    return { groupBy: { expressions: groupingExpressions, expansion: expansionState, defaultExpanded: groupsExpanded } };
                },
                restoreFeatureState: (context, state) => {
                    const grid = context.currGrid;
                    grid.groupingExpressions = state.expressions;
                    if (grid.groupsExpanded !== state.defaultExpanded) {
                        grid.toggleAllGroupRows();
                    }
                    else {
                        grid.groupingExpansionState = state.expansion;
                    }
                }
            },
            paging: {
                getFeatureState: (context) => {
                    const pagingState = context.currGrid.pagingState;
                    return { paging: pagingState };
                },
                restoreFeatureState: (context, state) => {
                    if (context.currGrid.perPage !== state.recordsPerPage) {
                        context.currGrid.perPage = state.recordsPerPage;
                        context.currGrid.cdr.detectChanges();
                    }
                    context.currGrid.page = state.index;
                }
            },
            rowSelection: {
                getFeatureState: (context) => {
                    const selection = context.currGrid.selectedRows;
                    return { rowSelection: selection };
                },
                restoreFeatureState: (context, state) => {
                    context.currGrid.selectRows(state, true);
                }
            },
            cellSelection: {
                getFeatureState: (context) => {
                    const selection = context.currGrid.getSelectedRanges().map(range => ({ rowStart: range.rowStart, rowEnd: range.rowEnd, columnStart: range.columnStart, columnEnd: range.columnEnd }));
                    return { cellSelection: selection };
                },
                restoreFeatureState: (context, state) => {
                    state.forEach(r => {
                        const range = { rowStart: r.rowStart, rowEnd: r.rowEnd, columnStart: r.columnStart, columnEnd: r.columnEnd };
                        context.currGrid.selectRange(range);
                    });
                }
            },
            columnSelection: {
                getFeatureState: (context) => {
                    const selection = context.currGrid.selectedColumns().map(c => c.field);
                    return { columnSelection: selection };
                },
                restoreFeatureState: (context, state) => {
                    context.currGrid.deselectAllColumns();
                    context.currGrid.selectColumns(state);
                }
            },
            rowPinning: {
                getFeatureState: (context) => {
                    const pinned = context.currGrid.pinnedRows.map(x => x.rowID);
                    return { rowPinning: pinned };
                },
                restoreFeatureState: (context, state) => {
                    // clear current state.
                    context.currGrid.pinnedRows.forEach(row => row.unpin());
                    state.forEach(rowID => context.currGrid.pinRow(rowID));
                }
            },
            pinningConfig: {
                getFeatureState: (context) => ({ pinningConfig: context.currGrid.pinning }),
                restoreFeatureState: (context, state) => {
                    context.currGrid.pinning = state;
                }
            },
            expansion: {
                getFeatureState: (context) => {
                    const expansionStates = Array.from(context.currGrid.expansionStates);
                    return { expansion: expansionStates };
                },
                restoreFeatureState: (context, state) => {
                    const expansionStates = new Map(state);
                    context.currGrid.expansionStates = expansionStates;
                }
            },
            rowIslands: {
                getFeatureState(context) {
                    const childGridStates = [];
                    const rowIslands = context.currGrid.allLayoutList;
                    if (rowIslands) {
                        rowIslands.forEach(rowIsland => {
                            const childGrids = rowIsland.rowIslandAPI.getChildGrids();
                            childGrids.forEach(chGrid => {
                                const parentRowID = this.getParentRowID(chGrid);
                                context.currGrid = chGrid;
                                if (context.currGrid) {
                                    const childGridState = context.buildState(context.featureKeys);
                                    childGridStates.push({ id: `${rowIsland.id}`, parentRowID, state: childGridState });
                                }
                            });
                        });
                    }
                    context.currGrid = context.grid;
                    return { rowIslands: childGridStates };
                },
                restoreFeatureState(context, state) {
                    const rowIslands = context.currGrid.allLayoutList;
                    if (rowIslands) {
                        rowIslands.forEach(rowIsland => {
                            const childGrids = rowIsland.rowIslandAPI.getChildGrids();
                            childGrids.forEach(chGrid => {
                                const parentRowID = this.getParentRowID(chGrid);
                                context.currGrid = chGrid;
                                const childGridState = state.find(st => st.id === rowIsland.id && st.parentRowID === parentRowID);
                                if (childGridState && context.currGrid) {
                                    context.restoreGridState(childGridState.state, context.featureKeys);
                                }
                            });
                        });
                    }
                    context.currGrid = context.grid;
                },
                /**
                 * Traverses the hierarchy up to the root grid to return the ID of the expanded row.
                 */
                getParentRowID: (grid) => {
                    let childGrid;
                    let childRow;
                    while (grid.parent) {
                        childRow = grid.childRow;
                        childGrid = grid;
                        grid = grid.parent;
                    }
                    return grid.hgridAPI.getParentRowId(childGrid);
                }
            }
        };
    }
    /**
     *  An object with options determining if a certain feature state should be saved.
     * ```html
     * <igx-grid [igxGridState]="options"></igx-grid>
     * ```
     * ```typescript
     * public options = {selection: false, advancedFiltering: false};
     * ```
     */
    get options() {
        return this._options;
    }
    set options(value) {
        Object.assign(this._options, value);
        if (!(this.grid instanceof IgxGridComponent)) {
            delete this._options.groupBy;
        }
        else {
            delete this._options.rowIslands;
        }
    }
    /**
     * Gets the state of a feature or states of all grid features, unless a certain feature is disabled through the `options` property.
     *
     * @param `serialize` determines whether the returned object will be serialized to JSON string. Default value is true.
     * @param `feature` string or array of strings determining the features to be added in the state. If skipped, all features are added.
     * @returns Returns the serialized to JSON string IGridState object, or the non-serialized IGridState object.
     * ```html
     * <igx-grid [igxGridState]="options"></igx-grid>
     * ```
     * ```typescript
     * @ViewChild(IgxGridStateDirective, { static: true }) public state;
     * let state = this.state.getState(); // returns string
     * let state = this.state(false) // returns `IGridState` object
     * ```
     */
    getState(serialize = true, features) {
        let state;
        this.currGrid = this.grid;
        this.state = state = this.buildState(features);
        if (serialize) {
            state = JSON.stringify(state, this.stringifyCallback);
        }
        return state;
    }
    /**
     * Restores grid features' state based on the IGridState object passed as an argument.
     *
     * @param IGridState object to restore state from.
     * @returns
     * ```html
     * <igx-grid [igxGridState]="options"></igx-grid>
     * ```
     * ```typescript
     * @ViewChild(IgxGridStateDirective, { static: true }) public state;
     * this.state.setState(gridState);
     * ```
     */
    setState(state, features) {
        if (typeof state === 'string') {
            state = JSON.parse(state);
        }
        this.currGrid = this.grid;
        this.restoreGridState(state, features);
        this.grid.cdr.detectChanges(); // TODO
    }
    /**
     * Builds an IGridState object.
     */
    buildState(keys) {
        this.applyFeatures(keys);
        let gridState = {};
        this.featureKeys.forEach(f => {
            if (this.options[f]) {
                if (!(this.grid instanceof IgxGridComponent) && f === 'groupBy') {
                    return;
                }
                const feature = this.getFeature(f);
                const featureState = feature.getFeatureState(this);
                gridState = Object.assign(gridState, featureState);
            }
        });
        return gridState;
    }
    /**
     * The method that calls corresponding methods to restore features from the passed IGridState object.
     */
    restoreGridState(state, features) {
        this.applyFeatures(features);
        this.featureKeys.forEach(f => {
            if (this.options[f]) {
                const featureState = state[f];
                if (featureState) {
                    const feature = this.getFeature(f);
                    feature.restoreFeatureState(this, featureState);
                }
            }
        });
    }
    /**
     * Returns a collection of all grid features.
     */
    applyFeatures(keys) {
        this.featureKeys = [];
        if (!keys) {
            for (const key of Object.keys(this.options)) {
                this.featureKeys.push(key);
            }
        }
        else if (Array.isArray(keys)) {
            this.featureKeys = [...keys];
        }
        else {
            this.featureKeys.push(keys);
        }
    }
    /**
     * This method builds a FilteringExpressionsTree from a provided object.
     */
    createExpressionsTreeFromObject(exprTreeObject) {
        if (!exprTreeObject || !exprTreeObject.filteringOperands) {
            return null;
        }
        const expressionsTree = new FilteringExpressionsTree(exprTreeObject.operator, exprTreeObject.fieldName);
        for (const item of exprTreeObject.filteringOperands) {
            // Check if item is an expressions tree or a single expression.
            if (item.filteringOperands) {
                const subTree = this.createExpressionsTreeFromObject(item);
                expressionsTree.filteringOperands.push(subTree);
            }
            else {
                const expr = item;
                let dataType;
                if (this.currGrid.columnList.length > 0) {
                    dataType = this.currGrid.columnList.find(c => c.field === expr.fieldName).dataType;
                }
                else {
                    dataType = this.state.columns.find(c => c.field === expr.fieldName).dataType;
                }
                // when ESF, values are stored in Set.
                // First those values are converted to an array before returning string in the stringifyCallback
                // now we need to convert those back to Set
                if (Array.isArray(expr.searchVal)) {
                    expr.searchVal = new Set(expr.searchVal);
                }
                else {
                    expr.searchVal = (dataType === 'date') ? new Date(Date.parse(expr.searchVal)) : expr.searchVal;
                }
                expr.condition = this.generateFilteringCondition(dataType, expr.condition.name);
                expressionsTree.filteringOperands.push(expr);
            }
        }
        return expressionsTree;
    }
    /**
     * Returns the filtering logic function for a given dataType and condition (contains, greaterThan, etc.)
     */
    generateFilteringCondition(dataType, name) {
        let filters;
        switch (dataType) {
            case DataType.Boolean:
                filters = IgxBooleanFilteringOperand.instance();
                break;
            case DataType.Number:
                filters = IgxNumberFilteringOperand.instance();
                break;
            case DataType.Date:
                filters = IgxDateFilteringOperand.instance();
                break;
            case DataType.String:
            default:
                filters = IgxStringFilteringOperand.instance();
                break;
        }
        return filters.condition(name);
    }
    stringifyCallback(key, val) {
        if (key === 'searchVal' && val instanceof Set) {
            return Array.from(val);
        }
        return val;
    }
    getFeature(key) {
        const feature = this.FEATURES[key];
        return feature;
    }
}
IgxGridStateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxGridState]'
            },] }
];
IgxGridStateDirective.ctorParameters = () => [
    { type: IgxGridBaseDirective, decorators: [{ type: Host }, { type: Optional }] },
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef }
];
IgxGridStateDirective.propDecorators = {
    options: [{ type: Input, args: ['igxGridState',] }]
};
/**
 * @hidden
 */
class IgxGridStateModule {
}
IgxGridStateModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxGridStateDirective],
                exports: [IgxGridStateDirective]
            },] }
];

class IgxGridSharedModules {
}
IgxGridSharedModules.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    IgxButtonModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxFocusModule,
                    IgxToggleModule,
                    IgxForOfModule,
                    IgxTemplateOutletModule,
                    IgxTextHighlightModule,
                    IgxTextSelectionModule,
                    IgxCheckboxModule,
                    IgxBadgeModule,
                    IgxChipsModule,
                    IgxDragDropModule,
                    IgxDropDownModule,
                    IgxButtonGroupModule,
                    IgxProgressBarModule,
                    IgxSelectModule,
                    IgxGridStateModule,
                    IgxSnackbarModule
                ],
                exports: [
                    CommonModule,
                    FormsModule,
                    IgxButtonModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxFocusModule,
                    IgxToggleModule,
                    IgxForOfModule,
                    IgxTemplateOutletModule,
                    IgxTextHighlightModule,
                    IgxGridStateModule,
                    IgxTextSelectionModule,
                    IgxCheckboxModule,
                    IgxBadgeModule,
                    IgxChipsModule,
                    IgxDragDropModule,
                    IgxDropDownModule,
                    IgxButtonGroupModule,
                    IgxProgressBarModule,
                    IgxSelectModule,
                    IgxSnackbarModule
                ]
            },] }
];

class IgxSummaryDataPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(id, trigger = 0) {
        const summaryService = this.gridAPI.grid.summaryService;
        return summaryService.calculateSummaries(summaryService.rootSummaryID, this.gridAPI.get_summary_data());
    }
}
IgxSummaryDataPipe.decorators = [
    { type: Pipe, args: [{
                name: 'igxGridSummaryDataPipe',
                pure: true
            },] }
];
IgxSummaryDataPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

class IgxGridSummaryModule {
}
IgxGridSummaryModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxSummaryCellComponent,
                    IgxSummaryRowComponent,
                    IgxSummaryDataPipe
                ],
                imports: [
                    IgxGridPipesModule,
                    IgxGridSharedModules
                ],
                exports: [
                    IgxSummaryCellComponent,
                    IgxSummaryRowComponent,
                    IgxSummaryDataPipe
                ]
            },] }
];

class IgxColumnActionsBaseDirective {
}
IgxColumnActionsBaseDirective.decorators = [
    { type: Directive }
];

class IgxColumnHidingDirective extends IgxColumnActionsBaseDirective {
    constructor(columnActions) {
        super();
        this.columnActions = columnActions;
        /**
         * @hidden @internal
         */
        this.actionEnabledColumnsFilter = c => !c.disableHiding;
        columnActions.actionsDirective = this;
    }
    /**
     * @hidden @internal
     */
    get checkAllLabel() {
        var _a, _b;
        return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_hiding_check_all_label) !== null && _b !== void 0 ? _b : 'Show All';
    }
    /**
     * @hidden @internal
     */
    get uncheckAllLabel() {
        var _a, _b;
        return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_hiding_uncheck_all_label) !== null && _b !== void 0 ? _b : 'Hide All';
    }
    /**
     * @hidden @internal
     */
    checkAll() {
        this.columnActions.filteredColumns.forEach(c => c.toggleVisibility(false));
    }
    /**
     * @hidden @internal
     */
    uncheckAll() {
        this.columnActions.filteredColumns.forEach(c => c.toggleVisibility(true));
    }
    /**
     * @hidden @internal
     */
    columnChecked(column) {
        return !column.hidden;
    }
    /**
     * @hidden @internal
     */
    toggleColumn(column) {
        column.toggleVisibility();
    }
    get allChecked() {
        return this.columnActions.filteredColumns.every(col => !this.columnChecked(col));
    }
    get allUnchecked() {
        return this.columnActions.filteredColumns.every(col => this.columnChecked(col));
    }
}
IgxColumnHidingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxColumnHiding]'
            },] }
];
IgxColumnHidingDirective.ctorParameters = () => [
    { type: IgxColumnActionsComponent, decorators: [{ type: Inject, args: [IgxColumnActionsComponent,] }] }
];

class IgxColumnPinningDirective extends IgxColumnActionsBaseDirective {
    constructor(columnActions) {
        super();
        this.columnActions = columnActions;
        /**
         * @hidden @internal
         */
        this.actionEnabledColumnsFilter = (c) => !c.disablePinning && !c.level;
        columnActions.actionsDirective = this;
    }
    /**
     * @hidden @internal
     */
    get checkAllLabel() {
        var _a, _b;
        return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_pinning_check_all_label) !== null && _b !== void 0 ? _b : 'Pin All';
    }
    /**
     * @hidden @internal
     */
    get uncheckAllLabel() {
        var _a, _b;
        return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_pinning_uncheck_all_label) !== null && _b !== void 0 ? _b : 'Unpin All';
    }
    /**
     * @hidden @internal
     */
    checkAll() {
        this.columnActions.filteredColumns.forEach(c => c.pinned = true);
    }
    /**
     * @hidden @internal
     */
    uncheckAll() {
        this.columnActions.filteredColumns.forEach(c => c.pinned = false);
    }
    /**
     * @hidden @internal
     */
    columnChecked(column) {
        return column.pinned;
    }
    /**
     * @hidden @internal
     */
    toggleColumn(column) {
        column.pinned = !column.pinned;
    }
    get allUnchecked() {
        return !this.columnActions.filteredColumns.some(col => !this.columnChecked(col));
    }
    get allChecked() {
        return !this.columnActions.filteredColumns.some(col => this.columnChecked(col));
    }
}
IgxColumnPinningDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxColumnPinning]'
            },] }
];
IgxColumnPinningDirective.ctorParameters = () => [
    { type: IgxColumnActionsComponent, decorators: [{ type: Inject, args: [IgxColumnActionsComponent,] }] }
];

class IgxColumnActionsModule {
}
IgxColumnActionsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxColumnHidingDirective,
                    IgxColumnPinningDirective,
                    IgxColumnActionsComponent,
                ],
                imports: [
                    IgxGridSharedModules,
                    IgxGridPipesModule
                ],
                exports: [
                    IgxColumnHidingDirective,
                    IgxColumnPinningDirective,
                    IgxColumnActionsComponent
                ]
            },] }
];

/**
 * Provides a pre-configured button to open the advanced filtering dialog of the grid.
 *
 *
 * @igxModule IgxGridToolbarModule
 * @igxParent IgxGridToolbarComponent
 *
 * @example
 * ```html
 * <igx-grid-toolbar-advanced-filtering></igx-grid-toolbar-advanced-filtering>
 * <igx-grid-toolbar-advanced-filtering>Custom text</igx-grid-toolbar-advanced-filtering>
 * ```
 */
class IgxGridToolbarAdvancedFilteringComponent {
    constructor(toolbar) {
        this.toolbar = toolbar;
    }
    /**
     * Returns the grid containing this component.
     */
    get grid() {
        return this.toolbar.grid;
    }
}
IgxGridToolbarAdvancedFilteringComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-grid-toolbar-advanced-filtering',
                template: "<button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" name=\"btnAdvancedFiltering\" igxRipple\n    [title]=\"grid?.resourceStrings.igx_grid_toolbar_advanced_filtering_button_tooltip\"\n    (click)=\"grid.openAdvancedFilteringDialog()\"\n    [ngClass]=\"grid.advancedFilteringExpressionsTree ? 'igx-grid-toolbar__adv-filter--filtered' : 'igx-grid-toolbar__adv-filter'\">\n    <igx-icon>filter_list</igx-icon>\n    <span #ref>\n        <ng-content></ng-content>\n    </span>\n    <span *ngIf=\"!ref.childNodes.length\">{{ grid?.resourceStrings.igx_grid_toolbar_advanced_filtering_button_label }}</span>\n</button>\n"
            },] }
];
IgxGridToolbarAdvancedFilteringComponent.ctorParameters = () => [
    { type: IgxGridToolbarComponent, decorators: [{ type: Host }] }
];

/**
 * Base class for the pinning/hiding column and exporter actions.
 *
 * @hidden @internal
 */
class BaseToolbarDirective {
    constructor(toolbar) {
        this.toolbar = toolbar;
        /**
         * Emits an event before the toggle container is opened.
         */
        this.opening = new EventEmitter();
        /**
         * Emits an event after the toggle container is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Emits an event before the toggle container is closed.
         */
        this.closing = new EventEmitter();
        /**
         * Emits an event after the toggle container is closed.
         */
        this.closed = new EventEmitter();
        /**
         * Emits when after a column's checked state is changed
         */
        this.columnToggle = new EventEmitter();
        this.$destroyer = new Subject();
    }
    /**
     * Returns the grid containing this component.
     */
    get grid() {
        return this.toolbar.grid;
    }
    ngOnDestroy() {
        this.$destroyer.next(true);
    }
    /** @hidden @internal */
    toggle(anchorElement, toggleRef, actions) {
        if (actions) {
            this._setupListeners(toggleRef, actions);
            const setHeight = () => { var _a; return actions.columnsAreaMaxHeight = (_a = this.columnListHeight) !== null && _a !== void 0 ? _a : `${Math.max(this.grid.calcHeight, 200)}px`; };
            toggleRef.onOpening.pipe(first$1()).subscribe(setHeight);
        }
        toggleRef.toggle(Object.assign(Object.assign({}, _makeOverlaySettings()), { target: anchorElement, outlet: this.grid.outlet,
            excludeFromOutsideClick: [anchorElement] }));
    }
    /** @hidden @internal */
    focusSearch(columnActions) {
        var _a;
        (_a = columnActions.querySelector('input')) === null || _a === void 0 ? void 0 : _a.focus();
    }
    _setupListeners(toggleRef, actions) {
        if (actions) {
            if (!this.$sub || this.$sub.closed) {
                this.$sub = actions.onColumnToggled.subscribe((event) => this.columnToggle.emit(event));
            }
            else {
                this.$sub.unsubscribe();
            }
        }
        /** The if statement prevents emitting open and close events twice  */
        if (toggleRef.collapsed) {
            toggleRef.onOpening.pipe(first$1(), takeUntil(this.$destroyer)).subscribe((event) => this.opening.emit(event));
            toggleRef.onOpened.pipe(first$1(), takeUntil(this.$destroyer)).subscribe((event) => this.opened.emit(event));
        }
        else {
            toggleRef.onClosing.pipe(first$1(), takeUntil(this.$destroyer)).subscribe((event) => this.closing.emit(event));
            toggleRef.onClosed.pipe(first$1(), takeUntil(this.$destroyer)).subscribe((event) => this.closed.emit(event));
        }
    }
}
BaseToolbarDirective.decorators = [
    { type: Directive }
];
BaseToolbarDirective.ctorParameters = () => [
    { type: IgxGridToolbarComponent, decorators: [{ type: Host }] }
];
BaseToolbarDirective.propDecorators = {
    columnListHeight: [{ type: Input }],
    title: [{ type: Input }],
    prompt: [{ type: Input }],
    opening: [{ type: Output }],
    opened: [{ type: Output }],
    closing: [{ type: Output }],
    closed: [{ type: Output }],
    columnToggle: [{ type: Output }]
};
/**
 * @hidden @internal
 * Base class for pinning/hiding column actions
 */
class BaseToolbarColumnActionsDirective extends BaseToolbarDirective {
    constructor() {
        super(...arguments);
        this.hideFilter = false;
        this.filterCriteria = '';
        this.columnDisplayOrder = ColumnDisplayOrder.DisplayOrder;
        this.columnsAreaMaxHeight = '100%';
        this.indentetion = 30;
    }
    checkAll() {
        this.columnActionsUI.checkAllColumns();
    }
    uncheckAll() {
        this.columnActionsUI.uncheckAllColumns();
    }
}
BaseToolbarColumnActionsDirective.decorators = [
    { type: Directive }
];
BaseToolbarColumnActionsDirective.propDecorators = {
    hideFilter: [{ type: Input }],
    filterCriteria: [{ type: Input }],
    columnDisplayOrder: [{ type: Input }],
    columnsAreaMaxHeight: [{ type: Input }],
    uncheckAllText: [{ type: Input }],
    checkAllText: [{ type: Input }],
    indentetion: [{ type: Input }]
};
const _makeOverlaySettings = () => {
    const positionSettings = {
        horizontalDirection: HorizontalAlignment.Left,
        horizontalStartPoint: HorizontalAlignment.Right,
        verticalDirection: VerticalAlignment.Bottom,
        verticalStartPoint: VerticalAlignment.Bottom
    };
    return {
        positionStrategy: new ConnectedPositioningStrategy(positionSettings),
        scrollStrategy: new AbsoluteScrollStrategy(),
        modal: false,
        closeOnEscape: true,
        closeOnOutsideClick: true
    };
};
const ɵ0$5 = _makeOverlaySettings;

/**
 * Provides a pre-configured exporter component for the grid.
 *
 * @remarks
 * This component still needs the actual exporter service(s) provided in the DI chain
 * in order to export something.
 *
 * @igxModule IgxGridToolbarModule
 * @igxParent IgxGridToolbarComponent
 *
 */
class IgxGridToolbarExporterComponent extends BaseToolbarDirective {
    constructor(toolbar, excelExporter, csvExporter) {
        super(toolbar);
        this.toolbar = toolbar;
        this.excelExporter = excelExporter;
        this.csvExporter = csvExporter;
        /**
         * Show entry for CSV export.
         */
        this.exportCSV = true;
        /**
         * Show entry for Excel export.
         */
        this.exportExcel = true;
        /**
         * The name for the exported file.
         */
        this.filename = 'ExportedData';
        /**
         * Emitted when starting an export operation. Re-emitted additionally
         * by the grid itself.
         */
        this.exportStarted = new EventEmitter();
        /**
         * Emitted on successful ending of an export operation.
         */
        this.exportEnded = new EventEmitter();
        /**
         * Indicates whether there is an export in progress.
         */
        this.isExporting = false;
    }
    /**
     * Returns whether the CSV exporter service is available in the DI chain.
     */
    get hasCsvExporter() {
        return !!this.csvExporter;
    }
    /**
     * Returns whether the Excel exporter service is available in the DI chain.
     */
    get hasExcelExporter() {
        return !!this.excelExporter;
    }
    export(type, toggleRef) {
        let options;
        let exporter;
        toggleRef === null || toggleRef === void 0 ? void 0 : toggleRef.close();
        switch (type) {
            case 'csv':
                options = new IgxCsvExporterOptions(this.filename, CsvFileTypes.CSV);
                exporter = this.csvExporter;
                break;
            case 'excel':
                options = new IgxExcelExporterOptions(this.filename);
                exporter = this.excelExporter;
        }
        const args = { exporter, options, grid: this.grid, cancel: false };
        this.exportStarted.emit(args);
        this.grid.onToolbarExporting.emit(args);
        this.isExporting = true;
        this.toolbar.showProgress = true;
        if (args.cancel) {
            return;
        }
        exporter.exportEnded.pipe(first$1()).subscribe(() => {
            this.exportEnded.emit();
            this.isExporting = false;
            this.toolbar.showProgress = false;
        });
        exporter.export(this.grid, options);
    }
}
IgxGridToolbarExporterComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-grid-toolbar-exporter',
                template: "<div class=\"igx-grid-toolbar__dropdown\" id=\"btnExport\">\n    <button [title]=\"grid?.resourceStrings.igx_grid_toolbar_exporter_button_tooltip\" [disabled]=\"isExporting\"\n        igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" igxRipple #btn (click)=\"toggle(btn, toggleRef)\">\n        <igx-icon>import_export</igx-icon>\n        <span #ref>\n            <ng-content></ng-content>\n        </span>\n        <span *ngIf=\"!ref.childNodes.length\">\n            {{ grid.exportText || grid?.resourceStrings.igx_grid_toolbar_exporter_button_label }}\n        </span>\n        <igx-icon>arrow_drop_down</igx-icon>\n    </button>\n\n    <ul class=\"igx-grid-toolbar__dd-list\" igxToggle #toggleRef=\"toggle\">\n        <li *ngIf=\"grid.exportExcel || exportExcel\" #btnExportExcel id=\"btnExportExcel\"\n            class=\"igx-grid-toolbar__dd-list-items\" igxRipple (click)=\"export('excel', toggleRef)\">\n            <ng-template #excel>\n                <ng-content select=[excelText],excel-text></ng-content>\n            </ng-template>\n            <excel-text *ngIf=\"!hasExcelAttr\">\n                {{ grid.exportExcelText || grid?.resourceStrings.igx_grid_toolbar_exporter_excel_entry_text}}\n            </excel-text>\n            <ng-container *ngTemplateOutlet=\"excel\"></ng-container>\n        </li>\n\n        <li *ngIf=\"grid.exportCsv || exportCSV\" #btnExportCsv id=\"btnExportCsv\" class=\"igx-grid-toolbar__dd-list-items\"\n            igxRipple (click)=\"export('csv', toggleRef)\">\n            <ng-template #csv>\n                <ng-content select=[csvText],csv-text></ng-content>\n            </ng-template>\n            <csv-text *ngIf=\"!hasCSVAttr\">\n                {{ grid.exportCsvText || grid?.resourceStrings.igx_grid_toolbar_exporter_csv_entry_text }}</csv-text>\n            <ng-container *ngTemplateOutlet=\"csv\"></ng-container>\n        </li>\n    </ul>\n</div>\n"
            },] }
];
IgxGridToolbarExporterComponent.ctorParameters = () => [
    { type: IgxGridToolbarComponent, decorators: [{ type: Host }] },
    { type: IgxExcelExporterService, decorators: [{ type: Optional }] },
    { type: IgxCsvExporterService, decorators: [{ type: Optional }] }
];
IgxGridToolbarExporterComponent.propDecorators = {
    hasExcelAttr: [{ type: ContentChild, args: [IgxExcelTextDirective,] }],
    hasCSVAttr: [{ type: ContentChild, args: [IgxCSVTextDirective,] }],
    exportCSV: [{ type: Input }],
    exportExcel: [{ type: Input }],
    filename: [{ type: Input }],
    exportStarted: [{ type: Output }],
    exportEnded: [{ type: Output }]
};

/**
 * Provides a pre-configured column hiding component for the grid.
 *
 *
 * @igxModule IgxGridToolbarModule
 * @igxParent IgxGridToolbarComponent
 *
 * @example
 * ```html
 *  <igx-grid-toolbar-hiding></igx-grid-toolbar-hiding>
 * ```
 */
class IgxGridToolbarHidingComponent extends BaseToolbarColumnActionsDirective {
    set content(content) {
        this.columnActionsUI = content;
    }
}
IgxGridToolbarHidingComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-grid-toolbar-hiding',
                template: "<ng-container *ngIf=\"grid.rendered$ | async\">\n    <button [title]=\"grid?.resourceStrings.igx_grid_toolbar_hiding_button_tooltip\" #btn igxButton=\"outlined\"\n        name=\"btnColumnHiding\" (click)=\"toggle(btn, ref, actions)\" [displayDensity]=\"grid.displayDensity\">\n        <igx-icon>{{ !grid.hiddenColumnsCount ? 'visibility' : 'visibility_off' }}</igx-icon>\n        <span>{{ grid.hiddenColumnsCount }}</span>\n        <span>{{ grid.hiddenColumnsText }}</span>\n    </button>\n    <igx-column-actions #actions igxColumnHiding igxToggle (onOpened)=\"focusSearch(ref.element)\" #ref=\"toggle\"\n        [grid]=\"grid\" [title]=\"grid.columnHidingTitleInternal || title || grid?.resourceStrings.igx_grid_toolbar_hiding_title\"\n        [filterColumnsPrompt]=\"prompt || grid?.resourceStrings.igx_grid_toolbar_actions_filter_prompt\"\n        [hideFilter]=\"hideFilter\" [filterCriteria]=\"filterCriteria\" [columnDisplayOrder]=\"columnDisplayOrder\" [columnsAreaMaxHeight]=\"columnsAreaMaxHeight\"\n        [uncheckAllText]=\"uncheckAllText\" [checkAllText]=\"checkAllText\" [indentation]=\"indentetion\">\n    </igx-column-actions>\n</ng-container>\n"
            },] }
];
IgxGridToolbarHidingComponent.propDecorators = {
    content: [{ type: ViewChild, args: [IgxColumnHidingDirective, { read: IgxColumnActionsComponent },] }]
};

/**
 * Provides a pre-configured column pinning component for the grid.
 *
 *
 * @igxModule IgxGridToolbarModule
 * @igxParent IgxGridToolbarComponent
 *
 * @example
 * ```html
 *  <igx-grid-toolbar-pinning></igx-grid-toolbar-pinning>
 * ```
 */
class IgxGridToolbarPinningComponent extends BaseToolbarColumnActionsDirective {
    set content(content) {
        this.columnActionsUI = content;
    }
}
IgxGridToolbarPinningComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-grid-toolbar-pinning',
                template: "<ng-container *ngIf=\"grid.rendered$ | async\">\n    <button [title]=\"grid?.resourceStrings.igx_grid_toolbar_pinning_button_tooltip\" #btn igxButton=\"outlined\"\n        name=\"btnColumnPinning\" (click)=\"toggle(btn, ref, actions)\" [displayDensity]=\"grid.displayDensity\">\n        <igx-icon family=\"imx-icons\" [name]=\"!grid.pinnedColumnsCount ? 'unpin-left' : 'pin-left'\"></igx-icon>\n        <span>{{ grid.pinnedColumnsCount }}</span>\n        <span>{{ grid.pinnedColumnsTextInternal }}</span>\n    </button>\n    <igx-column-actions #actions igxColumnPinning igxToggle (onOpened)=\"focusSearch(ref.element)\" #ref=\"toggle\"\n        [grid]=\"grid\" [title]=\"grid.columnPinningTitleInternal || title || grid?.resourceStrings.igx_grid_toolbar_pinning_title\"\n        [filterColumnsPrompt]=\"prompt || grid?.resourceStrings.igx_grid_toolbar_actions_filter_prompt\"\n        [hideFilter]=\"hideFilter\" [filterCriteria]=\"filterCriteria\" [columnDisplayOrder]=\"columnDisplayOrder\" [columnsAreaMaxHeight]=\"columnsAreaMaxHeight\"\n        [uncheckAllText]=\"uncheckAllText\" [checkAllText]=\"checkAllText\" [indentation]=\"indentetion\">\n    </igx-column-actions>\n</ng-container>\n"
            },] }
];
IgxGridToolbarPinningComponent.propDecorators = {
    content: [{ type: ViewChild, args: [IgxColumnPinningDirective, { read: IgxColumnActionsComponent },] }]
};

class IgxGridToolbarModule {
}
IgxGridToolbarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxCSVTextDirective,
                    IgxExcelTextDirective,
                    IgxGridToolbarActionsDirective,
                    IgxGridToolbarAdvancedFilteringComponent,
                    IgxGridToolbarComponent,
                    IgxGridToolbarExporterComponent,
                    IgxGridToolbarHidingComponent,
                    IgxGridToolbarPinningComponent,
                    IgxGridToolbarTitleDirective,
                    IgxGridToolbarDirective
                ],
                imports: [
                    IgxColumnActionsModule,
                    IgxGridSharedModules
                ],
                exports: [
                    IgxCSVTextDirective,
                    IgxExcelTextDirective,
                    IgxGridToolbarActionsDirective,
                    IgxGridToolbarAdvancedFilteringComponent,
                    IgxGridToolbarComponent,
                    IgxGridToolbarExporterComponent,
                    IgxGridToolbarHidingComponent,
                    IgxGridToolbarPinningComponent,
                    IgxGridToolbarTitleDirective,
                    IgxGridToolbarDirective
                ]
            },] }
];

class IgxColumnLayoutComponent extends IgxColumnGroupComponent {
    constructor() {
        super(...arguments);
        this.childrenVisibleIndexes = [];
    }
    /**
     * Gets the width of the column layout.
     * ```typescript
     * let columnGroupWidth = this.columnGroup.width;
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    get width() {
        const width = this.getFilledChildColumnSizes(this.children).reduce((acc, val) => acc + parseInt(val, 10), 0);
        return width;
    }
    set width(val) { }
    get columnLayout() {
        return true;
    }
    /**
     * @hidden
     */
    getCalcWidth() {
        let borderWidth = 0;
        if (this.headerGroup && this.headerGroup.hasLastPinnedChildColumn) {
            const headerStyles = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement.children[0]);
            borderWidth = parseInt(headerStyles.borderRightWidth, 10);
        }
        return super.getCalcWidth() + borderWidth;
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => c.columnLayout && !c.hidden);
        const pinnedColumns = this.grid.pinnedColumns.filter(c => c.columnLayout && !c.hidden);
        let vIndex = -1;
        if (!this.pinned) {
            const indexInCollection = unpinnedColumns.indexOf(this);
            vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
        }
        else {
            vIndex = pinnedColumns.indexOf(this);
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /*
     * Gets whether the column layout is hidden.
     * ```typescript
     * let isHidden = this.columnGroup.hidden;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column layout hidden property.
     * ```typescript
     * <igx-column-layout [hidden] = "true"></igx-column->
     * ```
     *
     * @memberof IgxColumnGroupComponent
     */
    set hidden(value) {
        this._hidden = value;
        this.children.forEach(child => child.hidden = value);
        if (this.grid && this.grid.columns && this.grid.columns.length > 0) {
            // reset indexes in case columns are hidden/shown runtime
            const columns = this.grid && this.grid.pinnedColumns && this.grid.unpinnedColumns ?
                this.grid.pinnedColumns.concat(this.grid.unpinnedColumns) : [];
            if (!this._hidden && !columns.find(c => c.field === this.field)) {
                this.grid.resetColumnCollections();
            }
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (!this.hidden) {
            this.hidden = this.allChildren.some(x => x.hidden);
        }
        else {
            this.children.forEach(child => child.hidden = this.hidden);
        }
        this.children.forEach(child => {
            child.movable = false;
        });
    }
    /*
     * Gets whether the group contains the last pinned child column of the column layout.
     * ```typescript
     * let columsHasLastPinned = this.columnLayout.hasLastPinnedChildColumn;
     * ```
     * @memberof IgxColumnLayoutComponent
     */
    get hasLastPinnedChildColumn() {
        return this.children.some(child => child.isLastPinned);
    }
    /*
     * Gets whether the group contains the first pinned child column of the column layout.
     * ```typescript
     * let hasFirstPinnedChildColumn = this.columnLayout.hasFirstPinnedChildColumn;
     * ```
     * @memberof IgxColumnLayoutComponent
     */
    get hasFirstPinnedChildColumn() {
        return this.children.some(child => child.isFirstPinned);
    }
    /**
     * @hidden
     */
    populateVisibleIndexes() {
        this.childrenVisibleIndexes = [];
        const grid = this.gridAPI.grid;
        const columns = grid && grid.pinnedColumns && grid.unpinnedColumns ? grid.pinnedColumns.concat(grid.unpinnedColumns) : [];
        const orderedCols = columns
            .filter(x => !x.columnGroup && !x.hidden)
            .sort((a, b) => a.rowStart - b.rowStart || columns.indexOf(a.parent) - columns.indexOf(b.parent) || a.colStart - b.colStart);
        this.children.forEach(child => {
            const rs = child.rowStart || 1;
            let vIndex = 0;
            // filter out all cols with larger rowStart
            const cols = orderedCols.filter(c => !c.columnGroup && (c.rowStart || 1) <= rs);
            vIndex = cols.indexOf(child);
            this.childrenVisibleIndexes.push({ column: child, index: vIndex });
        });
    }
}
IgxColumnLayoutComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: IgxColumnComponent, useExisting: forwardRef(() => IgxColumnLayoutComponent) }],
                selector: 'igx-column-layout',
                template: ``
            },] }
];
IgxColumnLayoutComponent.propDecorators = {
    hidden: [{ type: Input }]
};

class IgxGridColumnModule {
}
IgxGridColumnModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxFilterCellTemplateDirective,
                    IgxCellTemplateDirective,
                    IgxCellHeaderTemplateDirective,
                    IgxCellFooterTemplateDirective,
                    IgxCellEditorTemplateDirective,
                    IgxCollapsibleIndicatorTemplateDirective,
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent
                ],
                entryComponents: [
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent
                ],
                exports: [
                    IgxFilterCellTemplateDirective,
                    IgxCellTemplateDirective,
                    IgxCellHeaderTemplateDirective,
                    IgxCellFooterTemplateDirective,
                    IgxCellEditorTemplateDirective,
                    IgxCollapsibleIndicatorTemplateDirective,
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent
                ]
            },] }
];

class IgxGridFilteringModule {
}
IgxGridFilteringModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxGridFilteringCellComponent,
                    IgxGridFilteringRowComponent
                ],
                imports: [
                    IgxGridSharedModules,
                    IgxGridPipesModule
                ],
                exports: [
                    IgxGridFilteringCellComponent,
                    IgxGridFilteringRowComponent
                ]
            },] }
];

class SortingIndexPipe {
    transform(columnField, sortingExpressions) {
        let sortIndex = sortingExpressions.findIndex(expression => expression.fieldName === columnField);
        return sortIndex !== -1 ? ++sortIndex : null;
    }
}
SortingIndexPipe.decorators = [
    { type: Pipe, args: [{
                name: 'sortingIndex',
                pure: true
            },] }
];

class IgxGridHeadersModule {
}
IgxGridHeadersModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxGridHeaderComponent,
                    IgxGridHeaderGroupComponent,
                    SortingIndexPipe
                ],
                imports: [
                    IgxGridSharedModules,
                    IgxGridFilteringModule,
                    IgxColumnMovingModule,
                    IgxGridResizingModule
                ],
                exports: [
                    IgxGridHeaderComponent,
                    IgxGridHeaderGroupComponent
                ]
            },] }
];

/**
 * @hidden
 */
class IgxGridCommonModule {
}
IgxGridCommonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxRowDirective,
                    IgxGridCellComponent,
                    IgxRowEditTemplateDirective,
                    IgxRowEditActionsDirective,
                    IgxRowEditTextDirective,
                    IgxRowEditTabStopDirective,
                    IgxGridBodyDirective,
                    IgxGridFooterComponent,
                    IgxAdvancedFilteringDialogComponent,
                    IgxRowExpandedIndicatorDirective,
                    IgxRowCollapsedIndicatorDirective,
                    IgxHeaderExpandIndicatorDirective,
                    IgxHeaderCollapseIndicatorDirective,
                    IgxExcelStyleHeaderIconDirective,
                ],
                entryComponents: [
                    IgxAdvancedFilteringDialogComponent
                ],
                exports: [
                    IgxGridCellComponent,
                    IgxRowEditTemplateDirective,
                    IgxRowEditActionsDirective,
                    IgxRowEditTextDirective,
                    IgxRowEditTabStopDirective,
                    IgxGridBodyDirective,
                    IgxColumnActionsModule,
                    IgxGridColumnModule,
                    IgxGridHeadersModule,
                    IgxGridPipesModule,
                    IgxGridFilteringModule,
                    IgxGridExcelStyleFilteringModule,
                    IgxRowDragModule,
                    IgxPaginatorModule,
                    IgxGridFooterComponent,
                    IgxGridResizingModule,
                    IgxColumnMovingModule,
                    IgxGridSelectionModule,
                    IgxGridSummaryModule,
                    IgxGridToolbarModule,
                    IgxAdvancedFilteringDialogComponent,
                    IgxGridSharedModules,
                    IgxRowExpandedIndicatorDirective,
                    IgxRowCollapsedIndicatorDirective,
                    IgxHeaderExpandIndicatorDirective,
                    IgxHeaderCollapseIndicatorDirective,
                    IgxExcelStyleHeaderIconDirective,
                ],
                imports: [
                    IgxGridColumnModule,
                    IgxGridHeadersModule,
                    IgxColumnMovingModule,
                    IgxGridResizingModule,
                    IgxGridSelectionModule,
                    IgxGridSummaryModule,
                    IgxGridToolbarModule,
                    IgxColumnActionsModule,
                    IgxGridPipesModule,
                    IgxGridFilteringModule,
                    IgxGridExcelStyleFilteringModule,
                    IgxRowDragModule,
                    IgxPaginatorModule,
                    IgxGridSharedModules
                ],
                providers: [
                    { provide: IgxGridTransaction, useClass: IgxBaseTransactionService }
                ]
            },] }
];

/**
 * @hidden
 */
class IgxGridSortingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, expressions, sorting, id, pipeTrigger, pinned) {
        const grid = this.gridAPI.grid;
        let result;
        if (!expressions.length) {
            result = collection;
        }
        else {
            result = DataUtil.sort(cloneArray(collection), expressions, sorting, grid);
        }
        grid.setFilteredSortedData(result, pinned);
        return result;
    }
}
IgxGridSortingPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridSort',
                pure: true
            },] }
];
IgxGridSortingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxGridGroupingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, expression, expansion, defaultExpanded, id, groupsRecords, pipeTrigger) {
        const state = { expressions: [], expansion: [], defaultExpanded };
        const grid = this.gridAPI.grid;
        state.expressions = grid.groupingExpressions;
        let result;
        const fullResult = { data: [], metadata: [] };
        if (!state.expressions.length) {
            // empty the array without changing reference
            groupsRecords.splice(0, groupsRecords.length);
            result = {
                data: collection,
                metadata: collection
            };
        }
        else {
            state.expansion = grid.groupingExpansionState;
            state.defaultExpanded = grid.groupsExpanded;
            result = DataUtil.group(cloneArray(collection), state, grid, groupsRecords, fullResult);
        }
        grid.groupingFlatResult = result.data;
        grid.groupingResult = fullResult.data;
        grid.groupingMetadata = fullResult.metadata;
        return result;
    }
}
IgxGridGroupingPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridGroupBy',
                pure: true
            },] }
];
IgxGridGroupingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxGridPagingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, page = 0, perPage = 15, id, pipeTrigger) {
        if (!this.gridAPI.grid.paging || this.gridAPI.grid.pagingMode !== GridPagingMode.Local) {
            return collection;
        }
        const state = {
            index: page,
            recordsPerPage: perPage
        };
        const total = this.gridAPI.grid._totalRecords >= 0 ? this.gridAPI.grid._totalRecords : collection.data.length;
        DataUtil.correctPagingState(state, total);
        const result = {
            data: DataUtil.page(cloneArray(collection.data), state, total),
            metadata: DataUtil.page(cloneArray(collection.metadata), state, total)
        };
        if (this.gridAPI.grid.page !== state.index) {
            this.gridAPI.grid.page = state.index;
        }
        this.gridAPI.grid.pagingState = state;
        return result;
    }
}
IgxGridPagingPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridPaging',
                pure: true
            },] }
];
IgxGridPagingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxGridFilteringPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, expressionsTree, filterStrategy, advancedExpressionsTree, id, pipeTrigger, filteringPipeTrigger, pinned) {
        const grid = this.gridAPI.grid;
        const state = {
            expressionsTree,
            strategy: filterStrategy,
            advancedExpressionsTree
        };
        if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
            return collection;
        }
        const result = DataUtil.filter(cloneArray(collection), state, grid);
        grid.setFilteredData(result, pinned);
        return result;
    }
}
IgxGridFilteringPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridFiltering',
                pure: true
            },] }
];
IgxGridFilteringPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

class IgxGridRowComponent extends IgxRowDirective {
    get hasColumnLayouts() {
        return this.grid.hasColumnLayouts;
    }
    getContext(col, row) {
        return {
            $implicit: col,
            row
        };
    }
    get mrlRightPinnedOffset() {
        return !this.grid.isPinningToStart ?
            -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' :
            null;
    }
    getContextMRL(pinnedCols, row) {
        return {
            $implicit: pinnedCols,
            row
        };
    }
    get expanded() {
        return this.gridAPI.get_row_expansion_state(this.rowData);
    }
}
IgxGridRowComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-row',
                template: "<ng-container *ngTemplateOutlet='addRow ? addTemp : defaultTemp'></ng-container>\n\n<ng-template #addTemp>\n    <div class='igx-grid__tr--inner' [class.igx-grid__tr--add-animate]='animateAdd' (animationend)='animationEndHandler()'>\n        <ng-container *ngTemplateOutlet='defaultTemp'></ng-container>\n    </div>\n</ng-template>\n<ng-template #defaultTemp>\n    <ng-container *ngIf=\"rowDraggable\">\n        <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n            <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n        </div>\n    </ng-container>\n    <ng-container *ngIf=\"this.showRowSelectors\">\n        <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" (pointerdown)=\"$event.preventDefault()\" (click)=\"onRowSelectorClick($event)\">\n            <ng-template *ngTemplateOutlet=\"\n                this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n                context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n            </ng-template>\n        </div>\n    </ng-container>\n    <ng-container *ngIf=\"grid.groupingExpressions.length > 0\">\n        <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{grid.groupingExpressions.length}}\" (pointerdown)=\"$event.preventDefault()\" (click)=\"$event.stopPropagation()\"></div>\n    </ng-container>\n\n\n    <ng-container *ngIf=\"!grid.hasColumnLayouts\">\n        <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n            <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n                    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n            </ng-template>\n        </ng-container>\n        <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n            <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n        </ng-template>\n        <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n            <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n                    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n            </ng-template>\n        </ng-container>\n    </ng-container>\n\n    <ng-container *ngIf=\"grid.hasColumnLayouts\">\n        <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n            <ng-container *ngTemplateOutlet=\"mrlPinnedTemplate; context: getContextMRL(pinnedColumns, this)\"></ng-container>\n        </ng-container>\n        <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n            <div class=\"igx-grid__mrl-block\" [ngStyle]=\"{\n                'grid-template-rows':col.getGridTemplate(true, false),\n                'grid-template-columns':col.getGridTemplate(false, false),\n                '-ms-grid-rows':col.getGridTemplate(true, true),\n                '-ms-grid-columns':col.getGridTemplate(false, true)\n            }\">\n                <ng-template ngFor let-col [ngForOf]=\"col.children\">\n                        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? mrlExpandableCellTemplate : mrlCellTemplate; context: getContext(col, this)\"></ng-container>\n                </ng-template>\n            </div>\n        </ng-template>\n\n        <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n            <ng-container *ngTemplateOutlet=\"mrlPinnedTemplate; context: getContextMRL(pinnedColumns, this)\"></ng-container>\n        </ng-container>\n    </ng-container>\n</ng-template>\n\n<ng-template #mrlPinnedTemplate let-pinnedColumns>\n    <div *ngFor=\"let col of pinnedColumns | igxTopLevel\" class=\"igx-grid__mrl-block\"\n    [class.igx-grid__td--pinned-last]=\"col.hasLastPinnedChildColumn\"\n    [class.igx-grid__td--pinned-first]=\"col.hasFirstPinnedChildColumn\"\n    [style.left]=\"mrlRightPinnedOffset\"\n    [ngStyle]=\"{\n        'grid-template-rows':col.getGridTemplate(true, false),\n        'grid-template-columns':col.getGridTemplate(false, false),\n        'z-index': col.pinned ? 1 : null,\n        '-ms-grid-rows':col.getGridTemplate(true, true),\n        '-ms-grid-columns':col.getGridTemplate(false, true)\n    }\">\n        <ng-template ngFor let-col [ngForOf]=\"col.children\">\n                <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails? mrlExpandableCellTemplate : mrlCellTemplate; context: getContext(col, this)\"></ng-container>\n        </ng-template>\n    </div>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [checked]=\"selected\"\n            [readonly]=\"true\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<ng-template #cellTemplate let-col>\n        <igx-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [firstPinned]=\"col.columnLayoutChild ? null : col.isFirstPinned\"\n        [style.min-height.px]=\"cellHeight\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [style.left]=\"col.rightPinnedOffset\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #expandableCellTemplate let-col>\n    <igx-expandable-grid-cell\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n        [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [expanded]=\"expanded\"\n        [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [style.min-height.px]=\"cellHeight\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-expandable-grid-cell>\n</ng-template>\n\n<ng-template #mrlCellTemplate let-col>\n    <igx-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n        [column]=\"col\"\n        [style.-ms-grid-row-span]=\"col.gridRowSpan\"\n        [style.-ms-grid-column-span]=\"col.gridColumnSpan\"\n        [style.grid-row-end]=\"col.rowEnd\"\n        [style.grid-column-end]=\"col.colEnd\"\n        [style.-ms-grid-row]=\"col.rowStart\"\n        [style.grid-row-start]=\"col.rowStart\"\n        [style.-ms-grid-column]=\"col.colStart\"\n        [style.grid-column-start]=\"col.colStart\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [firstPinned]=\"col.columnLayoutChild ? null : col.isFirstPinned\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"cellHeight\"\n        [rowData]=\"rowData\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #mrlExpandableCellTemplate let-col>\n    <igx-expandable-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n        [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [expanded]=\"expanded\"\n        [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n        [column]=\"col\"\n        [style.-ms-grid-row-span]=\"col.gridRowSpan\"\n        [style.-ms-grid-column-span]=\"col.gridColumnSpan\"\n        [style.grid-row-end]=\"col.rowEnd\"\n        [style.grid-column-end]=\"col.colEnd\"\n        [style.-ms-grid-row]=\"col.rowStart\"\n        [style.grid-row-start]=\"col.rowStart\"\n        [style.-ms-grid-column]=\"col.colStart\"\n        [style.grid-column-start]=\"col.colStart\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"cellHeight\"\n        [rowData]=\"rowData\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-expandable-grid-cell>\n</ng-template>\n",
                providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxGridRowComponent) }]
            },] }
];
IgxGridRowComponent.propDecorators = {
    hasColumnLayouts: [{ type: HostBinding, args: ['class.igx-grid__tr--mrl',] }]
};

/** @hidden */
class IgxGridSummaryPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, hasSummary, summaryCalculationMode, summaryPosition, id, showSummary, pipeTrigger, summaryPipeTrigger) {
        if (!collection.data || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
            return collection.data;
        }
        return this.addSummaryRows(id, collection, summaryPosition, showSummary);
    }
    addSummaryRows(gridId, collection, summaryPosition, showSummary) {
        const recordsWithSummary = [];
        const lastChildMap = new Map();
        const grid = this.gridAPI.grid;
        const maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
        if (collection.metadata.length && !grid.isGroupByRecord(collection.data[0]) &&
            grid.isGroupByRecord(collection.metadata[0]) && summaryPosition === GridSummaryPosition.bottom) {
            const groups = [];
            groups.push(collection.metadata[0]);
            while (groups[groups.length - 1].groupParent) {
                groups.push(groups[groups.length - 1].groupParent);
            }
            groups.reverse();
            groups.forEach(g => g.skip = true);
            collection.data.splice(0, 0, ...groups);
        }
        for (const record of collection.data) {
            let skipAdd = false;
            let recordId;
            let groupByRecord = null;
            if (grid.isGroupByRecord(record)) {
                skipAdd = !!record.skip;
                record.skip = null;
                groupByRecord = record;
                recordId = this.gridAPI.get_groupBy_record_id(groupByRecord);
            }
            else {
                recordId = this.gridAPI.get_row_id(record);
            }
            if (!skipAdd) {
                recordsWithSummary.push(record);
            }
            if (summaryPosition === GridSummaryPosition.bottom && showSummary && (groupByRecord && !grid.isExpandedGroup(groupByRecord))) {
                const records = this.removeDeletedRecord(grid, groupByRecord.records.slice());
                const summaries = grid.summaryService.calculateSummaries(recordId, records);
                const summaryRecord = {
                    summaries,
                    max: maxSummaryHeight
                };
                recordsWithSummary.push(summaryRecord);
            }
            if (summaryPosition === GridSummaryPosition.bottom && lastChildMap.has(recordId)) {
                const groupRecords = lastChildMap.get(recordId);
                for (const groupRecord of groupRecords) {
                    const groupRecordId = this.gridAPI.get_groupBy_record_id(groupRecord);
                    const records = this.removeDeletedRecord(grid, groupRecord.records.slice());
                    const summaries = grid.summaryService.calculateSummaries(groupRecordId, records);
                    const summaryRecord = {
                        summaries,
                        max: maxSummaryHeight
                    };
                    recordsWithSummary.push(summaryRecord);
                }
            }
            const showSummaries = showSummary ? false : (groupByRecord && !grid.isExpandedGroup(groupByRecord));
            if (groupByRecord === null || showSummaries) {
                continue;
            }
            if (summaryPosition === GridSummaryPosition.top) {
                const records = this.removeDeletedRecord(grid, groupByRecord.records.slice());
                const summaries = grid.summaryService.calculateSummaries(recordId, records);
                const summaryRecord = {
                    summaries,
                    max: maxSummaryHeight
                };
                recordsWithSummary.push(summaryRecord);
            }
            else if (summaryPosition === GridSummaryPosition.bottom) {
                let lastChild = groupByRecord;
                while (lastChild.groups && lastChild.groups.length > 0 && grid.isExpandedGroup(lastChild)) {
                    lastChild = lastChild.groups[lastChild.groups.length - 1];
                }
                let lastChildId;
                if (grid.isExpandedGroup(lastChild)) {
                    lastChildId = this.gridAPI.get_row_id(lastChild.records[lastChild.records.length - 1]);
                }
                else {
                    lastChildId = this.gridAPI.get_groupBy_record_id(lastChild);
                }
                let groupRecords = lastChildMap.get(lastChildId);
                if (!groupRecords) {
                    groupRecords = [];
                    lastChildMap.set(lastChildId, groupRecords);
                }
                groupRecords.unshift(groupByRecord);
            }
        }
        return recordsWithSummary;
    }
    removeDeletedRecord(grid, data) {
        if (!grid.transactions.enabled) {
            return data;
        }
        const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === 'delete').map(t => t.id);
        deletedRows.forEach(rowID => {
            const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
            const index = tempData.indexOf(rowID);
            if (index !== -1) {
                data.splice(index, 1);
            }
        });
        return data;
    }
}
IgxGridSummaryPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridSummary',
                pure: true
            },] }
];
IgxGridSummaryPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/** @hidden */
class IgxGridDetailsPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, hasDetails, expansionStates, pipeTrigger) {
        if (!hasDetails) {
            return collection;
        }
        const res = this.addDetailRows(collection, expansionStates);
        return res;
    }
    addDetailRows(collection, expansionStates) {
        const result = [];
        collection.forEach((v) => {
            result.push(v);
            if (!this.gridAPI.grid.isGroupByRecord(v) && !this.gridAPI.grid.isSummaryRow(v) &&
                this.gridAPI.get_row_expansion_state(v)) {
                const detailsObj = { detailsData: v };
                result.push(detailsObj);
            }
        });
        return result;
    }
}
IgxGridDetailsPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridDetails',
                pure: true
            },] }
];
IgxGridDetailsPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

class IgxGridExpandableCellComponent extends IgxGridCellComponent {
    constructor(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil) {
        super(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil);
        this.zone = zone;
        this.document = document;
        this.platformUtil = platformUtil;
        /**
         * @hidden
         */
        this.expanded = false;
    }
    /**
     * @hidden
     */
    toggle(event) {
        event.stopPropagation();
        const expansionState = this.gridAPI.get_row_expansion_state(this.row.rowData);
        this.gridAPI.set_row_expansion_state(this.row.rowID, !expansionState, event);
    }
    /**
     * @hidden
     */
    onIndicatorFocus(event) {
        this.gridAPI.submit_value(event);
    }
    /**
     * @hidden
     */
    calculateSizeToFit(range) {
        const indicatorWidth = this.indicator.nativeElement.getBoundingClientRect().width;
        const indicatorStyle = this.document.defaultView.getComputedStyle(this.indicator.nativeElement);
        const indicatorMargin = parseFloat(indicatorStyle.marginRight);
        let leftPadding = 0;
        if (this.indentationDiv) {
            const indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);
            leftPadding = parseFloat(indentationStyle.paddingLeft);
        }
        const largestWidth = Math.max(...Array.from(this.nativeElement.children)
            .map((child) => getNodeSizeViaRange(range, child)));
        return largestWidth + indicatorWidth + indicatorMargin + leftPadding;
    }
    /**
     * @hidden
     */
    get iconTemplate() {
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    /**
     * @hidden
     */
    get showExpanderIndicator() {
        const isGhost = this.row.pinned && this.row.disabled;
        return !this.editMode && (!this.row.pinned || isGhost);
    }
}
IgxGridExpandableCellComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-expandable-grid-cell',
                template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip *ngIf=\"displayPinnedChip\" class=\"igx-grid__td--pinned-chip\" [disabled]=\"true\" [displayDensity]=\"'compact'\">{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip>\n</ng-template>\n<ng-template #defaultCell>\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n        [cssClass]=\"highlightClass\"\n        [activeCssClass]=\"activeHighlightClass\"\n        [groupName]=\"gridID\"\n        [value]=\"formatter ? (value | columnFormatter: formatter)\n            : column.dataType === 'number'\n            ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n            : column.dataType === 'date'\n            ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n            : column.dataType === 'currency'\n            ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n            : column.dataType === 'percent' ? (value | percent:column.pipeArgs.digitsInfo:grid.locale) : value\"\n        [row]=\"rowData\"\n        [column]=\"this.column.field\"\n        [containerClass]=\"'igx-grid__td-text'\"\n        [metadata]=\"searchMetadata\">{{ formatter ? (value | columnFormatter: formatter) : column.dataType === \"number\"\n            ? (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === \"date\"\n            ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : column.dataType === 'currency'\n            ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'percent'\n            ? (value | percent:column.pipeArgs.digitsInfo:grid.locale) : value }}</div>\n</ng-template>\n<ng-template #addRowCell let-cell=\"cell\">\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n    [cssClass]=\"highlightClass\"\n    [activeCssClass]=\"activeHighlightClass\"\n    [groupName]=\"gridID\"\n    [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ?\n        (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ?\n        (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : column.dataType === 'currency'?\n        (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'percent' ?\n        (value | percent:column.pipeArgs.digitsInfo:grid.locale) : value\"\n    [row]=\"rowData\"\n    [column]=\"this.column.field\"\n    [containerClass]=\"'igx-grid__td-text'\"\n    [metadata]=\"searchMetadata\">{{\n        value ? value : (column.header || column.field)\n    }}</div>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"true\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"true\" [step]=\"step\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outlet\" mode=\"dropdown\"\n        [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"true\" [labelVisibility]=\"false\">\n    </igx-date-picker>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'currency'\">\n        <igx-input-group displayDensity=\"compact\">\n            <igx-prefix *ngIf=\"grid.currencyPositionLeft\">{{ currencyCodeSymbol }}</igx-prefix>\n            <input  igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\" [step]=\"step\" type=\"number\"/>\n            <igx-suffix *ngIf=\"!grid.currencyPositionLeft\" >{{ currencyCodeSymbol }}</igx-suffix>\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'percent'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\" [step]=\"step\"\n                [igxFocus]=\"true\" type=\"number\"/>\n            <igx-suffix> {{ editValue | percent:column.pipeArgs.digitsInfo:grid.locale }} </igx-suffix>\n        </igx-input-group>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"showExpanderIndicator\">\n    <div #indicator\n         class=\"igx-grid__tree-grouping-indicator\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus($event)\">\n         <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n    </div>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon>expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon>chevron_right</igx-icon>\n</ng-template>\n",
                providers: [HammerGesturesManager]
            },] }
];
IgxGridExpandableCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: HammerGesturesManager },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: PlatformUtil }
];
IgxGridExpandableCellComponent.propDecorators = {
    expanded: [{ type: Input }],
    indicator: [{ type: ViewChild, args: ['indicator', { read: ElementRef },] }],
    indentationDiv: [{ type: ViewChild, args: ['indentationDiv', { read: ElementRef },] }],
    defaultExpandedTemplate: [{ type: ViewChild, args: ['defaultExpandedTemplate', { read: TemplateRef, static: true },] }],
    defaultCollapsedTemplate: [{ type: ViewChild, args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true },] }]
};

/**
 * @hidden
 */
class IgxGridModule {
}
IgxGridModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxGridComponent,
                    IgxGridRowComponent,
                    IgxGridGroupByRowComponent,
                    IgxGroupByRowTemplateDirective,
                    IgxGridDetailTemplateDirective,
                    IgxGroupAreaDropDirective,
                    IgxGridGroupingPipe,
                    IgxGridPagingPipe,
                    IgxGridSortingPipe,
                    IgxGridFilteringPipe,
                    IgxGridSummaryPipe,
                    IgxGridDetailsPipe,
                    IgxGridExpandableCellComponent
                ],
                exports: [
                    IgxGridComponent,
                    IgxGridExpandableCellComponent,
                    IgxGridGroupByRowComponent,
                    IgxGridRowComponent,
                    IgxGroupByRowTemplateDirective,
                    IgxGridDetailTemplateDirective,
                    IgxGroupAreaDropDirective,
                    IgxGridGroupingPipe,
                    IgxGridPagingPipe,
                    IgxGridSortingPipe,
                    IgxGridFilteringPipe,
                    IgxGridSummaryPipe,
                    IgxGridDetailsPipe,
                    IgxGridCommonModule
                ],
                imports: [
                    IgxGridCommonModule,
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

class IgxTreeGridAPIService extends GridBaseAPIService {
    get_all_data(transactions) {
        const grid = this.grid;
        let data = grid && grid.flatData ? grid.flatData : [];
        data = transactions ? grid.dataWithAddedInTransactionRows : data;
        return data;
    }
    get_summary_data() {
        const grid = this.grid;
        const data = grid.processedRootRecords.filter(row => row.isFilteredOutParent === undefined || row.isFilteredOutParent === false)
            .map(rec => rec.data);
        if (grid.transactions.enabled) {
            const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === TransactionType.DELETE).map(t => t.id);
            deletedRows.forEach(rowID => {
                const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
                const index = tempData.indexOf(rowID);
                if (index !== -1) {
                    data.splice(index, 1);
                }
            });
        }
        return data;
    }
    allow_expansion_state_change(rowID, expanded) {
        const grid = this.grid;
        const row = grid.records.get(rowID);
        if (row.expanded === expanded ||
            ((!row.children || !row.children.length) && (!grid.loadChildrenOnDemand ||
                (grid.hasChildrenKey && !row.data[grid.hasChildrenKey])))) {
            return false;
        }
        return true;
    }
    expand_path_to_record(record) {
        const grid = this.grid;
        const expandedStates = grid.expansionStates;
        while (record.parent) {
            record = record.parent;
            const expanded = this.get_row_expansion_state(record);
            if (!expanded) {
                expandedStates.set(record.rowID, true);
            }
        }
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(false);
        }
    }
    get_row_expansion_state(record) {
        const grid = this.grid;
        const states = grid.expansionStates;
        const expanded = states.get(record.rowID);
        if (expanded !== undefined) {
            return expanded;
        }
        else {
            return record.children && record.children.length && record.level < grid.expansionDepth;
        }
    }
    should_apply_number_style(column) {
        return column.dataType === DataType.Number && column.visibleIndex !== 0;
    }
    deleteRowById(rowID) {
        const treeGrid = this.grid;
        const flatDataWithCascadeOnDeleteAndTransactions = treeGrid.primaryKey &&
            treeGrid.foreignKey &&
            treeGrid.cascadeOnDelete &&
            treeGrid.transactions.enabled;
        if (flatDataWithCascadeOnDeleteAndTransactions) {
            treeGrid.transactions.startPending();
        }
        super.deleteRowById(rowID);
        if (flatDataWithCascadeOnDeleteAndTransactions) {
            treeGrid.transactions.endPending(true);
        }
    }
    deleteRowFromData(rowID, index) {
        const treeGrid = this.grid;
        const record = treeGrid.records.get(rowID);
        if (treeGrid.primaryKey && treeGrid.foreignKey) {
            index = treeGrid.primaryKey ?
                treeGrid.data.map(c => c[treeGrid.primaryKey]).indexOf(rowID) :
                treeGrid.data.indexOf(rowID);
            super.deleteRowFromData(rowID, index);
            if (treeGrid.cascadeOnDelete) {
                if (record && record.children) {
                    for (const child of record.children) {
                        super.deleteRowById(child.rowID);
                    }
                }
            }
        }
        else {
            const collection = record.parent ? record.parent.data[treeGrid.childDataKey] : treeGrid.data;
            index = treeGrid.primaryKey ?
                collection.map(c => c[treeGrid.primaryKey]).indexOf(rowID) :
                collection.indexOf(rowID);
            const selectedChildren = [];
            this.get_selected_children(record, selectedChildren);
            if (selectedChildren.length > 0) {
                treeGrid.deselectRows(selectedChildren);
            }
            if (treeGrid.transactions.enabled) {
                const path = treeGrid.generateRowPath(rowID);
                treeGrid.transactions.add({
                    id: rowID,
                    type: TransactionType.DELETE,
                    newValue: null,
                    path
                }, collection[index]);
            }
            else {
                collection.splice(index, 1);
            }
        }
    }
    get_selected_children(record, selectedRowIDs) {
        const grid = this.grid;
        if (!record.children || record.children.length === 0) {
            return;
        }
        for (const child of record.children) {
            if (grid.selectionService.isRowSelected(child.rowID)) {
                selectedRowIDs.push(child.rowID);
            }
            this.get_selected_children(child, selectedRowIDs);
        }
    }
    row_deleted_transaction(rowID) {
        return this.row_deleted_parent(rowID) || super.row_deleted_transaction(rowID);
    }
    get_rec_by_id(rowID) {
        return this.grid.records.get(rowID);
    }
    addRowToData(data, parentRowID) {
        if (parentRowID !== undefined && parentRowID !== null) {
            const state = this.grid.transactions.getState(parentRowID);
            // we should not allow adding of rows as child of deleted row
            if (state && state.type === TransactionType.DELETE) {
                throw Error(`Cannot add child row to deleted parent row`);
            }
            const parentRecord = this.grid.records.get(parentRowID);
            if (!parentRecord) {
                throw Error('Invalid parent row ID!');
            }
            this.grid.summaryService.clearSummaryCache({ rowID: parentRecord.rowID });
            if (this.grid.primaryKey && this.grid.foreignKey) {
                data[this.grid.foreignKey] = parentRowID;
                super.addRowToData(data);
            }
            else {
                const parentData = parentRecord.data;
                const childKey = this.grid.childDataKey;
                if (this.grid.transactions.enabled) {
                    const rowId = this.grid.primaryKey ? data[this.grid.primaryKey] : data;
                    const path = [];
                    path.push(...this.grid.generateRowPath(parentRowID));
                    path.push(parentRowID);
                    this.grid.transactions.add({
                        id: rowId,
                        path,
                        newValue: data,
                        type: TransactionType.ADD
                    }, null);
                }
                else {
                    if (!parentData[childKey]) {
                        parentData[childKey] = [];
                    }
                    parentData[childKey].push(data);
                }
            }
        }
        else {
            super.addRowToData(data);
        }
    }
    filterDataByExpressions(expressionsTree) {
        var _a;
        let records = this.grid.rootRecords;
        if (expressionsTree.filteringOperands.length) {
            const state = {
                expressionsTree,
                strategy: (_a = this.grid.filterStrategy) !== null && _a !== void 0 ? _a : new TreeGridFilteringStrategy()
            };
            records = DataUtil.filter(cloneArray(records), state, this.grid);
        }
        const data = [];
        this.getFlatDataFromFilteredRecords(records, data);
        return data;
    }
    update_row_in_array(value, rowID, index) {
        const grid = this.grid;
        if (grid.primaryKey && grid.foreignKey) {
            super.update_row_in_array(value, rowID, index);
        }
        else {
            const record = grid.records.get(rowID);
            const childData = record.parent ? record.parent.data[grid.childDataKey] : grid.data;
            index = grid.primaryKey ? childData.map(c => c[grid.primaryKey]).indexOf(rowID) :
                childData.indexOf(rowID);
            childData[index] = value;
        }
    }
    /**
     * Updates related row of provided grid's data source with provided new row value
     *
     * @param grid Grid to update data for
     * @param rowID ID of the row to update
     * @param rowValueInDataSource Initial value of the row as it is in data source
     * @param rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param rowNewValue New value of the row
     */
    updateData(grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
        if (grid.transactions.enabled) {
            const path = grid.generateRowPath(rowID);
            const transaction = {
                id: rowID,
                type: TransactionType.UPDATE,
                newValue: rowNewValue,
                path
            };
            grid.transactions.add(transaction, rowCurrentValue);
        }
        else {
            mergeObjects(rowValueInDataSource, rowNewValue);
        }
    }
    row_deleted_parent(rowID) {
        const grid = this.grid;
        if (!grid) {
            return false;
        }
        if ((grid.cascadeOnDelete && grid.foreignKey) || grid.childDataKey) {
            let node = grid.records.get(rowID);
            while (node) {
                const state = grid.transactions.getState(node.rowID);
                if (state && state.type === TransactionType.DELETE) {
                    return true;
                }
                node = node.parent;
            }
        }
        return false;
    }
    getFlatDataFromFilteredRecords(records, data) {
        if (!records || records.length === 0) {
            return;
        }
        for (const record of records) {
            if (!record.isFilteredOutParent) {
                data.push(record.data);
            }
            this.getFlatDataFromFilteredRecords(record.children, data);
        }
    }
}
IgxTreeGridAPIService.decorators = [
    { type: Injectable }
];

/**
 * @hidden
 */
class IgxRowLoadingIndicatorTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxRowLoadingIndicatorTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxRowLoadingIndicator]'
            },] }
];
IgxRowLoadingIndicatorTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

class IgxTreeGridSelectionService extends IgxGridSelectionService {
    /** Select specified rows. No event is emitted. */
    selectRowsWithNoEvent(rowIDs, clearPrevSelection) {
        if (this.grid && this.grid.rowSelection === GridSelectionMode.multipleCascade) {
            this.cascadeSelectRowsWithNoEvent(rowIDs, clearPrevSelection);
            return;
        }
        super.selectRowsWithNoEvent(rowIDs, clearPrevSelection);
    }
    /** Deselect specified rows. No event is emitted. */
    deselectRowsWithNoEvent(rowIDs) {
        if (this.grid.rowSelection === GridSelectionMode.multipleCascade) {
            this.cascadeDeselectRowsWithNoEvent(rowIDs);
            return;
        }
        super.deselectRowsWithNoEvent(rowIDs);
    }
    emitRowSelectionEvent(newSelection, added, removed, event) {
        if (this.grid.rowSelection === GridSelectionMode.multipleCascade) {
            this.emitCascadeRowSelectionEvent(newSelection, added, removed, event);
            return;
        }
        super.emitRowSelectionEvent(newSelection, added, removed, event);
    }
    updateCascadeSelectionOnFilterAndCRUD(parents, crudRowID, visibleRowIDs = null) {
        if (visibleRowIDs === null) {
            // if the tree grid has flat structure
            // do not explicitly handle the selection state of the rows
            if (!parents.size) {
                return;
            }
            visibleRowIDs = this.getRowIDs(this.allData);
            this.rowsToBeSelected = new Set(this.rowSelection);
            this.rowsToBeIndeterminate = new Set(this.indeterminateRows);
            if (crudRowID) {
                this.rowSelection.delete(crudRowID);
            }
        }
        if (!parents.size) {
            this.rowSelection = new Set(this.rowsToBeSelected);
            this.indeterminateRows = new Set(this.rowsToBeIndeterminate);
            // TODO: emit selectionChangeD event, calculate its args through the handleAddedAndRemovedArgs method
            this.clearHeaderCBState();
            this.selectedRowsChange.next();
            return;
        }
        const newParents = new Set();
        parents.forEach(parent => {
            this.handleRowSelectionState(parent, visibleRowIDs);
            if (parent && parent.parent) {
                newParents.add(parent.parent);
            }
        });
        this.updateCascadeSelectionOnFilterAndCRUD(newParents, null, visibleRowIDs);
    }
    cascadeSelectRowsWithNoEvent(rowIDs, clearPrevSelection) {
        if (clearPrevSelection) {
            this.indeterminateRows.clear();
            this.rowSelection.clear();
            this.calculateRowsNewSelectionState({ added: rowIDs, removed: [] });
        }
        else {
            const oldSelection = this.getSelectedRows();
            const newSelection = [...oldSelection, ...rowIDs];
            const args = { oldSelection, newSelection };
            // retrieve only the rows without their parents/children which has to be added to the selection
            this.handleAddedAndRemovedArgs(args);
            this.calculateRowsNewSelectionState(args);
        }
        this.rowSelection = new Set(this.rowsToBeSelected);
        this.indeterminateRows = new Set(this.rowsToBeIndeterminate);
        this.clearHeaderCBState();
        this.selectedRowsChange.next();
    }
    cascadeDeselectRowsWithNoEvent(rowIDs) {
        const args = { added: [], removed: rowIDs };
        this.calculateRowsNewSelectionState(args);
        this.rowSelection = new Set(this.rowsToBeSelected);
        this.indeterminateRows = new Set(this.rowsToBeIndeterminate);
        this.clearHeaderCBState();
        this.selectedRowsChange.next();
    }
    get selectionService() {
        return this.grid.selectionService;
    }
    emitCascadeRowSelectionEvent(newSelection, added, removed, event) {
        const currSelection = this.getSelectedRows();
        if (this.areEqualCollections(currSelection, newSelection)) {
            return;
        }
        const args = {
            oldSelection: currSelection, newSelection,
            added, removed, event, cancel: false
        };
        this.calculateRowsNewSelectionState(args);
        args.newSelection = Array.from(this.rowsToBeSelected);
        // retrieve rows/parents/children which has been added/removed from the selection
        this.handleAddedAndRemovedArgs(args);
        this.grid.onRowSelectionChange.emit(args);
        if (args.cancel) {
            return;
        }
        // if args.newSelection hasn't been modified
        if (this.areEqualCollections(Array.from(this.rowsToBeSelected), args.newSelection)) {
            this.rowSelection = new Set(this.rowsToBeSelected);
            this.indeterminateRows = new Set(this.rowsToBeIndeterminate);
            this.clearHeaderCBState();
            this.selectedRowsChange.next();
        }
        else {
            // select the rows within the modified args.newSelection with no event
            this.cascadeSelectRowsWithNoEvent(args.newSelection, true);
        }
    }
    /**
     * retrieve the rows which should be added/removed to/from the old selection
     */
    handleAddedAndRemovedArgs(args) {
        args.removed = args.oldSelection.filter(x => args.newSelection.indexOf(x) < 0);
        args.added = args.newSelection.filter(x => args.oldSelection.indexOf(x) < 0);
    }
    /**
     * adds to rowsToBeProcessed set all visible children of the rows which was initially within the rowsToBeProcessed set
     *
     * @param rowsToBeProcessed set of the rows (without their parents/children) to be selected/deselected
     * @param visibleRowIDs list of all visible rowIds
     * @returns a new set with all direct parents of the rows within rowsToBeProcessed set
     */
    collectRowsChildrenAndDirectParents(rowsToBeProcessed, visibleRowIDs) {
        const processedRowsParents = new Set();
        Array.from(rowsToBeProcessed).forEach((rowID) => {
            const rowTreeRecord = this.grid.gridAPI.get_rec_by_id(rowID);
            const rowAndAllChildren = this.get_all_children(rowTreeRecord);
            rowAndAllChildren.forEach(row => {
                if (visibleRowIDs.indexOf(row.rowID) >= 0) {
                    rowsToBeProcessed.add(row.rowID);
                }
            });
            if (rowTreeRecord && rowTreeRecord.parent) {
                processedRowsParents.add(rowTreeRecord.parent);
            }
        });
        return processedRowsParents;
    }
    /**
     * populates the rowsToBeSelected and rowsToBeIndeterminate sets
     * with the rows which will be eventually in selected/indeterminate state
     */
    calculateRowsNewSelectionState(args) {
        this.rowsToBeSelected = new Set(args.oldSelection ? args.oldSelection : this.getSelectedRows());
        this.rowsToBeIndeterminate = new Set(this.getIndeterminateRows());
        const visibleRowIDs = this.getRowIDs(this.allData);
        const removed = new Set(args.removed);
        const added = new Set(args.added);
        if (removed && removed.size) {
            let removedRowsParents = new Set();
            removedRowsParents = this.collectRowsChildrenAndDirectParents(removed, visibleRowIDs);
            removed.forEach(removedRow => {
                this.rowsToBeSelected.delete(removedRow);
                this.rowsToBeIndeterminate.delete(removedRow);
            });
            Array.from(removedRowsParents).forEach((parent) => {
                this.handleParentSelectionState(parent, visibleRowIDs);
            });
        }
        if (added && added.size) {
            let addedRowsParents = new Set();
            addedRowsParents = this.collectRowsChildrenAndDirectParents(added, visibleRowIDs);
            added.forEach(addedRow => {
                this.rowsToBeSelected.add(addedRow);
                this.rowsToBeIndeterminate.delete(addedRow);
            });
            Array.from(addedRowsParents).forEach((parent) => {
                this.handleParentSelectionState(parent, visibleRowIDs);
            });
        }
    }
    /**
     * recursively handle the selection state of the direct and indirect parents
     */
    handleParentSelectionState(treeRow, visibleRowIDs) {
        if (!treeRow) {
            return;
        }
        this.handleRowSelectionState(treeRow, visibleRowIDs);
        if (treeRow.parent) {
            this.handleParentSelectionState(treeRow.parent, visibleRowIDs);
        }
    }
    /**
     * Handle the selection state of a given row based the selection states of its direct children
     */
    handleRowSelectionState(treeRow, visibleRowIDs) {
        let visibleChildren = [];
        if (treeRow && treeRow.children) {
            visibleChildren = treeRow.children.filter(child => visibleRowIDs.indexOf(child.rowID) >= 0);
        }
        if (visibleChildren.length) {
            if (visibleChildren.every(row => this.rowsToBeSelected.has(row.rowID))) {
                this.rowsToBeSelected.add(treeRow.rowID);
                this.rowsToBeIndeterminate.delete(treeRow.rowID);
            }
            else if (visibleChildren.some(row => this.rowsToBeSelected.has(row.rowID) || this.rowsToBeIndeterminate.has(row.rowID))) {
                this.rowsToBeIndeterminate.add(treeRow.rowID);
                this.rowsToBeSelected.delete(treeRow.rowID);
            }
            else {
                this.rowsToBeIndeterminate.delete(treeRow.rowID);
                this.rowsToBeSelected.delete(treeRow.rowID);
            }
        }
        else {
            // if the children of the row has been deleted and the row was selected do not change its state
            if (this.isRowSelected(treeRow.rowID)) {
                this.rowsToBeSelected.add(treeRow.rowID);
                this.rowsToBeIndeterminate.delete(treeRow.rowID);
            }
            else {
                this.rowsToBeSelected.delete(treeRow.rowID);
                this.rowsToBeIndeterminate.delete(treeRow.rowID);
            }
        }
    }
    get_all_children(record) {
        const children = [];
        if (record && record.children && record.children.length) {
            for (const child of record.children) {
                children.push(...this.get_all_children(child));
                children.push(child);
            }
        }
        return children;
    }
}
IgxTreeGridSelectionService.decorators = [
    { type: Injectable }
];

let NEXT_ID$m = 0;
/**
 * **Ignite UI for Angular Tree Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid)
 *
 * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
 * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
 *
 * Example:
 * ```html
 * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-tree-grid>
 * ```
 */
class IgxTreeGridComponent extends IgxGridBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * An @Input property indicating whether child records should be deleted when their parent gets deleted.
         * By default it is set to true and deletes all children along with the parent.
         * ```html
         * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
         * </igx-tree-grid>
         * ```
         *
         * @memberof IgxTreeGridComponent
         */
        this.cascadeOnDelete = true;
        /**
         * @hidden @internal
         */
        this.role = 'treegrid';
        /**
         * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
         * ```
         *
         * @memberof IgxTreeGridComponent
         */
        this.id = `igx-tree-grid-${NEXT_ID$m++}`;
        /**
         * Returns a map of all `ITreeGridRecord`s.
         * ```typescript
         * // gets the record with primaryKey=2
         * const states = this.grid.records.get(2);
         * ```
         *
         * @memberof IgxTreeGridComponent
         */
        this.records = new Map();
        /**
         * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
         * ```typescript
         * // gets the processed record with primaryKey=2
         * const states = this.grid.processedRecords.get(2);
         * ```
         *
         * @memberof IgxTreeGridComponent
         */
        this.processedRecords = new Map();
        /**
         * @hidden
         */
        this.loadingRows = new Set();
        this._expansionDepth = Infinity;
        this._filteredData = null;
    }
    /**
     * An @Input property that lets you fill the `IgxTreeGridComponent` with an array of data.
     * ```html
     * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    get data() {
        return this._data;
    }
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
        }
        this.cdr.markForCheck();
    }
    /**
     * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    get filteredData() {
        return this._filteredData;
    }
    /**
     * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * this.grid.filteredData = [{
     *       ID: 1,
     *       Name: "A"
     * }];
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Get transactions service for the grid.
     *
     * @experimental @hidden
     */
    get transactions() {
        return this._transactions;
    }
    /**
     * An @Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
     * set to `Infinity` which means all levels would be expanded.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    get expansionDepth() {
        return this._expansionDepth;
    }
    set expansionDepth(value) {
        this._expansionDepth = value;
        this.notifyChanges();
    }
    /**
     * An @Input property that provides a template for the row loading indicator when load on demand is enabled.
     * ```html
     * <ng-template #rowLoadingTemplate>
     *     <igx-icon>loop</igx-icon>
     * </ng-template>
     *
     * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
     *                [loadChildrenOnDemand]="loadChildren"
     *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
     * </igx-tree-grid>
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    get rowLoadingIndicatorTemplate() {
        return this._rowLoadingIndicatorTemplate;
    }
    set rowLoadingIndicatorTemplate(value) {
        this._rowLoadingIndicatorTemplate = value;
        this.notifyChanges();
    }
    // Kind of stupid
    get _gridAPI() {
        return this.gridAPI;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.onRowToggle.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.loadChildrenOnRowExpansion(args);
        });
        this.onRowAdded.pipe(takeUntil(this.destroy$)).subscribe(args => {
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                let rec = this._gridAPI.get_rec_by_id(this.primaryKey ? args.data[this.primaryKey] : args.data);
                if (rec && rec.parent) {
                    this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec.parent]), rec.parent.rowID);
                }
                else {
                    // The record is still not available
                    // Wait for the change detection to update records through pipes
                    requestAnimationFrame(() => {
                        rec = this._gridAPI.get_rec_by_id(this.primaryKey ?
                            args.data[this.primaryKey] : args.data);
                        if (rec && rec.parent) {
                            this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec.parent]), rec.parent.rowID);
                        }
                        this.notifyChanges();
                    });
                }
            }
        });
        this.onRowDeleted.pipe(takeUntil(this.destroy$)).subscribe(args => {
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                if (args.data) {
                    const rec = this._gridAPI.get_rec_by_id(this.primaryKey ? args.data[this.primaryKey] : args.data);
                    this.handleCascadeSelection(args, rec);
                }
                else {
                    // if a row has been added and before commiting the transaction deleted
                    const leafRowsDirectParents = new Set();
                    this.records.forEach(record => {
                        if (record && !record.children && record.parent) {
                            leafRowsDirectParents.add(record.parent);
                        }
                    });
                    // Wait for the change detection to update records through pipes
                    requestAnimationFrame(() => {
                        this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(leafRowsDirectParents);
                        this.notifyChanges();
                    });
                }
            }
        });
        this.onFilteringDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                const leafRowsDirectParents = new Set();
                this.records.forEach(record => {
                    if (record && !record.children && record.parent) {
                        leafRowsDirectParents.add(record.parent);
                    }
                });
                this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(leafRowsDirectParents);
                this.notifyChanges();
            }
        });
        this.transactions.onStateUpdate.pipe(takeUntil(this.destroy$)).subscribe((event) => {
            let actions = [];
            if (event.origin === TransactionEventOrigin.REDO) {
                actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.DELETE) : [];
                if (this.rowSelection === GridSelectionMode.multipleCascade) {
                    this.handleCascadeSelection(event);
                }
            }
            else if (event.origin === TransactionEventOrigin.UNDO) {
                actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.ADD) : [];
                if (this.rowSelection === GridSelectionMode.multipleCascade) {
                    if (event.actions[0].transaction.type === 'add') {
                        const rec = this._gridAPI.get_rec_by_id(event.actions[0].transaction.id);
                        this.handleCascadeSelection(event, rec);
                    }
                    else {
                        this.handleCascadeSelection(event);
                    }
                }
            }
            if (actions.length) {
                for (const action of actions) {
                    this.deselectChildren(action.transaction.id);
                }
            }
        });
    }
    ngDoCheck() {
        super.ngDoCheck();
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        // TODO: pipesExectured event
        // run after change detection in super triggers pipes for records structure
        if (this.rowSelection === GridSelectionMode.multipleCascade && this.selectedRows.length) {
            const selRows = this.selectedRows;
            this.selectionService.clearRowSelection();
            this.selectRows(selRows, true);
            this.cdr.detectChanges();
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.rowLoadingTemplate) {
            this._rowLoadingIndicatorTemplate = this.rowLoadingTemplate.template;
        }
        super.ngAfterContentInit();
    }
    getDefaultExpandState(record) {
        return record.children && record.children.length && record.level < this.expansionDepth;
    }
    /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    expandAll() {
        this._expansionDepth = Infinity;
        this.expansionStates = new Map();
    }
    /**
     * Collapses all rows.
     *
     * ```typescript
     * this.grid.collapseAll();
     *  ```
     *
     * @memberof IgxTreeGridComponent
     */
    collapseAll() {
        this._expansionDepth = 0;
        this.expansionStates = new Map();
    }
    /**
     * @hidden
     */
    refreshGridState(args) {
        super.refreshGridState();
        if (this.primaryKey && this.foreignKey) {
            const rowID = args.data[this.foreignKey];
            this.summaryService.clearSummaryCache({ rowID });
            this._pipeTrigger++;
            this.cdr.detectChanges();
        }
    }
    /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     *
     * @param data
     * @param parentRowID
     * @memberof IgxTreeGridComponent
     */
    addRow(data, parentRowID) {
        super.endEdit(true);
        this.gridAPI.addRowToData(data, parentRowID);
        this.onRowAdded.emit({ data });
        this._pipeTrigger++;
        this.notifyChanges();
    }
    /**
     * @hidden
     */
    getContext(rowData, rowIndex, pinned) {
        return {
            $implicit: this.isGhostRecord(rowData) || this.isAddRowRecord(rowData) ? rowData.recordRef : rowData,
            index: this.getDataViewIndex(rowIndex, pinned),
            templateID: this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',
            disabled: this.isGhostRecord(rowData) ? rowData.recordRef.isFilteredOutParent === undefined : false,
            addRow: this.isAddRowRecord(rowData) ? rowData.addRow : false
        };
    }
    /**
     * @hidden
     * @internal
     */
    getInitialPinnedIndex(rec) {
        return this._pinnedRecordIDs.indexOf(rec.rowID);
    }
    /**
     * @inheritdoc
     */
    getSelectedData(formatters = false, headers = false) {
        let source = [];
        const process = (record) => {
            if (record.summaries) {
                source.push(null);
                return;
            }
            source.push(record.data);
        };
        this.unpinnedDataView.forEach(process);
        source = this.isRowPinningToTop ? [...this.pinnedDataView, ...source] : [...source, ...this.pinnedDataView];
        return this.extractDataFromSelection(source, formatters, headers);
    }
    getEmptyRecordObjectFor(rec) {
        const row = Object.assign({}, rec);
        const data = rec || {};
        row.data = Object.assign({}, data);
        Object.keys(row.data).forEach(key => {
            // persist foreign key if one is set.
            if (this.foreignKey && key === this.foreignKey) {
                row.data[key] = rec.data[key];
            }
            else {
                row.data[key] = undefined;
            }
        });
        let id = this.generateRowID();
        const rootRecPK = this.foreignKey && this.rootRecords && this.rootRecords.length > 0 ?
            this.rootRecords[0].data[this.foreignKey] : null;
        if (id === rootRecPK) {
            // safeguard in case generated id matches the root foreign key.
            id = this.generateRowID();
        }
        row.rowID = id;
        row.data[this.primaryKey] = id;
        return row;
    }
    /** @hidden */
    deleteRowById(rowId) {
        //  if this is flat self-referencing data, and CascadeOnDelete is set to true
        //  and if we have transactions we should start pending transaction. This allows
        //  us in case of delete action to delete all child rows as single undo action
        this._gridAPI.deleteRowById(rowId);
    }
    /** @hidden */
    generateRowPath(rowId) {
        const path = [];
        let record = this.records.get(rowId);
        while (record.parent) {
            path.push(record.parent.rowID);
            record = record.parent;
        }
        return path.reverse();
    }
    findRecordIndexInView(rec) {
        return this.dataView.findIndex(x => x.data[this.primaryKey] === rec[this.primaryKey]);
    }
    getUnpinnedIndexById(id) {
        return this.unpinnedRecords.findIndex(x => x.data[this.primaryKey] === id);
    }
    /**
     * @hidden
     * @internal
     */
    _getParentRecordId() {
        var _a;
        if (this.addRowParent.asChild) {
            return super._getParentRecordId();
        }
        else if (this.addRowParent.rowID !== null && this.addRowParent.rowID !== undefined) {
            const spawnedForRecord = this._gridAPI.get_rec_by_id(this.addRowParent.rowID);
            return (_a = spawnedForRecord === null || spawnedForRecord === void 0 ? void 0 : spawnedForRecord.parent) === null || _a === void 0 ? void 0 : _a.rowID;
        }
    }
    /**
     * @hidden @internal
     */
    getDataBasedBodyHeight() {
        return !this.flatData || (this.flatData.length < this._defaultTargetRecordNumber) ?
            0 : this.defaultTargetBodyHeight;
    }
    /**
     * @hidden
     */
    scrollTo(row, column) {
        let delayScrolling = false;
        let record;
        if (typeof (row) !== 'number') {
            const rowData = row;
            const rowID = this._gridAPI.get_row_id(rowData);
            record = this.processedRecords.get(rowID);
            this._gridAPI.expand_path_to_record(record);
            if (this.paging) {
                const rowIndex = this.processedExpandedFlatData.indexOf(rowData);
                const page = Math.floor(rowIndex / this.perPage);
                if (this.page !== page) {
                    delayScrolling = true;
                    this.page = page;
                }
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(first$1()).subscribe(() => {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(record));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(record));
        }
        this.scrollToHorizontally(column);
    }
    writeToData(rowIndex, value) {
        mergeObjects(this.flatData[rowIndex], value);
    }
    /**
     * @hidden
     */
    initColumns(collection, cb = null) {
        if (this.hasColumnLayouts) {
            // invalid configuration - tree grid should not allow column layouts
            // remove column layouts
            const nonColumnLayoutColumns = this.columnList.filter((col) => !col.columnLayout && !col.columnLayoutChild);
            this.columnList.reset(nonColumnLayoutColumns);
        }
        super.initColumns(collection, cb);
    }
    /**
     * @description A recursive way to deselect all selected children of a given record
     * @param recordID ID of the record whose children to deselect
     * @hidden
     * @internal
     */
    deselectChildren(recordID) {
        const selectedChildren = [];
        const rowToDeselect = this.getRowByKey(recordID).treeRow;
        this.selectionService.deselectRow(recordID);
        this._gridAPI.get_selected_children(rowToDeselect, selectedChildren);
        if (selectedChildren.length > 0) {
            selectedChildren.forEach(x => this.deselectChildren(x));
        }
    }
    addChildRows(children, parentID) {
        if (this.primaryKey && this.foreignKey) {
            for (const child of children) {
                child[this.foreignKey] = parentID;
            }
            this.data.push(...children);
        }
        else if (this.childDataKey) {
            let parent = this.records.get(parentID);
            let parentData = parent.data;
            if (this.transactions.enabled && this.transactions.getAggregatedChanges(true).length) {
                const path = [];
                while (parent) {
                    path.push(parent.rowID);
                    parent = parent.parent;
                }
                let collection = this.data;
                let record;
                for (let i = path.length - 1; i >= 0; i--) {
                    const pid = path[i];
                    record = collection.find(r => r[this.primaryKey] === pid);
                    if (!record) {
                        break;
                    }
                    collection = record[this.childDataKey];
                }
                if (record) {
                    parentData = record;
                }
            }
            parentData[this.childDataKey] = children;
        }
        this.selectionService.clearHeaderCBState();
        this._pipeTrigger++;
        if (this.rowSelection === GridSelectionMode.multipleCascade) {
            // Force pipe triggering for building the data structure
            this.cdr.detectChanges();
            if (this.selectionService.isRowSelected(parentID)) {
                this.selectionService.rowSelection.delete(parentID);
                this.selectionService.selectRowsWithNoEvent([parentID]);
            }
        }
    }
    loadChildrenOnRowExpansion(args) {
        if (this.loadChildrenOnDemand) {
            const parentID = args.rowID;
            if (args.expanded && !this._expansionStates.has(parentID)) {
                this.loadingRows.add(parentID);
                this.loadChildrenOnDemand(parentID, children => {
                    this.loadingRows.delete(parentID);
                    this.addChildRows(children, parentID);
                    this.notifyChanges();
                });
            }
        }
    }
    handleCascadeSelection(event, rec = null) {
        // Wait for the change detection to update records through the pipes
        requestAnimationFrame(() => {
            if (rec === null) {
                rec = this._gridAPI.get_rec_by_id(event.actions[0].transaction.id);
            }
            if (rec && rec.parent) {
                this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec.parent]), rec.parent.rowID);
                this.notifyChanges();
            }
        });
    }
}
IgxTreeGridComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-tree-grid',
                template: "<ng-content select=\"igx-grid-toolbar\"></ng-content>\n\n<div class=\"igx-grid__thead\" role=\"rowgroup\">\n    <div class=\"igx-grid__thead-wrapper\" (keydown.meta.c)=\"copyHandler($event)\" (keydown.control.c)=\"copyHandler($event)\" \n    (copy)=\"copyHandler($event)\" [style.width.px]='calcWidth' tabindex=\"0\" (focus)=\"navigation.focusFirstCell()\" \n    (keydown)=\"navigation.headerNavigation($event)\" #theadRow [attr.aria-activedescendant]=\"activeDescendant\">\n        <div class=\"igx-grid__tr\" [style.width.px]='calcWidth' role=\"row\">\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator igx-grid__tr-action\" (pointerdown)=\"$event.preventDefault()\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible }\" (pointerdown)=\"$event.preventDefault()\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                 </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]=\"'calcPixelWidth'\" #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\" [style.left]=\"col.rightPinnedOffset\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollSize\"></div>\n    <div igxToggle #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\" role=\"rowgroup\">\n    <div class=\"igx-grid__tbody-content\"  tabindex=\"0\" (focus)=\"navigation.focusTbody($event)\" (keydown)=\"navigation.handleNavigation($event)\" \n    (onDragStop)=\"selectionService.dragMode = $event\" [attr.aria-activedescendant]=\"activeDescendant\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth' #tbody (scroll)='preventContainerScroll($event)'>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template #pinnedRecordsTemplate>\n            <ng-container *ngIf='data\n            | treeGridTransaction:pipeTrigger\n            | visibleColumns:hasVisibleColumns\n            | treeGridNormalizeRecord:pipeTrigger\n            | gridRowPinning:id:true:pipeTrigger\n            | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:pipeTrigger:filteringPipeTrigger:true\n            | treeGridSorting:sortingExpressions:sortStrategy:pipeTrigger:true\n            | gridAddRow:true:pipeTrigger as pinnedData'>\n                <div #pinContainer *ngIf='pinnedData.length > 0'\n                    [ngClass]=\"{\n                        'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                        'igx-grid__tr--pinned-top': isRowPinningToTop\n                    }\"\n                    class='igx-grid__tr--pinned' [style.width.px]='calcWidth'>\n                    <ng-container *ngFor=\"let rowData of pinnedData;let rowIndex = index;\">\n                        <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                        </ng-container>\n                    </ng-container>\n                </div>\n            </ng-container>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | treeGridTransaction:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:pipeTrigger:filteringPipeTrigger\n        | treeGridSorting:sortingExpressions:sortStrategy:pipeTrigger\n        | treeGridFlattening:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:page:perPage:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:showSummaryOnCollapse:pipeTrigger:summaryPipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\n        | gridAddRow:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" #verticalScrollContainer>\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex, false)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-disabledRow=\"disabled\" let-rowData let-isAddRow=\"addRow\">\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" [disabled]=\"disabledRow\" [addRow]=\"isAddRow\" #row>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData let-isAddRow=\"addRow\">\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" [addRow]=\"isAddRow\" #row #pinnedRow>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\"\n                [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" role=\"row\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\"  (pointerdown)=\"$event.preventDefault()\"\n            [style.height.px]='calcHeight'>\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [actionText]=\"snackbarActionText\" [displayTime]='snackbarDisplayTime'>{{snackbarLabel}}</igx-snackbar>\n    </div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <div tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\" \n    (keydown)=\"navigation.summaryNav($event)\" [attr.aria-activedescendant]=\"activeDescendant\">\n        <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n            *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n            [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n            class=\"igx-grid__summaries\" #summaryRow>\n        </igx-grid-summary-row>\n        <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n            [style.width.px]=\"scrollSize\"></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\" (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [overlaySettings]=\"paginatorSettings\" [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\"\n        [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button igxButton=\"raised\" igxRipple (click)='beginAddRowByIndex(null, -1, $event)'>\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle #rowEditingOverlay>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\" *ngIf=\"!this.crudService.row?.isAddRow\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon>drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [readonly]=\"true\"\n            disableRipple=\"true\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n",
                providers: [
                    IgxGridCRUDService,
                    IgxGridSummaryService,
                    IgxGridNavigationService,
                    { provide: IgxGridSelectionService, useClass: IgxTreeGridSelectionService },
                    { provide: GridBaseAPIService, useClass: IgxTreeGridAPIService },
                    { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxTreeGridComponent) },
                    IgxFilteringService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService
                ]
            },] }
];
IgxTreeGridComponent.propDecorators = {
    childDataKey: [{ type: Input }],
    foreignKey: [{ type: Input }],
    hasChildrenKey: [{ type: Input }],
    cascadeOnDelete: [{ type: Input }],
    loadChildrenOnDemand: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    dragIndicatorIconBase: [{ type: ViewChild, args: ['dragIndicatorIconBase', { read: TemplateRef, static: true },] }],
    recordTemplate: [{ type: ViewChild, args: ['record_template', { read: TemplateRef, static: true },] }],
    summaryTemplate: [{ type: ViewChild, args: ['summary_template', { read: TemplateRef, static: true },] }],
    rowLoadingTemplate: [{ type: ContentChild, args: [IgxRowLoadingIndicatorTemplateDirective, { read: IgxRowLoadingIndicatorTemplateDirective },] }],
    data: [{ type: Input }],
    expansionDepth: [{ type: Input }],
    rowLoadingIndicatorTemplate: [{ type: Input }]
};

class IgxTreeGridRowComponent extends IgxRowDirective {
    /**
     * The `ITreeGridRecord` passed to the row component.
     *
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * const treeRow = row.treeRow;
     * ```
     */
    get treeRow() {
        return this._treeRow;
    }
    set treeRow(value) {
        if (this._treeRow !== value) {
            this._treeRow = value;
            this.rowData = this._treeRow.data;
        }
    }
    /**
     * Sets whether the row is pinned.
     * Default value is `false`.
     * ```typescript
     * this.grid.selectedRows[0].pinned = true;
     * ```
     */
    set pinned(value) {
        if (value) {
            this.grid.pinRow(this.rowID);
        }
        else {
            this.grid.unpinRow(this.rowID);
        }
    }
    /**
     * Gets whether the row is pinned.
     * ```typescript
     * let isPinned = row.pinned;
     * ```
     */
    get pinned() {
        return this.grid.isRecordPinned(this._treeRow);
    }
    /**
     * @hidden
     */
    get isRoot() {
        let treeRec = this.treeRow;
        const isPinnedArea = this.pinned && !this.disabled;
        if (isPinnedArea) {
            treeRec = this.grid.unpinnedRecords.find(x => x.data === this.rowData);
        }
        return treeRec.level === 0;
    }
    /**
     * @hidden
     */
    get hasChildren() {
        return true;
    }
    /**
     * Returns a value indicating whether the row component is expanded.
     *
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * const expanded = row.expanded;
     * ```
     */
    get expanded() {
        return this._treeRow.expanded;
    }
    /**
     * Sets a value indicating whether the row component is expanded.
     *
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * row.expanded = true;
     * ```
     */
    set expanded(value) {
        this.gridAPI.set_row_expansion_state(this._treeRow.rowID, value);
    }
    /**
     * @hidden
     * @internal
     */
    get viewIndex() {
        return this.index + this.grid.page * this.grid.perPage;
    }
    /**
     * @hidden
     */
    get showIndicator() {
        return this.grid.loadChildrenOnDemand ?
            this.grid.expansionStates.has(this.rowID) ?
                this.treeRow.children && this.treeRow.children.length :
                this.grid.hasChildrenKey ?
                    this.rowData[this.grid.hasChildrenKey] :
                    true :
            this.treeRow.children && this.treeRow.children.length;
    }
    /**
     * @hidden
     */
    get indeterminate() {
        return this.selectionService.isRowInIndeterminateState(this.rowID);
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        this.isLoading = this.grid.loadChildrenOnDemand ? this.grid.loadingRows.has(this.rowID) : false;
        super.ngDoCheck();
    }
    /**
     * Spawns the add child row UI for the specific row.
     *
     * @example
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * row.beginAddChild();
     * ```
     * @param rowID
     */
    beginAddChild() {
        this.grid.beginAddRowByIndex(this.rowID, this.index, true);
    }
    /**
     * @hidden
     */
    resolveClasses() {
        const classes = super.resolveClasses();
        const filteredClass = this.treeRow.isFilteredOutParent ? 'igx-grid__tr--filtered' : '';
        return `${classes} ${filteredClass}`;
    }
}
IgxTreeGridRowComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-tree-grid-row',
                template: "<ng-container *ngTemplateOutlet='addRow ? addTemp : defaultTemp'></ng-container>\n\n<ng-template #addTemp>\n    <div class='igx-grid__tr--inner' [class.igx-grid__tr--add-animate]='animateAdd' (animationend)='animationEndHandler()'>\n        <ng-container *ngTemplateOutlet='defaultTemp'></ng-container>\n    </div>\n</ng-template>\n<ng-template #defaultTemp>\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" (click)=\"onRowSelectorClick($event)\" (pointerdown)=\"$event.preventDefault()\">\n        <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n        </ng-template>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n    <ng-container *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-container>\n</ng-container>\n<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]=\"'calcPixelWidth'\" [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <ng-template #cellTemplate>\n        <igx-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"cellHeight\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n            #treeCell>\n        </igx-grid-cell>\n    </ng-template>\n    <ng-template #treeCellTemplate>\n        <igx-tree-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n            [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [level]=\"treeRow.level\"\n            [expanded]=\"treeRow.expanded\"\n            [showIndicator]=\"showIndicator\"\n            [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"cellHeight\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n            [isLoading]=\"isLoading\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n            #treeCell>\n        </igx-tree-grid-cell>\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n</ng-template>\n<ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n    <ng-container *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-container>\n</ng-container>\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"selected\"\n            [indeterminate]=\"indeterminate\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<ng-template #pinnedCellsTemplate let-col>\n    <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n        <ng-template #cellTemplate>\n            <igx-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n                [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n                [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n                [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [firstPinned]=\"col.isFirstPinned\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"cellHeight\"\n                [rowData]=\"rowData\"\n                [style.min-width]=\"col.width\"\n                [style.max-width]=\"col.width\"\n                [style.flex-basis]=\"col.width\"\n                [style.left]=\"col.rightPinnedOffset\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [lastSearchInfo]=\"grid.lastSearchInfo\"\n                [active]=\"isCellActive(col.visibleIndex)\"\n                [cellSelectionMode]=\"grid.cellSelection\"\n                [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n                #treeCell>\n            </igx-grid-cell>\n            </ng-template>\n        <ng-template #treeCellTemplate>\n            <igx-tree-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell igx-grid__td--pinned\"\n                [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n                [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n                [level]=\"treeRow.level\"\n                [expanded]=\"treeRow.expanded\"\n                [showIndicator]=\"showIndicator\"\n                [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"cellHeight\"\n                [rowData]=\"rowData\"\n                [style.min-width]=\"col.width\"\n                [style.max-width]=\"col.width\"\n                [style.flex-basis]=\"col.width\"\n                [style.left]=\"col.rightPinnedOffset\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n                [isLoading]=\"isLoading\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [lastSearchInfo]=\"grid.lastSearchInfo\"\n                [active]=\"isCellActive(col.visibleIndex)\"\n                [cellSelectionMode]=\"grid.cellSelection\"\n                [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n                #treeCell>\n            </igx-tree-grid-cell>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n    </ng-template>\n</ng-template>\n",
                providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxTreeGridRowComponent) }]
            },] }
];
IgxTreeGridRowComponent.propDecorators = {
    _cells: [{ type: ViewChildren, args: ['treeCell',] }],
    treeRow: [{ type: Input }],
    expanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }]
};

/**
 * @hidden
 */
class IgxTreeGridHierarchizingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, primaryKey, foreignKey, childDataKey, _) {
        const grid = this.gridAPI.grid;
        let hierarchicalRecords = [];
        const treeGridRecordsMap = new Map();
        const flatData = [];
        if (primaryKey && foreignKey) {
            hierarchicalRecords = this.hierarchizeFlatData(collection, primaryKey, foreignKey, treeGridRecordsMap, flatData);
        }
        else if (childDataKey) {
            hierarchicalRecords = this.hierarchizeRecursive(collection, primaryKey, childDataKey, undefined, flatData, 0, treeGridRecordsMap);
        }
        grid.flatData = grid.transactions.enabled ?
            flatData.filter(rec => !grid.transactions.getState(this.getRowID(primaryKey, rec))) : flatData;
        grid.records = treeGridRecordsMap;
        grid.rootRecords = hierarchicalRecords;
        return hierarchicalRecords;
    }
    getRowID(primaryKey, rowData) {
        return primaryKey ? rowData[primaryKey] : rowData;
    }
    hierarchizeFlatData(collection, primaryKey, foreignKey, map, flatData) {
        const result = [];
        const missingParentRecords = [];
        collection.forEach(row => {
            const record = {
                rowID: this.getRowID(primaryKey, row),
                data: row,
                children: []
            };
            const parent = map.get(row[foreignKey]);
            if (parent) {
                record.parent = parent;
                parent.children.push(record);
            }
            else {
                missingParentRecords.push(record);
            }
            map.set(row[primaryKey], record);
        });
        missingParentRecords.forEach(record => {
            const parent = map.get(record.data[foreignKey]);
            if (parent) {
                record.parent = parent;
                parent.children.push(record);
            }
            else {
                result.push(record);
            }
        });
        this.setIndentationLevels(result, 0, flatData);
        return result;
    }
    setIndentationLevels(collection, indentationLevel, flatData) {
        for (const record of collection) {
            record.level = indentationLevel;
            record.expanded = this.gridAPI.get_row_expansion_state(record);
            flatData.push(record.data);
            if (record.children && record.children.length > 0) {
                this.setIndentationLevels(record.children, indentationLevel + 1, flatData);
            }
        }
    }
    hierarchizeRecursive(collection, primaryKey, childDataKey, parent, flatData, indentationLevel, map) {
        const result = [];
        for (const item of collection) {
            const record = {
                rowID: this.getRowID(primaryKey, item),
                data: item,
                parent,
                level: indentationLevel
            };
            record.expanded = this.gridAPI.get_row_expansion_state(record);
            flatData.push(item);
            map.set(record.rowID, record);
            record.children = item[childDataKey] ?
                this.hierarchizeRecursive(item[childDataKey], primaryKey, childDataKey, record, flatData, indentationLevel + 1, map) :
                undefined;
            result.push(record);
        }
        return result;
    }
}
IgxTreeGridHierarchizingPipe.decorators = [
    { type: Pipe, args: [{
                name: 'treeGridHierarchizing',
                pure: true
            },] }
];
IgxTreeGridHierarchizingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxTreeGridFlatteningPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, expandedLevels, expandedStates, _) {
        const grid = this.gridAPI.grid;
        const data = [];
        grid.processedRootRecords = collection;
        grid.processedRecords = new Map();
        this.getFlatDataRecursive(collection, data, expandedLevels, expandedStates, true);
        grid.processedExpandedFlatData = data.map(r => r.data);
        return data;
    }
    getFlatDataRecursive(collection, data, expandedLevels, expandedStates, parentExpanded) {
        if (!collection || !collection.length) {
            return;
        }
        const grid = this.gridAPI.grid;
        for (const hierarchicalRecord of collection) {
            if (parentExpanded) {
                data.push(hierarchicalRecord);
            }
            hierarchicalRecord.expanded = this.gridAPI.get_row_expansion_state(hierarchicalRecord);
            this.updateNonProcessedRecordExpansion(grid, hierarchicalRecord);
            grid.processedRecords.set(hierarchicalRecord.rowID, hierarchicalRecord);
            this.getFlatDataRecursive(hierarchicalRecord.children, data, expandedLevels, expandedStates, parentExpanded && hierarchicalRecord.expanded);
        }
    }
    updateNonProcessedRecordExpansion(grid, record) {
        const rec = grid.records.get(record.rowID);
        rec.expanded = record.expanded;
    }
}
IgxTreeGridFlatteningPipe.decorators = [
    { type: Pipe, args: [{
                name: 'treeGridFlattening',
                pure: true
            },] }
];
IgxTreeGridFlatteningPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/** @hidden */
class IgxTreeGridSortingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(hierarchicalData, expressions, sorting, _, pinned) {
        const grid = this.gridAPI.grid;
        let result;
        if (!expressions.length) {
            result = hierarchicalData;
        }
        else {
            result = DataUtil.treeGridSort(hierarchicalData, expressions, sorting, null, grid);
        }
        const filteredSortedData = [];
        this.flattenTreeGridRecords(result, filteredSortedData);
        grid.setFilteredSortedData(filteredSortedData, pinned);
        return result;
    }
    flattenTreeGridRecords(records, flatData) {
        if (records && records.length) {
            for (const record of records) {
                flatData.push(record.data);
                this.flattenTreeGridRecords(record.children, flatData);
            }
        }
    }
}
IgxTreeGridSortingPipe.decorators = [
    { type: Pipe, args: [{
                name: 'treeGridSorting',
                pure: true
            },] }
];
IgxTreeGridSortingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/** @hidden */
class IgxTreeGridPagingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, page = 0, perPage = 15, _) {
        const grid = this.gridAPI.grid;
        if (!grid.paging || grid.pagingMode !== GridPagingMode.Local) {
            return collection;
        }
        const len = grid._totalRecords >= 0 ? grid._totalRecords : collection.length;
        const totalPages = Math.ceil(len / perPage);
        const state = {
            index: (totalPages > 0 && page >= totalPages) ? totalPages - 1 : page,
            recordsPerPage: perPage
        };
        const result = DataUtil.page(cloneArray(collection), state, len);
        grid.pagingState = state;
        grid._page = state.index;
        return result;
    }
}
IgxTreeGridPagingPipe.decorators = [
    { type: Pipe, args: [{
                name: 'treeGridPaging',
                pure: true
            },] }
];
IgxTreeGridPagingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/** @hidden */
class IgxTreeGridTransactionPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, _) {
        const grid = this.gridAPI.grid;
        if (grid.transactions.enabled) {
            const aggregatedChanges = grid.transactions.getAggregatedChanges(true);
            if (aggregatedChanges.length > 0) {
                const primaryKey = grid.primaryKey;
                if (!primaryKey) {
                    return collection;
                }
                const foreignKey = grid.foreignKey;
                const childDataKey = grid.childDataKey;
                if (foreignKey) {
                    const flatDataClone = cloneArray(collection);
                    return DataUtil.mergeTransactions(flatDataClone, aggregatedChanges, grid.primaryKey);
                }
                else if (childDataKey) {
                    const hierarchicalDataClone = cloneHierarchicalArray(collection, childDataKey);
                    return DataUtil.mergeHierarchicalTransactions(hierarchicalDataClone, aggregatedChanges, childDataKey, grid.primaryKey);
                }
            }
        }
        return collection;
    }
}
IgxTreeGridTransactionPipe.decorators = [
    { type: Pipe, args: [{
                name: 'treeGridTransaction',
                pure: true
            },] }
];
IgxTreeGridTransactionPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * This pipe maps the original record to ITreeGridRecord format used in TreeGrid.
 */
class IgxTreeGridNormalizeRecordsPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(_, __) {
        const grid = this.gridAPI.grid;
        const primaryKey = grid.primaryKey;
        // using flattened data because origin data may be hierarchical.
        const flatData = grid.flatData;
        const res = flatData.map(rec => ({
            rowID: grid.primaryKey ? rec[primaryKey] : rec,
            data: rec,
            level: 0,
            children: []
        }));
        return res;
    }
}
IgxTreeGridNormalizeRecordsPipe.decorators = [
    { type: Pipe, args: [{
                name: 'treeGridNormalizeRecord',
                pure: true
            },] }
];
IgxTreeGridNormalizeRecordsPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

class IgxTreeGridCellComponent extends IgxGridExpandableCellComponent {
    constructor() {
        super(...arguments);
        /**
         * @hidden
         */
        this.level = 0;
        /**
         * @hidden
         */
        this.showIndicator = false;
    }
    get treeGridAPI() {
        return this.gridAPI;
    }
    /**
     * @hidden
     */
    toggle(event) {
        event.stopPropagation();
        this.treeGridAPI.set_row_expansion_state(this.row.rowID, !this.row.expanded, event);
    }
    /**
     * @hidden
     */
    onLoadingDblClick(event) {
        event.stopPropagation();
    }
}
IgxTreeGridCellComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-tree-grid-cell',
                template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip\n        *ngIf=\"displayPinnedChip\"\n        class=\"igx-grid__td--pinned-chip\"\n        [disabled]=\"true\"\n        [displayDensity]=\"'compact'\"\n        >{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip\n    >\n</ng-template>\n<ng-template #defaultCell>\n    <div *ngIf=\"column.dataType !== 'boolean'\"\n        igxTextHighlight\n        class=\"igx-grid__td-text\"\n        style=\"pointer-events: none;\"\n        [cssClass]=\"highlightClass\"\n        [activeCssClass]=\"activeHighlightClass\"\n        [groupName]=\"gridID\"\n        [value]=\"\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === 'number'\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'date'\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : column.dataType === 'currency'\n                ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'percent'\n                ? (value | percent:column.pipeArgs.digitsInfo:grid.locale)\n                : value\n        \"\n        [row]=\"rowData\"\n        [column]=\"this.column.field\"\n        [containerClass]=\"'igx-grid__td-text'\"\n        [metadata]=\"searchMetadata\"\n    >{{\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === \"number\"\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === \"date\"\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : column.dataType === 'currency'\n                ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'percent'\n                ? (value | percent:column.pipeArgs.digitsInfo:grid.locale)\n                : value\n        }}</div>\n    <igx-icon\n        *ngIf=\"column.dataType === 'boolean'\"\n        [ngClass]=\"{ 'igx-icon--success': value, 'igx-icon--error': !value }\"\n        >{{ value ? \"check\" : \"close\" }}</igx-icon\n    >\n</ng-template>\n<ng-template #addRowCell let-cell=\"cell\">\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n    [cssClass]=\"highlightClass\"\n    [activeCssClass]=\"activeHighlightClass\"\n    [groupName]=\"gridID\"\n    [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ?\n        (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ?\n        (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : column.dataType === 'currency'?\n        (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'percent' ?\n        (value | percent:column.pipeArgs.digitsInfo:grid.locale) : value\"\n    [row]=\"rowData\"\n    [column]=\"this.column.field\"\n    [containerClass]=\"'igx-grid__td-text'\"\n    [metadata]=\"searchMetadata\">{{\n        !isEmptyAddRowCell ? value : (column.header || column.field)\n    }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"true\" />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [(ngModel)]=\"editValue\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox\n            (change)=\"editValue = $event.checked\"\n            [value]=\"editValue\"\n            [checked]=\"editValue\"\n            [disableRipple]=\"true\"\n        ></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker\n            [style.width.%]=\"100\"\n            [outlet]=\"grid.outlet\"\n            mode=\"dropdown\"\n            [locale]=\"grid.locale\"\n            [(value)]=\"editValue\"\n            [igxFocus]=\"true\"\n            [labelVisibility]=\"false\"\n        >\n        </igx-date-picker>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'currency'\">\n        <igx-input-group displayDensity=\"compact\">\n            <igx-prefix *ngIf=\"grid.currencyPositionLeft\">{{ currencyCodeSymbol }}</igx-prefix>\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n            <igx-suffix *ngIf=\"!grid.currencyPositionLeft\" >{{ currencyCodeSymbol }}</igx-suffix>\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'percent'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n            <igx-suffix> {{ editValue | percent:column.pipeArgs.digitsInfo:grid.locale }} </igx-suffix>\n        </igx-input-group>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"!editMode\">\n    <ng-container *ngIf=\"level > 0\">\n        <div\n            #indentationDiv\n            class=\"igx-grid__tree-cell--padding-level-{{ level }}\"\n        ></div>\n    </ng-container>\n    <div\n        #indicator\n        *ngIf=\"!isLoading\"\n        class=\"igx-grid__tree-grouping-indicator\"\n        [ngStyle]=\"{ visibility: showIndicator ? 'visible' : 'hidden' }\"\n        (click)=\"toggle($event)\"\n        (focus)=\"onIndicatorFocus($event)\"\n    >\n        <ng-container\n            *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\"\n        >\n        </ng-container>\n        <ng-container\n            *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\"\n        >\n        </ng-container>\n    </div>\n    <div\n        *ngIf=\"isLoading\"\n        (dblclick)=\"onLoadingDblClick($event)\"\n        class=\"igx-grid__tree-loading-indicator\"\n    >\n        <ng-container\n            *ngTemplateOutlet=\"\n                grid.rowLoadingIndicatorTemplate\n                    ? grid.rowLoadingIndicatorTemplate\n                    : defaultLoadingIndicatorTemplate\n            \"\n        >\n        </ng-container>\n    </div>\n    <ng-template #defaultLoadingIndicatorTemplate>\n        <igx-circular-bar [indeterminate]=\"true\"> </igx-circular-bar>\n    </ng-template>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\"> </ng-container>\n<ng-template #defaultExpandedTemplate>\n    <igx-icon>expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n    <igx-icon>chevron_right</igx-icon>\n</ng-template>\n",
                providers: [HammerGesturesManager]
            },] }
];
IgxTreeGridCellComponent.propDecorators = {
    level: [{ type: Input }],
    showIndicator: [{ type: Input }],
    isLoading: [{ type: Input }]
};

/** @hidden */
class IgxTreeGridFilteringPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(hierarchyData, expressionsTree, filterStrategy, advancedFilteringExpressionsTree, _, __, pinned) {
        const grid = this.gridAPI.grid;
        const state = {
            expressionsTree,
            advancedExpressionsTree: advancedFilteringExpressionsTree,
            strategy: new TreeGridFilteringStrategy()
        };
        if (filterStrategy) {
            state.strategy = filterStrategy;
        }
        if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
            grid.setFilteredData(null, pinned);
            return hierarchyData;
        }
        const result = this.filter(hierarchyData, state, grid);
        const filteredData = [];
        this.expandAllRecursive(grid, result, grid.expansionStates, filteredData);
        grid.setFilteredData(filteredData, pinned);
        return result;
    }
    expandAllRecursive(grid, data, expandedStates, filteredData) {
        for (const rec of data) {
            filteredData.push(rec.data);
            if (rec.children && rec.children.length > 0) {
                expandedStates.set(rec.rowID, true);
                this.expandAllRecursive(grid, rec.children, expandedStates, filteredData);
            }
        }
    }
    filter(data, state, grid) {
        return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree, grid);
    }
}
IgxTreeGridFilteringPipe.decorators = [
    { type: Pipe, args: [{
                name: 'treeGridFiltering',
                pure: true
            },] }
];
IgxTreeGridFilteringPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/** @hidden */
class IgxTreeGridSummaryPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(flatData, hasSummary, summaryCalculationMode, summaryPosition, showSummaryOnCollapse, _, __) {
        const grid = this.gridAPI.grid;
        if (!flatData || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
            return flatData;
        }
        return this.addSummaryRows(grid, flatData, summaryPosition, showSummaryOnCollapse);
    }
    addSummaryRows(grid, collection, summaryPosition, showSummaryOnCollapse) {
        const recordsWithSummary = [];
        const maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
        for (const record of collection) {
            recordsWithSummary.push(record);
            const isCollapsed = !record.expanded && record.children && record.children.length > 0 && showSummaryOnCollapse;
            if (isCollapsed) {
                let childData = record.children.filter(r => !r.isFilteredOutParent).map(r => r.data);
                childData = this.removeDeletedRecord(grid, record.rowID, childData);
                const summaries = grid.summaryService.calculateSummaries(record.rowID, childData);
                const summaryRecord = {
                    summaries,
                    max: maxSummaryHeight,
                    cellIndentation: record.level + 1
                };
                recordsWithSummary.push(summaryRecord);
            }
            const isExpanded = record.children && record.children.length > 0 && record.expanded;
            if (summaryPosition === GridSummaryPosition.bottom && !isExpanded) {
                let childRecord = record;
                let parent = record.parent;
                while (parent) {
                    const children = parent.children;
                    if (children[children.length - 1] === childRecord) {
                        let childData = children.filter(r => !r.isFilteredOutParent).map(r => r.data);
                        childData = this.removeDeletedRecord(grid, parent.rowID, childData);
                        const summaries = grid.summaryService.calculateSummaries(parent.rowID, childData);
                        const summaryRecord = {
                            summaries,
                            max: maxSummaryHeight,
                            cellIndentation: parent.level + 1
                        };
                        recordsWithSummary.push(summaryRecord);
                        childRecord = parent;
                        parent = childRecord.parent;
                    }
                    else {
                        break;
                    }
                }
            }
            else if (summaryPosition === GridSummaryPosition.top && isExpanded) {
                let childData = record.children.filter(r => !r.isFilteredOutParent).map(r => r.data);
                childData = this.removeDeletedRecord(grid, record.rowID, childData);
                const summaries = grid.summaryService.calculateSummaries(record.rowID, childData);
                const summaryRecord = {
                    summaries,
                    max: maxSummaryHeight,
                    cellIndentation: record.level + 1
                };
                recordsWithSummary.push(summaryRecord);
            }
        }
        return recordsWithSummary;
    }
    removeDeletedRecord(grid, rowId, data) {
        if (!grid.transactions.enabled || !grid.cascadeOnDelete) {
            return data;
        }
        const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === 'delete').map(t => t.id);
        let row = grid.records.get(rowId);
        if (!row && deletedRows.lenght === 0) {
            return [];
        }
        row = row.children ? row : row.parent;
        while (row) {
            rowId = row.rowID;
            if (deletedRows.indexOf(rowId) !== -1) {
                return [];
            }
            row = row.parent;
        }
        deletedRows.forEach(rowID => {
            const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
            const index = tempData.indexOf(rowID);
            if (index !== -1) {
                data.splice(index, 1);
            }
        });
        return data;
    }
}
IgxTreeGridSummaryPipe.decorators = [
    { type: Pipe, args: [{
                name: 'treeGridSummary',
                pure: true
            },] }
];
IgxTreeGridSummaryPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/**
 * @hidden
 */
class IgxTreeGridModule {
}
IgxTreeGridModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxTreeGridComponent,
                    IgxTreeGridRowComponent,
                    IgxTreeGridCellComponent,
                    IgxTreeGridHierarchizingPipe,
                    IgxTreeGridFlatteningPipe,
                    IgxTreeGridSortingPipe,
                    IgxTreeGridFilteringPipe,
                    IgxTreeGridPagingPipe,
                    IgxTreeGridTransactionPipe,
                    IgxTreeGridSummaryPipe,
                    IgxRowLoadingIndicatorTemplateDirective,
                    IgxTreeGridNormalizeRecordsPipe
                ],
                exports: [
                    IgxTreeGridComponent,
                    IgxTreeGridRowComponent,
                    IgxTreeGridCellComponent,
                    IgxRowLoadingIndicatorTemplateDirective,
                    IgxGridCommonModule
                ],
                imports: [
                    IgxGridCommonModule,
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

class IgxChildGridRowComponent {
    constructor(gridAPI, element, resolver, cdr) {
        this.gridAPI = gridAPI;
        this.element = element;
        this.cdr = cdr;
        /**
         *  The data passed to the row component.
         *
         * ```typescript
         * // get the row data for the first selected row
         * let selectedRowData = this.grid.selectedRows[0].rowData;
         * ```
         */
        this.rowData = [];
        /**
         * Returns whether the row is expanded.
         * ```typescript
         * const RowExpanded = this.grid1.rowList.first.expanded;
         * ```
         */
        this.expanded = false;
        this.resolver = resolver;
    }
    /**
     * @hidden
     */
    get parentHasScroll() {
        return !this.parentGrid.verticalScrollContainer.dc.instance.notVirtual;
    }
    /**
     * Get a reference to the grid that contains the selected row.
     *
     * ```typescript
     * handleRowSelection(event) {
     *  // the grid on which the onRowSelectionChange event was triggered
     *  const grid = event.row.grid;
     * }
     * ```
     *
     * ```html
     *  <igx-grid
     *    [data]="data"
     *    (onRowSelectionChange)="handleRowSelection($event)">
     *  </igx-grid>
     * ```
     */
    // TODO: Refactor
    get parentGrid() {
        return this.gridAPI.grid;
    }
    get level() {
        return this.layout.level;
    }
    /**
     * The native DOM element representing the row. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second selected row
     * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.layout.onLayoutChange.subscribe((ch) => {
            this._handleLayoutChanges(ch);
        });
        const changes = this.layout.initialChanges;
        changes.forEach(change => {
            this._handleLayoutChanges(change);
        });
        this.hGrid.parent = this.parentGrid;
        this.hGrid.parentIsland = this.layout;
        this.hGrid.childRow = this;
        // handler logic that re-emits hgrid events on the row island
        this.setupEventEmitters();
        this.layout.onGridCreated.emit({
            owner: this.layout,
            parentID: this.rowData.rowID,
            grid: this.hGrid
        });
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.hGrid.childLayoutList = this.layout.children;
        const layouts = this.hGrid.childLayoutList.toArray();
        layouts.forEach((l) => this.hGrid.hgridAPI.registerChildRowIsland(l));
        this.parentGrid.hgridAPI.registerChildGrid(this.rowData.rowID, this.layout.key, this.hGrid);
        this.layout.rowIslandAPI.registerChildGrid(this.rowData.rowID, this.hGrid);
        this.layout.onGridInitialized.emit({
            owner: this.layout,
            parentID: this.rowData.rowID,
            grid: this.hGrid
        });
        this.hGrid.cdr.detectChanges();
    }
    setupEventEmitters() {
        const destructor = takeUntil(this.hGrid.destroy$);
        const factory = this.resolver.resolveComponentFactory(IgxGridComponent);
        // exclude outputs related to two-way binding functionality
        const inputNames = factory.inputs.map(input => input.propName);
        const outputs = factory.outputs.filter(o => {
            const matchingInputPropName = o.propName.slice(0, o.propName.indexOf('Change'));
            return inputNames.indexOf(matchingInputPropName) === -1;
        });
        // TODO: Skip the `rendered` output. Rendered should be called once per grid.
        outputs.filter(o => o.propName !== 'rendered').forEach(output => {
            if (this.hGrid[output.propName]) {
                this.hGrid[output.propName].pipe(destructor).subscribe((args) => {
                    if (!args) {
                        args = {};
                    }
                    args.owner = this.hGrid;
                    this.layout[output.propName].emit(args);
                });
            }
        });
    }
    _handleLayoutChanges(changes) {
        for (const change in changes) {
            if (changes.hasOwnProperty(change)) {
                this.hGrid[change] = changes[change].currentValue;
            }
        }
    }
}
IgxChildGridRowComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-child-grid-row',
                template: "<div class=\"igx-grid__hierarchical-indent\" [ngClass]=\"{'igx-grid__hierarchical-indent--scroll': parentHasScroll}\">\n    <igx-hierarchical-grid #hgrid [data]='rowData.childGridsData[layout.key]'></igx-hierarchical-grid>\n</div>\n"
            },] }
];
IgxChildGridRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ElementRef },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef }
];
IgxChildGridRowComponent.propDecorators = {
    layout: [{ type: Input }],
    parentGridID: [{ type: Input }],
    rowData: [{ type: Input }],
    index: [{ type: Input }],
    hGrid: [{ type: ViewChild, args: ['hgrid', { static: true },] }],
    level: [{ type: HostBinding, args: ['attr.aria-level',] }]
};

class IgxHierarchicalGridNavigationService extends IgxGridNavigationService {
    constructor() {
        super(...arguments);
        this._pendingNavigation = false;
    }
    dispatchEvent(event) {
        const key = event.key.toLowerCase();
        if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) &&
            !this.grid.crudService.rowEditingBlocked && !this.grid.rowInEditMode) {
            return;
        }
        const targetGrid = this.getClosestElemByTag(event.target, 'igx-hierarchical-grid');
        if (targetGrid !== this.grid.nativeElement) {
            return;
        }
        if (this._pendingNavigation && NAVIGATION_KEYS.has(key)) {
            // In case focus needs to be moved from one grid to another, however there is a pending scroll operation
            // which is an async operation, any additional navigation keys should be ignored
            // untill operation complete.
            event.preventDefault();
            return;
        }
        super.dispatchEvent(event);
    }
    navigateInBody(rowIndex, visibleColIndex, cb = null) {
        const rec = this.grid.dataView[rowIndex];
        if (rec && this.grid.isChildGridRecord(rec)) {
            // target is child grid
            const virtState = this.grid.verticalScrollContainer.state;
            const inView = rowIndex >= virtState.startIndex && rowIndex <= virtState.startIndex + virtState.chunkSize;
            const isNext = this.activeNode.row < rowIndex;
            const targetLayoutIndex = isNext ? null : this.grid.childLayoutKeys.length - 1;
            if (inView) {
                this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            }
            else {
                let scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(rowIndex, !isNext);
                scrollAmount += isNext ? 1 : -1;
                this.grid.verticalScrollContainer.getScroll().scrollTop = scrollAmount;
                this._pendingNavigation = true;
                this.grid.verticalScrollContainer.onChunkLoad.pipe(first$1()).subscribe(() => {
                    this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
                    this._pendingNavigation = false;
                });
            }
            return;
        }
        const isLast = rowIndex === this.grid.dataView.length;
        if ((rowIndex === -1 || isLast) &&
            this.grid.parent !== null) {
            // reached end of child grid
            const nextSiblingIndex = this.nextSiblingIndex(isLast);
            if (nextSiblingIndex !== null) {
                this.grid.parent.navigation._moveToChild(this.grid.childRow.index, visibleColIndex, isLast, nextSiblingIndex, cb);
            }
            else {
                this._moveToParent(isLast, visibleColIndex, cb);
            }
            return;
        }
        if (this.grid.parent) {
            const isNext = this.activeNode && typeof this.activeNode.row === 'number' ? rowIndex > this.activeNode.row : false;
            const cbHandler = (args) => {
                this._handleScrollInChild(rowIndex, isNext);
                cb(args);
            };
            if (!this.activeNode) {
                this.activeNode = { row: null, column: null };
            }
            super.navigateInBody(rowIndex, visibleColIndex, cbHandler);
            return;
        }
        if (!this.activeNode) {
            this.activeNode = { row: null, column: null };
        }
        super.navigateInBody(rowIndex, visibleColIndex, cb);
    }
    shouldPerformVerticalScroll(index, visibleColumnIndex = -1, isNext) {
        const targetRec = this.grid.dataView[index];
        if (this.grid.isChildGridRecord(targetRec)) {
            const scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(index, !isNext);
            const currScroll = this.grid.verticalScrollContainer.getScroll().scrollTop;
            const shouldScroll = !isNext ? scrollAmount > currScroll : currScroll < scrollAmount;
            return shouldScroll;
        }
        else {
            return super.shouldPerformVerticalScroll(index, visibleColumnIndex);
        }
    }
    focusTbody(event) {
        if (!this.activeNode || this.activeNode.row === null) {
            this.activeNode = {
                row: 0,
                column: 0
            };
            this.grid.navigateTo(0, 0, (obj) => {
                this.grid.clearCellSelection();
                obj.target.activate(event);
            });
        }
        else {
            super.focusTbody(event);
        }
    }
    nextSiblingIndex(isNext) {
        const layoutKey = this.grid.childRow.layout.key;
        const layoutIndex = this.grid.parent.childLayoutKeys.indexOf(layoutKey);
        const nextIndex = isNext ? layoutIndex + 1 : layoutIndex - 1;
        if (nextIndex <= this.grid.parent.childLayoutKeys.length - 1 && nextIndex > -1) {
            return nextIndex;
        }
        else {
            return null;
        }
    }
    /**
     * Handles scrolling in child grid and ensures target child row is in main grid view port.
     *
     * @param rowIndex The row index which should be in view.
     * @param isNext  Optional. Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    _handleScrollInChild(rowIndex, isNext, cb) {
        const shouldScroll = this.shouldPerformVerticalScroll(rowIndex, -1, isNext);
        if (shouldScroll) {
            this.grid.navigation.performVerticalScrollToCell(rowIndex, -1, () => {
                this.positionInParent(rowIndex, isNext, cb);
            });
        }
        else {
            this.positionInParent(rowIndex, isNext, cb);
        }
    }
    /**
     *
     * @param rowIndex Row index that should come in view.
     * @param isNext  Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    positionInParent(rowIndex, isNext, cb) {
        const rowObj = this.grid.getRowByIndex(rowIndex);
        if (!rowObj) {
            if (cb) {
                cb();
            }
            return;
        }
        const positionInfo = this.getPositionInfo(rowObj, isNext);
        if (!positionInfo.inView) {
            // stop event from triggering multiple times before scrolling is complete.
            this._pendingNavigation = true;
            const scrollableGrid = isNext ? this.getNextScrollableDown(this.grid) : this.getNextScrollableUp(this.grid);
            scrollableGrid.grid.verticalScrollContainer.recalcUpdateSizes();
            scrollableGrid.grid.verticalScrollContainer.addScrollTop(positionInfo.offset);
            scrollableGrid.grid.verticalScrollContainer.onChunkLoad.pipe(first$1()).subscribe(() => {
                this._pendingNavigation = false;
                if (cb) {
                    cb();
                }
            });
        }
        else {
            if (cb) {
                cb();
            }
        }
    }
    /**
     * Moves navigation to child grid.
     *
     * @param parentRowIndex The parent row index, at which the child grid is rendered.
     * @param childLayoutIndex Optional. The index of the child row island to which the child grid belongs to. Uses first if not set.
     */
    _moveToChild(parentRowIndex, visibleColIndex, isNext, childLayoutIndex, cb) {
        const ri = typeof childLayoutIndex !== 'number' ?
            this.grid.childLayoutList.first : this.grid.childLayoutList.toArray()[childLayoutIndex];
        const rowId = this.grid.dataView[parentRowIndex].rowID;
        const pathSegment = {
            rowID: rowId,
            rowIslandKey: ri.key
        };
        const childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
        const targetIndex = isNext ? 0 : childGrid.dataView.length - 1;
        const targetRec = childGrid.dataView[targetIndex];
        if (!targetRec) {
            // if no target rec, then move on in next sibling or parent
            childGrid.navigation.navigateInBody(targetIndex, visibleColIndex, cb);
            return;
        }
        if (childGrid.isChildGridRecord(targetRec)) {
            // if target is a child grid record should move into it.
            this.grid.navigation.activeNode.row = null;
            childGrid.navigation.activeNode = { row: targetIndex, column: this.activeNode.column };
            childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
                const targetLayoutIndex = isNext ? 0 : childGrid.childLayoutList.toArray().length - 1;
                childGrid.navigation._moveToChild(targetIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            });
            return;
        }
        const childGridNav = childGrid.navigation;
        this.clearActivation();
        const lastVisibleIndex = childGridNav.lastColumnIndex;
        const columnIndex = visibleColIndex <= lastVisibleIndex ? visibleColIndex : lastVisibleIndex;
        childGridNav.activeNode = { row: targetIndex, column: columnIndex };
        childGrid.tbody.nativeElement.focus({ preventScroll: true });
        this._pendingNavigation = false;
        childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
            childGrid.navigateTo(targetIndex, columnIndex, cb);
        });
    }
    /**
     * Moves navigation back to parent grid.
     *
     * @param rowIndex
     */
    _moveToParent(isNext, columnIndex, cb) {
        const indexInParent = this.grid.childRow.index;
        const hasNextTarget = this.hasNextTarget(this.grid.parent, indexInParent, isNext);
        if (!hasNextTarget) {
            return;
        }
        this.clearActivation();
        const targetRowIndex = isNext ? indexInParent + 1 : indexInParent - 1;
        const lastVisibleIndex = this.grid.parent.navigation.lastColumnIndex;
        const nextColumnIndex = columnIndex <= lastVisibleIndex ? columnIndex : lastVisibleIndex;
        this._pendingNavigation = true;
        const cbFunc = (args) => {
            this._pendingNavigation = false;
            cb(args);
            args.target.grid.tbody.nativeElement.focus();
        };
        this.grid.parent.navigation.navigateInBody(targetRowIndex, nextColumnIndex, cbFunc);
    }
    /**
     * Gets information on the row position relative to the root grid view port.
     * Returns whether the row is in view and its offset.
     *
     * @param rowObj
     * @param isNext
     */
    getPositionInfo(rowObj, isNext) {
        let rowElem = rowObj.nativeElement;
        if (rowObj instanceof IgxChildGridRowComponent) {
            const childLayoutKeys = this.grid.childLayoutKeys;
            const riKey = isNext ? childLayoutKeys[0] : childLayoutKeys[childLayoutKeys.length - 1];
            const pathSegment = {
                rowID: rowObj.rowData.rowID,
                rowIslandKey: riKey
            };
            const childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
            rowElem = childGrid.tfoot.nativeElement;
        }
        const gridBottom = this._getMinBottom(this.grid);
        const diffBottom = rowElem.getBoundingClientRect().bottom - gridBottom;
        const gridTop = this._getMaxTop(this.grid);
        const diffTop = rowElem.getBoundingClientRect().bottom -
            rowElem.offsetHeight - gridTop;
        const isInView = isNext ? diffBottom <= 0 : diffTop >= 0;
        const calcOffset = isNext ? diffBottom : diffTop;
        return { inView: isInView, offset: calcOffset };
    }
    /**
     * Gets closest element by its tag name.
     *
     * @param sourceElem The element from which to start the search.
     * @param targetTag The target element tag name, for which to search.
     */
    getClosestElemByTag(sourceElem, targetTag) {
        let result = sourceElem;
        while (result !== null && result.nodeType === 1) {
            if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {
                return result;
            }
            result = result.parentNode;
        }
        return null;
    }
    clearActivation() {
        // clear if previous activation exists.
        if (this.activeNode) {
            this.activeNode.row = null;
        }
    }
    hasNextTarget(grid, index, isNext) {
        const targetRowIndex = isNext ? index + 1 : index - 1;
        const hasTargetRecord = !!grid.dataView[targetRowIndex];
        if (hasTargetRecord) {
            return true;
        }
        else {
            let hasTargetRecordInParent = false;
            if (grid.parent) {
                const indexInParent = grid.childRow.index;
                hasTargetRecordInParent = this.hasNextTarget(grid.parent, indexInParent, isNext);
            }
            return hasTargetRecordInParent;
        }
    }
    /**
     * Gets the max top view in the current grid hierarchy.
     *
     * @param grid
     */
    _getMaxTop(grid) {
        let currGrid = grid;
        let top = currGrid.tbody.nativeElement.getBoundingClientRect().top;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top + pinnedRowsHeight);
        }
        return top;
    }
    /**
     * Gets the min bottom view in the current grid hierarchy.
     *
     * @param grid
     */
    _getMinBottom(grid) {
        let currGrid = grid;
        let bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && !currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom - pinnedRowsHeight);
        }
        return bottom;
    }
    /**
     * Finds the next grid that allows scrolling down.
     *
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableDown(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid, prev: null };
        }
        let scrollTop = currGrid.verticalScrollContainer.scrollPosition;
        let scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
        let nonScrollable = scrollHeight === 0 ||
            Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            scrollTop = currGrid.verticalScrollContainer.scrollPosition;
            scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
            nonScrollable = scrollHeight === 0 ||
                Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        }
        return { grid: currGrid, prev };
    }
    /**
     * Finds the next grid that allows scrolling up.
     *
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableUp(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid, prev: null };
        }
        let nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        }
        return { grid: currGrid, prev };
    }
}
IgxHierarchicalGridNavigationService.decorators = [
    { type: Injectable }
];

const hierarchicalTransactionServiceFactory = () => new IgxTransactionService();
const IgxHierarchicalTransactionServiceFactory = {
    provide: IgxGridTransaction,
    useFactory: hierarchicalTransactionServiceFactory
};
class IgxHierarchicalGridBaseDirective extends IgxGridBaseDirective {
    constructor(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId) {
        super(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId);
        this.selectionService = selectionService;
        this.colResizingService = colResizingService;
        this.transactionFactory = transactionFactory;
        this.document = document;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * Gets/Sets whether the expand/collapse all button in the header should be rendered.
         *
         * @remark
         * The default value is false.
         * @example
         * ```html
         * <igx-hierarchical-grid #grid [data]="localData" [showExpandAll]="true">
         * </igx-hierarchical-grid>
         * ```
         */
        this.showExpandAll = false;
        /**
         * Emitted when a new chunk of data is loaded from virtualization.
         *
         * @example
         * ```typescript
         *  <igx-hierarchical-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true" (onDataPreLoad)="handleEvent()">
         *  </igx-hierarchical-grid>
         * ```
         */
        this.onDataPreLoad = new EventEmitter();
        this.hgridAPI = gridAPI;
    }
    /**
     * @hidden
     */
    get maxLevelHeaderDepth() {
        if (this._maxLevelHeaderDepth === null) {
            this._maxLevelHeaderDepth = this.columnList.reduce((acc, col) => Math.max(acc, col.level), 0);
        }
        return this._maxLevelHeaderDepth;
    }
    /**
     * Gets the outlet used to attach the grid's overlays to.
     *
     * @remark
     * If set, returns the outlet defined outside the grid. Otherwise returns the grid's internal outlet directive.
     */
    get outlet() {
        return this.rootGrid ? this.rootGrid.resolveOutlet() : this.resolveOutlet();
    }
    /**
     * Sets the outlet used to attach the grid's overlays to.
     */
    set outlet(val) {
        this._userOutletDirective = val;
    }
    /**
     * @hidden
     */
    createColumnsList(cols) {
        const columns = [];
        const topLevelCols = this.onlyTopLevel(cols);
        topLevelCols.forEach((col) => {
            const ref = this._createColumn(col);
            ref.changeDetectorRef.detectChanges();
            columns.push(ref.instance);
        });
        const result = flatten$1(columns);
        this.columnList.reset(result);
        this.columnList.notifyOnChanges();
        this.initPinning();
        const factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);
        const outputs = factoryColumn.outputs.filter(o => o.propName !== 'onColumnChange');
        outputs.forEach(output => {
            this.columnList.forEach(column => {
                if (column[output.propName]) {
                    column[output.propName].pipe(takeUntil(column.destroy$)).subscribe((args) => {
                        const rowIslandColumn = this.parentIsland.childColumns.find(col => col.field === column.field);
                        rowIslandColumn[output.propName].emit({ args, owner: this });
                    });
                }
            });
        });
    }
    _createColumn(col) {
        let ref;
        if (col instanceof IgxColumnGroupComponent) {
            ref = this._createColGroupComponent(col);
        }
        else {
            ref = this._createColComponent(col);
        }
        return ref;
    }
    _createColGroupComponent(col) {
        const factoryGroup = this.resolver.resolveComponentFactory(IgxColumnGroupComponent);
        const ref = this.viewRef.createComponent(factoryGroup, null, this.viewRef.injector);
        ref.changeDetectorRef.detectChanges();
        factoryGroup.inputs.forEach((input) => {
            const propName = input.propName;
            ref.instance[propName] = col[propName];
        });
        if (col.children.length > 0) {
            const newChildren = [];
            col.children.forEach(child => {
                const newCol = this._createColumn(child).instance;
                newCol.parent = ref.instance;
                newChildren.push(newCol);
            });
            ref.instance.children.reset(newChildren);
            ref.instance.children.notifyOnChanges();
        }
        return ref;
    }
    _createColComponent(col) {
        const factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);
        const ref = this.viewRef.createComponent(factoryColumn, null, this.viewRef.injector);
        factoryColumn.inputs.forEach((input) => {
            const propName = input.propName;
            if (!(col[propName] instanceof IgxSummaryOperand)) {
                ref.instance[propName] = col[propName];
            }
            else {
                ref.instance[propName] = col[propName].constructor;
            }
        });
        return ref;
    }
    getGridsForIsland(rowIslandID) {
        return this.hgridAPI.getChildGridsForRowIsland(rowIslandID);
    }
    getChildGrid(path) {
        if (!path) {
            return;
        }
        return this.hgridAPI.getChildGrid(path);
    }
}
IgxHierarchicalGridBaseDirective.decorators = [
    { type: Directive }
];
IgxHierarchicalGridBaseDirective.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: IgxColumnResizingService },
    { type: GridBaseAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
    { type: ElementRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: IterableDiffers },
    { type: ViewContainerRef },
    { type: IgxHierarchicalGridNavigationService },
    { type: IgxFilteringService },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxGridSummaryService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
IgxHierarchicalGridBaseDirective.propDecorators = {
    hasChildrenKey: [{ type: Input }],
    showExpandAll: [{ type: Input }],
    onDataPreLoad: [{ type: Output }],
    dragIndicatorIconBase: [{ type: ViewChild, args: ['dragIndicatorIconBase', { read: TemplateRef, static: true },] }]
};
const flatten$1 = (arr) => {
    let result = [];
    arr.forEach(el => {
        result.push(el);
        if (el.children) {
            result = result.concat(flatten$1(el.children.toArray()));
        }
    });
    return result;
};
const ɵ0$6 = flatten$1;

class IgxHierarchicalGridAPIService extends GridBaseAPIService {
    constructor() {
        super(...arguments);
        this.childRowIslands = new Map();
        this.childGrids = new Map();
    }
    registerChildRowIsland(rowIsland) {
        this.childRowIslands.set(rowIsland.key, rowIsland);
        this.destroyMap.set(rowIsland.key, new Subject());
    }
    unsetChildRowIsland(rowIsland) {
        this.childGrids.delete(rowIsland.key);
        this.childRowIslands.delete(rowIsland.key);
        this.destroyMap.delete(rowIsland.key);
    }
    getChildRowIsland(key) {
        return this.childRowIslands.get(key);
    }
    getChildGrid(path) {
        const currPath = path;
        let grid;
        const pathElem = currPath.shift();
        const childrenForLayout = this.childGrids.get(pathElem.rowIslandKey);
        if (childrenForLayout) {
            const childGrid = childrenForLayout.get(pathElem.rowID);
            if (currPath.length === 0) {
                grid = childGrid;
            }
            else {
                grid = childGrid.hgridAPI.getChildGrid(currPath);
            }
        }
        return grid;
    }
    getChildGrids(inDepth) {
        const allChildren = [];
        this.childGrids.forEach((layoutMap) => {
            layoutMap.forEach((grid) => {
                allChildren.push(grid);
                if (inDepth) {
                    const children = grid.hgridAPI.getChildGrids(inDepth);
                    children.forEach((item) => {
                        allChildren.push(item);
                    });
                }
            });
        });
        return allChildren;
    }
    getParentRowId(childGrid) {
        let rowID;
        this.childGrids.forEach((layoutMap) => {
            layoutMap.forEach((grid, key) => {
                if (grid === childGrid) {
                    rowID = key;
                    return;
                }
            });
        });
        return rowID;
    }
    registerChildGrid(parentRowID, rowIslandKey, grid) {
        let childrenForLayout = this.childGrids.get(rowIslandKey);
        if (!childrenForLayout) {
            this.childGrids.set(rowIslandKey, new Map());
            childrenForLayout = this.childGrids.get(rowIslandKey);
        }
        childrenForLayout.set(parentRowID, grid);
    }
    getChildGridsForRowIsland(rowIslandKey) {
        const childrenForLayout = this.childGrids.get(rowIslandKey);
        const children = [];
        if (childrenForLayout) {
            childrenForLayout.forEach((child) => {
                children.push(child);
            });
        }
        return children;
    }
    getChildGridByID(rowIslandKey, rowID) {
        const childrenForLayout = this.childGrids.get(rowIslandKey);
        return childrenForLayout.get(rowID);
    }
    get_row_expansion_state(record) {
        let inState;
        if (record.childGridsData !== undefined) {
            const ri = record.rowID;
            const states = this.grid.expansionStates;
            const expanded = states.get(ri);
            if (expanded !== undefined) {
                return expanded;
            }
            else {
                return this.grid.getDefaultExpandState(record);
            }
        }
        else {
            inState = !!super.get_row_expansion_state(record);
        }
        return inState && this.grid.childLayoutList.length !== 0;
    }
    allow_expansion_state_change(rowID, expanded) {
        const rec = this.get_rec_by_id(rowID);
        const grid = this.grid;
        if (grid.hasChildrenKey && !rec[grid.hasChildrenKey]) {
            return false;
        }
        return !!rec && this.grid.expansionStates.get(rowID) !== expanded;
    }
    get_rec_by_id(rowID) {
        const data = this.get_all_data(false);
        const index = this.get_row_index_in_data(rowID, data);
        return data[index];
    }
}
IgxHierarchicalGridAPIService.decorators = [
    { type: Injectable }
];

class IgxRowIslandAPIService {
    constructor() {
        this.change = new Subject();
        this.state = new Map();
        this.destroyMap = new Map();
        this.childRowIslands = new Map();
        this.childGrids = new Map();
    }
    register(rowIsland) {
        this.state.set(rowIsland.id, rowIsland);
        this.destroyMap.set(rowIsland.id, new Subject());
    }
    unsubscribe(rowIsland) {
        this.state.delete(rowIsland.id);
    }
    get(id) {
        return this.state.get(id);
    }
    unset(id) {
        this.state.delete(id);
        this.destroyMap.delete(id);
    }
    reset(oldId, newId) {
        const destroy = this.destroyMap.get(oldId);
        const rowIsland = this.get(oldId);
        this.unset(oldId);
        if (rowIsland) {
            this.state.set(newId, rowIsland);
        }
        if (destroy) {
            this.destroyMap.set(newId, destroy);
        }
    }
    registerChildRowIsland(rowIsland) {
        this.childRowIslands.set(rowIsland.key, rowIsland);
        this.destroyMap.set(rowIsland.key, new Subject());
    }
    unsetChildRowIsland(rowIsland) {
        this.childRowIslands.delete(rowIsland.key);
        this.destroyMap.delete(rowIsland.key);
    }
    getChildRowIsland(rowIslandKey) {
        return this.childRowIslands.get(rowIslandKey);
    }
    registerChildGrid(parentRowID, grid) {
        this.childGrids.set(parentRowID, grid);
    }
    getChildGrids(inDepth) {
        let allChildren = [];
        this.childGrids.forEach((grid) => {
            allChildren.push(grid);
        });
        if (inDepth) {
            this.childRowIslands.forEach((layout) => {
                allChildren = allChildren.concat(layout.rowIslandAPI.getChildGrids(inDepth));
            });
        }
        return allChildren;
    }
    getChildGridByID(rowID) {
        return this.childGrids.get(rowID);
    }
}
IgxRowIslandAPIService.decorators = [
    { type: Injectable }
];

/* eslint-disable @angular-eslint/no-conflicting-lifecycle */
class IgxRowIslandComponent extends IgxHierarchicalGridBaseDirective {
    constructor(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, rowIslandAPI, localeId) {
        super(selectionService, crudService, colResizingService, gridAPI, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId);
        this.selectionService = selectionService;
        this.colResizingService = colResizingService;
        this.transactionFactory = transactionFactory;
        this.document = document;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        this.rowIslandAPI = rowIslandAPI;
        /**
         * @hidden
         */
        this.children = new QueryList();
        /**
         * @hidden
         */
        this.childColumns = new QueryList();
        /**
         * @hidden
         */
        this.onLayoutChange = new EventEmitter();
        /**
         * Event emmited when a grid is being created based on this row island.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
         *      <igx-row-island [key]="'childData'" (onGridCreated)="gridCreated($event)" #rowIsland>
         *          <!-- ... -->
         *      </igx-row-island>
         * </igx-hierarchical-grid>
         * ```
         *
         * @memberof IgxRowIslandComponent
         */
        this.onGridCreated = new EventEmitter();
        /**
         * Emitted after a grid is being initialized for this row island.
         * The emitting is done in `ngAfterViewInit`.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
         *      <igx-row-island [key]="'childData'" (onGridInitialized)="gridInitialized($event)" #rowIsland>
         *          <!-- ... -->
         *      </igx-row-island>
         * </igx-hierarchical-grid>
         * ```
         *
         * @memberof IgxRowIslandComponent
         */
        this.onGridInitialized = new EventEmitter();
        /**
         * @hidden
         */
        this.initialChanges = [];
        /**
         * @hidden
         */
        this.rootGrid = null;
        this.layout_id = `igx-row-island-`;
        this.isInit = false;
        this.hgridAPI = gridAPI;
    }
    /**
     * Sets if all immediate children of the grids for this `IgxRowIslandComponent` should be expanded/collapsed.
     * ```html
     * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
     *      <igx-row-island [key]="'childData'" [expandChildren]="true" #rowIsland>
     *          <!-- ... -->
     *      </igx-row-island>
     * </igx-hierarchical-grid>
     * ```
     *
     * @memberof IgxRowIslandComponent
     */
    set expandChildren(value) {
        this._defaultExpandState = value;
        this.rowIslandAPI.getChildGrids().forEach((grid) => {
            if (document.body.contains(grid.nativeElement)) {
                // Detect changes right away if the grid is visible
                grid.expandChildren = value;
                grid.markForCheck();
            }
            else {
                // Else defer the detection on changes when the grid gets into view for performance.
                grid.updateOnRender = true;
            }
        });
    }
    /**
     * Gets if all immediate children of the grids for this `IgxRowIslandComponent` have been set to be expanded/collapsed.
     * ```typescript
     * const expanded = this.rowIsland.expandChildren;
     * ```
     *
     * @memberof IgxRowIslandComponent
     */
    get expandChildren() {
        return this._defaultExpandState;
    }
    /**
     * @hidden
     */
    get id() {
        const pId = this.parentId ? this.parentId.substring(this.parentId.indexOf(this.layout_id) + this.layout_id.length) + '-' : '';
        return this.layout_id + pId + this.key;
    }
    /**
     * @hidden
     */
    get parentId() {
        return this.parentIsland ? this.parentIsland.id : null;
    }
    /**
     * @hidden
     */
    get level() {
        let ptr = this.parentIsland;
        let lvl = 0;
        while (ptr) {
            lvl++;
            ptr = ptr.parentIsland;
        }
        return lvl + 1;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.filteringService.grid = this;
        this.rootGrid = this.hgridAPI.grid;
        this.rowIslandAPI.rowIsland = this;
        this.ri_columnListDiffer = this.differs.find([]).create(null);
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.updateChildren();
        this.children.notifyOnChanges();
        this.children.changes.pipe(takeUntil(this.destroy$))
            .subscribe(() => {
            this.updateChildren();
            // update existing grids since their child ri have been changed.
            this.getGridsForIsland(this.key).forEach(grid => {
                grid.onRowIslandChange(this.children);
            });
        });
        const nestedColumns = this.children.map((layout) => layout.columnList.toArray());
        const colsArray = [].concat.apply([], nestedColumns);
        const topCols = this.columnList.filter((item) => colsArray.indexOf(item) === -1);
        this.childColumns.reset(topCols);
        this.columnList.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
            Promise.resolve().then(() => {
                this.updateColumnList();
            });
        });
        // handle column changes so that they are passed to child grid instances when onColumnChange is emitted.
        this.ri_columnListDiffer.diff(this.childColumns);
        this.childColumns.toArray().forEach(x => x.onColumnChange.pipe(takeUntil(x.destroy$)).subscribe(() => this.updateColumnList()));
        this.childColumns.changes.pipe(takeUntil(this.destroy$)).subscribe((change) => {
            const diff = this.ri_columnListDiffer.diff(change);
            if (diff) {
                diff.forEachAddedItem((record) => {
                    record.item.onColumnChange.pipe(takeUntil(record.item.destroy$)).subscribe(() => this.updateColumnList());
                });
            }
        });
        this.actionStrip = this.actionStrips.first;
        if (this.actionStrip) {
            this.actionStrip.menuOverlaySettings.outlet = this.outlet;
        }
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.rowIslandAPI.register(this);
        if (this.parentIsland) {
            this.parentIsland.rowIslandAPI.registerChildRowIsland(this);
        }
        else {
            this.rootGrid.hgridAPI.registerChildRowIsland(this);
        }
        this._init = false;
        // Create the child toolbar if the parent island has a toolbar definition
        this.onGridCreated.pipe(pluck('grid'), takeUntil(this.destroy$)).subscribe(grid => {
            grid.rendered$.pipe(first$1(), filter(() => !!this.islandToolbarTemplate))
                .subscribe(() => grid.toolbarOutlet.createEmbeddedView(this.islandToolbarTemplate, { $implicit: grid }));
        });
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        this.onLayoutChange.emit(changes);
        if (!this.isInit) {
            this.initialChanges.push(changes);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        // Override the base destroy because we don't have rendered anything to use removeEventListener on
        this.destroy$.next(true);
        this.destroy$.complete();
        this._destroyed = true;
        this.rowIslandAPI.unset(this.id);
        if (this.parentIsland) {
            this.getGridsForIsland(this.key).forEach(grid => {
                this.cleanGridState(grid);
                grid.hgridAPI.unsetChildRowIsland(this);
            });
            this.parentIsland.rowIslandAPI.unsetChildRowIsland(this);
        }
        else {
            this.rootGrid.hgridAPI.unsetChildRowIsland(this);
            this.cleanGridState(this.rootGrid);
        }
    }
    /**
     * @hidden
     */
    ngDoCheck() {
    }
    /**
     * @hidden
     */
    reflow() { }
    /**
     * @hidden
     */
    calculateGridHeight() { }
    updateColumnList() {
        const nestedColumns = this.children.map((layout) => layout.columnList.toArray());
        const colsArray = [].concat.apply([], nestedColumns);
        const topCols = this.columnList.filter((item) => {
            if (colsArray.indexOf(item) === -1) {
                /* Reset the default width of the columns that come into this row island,
                because the root catches them first during the detectChanges() and sets their defaultWidth. */
                item.defaultWidth = undefined;
                return true;
            }
            return false;
        });
        this.childColumns.reset(topCols);
        if (this.parentIsland) {
            this.parentIsland.columnList.notifyOnChanges();
        }
        else {
            this.rootGrid.columnList.notifyOnChanges();
        }
        this.rowIslandAPI.getChildGrids().forEach((grid) => {
            grid.createColumnsList(this.childColumns.toArray());
            if (!document.body.contains(grid.nativeElement)) {
                grid.updateOnRender = true;
            }
        });
    }
    updateChildren() {
        if (this.children.first === this) {
            this.children.reset(this.children.toArray().slice(1));
        }
        this.children.forEach(child => {
            child.parentIsland = this;
        });
    }
    cleanGridState(grid) {
        grid.childGridTemplates.forEach((tmpl) => {
            tmpl.owner.cleanView(tmpl.context.templateID);
        });
        grid.childGridTemplates.clear();
        grid.onRowIslandChange();
    }
}
IgxRowIslandComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-row-island',
                template: ``,
                providers: [IgxRowIslandAPIService,
                    IgxFilteringService,
                    IgxGridSelectionService]
            },] }
];
IgxRowIslandComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: IgxColumnResizingService },
    { type: GridBaseAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
    { type: ElementRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: IterableDiffers },
    { type: ViewContainerRef },
    { type: IgxHierarchicalGridNavigationService },
    { type: IgxFilteringService },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxGridSummaryService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: IgxRowIslandAPIService },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
IgxRowIslandComponent.propDecorators = {
    key: [{ type: Input }],
    children: [{ type: ContentChildren, args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false },] }],
    childColumns: [{ type: ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: false },] }],
    islandToolbarTemplate: [{ type: ContentChild, args: [IgxGridToolbarDirective, { read: TemplateRef },] }],
    actionStrips: [{ type: ContentChildren, args: [IgxActionStripComponent, { read: IgxActionStripComponent, descendants: false },] }],
    onLayoutChange: [{ type: Output }],
    onGridCreated: [{ type: Output }],
    onGridInitialized: [{ type: Output }],
    expandChildren: [{ type: Input }]
};

let NEXT_ID$n = 0;
class IgxHierarchicalGridComponent extends IgxHierarchicalGridBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * @hidden @internal
         */
        this.role = 'grid';
        /**
         * @hidden
         */
        this.childLayoutKeys = [];
        /**
         * @hidden
         */
        this.highlightedRowID = null;
        /**
         * @hidden
         */
        this.updateOnRender = false;
        /**
         * @hidden
         */
        this.parent = null;
        this._filteredData = null;
        this.h_id = `igx-hierarchical-grid-${NEXT_ID$n++}`;
        this.childGridTemplates = new Map();
        this.scrollTop = 0;
        this.scrollLeft = 0;
    }
    /**
     * Gets/Sets the value of the `id` attribute.
     *
     * @remarks
     * If not provided it will be automatically generated.
     * @example
     * ```html
     * <igx-hierarchical-grid [id]="'igx-hgrid-1'" [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
     * ```
     */
    get id() {
        return this.h_id;
    }
    set id(value) {
        this.h_id = value;
    }
    /**
     * An @Input property that lets you fill the `IgxHierarchicalGridComponent` with an array of data.
     * ```html
     * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
     * ```
     *
     * @memberof IgxHierarchicalGridComponent
     */
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
            this.reflow();
        }
        this.cdr.markForCheck();
        if (this.parent && (this.height === null || this.height.indexOf('%') !== -1)) {
            // If the height will change based on how much data there is, recalculate sizes in igxForOf.
            this.notifyChanges(true);
        }
    }
    /**
     * Returns an array of data set to the `IgxHierarchicalGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     *
     * @memberof IgxHierarchicalGridComponent
     */
    get data() {
        return this._data;
    }
    /**
     * Sets an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
     * ```typescript
     * this.grid.filteredData = [{
     *       ID: 1,
     *       Name: "A"
     * }];
     * ```
     *
     * @memberof IgxHierarchicalGridComponent
     */
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Returns an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     *
     * @memberof IgxHierarchicalGridComponent
     */
    get filteredData() {
        return this._filteredData;
    }
    /**
     * Gets/Sets the total number of records in the data source.
     *
     * @remarks
     * This property is required for remote grid virtualization to function when it is bound to remote data.
     * @example
     * ```typescript
     * const itemCount = this.grid1.totalItemCount;
     * this.grid1.totalItemCount = 55;
     * ```
     */
    set totalItemCount(count) {
        this.verticalScrollContainer.totalItemCount = count;
        this.cdr.detectChanges();
    }
    get totalItemCount() {
        return this.verticalScrollContainer.totalItemCount;
    }
    /**
     * Sets if all immediate children of the `IgxHierarchicalGridComponent` should be expanded/collapsed.
     * Defult value is false.
     * ```html
     * <igx-hierarchical-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true" [expandChildren]="true"></igx-hierarchical-grid>
     * ```
     *
     * @memberof IgxHierarchicalGridComponent
     */
    set expandChildren(value) {
        this._defaultExpandState = value;
        this.expansionStates = new Map();
    }
    /**
     * Gets if all immediate children of the `IgxHierarchicalGridComponent` previously have been set to be expanded/collapsed.
     * If previously set and some rows have been manually expanded/collapsed it will still return the last set value.
     * ```typescript
     * const expanded = this.grid.expandChildren;
     * ```
     *
     * @memberof IgxHierarchicalGridComponent
     */
    get expandChildren() {
        return this._defaultExpandState;
    }
    /**
     * Gets the unique identifier of the parent row. It may be a `string` or `number` if `primaryKey` of the
     * parent grid is set or an object reference of the parent record otherwise.
     * ```typescript
     * const foreignKey = this.grid.foreignKey;
     * ```
     *
     * @memberof IgxHierarchicalGridComponent
     */
    get foreignKey() {
        if (!this.parent) {
            return null;
        }
        return this.parent.hgridAPI.getParentRowId(this);
    }
    /**
     * @hidden
     */
    get hasExpandableChildren() {
        return !!this.childLayoutKeys.length;
    }
    /**
     * @hidden
     */
    hideActionStrip() {
        if (!this.parent) {
            // hide child layout actions strips when
            // moving outside root grid.
            super.hideActionStrip();
            this.allLayoutList.forEach(ri => {
                var _a;
                (_a = ri.actionStrip) === null || _a === void 0 ? void 0 : _a.hide();
            });
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this._transactions instanceof IgxTransactionService) {
            // transaction service cannot be injected in a derived class in a factory manner
            this._transactions = new IgxTransactionService();
        }
        // this.expansionStatesChange.pipe(takeUntil(this.destroy$)).subscribe((value: Map<any, boolean>) => {
        //     const res = Array.from(value.entries()).filter(({1: v}) => v === true).map(([k]) => k);
        // });
        super.ngOnInit();
    }
    ngDoCheck() {
        if (this._cdrRequestRepaint && !this._init) {
            this.updateSizes();
        }
        super.ngDoCheck();
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.verticalScrollContainer.getScroll().addEventListener('scroll', this.hg_verticalScrollHandler.bind(this));
        this.headerContainer.getScroll().addEventListener('scroll', this.hg_horizontalScrollHandler.bind(this));
        this.verticalScrollContainer.onBeforeViewDestroyed.pipe(takeUntil(this.destroy$)).subscribe((view) => {
            const rowData = view.context.$implicit;
            if (this.isChildGridRecord(rowData)) {
                const cachedData = this.childGridTemplates.get(rowData.rowID);
                if (cachedData) {
                    const tmlpOutlet = cachedData.owner;
                    tmlpOutlet._viewContainerRef.detach(0);
                }
            }
        });
        if (this.parent) {
            this._displayDensity = this.rootGrid._displayDensity;
            this.rootGrid.onDensityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this._displayDensity = this.rootGrid._displayDensity;
                this.notifyChanges(true);
                this.cdr.markForCheck();
            });
            this.childLayoutKeys = this.parentIsland.children.map((item) => item.key);
        }
        this.actionStrip = this.parentIsland ? this.parentIsland.actionStrip : this.actionStrip;
        this.headSelectorsTemplates = this.parentIsland ?
            this.parentIsland.headSelectorsTemplates :
            this.headSelectorsTemplates;
        this.rowSelectorsTemplates = this.parentIsland ?
            this.parentIsland.rowSelectorsTemplates :
            this.rowSelectorsTemplates;
        this.dragIndicatorIconTemplate = this.parentIsland ?
            this.parentIsland.dragIndicatorIconTemplate :
            this.dragIndicatorIconTemplate;
        this.rowExpandedIndicatorTemplate = this.rootGrid.rowExpandedIndicatorTemplate;
        this.rowCollapsedIndicatorTemplate = this.rootGrid.rowCollapsedIndicatorTemplate;
        this.headerCollapseIndicatorTemplate = this.rootGrid.headerCollapseIndicatorTemplate;
        this.headerExpandIndicatorTemplate = this.rootGrid.headerExpandIndicatorTemplate;
        this.excelStyleHeaderIconTemplate = this.rootGrid.excelStyleHeaderIconTemplate;
        this.hasChildrenKey = this.parentIsland ?
            this.parentIsland.hasChildrenKey || this.rootGrid.hasChildrenKey :
            this.rootGrid.hasChildrenKey;
        this.showExpandAll = this.parentIsland ?
            this.parentIsland.showExpandAll : this.rootGrid.showExpandAll;
        this.excelStyleFilteringComponents = this.parentIsland ?
            this.parentIsland.excelStyleFilteringComponents :
            this.excelStyleFilteringComponents;
    }
    get outletDirective() {
        return this.rootGrid._outletDirective;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.updateColumnList(false);
        this.childLayoutKeys = this.parent ?
            this.parentIsland.children.map((item) => item.key) :
            this.childLayoutKeys = this.childLayoutList.map((item) => item.key);
        this.childLayoutList.notifyOnChanges();
        this.childLayoutList.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.onRowIslandChange());
        super.ngAfterContentInit();
    }
    /**
     * @hidden @internal
     */
    dataLoading(event) {
        this.onDataPreLoad.emit(event);
    }
    /** @hidden */
    featureColumnsWidth() {
        return super.featureColumnsWidth(this.headerHierarchyExpander);
    }
    /**
     * @hidden
     */
    onRowIslandChange() {
        if (this.parent) {
            this.childLayoutKeys = this.parentIsland.children.filter(item => !item._destroyed).map((item) => item.key);
        }
        else {
            this.childLayoutKeys = this.childLayoutList.filter(item => !item._destroyed).map((item) => item.key);
        }
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
    ngOnDestroy() {
        if (!this.parent) {
            this.hgridAPI.getChildGrids(true).forEach((grid) => {
                if (!grid.childRow.cdr.destroyed) {
                    grid.childRow.cdr.destroy();
                }
            });
        }
        if (this.parent && this.selectionService.activeElement) {
            // in case selection is in destroyed child grid, selection should be cleared.
            this._clearSeletionHighlights();
        }
        super.ngOnDestroy();
    }
    /**
     * @hidden
     */
    isRowHighlighted(rowData) {
        return this.highlightedRowID === rowData.rowID;
    }
    /**
     * @hidden
     */
    isHierarchicalRecord(record) {
        if (this.isGhostRecord(record)) {
            record = record.recordRef;
        }
        return this.childLayoutList.length !== 0 && record[this.childLayoutList.first.key];
    }
    /**
     * @hidden
     */
    isChildGridRecord(record) {
        // Can be null when there is defined layout but no child data was found
        return record.childGridsData !== undefined;
    }
    /**
     * @hidden
     */
    trackChanges(index, rec) {
        if (rec.childGridsData !== undefined) {
            // if is child rec
            return rec.rowID;
        }
        return rec;
    }
    /**
     * @hidden
     */
    getContext(rowData, rowIndex, pinned) {
        if (this.isChildGridRecord(rowData)) {
            const cachedData = this.childGridTemplates.get(rowData.rowID);
            if (cachedData) {
                const view = cachedData.view;
                const tmlpOutlet = cachedData.owner;
                return {
                    $implicit: rowData,
                    moveView: view,
                    owner: tmlpOutlet,
                    index: this.dataView.indexOf(rowData)
                };
            }
            else {
                const rowID = this.primaryKey ? rowData.rowID : this.data.indexOf(rowData.rowID);
                // child rows contain unique grids, hence should have unique templates
                return {
                    $implicit: rowData,
                    templateID: 'childRow-' + rowID,
                    index: this.dataView.indexOf(rowData)
                };
            }
        }
        else {
            return {
                $implicit: this.isGhostRecord(rowData) || this.isAddRowRecord(rowData) ? rowData.recordRef : rowData,
                templateID: 'dataRow',
                index: this.getDataViewIndex(rowIndex, pinned),
                disabled: this.isGhostRecord(rowData),
                addRow: this.isAddRowRecord(rowData) ? rowData.addRow : false
            };
        }
    }
    /**
     * @hidden
     */
    get rootGrid() {
        let currGrid = this;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
        }
        return currGrid;
    }
    /**
     * @hidden
     */
    get iconTemplate() {
        const expanded = this.hasExpandedRecords() && this.hasExpandableChildren;
        if (!expanded && this.showExpandAll) {
            return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
        }
        else {
            return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
        }
    }
    /**
     * @hidden
     * @internal
     */
    getDragGhostCustomTemplate() {
        if (this.parentIsland) {
            return this.parentIsland.getDragGhostCustomTemplate();
        }
        return super.getDragGhostCustomTemplate();
    }
    /**
     * @hidden
     * Gets the visible content height that includes header + tbody + footer.
     * For hierarchical child grid it may be scrolled and not fully visible.
     */
    getVisibleContentHeight() {
        let height = super.getVisibleContentHeight();
        if (this.parent) {
            const rootHeight = this.rootGrid.getVisibleContentHeight();
            const topDiff = this.nativeElement.getBoundingClientRect().top - this.rootGrid.nativeElement.getBoundingClientRect().top;
            height = rootHeight - topDiff > height ? height : rootHeight - topDiff;
        }
        return height;
    }
    /**
     * @hidden
     */
    toggleAll() {
        const expanded = this.hasExpandedRecords() && this.hasExpandableChildren;
        if (!expanded && this.showExpandAll) {
            this.expandAll();
        }
        else {
            this.collapseAll();
        }
    }
    /**
     * @hidden
     * @internal
     */
    hasExpandedRecords() {
        if (this.expandChildren) {
            return true;
        }
        let hasExpandedEntry = false;
        this.expansionStates.forEach(value => {
            if (value) {
                hasExpandedEntry = value;
            }
        });
        return hasExpandedEntry;
    }
    getDefaultExpandState(record) {
        if (this.hasChildrenKey && !record[this.hasChildrenKey]) {
            return false;
        }
        return this.expandChildren;
    }
    /**
     * @hidden
     */
    isExpanded(record) {
        return this.gridAPI.get_row_expansion_state(record);
    }
    /**
     * @hidden
     */
    viewCreatedHandler(args) {
        if (this.isChildGridRecord(args.context.$implicit)) {
            const key = args.context.$implicit.rowID;
            this.childGridTemplates.set(key, args);
        }
    }
    /**
     * @hidden
     */
    viewMovedHandler(args) {
        if (this.isChildGridRecord(args.context.$implicit)) {
            // view was moved, update owner in cache
            const key = args.context.$implicit.rowID;
            const cachedData = this.childGridTemplates.get(key);
            cachedData.owner = args.owner;
            this.childLayoutList.forEach((layout) => {
                const relatedGrid = this.hgridAPI.getChildGridByID(layout.key, args.context.$implicit.rowID);
                if (relatedGrid && relatedGrid.updateOnRender) {
                    // Detect changes if `expandChildren` has changed when the grid wasn't visible. This is for performance reasons.
                    relatedGrid.notifyChanges(true);
                    relatedGrid.updateOnRender = false;
                }
            });
            const childGrids = this.getChildGrids(true);
            childGrids.forEach((grid) => {
                if (grid.isPercentWidth) {
                    grid.notifyChanges(true);
                }
                grid.updateScrollPosition();
            });
        }
    }
    /**
     * @hidden
     */
    updateScrollPosition() {
        const vScr = this.verticalScrollContainer.getScroll();
        const hScr = this.headerContainer.getScroll();
        if (vScr) {
            vScr.scrollTop = this.scrollTop;
        }
        if (hScr) {
            hScr.scrollLeft = this.scrollLeft;
        }
    }
    onContainerScroll() {
        this.hideOverlays();
    }
    getChildGrids(inDeph) {
        return this.hgridAPI.getChildGrids(inDeph);
    }
    generateDataFields(data) {
        return super.generateDataFields(data).filter((field) => {
            const layoutsList = this.parentIsland ? this.parentIsland.children : this.childLayoutList;
            const keys = layoutsList.map((item) => item.key);
            return keys.indexOf(field) === -1;
        });
    }
    /**
     * @hidden
     */
    initColumns(collection, cb = null) {
        if (this.hasColumnLayouts) {
            // invalid configuration - hierarchical grid should not allow column layouts
            // remove column layouts
            const nonColumnLayoutColumns = this.columnList.filter((col) => !col.columnLayout && !col.columnLayoutChild);
            this.columnList.reset(nonColumnLayoutColumns);
        }
        super.initColumns(collection, cb);
    }
    setupColumns() {
        if (this.parentIsland && this.parentIsland.childColumns.length > 0 && !this.autoGenerate) {
            this.createColumnsList(this.parentIsland.childColumns.toArray());
        }
        super.setupColumns();
    }
    onColumnsChanged(change) {
        Promise.resolve().then(() => {
            this.updateColumnList();
            const cols = change.filter(c => c.gridAPI.grid === this);
            if (cols.length > 0 || this.autoGenerate) {
                this.columnList.reset(cols);
                super.onColumnsChanged(this.columnList);
            }
        });
    }
    _shouldAutoSize(renderedHeight) {
        if (this.isPercentHeight && this.parent) {
            return true;
        }
        return super._shouldAutoSize(renderedHeight);
    }
    updateSizes() {
        if (document.body.contains(this.nativeElement) && this.isPercentWidth) {
            this.reflow();
            this.hgridAPI.getChildGrids(false).forEach((grid) => {
                grid.updateSizes();
            });
        }
    }
    updateColumnList(recalcColSizes = true) {
        const childLayouts = this.parent ? this.childLayoutList : this.allLayoutList;
        const nestedColumns = childLayouts.map((layout) => layout.columnList.toArray());
        const colsArray = [].concat.apply([], nestedColumns);
        const colLength = this.columnList.length;
        if (colsArray.length > 0) {
            const topCols = this.columnList.filter((item) => colsArray.indexOf(item) === -1);
            this.columnList.reset(topCols);
            if (recalcColSizes && this.columnList.length !== colLength) {
                this.calculateGridSizes(false);
            }
        }
    }
    _clearSeletionHighlights() {
        [this.rootGrid, ...this.rootGrid.getChildGrids(true)].forEach(grid => {
            grid.selectionService.clear();
            grid.selectionService.activeElement = null;
            grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
            grid.highlightedRowID = null;
            grid.cdr.markForCheck();
        });
    }
    hg_verticalScrollHandler(event) {
        this.scrollTop = event.target.scrollTop;
    }
    hg_horizontalScrollHandler(event) {
        this.scrollLeft = event.target.scrollLeft;
    }
}
IgxHierarchicalGridComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-hierarchical-grid',
                template: "<ng-content select=\"igx-grid-toolbar\"></ng-content>\n<ng-container #toolbarOutlet></ng-container>\n\n<div class=\"igx-grid__thead\" role=\"rowgroup\">\n    <div class=\"igx-grid__thead-wrapper\" (keydown.meta.c)=\"copyHandler($event)\" (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" \n        tabindex=\"0\" (focus)=\"navigation.focusFirstCell()\" [attr.aria-activedescendant]=\"activeDescendant\"\n        (keydown)=\"navigation.headerNavigation($event)\" [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <!-- Drag indicator -->\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator igx-grid__tr-action\" [ngClass]=\"{\n                        'igx-grid__drag-indicator--header': !isRowSelectable\n                    }\" (pointerdown)='$event.preventDefault()' #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n\n            <!-- Select All Row -->\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                        'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                    }\"  (pointerdown)='$event.preventDefault()'>\n                    <ng-template #headSelector\n                                 *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter,\n                                        selectAll: selectAllRows.bind(this),\n                                        deselectAll: deselectAllRows.bind(this) }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n\n            <!-- Expand all -->\n            <div #headerHierarchyExpander (click)=\"toggleAll()\" (mousedown)='$event.preventDefault()' [hidden]='!hasExpandableChildren || !hasVisibleColumns' [ngClass]=\"{\n                'igx-grid__hierarchical-expander igx-grid__hierarchical-expander--header igx-grid__tr-action': hasExpandableChildren,\n                'igx-grid__hierarchical-expander--push': filteringService.isFilterRowVisible,\n                'igx-grid__hierarchical-expander--no-border': isRowSelectable || rowDraggable\n            }\">\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n            </div>\n\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                                           [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                         [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                         [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                         [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                                       [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group\n                            [column]=\"col\"\n                            [gridID]=\"id\"\n                            [style.min-width]=\"getHeaderGroupWidth(col)\"\n                            [style.flex-basis]=\"getHeaderGroupWidth(col)\"\n                            [style.left]=\"col.rightPinnedOffset\">\n                    </igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div igxToggle #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollSize\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\" role=\"rowgroup\">\n    <div class=\"igx-grid__tbody-content\"  tabindex=\"0\" (focus)=\"navigation.focusTbody($event)\"\n     (keydown)=\"navigation.handleNavigation($event)\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\" [attr.aria-activedescendant]=\"activeDescendant\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth' #tbody (scroll)='preventContainerScroll($event)'>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template #pinnedRecordsTemplate>\n            <ng-container *ngIf=\"data\n            | gridTransaction:id:pipeTrigger\n            | visibleColumns:hasVisibleColumns\n            | gridRowPinning:id:true:pipeTrigger\n            | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n            | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger:true\n            | gridAddRow:true:pipeTrigger as pinnedData\">\n                <div #pinContainer *ngIf='pinnedData.length > 0' class='igx-grid__tr--pinned'\n                    [ngClass]=\"{ 'igx-grid__tr--pinned-bottom':  !isRowPinningToTop, 'igx-grid__tr--pinned-top': isRowPinningToTop }\"\n                    [style.width.px]='calcWidth'>\n                    <ng-container *ngFor=\"let rowData of pinnedData; let rowIndex = index\">\n                        <ng-container *ngTemplateOutlet=\"pinned_hierarchical_record_template; context: getContext(rowData, rowIndex, true)\">\n                        </ng-container>\n                    </ng-container>\n                </div>\n            </ng-container>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-template igxGridFor let-rowData let-rowIndex=\"index\" [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger\n        | gridHierarchicalPaging:page:perPage:id:pipeTrigger\n        | gridHierarchical:expansionStates:id:primaryKey:childLayoutKeys:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\n        | gridAddRow:false:pipeTrigger\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" [igxForTrackBy]='trackChanges'\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template\n                [igxTemplateOutlet]='(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template))'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex, false)' (onViewCreated)='viewCreatedHandler($event)'\n                (onViewMoved)='viewMovedHandler($event)' (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n            <!-- <ng-container *igxTemplateOutlet=\"(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template)); context: getContext(rowData)\"></ng-container> -->\n        </ng-template>\n        <ng-template #hierarchical_record_template let-rowIndex=\"index\" let-disabledRow=\"disabled\" let-rowData let-isAddRow=\"addRow\">\n            <igx-hierarchical-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [disabled]=\"disabledRow\" [rowData]=\"rowData\" [addRow]=\"isAddRow\" #row>\n            </igx-hierarchical-grid-row>\n        </ng-template>\n\n        <ng-template #pinned_hierarchical_record_template let-rowIndex=\"index\" let-rowData let-isAddRow=\"addRow\">\n            <igx-hierarchical-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" [addRow]=\"isAddRow\" #row #pinnedRow>\n            </igx-hierarchical-grid-row>\n        </ng-template>\n        <ng-template #child_record_template let-rowIndex=\"index\" let-rowData>\n            <div style=\"overflow: auto; width: 100%;\" [attr.data-rowindex]='rowIndex' (scroll)='onContainerScroll()'\n                [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr--highlighted':isRowHighlighted(rowData)\n            }\">\n                <igx-child-grid-row *ngFor=\"let layout of childLayoutList\" [parentGridID]=\"id\" [index]=\"rowIndex\"\n                    [rowData]=\"rowData\" [layout]='layout' #row>\n                </igx-child-grid-row>\n            </div>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n            id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark *ngIf=\"!this.parent\"></igc-trial-watermark>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\" (pointerdown)=\"$event.preventDefault()\">\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [actionText]=\"snackbarActionText\" [displayTime]='snackbarDisplayTime'>{{snackbarLabel}}</igx-snackbar>\n    </div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <div tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\" [attr.aria-activedescendant]=\"activeDescendant\"\n     (keydown)=\"navigation.summaryNav($event)\">\n        <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n            *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n            [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n            class=\"igx-grid__summaries\" #summaryRow>\n        </igx-grid-summary-row>\n        <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n            [style.width.px]=\"scrollSize\"></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\"  (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [overlaySettings]=\"paginatorSettings\" [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\"\n        [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button igxButton=\"raised\" igxRipple (click)='beginAddRowByIndex(null, -1, $event)'>\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\">unfold_more</igx-icon>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" [active]='hasExpandedRecords() && hasExpandableChildren'>unfold_less</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle #rowEditingOverlay>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\" *ngIf=\"!this.crudService.row?.isAddRow\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon>drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n",
                providers: [
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    { provide: GridBaseAPIService, useClass: IgxHierarchicalGridAPIService },
                    { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxHierarchicalGridComponent) },
                    IgxGridSummaryService,
                    IgxFilteringService,
                    IgxHierarchicalGridNavigationService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService,
                    IgxRowIslandAPIService
                ]
            },] }
];
IgxHierarchicalGridComponent.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.role',] }],
    childLayoutList: [{ type: ContentChildren, args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false },] }],
    allLayoutList: [{ type: ContentChildren, args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: true },] }],
    toolbarTemplate: [{ type: ContentChild, args: [IgxGridToolbarDirective, { read: TemplateRef, static: true },] }],
    toolbarOutlet: [{ type: ViewChild, args: ['toolbarOutlet', { read: ViewContainerRef },] }],
    templateOutlets: [{ type: ViewChildren, args: [IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective },] }],
    hierarchicalRows: [{ type: ViewChildren, args: [IgxChildGridRowComponent, { read: IgxChildGridRowComponent },] }],
    hierarchicalRecordTemplate: [{ type: ViewChild, args: ['hierarchical_record_template', { read: TemplateRef, static: true },] }],
    childTemplate: [{ type: ViewChild, args: ['child_record_template', { read: TemplateRef, static: true },] }],
    headerHierarchyExpander: [{ type: ViewChild, args: ['headerHierarchyExpander', { read: ElementRef, static: true },] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    data: [{ type: Input }],
    expandChildren: [{ type: Input }]
};

class IgxHierarchicalGridCellComponent extends IgxGridCellComponent {
    constructor(selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil) {
        super(selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil);
        this.selectionService = selectionService;
        this.crudService = crudService;
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.zone = zone;
        this.platformUtil = platformUtil;
    }
    ngOnInit() {
        super.ngOnInit();
        this._rootGrid = this._getRootGrid();
    }
    // TODO: Extend the new selection service to avoid complete traversal
    _clearAllHighlights() {
        [this._rootGrid, ...this._rootGrid.getChildGrids(true)].forEach(grid => {
            if (grid !== this.grid && grid.navigation.activeNode) {
                grid.navigation.clearActivation();
                grid.selectionService.initKeyboardState();
                grid.selectionService.clear();
            }
            grid.selectionService.activeElement = null;
            grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
            grid.highlightedRowID = null;
            grid.cdr.markForCheck();
        });
    }
    /**
     * @hidden
     * @internal
     */
    activate(event) {
        this._clearAllHighlights();
        const currentElement = this.grid.nativeElement;
        let parentGrid = this.grid;
        let childGrid;
        // add highligh to the current grid
        if (this._rootGrid.id !== currentElement.id) {
            currentElement.classList.add('igx-grid__tr--highlighted');
        }
        // add highligh to the current grid
        while (this._rootGrid.id !== parentGrid.id) {
            childGrid = parentGrid;
            parentGrid = parentGrid.parent;
            const parentRowID = parentGrid.hgridAPI.getParentRowId(childGrid);
            parentGrid.highlightedRowID = parentRowID;
        }
        this.grid.navigation.activeNode.gridID = this.gridID;
        super.activate(event);
    }
    _getRootGrid() {
        let currGrid = this.grid;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
        }
        return currGrid;
    }
}
IgxHierarchicalGridCellComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-hierarchical-grid-cell',
                template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip\n        *ngIf=\"displayPinnedChip\"\n        class=\"igx-grid__td--pinned-chip\"\n        [disabled]=\"true\"\n        [displayDensity]=\"'compact'\"\n        >{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip\n    >\n</ng-template>\n<ng-template #defaultCell>\n    <div *ngIf=\"column.dataType !== 'boolean'\"\n        igxTextHighlight\n        class=\"igx-grid__td-text\"\n        style=\"pointer-events: none;\"\n        [cssClass]=\"highlightClass\"\n        [activeCssClass]=\"activeHighlightClass\"\n        [groupName]=\"gridID\"\n        [value]=\"\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === 'number'\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'date'\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : column.dataType === 'currency'\n                ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'percent'\n                ? (value | percent:column.pipeArgs.digitsInfo:grid.locale)\n                : value\n        \"\n        [row]=\"rowData\"\n        [column]=\"this.column.field\"\n        [containerClass]=\"'igx-grid__td-text'\"\n        [metadata]=\"searchMetadata\"\n    >{{\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === \"number\"\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === \"date\"\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : column.dataType === 'currency'\n                ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'percent'\n                ? (value | percent:column.pipeArgs.digitsInfo:grid.locale)\n                : value\n        }}</div>\n    <igx-icon\n        *ngIf=\"column.dataType === 'boolean'\"\n        [ngClass]=\"{ 'igx-icon--success': value, 'igx-icon--error': !value }\"\n        >{{ value ? \"check\" : \"close\" }}</igx-icon\n    >\n</ng-template>\n<ng-template #addRowCell let-cell=\"cell\">\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n    [cssClass]=\"highlightClass\"\n    [activeCssClass]=\"activeHighlightClass\"\n    [groupName]=\"gridID\"\n    [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ?\n        (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ?\n        (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : column.dataType === 'currency' ?\n        (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'percent' ?\n        (value | percent:column.pipeArgs.digitsInfo:grid.locale) : value\"\n    [row]=\"rowData\"\n    [column]=\"this.column.field\"\n    [containerClass]=\"'igx-grid__td-text'\"\n    [metadata]=\"searchMetadata\">{{\n        !isEmptyAddRowCell ? value : (column.header || column.field)\n    }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox\n            (change)=\"editValue = $event.checked\"\n            [value]=\"editValue\"\n            [checked]=\"editValue\"\n            [igxFocus]=\"true\"\n            [disableRipple]=\"true\"\n        ></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker\n            [style.width.%]=\"100\"\n            [outlet]=\"grid.outlet\"\n            mode=\"dropdown\"\n            [locale]=\"grid.locale\"\n            [(value)]=\"editValue\"\n            [igxFocus]=\"true\"\n            [labelVisibility]=\"false\"\n        >\n        </igx-date-picker>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'currency'\">\n        <igx-input-group displayDensity=\"compact\">\n            <igx-prefix *ngIf=\"grid.currencyPositionLeft\">{{ currencyCodeSymbol }}</igx-prefix>\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n            <igx-suffix *ngIf=\"!grid.currencyPositionLeft\" >{{ currencyCodeSymbol }}</igx-suffix>\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'percent'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n            <igx-suffix> {{ editValue | percent:column.pipeArgs.digitsInfo:grid.locale }} </igx-suffix>\n        </igx-input-group>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n",
                providers: [HammerGesturesManager]
            },] }
];
IgxHierarchicalGridCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];

class IgxHierarchicalRowComponent extends IgxRowDirective {
    constructor() {
        super(...arguments);
        this.expanderClass = 'igx-grid__hierarchical-expander';
        this.rolActionClass = 'igx-grid__tr-action';
        /**
         * @hidden
         * @internal
         */
        this.select = () => {
            this.grid.selectRows([this.rowID]);
        };
        /**
         * @hidden
         * @internal
         */
        this.deselect = () => {
            this.grid.deselectRows([this.rowID]);
        };
    }
    /**
     * @hidden
     */
    get expanderClassResolved() {
        return {
            [`${this.expanderClass} ${this.rolActionClass}`]: !this.pinned || this.disabled,
            [`${this.expanderClass}--empty`]: this.pinned && !this.disabled
        };
    }
    get viewIndex() {
        return this.index + this.grid.page * this.grid.perPage;
    }
    /**
     * Returns whether the row is expanded.
     * ```typescript
     * const RowExpanded = this.grid1.rowList.first.expanded;
     * ```
     */
    get expanded() {
        return this.gridAPI.get_row_expansion_state(this.rowData);
    }
    /**
     * @hidden
     */
    get expandedClass() {
        return this.expanded && !this.pinned;
    }
    get hasChildren() {
        return !!this.grid.childLayoutKeys.length;
    }
    /**
     * @hidden
     */
    get highlighted() {
        return this.grid && this.grid.highlightedRowID === this.rowID;
    }
    /**
     * @hidden
     */
    expanderClick(event) {
        event.stopPropagation();
        this.toggle();
    }
    /**
     * Toggles the hierarchical row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     */
    toggle() {
        if (this.added) {
            return;
        }
        const grid = this.gridAPI.grid;
        this.endEdit(grid.rootGrid);
        this.gridAPI.set_row_expansion_state(this.rowID, !this.expanded);
        grid.cdr.detectChanges();
    }
    /**
     * @hidden
     */
    get iconTemplate() {
        let expandable = true;
        if (this.grid.hasChildrenKey) {
            expandable = this.rowData[this.grid.hasChildrenKey];
        }
        if (!expandable || (this.pinned && !this.disabled)) {
            return this.defaultEmptyTemplate;
        }
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    endEdit(grid) {
        if (grid.crudService.cellInEditMode) {
            grid.endEdit();
        }
        grid.hgridAPI.getChildGrids(true).forEach(g => {
            if (g.crudService.cellInEditMode) {
                g.endEdit();
            }
        });
    }
}
IgxHierarchicalRowComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-hierarchical-grid-row',
                template: "<ng-container *ngTemplateOutlet='addRow ? addTemp : defaultTemp'></ng-container>\n<ng-template #defaultExpandedTemplate>\n    <igx-icon [active]='!added'>expand_more</igx-icon>\n</ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n    <igx-icon [active]='!added'>chevron_right</igx-icon>\n</ng-template>\n\n<ng-template #defaultEmptyTemplate>\n    <igx-icon></igx-icon>\n</ng-template>\n\n<ng-template #addTemp>\n    <div class='igx-grid__tr--inner' [class.igx-grid__tr--add-animate]='animateAdd' (animationend)='animationEndHandler()'>\n        <ng-container *ngTemplateOutlet='defaultTemp'></ng-container>\n    </div>\n</ng-template>\n<ng-template #defaultTemp>\n    <!-- Drag indicator -->\n    <ng-container *ngIf=\"rowDraggable\">\n        <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\" (pointerdown)=\"$event.preventDefault()\">\n            <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n        </div>\n    </ng-container>\n\n    <!-- Select Row -->\n    <ng-container *ngIf=\"showRowSelectors\">\n        <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" (click)=\"onRowSelectorClick($event)\" (pointerdown)=\"$event.preventDefault()\">\n            <ng-template *ngTemplateOutlet=\"\n                this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n                context: { $implicit: {\n                                index: viewIndex,\n                                rowID: rowID,\n                                selected: selected,\n                                select: select,\n                                deselect: deselect }}\">\n            </ng-template>\n        </div>\n    </ng-container>\n\n    <!-- Row Expander -->\n    <div  (click)=\"expanderClick($event)\" (mousedown)='$event.preventDefault()' [ngClass]=\"expanderClassResolved\" *ngIf=\"hasChildren\" #expander>\n        <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n        </ng-container>\n    </div>\n\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n        <ng-template *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-template>\n    </ng-container>\n\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"' [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <igx-hierarchical-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [style.min-height.px]=\"cellHeight\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\">\n        </igx-hierarchical-grid-cell>\n    </ng-template>\n\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n        <ng-template *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-template>\n    </ng-container>\n\n    <ng-template #rowSelectorBaseTemplate>\n        <div class=\"igx-grid__cbx-padding\">\n            <igx-checkbox\n                [tabindex]=\"-1\"\n                [readonly]=\"true\"\n                [checked]=\"selected\"\n                disableRipple=\"true\"\n                [disabled]=\"deleted\"\n                [disableTransitions]=\"grid.disableTransitions\"\n                [aria-label]=\"rowCheckboxAriaLabel\">\n            </igx-checkbox>\n        </div>\n    </ng-template>\n\n    <ng-template #pinnedCellsTemplate let-col>\n        <igx-hierarchical-grid-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n            [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [firstPinned]=\"col.isFirstPinned\"\n            [lastPinned]=\"col.isLastPinned\"\n            [style.min-height.px]=\"cellHeight\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [style.left]=\"col.rightPinnedOffset\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\">\n        </igx-hierarchical-grid-cell>\n    </ng-template>\n</ng-template>\n",
                providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxHierarchicalRowComponent) }]
            },] }
];
IgxHierarchicalRowComponent.propDecorators = {
    expander: [{ type: ViewChild, args: ['expander', { read: ElementRef },] }],
    _cells: [{ type: ViewChildren, args: [forwardRef(() => IgxHierarchicalGridCellComponent), { read: IgxHierarchicalGridCellComponent },] }],
    defaultExpandedTemplate: [{ type: ViewChild, args: ['defaultExpandedTemplate', { read: TemplateRef, static: true },] }],
    defaultEmptyTemplate: [{ type: ViewChild, args: ['defaultEmptyTemplate', { read: TemplateRef, static: true },] }],
    defaultCollapsedTemplate: [{ type: ViewChild, args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true },] }],
    expandedClass: [{ type: HostBinding, args: ['class.igx-grid__tr--expanded',] }],
    highlighted: [{ type: HostBinding, args: ['class.igx-grid__tr--highlighted',] }]
};

/**
 * @hidden
 */
class IgxGridHierarchicalPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, state = new Map(), id, primaryKey, childKeys, pipeTrigger) {
        if (childKeys.length === 0) {
            return collection;
        }
        const grid = this.gridAPI.grid;
        if (grid.verticalScrollContainer.isRemote) {
            return collection;
        }
        const result = this.addHierarchy(grid, cloneArray(collection), state, primaryKey, childKeys);
        return result;
    }
    addHierarchy(grid, data, state, primaryKey, childKeys) {
        const result = [];
        data.forEach((v) => {
            result.push(v);
            const childGridsData = {};
            childKeys.forEach((childKey) => {
                const childData = v[childKey] ? v[childKey] : null;
                childGridsData[childKey] = childData;
            });
            if (grid.gridAPI.get_row_expansion_state(v)) {
                result.push({ rowID: primaryKey ? v[primaryKey] : v, childGridsData });
            }
        });
        return result;
    }
}
IgxGridHierarchicalPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridHierarchical',
                pure: true
            },] }
];
IgxGridHierarchicalPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxGridHierarchicalPagingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, page = 0, perPage = 15, id, pipeTrigger) {
        if (!this.gridAPI.grid.paging || this.gridAPI.grid.pagingMode !== GridPagingMode.Local) {
            return collection;
        }
        const state = {
            index: page,
            recordsPerPage: perPage
        };
        const total = this.gridAPI.grid._totalRecords >= 0 ? this.gridAPI.grid._totalRecords : collection.length;
        const result = DataUtil.page(cloneArray(collection), state, total);
        this.gridAPI.grid.pagingState = state;
        return result;
    }
}
IgxGridHierarchicalPagingPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridHierarchicalPaging',
                pure: true
            },] }
];
IgxGridHierarchicalPagingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/**
 * @hidden
 */
class IgxHierarchicalGridModule {
}
IgxHierarchicalGridModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxHierarchicalGridComponent,
                    IgxHierarchicalRowComponent,
                    IgxRowIslandComponent,
                    IgxChildGridRowComponent,
                    IgxHierarchicalGridCellComponent,
                    IgxGridHierarchicalPipe,
                    IgxGridHierarchicalPagingPipe
                ],
                exports: [
                    IgxGridModule,
                    IgxHierarchicalGridComponent,
                    IgxHierarchicalRowComponent,
                    IgxHierarchicalGridCellComponent,
                    IgxRowIslandComponent,
                    IgxChildGridRowComponent
                ],
                imports: [
                    IgxGridModule,
                ],
                entryComponents: [
                    IgxGridComponent
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * IgxActionIcon is a container for the action nav icon of the IgxNavbar.
 */
class IgxNavbarActionDirective {
}
IgxNavbarActionDirective.decorators = [
    { type: Directive, args: [{
                selector: 'igx-navbar-action,[igxNavbarAction]'
            },] }
];
class IgxNavbarTitleDirective {
}
IgxNavbarTitleDirective.decorators = [
    { type: Directive, args: [{
                selector: 'igx-navbar-title,[igxNavbarTitle]'
            },] }
];
let NEXT_ID$o = 0;
/**
 * **Ignite UI for Angular Navbar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navbar.html)
 *
 * The Ignite UI Navbar is most commonly used to provide an app header with a hamburger menu and navigation
 * state such as a "Go Back" button. It also supports other actions represented by icons.
 *
 * Example:
 * ```html
 * <igx-navbar title="Sample App" actionButtonIcon="menu">
 *   <igx-icon>search</igx-icon>
 *   <igx-icon>favorite</igx-icon>
 *   <igx-icon>more_vert</igx-icon>
 * </igx-navbar>
 * ```
 */
class IgxNavbarComponent {
    constructor() {
        /**
         * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-navbar [id]="'igx-navbar-12'" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.id = `igx-navbar-${NEXT_ID$o++}`;
        /**
         * The event that will be thrown when the action is executed,
         * provides reference to the `IgxNavbar` component as argument
         * ```typescript
         * public actionExc(event){
         *     alert("Action Execute!");
         * }
         *  //..
         * ```
         * ```html
         * <igx-navbar (action)="actionExc($event)" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.action = new EventEmitter();
        /**
         * An @Input property that sets the titleId of the `IgxNavbarComponent`. If not set it will be automatically generated.
         * ```html
         * <igx-navbar [titleId]="'igx-navbar-7'" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.titleId = `igx-navbar-title-${NEXT_ID$o++}`;
        this.isVisible = true;
    }
    /**
     * Sets whether the action button of the `IgxNavbarComponent` is visible.
     * ```html
     * <igx-navbar [title]="currentView" [isActionButtonVisible]="'false'"></igx-navbar>
     * ```
     */
    set isActionButtonVisible(value) {
        this.isVisible = value;
    }
    /**
     * Returns whether the `IgxNavbarComponent` action button is visible, true/false.
     * ```typescript
     *  @ViewChild("MyChild")
     * public navBar: IgxNavbarComponent;
     * ngAfterViewInit(){
     *     let actionButtonVisibile = this.navBar.isActionButtonVisible;
     * }
     * ```
     */
    get isActionButtonVisible() {
        if (this.actionIconTemplate || !this.actionButtonIcon) {
            return false;
        }
        return this.isVisible;
    }
    get isTitleContentVisible() {
        return this.titleContent ? true : false;
    }
    /**
     * @hidden
     */
    _triggerAction() {
        this.action.emit(this);
    }
}
IgxNavbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-navbar',
                template: "<nav class=\"igx-navbar\" role=\"navigation\" [attr.aria-labelledby]=\"titleId\">\n    <div class=\"igx-navbar__left\">\n        <igx-icon\n            (click)=\"_triggerAction()\"\n            *ngIf=\"isActionButtonVisible\">\n            {{actionButtonIcon}}\n        </igx-icon>\n        <ng-content select=\"igx-navbar-action, [igxNavbarAction]\"></ng-content>\n        <h1\n            *ngIf=\"!isTitleContentVisible\"\n            class=\"igx-navbar__title\"\n            [attr.id]=\"titleId\">\n            {{ title }}\n        </h1>\n        <ng-content select=\"igx-navbar-title, [igxNavbarTitle]\"></ng-content>\n    </div>\n    <div class=\"igx-navbar__right\">\n        <ng-content></ng-content>\n    </div>\n</nav>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            },] }
];
IgxNavbarComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    actionButtonIcon: [{ type: Input }],
    title: [{ type: Input }],
    action: [{ type: Output }],
    titleId: [{ type: Input }],
    actionIconTemplate: [{ type: ContentChild, args: [IgxNavbarActionDirective, { read: IgxNavbarActionDirective },] }],
    titleContent: [{ type: ContentChild, args: [IgxNavbarTitleDirective, { read: IgxNavbarTitleDirective },] }],
    isActionButtonVisible: [{ type: Input }]
};
/**
 * @hidden
 */
class IgxNavbarModule {
}
IgxNavbarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxNavbarComponent, IgxNavbarActionDirective, IgxNavbarTitleDirective],
                exports: [IgxNavbarComponent, IgxNavbarActionDirective, IgxNavbarTitleDirective],
                imports: [IgxButtonModule, IgxIconModule, CommonModule]
            },] }
];

class IgxNavDrawerItemDirective {
    constructor() {
        /**
         * @hidden
         */
        this.active = false;
        /**
         * @hidden
         */
        this.isHeader = false;
        /**
         * @hidden
         */
        this.activeClass = 'igx-nav-drawer__item--active';
    }
    /**
     * @hidden
     */
    get defaultCSS() {
        return !this.active && !this.isHeader;
    }
    /**
     * @hidden
     */
    get currentCSS() {
        return this.active && !this.isHeader;
    }
    /**
     * @hidden
     */
    get headerCSS() {
        return this.isHeader;
    }
}
IgxNavDrawerItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDrawerItem]',
                exportAs: 'igxDrawerItem'
            },] }
];
IgxNavDrawerItemDirective.propDecorators = {
    active: [{ type: Input, args: ['active',] }],
    isHeader: [{ type: Input, args: ['isHeader',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-nav-drawer__item',] }],
    currentCSS: [{ type: HostBinding, args: ['class.igx-nav-drawer__item--active',] }],
    headerCSS: [{ type: HostBinding, args: ['class.igx-nav-drawer__item--header',] }]
};
class IgxNavDrawerTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxNavDrawerTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDrawer]'
            },] }
];
IgxNavDrawerTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxNavDrawerMiniTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxNavDrawerMiniTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDrawerMini]'
            },] }
];
IgxNavDrawerMiniTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

let NEXT_ID$p = 0;
/**
 * **Ignite UI for Angular Navigation Drawer** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer)
 *
 * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
 *
 * Example:
 * ```html
 * <igx-nav-drawer id="navigation" [isOpen]="true">
 *   <ng-template igxDrawer>
 *     <nav>
 *       <span igxDrawerItem [isHeader]="true">Email</span>
 *       <span igxDrawerItem igxRipple>Inbox</span>
 *       <span igxDrawerItem igxRipple>Deleted</span>
 *       <span igxDrawerItem igxRipple>Sent</span>
 *     </nav>
 *   </ng-template>
 * </igx-nav-drawer>
 * ```
 */
class IgxNavigationDrawerComponent {
    constructor(elementRef, _state, renderer, _touchManager, platformUtil) {
        this.elementRef = elementRef;
        this._state = _state;
        this.renderer = renderer;
        this._touchManager = _touchManager;
        this.platformUtil = platformUtil;
        /** @hidden @internal */
        this.cssClass = true;
        /**
         * ID of the component
         *
         * ```typescript
         * // get
         * let myNavDrawerId = this.navdrawer.id;
         * ```
         *
         * ```html
         * <!--set-->
         *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
         * ```
         */
        this.id = `igx-nav-drawer-${NEXT_ID$p++}`;
        /**
         * Position of the Navigation Drawer. Can be "left"(default) or "right".
         *
         * ```typescript
         * // get
         * let myNavDrawerPosition = this.navdrawer.position;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
         * ```
         */
        this.position = 'left';
        /**
         * Enables the use of touch gestures to manipulate the drawer:
         * - swipe/pan from edge to open, swipe-toggle and pan-drag.
         *
         * ```typescript
         * // get
         * let gesturesEnabled = this.navdrawer.enableGestures;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
         * ```
         */
        this.enableGestures = true;
        /**
         * @hidden
         */
        this.isOpenChange = new EventEmitter();
        /**
         * Minimum device width required for automatic pin to be toggled.
         * Default is 1024, can be set to a falsy value to disable this behavior.
         *
         * ```typescript
         * // get
         * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
         * ```
         */
        this.pinThreshold = 1024;
        /**
         * When pinned the drawer is relatively positioned instead of sitting above content.
         * May require additional layout styling.
         *
         * ```typescript
         * // get
         * let navDrawerIsPinned = this.navdrawer.pin;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
         * ```
         */
        this.pin = false;
        /**
         * Width of the drawer in its open state. Defaults to "280px".
         *
         * ```typescript
         * // get
         * let navDrawerWidth = this.navdrawer.width;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
         * ```
         */
        this.width = '280px';
        /**
         * Enables/disables the animation, when toggling the drawer. Set to `false` by default.
         * ````html
         * <igx-nav-drawer [disableAnimation]="true"></igx-nav-drawer>
         * ````
         */
        this.disableAnimation = false;
        /**
         * Width of the drawer in its mini state. Defaults to 68px.
         *
         * ```typescript
         * // get
         * let navDrawerMiniWidth = this.navdrawer.miniWidth;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
         * ```
         */
        this.miniWidth = '68px';
        /**
         * Pinned state change output for two-way binding.
         *
         * ```html
         * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
         * ```
         */
        this.pinChange = new EventEmitter(true);
        /**
         * Event fired as the Navigation Drawer is about to open.
         *
         * ```html
         *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
         * ```
         */
        this.opening = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has opened.
         *
         * ```html
         * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
         * ```
         */
        this.opened = new EventEmitter();
        /**
         * Event fired as the Navigation Drawer is about to close.
         *
         * ```html
         * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
         * ```
         */
        this.closing = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has closed.
         *
         * ```html
         * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
         * ```
         */
        this.closed = new EventEmitter();
        this._isOpen = false;
        this._gesturesAttached = false;
        this._widthCache = { width: null, miniWidth: null, windowWidth: null };
        this.css = {
            drawer: 'igx-nav-drawer__aside',
            mini: 'igx-nav-drawer__aside--mini',
            overlay: 'igx-nav-drawer__overlay',
            styleDummy: 'igx-nav-drawer__style-dummy'
        };
        /** Pan animation properties */
        this._panning = false;
        this._maxEdgeZone = 50;
        this.checkPinThreshold = (evt) => {
            if (!this.platformUtil.isBrowser) {
                return;
            }
            let windowWidth;
            if (this.pinThreshold) {
                windowWidth = this.getWindowWidth();
                if (evt && this._widthCache.windowWidth === windowWidth) {
                    return;
                }
                this._widthCache.windowWidth = windowWidth;
                if (!this.pin && windowWidth >= this.pinThreshold) {
                    this.pin = true;
                    this.pinChange.emit(true);
                }
                else if (this.pin && windowWidth < this.pinThreshold) {
                    this.pin = false;
                    this.pinChange.emit(false);
                }
            }
        };
        this.swipe = (evt) => {
            // TODO: Could also force input type: http://stackoverflow.com/a/27108052
            if (!this.enableGestures || evt.pointerType !== 'touch') {
                return;
            }
            // HammerJS swipe is horizontal-only by default, don't check deltaY
            let deltaX;
            let startPosition;
            if (this.position === 'right') {
                // when on the right use inverse of deltaX
                deltaX = -evt.deltaX;
                startPosition = this.getWindowWidth() - (evt.center.x + evt.distance);
            }
            else {
                deltaX = evt.deltaX;
                startPosition = evt.center.x - evt.distance;
            }
            // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
            if ((this.isOpen && deltaX < 0) ||
                // positive deltaX from the edge:
                (deltaX > 0 && startPosition < this.maxEdgeZone)) {
                this.toggle();
            }
        };
        this.panstart = (evt) => {
            if (!this.enableGestures || this.pin || evt.pointerType !== 'touch') {
                return;
            }
            const startPosition = this.position === 'right' ? this.getWindowWidth() - (evt.center.x + evt.distance)
                : evt.center.x - evt.distance;
            // cache width during animation, flag to allow further handling
            if (this.isOpen || (startPosition < this.maxEdgeZone)) {
                this._panning = true;
                this._panStartWidth = this.getExpectedWidth(!this.isOpen);
                this._panLimit = this.getExpectedWidth(this.isOpen);
                this.renderer.addClass(this.overlay, 'panning');
                this.renderer.addClass(this.drawer, 'panning');
            }
        };
        this.pan = (evt) => {
            // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
            // get actual delta (not total session one) from event?
            // pan WILL also fire after a full swipe, only resize on flag
            if (!this._panning) {
                return;
            }
            const right = this.position === 'right';
            // when on the right use inverse of deltaX
            const deltaX = right ? -evt.deltaX : evt.deltaX;
            let newX;
            let percent;
            const visibleWidth = this._panStartWidth + deltaX;
            if (this.isOpen && deltaX < 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth <= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panLimit) / (this._panStartWidth - this._panLimit);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panStartWidth;
                    newX = evt.deltaX;
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
            else if (!this.isOpen && deltaX > 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth >= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panStartWidth) / (this._panLimit - this._panStartWidth);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panLimit;
                    newX = (this._panLimit - visibleWidth) * (right ? 1 : -1);
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
        };
        this.panEnd = (evt) => {
            if (this._panning) {
                const deltaX = this.position === 'right' ? -evt.deltaX : evt.deltaX;
                const visibleWidth = this._panStartWidth + deltaX;
                this.resetPan();
                // check if pan brought the drawer to 50%
                if (this.isOpen && visibleWidth <= this._panStartWidth / 2) {
                    this.close();
                }
                else if (!this.isOpen && visibleWidth >= this._panLimit / 2) {
                    this.open();
                }
                this._panStartWidth = null;
            }
        };
        this.toggleOpenedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleOpenedEvent, false);
            this.opened.emit();
        };
        this.toggleClosedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleClosedEvent, false);
            this.closed.emit();
        };
    }
    /**
     * State of the drawer.
     *
     * ```typescript
     * // get
     * let navDrawerIsOpen = this.navdrawer.isOpen;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <!--set-->
     * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>
     * ```
     */
    get isOpen() {
        return this._isOpen;
    }
    set isOpen(value) {
        this._isOpen = value;
        this.isOpenChange.emit(this._isOpen);
    }
    /**
     * Returns nativeElement of the component.
     *
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get template() {
        if (this.miniTemplate && !this.isOpen) {
            return this.miniTemplate.template;
        }
        else if (this.contentTemplate) {
            return this.contentTemplate.template;
        }
    }
    /**
     * @hidden
     */
    get miniTemplate() {
        return this._miniTemplate;
    }
    /**
     * @hidden
     */
    set miniTemplate(v) {
        if (!this.isOpen) {
            this.setDrawerWidth(v ? this.miniWidth : '');
        }
        this._miniTemplate = v;
    }
    /**
     * @hidden
     */
    get flexWidth() {
        if (!this.pin) {
            return '0px';
        }
        if (this.isOpen) {
            return this.width;
        }
        if (this.miniTemplate && this.miniWidth) {
            return this.miniWidth;
        }
        return '0px';
    }
    /** @hidden */
    get isPinnedRight() {
        return this.pin && this.position === 'right' ? '1' : '0';
    }
    /**
     * @hidden
     */
    get drawer() {
        return this._drawer.nativeElement;
    }
    /**
     * @hidden
     */
    get overlay() {
        return this._overlay.nativeElement;
    }
    /**
     * @hidden
     */
    get styleDummy() {
        return this._styleDummy.nativeElement;
    }
    /**
     * Property to decide whether to change width or translate the drawer from pan gesture.
     *
     * @hidden
     */
    get hasAnimateWidth() {
        return this.pin || !!this.miniTemplate;
    }
    /**
     * Used for touch gestures (swipe and pan).
     * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
     *
     * @hidden
     */
    get maxEdgeZone() {
        return this._maxEdgeZone;
    }
    /**
     * Gets the Drawer width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     *
     * @hidden
     */
    get expectedWidth() {
        return this.getExpectedWidth(false);
    }
    /**
     * Get the Drawer mini width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     * @hidden
     */
    get expectedMiniWidth() {
        return this.getExpectedWidth(true);
    }
    /**
     * @hidden
     */
    get touchManager() {
        return this._touchManager;
    }
    /**
     * Exposes optional navigation service
     *
     * @hidden
     */
    get state() {
        return this._state;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        // DOM and @Input()-s initialized
        if (this._state) {
            this._state.add(this.id, this);
        }
        if (this.isOpen) {
            this.setDrawerWidth(this.width);
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        // wait for template and ng-content to be ready
        this.updateEdgeZone();
        this.checkPinThreshold();
        this.ensureEvents();
        // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
        // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._touchManager.destroy();
        if (this._state) {
            this._state.remove(this.id);
        }
        if (this._resizeObserver) {
            this._resizeObserver.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
        if (changes.enableGestures && changes.enableGestures.currentValue !== undefined) {
            this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
            this.ensureEvents();
        }
        if (changes.pin && changes.pin.currentValue !== undefined) {
            this.pin = !!(this.pin && this.pin.toString() === 'true');
            if (this.pin) {
                this._touchManager.destroy();
                this._gesturesAttached = false;
            }
            else {
                this.ensureEvents();
            }
        }
        if (changes.pinThreshold) {
            if (this.pinThreshold) {
                this.ensureEvents();
                this.checkPinThreshold();
            }
        }
        if (changes.width && this.isOpen) {
            this.setDrawerWidth(changes.width.currentValue);
        }
        if (changes.isOpen) {
            this.setDrawerWidth(this.isOpen ? this.width : (this.miniTemplate ? this.miniWidth : ''));
        }
        if (changes.miniWidth) {
            if (!this.isOpen) {
                this.setDrawerWidth(changes.miniWidth.currentValue);
            }
            this.updateEdgeZone();
        }
    }
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     */
    toggle() {
        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     */
    open() {
        if (this._panning) {
            this.resetPan();
        }
        if (this.isOpen) {
            return;
        }
        this.opening.emit();
        this.isOpen = true;
        // TODO: Switch to animate API when available
        // var animationCss = this.animate.css();
        //     animationCss
        //         .setStyles({'width':'50px'}, {'width':'400px'})
        //         .start(this.elementRef.nativeElement)
        //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
        this.setDrawerWidth(this.width);
    }
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     */
    close() {
        if (this._panning) {
            this.resetPan();
        }
        if (!this.isOpen) {
            return;
        }
        this.closing.emit();
        this.isOpen = false;
        this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
    }
    /**
     * @hidden
     */
    set_maxEdgeZone(value) {
        this._maxEdgeZone = value;
    }
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @param [mini] - Request mini width instead
     */
    getExpectedWidth(mini) {
        if (mini) {
            if (!this.miniTemplate) {
                return 0;
            }
            if (this.miniWidth) {
                return parseFloat(this.miniWidth);
            }
            else {
                // if (!this.isOpen) { // This WON'T work due to transition timings...
                //     return this.elementRef.nativeElement.children[1].offsetWidth;
                // } else {
                if (this._widthCache.miniWidth === null) {
                    // force class for width calc. TODO?
                    // force class for width calc. TODO?
                    this.renderer.addClass(this.styleDummy, this.css.drawer);
                    this.renderer.addClass(this.styleDummy, this.css.mini);
                    this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                    this.renderer.removeClass(this.styleDummy, this.css.drawer);
                    this.renderer.removeClass(this.styleDummy, this.css.mini);
                }
                return this._widthCache.miniWidth;
            }
        }
        else {
            if (this.width) {
                return parseFloat(this.width);
            }
            else {
                if (this._widthCache.width === null) {
                    // force class for width calc. TODO?
                    // force class for width calc. TODO?
                    this.renderer.addClass(this.styleDummy, this.css.drawer);
                    this._widthCache.width = this.styleDummy.offsetWidth;
                    this.renderer.removeClass(this.styleDummy, this.css.drawer);
                }
                return this._widthCache.width;
            }
        }
    }
    getWindowWidth() {
        return (window.innerWidth > 0) ? window.innerWidth : screen.width;
    }
    /**
     * Sets the drawer width.
     */
    setDrawerWidth(width) {
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(() => {
                if (this.drawer) {
                    this.renderer.setStyle(this.drawer, 'width', width);
                }
            });
        }
        else {
            this.renderer.setStyle(this.drawer, 'width', width);
        }
    }
    /**
     * Get current Drawer width.
     */
    getDrawerWidth() {
        return this.drawer.offsetWidth;
    }
    ensureEvents() {
        // set listeners for swipe/pan only if needed, but just once
        if (this.enableGestures && !this.pin && !this._gesturesAttached) {
            // Built-in manager handler(L20887) causes endless loop and max stack exception.
            // https://github.com/angular/angular/issues/6993
            // Use ours for now (until beta.10):
            // this.renderer.listen(document, "swipe", this.swipe);
            this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);
            this._gesturesAttached = true;
            // this.renderer.listen(document, "panstart", this.panstart);
            // this.renderer.listen(document, "pan", this.pan);
            this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);
            this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);
            this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
        }
        if (!this._resizeObserver && this.platformUtil.isBrowser) {
            this._resizeObserver = fromEvent(window, 'resize').pipe(debounce(() => interval(150)))
                .subscribe((value) => {
                this.checkPinThreshold(value);
            });
        }
    }
    updateEdgeZone() {
        let maxValue;
        if (this.miniTemplate) {
            maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
            this.set_maxEdgeZone(maxValue);
        }
    }
    resetPan() {
        this._panning = false;
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        this.renderer.removeClass(this.overlay, 'panning');
        this.renderer.removeClass(this.drawer, 'panning');
        this.setXSize(0, '');
    }
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     *
     * @param x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param opacity optional value to apply to the overlay
     */
    setXSize(x, opacity) {
        // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
        window.requestAnimationFrame(() => {
            if (this.hasAnimateWidth) {
                this.renderer.setStyle(this.drawer, 'width', x ? Math.abs(x) + 'px' : '');
            }
            else {
                this.renderer.setStyle(this.drawer, 'transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
                this.renderer.setStyle(this.drawer, '-webkit-transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
            }
            if (opacity !== undefined) {
                this.renderer.setStyle(this.overlay, 'opacity', opacity);
            }
        });
    }
}
IgxNavigationDrawerComponent.decorators = [
    { type: Component, args: [{
                providers: [HammerGesturesManager],
                selector: 'igx-nav-drawer',
                template: "<ng-template #defaultItemsTemplate>\n    <div igxDrawerItem [isHeader]=\"true\">Navigation Drawer</div>\n    <div igxDrawerItem> Start by adding</div>\n    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>\n    <div igxDrawerItem> And some items inside </div>\n    <div igxDrawerItem> Style with igxDrawerItem </div>\n    <div igxDrawerItem> and igxRipple directives</div>\n</ng-template>\n\n<div [hidden]=\"pin\"\n    class=\"igx-nav-drawer__overlay\"\n    [class.igx-nav-drawer__overlay--hidden]=\"!isOpen\"\n    [class.igx-nav-drawer--disable-animation]=\"disableAnimation\"\n    (click)=\"close()\" #overlay>\n</div>\n<aside role=\"navigation\"\n    class=\"igx-nav-drawer__aside\"\n    [class.igx-nav-drawer__aside--collapsed]=\"!miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--mini]=\"miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--normal]=\"!miniTemplate || isOpen\"\n    [class.igx-nav-drawer__aside--pinned]=\"pin\"\n    [class.igx-nav-drawer__aside--right]=\"position == 'right'\" #aside\n    [class.igx-nav-drawer--disable-animation]=\"disableAnimation\">\n\n    <ng-container *ngTemplateOutlet=\"template || defaultItemsTemplate\"></ng-container>\n</aside>\n<div class=\"igx-nav-drawer__style-dummy\" #dummy></div>\n",
                styles: [`
        :host {
            display: block;
            height: 100%;
        }
    `]
            },] }
];
IgxNavigationDrawerComponent.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] },
    { type: Renderer2 },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];
IgxNavigationDrawerComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-nav-drawer',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    position: [{ type: Input }],
    enableGestures: [{ type: Input }],
    isOpenChange: [{ type: Output }],
    pinThreshold: [{ type: Input }],
    pin: [{ type: Input }],
    width: [{ type: Input }],
    disableAnimation: [{ type: HostBinding, args: ['class.igx-nav-drawer--disable-animation',] }, { type: Input }],
    miniWidth: [{ type: Input }],
    pinChange: [{ type: Output }],
    opening: [{ type: Output }],
    opened: [{ type: Output }],
    closing: [{ type: Output }],
    closed: [{ type: Output }],
    contentTemplate: [{ type: ContentChild, args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective },] }],
    _drawer: [{ type: ViewChild, args: ['aside', { static: true },] }],
    _overlay: [{ type: ViewChild, args: ['overlay', { static: true },] }],
    _styleDummy: [{ type: ViewChild, args: ['dummy', { static: true },] }],
    isOpen: [{ type: Input }],
    miniTemplate: [{ type: ContentChild, args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective },] }],
    flexWidth: [{ type: HostBinding, args: ['style.flexBasis',] }],
    isPinnedRight: [{ type: HostBinding, args: ['style.order',] }]
};

/**
 * @hidden
 */
class IgxNavigationDrawerModule {
}
IgxNavigationDrawerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxNavigationDrawerComponent,
                    IgxNavDrawerItemDirective,
                    IgxNavDrawerMiniTemplateDirective,
                    IgxNavDrawerTemplateDirective
                ],
                exports: [
                    IgxNavigationDrawerComponent,
                    IgxNavDrawerItemDirective,
                    IgxNavDrawerMiniTemplateDirective,
                    IgxNavDrawerTemplateDirective
                ],
                imports: [CommonModule]
            },] }
];

/**
 * Template directive that allows you to set a custom template representing the lower label value of the {@link IgxSliderComponent}
 *
 * ```html
 * <igx-slider>
 *  <ng-template igxSliderThumbFrom let-value let-labels>{{value}}</ng-template>
 * </igx-slider>
 * ```
 *
 * @context {@link IgxSliderComponent.context}
 */
class IgxThumbFromTemplateDirective {
}
IgxThumbFromTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxSliderThumbFrom]'
            },] }
];
/**
 * Template directive that allows you to set a custom template representing the upper label value of the {@link IgxSliderComponent}
 *
 * ```html
 * <igx-slider>
 *  <ng-template igxSliderThumbTo let-value let-labels>{{value}}</ng-template>
 * </igx-slider>
 * ```
 *
 * @context {@link IgxSliderComponent.context}
 */
class IgxThumbToTemplateDirective {
}
IgxThumbToTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxSliderThumbTo]'
            },] }
];
/**
 * Template directive that allows you to set a custom template, represeting primary/secondary tick labels of the {@link IgxSliderComponent}
 *
 * @context {@link IgxTicksComponent.context}
 */
class IgxTickLabelTemplateDirective {
}
IgxTickLabelTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxSliderTickLabel]'
            },] }
];
const IgxSliderType = mkenum({
    /**
     * Slider with single thumb.
     */
    SLIDER: 'slider',
    /**
     *  Range slider with multiple thumbs, that can mark the range.
     */
    RANGE: 'range'
});
const SliderHandle = mkenum({
    FROM: 'from',
    TO: 'to'
});
/**
 * Slider Tick labels Orientation
 */
const TickLabelsOrientation = mkenum({
    Horizontal: 'horizontal',
    TopToBottom: 'toptobottom',
    BottomToTop: 'bottomtotop'
});
/**
 * Slider Ticks orientation
 */
const TicksOrientation = mkenum({
    Top: 'top',
    Bottom: 'bottom',
    Mirror: 'mirror'
});

/**
 * @hidden
 */
class IgxSliderThumbComponent {
    constructor(_elementRef, _dir) {
        this._elementRef = _elementRef;
        this._dir = _dir;
        this.onThumbValueChange = new EventEmitter();
        this.onChange = new EventEmitter();
        this.onHoverChange = new EventEmitter();
        this.tabindex = 0;
        this.zIndex = 0;
        this.isActive = false;
        this._isActive = false;
        this._isPressed = false;
        this._destroy$ = new Subject();
    }
    get thumbFromClass() {
        return this.type === SliderHandle.FROM;
    }
    get thumbToClass() {
        return this.type === SliderHandle.TO;
    }
    get thumbFromActiveClass() {
        return this.type === SliderHandle.FROM && this._isActive;
    }
    get thumbToActiveClass() {
        return this.type === SliderHandle.TO && this._isActive;
    }
    get thumbPressedClass() {
        return this.isActive && this._isPressed;
    }
    get nativeElement() {
        return this._elementRef.nativeElement;
    }
    get destroy() {
        return this._destroy$;
    }
    get thumbPositionX() {
        const thumbBounderies = this.nativeElement.getBoundingClientRect();
        const thumbCenter = (thumbBounderies.right - thumbBounderies.left) / 2;
        return thumbBounderies.left + thumbCenter;
    }
    onPinterEnter() {
        this.onHoverChange.emit(true);
    }
    onPointerLeave() {
        this.onHoverChange.emit(false);
    }
    onKeyDown(event) {
        if (this.disabled) {
            return;
        }
        let increment = 0;
        if (event.key.endsWith('Left')) {
            increment = this.step * -1;
        }
        else if (event.key.endsWith('Right')) {
            increment = this.step;
        }
        else {
            return;
        }
        this.onChange.emit();
        this.onThumbValueChange.emit(increment);
    }
    onBlur() {
        this.isActive = false;
        this.zIndex = 0;
    }
    onFocusListener() {
        this.isActive = true;
        this.zIndex = 1;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.onPan
            .pipe(takeUntil(this._destroy$))
            .subscribe(mouseX => this.updateThumbValue(mouseX));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
    }
    /**
     * Show thumb label and ripple.
     */
    showThumbIndicators() {
        this.toggleThumbIndicators(true);
    }
    /**
     * Hide thumb label and ripple.
     */
    hideThumbIndicators() {
        this.toggleThumbIndicators(false);
    }
    updateThumbValue(mouseX) {
        const updateValue = this.calculateTrackUpdate(mouseX);
        if (this.isActive && updateValue !== 0) {
            this.onThumbValueChange.emit(updateValue);
        }
    }
    calculateTrackUpdate(mouseX) {
        const scaleX = this._dir.rtl ? this.thumbPositionX - mouseX : mouseX - this.thumbPositionX;
        const stepDistanceCenter = this.stepDistance / 2;
        // If the thumb scale range (slider update) is less thàn a half step,
        // the position stays the same.
        const scaleXPositive = Math.abs(scaleX);
        if (scaleXPositive < stepDistanceCenter) {
            return 0;
        }
        return this.stepToProceed(scaleX, this.stepDistance);
    }
    stepToProceed(scaleX, stepDist) {
        return Math.round(scaleX / stepDist) * this.step;
    }
    toggleThumbIndicators(visible) {
        this._isPressed = visible;
        if (this.continuous || this.deactiveState) {
            this._isActive = false;
        }
        else {
            this._isActive = visible;
        }
    }
}
IgxSliderThumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-thumb',
                template: "<div class=\"dot\"></div>\n"
            },] }
];
IgxSliderThumbComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxDirectionality }
];
IgxSliderThumbComponent.propDecorators = {
    value: [{ type: Input }],
    continuous: [{ type: Input }],
    thumbLabelVisibilityDuration: [{ type: Input }],
    disabled: [{ type: Input }],
    onPan: [{ type: Input }],
    stepDistance: [{ type: Input }],
    step: [{ type: Input }],
    templateRef: [{ type: Input }],
    context: [{ type: Input }],
    type: [{ type: Input }],
    deactiveState: [{ type: Input }],
    onThumbValueChange: [{ type: Output }],
    onChange: [{ type: Output }],
    onHoverChange: [{ type: Output }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    zIndex: [{ type: HostBinding, args: ['attr.z-index',] }],
    thumbFromClass: [{ type: HostBinding, args: ['class.igx-slider__thumb-from',] }],
    thumbToClass: [{ type: HostBinding, args: ['class.igx-slider__thumb-to',] }],
    thumbFromActiveClass: [{ type: HostBinding, args: ['class.igx-slider__thumb-from--active',] }],
    thumbToActiveClass: [{ type: HostBinding, args: ['class.igx-slider__thumb-to--active',] }],
    thumbPressedClass: [{ type: HostBinding, args: ['class.igx-slider__thumb--pressed',] }],
    onPinterEnter: [{ type: HostListener, args: ['pointerenter',] }],
    onPointerLeave: [{ type: HostListener, args: ['pointerleave',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onBlur: [{ type: HostListener, args: ['blur',] }],
    onFocusListener: [{ type: HostListener, args: ['focus',] }]
};

/**
 * @hidden
 */
class IgxThumbLabelComponent {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
    get thumbFromClass() {
        return this.type === SliderHandle.FROM;
    }
    get thumbToClass() {
        return this.type === SliderHandle.TO;
    }
    get thumbFromActiveClass() {
        return this.type === SliderHandle.FROM && this.active;
    }
    get thumbToActiveClass() {
        return this.type === SliderHandle.TO && this.active;
    }
    get labelPressedClass() {
        var _a;
        return (_a = this.thumb) === null || _a === void 0 ? void 0 : _a.thumbPressedClass;
    }
    get nativeElement() {
        return this._elementRef.nativeElement;
    }
    get active() {
        return this._active;
    }
    set active(val) {
        if (this.continuous || this.deactiveState) {
            this._active = false;
        }
        else {
            this._active = val;
        }
    }
}
IgxThumbLabelComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-thumb-label',
                template: "<div class=\"label\">\n    <ng-container *ngTemplateOutlet=\"templateRef ? templateRef : thumbFromDefaultTemplate; context: context\"></ng-container>\n</div>\n\n<ng-template #thumbFromDefaultTemplate>\n    {{ value }}\n</ng-template>\n"
            },] }
];
IgxThumbLabelComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxThumbLabelComponent.propDecorators = {
    value: [{ type: Input }],
    templateRef: [{ type: Input }],
    context: [{ type: Input }],
    type: [{ type: Input }],
    continuous: [{ type: Input }],
    deactiveState: [{ type: Input }],
    thumb: [{ type: Input }],
    thumbFromClass: [{ type: HostBinding, args: ['class.igx-slider__label-from',] }],
    thumbToClass: [{ type: HostBinding, args: ['class.igx-slider__label-to',] }],
    thumbFromActiveClass: [{ type: HostBinding, args: ['class.igx-slider__label-from--active',] }],
    thumbToActiveClass: [{ type: HostBinding, args: ['class.igx-slider__label-to--active',] }],
    labelPressedClass: [{ type: HostBinding, args: ['class.igx-slider__label--pressed',] }]
};

/**
 * @hidden
 */
class IgxTicksComponent {
    constructor() {
        /**
         * @hidden
         */
        this.ticksClass = true;
    }
    /**
     * @hidden
     */
    get ticksTopClass() {
        return this.ticksOrientation === TicksOrientation.Top;
    }
    /**
     * @hidden
     */
    get hasPrimaryClass() {
        return this.primaryTicks > 0;
    }
    /**
     * @hidden
     */
    get labelsTopToBottomClass() {
        return this.tickLabelsOrientation === TickLabelsOrientation.TopToBottom;
    }
    /**
     * @hidden
     */
    get labelsBottomToTopClass() {
        return this.tickLabelsOrientation === TickLabelsOrientation.BottomToTop;
    }
    /**
     * Returns the template context corresponding to
     * {@link IgxTickLabelTemplateDirective}
     *
     * ```typescript
     * return {
     *  $implicit //returns the value per each tick label.
     *  isPrimery //returns if the tick is primary.
     *  labels // returns the {@link labels} collection.
     *  index // returns the index per each tick of the whole sequence.
     * }
     * ```
     *
     * @param idx the index per each tick label.
     */
    context(idx) {
        return {
            $implicit: this.tickLabel(idx),
            isPrimary: this.isPrimary(idx),
            labels: this.labels,
            index: idx
        };
    }
    /**
     * @hidden
     */
    get ticksLength() {
        return this.primaryTicks > 0 ?
            ((this.primaryTicks - 1) * this.secondaryTicks) + this.primaryTicks :
            this.secondaryTicks > 0 ? this.secondaryTicks : 0;
    }
    hiddenTickLabels(idx) {
        return this.isPrimary(idx) ? this.primaryTickLabels : this.secondaryTickLabels;
    }
    /**
     * @hidden
     */
    isPrimary(idx) {
        return this.primaryTicks <= 0 ? false :
            idx % (this.secondaryTicks + 1) === 0;
    }
    /**
     * @hidden
     */
    tickLabel(idx) {
        if (this.labelsViewEnabled) {
            return this.labels[idx];
        }
        const labelStep = (Math.max(this.minValue, this.maxValue) - Math.min(this.minValue, this.maxValue)) / (this.ticksLength - 1);
        const labelVal = labelStep * idx;
        return (this.minValue + labelVal).toFixed(2);
    }
}
IgxTicksComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-ticks',
                template: "<div class=\"igx-slider__ticks-group\" *ngFor=\"let n of [].constructor(ticksLength); let idx=index\" [ngClass]=\"{ 'igx-slider__ticks-group--tall': isPrimary(idx)}\">\n    <div class=\"igx-slider__ticks-tick\">\n        <span class=\"igx-slider__ticks-label\" [ngClass]=\"{ 'igx-slider__tick-label--hidden': !hiddenTickLabels(idx)}\">\n            <ng-container *ngTemplateOutlet=\"tickLabelTemplateRef ? tickLabelTemplateRef : tickLabelDefaultTemplate; context: context(idx)\"></ng-container>\n        </span>\n    </div>\n</div>\n\n<ng-template #tickLabelDefaultTemplate let-value>\n    {{ value }}\n</ng-template>\n"
            },] }
];
IgxTicksComponent.propDecorators = {
    primaryTicks: [{ type: Input }],
    secondaryTicks: [{ type: Input }],
    primaryTickLabels: [{ type: Input }],
    secondaryTickLabels: [{ type: Input }],
    ticksOrientation: [{ type: Input }],
    tickLabelsOrientation: [{ type: Input }],
    maxValue: [{ type: Input }],
    minValue: [{ type: Input }],
    labelsViewEnabled: [{ type: Input }],
    labels: [{ type: Input }],
    tickLabelTemplateRef: [{ type: Input }],
    ticksClass: [{ type: HostBinding, args: ['class.igx-slider__ticks',] }],
    ticksTopClass: [{ type: HostBinding, args: ['class.igx-slider__ticks--top',] }],
    hasPrimaryClass: [{ type: HostBinding, args: ['class.igx-slider__ticks--tall',] }],
    labelsTopToBottomClass: [{ type: HostBinding, args: ['class.igx-slider__tick-labels--top-bottom',] }],
    labelsBottomToTopClass: [{ type: HostBinding, args: ['class.igx-slider__tick-labels--bottom-top',] }]
};

/**
 * @hidden
 */
class IgxTickLabelsPipe {
    transform(labels, secondaryTicks) {
        if (!labels) {
            return;
        }
        const result = [];
        labels.forEach(item => {
            result.push(item);
            for (let i = 0; i < secondaryTicks; i++) {
                result.push('');
            }
        });
        return result;
    }
}
IgxTickLabelsPipe.decorators = [
    { type: Pipe, args: [{
                name: 'spreadTickLabels'
            },] }
];

let NEXT_ID$q = 0;
/**
 * **Ignite UI for Angular Slider** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider/slider)
 *
 * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
 * can be defined as continuous or stepped, and you can choose between single and range slider types.
 *
 * Example:
 * ```html
 * <igx-slider id="slider"
 *            [minValue]="0" [maxValue]="100"
 *            [continuous]=true [(ngModel)]="volume">
 * </igx-slider>
 * ```
 */
class IgxSliderComponent {
    constructor(renderer, _el, _cdr, _ngZone, _dir) {
        this.renderer = renderer;
        this._el = _el;
        this._cdr = _cdr;
        this._ngZone = _ngZone;
        this._dir = _dir;
        /**
         * @hidden
         */
        this.role = 'slider';
        /**
         * @hidden
         */
        this.slierClass = true;
        /**
         * An @Input property that sets the value of the `id` attribute.
         * If not provided it will be automatically generated.
         * ```html
         * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */
        this.id = `igx-slider-${NEXT_ID$q++}`;
        /**
         * An @Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
         * ```html
         * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.thumbLabelVisibilityDuration = 750;
        /**
         * Show/hide slider ticks
         * ```html
         * <igx-slier [showTicks]="true" [primaryTicks]="5"></igx-slier>
         * ```
         */
        this.showTicks = false;
        /**
         * show/hide primary tick labels
         * ```html
         * <igx-slider [primaryTicks]="5" [primaryTickLabels]="false"></igx-slider>
         * ```
         */
        this.primaryTickLabels = true;
        /**
         * show/hide secondary tick labels
         * ```html
         * <igx-slider [secondaryTicks]="5" [secondaryTickLabels]="false"></igx-slider>
         * ```
         */
        this.secondaryTickLabels = true;
        /**
         * Changes ticks orientation:
         * bottom - The default orienation, below the slider track.
         * top - Above the slider track
         * mirror - combines top and bottom orientation.
         * ```html
         * <igx-slider [primaryTicks]="5" [ticksOrientation]="ticksOrientation"></igx-slider>
         * ```
         */
        this.ticksOrientation = TicksOrientation.Bottom;
        /**
         * Changes tick labels rotation:
         * horizontal - The default rotation
         * toptobottom - Rotates tick labels vertically to 90deg
         * bottomtotop - Rotate tick labels vertically to -90deg
         * ```html
         * <igx-slider [primaryTicks]="5" [secondaryTicks]="3" [tickLabelsOrientation]="tickLabelsOrientaiton"></igx-slider>
         * ```
         */
        this.tickLabelsOrientation = TickLabelsOrientation.Horizontal;
        /**
         * This event is emitted every time the value is changed.
         * ```typescript
         * public change(event){
         *    alert("The value has been changed!");
         * }
         * ```
         * ```html
         * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.onValueChange = new EventEmitter();
        /**
         * This event is emitted at the end of every slide interaction.
         * ```typescript
         * public change(event){
         *    alert("The value has been changed!");
         * }
         * ```
         * ```html
         * <igx-slider (onValueChanged)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.onValueChanged = new EventEmitter();
        /**
         * @hidden
         */
        this.thumbs = new QueryList();
        /**
         * @hidden
         */
        this.labelRefs = new QueryList();
        /**
         * @hidden
         */
        this.onPan = new Subject();
        // Limit handle travel zone
        this._pMin = 0;
        this._pMax = 1;
        // From/upperValue in percent values
        this._hasViewInit = false;
        this._minValue = 0;
        this._maxValue = 100;
        this._continuous = false;
        this._disabled = false;
        this._step = 1;
        this._value = 0;
        // ticks
        this._primaryTicks = 0;
        this._secondaryTicks = 0;
        this._labels = new Array();
        this._type = IgxSliderType.SLIDER;
        this._destroyer$ = new Subject();
        this._indicatorsDestroyer$ = new Subject();
        this._onChangeCallback = noop;
        this._onTouchedCallback = noop;
        this.stepDistance = this._step;
    }
    /**
     * @hidden
     */
    get thumbFrom() {
        return this.thumbs.find(thumb => thumb.type === SliderHandle.FROM);
    }
    /**
     * @hidden
     */
    get thumbTo() {
        return this.thumbs.find(thumb => thumb.type === SliderHandle.TO);
    }
    get labelFrom() {
        return this.labelRefs.find(label => label.type === SliderHandle.FROM);
    }
    get labelTo() {
        return this.labelRefs.find(label => label.type === SliderHandle.TO);
    }
    /**
     * @hidden
     */
    get valuemin() {
        return this.minValue;
    }
    /**
     * @hidden
     */
    get valuemax() {
        return this.maxValue;
    }
    /**
     * @hidden
     */
    get readonly() {
        return this.disabled;
    }
    /**
     * @hidden
     */
    get disabledClass() {
        return this.disabled;
    }
    /**
     * An @Input property that gets the type of the `IgxSliderComponent`.
     * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let type = this.slider.type;
     * }
     */
    get type() {
        return this._type;
    }
    /**
     * An @Input property that sets the type of the `IgxSliderComponent`.
     * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
     * ```typescript
     * sliderType: IgxSliderType = IgxSliderType.RANGE;
     * ```
     * ```html
     * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
     * ```
     */
    set type(type) {
        this._type = type;
        if (type === IgxSliderType.SLIDER) {
            this.lowerValue = 0;
        }
        if (this.labelsViewEnabled && this.upperValue > this.maxValue) {
            this.upperValue = this.labels.length - 1;
        }
        if (this._hasViewInit) {
            this.updateTrack();
        }
    }
    /**
     * Enables `labelView`, by accepting a collection of primitive values with more than one element.
     * Each element will be equally spread over the slider and it will serve as a thumb label.
     * Once the property is set, it will precendence over {@link maxValue}, {@link minValue}, {@link step}.
     * This means that the manipulation for those properties won't be allowed.
     */
    get labels() {
        return this._labels;
    }
    set labels(labels) {
        this._labels = labels;
        this._pMax = this.valueToFraction(this.upperBound, 0, 1);
        this._pMin = this.valueToFraction(this.lowerBound, 0, 1);
        this.positionHandlersAndUpdateTrack();
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.setTickInterval();
        }
    }
    /**
     * Returns the template context corresponding
     * to {@link IgxThumbFromTemplateDirective} and {@link IgxThumbToTemplateDirective} templates.
     *
     * ```typescript
     * return {
     *  $implicit // returns the value of the label,
     *  labels // returns the labels collection the user has passed.
     * }
     * ```
     */
    get context() {
        return {
            $implicit: this.value,
            labels: this.labels
        };
    }
    /**
     * An @Input property that sets the incremental/decremental step of the value when dragging the thumb.
     * The default step is 1, and step should not be less or equal than 0.
     * ```html
     * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     */
    set step(step) {
        this._step = step;
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.normalizeByStep(this.value);
            this.setTickInterval();
        }
    }
    /**
     * Returns the incremental/decremental dragging step of the {@link IgxSliderComponent}.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let step = this.slider.step;
     * }
     * ```
     */
    get step() {
        return this.labelsViewEnabled ? 1 : this._step;
    }
    /**
     * Returns if the {@link IgxSliderComponent} is disabled.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let isDisabled = this.slider.disabled;
     * }
     * ```
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * An @Input property that disables or enables UI interaction.
     * ```html
     * <igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     */
    set disabled(disable) {
        this._disabled = disable;
        if (this._hasViewInit) {
            this.changeThumbFocusableState(disable);
        }
    }
    /**
     * Returns if the {@link IgxSliderComponent} is set as continuous.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let continuous = this.slider.continuous;
     * }
     * ```
     */
    get continuous() {
        return this._continuous;
    }
    /**
     * An @Input property that marks the {@link IgxSliderComponent} as continuous.
     * By default is considered that the {@link IgxSliderComponent} is discrete.
     * Discrete {@link IgxSliderComponent} slider has step indicators over the track and visible thumb labels during interaction.
     * Continuous {@link IgxSliderComponent} does not have ticks and does not show bubble labels for values.
     * ```html
     * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     */
    set continuous(continuous) {
        this._continuous = continuous;
        if (this._hasViewInit) {
            this.setTickInterval();
        }
    }
    /**
     * Returns the minimal value of the `IgxSliderComponent`.
     * ```typescript
     *  @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let sliderMin = this.slider.minValue;
     * }
     * ```
     */
    get minValue() {
        if (this.labelsViewEnabled) {
            return 0;
        }
        return this._minValue;
    }
    /**
     * Sets the minimal value for the `IgxSliderComponent`.
     * The default minimal value is 0.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
     * ```
     */
    set minValue(value) {
        if (value >= this.maxValue) {
            return;
        }
        else {
            this._minValue = value;
        }
        if (value > this.upperBound) {
            this.updateUpperBoundAndMaxTravelZone();
            this.lowerBound = value;
        }
        // Refresh min travel zone limit.
        this._pMin = 0;
        // Recalculate step distance.
        this.positionHandlersAndUpdateTrack();
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.setTickInterval();
        }
    }
    /**
     * Returns the maximum value for the {@link IgxSliderComponent}.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let sliderMax = this.slider.maxValue;
     * }
     *  ```
     */
    get maxValue() {
        return this.labelsViewEnabled ?
            this.labels.length - 1 :
            this._maxValue;
    }
    /**
     * Sets the maximal value for the `IgxSliderComponent`.
     * The default maximum value is 100.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
     * ```
     */
    set maxValue(value) {
        if (value <= this._minValue) {
            return;
        }
        else {
            this._maxValue = value;
        }
        if (value < this.lowerBound) {
            this.updateLowerBoundAndMinTravelZone();
            this.upperBound = value;
        }
        // refresh max travel zone limits.
        this._pMax = 1;
        // recalculate step distance.
        this.positionHandlersAndUpdateTrack();
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.setTickInterval();
        }
    }
    /**
     * Returns the lower boundary of the `IgxSliderComponent`.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let sliderLowBound = this.slider.lowerBound;
     * }
     * ```
     */
    get lowerBound() {
        if (!Number.isNaN(this._lowerBound) && this._lowerBound !== undefined) {
            return this.valueInRange(this._lowerBound, this.minValue, this.maxValue);
        }
        return this.minValue;
    }
    /**
     * Sets the lower boundary of the `IgxSliderComponent`.
     * If not set is the same as min value.
     * ```html
     * <igx-slider [step]="5" [lowerBound]="20">
     * ```
     */
    set lowerBound(value) {
        if (value >= this.upperBound || (this.labelsViewEnabled && value < 0)) {
            return;
        }
        this._lowerBound = this.valueInRange(value, this.minValue, this.maxValue);
        // Refresh min travel zone.
        this._pMin = this.valueToFraction(this._lowerBound, 0, 1);
        this.positionHandlersAndUpdateTrack();
    }
    /**
     * Returns the upper boundary of the `IgxSliderComponent`.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderUpBound = this.slider.upperBound;
     * }
     * ```
     */
    get upperBound() {
        if (!Number.isNaN(this._upperBound) && this._upperBound !== undefined) {
            return this.valueInRange(this._upperBound, this.minValue, this.maxValue);
        }
        return this.maxValue;
    }
    /**
     * Sets the upper boundary of the `IgxSliderComponent`.
     * If not set is the same as max value.
     * ```html
     * <igx-slider [step]="5" [upperBound]="20">
     * ```
     */
    set upperBound(value) {
        if (value <= this.lowerBound || (this.labelsViewEnabled && value > this.labels.length - 1)) {
            return;
        }
        this._upperBound = this.valueInRange(value, this.minValue, this.maxValue);
        // Refresh time travel zone.
        this._pMax = this.valueToFraction(this._upperBound, 0, 1);
        this.positionHandlersAndUpdateTrack();
    }
    /**
     * Returns the slider value. If the slider is of type {@link IgxSliderType.SLIDER} the returned value is number.
     * If the slider type is {@link IgxSliderType.RANGE}.
     * The returned value represents an object of {@link lowerValue} and {@link upperValue}.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public sliderValue(event){
     *     let sliderVal = this.slider.value;
     * }
     * ```
     */
    get value() {
        if (this.isRange) {
            return {
                lower: this.valueInRange(this.lowerValue, this.lowerBound, this.upperBound),
                upper: this.valueInRange(this.upperValue, this.lowerBound, this.upperBound)
            };
        }
        else {
            return this.valueInRange(this.upperValue, this.lowerBound, this.upperBound);
        }
    }
    /**
     * Sets the slider value.
     * If the slider is of type {@link IgxSliderType.SLIDER}.
     * The argument is number. By default the {@link value} gets the {@link lowerBound}.
     * If the slider type is {@link IgxSliderType.RANGE} the argument
     * represents an object of {@link lowerValue} and {@link upperValue} properties.
     * By default the object is associated with the {@link lowerBound} and {@link upperBound} property values.
     * ```typescript
     * rangeValue = {
     *   lower: 30,
     *   upper: 60
     * };
     * ```
     * ```html
     * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
     * ```
     */
    set value(value) {
        if (this._hasViewInit) {
            this.setValue(value, true);
            this.positionHandlersAndUpdateTrack();
        }
        else {
            this._value = value;
        }
    }
    /**
     * Returns the number of the presented primary ticks.
     * ```typescript
     * const primaryTicks = this.slider.primaryTicks;
     * ```
     */
    get primaryTicks() {
        if (this.labelsViewEnabled) {
            return this._primaryTicks = this.labels.length;
        }
        return this._primaryTicks;
    }
    /**
     * Sets the number of primary ticks. If {@link @labels} is enabled, this property won't function.
     * Insted enable ticks by {@link showTicks} property.
     * ```typescript
     * this.slider.primaryTicks = 5;
     * ```
     */
    set primaryTicks(val) {
        if (val <= 1) {
            return;
        }
        this._primaryTicks = val;
    }
    /**
     * Returns the number of the presented secondary ticks.
     * ```typescript
     * const secondaryTicks = this.slider.secondaryTicks;
     * ```
     */
    get secondaryTicks() {
        return this._secondaryTicks;
    }
    /**
     * Sets the number of secondary ticks. The property functions even when {@link labels} is enabled,
     * but all secondary ticks won't present any tick labels.
     * ```typescript
     * this.slider.secondaryTicks = 5;
     * ```
     */
    set secondaryTicks(val) {
        if (val < 1) {
            return;
        }
        this._secondaryTicks = val;
    }
    /**
     * @hidden
     */
    get deactivateThumbLabel() {
        return ((this.primaryTicks && this.primaryTickLabels) || (this.secondaryTicks && this.secondaryTickLabels)) &&
            (this.ticksOrientation === TicksOrientation.Top || this.ticksOrientation === TicksOrientation.Mirror);
    }
    /**
     * @hidden
     */
    onPointerDown($event) {
        this.findClosestThumb($event);
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        const activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbFrom;
        activeThumb.nativeElement.setPointerCapture($event.pointerId);
        this.showSliderIndicators();
        $event.preventDefault();
    }
    /**
     * @hidden
     */
    onPointerUp($event) {
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        const activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbTo;
        activeThumb.nativeElement.releasePointerCapture($event.pointerId);
        this.hideSliderIndicators();
        this.onValueChanged.emit(this.value);
    }
    /**
     * @hidden
     */
    onFocus() {
        this.toggleSliderIndicators();
    }
    /**
     * @hidden
     */
    onPanListener($event) {
        this.update($event.srcEvent.clientX);
    }
    /**
     * Returns whether the `IgxSliderComponent` type is RANGE.
     * ```typescript
     *  @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let sliderRange = this.slider.isRange;
     * }
     * ```
     */
    get isRange() {
        return this.type === IgxSliderType.RANGE;
    }
    /**
     * Returns the lower value of the `IgxSliderComponent`.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *    let sliderLowValue = this.slider.lowerValue;
     * }
     * ```
     */
    get lowerValue() {
        if (!Number.isNaN(this._lowerValue) && this._lowerValue !== undefined && this._lowerValue >= this.lowerBound) {
            return this._lowerValue;
        }
        return this.lowerBound;
    }
    /**
     * Sets the lower value of the `IgxSliderComponent`.
     * ```typescript
     *  @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *     this.slider.lowerValue = 120;
     * }
     * ```
     */
    set lowerValue(value) {
        value = this.valueInRange(value, this.lowerBound, this.upperBound);
        this._lowerValue = value;
    }
    /**
     * Returns the upper value of the `IgxSliderComponent`.
     * ```typescript
     *  @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public upperValue(event){
     *     let upperValue = this.slider.upperValue;
     * }
     * ```
     */
    get upperValue() {
        if (!Number.isNaN(this._upperValue) && this._upperValue !== undefined && this._upperValue <= this.upperBound) {
            return this._upperValue;
        }
        return this.upperBound;
    }
    /**
     * Sets the upper value of the `IgxSliderComponent`.
     * ```typescript
     *  @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public upperValue(event){
     *     this.slider.upperValue = 120;
     * }
     * ```
     */
    set upperValue(value) {
        value = this.valueInRange(value, this.lowerBound, this.upperBound);
        this._upperValue = value;
    }
    /**
     * Returns the value corresponding the lower label.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.lowerLabel;
     * ```
     */
    get lowerLabel() {
        return this.labelsViewEnabled ?
            this.labels[this.lowerValue] :
            this.lowerValue;
    }
    /**
     * Returns the value corresponding the upper label.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.upperLabel;
     * ```
     */
    get upperLabel() {
        return this.labelsViewEnabled ?
            this.labels[this.upperValue] :
            this.upperValue;
    }
    /**
     * Returns if label view is enabled.
     * If the {@link labels} is set, the view is automatically activated.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let labelView = this.slider.labelsViewEnabled;
     * ```
     */
    get labelsViewEnabled() {
        return !!(this.labels && this.labels.length > 1);
    }
    /**
     * @hidden
     */
    get showTopTicks() {
        return this.ticksOrientation === TicksOrientation.Top ||
            this.ticksOrientation === TicksOrientation.Mirror;
    }
    /**
     * @hidden
     */
    get showBottomTicks() {
        return this.ticksOrientation === TicksOrientation.Bottom ||
            this.ticksOrientation === TicksOrientation.Mirror;
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (changes.minValue && changes.maxValue &&
            changes.minValue.currentValue < changes.maxValue.currentValue) {
            this._maxValue = changes.maxValue.currentValue;
            this._minValue = changes.minValue.currentValue;
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.sliderSetup();
        // Set track travel zone
        this._pMin = this.valueToFraction(this.lowerBound) || 0;
        this._pMax = this.valueToFraction(this.upperBound) || 1;
    }
    ngAfterContentInit() {
        this.setValue(this._value, false);
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this._hasViewInit = true;
        this.stepDistance = this.calculateStepDistance();
        this.positionHandlersAndUpdateTrack();
        this.setTickInterval();
        this.changeThumbFocusableState(this.disabled);
        this.subscribeTo(this.thumbFrom, this.thumbChanged.bind(this));
        this.subscribeTo(this.thumbTo, this.thumbChanged.bind(this));
        this.thumbs.changes.pipe(takeUntil(this._destroyer$)).subscribe(change => {
            const thumbFrom = change.find((thumb) => thumb.type === SliderHandle.FROM);
            this.positionHandler(thumbFrom, null, this.lowerValue);
            this.subscribeTo(thumbFrom, this.thumbChanged.bind(this));
            this.changeThumbFocusableState(this.disabled);
        });
        this.labelRefs.changes.pipe(takeUntil(this._destroyer$)).subscribe(change => {
            const labelFrom = this.labelRefs.find((label) => label.type === SliderHandle.FROM);
            this.positionHandler(null, labelFrom, this.lowerValue);
        });
        this._ngZone.runOutsideAngular(() => {
            resizeObservable(this._el.nativeElement).pipe(throttleTime(40), takeUntil(this._destroyer$)).subscribe(() => this._ngZone.run(() => {
                this.stepDistance = this.calculateStepDistance();
            }));
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroyer$.next(true);
        this._destroyer$.complete();
        this._indicatorsDestroyer$.next(true);
        this._indicatorsDestroyer$.complete();
    }
    /**
     * @hidden
     */
    writeValue(value) {
        if (!value) {
            return;
        }
        this.normalizeByStep(value);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /** @hidden */
    getEditElement() {
        return this.isRange ? this.thumbFrom.nativeElement : this.thumbTo.nativeElement;
    }
    /**
     *
     * @hidden
     */
    update(mouseX) {
        if (this.disabled) {
            return;
        }
        // Update To/From Values
        this.onPan.next(mouseX);
        // Finally do positionHandlersAndUpdateTrack the DOM
        // based on data values
        this.positionHandlersAndUpdateTrack();
        this._onTouchedCallback();
    }
    /**
     * @hidden
     */
    thumbChanged(value, thumbType) {
        const oldValue = this.value;
        let newVal;
        if (this.isRange) {
            if (thumbType === SliderHandle.FROM) {
                newVal = {
                    lower: this.value.lower + value,
                    upper: this.value.upper
                };
            }
            else {
                newVal = {
                    lower: this.value.lower,
                    upper: this.value.upper + value
                };
            }
            // Swap the thumbs if a collision appears.
            if (newVal.lower >= newVal.upper) {
                this.value = this.swapThumb(newVal);
            }
            else {
                this.value = newVal;
            }
        }
        else {
            this.value = this.value + value;
        }
        if (this.hasValueChanged(oldValue)) {
            this.emitValueChanged(oldValue);
        }
    }
    /**
     * @hidden
     */
    onThumbChange() {
        this.toggleSliderIndicators();
    }
    /**
     * @hidden
     */
    onHoverChange(state) {
        return state ? this.showSliderIndicators() : this.hideSliderIndicators();
    }
    setValue(value, triggerChange) {
        let res;
        if (!this.isRange) {
            this.upperValue = value - (value % this.step);
            res = this.upperValue;
        }
        else {
            value = this.validateInitialValue(value);
            this.upperValue = value.upper;
            this.lowerValue = value.lower;
            res = { lower: this.lowerValue, upper: this.upperValue };
        }
        if (triggerChange) {
            this._onChangeCallback(res);
        }
    }
    swapThumb(value) {
        if (this.thumbFrom.isActive) {
            value.upper = this.upperValue;
            value.lower = this.upperValue;
        }
        else {
            value.upper = this.lowerValue;
            value.lower = this.lowerValue;
        }
        this.toggleThumb();
        return value;
    }
    findClosestThumb(event) {
        if (this.isRange) {
            this.closestHandle(event);
        }
        else {
            this.thumbTo.nativeElement.focus();
        }
        this.update(event.clientX);
    }
    updateLowerBoundAndMinTravelZone() {
        this.lowerBound = this.minValue;
        this._pMin = 0;
    }
    updateUpperBoundAndMaxTravelZone() {
        this.upperBound = this.maxValue;
        this._pMax = 1;
    }
    sliderSetup() {
        /**
         * if {@link SliderType.SLIDER} than the initial value shold be the lowest one.
         */
        if (!this.isRange && this._upperValue === undefined) {
            this._upperValue = this.lowerBound;
        }
    }
    calculateStepDistance() {
        return this._el.nativeElement.getBoundingClientRect().width / (this.maxValue - this.minValue) * this.step;
    }
    toggleThumb() {
        return this.thumbFrom.isActive ?
            this.thumbTo.nativeElement.focus() :
            this.thumbFrom.nativeElement.focus();
    }
    valueInRange(value, min = 0, max = 100) {
        return Math.max(Math.min(value, max), min);
    }
    generateTickMarks(color, interval) {
        return interval !== null ? `repeating-linear-gradient(
            ${'to left'},
            ${color},
            ${color} 1.5px,
            transparent 1.5px,
            transparent ${interval}%
        ), repeating-linear-gradient(
            ${'to right'},
            ${color},
            ${color} 1.5px,
            transparent 1.5px,
            transparent ${interval}%
        )` : interval;
    }
    positionHandler(thumbHandle, labelHandle, position) {
        const percent = `${this.valueToFraction(position) * 100}%`;
        const dir = this._dir.rtl ? 'right' : 'left';
        if (thumbHandle) {
            thumbHandle.nativeElement.style[dir] = percent;
        }
        if (labelHandle) {
            labelHandle.nativeElement.style[dir] = percent;
        }
    }
    positionHandlersAndUpdateTrack() {
        if (!this.isRange) {
            this.positionHandler(this.thumbTo, this.labelTo, this.value);
        }
        else {
            this.positionHandler(this.thumbTo, this.labelTo, this.value.upper);
            this.positionHandler(this.thumbFrom, this.labelFrom, this.value.lower);
        }
        if (this._hasViewInit) {
            this.updateTrack();
        }
    }
    closestHandle(event) {
        const fromOffset = this.thumbFrom.nativeElement.offsetLeft + this.thumbFrom.nativeElement.offsetWidth / 2;
        const toOffset = this.thumbTo.nativeElement.offsetLeft + this.thumbTo.nativeElement.offsetWidth / 2;
        const xPointer = event.clientX - this._el.nativeElement.getBoundingClientRect().left;
        const match = this.closestTo(xPointer, [fromOffset, toOffset]);
        if (fromOffset === toOffset && toOffset < xPointer) {
            this.thumbTo.nativeElement.focus();
        }
        else if (fromOffset === toOffset && toOffset > xPointer) {
            this.thumbFrom.nativeElement.focus();
        }
        else if (match === fromOffset) {
            this.thumbFrom.nativeElement.focus();
        }
        else {
            this.thumbTo.nativeElement.focus();
        }
    }
    setTickInterval() {
        let interval;
        const trackProgress = 100;
        if (this.labelsViewEnabled) {
            // Calc ticks depending on the labels length;
            interval = ((trackProgress / (this.labels.length - 1) * 10)) / 10;
        }
        else {
            const trackRange = this.maxValue - this.minValue;
            interval = this.step > 1 ?
                (trackProgress / ((trackRange / this.step)) * 10) / 10
                : null;
        }
        const renderCallbackExecution = !this.continuous ? this.generateTickMarks(isIE() ? 'white' : 'var(--igx-slider-track-step-color, white)', interval) : null;
        this.renderer.setStyle(this.ticks.nativeElement, 'background', renderCallbackExecution);
    }
    showSliderIndicators() {
        if (this.disabled) {
            return;
        }
        if (this._indicatorsTimer) {
            this._indicatorsDestroyer$.next(true);
            this._indicatorsTimer = null;
        }
        this.thumbTo.showThumbIndicators();
        this.labelTo.active = true;
        if (this.thumbFrom) {
            this.thumbFrom.showThumbIndicators();
        }
        if (this.labelFrom) {
            this.labelFrom.active = true;
        }
    }
    hideSliderIndicators() {
        if (this.disabled) {
            return;
        }
        this._indicatorsTimer = timer(this.thumbLabelVisibilityDuration);
        this._indicatorsTimer.pipe(takeUntil(this._indicatorsDestroyer$)).subscribe(() => {
            this.thumbTo.hideThumbIndicators();
            this.labelTo.active = false;
            if (this.thumbFrom) {
                this.thumbFrom.hideThumbIndicators();
            }
            if (this.labelFrom) {
                this.labelFrom.active = false;
            }
        });
    }
    toggleSliderIndicators() {
        this.showSliderIndicators();
        this.hideSliderIndicators();
    }
    changeThumbFocusableState(state) {
        const value = state ? -1 : 1;
        if (this.isRange) {
            this.thumbFrom.tabindex = value;
        }
        this.thumbTo.tabindex = value;
        this._cdr.detectChanges();
    }
    closestTo(goal, positions) {
        return positions.reduce((previous, current) => (Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous));
    }
    valueToFraction(value, pMin = this._pMin, pMax = this._pMax) {
        return this.valueInRange((value - this.minValue) / (this.maxValue - this.minValue), pMin, pMax);
    }
    /**
     * @hidden
     * Normalizе the value when two-way data bind is used and {@link this.step} is set.
     * @param value
     */
    normalizeByStep(value) {
        if (this.isRange) {
            this.value = {
                lower: value.lower - (value.lower % this.step),
                upper: value.upper - (value.upper % this.step)
            };
        }
        else {
            this.value = value - (value % this.step);
        }
        this._cdr.detectChanges();
    }
    updateTrack() {
        const fromPosition = this.valueToFraction(this.lowerValue);
        const toPosition = this.valueToFraction(this.upperValue);
        const positionGap = toPosition - fromPosition;
        let trackLeftIndention = fromPosition;
        if (this.isRange) {
            if (positionGap) {
                trackLeftIndention = Math.round((1 / positionGap * fromPosition) * 100);
            }
            trackLeftIndention = this._dir.rtl ? -trackLeftIndention : trackLeftIndention;
            this.renderer.setStyle(this.trackRef.nativeElement, 'transform', `scaleX(${positionGap}) translateX(${trackLeftIndention}%)`);
        }
        else {
            this.renderer.setStyle(this.trackRef.nativeElement, 'transform', `scaleX(${toPosition})`);
        }
    }
    validateInitialValue(value) {
        if (value.lower < this.lowerBound && value.upper < this.lowerBound) {
            value.upper = this.lowerBound;
            value.lower = this.lowerBound;
        }
        if (value.lower > this.upperBound && value.upper > this.upperBound) {
            value.upper = this.upperBound;
            value.lower = this.upperBound;
        }
        if (value.upper < value.lower) {
            value.upper = this.upperValue;
            value.lower = this.lowerValue;
        }
        return value;
    }
    subscribeTo(thumb, callback) {
        if (!thumb) {
            return;
        }
        thumb.onThumbValueChange
            .pipe(takeUntil(this.unsubscriber(thumb)))
            .subscribe(value => callback(value, thumb.type));
    }
    unsubscriber(thumb) {
        return merge(this._destroyer$, thumb.destroy);
    }
    hasValueChanged(oldValue) {
        const isSliderWithDifferentValue = !this.isRange && oldValue !== this.value;
        const isRangeWithOneDifferentValue = this.isRange &&
            (oldValue.lower !== this.value.lower ||
                oldValue.upper !== this.value.upper);
        return isSliderWithDifferentValue || isRangeWithOneDifferentValue;
    }
    emitValueChanged(oldValue) {
        this.onValueChange.emit({ oldValue, value: this.value });
    }
}
IgxSliderComponent.decorators = [
    { type: Component, args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSliderComponent, multi: true }],
                selector: 'igx-slider',
                template: "<div class=\"igx-slider__track\">\n    <igx-ticks\n        *ngIf=\"showTicks && showTopTicks\"\n        ticksOrientation=\"top\"\n        [primaryTicks]=\"primaryTicks\"\n        [secondaryTicks]=\"secondaryTicks\"\n        [primaryTickLabels]=\"primaryTickLabels\"\n        [secondaryTickLabels]=\"secondaryTickLabels\"\n        [tickLabelsOrientation]=\"tickLabelsOrientation\"\n        [labelsViewEnabled]=\"labelsViewEnabled\"\n        [labels]=\"labels | spreadTickLabels:secondaryTicks\"\n        [tickLabelTemplateRef]=\"tickLabelTemplateRef\"\n        [minValue]=\"minValue\"\n        [maxValue]=\"maxValue\"></igx-ticks>\n\n    <div #track class=\"igx-slider__track-fill\"></div>\n    <div #ticks class=\"igx-slider__track-steps\"></div>\n\n    <igx-ticks\n        *ngIf=\"showTicks && showBottomTicks\"\n        ticksOrientation=\"bottom\"\n        [primaryTicks]=\"primaryTicks\"\n        [secondaryTicks]=\"secondaryTicks\"\n        [primaryTickLabels]=\"primaryTickLabels\"\n        [secondaryTickLabels]=\"secondaryTickLabels\"\n        [tickLabelsOrientation]=\"tickLabelsOrientation\"\n        [labelsViewEnabled]=\"labelsViewEnabled\"\n        [labels]=\"labels | spreadTickLabels:secondaryTicks\"\n        [tickLabelTemplateRef]=\"tickLabelTemplateRef\"\n        [minValue]=\"minValue\"\n        [maxValue]=\"maxValue\"></igx-ticks>\n</div>\n<div class=\"igx-slider__thumbs\">\n    <igx-thumb-label\n        *ngIf=\"isRange\"\n        type=\"from\"\n        [value]=\"lowerLabel\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumb]=\"thumbFrom\"></igx-thumb-label>\n\n    <igx-thumb\n        *ngIf=\"isRange\"\n        #thumbFrom\n        type=\"from\"\n        [value]=\"lowerLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n\n    <igx-thumb-label\n        [value]=\"upperLabel\"\n        type=\"to\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumb]=\"thumbTo\"></igx-thumb-label>\n\n    <igx-thumb\n        #thumbTo\n        type=\"to\"\n        [value]=\"upperLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n</div>\n"
            },] }
];
IgxSliderComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: IgxDirectionality }
];
IgxSliderComponent.propDecorators = {
    trackRef: [{ type: ViewChild, args: ['track', { static: true },] }],
    thumbFromTemplateRef: [{ type: ContentChild, args: [IgxThumbFromTemplateDirective, { read: TemplateRef },] }],
    thumbToTemplateRef: [{ type: ContentChild, args: [IgxThumbToTemplateDirective, { read: TemplateRef },] }],
    tickLabelTemplateRef: [{ type: ContentChild, args: [IgxTickLabelTemplateDirective, { read: TemplateRef, static: false },] }],
    role: [{ type: HostBinding, args: [`attr.role`,] }],
    slierClass: [{ type: HostBinding, args: ['class.igx-slider',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    thumbLabelVisibilityDuration: [{ type: Input }],
    valuemin: [{ type: HostBinding, args: [`attr.aria-valuemin`,] }],
    valuemax: [{ type: HostBinding, args: [`attr.aria-valuemax`,] }],
    readonly: [{ type: HostBinding, args: [`attr.aria-readonly`,] }],
    disabledClass: [{ type: HostBinding, args: ['class.igx-slider--disabled',] }],
    type: [{ type: Input }],
    labels: [{ type: Input }],
    step: [{ type: Input }],
    disabled: [{ type: Input }],
    continuous: [{ type: Input }],
    minValue: [{ type: Input }],
    maxValue: [{ type: Input }],
    lowerBound: [{ type: Input }],
    upperBound: [{ type: Input }],
    value: [{ type: Input }],
    primaryTicks: [{ type: Input }],
    secondaryTicks: [{ type: Input }],
    showTicks: [{ type: Input }],
    primaryTickLabels: [{ type: Input }],
    secondaryTickLabels: [{ type: Input }],
    ticksOrientation: [{ type: Input }],
    tickLabelsOrientation: [{ type: Input }],
    onValueChange: [{ type: Output }],
    onValueChanged: [{ type: Output }],
    ticks: [{ type: ViewChild, args: ['ticks', { static: true },] }],
    thumbs: [{ type: ViewChildren, args: [IgxSliderThumbComponent,] }],
    labelRefs: [{ type: ViewChildren, args: [IgxThumbLabelComponent,] }],
    onPointerDown: [{ type: HostListener, args: ['pointerdown', ['$event'],] }],
    onPointerUp: [{ type: HostListener, args: ['pointerup', ['$event'],] }],
    onFocus: [{ type: HostListener, args: ['focus',] }],
    onPanListener: [{ type: HostListener, args: ['pan', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxSliderModule {
}
IgxSliderModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxSliderComponent,
                    IgxThumbFromTemplateDirective,
                    IgxThumbToTemplateDirective,
                    IgxTickLabelTemplateDirective,
                    IgxSliderThumbComponent,
                    IgxThumbLabelComponent,
                    IgxTicksComponent,
                    IgxTickLabelsPipe
                ],
                exports: [
                    IgxSliderComponent,
                    IgxThumbFromTemplateDirective,
                    IgxThumbToTemplateDirective,
                    IgxTickLabelTemplateDirective,
                    IgxSliderThumbComponent,
                    IgxThumbLabelComponent,
                    IgxTicksComponent
                ],
                imports: [CommonModule, FormsModule]
            },] }
];

const SwitchLabelPosition = mkenum({
    BEFORE: 'before',
    AFTER: 'after'
});
let nextId$3 = 0;
/**
 *
 * The Switch component is a binary choice selection component.
 *
 * @igxModule IgxSwitchModule
 *
 * @igxTheme igx-switch-theme, igx-tooltip-theme
 *
 * @igxKeywords switch, states, tooltip
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 *
 * The Ignite UI Switch lets the user toggle between on/off or true/false states.
 *
 * @example
 * ```html
 * <igx-switch [checked]="true">
 *   Simple switch
 * </igx-switch>
 * ```
 */
class IgxSwitchComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the switch component.
         * If not set, the `id` of the first switch component will be `"igx-switch-0"`.
         *
         * @example
         * ```html
         * <igx-switch id="my-first-switch"></igx-switch>
         * ```
         */
        this.id = `igx-switch-${nextId$3++}`;
        /**
         * Sets/gets the id of the `label` element of the switch component.
         * If not set, the label of the first switch component will have value `"igx-switch-0-label"`.
         *
         * @example
         * ```html
         * <igx-switch labelId="Label1"></igx-switch>
         * ```
         */
        this.labelId = `${this.id}-label`;
        /**
         * Sets/gets the value of the `tabindex` attribute.
         *
         * @example
         * ```html
         * <igx-switch [tabindex]="1"></igx-switch>
         * ```
         */
        this.tabindex = null;
        /**
         * Sets/gets the position of the `label` in the switch component.
         * If not set, `labelPosition` will have value `"after"`.
         *
         * @example
         * ```html
         * <igx-switch labelPosition="before"></igx-switch>
         * ```
         */
        this.labelPosition = 'after';
        /**
         * Enables/Disables the ripple effect
         * If not set, `disableRipple` will have value `false`.
         *
         * @example
         * ```html
         * <igx-switch [disableRipple]="true"></igx-switch>
         * ```
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether switch is required.
         * If not set, `required` will have value `false`.
         *
         * @example
         * ```html
         * <igx-switch [required]="true"></igx-switch>
         * ```
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledBy` attribute.
         * If not set, the  value of `aria-labelledBy` will be equal to the value of `labelId` attribute.
         *
         * @example
         * ```html
         * <igx-switch aria-labelledby = "Label1"></igx-switch>
         * ```
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the value of the `aria-label` attribute.
         *
         * @example
         * ```html
         * <igx-switch aria-label="Label1"></igx-switch>
         * ```
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the switch state is changed.
         * Provides references to the `IgxSwitchComponent` and the `checked` property as event arguments.
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.change = new EventEmitter();
        /**
         * Returns the class of the switch component.
         *
         * @example
         * ```typescript
         * let switchClass = this.switch.cssClass;
         * ```
         */
        this.cssClass = 'igx-switch';
        /**
         * Sets/gets whether the switch is on or off.
         * Default value is 'false'.
         *
         * @example
         * ```html
         *  <igx-switch [checked]="true"></igx-switch>
         * ```
         */
        this.checked = false;
        /**
         * Sets/gets the `disabled` attribute.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-switch [disabled]="true"><igx-switch>
         * ```
         */
        this.disabled = false;
        /**
         * Sets/gets whether the switch component is on focus.
         * Default value is `false`.
         *
         * @example
         * ```typescript
         * this.switch.focused = true;
         * ```
         */
        this.focused = false;
        /**
         * @hidden
         * @internal
         */
        this.inputId = `${this.id}-input`;
        /**
         * @hidden
         * @internal
         */
        this._onTouchedCallback = noop;
        /**
         * @hidden
         * @internal
         */
        this._onChangeCallback = noop;
    }
    /**
     * @hidden
     * @internal
     */
    onKeyUp(event) {
        event.stopPropagation();
        this.focused = true;
    }
    /**
     * Toggles the checked state of the switch.
     *
     * @example
     * ```typescript
     * this.switch.toggle();
     * ```
     */
    toggle() {
        if (this.disabled) {
            return;
        }
        this.nativeCheckbox.nativeElement.focus();
        this.checked = !this.checked;
        this.change.emit({ checked: this.checked, switch: this });
        this._onChangeCallback(this.checked);
    }
    /**
     * @hidden
     * @internal
     */
    _onSwitchChange(event) {
        event.stopPropagation();
    }
    /**
     * @hidden
     * @internal
     */
    _onSwitchClick(event) {
        event.stopPropagation();
        this.toggle();
        if (isIE()) {
            this.nativeCheckbox.nativeElement.blur();
        }
    }
    /**
     * @hidden
     * @internal
     */
    onLabelClick() {
        this.toggle();
    }
    /**
     * @hidden
     * @internal
     */
    onBlur() {
        this.focused = false;
        this._onTouchedCallback();
    }
    /**
     * @hidden
     * @internal
     */
    writeValue(value) {
        this._value = value;
        this.checked = !!this._value;
    }
    /**
     * @hidden
     * @internal
     */
    getEditElement() {
        return this.nativeCheckbox.nativeElement;
    }
    /**
     * @hidden
     * @internal
     */
    get labelClass() {
        switch (this.labelPosition) {
            case SwitchLabelPosition.BEFORE:
                return `${this.cssClass}__label--before`;
            case SwitchLabelPosition.AFTER:
            default:
                return `${this.cssClass}__label`;
        }
    }
    /**
     * @hidden
     * @internal
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     * @internal
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
}
IgxSwitchComponent.decorators = [
    { type: Component, args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSwitchComponent, multi: true }],
                selector: 'igx-switch',
                template: "<input #checkbox class=\"igx-switch__input\" type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onSwitchChange($event)\"\n    (click)=\"_onSwitchClick($event)\"\n    (blur)=\"onBlur()\" />\n\n<label #label class =\"igx-switch__composite\" [for]=\"inputId\"\n    igxRipple\n    igxRippleTarget=\".igx-switch__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\">\n    <div class=\"igx-switch__composite-thumb\">\n        <div class=\"igx-switch__ripple\"></div>\n    </div>\n</label>\n\n<span #placeholderLabel\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"onLabelClick()\">\n    <ng-content></ng-content>\n</span>\n"
            },] }
];
IgxSwitchComponent.propDecorators = {
    nativeCheckbox: [{ type: ViewChild, args: ['checkbox', { static: true },] }],
    nativeLabel: [{ type: ViewChild, args: ['label', { static: true },] }],
    placeholderLabel: [{ type: ViewChild, args: ['placeholderLabel', { static: true },] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    labelId: [{ type: Input }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    tabindex: [{ type: Input }],
    labelPosition: [{ type: Input }],
    disableRipple: [{ type: Input }],
    required: [{ type: Input }],
    ariaLabelledBy: [{ type: Input, args: ['aria-labelledby',] }],
    ariaLabel: [{ type: Input, args: ['aria-label',] }],
    change: [{ type: Output }],
    cssClass: [{ type: HostBinding, args: ['class.igx-switch',] }],
    checked: [{ type: HostBinding, args: ['class.igx-switch--checked',] }, { type: Input }],
    disabled: [{ type: HostBinding, args: ['class.igx-switch--disabled',] }, { type: Input }],
    focused: [{ type: HostBinding, args: ['class.igx-switch--focused',] }],
    onKeyUp: [{ type: HostListener, args: ['keyup', ['$event'],] }]
};
const IGX_SWITCH_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => IgxSwitchRequiredDirective),
    multi: true
};
/* eslint-disable  @angular-eslint/directive-selector */
class IgxSwitchRequiredDirective extends CheckboxRequiredValidator {
}
IgxSwitchRequiredDirective.decorators = [
    { type: Directive, args: [{
                selector: `igx-switch[required][formControlName],
    igx-switch[required][formControl],
    igx-switch[required][ngModel]`,
                providers: [IGX_SWITCH_REQUIRED_VALIDATOR]
            },] }
];
/**
 * @hidden
 */
class IgxSwitchModule {
}
IgxSwitchModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                exports: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                imports: [IgxRippleModule]
            },] }
];

let NEXT_ID$r = 0;
class IgxTabTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxTabTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxTab]'
            },] }
];
IgxTabTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * **Ignite UI for Angular Tab Bar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tabbar)
 *
 * The Ignite UI Tab Bar enables the user to navigate among a number of content panels displayed in a single view.
 *
 * Example:
 * ```html
 * <igx-bottom-nav>
 *   <igx-tab-panel label="Tab 1">Tab 1 Content</igx-tab-panel>
 *   <igx-tab-panel label="Tab 2">Tab 2 Content</igx-tab-panel>
 *   <igx-tab-panel label="Tab 3">Tab 3 Content</igx-tab-panel>
 * </igx-bottom-nav>
 * ```
 */
class IgxBottomNavComponent {
    constructor() {
        /**
         * Emits an event when a new tab is selected.
         * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
         * ```html
         * <igx-bottom-nav (onTableSelected) = "onTabSelected($event)"><igx-bottom-nav>
         * ```
         *
         * @memberof IgxBottomNavComponent
         */
        this.onTabSelected = new EventEmitter();
        /**
         * Emits an event when a tab is deselected.
         * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
         * ```html
         * <igx-bottom-nav (onTabDeselected) = "onTabDeselected($event)"><igx-bottom-nav>
         * ```
         *
         * @memberof IgxBottomNavComponent
         */
        this.onTabDeselected = new EventEmitter();
        this._currentBottomNavId = NEXT_ID$r++;
        /**
         * Sets/gets the `id` of the tab bar.
         * If not set, the `id` of the first tab bar component will be `"igx-bottom-nav-0"`.
         * ```html
         * <igx-bottom-nav id = "my-first-tab-bar"></igx-bottom-nav>
         * ```
         * ```typescript
         * let tabBarId =  this.tabBar.id;
         * ```
         *
         * @memberof IgxBottomNavComponent
         */
        // eslint-disable-next-line @typescript-eslint/member-ordering
        this.id = `igx-bottom-nav-${this._currentBottomNavId}`;
        /**
         * Gets the `index` of selected tab/panel in the respective collection.
         * ```typescript
         * let index =  this.tabBar.selectedIndex;
         * ```
         *
         * @memberof IgxBottomNavComponent
         */
        // eslint-disable-next-line @typescript-eslint/member-ordering
        this.selectedIndex = -1;
        /**
         * @hidden
         */
        this._itemStyle = 'igx-bottom-nav';
    }
    /**
     * Gets the `IgxTabComponent` elements for this bottom navigation component.
     * First try to get them as content children if not available get them as view children.
     * ```typescript
     * let tabs: QueryList<IgxTabComponent> =  this.tabBar.tabs;
     * ```
     *
     * @memberof IgxBottomNavComponent
     */
    get tabs() {
        return this.hasContentTabs ? this.contentTabs : this.viewTabs;
    }
    /**
     * Gets the `itemStyle` of the tab bar.
     * ```typescript
     * let itemStyle =  this.tabBar.itemStyle;
     * ```
     *
     * @memberof IgxBottomNavComponent
     */
    get itemStyle() {
        return this._itemStyle;
    }
    /**
     * @hidden
     */
    get hasContentTabs() {
        return (this.contentTabs && this.contentTabs.length > 0);
    }
    /**
     * Gets the selected tab in the tab bar.
     * ```typescript
     * let tab =  this.tabBar.selectedTab;
     * ```
     *
     * @memberof IgxBottomNavComponent
     */
    get selectedTab() {
        if (this.tabs && this.selectedIndex !== undefined) {
            return this.tabs.toArray()[this.selectedIndex];
        }
    }
    /**
     * @hidden
     */
    selectedPanelHandler(args) {
        if (this.hasContentTabs) {
            this.selectedIndex = args.tab.index;
            this.contentTabs.forEach((t) => {
                if (t !== args.tab) {
                    this._deselectTab(t);
                }
            });
        }
        else {
            if (args.panel) {
                this.selectedIndex = args.panel.index;
                this.panels.forEach((p) => {
                    if (p.index !== this.selectedIndex) {
                        this._deselectPanel(p);
                    }
                });
            }
        }
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.setPanelsAttributes();
        this._panelsChanges$ = this.panels.changes.subscribe(() => {
            this.setPanelsAttributes();
        });
        // initial selection
        setTimeout(() => {
            if (this.selectedIndex === -1) {
                const selectablePanels = this.panels.filter((p) => !p.disabled);
                const panel = selectablePanels[0];
                if (panel) {
                    panel.select();
                }
            }
        }, 0);
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this._panelsChanges$) {
            this._panelsChanges$.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    getTabId(index) {
        return `igx-tab-${this._currentBottomNavId}-${index}`;
    }
    /**
     * @hidden
     */
    getTabPanelId(index) {
        return `igx-tab-panel-${this._currentBottomNavId}-${index}`;
    }
    setPanelsAttributes() {
        const panelsArray = Array.from(this.panels);
        for (let index = 0; index < this.panels.length; index++) {
            const tabPanels = panelsArray[index];
            tabPanels.nativeElement.setAttribute('id', this.getTabPanelId(index));
            tabPanels.nativeElement.setAttribute('aria-labelledby', this.getTabId(index));
        }
    }
    /**
     * @hidden
     */
    _deselectPanel(panel) {
        // Cannot deselect the selected tab - this will mean that there will be not selected tab left
        if (panel.disabled || this.selectedTab.index === panel.index) {
            return;
        }
        panel.isSelected = false;
        this.onTabDeselected.emit({ tab: this.tabs[panel.index], panel });
    }
    _deselectTab(aTab) {
        aTab.isSelected = false;
        this.onTabDeselected.emit({ tab: aTab, panel: null });
    }
}
IgxBottomNavComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-bottom-nav',
                template: "<div *ngIf=\"!hasContentTabs\">\n    <ng-content></ng-content>\n</div>\n<div #tablist class=\"{{itemStyle}}__menu {{itemStyle}}__menu--bottom\" role=\"tablist\" aria-orientation=\"horizontal\">\n    <ng-container *ngIf=\"!hasContentTabs\">\n        <igx-tab *ngFor=\"let panel of panels; let i = index\"\n            [relatedPanel]=\"panel\"\n            [autoGenerated]=\"true\"\n            [id]=\"getTabId(i)\"\n            [attr.aria-controls]=\"getTabPanelId(i)\">>\n        </igx-tab>\n    </ng-container>\n    <ng-content select=\"igx-tab\"></ng-content>\n</div>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            },] }
];
IgxBottomNavComponent.propDecorators = {
    viewTabs: [{ type: ViewChildren, args: [forwardRef(() => IgxTabComponent),] }],
    contentTabs: [{ type: ContentChildren, args: [forwardRef(() => IgxTabComponent),] }],
    panels: [{ type: ContentChildren, args: [forwardRef(() => IgxTabPanelComponent),] }],
    onTabSelected: [{ type: Output }],
    onTabDeselected: [{ type: Output }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    selectedPanelHandler: [{ type: HostListener, args: ['onTabSelected', ['$event'],] }]
};
// ================================= IgxTabPanelComponent ======================================
class IgxTabPanelComponent {
    constructor(_tabBar, _element) {
        this._tabBar = _tabBar;
        this._element = _element;
        /**
         * Gets the role of the tab panel.
         * ```typescript
         * let tabPanelRole = this.tabPanel.role;
         * ```
         *
         * @memberof IgxTabPanelComponent
         */
        this.role = 'tabpanel';
        /**
         * @hidden
         */
        this._itemStyle = 'igx-tab-panel';
        /**
         * @hidden
         */
        this._isSelected = false;
    }
    /**
     * Gets whether a tab panel will have `igx-bottom-nav__panel` class.
     * ```typescript
     * let styleClass = this.tabPanel.styleClass;
     * ```
     *
     * @memberof IgxTabPanelComponent
     */
    get styleClass() {
        return (!this.isSelected);
    }
    /**
     * Sets/gets whether a tab panel is selected.
     * ```typescript
     * this.tabPanel.isSelected = true;
     * ```
     * ```typescript
     * let isSelected =  this.tabPanel.isSelected;
     * ```
     *
     * @memberof IgxTabPanelComponent
     */
    get isSelected() {
        return this._isSelected;
    }
    set isSelected(newValue) {
        if (this._isSelected !== newValue) {
            if (newValue) {
                this.select();
            }
            else {
                this._isSelected = newValue;
            }
        }
    }
    /**
     * Gets the `itemStyle` of the tab panel.
     * ```typescript
     * let itemStyle = this.tabPanel.itemStyle;
     * ```
     *
     * @memberof IgxTabPanelComponent
     */
    get itemStyle() {
        return this._itemStyle;
    }
    /**
     * Returns the native element of the tab-panel component
     * ```typescript
     *  const mytabPanelElement: HTMLElement = tabPanel.nativeElement;
     * ```
     */
    get nativeElement() {
        return this._element.nativeElement;
    }
    /**
     * Gets the tab associated with the panel.
     * ```typescript
     * let tab = this.tabPanel.relatedTab;
     * ```
     *
     * @memberof IgxTabPanelComponent
     */
    get relatedTab() {
        if (this._tabBar.tabs) {
            return this._tabBar.tabs.toArray()[this.index];
        }
    }
    /**
     * Gets the changes and updates accordingly applied to the tab/panel.
     *
     * @memberof IgxTabComponent
     */
    get changesCount() {
        return this.relatedTab ? this.relatedTab.changesCount : 0;
    }
    /**
     * Gets the index of a panel in the panels collection.
     * ```typescript
     * let panelIndex =  this.tabPanel.index
     * ```
     *
     * @memberof IgxTabPanelComponent
     */
    get index() {
        if (this._tabBar.panels) {
            return this._tabBar.panels.toArray().indexOf(this);
        }
    }
    /**
     * Gets the tab template.
     * ```typescript
     * let tabTemplate = this.tabPanel.customTabTemplate
     * ```
     *
     * @memberof IgxTabPanelComponent
     */
    get customTabTemplate() {
        return this._tabTemplate;
    }
    /**
     * Sets the tab template.
     * ```typescript
     * this.tabPanel.customTabTemplate(tabTemplate);
     * ```
     *
     * @memberof IgxTabPanelComponent
     */
    set customTabTemplate(template) {
        this._tabTemplate = template;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.tabTemplate) {
            this._tabTemplate = this.tabTemplate.template;
        }
    }
    /**
     * Selects the current tab and the tab panel.
     * ```typescript
     * this.tabPanel.select();
     * ```
     *
     * @memberof IgxTabPanelComponent
     */
    select() {
        if (this.disabled || this._tabBar.selectedIndex === this.index) {
            return;
        }
        this._isSelected = true;
        this._tabBar.onTabSelected.emit({ tab: this._tabBar.tabs.toArray()[this.index], panel: this });
    }
}
IgxTabPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-tab-panel',
                template: "<ng-content></ng-content>\n"
            },] }
];
IgxTabPanelComponent.ctorParameters = () => [
    { type: IgxBottomNavComponent },
    { type: ElementRef }
];
IgxTabPanelComponent.propDecorators = {
    label: [{ type: Input }],
    icon: [{ type: Input }],
    disabled: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    styleClass: [{ type: HostBinding, args: ['class.igx-bottom-nav__panel',] }],
    isSelected: [{ type: HostBinding, args: ['class.igx-bottom-nav__panel--selected',] }],
    tabTemplate: [{ type: ContentChild, args: [IgxTabTemplateDirective, { read: IgxTabTemplateDirective },] }]
};
// ======================================= IgxTabComponent ==========================================
class IgxTabComponent {
    constructor(_tabBar, _element) {
        this._tabBar = _tabBar;
        this._element = _element;
        /**
         * Gets the `role` attribute.
         * ```typescript
         * let tabRole = this.tab.role;
         * ```
         *
         * @memberof IgxTabComponent
         */
        this.role = 'tab';
        /**
         * @hidden @internal
         */
        this.ariaLabel = this.label;
        /**
         * @hidden @internal
         */
        this.ariaDisabled = this.disabled;
        /**
         * @hidden @internal
         */
        this.ariaSelected = this.isSelected;
        /**
         * @hidden
         */
        this._changesCount = 0; // changes and updates accordingly applied to the tab.
        this._disabled = false;
        this._selected = false;
    }
    /**
     * Sets/gets the `label` of the tab panel.
     * ```html
     * <igx-tab [label] = "'Tab label'"><igx-tab>
     * ```
     * ```typescript
     * let tabLabel = this.tab.label;
     * ```
     *
     * @memberof IgxTabComponent
     */
    get label() {
        return this.relatedPanel ? this.relatedPanel.label : this._label;
    }
    set label(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.label = newValue;
        }
        this._label = newValue;
    }
    /**
     * Sets/gets  the `icon` of the tab panel.
     * ```html
     * <igx-tab [icon] = "tab_icon"><igx-tab>
     * ```
     * ```typescript
     * let tabIcon =  this.tab.icon;
     * ```
     *
     * @memberof IgxTabComponent
     */
    get icon() {
        return this.relatedPanel ? this.relatedPanel.icon : this._icon;
    }
    set icon(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.icon = newValue;
        }
        this._icon = newValue;
    }
    /**
     * Gets the changes and updates accordingly applied to the tab.
     *
     * @memberof IgxTabComponent
     */
    get changesCount() {
        return this._changesCount;
    }
    /**
     * Gets whether the tab is disabled.
     * ```typescript
     * let isDisabled = this.tab.disabled;
     * ```
     *
     * @memberof IgxTabComponent
     */
    get disabled() {
        return this.relatedPanel ? this.relatedPanel.disabled : this._disabled;
    }
    set disabled(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.disabled = newValue;
        }
        else {
            this._disabled = newValue;
        }
    }
    /**
     * Gets whether the tab is selected.
     * ```typescript
     * let isSelected  = this.tab.isSelected;
     * ```
     *
     * @memberof IgxTabComponent
     */
    set isSelected(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.isSelected = newValue;
        }
        else if (this._selected !== newValue) {
            this._selected = newValue;
            if (this._selected) {
                this._tabBar.onTabSelected.emit({ tab: this, panel: null });
            }
        }
    }
    get isSelected() {
        return this.relatedPanel ? this.relatedPanel.isSelected : this._selected;
    }
    get cssClassSelected() {
        return this.isSelected;
    }
    get cssClassDisabled() {
        return this.disabled;
    }
    get cssClass() {
        return (!this.disabled && !this.isSelected);
    }
    /**
     * Gets the `index` of the tab.
     * ```typescript
     * let tabIndex = this.tab.index;
     * ```
     *
     * @memberof IgxTabComponent
     */
    get index() {
        if (this._tabBar.tabs) {
            return this._tabBar.tabs.toArray().indexOf(this);
        }
    }
    /**
     * Returns the `template` for this IgxTabComponent.
     * ```typescript
     * let tabItemTemplate = this.tabItem.template;
     * ```
     *
     * @memberof IgxTabComponent
     */
    get template() {
        if (this.relatedPanel && this.relatedPanel.customTabTemplate) {
            return this.relatedPanel.customTabTemplate;
        }
        if (this.customTabTemplateDir) {
            return this.customTabTemplateDir.template;
        }
        return this.defaultTabTemplate;
    }
    /**
     * Returns the `context` object for the template of this `IgxTabComponent`.
     * ```typescript
     * let tabItemContext = this.tabItem.context;
     * ```
     */
    get context() {
        return this.relatedPanel ? this.relatedPanel : this;
    }
    /**
     * @hidden
     */
    onClick() {
        if (this.autoGenerated) {
            this.select();
        }
    }
    /**
     * Selects the current tab and the associated panel.
     * ```typescript
     * this.tab.select();
     * ```
     *
     * @memberof IgxTabComponent
     */
    select() {
        if (this.relatedPanel) {
            this.relatedPanel.select();
        }
        else {
            this._selected = true;
            this._tabBar.onTabSelected.emit({ tab: this, panel: null });
        }
    }
    elementRef() {
        return this._element;
    }
}
IgxTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-tab',
                template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"tab-icon\">\n        <igx-icon>{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"context.changesCount\" [hidden]=\"context.changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"tab-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>\n"
            },] }
];
IgxTabComponent.ctorParameters = () => [
    { type: IgxBottomNavComponent },
    { type: ElementRef }
];
IgxTabComponent.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.role',] }],
    ariaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],
    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],
    ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
    relatedPanel: [{ type: Input }],
    autoGenerated: [{ type: Input }],
    defaultTabTemplate: [{ type: ViewChild, args: ['defaultTabTemplate', { read: TemplateRef, static: true },] }],
    customTabTemplateDir: [{ type: ContentChild, args: [IgxTabTemplateDirective, { read: IgxTabTemplateDirective },] }],
    label: [{ type: Input }],
    icon: [{ type: Input }],
    disabled: [{ type: Input }],
    isSelected: [{ type: Input }],
    cssClassSelected: [{ type: HostBinding, args: ['class.igx-bottom-nav__menu-item--selected',] }],
    cssClassDisabled: [{ type: HostBinding, args: ['class.igx-bottom-nav__menu-item--disabled',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-bottom-nav__menu-item',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
/**
 * @hidden
 */
class IgxBottomNavModule {
}
IgxBottomNavModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                exports: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                imports: [CommonModule, IgxBadgeModule, IgxIconModule]
            },] }
];

/** @hidden */
class IgxTabsBase {
}
/** @hidden */
class IgxTabItemBase {
    get index() {
        return 0;
    }
    select() { }
}
/** @hidden */
class IgxTabsGroupBase {
}

var TabScrollButtonStyle;
(function (TabScrollButtonStyle) {
    TabScrollButtonStyle["Visible"] = "visible";
    TabScrollButtonStyle["Hidden"] = "hidden";
    TabScrollButtonStyle["NotDisplayed"] = "not_displayed";
})(TabScrollButtonStyle || (TabScrollButtonStyle = {}));
class IgxRightButtonStyleDirective {
    constructor(tabs) {
        this.tabs = tabs;
    }
    get visibleCSS() {
        return (this.getRightButtonStyle() === TabScrollButtonStyle.Visible) ? true : false;
    }
    get hiddenCSS() {
        return (this.getRightButtonStyle() === TabScrollButtonStyle.Hidden) ? true : false;
    }
    get notDisplayedCSS() {
        return (this.getRightButtonStyle() === TabScrollButtonStyle.NotDisplayed) ? true : false;
    }
    getRightButtonStyle() {
        const viewPortWidth = this.tabs.viewPort.nativeElement.offsetWidth;
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
        }
        const headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
        const offset = this.tabs.offset;
        const total = offset + viewPortWidth;
        // Fix for IE 11, a difference is accumulated from the widths calculations.
        if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
            return TabScrollButtonStyle.NotDisplayed;
        }
        if (itemsContainerWidth > total) {
            return TabScrollButtonStyle.Visible;
        }
        else {
            return TabScrollButtonStyle.Hidden;
        }
    }
}
IgxRightButtonStyleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxRightButtonStyle]'
            },] }
];
IgxRightButtonStyleDirective.ctorParameters = () => [
    { type: IgxTabsBase }
];
IgxRightButtonStyleDirective.propDecorators = {
    visibleCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button',] }],
    hiddenCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--hidden',] }],
    notDisplayedCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--none',] }]
};
class IgxLeftButtonStyleDirective {
    constructor(tabs) {
        this.tabs = tabs;
    }
    get visibleCSS() {
        return (this.getLeftButtonStyle() === TabScrollButtonStyle.Visible) ? true : false;
    }
    get hiddenCSS() {
        return (this.getLeftButtonStyle() === TabScrollButtonStyle.Hidden) ? true : false;
    }
    get notDisplayedCSS() {
        return (this.getLeftButtonStyle() === TabScrollButtonStyle.NotDisplayed) ? true : false;
    }
    getLeftButtonStyle() {
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
        }
        const headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
        const offset = this.tabs.offset;
        if (offset === 0) {
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1) {
                return TabScrollButtonStyle.NotDisplayed;
            }
            return TabScrollButtonStyle.Hidden;
        }
        else {
            return TabScrollButtonStyle.Visible;
        }
    }
}
IgxLeftButtonStyleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxLeftButtonStyle]'
            },] }
];
IgxLeftButtonStyleDirective.ctorParameters = () => [
    { type: IgxTabsBase }
];
IgxLeftButtonStyleDirective.propDecorators = {
    visibleCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button',] }],
    hiddenCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--hidden',] }],
    notDisplayedCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--none',] }]
};
class IgxTabItemTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxTabItemTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxTab]'
            },] }
];
IgxTabItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

class IgxTabItemComponent extends IgxTabItemBase {
    constructor(_tabs, _element, _ngZone) {
        super();
        this._tabs = _tabs;
        this._element = _element;
        this._ngZone = _ngZone;
        /**
         * @hidden @internal
         */
        this.role = 'tab';
        /**
         * @hidden @internal
         */
        this.tabindex = -1;
        /**
         * @hidden @internal
         */
        this.ariaLabel = this.label;
        /**
         * @hidden @internal
         */
        this.ariaDisabled = this.disabled;
        /**
         * @hidden @internal
         */
        this.ariaSelected = this.isSelected;
        this._changesCount = 0; // changes and updates accordingly applied to the tab.
        this._isSelected = false;
        this._disabled = false;
        this._nativeTabItem = _element;
    }
    /**
     * An @Input property that sets the value of the `icon`.
     * The value should be valid icon name from {@link https://material.io/tools/icons/?style=baseline}.
     * ```html
     * <igx-tab-item label="Tab 1" icon="home">
     * ```
     */
    get icon() {
        return this.relatedGroup ? this.relatedGroup.icon : this._icon;
    }
    set icon(newValue) {
        if (this.relatedGroup) {
            this.relatedGroup.icon = newValue;
        }
        this._icon = newValue;
    }
    /**
     * An @Input property that sets the value of the `label`.
     * ```html
     * <igx-tabs-item label="Tab 2" icon="folder">
     * ```
     */
    get label() {
        return this.relatedGroup ? this.relatedGroup.label : this._label;
    }
    set label(newValue) {
        if (this.relatedGroup) {
            this.relatedGroup.label = newValue;
        }
        this._label = newValue;
    }
    get provideCssClassSelected() {
        return this.isSelected;
    }
    get provideCssClassDisabled() {
        return this.disabled;
    }
    get provideCssClass() {
        return (!this.disabled && !this.isSelected);
    }
    /**
     * @hidden
     */
    onClick() {
        if (this.autoGenerated) {
            this.select();
        }
    }
    /**
     * @hidden
     */
    onKeydown(event) {
        const tabsArray = this._tabs.tabs.toArray();
        const startIndex = tabsArray.indexOf(this);
        let finalIndex = -1;
        let currentIndex = startIndex;
        switch (event.key) {
            case "ArrowRight" /* RIGHT_ARROW */:
            case "Right" /* RIGHT_ARROW_IE */:
                do {
                    currentIndex++;
                    if (currentIndex === tabsArray.length) {
                        currentIndex = -1;
                        continue;
                    }
                    else if (tabsArray[currentIndex].disabled === false) {
                        finalIndex = currentIndex;
                        break;
                    }
                } while (currentIndex !== startIndex);
                break;
            case "ArrowLeft" /* LEFT_ARROW */:
            case "Left" /* LEFT_ARROW_IE */:
                do {
                    currentIndex--;
                    if (currentIndex === -1) {
                        currentIndex = tabsArray.length;
                        continue;
                    }
                    else if (tabsArray[currentIndex].disabled === false) {
                        finalIndex = currentIndex;
                        break;
                    }
                } while (currentIndex !== startIndex);
                break;
            case "Home" /* HOME */:
                event.preventDefault();
                finalIndex = tabsArray.find(t => t.disabled === false).index;
                break;
            case "End" /* END */:
                event.preventDefault();
                finalIndex = tabsArray.slice().reverse().find(t => t.disabled === false).index;
                break;
            case "Enter" /* ENTER */:
                if (!this.autoGenerated) {
                    this.nativeTabItem.nativeElement.click();
                }
                break;
            case " " /* SPACE */:
            case "Spacebar" /* SPACE_IE */:
                event.preventDefault();
                if (!this.autoGenerated) {
                    this.nativeTabItem.nativeElement.click();
                }
                break;
            default:
                break;
        }
        if (finalIndex > -1) {
            const tab = tabsArray[finalIndex];
            tab.nativeTabItem.nativeElement.focus();
            if (this.autoGenerated) {
                tab.select();
            }
        }
    }
    ngAfterViewInit() {
        this._ngZone.runOutsideAngular(() => {
            this._resizeObserver = new ResizeObserver(() => {
                this._tabs.transformIndicatorAnimation(this._nativeTabItem.nativeElement, 0);
            });
        });
    }
    ngOnDestroy() {
        this._ngZone.runOutsideAngular(() => {
            this._resizeObserver.disconnect();
        });
    }
    /**
     * @hidden
     */
    get changesCount() {
        return this._changesCount;
    }
    /**
     * @hidden
     */
    get nativeTabItem() {
        return this._nativeTabItem;
    }
    /**
     * 	Gets whether the tab is disabled.
     * ```
     * const disabledItem = this.myTabComponent.tabs.first.disabled;
     * ```
     */
    get disabled() {
        return this.relatedGroup ? this.relatedGroup.disabled : this._disabled;
    }
    set disabled(newValue) {
        if (this.relatedGroup) {
            this.relatedGroup.disabled = newValue;
        }
        else {
            this._disabled = newValue;
        }
    }
    /**
     * Gets whether the tab is selected.
     * ```typescript
     * const selectedItem = this.myTabComponent.tabs.first.isSelected;
     * ```
     */
    get isSelected() {
        return this.relatedGroup ? this.relatedGroup.isSelected : this._isSelected;
    }
    set isSelected(newValue) {
        if (!this.disabled && this.isSelected !== newValue) {
            this._tabs.performSelectionChange(newValue ? this : null);
        }
    }
    /**
     * @hidden
     */
    select() {
        if (!this.disabled && !this.isSelected) {
            this._tabs.performSelectionChange(this);
        }
    }
    /**
     * @hidden
     */
    get index() {
        if (this._tabs.tabs) {
            return this._tabs.tabs.toArray().indexOf(this);
        }
        return -1;
    }
    /**
     * @hidden
     */
    setSelectedInternal(newValue) {
        this._isSelected = newValue;
        this._ngZone.runOutsideAngular(() => {
            if (this._resizeObserver) {
                if (this._isSelected) {
                    this._resizeObserver.observe(this._element.nativeElement);
                }
                else {
                    this._resizeObserver.disconnect();
                }
            }
        });
        this.tabindex = newValue ? 0 : -1;
    }
    /**
     * @hidden
     */
    get template() {
        if (this.relatedGroup && this.relatedGroup.customTabTemplate) {
            return this.relatedGroup.customTabTemplate;
        }
        if (this.customTabTemplateDir) {
            return this.customTabTemplateDir.template;
        }
        return this.defaultTabTemplate;
    }
    /**
     * @hidden
     */
    get context() {
        return this.relatedGroup ? this.relatedGroup : this;
    }
}
IgxTabItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-tab-item',
                template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"igx-tabs__header-menu-item-icon\">\n        <igx-icon>{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"changesCount\" [hidden]=\"changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"igx-tabs__item-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>\n"
            },] }
];
IgxTabItemComponent.ctorParameters = () => [
    { type: IgxTabsBase },
    { type: ElementRef },
    { type: NgZone }
];
IgxTabItemComponent.propDecorators = {
    autoGenerated: [{ type: Input }],
    relatedGroup: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    ariaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],
    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],
    ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
    defaultTabTemplate: [{ type: ViewChild, args: ['defaultTabTemplate', { read: TemplateRef, static: true },] }],
    customTabTemplateDir: [{ type: ContentChild, args: [IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective },] }],
    icon: [{ type: Input }],
    label: [{ type: Input }],
    provideCssClassSelected: [{ type: HostBinding, args: ['class.igx-tabs__header-menu-item--selected',] }],
    provideCssClassDisabled: [{ type: HostBinding, args: ['class.igx-tabs__header-menu-item--disabled',] }],
    provideCssClass: [{ type: HostBinding, args: ['class.igx-tabs__header-menu-item',] }],
    onClick: [{ type: HostListener, args: ['click',] }],
    onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    disabled: [{ type: Input }],
    isSelected: [{ type: Input }]
};

class IgxTabsGroupComponent extends IgxTabsGroupBase {
    constructor(_tabs, _element) {
        super();
        this._tabs = _tabs;
        this._element = _element;
        /**
         * An @Input property that allows you to enable/disable the `IgxTabGroupComponent`.
         * ```html
         * <igx-tabs-group label="Tab 2  Lorem ipsum dolor sit" icon="home" [disabled]="true">
         * ```
         */
        this.disabled = false;
        /**
         * @hidden
         */
        this.role = 'tabpanel';
        /**
         * @hidden
         */
        this.styleClass = true;
        this._isSelected = false;
    }
    /**
     * Sets/gets whether a tab group is selected.
     * ```typescript
     * this.tabGroup.isSelected = true;
     * ```
     * ```typescript
     * let isSelected = this.tabGroup.isSelected;
     * ```
     *
     * @memberof IgxTabsGroupComponent
     */
    get isSelected() {
        return this._isSelected;
    }
    set isSelected(newValue) {
        if (!this.disabled && this.isSelected !== newValue) {
            this._tabs.performSelectionChange(newValue ? this.relatedTab : null);
        }
    }
    /**
     * Returns the native element of the tabs-group component
     * ```typescript
     *  const mytabsGroupElement: HTMLElement = tabsGroup.nativeElement;
     * ```
     */
    get nativeElement() {
        return this._element.nativeElement;
    }
    /**
     * An accessor that returns the `IgxTabItemComponent` component.
     * ```typescript
     * @ViewChild("MyTabsGroup")
     * public tab: IgxTabsGroupComponent;
     * ngAfterViewInIt(){
     *    let tabComponent = this.tab.relatedTab;
     * }
     * ```
     */
    get relatedTab() {
        if (this._tabs.tabs) {
            return this._tabs.tabs.toArray()[this.index];
        }
    }
    /**
     * An accessor that returns the value of the index of the `IgxTabsGroupComponent`.
     * ```typescript
     * @ViewChild("MyTabsGroup")
     * public tab: IgxTabsGroupComponent;
     * ngAfterViewInIt(){
     *    let tabIndex = this.tab.index;
     * }
     * ```
     */
    get index() {
        if (this._tabs.groups) {
            return this._tabs.groups.toArray().indexOf(this);
        }
        return -1;
    }
    /**
     * @hidden
     */
    get customTabTemplate() {
        return this._tabTemplate;
    }
    /**
     * @hidden
     */
    set customTabTemplate(template) {
        this._tabTemplate = template;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.tabTemplate) {
            this._tabTemplate = this.tabTemplate.template;
        }
    }
    /**
     * A method that sets the focus on a tab.
     *
     * @memberof {@link IgxTabsGroupComponent}
     * ```typescript
     *  @ViewChild("MyChild")
     * public tab : IgxTabsGroupComponent;
     * ngAfterViewInit(){
     *     this.tab.select();
     * }
     * ```
     */
    select() {
        if (!this.disabled && !this.isSelected) {
            this._tabs.performSelectionChange(this.relatedTab);
        }
    }
    /**
     * @hidden
     */
    setSelectedInternal(newValue) {
        this._isSelected = newValue;
    }
}
IgxTabsGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-tabs-group',
                template: "<ng-content *ngIf=\"isSelected\"></ng-content>\n"
            },] }
];
IgxTabsGroupComponent.ctorParameters = () => [
    { type: IgxTabsBase },
    { type: ElementRef }
];
IgxTabsGroupComponent.propDecorators = {
    disabled: [{ type: Input }],
    icon: [{ type: Input }],
    label: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    styleClass: [{ type: HostBinding, args: ['class.igx-tabs__group',] }],
    tabTemplate: [{ type: ContentChild, args: [IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective },] }]
};

const IgxTabsType = mkenum({
    FIXED: 'fixed',
    CONTENTFIT: 'contentfit'
});
let NEXT_TABS_ID = 0;
class IgxTabsComponent {
    constructor(_ngZone, platformUtil) {
        this._ngZone = _ngZone;
        this.platformUtil = platformUtil;
        /**
         * @hidden
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
         * By default the header sizing mode is `contentfit`.
         * ```html
         * <igx-tabs type="fixed">
         *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
         * </igx-tabs>
         * ```
         */
        this.type = 'contentfit';
        /**
         * @hidden
         */
        this.class = '';
        /**
         * Emitted when a tab item is deselected.
         * ```html
         * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemDeselected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.tabItemDeselected = new EventEmitter();
        /**
         * Emitted when a tab item is selected.
         * ```html
         * <igx-tabs (tabItemSelected)="itemSelected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemSelected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.tabItemSelected = new EventEmitter();
        /**
         * Enables/disables the transition animation of the tabs' content. Set to `false` by default.
         * ````html
         * <igx-tabs [disableAnimation]="true"></igx-tabs>
         */
        this.disableAnimation = false;
        this._currentTabsId = NEXT_TABS_ID++;
        /**
         * Sets/gets the `id` of the tabs.
         *
         * @remarks
         * If not set, the `id` will have value `"igx-tabs-0"`.
         *
         * @example
         * ```html
         * <igx-tabs id="my-first-tabs"></igx-tabs>
         * ```
         * @memberof IgxTabsComponent
         */
        // eslint-disable-next-line @typescript-eslint/member-ordering
        this.id = `igx-tabs-${this._currentTabsId}`;
        /**
         * @hidden
         */
        // eslint-disable-next-line @typescript-eslint/member-ordering
        this.offset = 0;
        this._selectedIndex = -1;
    }
    /**
     * An @Input property that sets the value of the `selectedIndex`.
     * Default value is 0.
     * ```html
     * <igx-tabs selectedIndex="1">
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-tabs [(selectedIndex)]="model.selectedIndex">
     * ```
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    set selectedIndex(index) {
        const newIndex = typeof index !== 'number' ? parseInt(index, 10) : index;
        if (this._selectedIndex !== newIndex) {
            if (this.tabs && this.tabs.length > 0) {
                const newTab = this.tabs.toArray()[newIndex];
                if (newTab) {
                    this.performSelectionChange(newTab);
                }
            }
            else {
                this._selectedIndex = newIndex;
            }
        }
    }
    /**
     * Provides an observable collection of all `IgxTabItemComponent`s.
     * First try to get them as content children if not available get them as view children.
     * ```typescript
     * const tabItems = this.myTabComponent.tabs;
     * ```
     */
    get tabs() {
        if (this.hasContentTabs) {
            return this.contentTabs;
        }
        return this.viewTabs;
    }
    /**
     * @hidden
     */
    get hasContentTabs() {
        return (this.contentTabs && this.contentTabs.length > 0);
    }
    /**
     * @hidden
     */
    get cssClass() {
        const defaultStyle = `igx-tabs`;
        const fixedStyle = `igx-tabs--fixed`;
        const iconStyle = `igx-tabs--icons`;
        const iconLabelFoundInGroups = this.groups.find((group) => group.icon != null && group.label != null);
        const iconLabelFoundInTabs = this.contentTabs.find((tab) => tab.icon != null && tab.label != null);
        let css;
        switch (IgxTabsType[this.type.toUpperCase()]) {
            case IgxTabsType.FIXED: {
                css = fixedStyle;
                break;
            }
            default: {
                css = defaultStyle;
                break;
            }
        }
        // Layout fix for items with icons
        if (iconLabelFoundInGroups !== undefined || iconLabelFoundInTabs !== undefined) {
            css = `${css} ${iconStyle}`;
        }
        return `${css} ${this.class}`;
    }
    /**
     * @hidden
     */
    scrollLeft() {
        this.scroll(false);
    }
    /**
     * @hidden
     */
    scrollRight() {
        this.scroll(true);
    }
    /**
     * @hidden
     */
    scrollElement(element, scrollRight) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollRight) ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
        this.itemsContainer.nativeElement.style.transform = `translate(${-this.offset}px)`;
    }
    /**
     * Gets the selected `IgxTabItemComponent`.
     * ```
     * const selectedItem = this.myTabComponent.selectedTabItem;
     * ```
     */
    get selectedTabItem() {
        if (this.tabs && this.selectedIndex !== undefined) {
            return this.tabs.toArray()[this.selectedIndex];
        }
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        if (this._selectedIndex === -1) {
            this.tabs.forEach((t) => {
                if (t.isSelected) {
                    this._selectedIndex = t.index;
                }
            });
        }
        if (!this.hasContentTabs && (this.selectedIndex < 0 || this.selectedIndex >= this.groups.length)) {
            this._selectedIndex = 0;
        }
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(() => {
                const newTab = this.tabs.toArray()[this._selectedIndex];
                if (newTab) {
                    this.performSelection(newTab);
                }
                else {
                    this.hideIndicator();
                }
            });
            this._ngZone.runOutsideAngular(() => {
                this._resizeObserver = new ResizeObserver(() => {
                    if (!this.hasContentTabs && this._selectedIndex >= 0 && this._selectedIndex < this.tabs.length) {
                        const newTab = this.tabs.toArray()[this._selectedIndex];
                        this.transformContentAnimation(newTab, 0);
                    }
                });
                this._resizeObserver.observe(this.tabsContainer.nativeElement);
            });
        }
        this.setGroupsAttributes();
        this._groupChanges$ = this.groups.changes.subscribe(() => {
            this.setGroupsAttributes();
            this.resetSelectionOnCollectionChanged();
        });
    }
    /**
     * @hidden
     */
    performSelectionChange(newTab) {
        const oldTab = this.selectedTabItem;
        if (oldTab) {
            this.performDeselection(oldTab);
        }
        if (newTab) {
            this.performSelection(newTab);
        }
        else {
            // if there is no new selected tab hide the selection indicator
            this.hideIndicator();
        }
        this.selectedIndexChange.emit(this._selectedIndex);
    }
    /**
     * @hidden
     */
    getTabItemId(index) {
        return `igx-tab-item-${this._currentTabsId}-${index}`;
    }
    /**
     * @hidden
     */
    getTabsGroupId(index) {
        return `igx-tabs-group-${this._currentTabsId}-${index}`;
    }
    /**
     * @hidden
     */
    // animation for the new panel/group (not needed for tab only mode)
    transformContentAnimation(tab, duration) {
        const contentOffset = this.tabsContainer.nativeElement.offsetWidth * tab.index;
        this.contentsContainer.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
        this.contentsContainer.nativeElement.style.transform = `translate(${-contentOffset}px)`;
    }
    /**
     * @hidden
     */
    transformIndicatorAnimation(element, duration = 0.3) {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
            this.selectedIndicator.nativeElement.style.width = `${element.offsetWidth}px`;
            this.selectedIndicator.nativeElement.style.transform = `translate(${element.offsetLeft}px)`;
        }
    }
    hideIndicator() {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this._groupChanges$) {
            this._groupChanges$.unsubscribe();
        }
        if (this._resizeObserver) {
            this._ngZone.runOutsideAngular(() => {
                this._resizeObserver.disconnect();
            });
        }
    }
    setGroupsAttributes() {
        const groupsArray = Array.from(this.groups);
        for (let index = 0; index < this.groups.length; index++) {
            const tabsGroup = groupsArray[index];
            tabsGroup.nativeElement.setAttribute('id', this.getTabsGroupId(index));
            tabsGroup.nativeElement.setAttribute('aria-labelledby', this.getTabItemId(index));
        }
    }
    resetSelectionOnCollectionChanged() {
        requestAnimationFrame(() => {
            const currentTab = this.tabs.toArray()[this.selectedIndex];
            if (currentTab) {
                this.performSelectionChange(currentTab);
            }
            else if (this.selectedIndex >= this.tabs.length) {
                this.performSelectionChange(this.tabs.last);
            }
            else {
                this.hideIndicator();
            }
        });
    }
    scroll(scrollRight) {
        const tabsArray = this.tabs.toArray();
        for (const tab of tabsArray) {
            const element = tab.nativeTabItem.nativeElement;
            if (scrollRight) {
                if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
            else {
                if (element.offsetWidth + element.offsetLeft >= this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
        }
    }
    performDeselection(oldTab) {
        oldTab.setSelectedInternal(false);
        const oldTabRelatedGroup = this.groups.toArray()[oldTab.index];
        if (oldTabRelatedGroup) {
            oldTabRelatedGroup.setSelectedInternal(false);
        }
        this._selectedIndex = -1;
        this.tabItemDeselected.emit({ tab: oldTab, group: oldTabRelatedGroup });
    }
    performSelection(newTab) {
        newTab.setSelectedInternal(true);
        this._selectedIndex = newTab.index;
        let newTabRelatedGroup = null;
        if (!this.hasContentTabs && this.groups) {
            newTabRelatedGroup = this.groups.toArray()[newTab.index];
            if (newTabRelatedGroup) {
                newTabRelatedGroup.setSelectedInternal(true);
            }
        }
        this.tabItemSelected.emit({ tab: newTab, group: newTabRelatedGroup });
        requestAnimationFrame(() => {
            const transitionDuration = this.disableAnimation ? 0 : 0.2;
            // bring the new selected tab into view if it is not
            this.bringNewTabIntoView(newTab);
            // animate the new selection indicator
            this.transformIndicatorAnimation(newTab.nativeTabItem.nativeElement);
            // animate the new tab's group content
            if (!this.hasContentTabs) {
                this.transformContentAnimation(newTab, transitionDuration);
            }
        });
    }
    bringNewTabIntoView(newTab) {
        const tabNativeElement = newTab.nativeTabItem.nativeElement;
        // Scroll left if there is need
        if (tabNativeElement.offsetLeft < this.offset) {
            this.scrollElement(tabNativeElement, false);
        }
        // Scroll right if there is need
        const viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
        const delta = (tabNativeElement.offsetLeft + tabNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
        // Fix for IE 11, a difference is accumulated from the widths calculations
        if (delta > 1) {
            this.scrollElement(tabNativeElement, true);
        }
    }
}
IgxTabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-tabs',
                template: "<!-- TODO Remove tab container from here -->\n<div #tabsContainer>\n    <div class=\"igx-tabs__header\" #headerContainer>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollLeft()\" igxLeftButtonStyle>\n            <igx-icon>navigate_before</igx-icon>\n        </button>\n        <div class=\"igx-tabs__header-wrapper-fixed\" #viewPort>\n            <div #itemsContainer class=\"igx-tabs__header-wrapper-fluid\">\n                <ng-container *ngIf=\"!hasContentTabs\">\n                    <igx-tab-item igxRipple\n                        *ngFor=\"let group of groups; let i = index\"\n                        [relatedGroup]=\"group\"\n                        [autoGenerated]=\"true\"\n                        [id]=\"getTabItemId(i)\"\n                        [attr.aria-controls]=\"getTabsGroupId(i)\">\n                    </igx-tab-item>\n                </ng-container>\n                <ng-content select=\"igx-tab-item\"></ng-content>\n                <div #selectedIndicator *ngIf=\"groups.length > 0 || contentTabs.length > 0\" class=\"igx-tabs__header-menu-item-indicator\"></div>\n            </div>\n        </div>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollRight()\" igxRightButtonStyle>\n            <igx-icon>navigate_next</igx-icon>\n        </button>\n    </div>\n    <div class=\"igx-tabs__content-fixed\">\n        <div #contentsContainer class=\"igx-tabs__content-fluid\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</div>\n",
                providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }]
            },] }
];
IgxTabsComponent.ctorParameters = () => [
    { type: NgZone },
    { type: PlatformUtil }
];
IgxTabsComponent.propDecorators = {
    groups: [{ type: ContentChildren, args: [forwardRef(() => IgxTabsGroupComponent),] }],
    contentTabs: [{ type: ContentChildren, args: [forwardRef(() => IgxTabItemComponent),] }],
    selectedIndex: [{ type: Input }],
    selectedIndexChange: [{ type: Output }],
    type: [{ type: Input, args: ['type',] }],
    class: [{ type: Input }],
    tabItemDeselected: [{ type: Output }],
    tabItemSelected: [{ type: Output }],
    contentsContainer: [{ type: ViewChild, args: ['contentsContainer', { static: true },] }],
    headerContainer: [{ type: ViewChild, args: ['headerContainer', { static: true },] }],
    itemsContainer: [{ type: ViewChild, args: ['itemsContainer', { static: true },] }],
    selectedIndicator: [{ type: ViewChild, args: ['selectedIndicator',] }],
    tabsContainer: [{ type: ViewChild, args: ['tabsContainer', { static: true },] }],
    viewPort: [{ type: ViewChild, args: ['viewPort', { static: true },] }],
    viewTabs: [{ type: ViewChildren, args: [forwardRef(() => IgxTabItemComponent),] }],
    disableAnimation: [{ type: Input }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    cssClass: [{ type: HostBinding, args: ['attr.class',] }]
};
/**
 * @hidden
 */
class IgxTabsModule {
}
IgxTabsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                exports: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                imports: [CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]
            },] }
];

/** @hidden */
const IGX_TIME_PICKER_COMPONENT = 'IgxTimePickerComponentToken';
/** @hidden */
var TimeParts;
(function (TimeParts) {
    TimeParts["Hour"] = "hour";
    TimeParts["Minute"] = "minute";
    TimeParts["Seconds"] = "seconds";
    TimeParts["AMPM"] = "ampm";
})(TimeParts || (TimeParts = {}));

/**
 * This file contains all the directives used by the @link IgxTimePickerComponent.
 * You should generally not use them directly.
 *
 * @preferred
 */
/** @hidden */
class IgxItemListDirective {
    constructor(timePicker, elementRef) {
        this.timePicker = timePicker;
        this.elementRef = elementRef;
        this.tabindex = 0;
    }
    get defaultCSS() {
        return true;
    }
    get hourCSS() {
        return this.type === 'hourList';
    }
    get minuteCSS() {
        return this.type === 'minuteList';
    }
    get secondsCSS() {
        return this.type === 'secondsList';
    }
    get ampmCSS() {
        return this.type === 'ampmList';
    }
    onFocus() {
        this.isActive = true;
    }
    onBlur() {
        this.isActive = false;
    }
    /**
     * @hidden
     */
    onKeydownArrowDown(event) {
        event.preventDefault();
        this.nextItem();
    }
    /**
     * @hidden
     */
    onKeydownArrowUp(event) {
        event.preventDefault();
        this.prevItem();
    }
    /**
     * @hidden
     */
    onKeydownArrowRight(event) {
        event.preventDefault();
        const listName = event.target.className;
        if (listName.indexOf('hourList') !== -1 && this.timePicker.minuteList) {
            this.timePicker.minuteList.nativeElement.focus();
        }
        else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1) && this.timePicker.secondsList) {
            this.timePicker.secondsList.nativeElement.focus();
        }
        else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1 ||
            listName.indexOf('secondsList') !== -1) && this.timePicker.ampmList) {
            this.timePicker.ampmList.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowLeft(event) {
        event.preventDefault();
        const listName = event.target.className;
        if (listName.indexOf('ampmList') !== -1 && this.timePicker.secondsList) {
            this.timePicker.secondsList.nativeElement.focus();
        }
        else if (listName.indexOf('secondsList') !== -1 && this.timePicker.secondsList
            && listName.indexOf('minutesList') && this.timePicker.minuteList) {
            this.timePicker.minuteList.nativeElement.focus();
        }
        else if (listName.indexOf('ampmList') !== -1 && this.timePicker.minuteList) {
            this.timePicker.minuteList.nativeElement.focus();
        }
        else if ((listName.indexOf('ampmList') !== -1 || listName.indexOf('secondsList') !== -1 ||
            listName.indexOf('minuteList') !== -1) && this.timePicker.hourList) {
            this.timePicker.hourList.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onKeydownEnter(event) {
        event.preventDefault();
        if (this.timePicker.mode === InteractionMode.DropDown) {
            this.timePicker.close();
            return;
        }
        this.timePicker.okButtonClick();
    }
    /**
     * @hidden
     */
    onKeydownEscape(event) {
        event.preventDefault();
        this.timePicker.cancelButtonClick();
    }
    /**
     * @hidden
     */
    onHover() {
        this.elementRef.nativeElement.focus();
    }
    /**
     * @hidden
     */
    onScroll(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.deltaY > 0) {
            this.nextItem();
        }
        else if (event.deltaY < 0) {
            this.prevItem();
        }
    }
    /**
     * @hidden
     */
    onPanMove(event) {
        if (event.deltaY < 0) {
            this.nextItem();
        }
        else if (event.deltaY > 0) {
            this.prevItem();
        }
    }
    nextItem() {
        switch (this.type) {
            case 'hourList': {
                this.timePicker.nextHour();
                break;
            }
            case 'minuteList': {
                this.timePicker.nextMinute();
                break;
            }
            case 'secondsList': {
                this.timePicker.nextSeconds();
                break;
            }
            case 'ampmList': {
                this.timePicker.nextAmPm();
                break;
            }
        }
    }
    prevItem() {
        switch (this.type) {
            case 'hourList': {
                this.timePicker.prevHour();
                break;
            }
            case 'minuteList': {
                this.timePicker.prevMinute();
                break;
            }
            case 'secondsList': {
                this.timePicker.prevSeconds();
                break;
            }
            case 'ampmList': {
                this.timePicker.prevAmPm();
                break;
            }
        }
    }
}
IgxItemListDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxItemList]'
            },] }
];
IgxItemListDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: ElementRef }
];
IgxItemListDirective.propDecorators = {
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    type: [{ type: Input, args: ['igxItemList',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__column',] }],
    hourCSS: [{ type: HostBinding, args: ['class.igx-time-picker__hourList',] }],
    minuteCSS: [{ type: HostBinding, args: ['class.igx-time-picker__minuteList',] }],
    secondsCSS: [{ type: HostBinding, args: ['class.igx-time-picker__secondsList',] }],
    ampmCSS: [{ type: HostBinding, args: ['class.igx-time-picker__ampmList',] }],
    onFocus: [{ type: HostListener, args: ['focus',] }],
    onBlur: [{ type: HostListener, args: ['blur',] }],
    onKeydownArrowDown: [{ type: HostListener, args: ['keydown.arrowdown', ['$event'],] }],
    onKeydownArrowUp: [{ type: HostListener, args: ['keydown.arrowup', ['$event'],] }],
    onKeydownArrowRight: [{ type: HostListener, args: ['keydown.arrowright', ['$event'],] }],
    onKeydownArrowLeft: [{ type: HostListener, args: ['keydown.arrowleft', ['$event'],] }],
    onKeydownEnter: [{ type: HostListener, args: ['keydown.enter', ['$event'],] }],
    onKeydownEscape: [{ type: HostListener, args: ['keydown.escape', ['$event'],] }],
    onHover: [{ type: HostListener, args: ['mouseover',] }],
    onScroll: [{ type: HostListener, args: ['wheel', ['$event'],] }],
    onPanMove: [{ type: HostListener, args: ['panmove', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxHourItemDirective {
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    get defaultCSS() {
        return true;
    }
    get selectedCSS() {
        return this.isSelectedHour;
    }
    get activeCSS() {
        return this.isSelectedHour && this.itemList.isActive;
    }
    get isSelectedHour() {
        return this.timePicker.selectedHour === this.value;
    }
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollHourIntoView(item);
        }
    }
}
IgxHourItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxHourItem]'
            },] }
];
IgxHourItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
IgxHourItemDirective.propDecorators = {
    value: [{ type: Input, args: ['igxHourItem',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item',] }],
    selectedCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--selected',] }],
    activeCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--active',] }],
    onClick: [{ type: HostListener, args: ['click', ['value'],] }]
};
/**
 * @hidden
 */
class IgxMinuteItemDirective {
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    get defaultCSS() {
        return true;
    }
    get selectedCSS() {
        return this.isSelectedMinute;
    }
    get activeCSS() {
        return this.isSelectedMinute && this.itemList.isActive;
    }
    get isSelectedMinute() {
        return this.timePicker.selectedMinute === this.value;
    }
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollMinuteIntoView(item);
        }
    }
}
IgxMinuteItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxMinuteItem]'
            },] }
];
IgxMinuteItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
IgxMinuteItemDirective.propDecorators = {
    value: [{ type: Input, args: ['igxMinuteItem',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item',] }],
    selectedCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--selected',] }],
    activeCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--active',] }],
    onClick: [{ type: HostListener, args: ['click', ['value'],] }]
};
/**
 * @hidden
 */
class IgxSecondsItemDirective {
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    get defaultCSS() {
        return true;
    }
    get selectedCSS() {
        return this.isSelectedSeconds;
    }
    get activeCSS() {
        return this.isSelectedSeconds && this.itemList.isActive;
    }
    get isSelectedSeconds() {
        return this.timePicker.selectedSeconds === this.value;
    }
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollSecondsIntoView(item);
        }
    }
}
IgxSecondsItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxSecondsItem]'
            },] }
];
IgxSecondsItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
IgxSecondsItemDirective.propDecorators = {
    value: [{ type: Input, args: ['igxSecondsItem',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item',] }],
    selectedCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--selected',] }],
    activeCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--active',] }],
    onClick: [{ type: HostListener, args: ['click', ['value'],] }]
};
/**
 * @hidden
 */
class IgxAmPmItemDirective {
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    get defaultCSS() {
        return true;
    }
    get selectedCSS() {
        return this.isSelectedAmPm;
    }
    get activeCSS() {
        return this.isSelectedAmPm && this.itemList.isActive;
    }
    get isSelectedAmPm() {
        return this.timePicker.selectedAmPm === this.value;
    }
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollAmPmIntoView(item);
        }
    }
}
IgxAmPmItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxAmPmItem]'
            },] }
];
IgxAmPmItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
IgxAmPmItemDirective.propDecorators = {
    value: [{ type: Input, args: ['igxAmPmItem',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item',] }],
    selectedCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--selected',] }],
    activeCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--active',] }],
    onClick: [{ type: HostListener, args: ['click', ['value'],] }]
};
/**
 * This directive should be used to mark which ng-template will be used from IgxTimePicker when re-templating its input group.
 */
class IgxTimePickerTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxTimePickerTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxTimePickerTemplate]'
            },] }
];
IgxTimePickerTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * This directive can be used to add custom action buttons to the dropdownb/dialog.
 */
class IgxTimePickerActionsDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxTimePickerActionsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxTimePickerActions]'
            },] }
];
IgxTimePickerActionsDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * Formats `IgxTimePickerComponent` display value according to the `format` property,
 * when the input element loses focus.
 */
class TimeDisplayFormatPipe {
    constructor(timePicker) {
        this.timePicker = timePicker;
    }
    transform(value) {
        let hour;
        let minutes;
        let seconds;
        let amPM;
        const maskAmPM = this.timePicker.parseMask();
        const mask = this.timePicker.parseMask(false);
        if (!value || value === mask || value === maskAmPM) {
            return '';
        }
        const sections = value.split(/[\s:]+/);
        if (this.timePicker.showHoursList) {
            hour = sections[0];
        }
        if (this.timePicker.showMinutesList) {
            minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
        }
        if (this.timePicker.showSecondsList) {
            seconds = sections[sections.length - (this.timePicker.showAmPmList ? 2 : 1)];
        }
        if (this.timePicker.showAmPmList) {
            amPM = sections[sections.length - 1];
        }
        const format = this.timePicker.format;
        const prompt = this.timePicker.promptChar;
        const regExp = new RegExp(this.timePicker.promptChar, 'g');
        if (format.indexOf('hh') !== -1 || format.indexOf('HH') !== -1 && hour.indexOf(prompt) !== -1) {
            hour = hour === prompt + prompt ? '00' : hour.replace(regExp, '0');
        }
        if (format.indexOf('mm') !== -1 && minutes.indexOf(prompt) !== -1) {
            minutes = minutes === prompt + prompt ? '00' : minutes.replace(regExp, '0');
        }
        if (format.indexOf('ss') !== -1 && seconds.indexOf(prompt) !== -1) {
            seconds = seconds === prompt + prompt ? '00' : seconds.replace(regExp, '0');
        }
        if (format.indexOf('hh') === -1 && format.indexOf('HH') === -1 && hour !== undefined) {
            hour = hour.indexOf(prompt) !== -1 ? hour.replace(regExp, '') : hour;
            const hourVal = parseInt(hour, 10);
            hour = !hourVal ? '0' : hourVal < 10 && hourVal !== 0 ? hour.replace('0', '') : hour;
        }
        if (format.indexOf('mm') === -1 && minutes !== undefined) {
            minutes = minutes.indexOf(prompt) !== -1 ? minutes.replace(regExp, '') : minutes;
            const minutesVal = parseInt(minutes, 10);
            minutes = !minutesVal ? '0' : minutesVal < 10 && minutesVal !== 0 ? minutes.replace('0', '') : minutes;
        }
        if (format.indexOf('ss') === -1 && seconds !== undefined) {
            seconds = seconds.indexOf(prompt) !== -1 ? seconds.replace(regExp, '') : seconds;
            const secondsVal = parseInt(seconds, 10);
            seconds = !secondsVal ? '0' : secondsVal < 10 && secondsVal !== 0 ? seconds.replace('0', '') : seconds;
        }
        if (format.indexOf('tt') !== -1 && (amPM !== 'AM' || amPM !== 'PM')) {
            amPM = amPM.indexOf('p') !== -1 || amPM.indexOf('P') !== -1 ? 'PM' : 'AM';
        }
        let result = `${hour}:${minutes}:${seconds}`;
        if (!hour) {
            // remove the hours
            result = result.slice(result.indexOf(':') + 1);
        }
        if (!minutes) {
            if (hour) {
                // get the hours and seconds and concat them
                result = result.slice(0, result.indexOf(':')) +
                    result.slice(result.lastIndexOf(':'), result.length);
            }
            else {
                // remove the minutes
                result = result.slice(result.indexOf(':') + 1);
            }
        }
        if (!seconds) {
            // remove the seconds
            result = result.slice(0, result.lastIndexOf(':'));
        }
        return amPM ? `${result} ${amPM}` : result;
    }
}
TimeDisplayFormatPipe.decorators = [
    { type: Pipe, args: [{ name: 'displayFormat' },] }
];
TimeDisplayFormatPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] }
];
/**
 * Formats `IgxTimePickerComponent` display value according to the `format` property,
 * when the input element gets focus.
 */
class TimeInputFormatPipe {
    constructor(timePicker) {
        this.timePicker = timePicker;
    }
    transform(value) {
        const prompt = this.timePicker.promptChar;
        const regExp = new RegExp(prompt, 'g');
        let mask;
        let hour;
        let minutes;
        let seconds;
        let amPM;
        if (this.timePicker.cleared) {
            this.timePicker.cleared = false;
            mask = this.timePicker.parseMask(false);
        }
        else {
            mask = this.timePicker.parseMask();
        }
        // TODO: Pending refactoring.
        value = this.timePicker.displayValue;
        if (!value || value === mask) {
            return mask;
        }
        const sections = value.split(/[\s:]+/);
        if (this.timePicker.showHoursList) {
            hour = sections[0];
            hour = hour.replace(regExp, '');
            const leadZeroHour = (parseInt(hour, 10) < 10 && !hour.startsWith('0')) || hour === '0';
            hour = leadZeroHour ? '0' + hour : hour;
        }
        if (this.timePicker.showMinutesList) {
            minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
            minutes = minutes.replace(regExp, '');
            const leadZeroMinutes = (parseInt(minutes, 10) < 10 && !minutes.startsWith('0')) || minutes === '0';
            minutes = leadZeroMinutes ? '0' + minutes : minutes;
        }
        if (this.timePicker.showSecondsList) {
            seconds = sections[sections.length - (this.timePicker.showAmPmList ? 2 : 1)];
            seconds = seconds.replace(regExp, '');
            const leadZeroSeconds = (parseInt(seconds, 10) < 10 && !seconds.startsWith('0')) || seconds === '0';
            seconds = leadZeroSeconds ? '0' + seconds : seconds;
        }
        if (this.timePicker.showAmPmList) {
            amPM = sections[sections.length - 1];
        }
        let result = `${hour}:${minutes}:${seconds}`;
        if (!hour) {
            // remove the hours
            result = result.slice(result.indexOf(':') + 1);
        }
        if (!minutes) {
            if (hour) {
                // get the hours and seconds and concat them
                result = result.slice(0, result.indexOf(':')) +
                    result.slice(result.lastIndexOf(':'), result.length);
            }
            else {
                // remove the minutes
                result = result.slice(result.indexOf(':') + 1);
            }
        }
        if (!seconds) {
            // remove the seconds
            result = result.slice(0, result.lastIndexOf(':'));
        }
        return amPM ? `${result} ${amPM}` : result;
    }
}
TimeInputFormatPipe.decorators = [
    { type: Pipe, args: [{ name: 'inputFormat' },] }
];
TimeInputFormatPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] }
];

let NEXT_ID$s = 0;
const ITEMS_COUNT = 7;
class TimePickerHammerConfig extends HammerGestureConfig {
    constructor() {
        super(...arguments);
        this.overrides = {
            pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
        };
    }
}
TimePickerHammerConfig.decorators = [
    { type: Injectable }
];
class IgxTimePickerComponent {
    constructor(_injector, _cdr) {
        this._injector = _injector;
        this._cdr = _cdr;
        /**
         * An @Input property that sets the value of the `id` attribute.
         * ```html
         * <igx-time-picker [id]="'igx-time-picker-5'" format="h:mm tt" ></igx-time-picker>
         * ```
         */
        this.id = `igx-time-picker-${NEXT_ID$s++}`;
        /**
         * An @Input property that allows you to disable the `igx-time-picker` component. By default `disabled` is set to false.
         * ```html
         * <igx-time-picker [disabled]="'true'" [vertical]="true" format="h:mm tt" ></igx-time-picker>
         * ```
         */
        this.disabled = false;
        /**
         * An @Input property that determines the spin behavior. By default `isSpinLoop` is set to true.
         * The seconds, minutes and hour spinning will wrap around by default.
         * ```html
         * <igx-time-picker [isSpinLoop]="false" id="time-picker"></igx-time-picker>
         * ```
         */
        this.isSpinLoop = true;
        /**
         * An @Input property that Gets/Sets the orientation of the `igxTimePicker`. By default `vertical` is set to false.
         * ```html
         * <igx-time-picker [vertical]="true" id="time-picker"></igx-time-picker>
         * ```
         */
        this.vertical = false;
        /**
         * Sets the character used to prompt the user for input.
         * Default value is "'-'".
         * ```html
         * <igx-time-picker [promptChar] = "'_'">
         * ```
         *
         * @memberof IgxTimePickerComponent
         */
        this.promptChar = '-';
        /**
         * An @Input property that allows you to switch the interaction mode between
         * a dialog picker or dropdown with editable masked input.
         * Deafult is dialog picker.
         * ```html
         * public mode = InteractionMode.DROPDOWN;
         *  //..
         * <igx-time-picker [mode]="mode"></igx-time-picker>
         * ```
         *
         * @memberof IgxTimePickerComponent
         */
        this.mode = InteractionMode.Dialog;
        /**
         * Emitted when selection is made. The event contains the selected value. Returns {`oldValue`: `Date`, `newValue`: `Date`}.
         * ```typescript
         *  @ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onValueChanged(timepicker){
         *     this.toast.open()
         * }
         *  //...
         *  ```
         *  ```html
         * <igx-time-picker (onValueChanged)="onValueChanged($event)"></igx-time-picker>
         * <igx-toast #toast message="The value has been changed!"></igx-toast>
         * ```
         */
        this.onValueChanged = new EventEmitter();
        /**
         * Emitted when an invalid value is being set. Returns {`timePicker`: `any`, `currentValue`: `Date`, `setThroughUI`: `boolean`}
         * ```typescript
         * public min: string = "09:00";
         * public max: string = "18:00";
         *  @ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onValidationFailed(timepicker){
         *     this.toast.open();
         * }
         *  //...
         *  ```
         *  ```html
         * <igx-time-picker [minValue]="min" [maxValue]="max" (onValidationFailed)="onValidationFailed($event)"></igx-time-picker>
         * <igx-toast #toast message="Value must be between 09:00 and 18:00!"></igx-toast>
         * ```
         */
        this.onValidationFailed = new EventEmitter();
        /**
         * Emitted when a timePicker is opened.
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted when a timePicker is closed.
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted when a timePicker is being closed.
         */
        this.onClosing = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.timeParts = Object.assign({}, TimeParts);
        /**
         * @hidden
         */
        this._hourItems = [];
        /**
         * @hidden
         */
        this._minuteItems = [];
        /**
         * @hidden
         */
        this._secondsItems = [];
        /**
         * @hidden
         */
        this._ampmItems = [];
        /**
         * @hidden
         */
        this.cleared = false;
        /**
         * @hidden
         */
        this.isNotEmpty = false;
        /**
         * @hidden
         */
        this.displayFormat = new TimeDisplayFormatPipe(this);
        /**
         * @hidden
         */
        this.inputFormat = new TimeInputFormatPipe(this);
        this._resourceStrings = CurrentResourceStrings.TimePickerResStrings;
        this._okButtonLabel = null;
        this._cancelButtonLabel = null;
        this._itemsDelta = { hours: 1, minutes: 1, seconds: 1 };
        this._isHourListLoop = this.isSpinLoop;
        this._isMinuteListLoop = this.isSpinLoop;
        this._isSecondsListLoop = this.isSpinLoop;
        this._hourView = [];
        this._minuteView = [];
        this._secondsView = [];
        this._ampmView = [];
        this._destroy$ = new Subject();
        this._onOpen = new EventEmitter();
        this._onClose = new EventEmitter();
        this._hoursPos = new Set();
        this._minutesPos = new Set();
        this._secondsPos = new Set();
        this._amPmPos = new Set();
        this._ngControl = null;
        this._onChangeCallback = noop;
        this._onTouchedCallback = noop;
    }
    /**
     * @hidden
     */
    get mask() {
        return this._mask || '00:00 LL';
    }
    set mask(val) {
        this._mask = val;
    }
    /**
     * @hidden
     */
    get displayValue() {
        if (this._displayValue === undefined) {
            return this._formatTime(this.value, this.format);
        }
        return this._displayValue;
    }
    set displayValue(value) {
        this._displayValue = value;
    }
    /**
     * Returns the current time formatted as string using the `format` option.
     * If there is no set time the return is an empty string.
     * ```typescript
     * @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let time = this.picker.displayTime;
     * }
     * ```
     */
    get displayTime() {
        if (this.value) {
            return this._formatTime(this.value, this.format);
        }
        return '';
    }
    /**
     * @hidden
     */
    get hourView() {
        return this._hourView;
    }
    /**
     * @hidden
     */
    get minuteView() {
        return this._minuteView;
    }
    /**
     * @hidden
     */
    get secondsView() {
        return this._secondsView;
    }
    /**
     * @hidden
     */
    get ampmView() {
        return this._ampmView;
    }
    /**
     * @hidden
     */
    get showClearButton() {
        return (this.displayValue && this.displayValue !== this.parseMask(false)) || this.isNotEmpty;
    }
    /**
     * @hidden
     */
    get showHoursList() {
        return this.format.indexOf('h') !== -1 || this.format.indexOf('H') !== -1;
    }
    /**
     * @hidden
     */
    get showMinutesList() {
        return this.format.indexOf('m') !== -1;
    }
    /**
     * @hidden
     */
    get showSecondsList() {
        return this.format.indexOf('s') !== -1;
    }
    /**
     * @hidden
     */
    get showAmPmList() {
        return this.format.indexOf('t') !== -1;
    }
    /**
     * @hidden
     */
    get validSecondsEntries() {
        const secondsEntries = [];
        for (let i = 0; i < 60; i++) {
            secondsEntries.push(i);
        }
        return secondsEntries;
    }
    /**
     * @hidden
     */
    get validMinuteEntries() {
        const minuteEntries = [];
        for (let i = 0; i < 60; i++) {
            minuteEntries.push(i);
        }
        return minuteEntries;
    }
    /**
     * @hidden
     */
    get validHourEntries() {
        const hourEntries = [];
        const index = this.format.indexOf('h') !== -1 ? 13 : 24;
        for (let i = 0; i < index; i++) {
            hourEntries.push(i);
        }
        return hourEntries;
    }
    /**
     * Gets the input group template.
     * ```typescript
     * let template = this.template();
     * ```
     *
     * @memberof IgxTimePickerComponent
     */
    get template() {
        if (this.timePickerTemplateDirective) {
            return this.timePickerTemplateDirective.template;
        }
        return this.mode === InteractionMode.Dialog ? this.defaultTimePickerTemplate : this.dropdownInputTemplate;
    }
    /**
     * Gets the context passed to the input group template.
     *
     * @memberof IgxTimePickerComponent
     */
    get context() {
        return {
            value: this.value,
            displayTime: this.displayTime,
            displayValue: this.displayValue,
            openDialog: (target) => this.openDialog(target)
        };
    }
    get required() {
        if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            const error = this._ngControl.control.validator({});
            return error && error.required;
        }
        return false;
    }
    /**
     * An accessor that allows you to set a time using the `value` input.
     * ```html
     * public date: Date = new Date(Date.now());
     *  //...
     * <igx-time-picker [value]="date" format="h:mm tt"></igx-time-picker>
     * ```
     */
    set value(value) {
        if (this._isValueValid(value)) {
            const oldVal = this._value;
            this._value = value;
            this._onChangeCallback(value);
            const dispVal = this._formatTime(this.value, this.format);
            if (this.mode === InteractionMode.DropDown && this._displayValue !== dispVal) {
                this.displayValue = dispVal;
            }
            const args = {
                oldValue: oldVal,
                newValue: value
            };
            this.onValueChanged.emit(args);
        }
        else {
            const args = {
                timePicker: this,
                currentValue: value,
                setThroughUI: false
            };
            this.onValidationFailed.emit(args);
        }
    }
    /**
     * An accessor that returns the value of `igx-time-picker` component.
     * ```html
     * @ViewChild("MyPick")
     * public pick: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let pickSelect = this.pick.value;
     * }
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * An accessor that sets the resource strings.
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /**
     * An @Input property that renders OK button with custom text. By default `okButtonLabel` is set to OK.
     * ```html
     * <igx-time-picker okButtonLabel='SET' [value]="date" format="h:mm tt"></igx-time-picker>
     * ```
     */
    set okButtonLabel(value) {
        this._okButtonLabel = value;
    }
    /**
     * An accessor that returns the label of ok button.
     */
    get okButtonLabel() {
        if (this._okButtonLabel === null) {
            return this.resourceStrings.igx_time_picker_ok;
        }
        return this._okButtonLabel;
    }
    /**
     * An @Input property that renders cancel button with custom text.
     * By default `cancelButtonLabel` is set to Cancel.
     * ```html
     * <igx-time-picker cancelButtonLabel='Exit' [value]="date" format="h:mm tt"></igx-time-picker>
     * ```
     */
    set cancelButtonLabel(value) {
        this._cancelButtonLabel = value;
    }
    /**
     * An accessor that returns the label of cancel button.
     */
    get cancelButtonLabel() {
        if (this._cancelButtonLabel === null) {
            return this.resourceStrings.igx_time_picker_cancel;
        }
        return this._cancelButtonLabel;
    }
    /**
     * An @Input property that gets/sets the delta by which hour and minute items would be changed <br>
     * when the user presses the Up/Down keys.
     * By default `itemsDelta` is set to `{hours: 1, minutes: 1, seconds: 1}`
     * ```html
     * <igx-time-picker [itemsDelta]="{hours:3, minutes:5, seconds:10}" id="time-picker"></igx-time-picker>
     * ```
     */
    set itemsDelta(value) {
        this._itemsDelta = Object.assign({ hours: 1, minutes: 1, seconds: 1 }, value);
    }
    get itemsDelta() {
        return this._itemsDelta;
    }
    /**
     * An @Input property that Gets/Sets format of time while `igxTimePicker` does not have focus. <br>
     * By default `format` is set to hh:mm tt. <br>
     * List of time-flags: <br>
     * `h` : hours field in 12-hours format without leading zero <br>
     * `hh` : hours field in 12-hours format with leading zero <br>
     * `H` : hours field in 24-hours format without leading zero <br>
     * `HH` : hours field in 24-hours format with leading zero <br>
     * `m` : minutes field without leading zero <br>
     * `mm` : minutes field with leading zero <br>
     * `s` : seconds field without leading zero <br>
     * `ss` : seconds field with leading zero <br>
     * `tt` : 2 character string which represents AM/PM field <br>
     * ```html
     * <igx-time-picker format="HH:m" id="time-picker"></igx-time-picker>
     * ```
     */
    get format() {
        return this._format || 'hh:mm tt';
    }
    set format(formatValue) {
        this._format = formatValue;
        this.mask = this._format.indexOf('tt') !== -1 ? '00:00:00 LL' : '00:00:00';
        if (!this.showHoursList || !this.showMinutesList) {
            this.trimMask();
        }
        if (!this.showSecondsList) {
            this.trimMask();
        }
        if (this.displayValue) {
            this.displayValue = this._formatTime(this.value, this._format);
        }
        this.determineCursorPos();
    }
    /**
     * An @Input property that allows you to modify overlay positioning, interaction and scroll behavior.
     * ```typescript
     * const settings: OverlaySettings = {
     *      closeOnOutsideClick: true,
     *      modal: false
     *  }
     * ```
     * ---
     * ```html
     * <igx-time-picker [overlaySettings]="settings"></igx-time-picker>
     * ```
     *
     * @memberof IgxTimePickerComponent
     */
    set overlaySettings(value) {
        this._overlaySettings = value;
    }
    get overlaySettings() {
        return this._overlaySettings ? this._overlaySettings :
            (this.mode === InteractionMode.Dialog ? this._dialogOverlaySettings : this._dropDownOverlaySettings);
    }
    /**
     * @hidden
     */
    onKeydownSpace(event) {
        this.openDialog(this.getInputGroupElement());
        event.preventDefault();
    }
    /**
     * @hidden
     */
    onAltArrowDown() {
        this.openDialog(this.getInputGroupElement());
    }
    //#region ControlValueAccessor
    /** @hidden @internal */
    writeValue(value) {
        // use this flag to make sure that min/maxValue are checked (in _convertMinMaxValue() method)
        // against the real value when initializing the component and value is bound via ngModel
        this._dateFromModel = value;
        this._value = value;
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this._formatTime(this.value, this.format);
        }
    }
    /** @hidden @internal */
    applyDisabledStyleForItem(period, value) {
        if (!this.minValue || !this.maxValue) {
            return false;
        }
        const minValueDate = this.convertMinMaxValue(this.minValue);
        const maxValueDate = this.convertMinMaxValue(this.maxValue);
        let hour = parseInt(this.selectedHour, 10);
        let minute = parseInt(this.selectedMinute, 10);
        let seconds = parseInt(this.selectedSeconds, 10);
        let amPM = this.selectedAmPm;
        const date = new Date(minValueDate);
        switch (period) {
            case TimeParts.Hour:
                hour = parseInt(value, 10);
                break;
            case TimeParts.Minute:
                minute = parseInt(value, 10);
                break;
            case TimeParts.Seconds:
                seconds = parseInt(value, 10);
                break;
            case TimeParts.AMPM:
                amPM = value;
                break;
        }
        if (amPM === 'PM') {
            hour += 12;
        }
        date.setHours(hour);
        date.setMinutes(minute);
        date.setSeconds(seconds);
        return date < minValueDate || date > maxValueDate;
    }
    /** @hidden @internal */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /** @hidden @internal */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /** @hidden @internal */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    //#endregion
    /**
     * @hidden
     */
    ngOnInit() {
        this._generateHours();
        this._generateMinutes();
        this._generateSeconds();
        if (this.format.indexOf('tt') !== -1) {
            this._generateAmPm();
        }
        this._dropDownOverlaySettings = {
            modal: false,
            closeOnOutsideClick: true,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy()
        };
        this._dialogOverlaySettings = {};
        this._ngControl = this._injector.get(NgControl, null);
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        if (this.mode === InteractionMode.DropDown && this._inputElementRef) {
            fromEvent(this._inputElementRef.nativeElement, 'keydown').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy$)).subscribe((event) => {
                if (event.key === "ArrowUp" /* UP_ARROW */ || event.key === "Up" /* UP_ARROW_IE */ ||
                    event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */) {
                    this.spinOnEdit(event);
                }
            });
        }
        if (this.toggleRef && this._inputGroup) {
            this.toggleRef.element.style.width = this._inputGroup.element.nativeElement.getBoundingClientRect().width + 'px';
        }
        if (this.toggleRef) {
            this.toggleRef.onClosed.pipe(takeUntil(this._destroy$)).subscribe(() => {
                if (this.mode === InteractionMode.DropDown) {
                    this._onDropDownClosed();
                }
                this.onClosed.emit(this);
            });
            this.toggleRef.onOpened.pipe(takeUntil(this._destroy$)).subscribe(() => {
                this.onOpened.emit(this);
            });
            this.toggleRef.onClosing.pipe(takeUntil(this._destroy$)).subscribe((event) => {
                this.onClosing.emit(event);
                // If canceled in a user onClosing handler
                if (event.cancel) {
                    return;
                }
                // Do not focus the input if clicking outside in dropdown mode
                const input = this.getEditElement();
                if (input && !(event.event && this.mode === InteractionMode.DropDown)) {
                    input.focus();
                }
                else {
                    this._updateValidityOnBlur();
                }
            });
            this.determineCursorPos();
            if (this._ngControl) {
                this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
            }
        }
    }
    ngAfterViewChecked() {
        // if one sets mode at run time this forces initialization of new igxInputGroup
        // As a result a new igxInputDirective is initialized too. In ngAfterViewInit of
        // the new directive isRequired of the igxInputGroup is set again. However
        // ngAfterViewInit of the time picker is not called again and we may finish with wrong
        // isRequired in igxInputGroup. This is why we should set it her, only when needed
        if (this._inputGroup && this._inputGroup.isRequired !== this.required) {
            this._inputGroup.isRequired = this.required;
            this._cdr.detectChanges();
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
        if (this._statusChanges$) {
            this._statusChanges$.unsubscribe();
        }
    }
    /** @hidden @internal */
    convertMinMaxValue(value) {
        if (!value) {
            return;
        }
        const date = this.value ? new Date(this.value) : this._dateFromModel ? new Date(this._dateFromModel) : new Date();
        const sections = value.split(/[\s:]+/);
        let hour;
        let minutes;
        let seconds;
        let amPM;
        date.setSeconds(0);
        if (this.showHoursList) {
            hour = sections[0];
            date.setHours(parseInt(hour, 10));
        }
        if (this.showMinutesList) {
            minutes = this.showHoursList ? sections[1] : sections[0];
            date.setMinutes(parseInt(minutes, 10));
        }
        if (this.showSecondsList) {
            seconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
            date.setSeconds(parseInt(seconds, 10));
        }
        if (this.showAmPmList) {
            amPM = sections[sections.length - 1].toUpperCase();
            if (((this.showHoursList && date.getHours().toString() !== '12') ||
                (!this.showHoursList && date.getHours().toString() <= '11')) && amPM === 'PM') {
                date.setHours(date.getHours() + 12);
            }
            if (!this.showHoursList && amPM === 'AM' && date.getHours().toString() > '11') {
                date.setHours(date.getHours() - 12);
            }
            if (this.showHoursList && date.getHours() === 12 && amPM === 'AM') {
                date.setHours(0);
            }
        }
        return date;
    }
    /**
     * @hidden
     */
    getEditElement() {
        return this._inputElementRef ? this._inputElementRef.nativeElement : null;
    }
    /**
     * @hidden
     */
    getInputGroupElement() {
        return this._inputGroup ? this._inputGroup.element.nativeElement : null;
    }
    /**
     * opens the dialog.
     *
     * @param target HTMLElement - the target element to use for positioning the drop down container according to
     * ```html
     * <igx-time-picker [value]="date" mode="dropdown" #retemplated>
     *   <ng-template igxTimePickerTemplate let-openDialog="openDialog"
     *                let-displayTime="displayTime">
     *     <igx-input-group>
     *       <input #dropDownTarget igxInput [value]="displayTime" />
     *       <igx-suffix (click)="openDialog(dropDownTarget)">
     *         <igx-icon>alarm</igx-icon>
     *       </igx-suffix>
     *     </igx-input-group>
     *   </ng-template>
     * </igx-time-picker>
     * ```
     */
    openDialog(target) {
        if (!this.toggleRef.collapsed) {
            return this._onDropDownClosed();
        }
        const settings = this.overlaySettings;
        if (target && settings && settings.positionStrategy) {
            settings.target = target;
        }
        if (this.outlet) {
            settings.outlet = this.outlet;
        }
        this.toggleRef.open(settings);
        this._initializeContainer();
    }
    /**
     * Scrolls a hour item into view.
     * ```typescript
     * scrhintoView(picker) {
     * picker.scrollHourIntoView('2');
     * }
     *  ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrhintoView(picker)"></igx-time-picker>
     * ```
     *
     * @param item to be scrolled in view.
     */
    scrollHourIntoView(item) {
        if (this.showHoursList) {
            const hourIntoView = this._scrollItemIntoView(item, this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
            if (hourIntoView) {
                this._hourView = hourIntoView.view;
                this.selectedHour = hourIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * Scrolls a minute item into view.
     * ```typescript
     * scrMintoView(picker) {
     * picker.scrollMinuteIntoView('3');
     * }
     *  ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrMintoView(picker)"></igx-time-picker>
     * ```
     *
     * @param item to be scrolled in view.
     */
    scrollMinuteIntoView(item) {
        if (this.showMinutesList) {
            const minuteIntoView = this._scrollItemIntoView(item, this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
            if (minuteIntoView) {
                this._minuteView = minuteIntoView.view;
                this.selectedMinute = minuteIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * Scrolls a seconds item into view.
     * ```typescript
     * scrMintoView(picker) {
     * picker.scrollSecondsIntoView('4');
     * }
     *  ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrMintoView(picker)"></igx-time-picker>
     * ```
     *
     * @param item to be scrolled in view.
     */
    scrollSecondsIntoView(item) {
        if (this.showSecondsList) {
            const secondsIntoView = this._scrollItemIntoView(item, this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
            if (secondsIntoView) {
                this._secondsView = secondsIntoView.view;
                this.selectedSeconds = secondsIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * Scrolls an ampm item into view.
     * ```typescript
     * scrAmPmIntoView(picker) {
     * picker.scrollAmPmIntoView('PM');
     * }
     *  ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrAmPmIntoView(picker)"></igx-time-picker>
     * ```
     *
     * @param item to be scrolled in view.
     */
    scrollAmPmIntoView(item) {
        if (this.showAmPmList) {
            const ampmIntoView = this._scrollItemIntoView(item, this._ampmItems, this.selectedAmPm, false, null);
            if (ampmIntoView) {
                this._ampmView = ampmIntoView.view;
                this.selectedAmPm = ampmIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * @hidden
     */
    nextHour() {
        const nextHour = this._nextItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
        this._hourView = nextHour.view;
        this.selectedHour = nextHour.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    prevHour() {
        const prevHour = this._prevItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
        this._hourView = prevHour.view;
        this.selectedHour = prevHour.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    nextMinute() {
        const nextMinute = this._nextItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
        this._minuteView = nextMinute.view;
        this.selectedMinute = nextMinute.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    prevMinute() {
        const prevMinute = this._prevItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
        this._minuteView = prevMinute.view;
        this.selectedMinute = prevMinute.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    nextSeconds() {
        const nextSeconds = this._nextItem(this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
        this._secondsView = nextSeconds.view;
        this.selectedSeconds = nextSeconds.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    prevSeconds() {
        const prevSeconds = this._prevItem(this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
        this._secondsView = prevSeconds.view;
        this.selectedSeconds = prevSeconds.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    nextAmPm() {
        const selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
        if (selectedIndex + 1 < this._ampmItems.length - 3) {
            this._updateAmPmView(selectedIndex - 2, selectedIndex + 5);
            this.selectedAmPm = this._ampmItems[selectedIndex + 1];
            this._updateEditableInput();
        }
    }
    /**
     * @hidden
     */
    prevAmPm() {
        const selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
        if (selectedIndex > 3) {
            this._updateAmPmView(selectedIndex - 4, selectedIndex + 3);
            this.selectedAmPm = this._ampmItems[selectedIndex - 1];
            this._updateEditableInput();
        }
    }
    /**
     * If current value is valid selects it, closes the dialog and returns true, otherwise returns false.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [rightButtonLabel]="okButtonLabel" (onRightButtonSelect)="okButtonClick()">
     * //..
     * </igx-dialog>
     * ```
     */
    okButtonClick() {
        const time = this._getSelectedTime();
        if (this._isValueValid(time)) {
            this.close();
            this.value = time;
            return true;
        }
        else {
            const args = {
                timePicker: this,
                currentValue: time,
                setThroughUI: true
            };
            this.onValidationFailed.emit(args);
            return false;
        }
    }
    /**
     * Closes the dialog without selecting the current value.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [leftButtonLabel]="cancelButtonLabel" (onLeftButtonSelect)="cancelButtonClick()">
     * //...
     * </igx-dialog>
     * ```
     */
    cancelButtonClick() {
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this.value ? this._formatTime(this.value, this.format) : this.parseMask(false);
        }
        this.close();
        this.selectedHour = this._prevSelectedHour;
        this.selectedMinute = this._prevSelectedMinute;
        this.selectedSeconds = this._prevSelectedSeconds;
        this.selectedAmPm = this._prevSelectedAmPm;
    }
    /**
     * Returns an array of the hours currently in view.
     * ```html
     *  @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *     let hInView = this.picker.hoursInView;
     * }
     * ```
     */
    hoursInView() {
        return this._hourView.filter((hour) => hour !== '');
    }
    /**
     * Returns an array of the minutes currently in view.
     * ```html
     *  @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *     let minInView = this.picker.minutesInView;
     * }
     * ```
     */
    minutesInView() {
        return this._minuteView.filter((minute) => minute !== '');
    }
    /**
     * Returns an array of the seconds currently in view.
     * ```html
     *  @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *     let minInView = this.picker.secondsInView;
     * }
     * ```
     */
    secondsInView() {
        return this._secondsView.filter((seconds) => seconds !== '');
    }
    /**
     * Returns an array of the AM/PM currently in view.
     * ```html
     *  @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *     let ApInView = this.picker.ampmInView;
     * }
     * ```
     */
    ampmInView() {
        return this._ampmView.filter((ampm) => ampm !== '');
    }
    /**
     * Closes the dropdown/dialog.
     * ```html
     * <igx-time-picker #timePicker></igx-time-picker>
     * ```
     * ```typescript
     * @ViewChild('timePicker', { read: IgxTimePickerComponent }) picker: IgxTimePickerComponent;
     * picker.close();
     * ```
     */
    close() {
        this.toggleRef.close();
    }
    /**
     * @hidden
     */
    parseMask(preserveAmPm = true) {
        const maskWithAmPm = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace('LL', 'AM');
        const pureMask = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace(new RegExp('L', 'g'), this.promptChar);
        return preserveAmPm ? maskWithAmPm : pureMask;
    }
    /**
     * @hidden
     */
    clear() {
        var _a, _b;
        if (this.toggleRef.collapsed) {
            this.cleared = true;
            this.isNotEmpty = false;
            const oldVal = new Date(this.value);
            this.displayValue = this.parseMask(false);
            requestAnimationFrame(() => {
                this._setCursorPosition(0);
            });
            // TODO: refactoring - this.value should be null #6585
            (_a = this.value) === null || _a === void 0 ? void 0 : _a.setHours(0, 0, 0);
            if (oldVal.getTime() !== ((_b = this.value) === null || _b === void 0 ? void 0 : _b.getTime()) || this.isReset()) {
                const args = {
                    oldValue: oldVal,
                    newValue: this.value
                };
                this.onValueChanged.emit(args);
            }
        }
        else {
            this.close();
        }
    }
    /**
     * @hidden
     */
    onInput(event) {
        var _a, _b;
        const inputMask = event.target.value;
        const oldVal = new Date(this.value);
        this.isNotEmpty = inputMask !== this.parseMask(false);
        // handle cases where all empty positions (promts) are filled and we want to update
        // timepicker own value property if it is a valid Date
        if (inputMask.indexOf(this.promptChar) === -1) {
            if (this._isEntryValid(inputMask)) {
                const newVal = this.convertMinMaxValue(inputMask);
                if (oldVal.getTime() !== newVal.getTime()) {
                    this.value = newVal;
                }
            }
            else {
                const args = {
                    timePicker: this,
                    currentValue: new Date(inputMask),
                    setThroughUI: false
                };
                this.onValidationFailed.emit(args);
            }
            // handle cases where the user deletes the display value (when pressing backspace or delete)
        }
        else if (!this.value || inputMask.length === 0 || !this.isNotEmpty) {
            this.isNotEmpty = false;
            // TODO: refactoring - this.value should be null #6585
            (_a = this.value) === null || _a === void 0 ? void 0 : _a.setHours(0, 0, 0);
            this.displayValue = inputMask;
            if (oldVal.getTime() !== ((_b = this.value) === null || _b === void 0 ? void 0 : _b.getTime()) || this.isReset()) {
                // TODO: Do not emit event when the editor is empty #6482
                const args = {
                    oldValue: oldVal,
                    newValue: this.value
                };
                this.onValueChanged.emit(args);
            }
        }
    }
    /**
     * @hidden
     */
    onFocus(event) {
        this.isNotEmpty = event.target.value !== this.parseMask(false);
    }
    /**
     * @hidden
     */
    onBlur(event) {
        if (this.mode === InteractionMode.DropDown) {
            const value = event.target.value;
            this.isNotEmpty = value !== '';
            this.displayValue = value;
            if (value && (value !== this.parseMask() || value !== this.parseMask(false))) {
                if (this._isEntryValid(value)) {
                    const newVal = this.convertMinMaxValue(value);
                    if (!this.value || this.value.getTime() !== newVal.getTime()) {
                        this.value = newVal;
                    }
                }
                else {
                    const args = {
                        timePicker: this,
                        currentValue: value,
                        setThroughUI: false
                    };
                    this.onValidationFailed.emit(args);
                }
            }
        }
        if (this.toggleRef.collapsed) {
            this._updateValidityOnBlur();
        }
    }
    mouseDown(event) {
        // if the click is not on the input but in input group
        // e.g. on prefix or suffix, prevent default and this way prevent blur
        if (event.target !== this.getEditElement()) {
            event.preventDefault();
        }
    }
    /**
     * @hidden
     */
    spinOnEdit(event) {
        event.preventDefault();
        let sign;
        let displayVal;
        const currentVal = new Date(this.value);
        const min = this.minValue ? this.convertMinMaxValue(this.minValue) : this.convertMinMaxValue('00:00');
        const max = this.maxValue ? this.convertMinMaxValue(this.maxValue) : this.convertMinMaxValue('24:00');
        const cursor = this._getCursorPosition();
        if (event.key) {
            const key = event.key;
            sign = key === "ArrowDown" /* DOWN_ARROW */ || key === "Down" /* DOWN_ARROW_IE */ ? -1 : 1;
        }
        if (event.deltaY) {
            sign = event.deltaY < 0 ? 1 : -1;
        }
        if (!this.displayValue) {
            this.value = min;
            displayVal = this._formatTime(this.value, this.format);
        }
        else {
            const hDelta = this.itemsDelta.hours * 60 + (sign * this.value.getMinutes());
            const mDelta = this.itemsDelta.minutes;
            const sDelta = this.itemsDelta.seconds;
            if (this.cursorOnHours(cursor, this.showHoursList)) {
                this.value = this._spinHours(currentVal, min, max, hDelta, sign);
            }
            if (this.cursorOnMinutes(cursor, this.showHoursList, this.showMinutesList)) {
                this.value = this._spinMinutes(currentVal, mDelta, sign);
            }
            if (this.cursorOnSeconds(cursor, this.showHoursList, this.showMinutesList, this.showSecondsList)) {
                this.value = this._spinSeconds(currentVal, sDelta, sign);
            }
            if (this.cursorOnAmPm(cursor, this.showHoursList, this.showMinutesList, this.showSecondsList, this.showAmPmList)) {
                const sections = this.displayValue.split(/[\s:]+/);
                sign = sections[sections.length - 1] === 'AM' ? 1 : -1;
                currentVal.setHours(currentVal.getHours() + (sign * 12));
                this.value = currentVal;
            }
            displayVal = this._formatTime(this.value, this.format);
        }
        // minor hack for preventing cursor jumping in IE
        this._displayValue = this.inputFormat.transform(displayVal);
        this._inputElementRef.nativeElement.value = this._displayValue;
        this._setCursorPosition(cursor);
        requestAnimationFrame(() => {
            this._setCursorPosition(cursor);
        });
    }
    onStatusChanged() {
        if ((this._ngControl.control.touched || this._ngControl.control.dirty) &&
            (this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {
            const input = this._inputDirective || this._inputDirectiveUserTemplate;
            if (this._inputGroup.isFocused) {
                input.valid = this._ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
            }
            else {
                input.valid = this._ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
            }
        }
        if (this._inputGroup && this._inputGroup.isRequired !== this.required) {
            this._inputGroup.isRequired = this.required;
        }
    }
    trimMask() {
        this.mask = this.mask.slice(this.mask.indexOf(':') + 1, this.mask.length);
    }
    determineCursorPos() {
        this.clearCursorPos();
        for (const char of this.format) {
            switch (char) {
                case 'H':
                case 'h':
                    if (this._hoursPos.size === 0) {
                        this._hoursPos.add(this.format.indexOf(char));
                    }
                    else {
                        this._hoursPos.add(this.format.lastIndexOf(char));
                    }
                    this._hoursPos.add(this.format.lastIndexOf(char) + 1);
                    break;
                case 'M':
                case 'm':
                    if (this._minutesPos.size === 0) {
                        this._minutesPos.add(this.format.indexOf(char));
                    }
                    else {
                        this._minutesPos.add(this.format.lastIndexOf(char));
                    }
                    this._minutesPos.add(this.format.lastIndexOf(char) + 1);
                    break;
                case 'S':
                case 's':
                    if (this._secondsPos.size === 0) {
                        this._secondsPos.add(this.format.indexOf(char));
                    }
                    else {
                        this._secondsPos.add(this.format.lastIndexOf(char));
                    }
                    this._secondsPos.add(this.format.lastIndexOf(char) + 1);
                    break;
                case 'T':
                case 't':
                    if (this._amPmPos.size === 0) {
                        this._amPmPos.add(this.format.indexOf(char));
                    }
                    else {
                        this._amPmPos.add(this.format.lastIndexOf(char));
                    }
                    this._amPmPos.add(this.format.lastIndexOf(char) + 1);
                    break;
            }
        }
    }
    clearCursorPos() {
        this._hoursPos.forEach(v => this._hoursPos.delete(v));
        this._minutesPos.forEach(v => this._minutesPos.delete(v));
        this._secondsPos.forEach(v => this._secondsPos.delete(v));
        this._amPmPos.forEach(v => this._amPmPos.delete(v));
    }
    _scrollItemIntoView(item, items, selectedItem, isListLoop, viewType) {
        let itemIntoView;
        if (items) {
            const index = (item === 'AM' || item === 'PM') ? items.indexOf(item) : items.indexOf(parseInt(item, 10));
            let view;
            if (index !== -1) {
                if (isListLoop) {
                    if (index > 0) {
                        selectedItem = this._itemToString(items[index - 1], viewType);
                        itemIntoView = this._nextItem(items, selectedItem, isListLoop, viewType);
                    }
                    else {
                        selectedItem = this._itemToString(items[1], viewType);
                        itemIntoView = this._prevItem(items, selectedItem, isListLoop, viewType);
                    }
                }
                else {
                    view = items.slice(index - 3, index + 4);
                    selectedItem = this._itemToString(items[index], viewType);
                    itemIntoView = { selectedItem, view };
                }
                itemIntoView.view = this._viewToString(itemIntoView.view, viewType);
            }
        }
        return itemIntoView;
    }
    _viewToString(view, viewType) {
        for (let i = 0; i < view.length; i++) {
            if (typeof (view[i]) !== 'string') {
                view[i] = this._itemToString(view[i], viewType);
            }
        }
        return view;
    }
    _itemToString(item, viewType) {
        if (item === null) {
            item = '';
        }
        else if (viewType && typeof (item) !== 'string') {
            const leadZeroHour = (item < 10 && (this.format.indexOf('hh') !== -1 || this.format.indexOf('HH') !== -1));
            const leadZeroMinute = (item < 10 && this.format.indexOf('mm') !== -1);
            const leadZeroSeconds = (item < 10 && this.format.indexOf('ss') !== -1);
            const leadZero = {
                hour: leadZeroHour,
                minute: leadZeroMinute,
                seconds: leadZeroSeconds
            }[viewType];
            item = (leadZero) ? '0' + item : `${item}`;
        }
        return item;
    }
    _prevItem(items, selectedItem, isListLoop, viewType) {
        const selectedIndex = items.indexOf(parseInt(selectedItem, 10));
        const itemsCount = items.length;
        let view;
        if (selectedIndex === -1) {
            view = items.slice(0, 7);
            selectedItem = items[3];
        }
        else if (isListLoop) {
            if (selectedIndex - 4 < 0) {
                view = items.slice(itemsCount - (4 - selectedIndex), itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 3));
            }
            else if (selectedIndex + 4 > itemsCount) {
                view = items.slice(selectedIndex - 4, itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 3 - itemsCount));
            }
            else {
                view = items.slice(selectedIndex - 4, selectedIndex + 3);
            }
            selectedItem = (selectedIndex === 0) ? items[itemsCount - 1] : items[selectedIndex - 1];
        }
        else if (selectedIndex > 3) {
            view = items.slice(selectedIndex - 4, selectedIndex + 3);
            selectedItem = items[selectedIndex - 1];
        }
        else if (selectedIndex === 3) {
            view = items.slice(0, 7);
        }
        view = this._viewToString(view, viewType);
        selectedItem = this._itemToString(selectedItem, viewType);
        return {
            selectedItem,
            view
        };
    }
    _nextItem(items, selectedItem, isListLoop, viewType) {
        const selectedIndex = items.indexOf(parseInt(selectedItem, 10));
        const itemsCount = items.length;
        let view;
        if (selectedIndex === -1) {
            view = items.slice(0, 7);
            selectedItem = items[3];
        }
        else if (isListLoop) {
            if (selectedIndex < 2) {
                view = items.slice(itemsCount - (2 - selectedIndex), itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 5));
            }
            else if (selectedIndex + 4 >= itemsCount) {
                view = items.slice(selectedIndex - 2, itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 5 - itemsCount));
            }
            else {
                view = items.slice(selectedIndex - 2, selectedIndex + 5);
            }
            selectedItem = (selectedIndex === itemsCount - 1) ? items[0] : items[selectedIndex + 1];
        }
        else if (selectedIndex + 1 < itemsCount - 3) {
            view = items.slice(selectedIndex - 2, selectedIndex + 5);
            selectedItem = items[selectedIndex + 1];
        }
        else if (selectedIndex === itemsCount - 4) {
            view = items.slice(selectedIndex - 3, itemsCount);
        }
        view = this._viewToString(view, viewType);
        selectedItem = this._itemToString(selectedItem, viewType);
        return {
            selectedItem,
            view
        };
    }
    _formatTime(value, format) {
        if (!value) {
            return '';
        }
        else {
            let hour = value.getHours();
            let formattedHour;
            const minute = value.getMinutes();
            const seconds = value.getSeconds();
            const amPM = (hour > 11) ? 'PM' : 'AM';
            if (format.indexOf('h') !== -1) {
                if (hour > 12) {
                    hour -= 12;
                    formattedHour = hour < 10 && format.indexOf('hh') !== -1 ? '0' + hour : `${hour}`;
                }
                else if (hour === 0) {
                    formattedHour = '12';
                }
                else if (hour < 10 && format.indexOf('hh') !== -1) {
                    formattedHour = '0' + hour;
                }
                else {
                    formattedHour = `${hour}`;
                }
            }
            else {
                if (hour < 10 && format.indexOf('HH') !== -1) {
                    formattedHour = '0' + hour;
                }
                else {
                    formattedHour = `${hour}`;
                }
            }
            const formattedMinute = minute < 10 && format.indexOf('mm') !== -1 ? '0' + minute : `${minute}`;
            const formattedSeconds = seconds < 10 && format.indexOf('ss') !== -1 ? '0' + seconds : `${seconds}`;
            return format.replace('hh', formattedHour).replace('h', formattedHour)
                .replace('HH', formattedHour).replace('H', formattedHour)
                .replace('mm', formattedMinute).replace('m', formattedMinute)
                .replace('ss', formattedSeconds).replace('s', formattedSeconds)
                .replace('tt', amPM);
        }
    }
    _updateHourView(start, end) {
        this._hourView = this._viewToString(this._hourItems.slice(start, end), 'hour');
    }
    _updateMinuteView(start, end) {
        this._minuteView = this._viewToString(this._minuteItems.slice(start, end), 'minute');
    }
    _updateSecondsView(start, end) {
        this._secondsView = this._viewToString(this._secondsItems.slice(start, end), 'seconds');
    }
    _updateAmPmView(start, end) {
        this._ampmView = this._ampmItems.slice(start, end);
    }
    _addEmptyItems(items) {
        for (let i = 0; i < 3; i++) {
            items.push(null);
        }
    }
    _generateHours() {
        let hourItemsCount = 24;
        if (this.format.indexOf('h') !== -1) {
            hourItemsCount = 13;
        }
        hourItemsCount /= this.itemsDelta.hours;
        let i = this.format.indexOf('H') !== -1 ? 0 : 1;
        if (hourItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._hourItems);
            this._isHourListLoop = false;
        }
        if (hourItemsCount > 1) {
            for (i; i < hourItemsCount; i++) {
                this._hourItems.push(i * this.itemsDelta.hours);
            }
        }
        else {
            this._hourItems.push(0);
        }
        if (hourItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._hourItems);
        }
    }
    _generateMinutes() {
        const minuteItemsCount = 60 / this.itemsDelta.minutes;
        if (minuteItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._minuteItems);
            this._isMinuteListLoop = false;
        }
        for (let i = 0; i < minuteItemsCount; i++) {
            this._minuteItems.push(i * this.itemsDelta.minutes);
        }
        if (minuteItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._minuteItems);
        }
    }
    _generateSeconds() {
        const secondsItemsCount = 60 / this.itemsDelta.seconds;
        if (secondsItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._secondsItems);
            this._isSecondsListLoop = false;
        }
        for (let i = 0; i < secondsItemsCount; i++) {
            this._secondsItems.push(i * this.itemsDelta.seconds);
        }
        if (secondsItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._secondsItems);
        }
    }
    _generateAmPm() {
        this._addEmptyItems(this._ampmItems);
        this._ampmItems.push('AM');
        this._ampmItems.push('PM');
        this._addEmptyItems(this._ampmItems);
    }
    _getSelectedTime() {
        const date = this.value ? new Date(this.value) : new Date();
        if (this.selectedHour) {
            date.setHours(parseInt(this.selectedHour, 10));
        }
        if (this.selectedMinute) {
            date.setMinutes(parseInt(this.selectedMinute, 10));
        }
        if (this.selectedSeconds) {
            date.setSeconds(parseInt(this.selectedSeconds, 10));
        }
        if (((this.showHoursList && this.selectedHour !== '12') || (!this.showHoursList && this.selectedHour <= '11')) &&
            this.selectedAmPm === 'PM') {
            date.setHours(date.getHours() + 12);
        }
        if (!this.showHoursList && this.selectedAmPm === 'AM' && this.selectedHour > '11') {
            date.setHours(date.getHours() - 12);
        }
        if (this.selectedAmPm === 'AM' && this.selectedHour === '12') {
            date.setHours(0);
        }
        return date;
    }
    _isValueValid(value) {
        if (this.maxValue && value > this.convertMinMaxValue(this.maxValue)) {
            return false;
        }
        else if (this.minValue && value < this.convertMinMaxValue(this.minValue)) {
            return false;
        }
        else {
            return true;
        }
    }
    _isEntryValid(val) {
        let validH = true;
        let validM = true;
        let validS = true;
        const sections = val.split(/[\s:]+/);
        const re = new RegExp(this.promptChar, 'g');
        if (this.showHoursList) {
            validH = this.validHourEntries.indexOf(parseInt(sections[0].replace(re, ''), 10)) !== -1;
        }
        if (this.showMinutesList) {
            const minutes = this.showHoursList ? sections[1] : sections[0];
            validM = this.validMinuteEntries.indexOf(parseInt(minutes.replace(re, ''), 10)) !== -1;
        }
        if (this.showSecondsList) {
            const seconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
            validS = this.validSecondsEntries.indexOf(parseInt(seconds.replace(re, ''), 10)) !== -1;
        }
        return validH && validM && validS;
    }
    _getCursorPosition() {
        return this._inputElementRef.nativeElement.selectionStart;
    }
    _setCursorPosition(start, end = start) {
        this._inputElementRef.nativeElement.setSelectionRange(start, end);
    }
    _updateEditableInput() {
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this._formatTime(this._getSelectedTime(), this.format);
        }
    }
    _spinHours(currentVal, minVal, maxVal, hDelta, sign) {
        const oldVal = new Date(currentVal);
        currentVal.setMinutes(sign * hDelta);
        if (currentVal.getDate() !== oldVal.getDate() && this.isSpinLoop) {
            currentVal.setDate(oldVal.getDate());
        }
        let minutes = currentVal.getMinutes();
        if (currentVal.getTime() > maxVal.getTime()) {
            if (this.isSpinLoop) {
                minutes = minutes < minVal.getMinutes() ? 60 + minutes : minutes;
                minVal.setMinutes(sign * minutes);
                return minVal;
            }
            else {
                return oldVal;
            }
        }
        else if (currentVal.getTime() < minVal.getTime()) {
            if (this.isSpinLoop) {
                minutes = minutes <= maxVal.getMinutes() ? minutes : minutes - 60;
                maxVal.setMinutes(minutes);
                return maxVal;
            }
            else {
                return oldVal;
            }
        }
        else {
            return currentVal;
        }
    }
    _spinMinutes(currentVal, mDelta, sign) {
        let minutes = currentVal.getMinutes() + (sign * mDelta);
        if (minutes < 0 || minutes >= 60) {
            minutes = this.isSpinLoop ? minutes - (sign * 60) : currentVal.getMinutes();
        }
        currentVal.setMinutes(minutes);
        return currentVal;
    }
    _spinSeconds(currentVal, sDelta, sign) {
        let seconds = currentVal.getSeconds() + (sign * sDelta);
        if (seconds < 0 || seconds >= 60) {
            seconds = this.isSpinLoop ? seconds - (sign * 60) : currentVal.getSeconds();
        }
        currentVal.setSeconds(seconds);
        return currentVal;
    }
    _initializeContainer() {
        if (this.value) {
            const formttedTime = this._formatTime(this.value, this.format);
            const sections = formttedTime.split(/[\s:]+/);
            if (this.showHoursList) {
                this.selectedHour = sections[0];
            }
            if (this.showMinutesList) {
                this.selectedMinute = this.showHoursList ? sections[1] : sections[0];
            }
            if (this.showSecondsList) {
                this.selectedSeconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
            }
            if (this.showAmPmList && this._ampmItems !== null) {
                this.selectedAmPm = sections[sections.length - 1];
            }
        }
        if (this.selectedHour === undefined) {
            this.selectedHour = !this.showHoursList && this.value ? this.value.getHours().toString() :
                this.showHoursList ? `${this._hourItems[3]}` : '0';
        }
        if (this.selectedMinute === undefined) {
            this.selectedMinute = !this.showMinutesList && this.value ? this.value.getMinutes().toString() : '0';
        }
        if (this.selectedSeconds === undefined) {
            this.selectedSeconds = !this.showSecondsList && this.value ? this.value.getSeconds().toString() : '0';
        }
        if (this.selectedAmPm === undefined && this._ampmItems !== null) {
            this.selectedAmPm = this._ampmItems[3];
        }
        this._prevSelectedHour = this.selectedHour;
        this._prevSelectedMinute = this.selectedMinute;
        this._prevSelectedSeconds = this.selectedSeconds;
        this._prevSelectedAmPm = this.selectedAmPm;
        this._onTouchedCallback();
        this._updateHourView(0, ITEMS_COUNT);
        this._updateMinuteView(0, ITEMS_COUNT);
        this._updateSecondsView(0, ITEMS_COUNT);
        this._updateAmPmView(0, ITEMS_COUNT);
        if (this.selectedHour) {
            this.scrollHourIntoView(this.selectedHour);
        }
        if (this.selectedMinute) {
            this.scrollMinuteIntoView(this.selectedMinute);
        }
        if (this.selectedSeconds) {
            this.scrollSecondsIntoView(this.selectedSeconds);
        }
        if (this.selectedAmPm) {
            this.scrollAmPmIntoView(this.selectedAmPm);
        }
        requestAnimationFrame(() => {
            if (this.hourList) {
                this.hourList.nativeElement.focus();
            }
            else if (this.minuteList) {
                this.minuteList.nativeElement.focus();
            }
            else if (this.secondsList) {
                this.secondsList.nativeElement.focus();
            }
        });
    }
    _onDropDownClosed() {
        const oldValue = this.value;
        const newVal = this.convertMinMaxValue(this.displayValue);
        if (this.displayValue === this.parseMask(false)) {
            return;
        }
        if (this._isValueValid(newVal)) {
            if (!this.value || oldValue.getTime() !== newVal.getTime()) {
                this.value = newVal;
            }
        }
        else {
            this.displayValue = this.inputFormat.transform(this._formatTime(oldValue, this.format));
            const args = {
                timePicker: this,
                currentValue: newVal,
                setThroughUI: true
            };
            this.onValidationFailed.emit(args);
        }
    }
    cursorOnHours(cursor, showHours) {
        return showHours && this._hoursPos.has(cursor);
    }
    cursorOnMinutes(cursor, showHours, showMinutes) {
        return showMinutes &&
            (showHours && this._minutesPos.has(cursor)) ||
            (!showHours && this._minutesPos.has(cursor));
    }
    cursorOnSeconds(cursor, showHours, showMinutes, showSeconds) {
        return showSeconds &&
            (showHours && showMinutes && this._secondsPos.has(cursor)) ||
            ((!showHours || !showMinutes) && this._secondsPos.has(cursor)) ||
            (!showHours && !showMinutes && this._secondsPos.has(cursor));
    }
    cursorOnAmPm(cursor, showHours, showMinutes, showSeconds, showAmPm) {
        return showAmPm &&
            (showHours && showMinutes && showSeconds && this._amPmPos.has(cursor)) ||
            ((!showHours || !showMinutes || !showSeconds) && this._amPmPos.has(cursor)) ||
            (!showHours && (!showMinutes || !showSeconds) && this._amPmPos.has(cursor));
    }
    _updateValidityOnBlur() {
        this._onTouchedCallback();
        const input = this._inputDirective || this._inputDirectiveUserTemplate;
        if (this._ngControl && !this._ngControl.valid) {
            input.valid = IgxInputState.INVALID;
        }
        else {
            input.valid = IgxInputState.INITIAL;
        }
    }
    // Workaround method for #8135
    // TODO: It must be removed in #6482
    isReset() {
        var _a, _b, _c;
        return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.getHours()) === 0
            && ((_b = this.value) === null || _b === void 0 ? void 0 : _b.getMinutes()) === 0
            && ((_c = this.value) === null || _c === void 0 ? void 0 : _c.getSeconds()) === 0;
    }
}
IgxTimePickerComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxTimePickerComponent,
                        multi: true
                    },
                    {
                        provide: HAMMER_GESTURE_CONFIG,
                        useClass: TimePickerHammerConfig
                    },
                    {
                        provide: IGX_TIME_PICKER_COMPONENT,
                        useExisting: IgxTimePickerComponent
                    }
                ],
                selector: 'igx-time-picker',
                template: "<ng-template #labelTemplate>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #dropdownInputTemplate>\n    <igx-input-group #group (mousedown)=\"mouseDown($event)\" [suppressInputAutofocus]=\"true\">\n        <label igxLabel *ngIf=\"!labelDirective\">Time</label>\n        <ng-container ngProjectAs=\"[igxLabel]\" *ngTemplateOutlet=\"labelTemplate\"></ng-container>\n        <igx-prefix (click)=\"openDialog(group.element.nativeElement)\">\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <input\n            type=\"text\"\n            [igxMask]=\"mask\"\n            igxInput\n            [includeLiterals]=\"true\"\n            [placeholder]=\"format\"\n            [displayValuePipe]=\"displayFormat\"\n            [focusedValuePipe]=\"inputFormat\"\n            [promptChar]=\"promptChar\"\n            [value]=\"displayValue\"\n            [igxTextSelection]=\"true\"\n            (input)=\"onInput($event)\"\n            (blur)=\"onBlur($event)\"\n            (focus)=\"onFocus($event)\"\n            (wheel)=\"spinOnEdit($event)\"\n            [disabled]=\"disabled\" />\n        <igx-suffix *ngIf=\"showClearButton\" igxRipple (click)=\"clear()\">\n            <igx-icon>clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n<ng-template #defaultTimePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\" (mousedown)=\"mouseDown($event)\">\n        <igx-prefix>\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <label igxLabel *ngIf=\"!labelDirective\">Time</label>\n        <ng-container ngProjectAs=\"[igxLabel]\" *ngTemplateOutlet=\"labelTemplate\"></ng-container>\n        <input\n            igxInput\n            [value]=\"displayTime || ''\"\n            [disabled]=\"disabled\"\n            tabindex=\"0\" readonly\n            (blur)=\"onBlur($event)\" />\n    </igx-input-group>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n\n<ng-template #defaultTimePickerActions>\n    <div *ngIf=\"cancelButtonLabel || okButtonLabel\" class=\"igx-time-picker__buttons\">\n        <button *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" (click)=\"cancelButtonClick()\">\n            {{cancelButtonLabel}}\n        </button>\n        <button *ngIf=\"okButtonLabel\" igxButton=\"flat\" (click)=\"okButtonClick()\">\n            {{okButtonLabel}}\n        </button>\n    </div>\n</ng-template>\n<div igxToggle class=\"igx-time-picker\"\n    [ngClass]=\"{'igx-time-picker--dropdown': mode === 'dropdown', 'igx-time-picker--vertical': vertical && mode === 'dialog'}\">\n    <div *ngIf=\"mode === 'dialog'\" class=\"igx-time-picker__header\">\n        <h5 class=\"igx-time-picker__header-ampm\">{{ selectedAmPm }}</h5>\n        <h2 class=\"igx-time-picker__header-hour\">\n            <span>{{ selectedHour }}</span>:<span>{{ selectedMinute }}</span>:<span>{{ selectedSeconds }}</span>\n        </h2>\n    </div>\n    <div class=\"igx-time-picker__main\">\n        <div class=\"igx-time-picker__body\">\n            <div *ngIf=\"showHoursList\" #hourList [igxItemList]=\"'hourList'\">\n                <span [igxHourItem]=\"hour\"\n                [ngClass]=\"{'igx-time-picker__item--disabled': applyDisabledStyleForItem(timeParts.Hour, hour)}\"\n                *ngFor=\"let hour of hourView\">{{ hour }}</span>\n            </div>\n            <div *ngIf=\"showMinutesList\" #minuteList [igxItemList]=\"'minuteList'\">\n                <span [igxMinuteItem]=\"minute\"\n                [ngClass]=\"{'igx-time-picker__item--disabled': applyDisabledStyleForItem(timeParts.Minute, minute)}\"\n                *ngFor=\"let minute of minuteView\" >{{ minute }}</span>\n            </div>\n            <div *ngIf=\"showSecondsList\" #secondsList [igxItemList]=\"'secondsList'\">\n                <span [igxSecondsItem]=\"seconds\"\n                [ngClass]=\"{'igx-time-picker__item--disabled': applyDisabledStyleForItem(timeParts.Seconds, seconds)}\"\n                *ngFor=\"let seconds of secondsView\">{{ seconds }}</span>\n            </div>\n            <div *ngIf=\"showAmPmList\" #ampmList [igxItemList]=\"'ampmList'\">\n                <span [igxAmPmItem]=\"ampm\"\n                [ngClass]=\"{'igx-time-picker__item--disabled': applyDisabledStyleForItem(timeParts.AMPM, ampm)}\"\n                *ngFor=\"let ampm of ampmView\">{{ ampm }}</span>\n            </div>\n        </div>\n        <ng-container\n            *ngTemplateOutlet=\"timePickerActionsDirective ? timePickerActionsDirective.template : defaultTimePickerActions\">\n        </ng-container>\n    </div>\n</div>\n",
                styles: [`:host {
            display: block;
        }`]
            },] }
];
IgxTimePickerComponent.ctorParameters = () => [
    { type: Injector },
    { type: ChangeDetectorRef }
];
IgxTimePickerComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    disabled: [{ type: Input }],
    minValue: [{ type: Input }],
    maxValue: [{ type: Input }],
    isSpinLoop: [{ type: Input }],
    vertical: [{ type: Input }],
    promptChar: [{ type: Input }],
    mode: [{ type: Input }],
    outlet: [{ type: Input }],
    onValueChanged: [{ type: Output }],
    onValidationFailed: [{ type: Output }],
    onOpened: [{ type: Output }],
    onClosed: [{ type: Output }],
    onClosing: [{ type: Output }],
    hourList: [{ type: ViewChild, args: ['hourList',] }],
    minuteList: [{ type: ViewChild, args: ['minuteList',] }],
    secondsList: [{ type: ViewChild, args: ['secondsList',] }],
    ampmList: [{ type: ViewChild, args: ['ampmList',] }],
    timePickerActionsDirective: [{ type: ContentChild, args: [IgxTimePickerActionsDirective, { read: IgxTimePickerActionsDirective },] }],
    labelDirective: [{ type: ContentChild, args: [IgxLabelDirective,] }],
    toggleRef: [{ type: ViewChild, args: [IgxToggleDirective, { static: true },] }],
    defaultTimePickerTemplate: [{ type: ViewChild, args: ['defaultTimePickerTemplate', { read: TemplateRef, static: true },] }],
    timePickerTemplateDirective: [{ type: ContentChild, args: [IgxTimePickerTemplateDirective, { read: IgxTimePickerTemplateDirective },] }],
    dropdownInputTemplate: [{ type: ViewChild, args: ['dropdownInputTemplate', { read: TemplateRef, static: true },] }],
    _inputElementRef: [{ type: ViewChild, args: [IgxInputDirective, { read: ElementRef },] }],
    _inputDirective: [{ type: ViewChild, args: [IgxInputDirective, { read: IgxInputDirective },] }],
    _inputDirectiveUserTemplate: [{ type: ContentChild, args: [IgxInputDirective, { read: IgxInputDirective },] }],
    _inputGroup: [{ type: ViewChild, args: [IgxInputGroupComponent, { read: IgxInputGroupComponent },] }],
    value: [{ type: Input }],
    resourceStrings: [{ type: Input }],
    okButtonLabel: [{ type: Input }],
    cancelButtonLabel: [{ type: Input }],
    itemsDelta: [{ type: Input }],
    format: [{ type: Input }],
    overlaySettings: [{ type: Input }],
    onKeydownSpace: [{ type: HostListener, args: ['keydown.spacebar', ['$event'],] }, { type: HostListener, args: ['keydown.space', ['$event'],] }],
    onAltArrowDown: [{ type: HostListener, args: ['keydown.Alt.ArrowDown',] }]
};
/**
 * @hidden
 */
class IgxTimePickerModule {
}
IgxTimePickerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxTimePickerComponent,
                    IgxHourItemDirective,
                    IgxMinuteItemDirective,
                    IgxSecondsItemDirective,
                    IgxItemListDirective,
                    IgxAmPmItemDirective,
                    IgxTimePickerTemplateDirective,
                    IgxTimePickerActionsDirective,
                    TimeDisplayFormatPipe,
                    TimeInputFormatPipe
                ],
                exports: [
                    IgxTimePickerComponent,
                    IgxTimePickerTemplateDirective,
                    IgxTimePickerActionsDirective,
                    TimeDisplayFormatPipe,
                    TimeInputFormatPipe,
                    IgxInputGroupModule
                ],
                imports: [
                    CommonModule,
                    IgxInputGroupModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxMaskModule,
                    IgxToggleModule,
                    IgxTextSelectionModule
                ],
                providers: []
            },] }
];

let NEXT_ID$t = 0;
/**
 * Enumeration for toast position
 * Can be:
 * Bottom
 * Middle
 * Top
 */
const IgxToastPosition = mkenum({
    Bottom: 'bottom',
    Middle: 'middle',
    Top: 'top'
});
/**
 * **Ignite UI for Angular Toast** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/toast)
 *
 * The Ignite UI Toast provides information and warning messages that are non-interactive and cannot
 * be dismissed by the user. Toasts can be displayed at the bottom, middle, or top of the page.
 *
 * Example:
 * ```html
 * <button (click)="toast.show()">Show notification</button>
 * <igx-toast #toast
 *           message="Notification displayed"
 *           displayTime="1000">
 * </igx-toast>
 * ```
 */
class IgxToastComponent extends IgxToggleDirective {
    constructor(_element, cdr, navService, overlayService) {
        super(_element, cdr, overlayService, navService);
        this._element = _element;
        /**
         * @hidden
         */
        this.cssClass = 'igx-toast';
        /**
         * Sets/gets the `id` of the toast.
         * If not set, the `id` will have value `"igx-toast-0"`.
         * ```html
         * <igx-toast id = "my-first-toast"></igx-toast>
         * ```
         * ```typescript
         * let toastId = this.toast.id;
         * ```
         */
        this.id = `igx-toast-${NEXT_ID$t++}`;
        /**
         * Emits an event prior the toast is shown.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (showing)="handleShowing($event)"></igx-toast>
         * ```
         *
         * @memberof IgxToastComponent
         */
        this.showing = new EventEmitter();
        /**
         * Emits an event when the toast is shown.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (shown)="handleShown($event)"></igx-toast>
         * ```
         *
         * @memberof IgxToastComponent
         */
        this.shown = new EventEmitter();
        /**
         * Emits an event prior the toast is hidden.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (hiding)="handleHiding($event)"></igx-toast>
         * ```
         *
         * @memberof IgxToastComponent
         */
        this.hiding = new EventEmitter();
        /**
         *  Emits an event when the toast is hidden.
         *  Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (hidden)="handleHidden($event)"></igx-toast>
         * ```
         *
         * @memberof IgxToastComponent
         */
        this.hidden = new EventEmitter();
        /**
         * Sets/gets the `role` attribute.
         * If not set, `role` will have value `"alert"`.
         * ```html
         * <igx-toast [role] = "'notify'"></igx-toast>
         * ```
         * ```typescript
         * let toastRole = this.toast.role;
         * ```
         *
         * @memberof IgxToastComponent
         */
        this.role = 'alert';
        /**
         * Sets/gets whether the toast will be hidden after the `displayTime` is over.
         * Default value is `true`.
         * ```html
         * <igx-toast [autoHide] = "false"></igx-toast>
         * ```
         * ```typescript
         * let autoHide = this.toast.autoHide;
         * ```
         *
         * @memberof IgxToastComponent
         */
        this.autoHide = true;
        /**
         * Sets/gets the duration of time span(in milliseconds) which the toast will be visible
         * after it is being shown.
         * Default value is `4000`.
         * ```html
         * <igx-toast [displayTime] = "2500"></igx-toast>
         * ```
         * ```typescript
         * let displayTime = this.toast.displayTime;
         * ```
         *
         * @memberof IgxToastComponent
         */
        this.displayTime = 4000;
        /**
         * @hidden
         */
        this.isVisibleChange = new EventEmitter();
        /**
         * Sets/gets the position of the toast.
         * If not set, the `position` attribute will have value `IgxToastPosition.Bottom`.
         * ```html
         * <igx-toast [position]="top"></igx-toast>
         * ```
         * ```typescript
         * let toastPosition = this.toast.position;
         * ```
         *
         * @memberof IgxToastComponent
         */
        this.position = 'bottom';
        /**
         * @hidden
         * @internal
         */
        this.toastMessage = '';
        this.d$ = new Subject();
    }
    /**
     * Enables/Disables the visibility of the toast.
     * If not set, the `isVisible` attribute will have value `false`.
     * ```html
     * <igx-toast [isVisible]="true"></igx-toast>
     * ```
     * ```typescript
     * let isVisible = this.toast.isVisible;
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-toast [(isVisible)]="model.isVisible"></igx-toast>
     * ```
     *
     * @memberof IgxToastComponent
     */
    get isVisible() {
        return !this.collapsed;
    }
    set isVisible(value) {
        if (value !== this.isVisible) {
            if (value) {
                requestAnimationFrame(() => {
                    this.open();
                });
            }
            else {
                this.close();
            }
        }
    }
    /**
     * @deprecated Place your message in the toast content instead.
     * Sets/gets the message that will be shown by the toast.
     * ```html
     * <igx-toast [message]="Notification"></igx-toast>
     * ```
     * ```typescript
     * let toastMessage = this.toast.message;
     * ```
     * @memberof IgxToastComponent
     */
    set message(value) {
        this.toastMessage = value;
    }
    get message() {
        return this.toastMessage;
    }
    /**
     * Gets the nativeElement of the toast.
     * ```typescript
     * let nativeElement = this.toast.element;
     * ```
     *
     * @memberof IgxToastComponent
     */
    get element() {
        return this._element.nativeElement;
    }
    /**
     * @deprecated
     * Shows the toast.
     * If `autoHide` is enabled, the toast will hide after `displayTime` is over.
     *
     * ```typescript
     * this.toast.show();
     * ```
     *
     * @memberof IgxToastComponent
     */
    show(message) {
        this.open(message);
    }
    /**
     * @deprecated
     * Hides the toast.
     *
     * ```typescript
     * this.toast.hide();
     * ```
     *
     * @memberof IgxToastComponent
     */
    hide() {
        this.close();
    }
    /**
     * Shows the toast.
     * If `autoHide` is enabled, the toast will hide after `displayTime` is over.
     *
     * ```typescript
     * this.toast.open();
     * ```
     */
    open(message) {
        clearInterval(this.timeoutId);
        const overlaySettings = {
            positionStrategy: new GlobalPositionStrategy({
                horizontalDirection: HorizontalAlignment.Center,
                verticalDirection: this.position === 'bottom'
                    ? VerticalAlignment.Bottom
                    : this.position === 'middle'
                        ? VerticalAlignment.Middle
                        : VerticalAlignment.Top,
            }),
            closeOnEscape: false,
            closeOnOutsideClick: false,
            modal: false,
            outlet: this.outlet,
        };
        if (message !== undefined) {
            this.toastMessage = message;
        }
        this.showing.emit(this);
        super.open(overlaySettings);
        if (this.autoHide) {
            this.timeoutId = window.setTimeout(() => {
                this.close();
            }, this.displayTime);
        }
    }
    /**
     * Hides the toast.
     *
     * ```typescript
     * this.toast.close();
     * ```
     */
    close() {
        clearInterval(this.timeoutId);
        this.hiding.emit(this);
        super.close();
    }
    /**
     * Toggles the visible state of the toast.
     * ```typescript
     * this.toast.toggle();
     * ```
     *
     * @memberof IgxToastComponent
     */
    toggle() {
        super.toggle();
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.onOpened.pipe(takeUntil(this.d$)).subscribe(() => {
            this.isVisibleChange.emit(true);
            this.shown.emit(this);
        });
        this.onClosed.pipe(takeUntil(this.d$)).subscribe(() => {
            this.isVisibleChange.emit(false);
            this.hidden.emit(this);
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.d$.next(true);
        this.d$.complete();
    }
}
IgxToastComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-toast',
                template: "<ng-content></ng-content>\n<span>{{ toastMessage }}</span>\n\n"
            },] }
];
IgxToastComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] }
];
IgxToastComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-toast',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    showing: [{ type: Output }],
    shown: [{ type: Output }],
    hiding: [{ type: Output }],
    hidden: [{ type: Output }],
    role: [{ type: Input }],
    autoHide: [{ type: Input }],
    displayTime: [{ type: Input }],
    outlet: [{ type: Input }],
    isVisible: [{ type: Input }],
    isVisibleChange: [{ type: Output }],
    message: [{ type: Input }],
    position: [{ type: Input }]
};
__decorate([
    DeprecateProperty(`'showing' property is deprecated. You can use 'onOpening' instead.`)
], IgxToastComponent.prototype, "showing", void 0);
__decorate([
    DeprecateProperty(`'shown' property is deprecated. You can use 'onOpened' instead.`)
], IgxToastComponent.prototype, "shown", void 0);
__decorate([
    DeprecateProperty(`'hiding' property is deprecated. You can use 'onClosing' instead.`)
], IgxToastComponent.prototype, "hiding", void 0);
__decorate([
    DeprecateProperty(`'hidden' property is deprecated. You can use 'onClosed' instead.`)
], IgxToastComponent.prototype, "hidden", void 0);
__decorate([
    DeprecateProperty(`'message' property is deprecated.
        You can use place the message in the toast content or pass it as parameter to the show method instead.`)
], IgxToastComponent.prototype, "message", null);
__decorate([
    DeprecateMethod(`'show' is deprecated. Use 'open' method instead.`)
], IgxToastComponent.prototype, "show", null);
__decorate([
    DeprecateMethod(`'hide' is deprecated. Use 'close' method instead.`)
], IgxToastComponent.prototype, "hide", null);
/**
 * @hidden
 */
class IgxToastModule {
}
IgxToastModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxToastComponent],
                exports: [IgxToastComponent],
                imports: [CommonModule],
            },] }
];

/**
 * Represents individual resizable/collapsible panes.
 *
 * @igxModule IgxSplitterModule
 *
 * @igxParent IgxSplitterComponent
 *
 * @igxKeywords pane
 *
 * @igxGroup presentation
 *
 * @remarks
 *  Users can control the resize behavior via the min and max size properties.
 */
class IgxSplitterPaneComponent {
    constructor(el) {
        this.el = el;
        /**
         * @hidden @internal
         * Gets/Sets the 'display' property of the current pane.
         */
        this.display = 'flex';
        /**
         * Gets/Sets whether pane is resizable.
         *
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane [resizable]='false'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         * @remarks
         * If pane is not resizable its related splitter bar cannot be dragged.
         */
        this.resizable = true;
        /**
         * Event fired when collapsed state of pane is changed.
         *
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane (onToggle)='onPaneToggle($event)'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.onToggle = new EventEmitter();
        /**
         * Event fired when collapsed state of pane is changed.
         *
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane (collapsedChange)='paneCollapsedChange($event)'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.collapsedChange = new EventEmitter();
        /**
         * @hidden @internal
         * Gets/Sets the `overflow`.
         */
        this.overflow = 'auto';
        /**
         * @hidden @internal
         * Gets/Sets the `minHeight` and `minWidth` properties of the current pane.
         */
        this.minHeight = 0;
        /**
         * @hidden @internal
         * Gets/Sets the `maxHeight` and `maxWidth` properties of the current `IgxSplitterPaneComponent`.
         */
        this.maxHeight = '100%';
        this._size = 'auto';
        this._collapsed = false;
    }
    /**
     * Gets/Sets the size of the current pane.
     *  * @example
     * ```html
     * <igx-splitter>
     *  <igx-splitter-pane [size]='size'>...</igx-splitter-pane>
     * </igx-splitter>
     * ```
     */
    get size() {
        return this._size;
    }
    set size(value) {
        this._size = value;
        this.el.nativeElement.style.flex = this.flex;
    }
    /** @hidden @internal */
    get isPercentageSize() {
        return this.size === 'auto' || this.size.indexOf('%') !== -1;
    }
    /** @hidden @internal */
    get dragSize() {
        return this._dragSize;
    }
    set dragSize(val) {
        this._dragSize = val;
        this.el.nativeElement.style.flex = this.flex;
    }
    /**
     *
     * @hidden @internal
     * Gets the host native element.
     */
    get element() {
        return this.el.nativeElement;
    }
    /**
     * @hidden @internal
     * Gets the `flex` property of the current `IgxSplitterPaneComponent`.
     */
    get flex() {
        const isAuto = this.size === 'auto' && !this.dragSize;
        const grow = !isAuto ? 0 : 1;
        const size = this.dragSize || this.size;
        return `${grow} ${grow} ${size}`;
    }
    /**
     * Gets/Sets whether current pane is collapsed.
     *
     * @example
     * ```typescript
     * const isCollapsed = pane.collapsed;
     * ```
     */
    set collapsed(value) {
        this._collapsed = value;
        this.display = this._collapsed ? 'none' : 'flex';
    }
    get collapsed() {
        return this._collapsed;
    }
    /**
     * Toggles the collapsed state of the pane.
     *
     * @example
     * ```typescript
     * pane.toggle();
     * ```
     */
    toggle() {
        // reset sibling sizes when pane collapse state changes.
        this._getSiblings().forEach(sibling => sibling.size = 'auto');
        this.collapsed = !this.collapsed;
        this.onToggle.emit(this);
        this.collapsedChange.emit(this.collapsed);
    }
    /** @hidden @internal */
    _getSiblings() {
        const panes = this.owner.panes.toArray();
        const index = panes.indexOf(this);
        const siblings = [];
        if (index !== 0) {
            siblings.push(panes[index - 1]);
        }
        if (index !== panes.length - 1) {
            siblings.push(panes[index + 1]);
        }
        return siblings;
    }
}
IgxSplitterPaneComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-splitter-pane',
                template: "<ng-content></ng-content>"
            },] }
];
IgxSplitterPaneComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxSplitterPaneComponent.propDecorators = {
    display: [{ type: HostBinding, args: ['style.display',] }],
    minSize: [{ type: Input }],
    maxSize: [{ type: Input }],
    resizable: [{ type: Input }],
    onToggle: [{ type: Output }],
    collapsedChange: [{ type: Output }],
    order: [{ type: HostBinding, args: ['style.order',] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }],
    minHeight: [{ type: HostBinding, args: ['style.min-height',] }, { type: HostBinding, args: ['style.min-width',] }],
    maxHeight: [{ type: HostBinding, args: ['style.max-height',] }, { type: HostBinding, args: ['style.max-width',] }],
    size: [{ type: Input }],
    flex: [{ type: HostBinding, args: ['style.flex',] }],
    collapsed: [{ type: Input }]
};
__decorate([
    DeprecateProperty(`Deprecated. Subscribe to the 'collapsedChange' output instead.`)
], IgxSplitterPaneComponent.prototype, "onToggle", void 0);

/**
 * An enumeration that defines the `SplitterComponent` panes orientation.
 */
var SplitterType;
(function (SplitterType) {
    SplitterType[SplitterType["Horizontal"] = 0] = "Horizontal";
    SplitterType[SplitterType["Vertical"] = 1] = "Vertical";
})(SplitterType || (SplitterType = {}));
/**
 * Provides a framework for a simple layout, splitting the view horizontally or vertically
 * into multiple smaller resizable and collapsible areas.
 *
 * @igxModule IgxSplitterModule
 *
 * @igxParent Layouts
 *
 * @igxTheme igx-splitter-theme
 *
 * @igxKeywords splitter panes layout
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <igx-splitter>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 * </igx-splitter>
 * ```
 */
class IgxSplitterComponent {
    constructor(document, elementRef) {
        this.document = document;
        this.elementRef = elementRef;
        /**
         * @hidden @internal
         * Gets/Sets the `overflow` property of the current splitter.
         */
        this.overflow = 'hidden';
        /**
         * @hidden @internal
         * Sets/Gets the `display` property of the current splitter.
         */
        this.display = 'flex';
        /**
         * Event fired when resizing of panes starts.
         *
         * @example
         * ```html
         * <igx-splitter (resizeStart)='resizeStart($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizeStart = new EventEmitter();
        /**
         * Event fired when resizing of panes is in progress.
         *
         * @example
         * ```html
         * <igx-splitter (resizing)='resizing($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizing = new EventEmitter();
        /**
         * Event fired when resizing of panes ends.
         *
         * @example
         * ```html
         * <igx-splitter (resizeEnd)='resizeEnd($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizeEnd = new EventEmitter();
        this._type = SplitterType.Horizontal;
    }
    /**
     * Gets/Sets the splitter orientation.
     *
     * @example
     * ```html
     * <igx-splitter [type]="type">...</igx-splitter>
     * ```
     */
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
        if (this.panes) {
            // if type is changed runtime, should reset sizes.
            this.panes.forEach(x => x.size = 'auto');
        }
    }
    /**
     * @hidden @internal
     * Gets the `flex-direction` property of the current `SplitterComponent`.
     */
    get direction() {
        return this.type === SplitterType.Horizontal ? 'row' : 'column';
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this.panes.forEach(pane => pane.owner = this);
        this.assignFlexOrder();
        this.panes.changes.subscribe(() => {
            this.panes.forEach(pane => pane.owner = this);
            this.assignFlexOrder();
        });
    }
    /**
     * @hidden @internal
     * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.
     * @param pane - the main pane associated with the currently dragged bar.
     */
    onMoveStart(pane) {
        const panes = this.panes.toArray();
        this.pane = pane;
        this.sibling = panes[panes.indexOf(this.pane) + 1];
        const paneRect = this.pane.element.getBoundingClientRect();
        this.initialPaneSize = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        const siblingRect = this.sibling.element.getBoundingClientRect();
        this.initialSiblingSize = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizeStart.emit(args);
    }
    /**
     * @hidden @internal
     * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.
     * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.
     */
    onMoving(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        this.pane.dragSize = paneSize + 'px';
        this.sibling.dragSize = siblingSize + 'px';
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizing.emit(args);
    }
    onMoveEnd(delta) {
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (this.pane.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentPaneSize = (paneSize / totalSize) * 100;
            this.pane.size = percentPaneSize + '%';
        }
        else {
            // px resize
            this.pane.size = paneSize + 'px';
        }
        if (this.sibling.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentSiblingPaneSize = (siblingSize / totalSize) * 100;
            this.sibling.size = percentSiblingPaneSize + '%';
        }
        else {
            // px resize
            this.sibling.size = siblingSize + 'px';
        }
        this.pane.dragSize = null;
        this.sibling.dragSize = null;
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizeEnd.emit(args);
    }
    /** @hidden @internal */
    getPaneSiblingsByOrder(order, barIndex) {
        const panes = this.panes.toArray();
        const prevPane = panes[order - barIndex - 1];
        const nextPane = panes[order - barIndex];
        const siblings = [prevPane, nextPane];
        return siblings;
    }
    getTotalSize() {
        const computed = this.document.defaultView.getComputedStyle(this.elementRef.nativeElement);
        const totalSize = this.type === SplitterType.Horizontal ? computed.getPropertyValue('width') : computed.getPropertyValue('height');
        return parseFloat(totalSize);
    }
    /**
     * @hidden @internal
     * This method assigns the order of each pane.
     */
    assignFlexOrder() {
        let k = 0;
        this.panes.forEach((pane) => {
            pane.order = k;
            k += 2;
        });
    }
}
IgxSplitterComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-splitter',
                template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\"\n                    (movingEnd)='onMoveEnd($event)'>\n    </igx-splitter-bar>\n</ng-container>\n"
            },] }
];
IgxSplitterComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ElementRef }
];
IgxSplitterComponent.propDecorators = {
    panes: [{ type: ContentChildren, args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent },] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }],
    display: [{ type: HostBinding, args: ['style.display',] }],
    resizeStart: [{ type: Output }],
    resizing: [{ type: Output }],
    resizeEnd: [{ type: Output }],
    type: [{ type: Input }],
    direction: [{ type: HostBinding, args: ['style.flex-direction',] }]
};

const SPLITTER_INTERACTION_KEYS = new Set('right down left up arrowright arrowdown arrowleft arrowup'.split(' '));
/**
 * @hidden @internal
 * Represents the draggable bar that visually separates panes and allows for changing their sizes.
 */
class IgxSplitBarComponent {
    constructor() {
        /**
         * Set css class to the host element.
         */
        this.cssClass = 'igx-splitter-bar-host';
        /**
         * Gets/Sets the orientation.
         */
        this.type = SplitterType.Horizontal;
        /**
         * An event that is emitted whenever we start dragging the current `SplitBarComponent`.
         */
        this.moveStart = new EventEmitter();
        /**
         * An event that is emitted while we are dragging the current `SplitBarComponent`.
         */
        this.moving = new EventEmitter();
        this.movingEnd = new EventEmitter();
    }
    /**
     * @hidden
     * @internal
     */
    get tabindex() {
        return this.resizeDisallowed ? null : 0;
    }
    /**
     * @hidden
     * @internal
     */
    get orientation() {
        return this.type === SplitterType.Horizontal ? 'horizontal' : 'vertical';
    }
    /**
     * @hidden
     * @internal
     */
    get cursor() {
        if (this.resizeDisallowed) {
            return '';
        }
        return this.type === SplitterType.Horizontal ? 'col-resize' : 'row-resize';
    }
    /**
     * @hidden @internal
     */
    get prevButtonHidden() {
        return this.siblings[0].collapsed && !this.siblings[1].collapsed;
    }
    /**
     * @hidden @internal
     */
    keyEvent(event) {
        const key = event.key.toLowerCase();
        const ctrl = event.ctrlKey;
        event.stopPropagation();
        if (SPLITTER_INTERACTION_KEYS.has(key)) {
            event.preventDefault();
        }
        switch (key) {
            case 'arrowup':
            case 'up':
                if (this.type === SplitterType.Vertical) {
                    if (ctrl) {
                        this.onCollapsing(false);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(10);
                    }
                }
                break;
            case 'arrowdown':
            case 'down':
                if (this.type === SplitterType.Vertical) {
                    if (ctrl) {
                        this.onCollapsing(true);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(-10);
                    }
                }
                break;
            case 'arrowleft':
            case 'left':
                if (this.type === SplitterType.Horizontal) {
                    if (ctrl) {
                        this.onCollapsing(false);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(10);
                    }
                }
                break;
            case 'arrowright':
            case 'right':
                if (this.type === SplitterType.Horizontal) {
                    if (ctrl) {
                        this.onCollapsing(true);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(-10);
                    }
                }
                break;
            default:
                break;
        }
    }
    /**
     * @hidden @internal
     */
    get dragDir() {
        return this.type === SplitterType.Horizontal ? DragDirection.VERTICAL : DragDirection.HORIZONTAL;
    }
    /**
     * @hidden @internal
     */
    get nextButtonHidden() {
        return this.siblings[1].collapsed && !this.siblings[0].collapsed;
    }
    /**
     * @hidden @internal
     */
    onDragStart(event) {
        if (this.resizeDisallowed) {
            event.cancel = true;
            return;
        }
        this.startPoint = this.type === SplitterType.Horizontal ? event.startX : event.startY;
        this.moveStart.emit(this.pane);
    }
    /**
     * @hidden @internal
     */
    onDragMove(event) {
        const isHorizontal = this.type === SplitterType.Horizontal;
        const curr = isHorizontal ? event.pageX : event.pageY;
        const delta = this.startPoint - curr;
        if (delta !== 0) {
            this.moving.emit(delta);
            event.cancel = true;
            event.owner.element.nativeElement.style.transform = '';
        }
    }
    onDragEnd(event) {
        const isHorizontal = this.type === SplitterType.Horizontal;
        const curr = isHorizontal ? event.pageX : event.pageY;
        const delta = this.startPoint - curr;
        if (delta !== 0) {
            this.movingEnd.emit(delta);
        }
    }
    get resizeDisallowed() {
        const relatedTabs = this.siblings;
        return !!relatedTabs.find(x => x.resizable === false || x.collapsed === true);
    }
    /**
     * @hidden @internal
     */
    onCollapsing(next) {
        const prevSibling = this.siblings[0];
        const nextSibling = this.siblings[1];
        let target;
        if (next) {
            // if next is clicked when prev pane is hidden, show prev pane, else hide next pane.
            target = prevSibling.collapsed ? prevSibling : nextSibling;
        }
        else {
            // if prev is clicked when next pane is hidden, show next pane, else hide prev pane.
            target = nextSibling.collapsed ? nextSibling : prevSibling;
        }
        target.toggle();
    }
}
IgxSplitBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-splitter-bar',
                template: "<div class=\"igx-splitter-bar\"\n    [class.igx-splitter-bar--vertical]='type === 0'\n    [style.cursor]='cursor'\n    igxDrag\n    [ghost]=\"false\"\n    [dragDirection]='dragDir'\n    (dragStart)='onDragStart($event)'\n    (dragMove)=\"onDragMove($event)\"\n    (dragEnd)=\"onDragEnd($event)\"\n>\n    <div class=\"igx-splitter-bar__expander--start\" igxDragIgnore (click)='onCollapsing(false)' [hidden]='prevButtonHidden'></div>\n    <div class=\"igx-splitter-bar__handle\" ></div>\n    <div class=\"igx-splitter-bar__expander--end\" igxDragIgnore (click)='onCollapsing(true)' [hidden]='nextButtonHidden'></div>\n</div>\n"
            },] }
];
IgxSplitBarComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-splitter-bar-host',] }],
    type: [{ type: Input }],
    order: [{ type: HostBinding, args: ['style.order',] }, { type: Input }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    orientation: [{ type: HostBinding, args: ['attr.aria-orientation',] }],
    pane: [{ type: Input }],
    siblings: [{ type: Input }],
    moveStart: [{ type: Output }],
    moving: [{ type: Output }],
    movingEnd: [{ type: Output }],
    keyEvent: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

class IgxSplitterModule {
}
IgxSplitterModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, IgxIconModule, IgxDragDropModule
                ],
                declarations: [
                    IgxSplitterComponent,
                    IgxSplitterPaneComponent,
                    IgxSplitBarComponent
                ],
                exports: [
                    IgxSplitterComponent,
                    IgxSplitterPaneComponent
                ]
            },] }
];

/** @hidden @internal */
class DateRangePickerFormatPipe {
    transform(values, appliedFormat, locale, formatter) {
        if (!values || !values.start && !values.end) {
            return '';
        }
        if (formatter) {
            return formatter(values);
        }
        const { start, end } = values;
        const startDate = appliedFormat ? DatePickerUtil.formatDate(start, appliedFormat, locale || 'en') : start === null || start === void 0 ? void 0 : start.toLocaleDateString();
        const endDate = appliedFormat ? DatePickerUtil.formatDate(end, appliedFormat, locale || 'en') : end === null || end === void 0 ? void 0 : end.toLocaleDateString();
        let formatted;
        if (start) {
            formatted = `${startDate} - `;
            if (end) {
                formatted += endDate;
            }
        }
        return formatted ? formatted : '';
    }
}
DateRangePickerFormatPipe.decorators = [
    { type: Pipe, args: [{ name: 'dateRange' },] }
];
/** @hidden @internal */
class IgxDateRangeInputsBaseComponent extends IgxInputGroupComponent {
    /** @hidden @internal */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /** @hidden @internal */
    setFocus() {
        this.input.focus();
    }
    /** @hidden @internal */
    updateInputValue(value) {
        if (this.ngControl) {
            this.ngControl.control.setValue(value);
        }
        else {
            this.dateTimeEditor.value = value;
        }
    }
    /** @hidden @internal */
    updateInputValidity(state) {
        this.inputDirective.valid = state;
    }
}
IgxDateRangeInputsBaseComponent.decorators = [
    { type: Component, args: [{
                template: ``,
                selector: `igx-date-range-base`,
                providers: [{ provide: IgxInputGroupBase, useExisting: IgxDateRangeInputsBaseComponent }]
            },] }
];
IgxDateRangeInputsBaseComponent.propDecorators = {
    dateTimeEditor: [{ type: ContentChild, args: [IgxDateTimeEditorDirective,] }],
    inputDirective: [{ type: ContentChild, args: [IgxInputDirective,] }],
    ngControl: [{ type: ContentChild, args: [NgControl,] }]
};
/**
 * Templates the default icon in the `IgxDateRangePicker`.
 *
 * @igxModule IgxDateRangePickerModule
 *
 * @igxKeyWords date range icon, date picker icon
 *
 * @igxGroup scheduling
 *
 * @example
 * ```html
 * <igx-date-range-picker>
 *   <igx-picker-toggle igxSuffix>
 *      <igx-icon>calendar_view_day</igx-icon>
 *   </igx-picker-toggle>
 * </igx-date-range-picker>
 * ```
 */
class IgxPickerToggleComponent {
    constructor() {
        this.clicked = new EventEmitter();
    }
    onClick(event) {
        // do not focus input on click
        event.stopPropagation();
        this.clicked.emit();
    }
}
IgxPickerToggleComponent.decorators = [
    { type: Component, args: [{
                template: `<ng-content></ng-content>`,
                selector: 'igx-picker-toggle'
            },] }
];
IgxPickerToggleComponent.propDecorators = {
    clicked: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/**
 * Defines the start input for a date range picker
 *
 * @igxModule IgxDateRangePickerModule
 *
 * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme
 *
 * @igxKeywords date, range, date range, date picker
 *
 * @igxGroup scheduling
 *
 * @remarks
 * When templating, start input has to be templated separately
 *
 * @example
 * ```html
 * <igx-date-range-picker mode="dropdown">
 *      <igx-date-range-start>
 *          <input igxInput igxDateTimeEditor type="text">
 *      </igx-date-range-start>
 *      ...
 * </igx-date-range-picker>
 * ```
 */
class IgxDateRangeStartComponent extends IgxDateRangeInputsBaseComponent {
}
IgxDateRangeStartComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-date-range-start',
                template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n\n<div class=\"igx-input-group__hint\" (click)=\"hintClickHandler($event)\">\n    <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n</div>\n\n<ng-template #label>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #input>\n    <ng-content select=\"[igxInput]\"></ng-content>\n</ng-template>\n\n<ng-template #prefix>\n    <ng-content select=\"igx-prefix, [igxPrefix]\"></ng-content>\n</ng-template>\n\n<ng-template #uploadButton>\n    <igx-prefix *ngIf=\"isFileType\">\n        <button\n            igxButton=\"raised\"\n            (click)=\"uploadButtonHandler()\"\n            [displayDensity]=\"displayDensity\"\n            [disabled]=\"disabled\"\n            [ngClass]=\"{ 'igx-input-group__upload-button': isTypeLine }\"\n        >\n            {{ resourceStrings.igx_input_upload_button }}\n        </button>\n    </igx-prefix>\n</ng-template>\n\n<ng-template #files>\n    <div\n        *ngIf=\"isFileType\"\n        class=\"igx-input-group__file-input\"\n        [title]=\"fileNames\"\n    >\n        <span>{{ fileNames }}</span>\n    </div>\n</ng-template>\n\n<ng-template #clear>\n    <igx-suffix\n        class=\"igx-input-group__clear-icon\"\n        *ngIf=\"isFileType && isFilled\"\n        (click)=\"clearValueHandler()\"\n        (keydown.Enter)=\"clearValueHandler()\"\n        title=\"clear files\"\n        tabindex=\"0\"\n    >\n        <igx-icon>{{ resourceStrings.igx_input_clear_button }}</igx-icon>\n    </igx-suffix>\n</ng-template>\n\n<ng-template #suffix>\n    <ng-content select=\"igx-suffix, [igxSuffix]\"></ng-content>\n</ng-template>\n\n<ng-template #materialBundle>\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #fluentBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bootstrapBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bundle>\n    <ng-container [ngSwitch]=\"theme\">\n        <ng-container *ngSwitchCase=\"'bootstrap'\">\n            <ng-container *ngTemplateOutlet=\"bootstrapBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'fluent'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'indigo-design'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"materialBundle\"></ng-container>\n        </ng-container>\n    </ng-container>\n</ng-template>\n",
                providers: [
                    { provide: IgxInputGroupBase, useExisting: IgxDateRangeStartComponent },
                    { provide: IgxDateRangeInputsBaseComponent, useExisting: IgxDateRangeStartComponent }
                ]
            },] }
];
/**
 * Defines the end input for a date range picker
 *
 * @igxModule IgxDateRangeModule
 *
 * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme
 *
 * @igxKeywords date, range, date range, date picker
 *
 * @igxGroup scheduling
 *
 * @remarks
 * When templating, end input has to be template separately
 *
 * @example
 * ```html
 * <igx-date-range-picker mode="dropdown">
 *      <igx-date-range-end>
 *          <input igxInput igxDateTimeEditor type="text">
 *      </igx-date-range-end>
 *      ...
 * </igx-date-range-picker>
 * ```
 */
class IgxDateRangeEndComponent extends IgxDateRangeInputsBaseComponent {
}
IgxDateRangeEndComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-date-range-end',
                template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n\n<div class=\"igx-input-group__hint\" (click)=\"hintClickHandler($event)\">\n    <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n</div>\n\n<ng-template #label>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #input>\n    <ng-content select=\"[igxInput]\"></ng-content>\n</ng-template>\n\n<ng-template #prefix>\n    <ng-content select=\"igx-prefix, [igxPrefix]\"></ng-content>\n</ng-template>\n\n<ng-template #uploadButton>\n    <igx-prefix *ngIf=\"isFileType\">\n        <button\n            igxButton=\"raised\"\n            (click)=\"uploadButtonHandler()\"\n            [displayDensity]=\"displayDensity\"\n            [disabled]=\"disabled\"\n            [ngClass]=\"{ 'igx-input-group__upload-button': isTypeLine }\"\n        >\n            {{ resourceStrings.igx_input_upload_button }}\n        </button>\n    </igx-prefix>\n</ng-template>\n\n<ng-template #files>\n    <div\n        *ngIf=\"isFileType\"\n        class=\"igx-input-group__file-input\"\n        [title]=\"fileNames\"\n    >\n        <span>{{ fileNames }}</span>\n    </div>\n</ng-template>\n\n<ng-template #clear>\n    <igx-suffix\n        class=\"igx-input-group__clear-icon\"\n        *ngIf=\"isFileType && isFilled\"\n        (click)=\"clearValueHandler()\"\n        (keydown.Enter)=\"clearValueHandler()\"\n        title=\"clear files\"\n        tabindex=\"0\"\n    >\n        <igx-icon>{{ resourceStrings.igx_input_clear_button }}</igx-icon>\n    </igx-suffix>\n</ng-template>\n\n<ng-template #suffix>\n    <ng-content select=\"igx-suffix, [igxSuffix]\"></ng-content>\n</ng-template>\n\n<ng-template #materialBundle>\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #fluentBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bootstrapBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bundle>\n    <ng-container [ngSwitch]=\"theme\">\n        <ng-container *ngSwitchCase=\"'bootstrap'\">\n            <ng-container *ngTemplateOutlet=\"bootstrapBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'fluent'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'indigo-design'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"materialBundle\"></ng-container>\n        </ng-container>\n    </ng-container>\n</ng-template>\n",
                providers: [
                    { provide: IgxInputGroupBase, useExisting: IgxDateRangeEndComponent },
                    { provide: IgxDateRangeInputsBaseComponent, useExisting: IgxDateRangeEndComponent }
                ]
            },] }
];
class IgxDateRangeSeparatorDirective {
}
IgxDateRangeSeparatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDateRangeSeparator]'
            },] }
];

const SingleInputDatesConcatenationString = ' - ';
/**
 * Provides the ability to select a range of dates from a calendar UI or editable inputs.
 *
 * @igxModule IgxDateRangeModule
 *
 * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme
 *
 * @igxKeywords date, range, date range, date picker
 *
 * @igxGroup scheduling
 *
 * @remarks
 * It displays the range selection in a single or two input fields.
 * The default template displays a single *readonly* input field
 * while projecting `igx-date-range-start` and `igx-date-range-end`
 * displays two *editable* input fields.
 *
 * @example
 * ```html
 * <igx-date-range-picker mode="dropdown"></igx-date-range-picker>
 * ```
 */
class IgxDateRangePickerComponent extends DisplayDensityBase {
    constructor(element, _displayDensityOptions, localeId, _injector) {
        super(_displayDensityOptions);
        this.element = element;
        this._displayDensityOptions = _displayDensityOptions;
        this.localeId = localeId;
        this._injector = _injector;
        /**
         * Display calendar in either `dialog` or `dropdown` mode.
         *
         * @remarks
         * Default mode is `dialog`
         *
         * @example
         * ```html
         * <igx-date-range-picker mode="dropdown"></igx-date-range-picker>
         * ```
         */
        this.mode = InteractionMode.Dialog;
        /**
         * The number of displayed month views.
         *
         * @remarks
         * Default is `2`.
         *
         * @example
         * ```html
         * <igx-date-range-picker [monthsViewNumber]="3"></igx-date-range-picker>
         * ```
         */
        this.monthsViewNumber = 2;
        /**
         * The start day of the week.
         *
         * @remarks
         * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
         *
         * @example
         * ```html
         * <igx-date-range-picker [weekStart]="1"></igx-date-range-picker>
         * ```
         */
        this.weekStart = WEEKDAYS.SUNDAY;
        /**
         * The default text of the calendar dialog `done` button.
         *
         * @remarks
         * Default value is `Done`.
         * The button will only show up in `dialog` mode.
         *
         * @example
         * ```html
         * <igx-date-range-picker doneButtonText="完了"></igx-date-range-picker>
         * ```
         */
        this.doneButtonText = 'Done';
        /**
         * Enables/Disables the `IgxDateRangePickerComponent`.
         *
         *  @example
         * ```html
         * <igx-date-range-picker [disabled]="'true'"></igx-date-range-picker>
         * ```
         */
        this.disabled = false;
        /**
         * Sets the `placeholder` for single-input `IgxDateRangePickerComponent`.
         *
         *   @example
         * ```html
         * <igx-date-range-picker [placeholder]="'Choose your dates'"></igx-date-range-picker>
         * ```
         */
        this.placeholder = '';
        /**
         * Emitted when a range is selected.
         *
         * @example
         * ```html
         * <igx-date-range-picker (rangeSelected)="handleSelected($event)"></igx-date-range-picker>
         * ```
         */
        this.rangeSelected = new EventEmitter();
        /**
         * Emitted when the calendar starts opening, cancelable.
         *
         * @example
         * ```html
         * <igx-date-range-picker (onOpening)="handleOpening($event)"></igx-date-range-picker>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted when the `IgxDateRangeComponent` is opened.
         *
         * @example
         * ```html
         * <igx-date-range-picker (onOpened)="handleOpened($event)"></igx-date-range-picker>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted when the calendar starts closing, cancelable.
         *
         * @example
         * ```html
         * <igx-date-range-picker (onClosing)="handleClosing($event)"></igx-date-range-picker>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted when the `IgxDateRangeComponent` is closed.
         *
         * @example
         * ```html
         * <igx-date-range-picker (onClosed)="handleClosed($event)"></igx-date-range-picker>
         * ```
         */
        this.onClosed = new EventEmitter();
        /** @hidden @internal */
        this.cssClass = 'igx-date-range-picker';
        /** @hidden @internal */
        this.dateSeparator = CurrentResourceStrings.DateRangePickerResStrings.igx_date_range_picker_date_separator;
        this._collapsed = true;
        this.$destroy = new Subject();
        this.$toggleClickNotifier = new Subject();
        this._dialogOverlaySettings = {
            closeOnOutsideClick: true,
            modal: true
        };
        this._dropDownOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false
        };
        this.onChangeCallback = noop;
        this.onTouchCallback = noop;
        this.onValidatorChange = noop;
        this.onStatusChanged = () => {
            if ((this._ngControl.control.touched || this._ngControl.control.dirty) &&
                (this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {
                if (this.inputGroup) {
                    this.inputDirective.valid = this.getInputState(this.inputGroup.isFocused);
                }
                else if (this.hasProjectedInputs) {
                    this.projectedInputs
                        .forEach(i => {
                        i.inputDirective.valid = this.getInputState(i.isFocused);
                    });
                }
            }
            this.setRequiredToInputs();
        };
        this.locale = this.locale || this.localeId;
    }
    /**
     * The minimum value in a valid range.
     *
     * @example
     * <igx-date-range-picker [minValue]="minDate"></igx-date-range-picker>
     */
    set minValue(value) {
        this._minValue = value;
        this.onValidatorChange();
    }
    get minValue() {
        return this._minValue;
    }
    /**
     * The maximum value in a valid range.
     *
     * @example
     * <igx-date-range-picker [maxValue]="maxDate"></igx-date-range-picker>
     */
    set maxValue(value) {
        this._maxValue = value;
        this.onValidatorChange();
    }
    get maxValue() {
        return this._maxValue;
    }
    /** @hidden @internal */
    get appliedFormat() {
        return DatePickerUtil.getLocaleDateFormat(this.locale, this.displayFormat)
            || DatePickerUtil.DEFAULT_INPUT_FORMAT;
    }
    /** @hidden @internal */
    get singleInputFormat() {
        if (this.placeholder !== '') {
            return this.placeholder;
        }
        const format = this.appliedFormat;
        return `${format}${SingleInputDatesConcatenationString}${format}`;
    }
    /**
     * Gets calendar state.
     *
     * ```typescript
     * let state = this.dateRange.collapsed;
     * ```
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * The currently selected value / range from the calendar
     *
     * @remarks
     * The current value is of type `DateRange`
     *
     * @example
     * ```typescript
     * const newValue: DateRange = { start: new Date("2/2/2012"), end: new Date("3/3/2013")};
     * this.dateRangePicker.value = newValue;
     * ```
     */
    get value() {
        return this._value;
    }
    set value(value) {
        this.updateValue(value);
        this.onChangeCallback(value);
    }
    /** @hidden @internal */
    get hasProjectedInputs() {
        var _a;
        return ((_a = this.projectedInputs) === null || _a === void 0 ? void 0 : _a.length) > 0;
    }
    get dropdownOverlaySettings() {
        return Object.assign({}, this._dropDownOverlaySettings, this.overlaySettings);
    }
    get dialogOverlaySettings() {
        return Object.assign({}, this._dialogOverlaySettings, this.overlaySettings);
    }
    get required() {
        if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
            const error = this._ngControl.control.validator({});
            return (error && error.required) ? true : false;
        }
        return false;
    }
    /** @hidden @internal */
    onKeyDown(event) {
        switch (event.key) {
            case "ArrowUp" /* UP_ARROW */:
            case "Up" /* UP_ARROW_IE */:
                if (event.altKey) {
                    this.close();
                }
                break;
            case "ArrowDown" /* DOWN_ARROW */:
            case "Down" /* DOWN_ARROW_IE */:
                if (event.altKey) {
                    this.open();
                }
                break;
            case "Escape" /* ESCAPE */:
            case "Esc" /* ESCAPE_IE */:
                this.close();
                break;
        }
    }
    /**
     * Opens the date range picker's dropdown or dialog.
     *
     * @example
     * ```html
     * <igx-date-range-picker #dateRange></igx-date-range-picker>
     *
     * <button (click)="dateRange.open()">Open Dialog</button
     * ```
     */
    open(overlaySettings) {
        if (!this.collapsed || this.disabled) {
            return;
        }
        this.updateCalendar();
        const settings = this.mode === InteractionMode.Dialog ? this.dialogOverlaySettings : this.dropdownOverlaySettings;
        this.toggleDirective.open(Object.assign(settings, overlaySettings));
    }
    /**
     * Closes the date range picker's dropdown or dialog.
     *
     * @example
     * html```
     * <igx-date-range-picker #dateRange></igx-date-range-picker>
     *
     * <button (click)="dateRange.close()">Close Dialog</button>
     * ```
     */
    close() {
        if (!this.collapsed) {
            this.toggleDirective.close();
        }
    }
    /**
     * Toggles the date range picker's dropdown or dialog
     *
     * @example
     * html```
     * <igx-date-range-picker #dateRange></igx-date-range-picker>
     *
     * <button (click)="dateRange.toggle()">Toggle Dialog</button>
     * ```
     */
    toggle(overlaySettings) {
        if (!this.collapsed) {
            this.close();
        }
        else {
            this.open(overlaySettings);
        }
    }
    /**
     * Selects a range of dates. If no `endDate` is passed, range is 1 day (only `startDate`)
     *
     * @example
     * ```typescript
     * public selectFiveDayRange() {
     *  const today = new Date();
     *  const inFiveDays = new Date(new Date().setDate(today.getDate() + 5));
     *  this.dateRange.selectRange(today, inFiveDays);
     * }
     * ```
     */
    selectRange(startDate, endDate) {
        endDate = endDate !== null && endDate !== void 0 ? endDate : startDate;
        const dateRange = [startDate, endDate];
        this.calendar.selectDate(dateRange);
        this.handleSelection(dateRange);
    }
    /** @hidden @internal */
    writeValue(value) {
        this.updateValue(value);
    }
    /** @hidden @internal */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /** @hidden @internal */
    registerOnTouched(fn) {
        this.onTouchCallback = fn;
    }
    /** @hidden @internal */
    validate(control) {
        const value = control.value;
        const errors = {};
        if (value) {
            if (this.hasProjectedInputs) {
                const startInput = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);
                const endInput = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);
                if (!startInput.dateTimeEditor.value) {
                    Object.assign(errors, { startValue: true });
                }
                if (!endInput.dateTimeEditor.value) {
                    Object.assign(errors, { endValue: true });
                }
            }
            const min = DatePickerUtil.parseDate(this.minValue);
            const max = DatePickerUtil.parseDate(this.maxValue);
            const start = DatePickerUtil.parseDate(value.start);
            const end = DatePickerUtil.parseDate(value.end);
            if ((min && start && DatePickerUtil.lessThanMinValue(start, min, false))
                || (min && end && DatePickerUtil.lessThanMinValue(end, min, false))) {
                Object.assign(errors, { minValue: true });
            }
            if ((max && start && DatePickerUtil.greaterThanMaxValue(start, max, false))
                || (max && end && DatePickerUtil.greaterThanMaxValue(end, max, false))) {
                Object.assign(errors, { maxValue: true });
            }
        }
        return Object.keys(errors).length > 0 ? errors : null;
    }
    /** @hidden @internal */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /** @hidden @internal */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /** @hidden @internal */
    get separatorClass() {
        return this.getComponentDensityClass('igx-date-range-picker__label');
    }
    /** @hidden */
    ngOnInit() {
        this._ngControl = this._injector.get(NgControl, null);
    }
    /** @hidden */
    ngAfterViewInit() {
        this.subscribeToDateEditorEvents();
        this.configPositionStrategy();
        this.configOverlaySettings();
        this.cacheFocusedInput();
        this.attachOnTouched();
        const subsToClicked = () => {
            this.$toggleClickNotifier.next();
            this.toggleComponents.forEach(toggle => {
                toggle.clicked.pipe(takeUntil(this.$toggleClickNotifier)).subscribe(() => this.open());
            });
        };
        this.toggleComponents.changes.pipe(takeUntil(this.$destroy)).subscribe(() => subsToClicked());
        subsToClicked();
        this.setRequiredToInputs();
        if (this._ngControl) {
            this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
        }
        // delay invocations until the current change detection cycle has completed
        Promise.resolve().then(() => {
            this.updateDisabledState();
            this.initialSetValue();
            this.updateInputs();
        });
        this.updateDisplayFormat();
        this.updateInputFormat();
    }
    /** @hidden @internal */
    ngOnChanges(changes) {
        if (changes['locale']) {
            this.inputFormat = DatePickerUtil.getDefaultInputFormat(this.locale || 'en') || DatePickerUtil.DEFAULT_INPUT_FORMAT;
        }
        if (changes['displayFormat'] && this.hasProjectedInputs) {
            this.updateDisplayFormat();
        }
        if (changes['inputFormat'] && this.hasProjectedInputs) {
            this.updateInputFormat();
        }
        if (changes['disabled']) {
            this.updateDisabledState();
        }
    }
    /** @hidden @internal */
    ngOnDestroy() {
        this.$destroy.next();
        this.$destroy.complete();
        this.$toggleClickNotifier.next();
        this.$toggleClickNotifier.complete();
        if (this._statusChanges$) {
            this._statusChanges$.unsubscribe();
        }
    }
    /** @hidden @internal */
    handleOpening(event) {
        const args = { owner: this, cancel: event.cancel, event: event.event };
        this.onOpening.emit(args);
        event.cancel = args.cancel;
        if (!args.cancel) {
            this._collapsed = false;
        }
    }
    /** @hidden @internal */
    handleOpened() {
        this.calendar.daysView.focusActiveDate();
        this.onOpened.emit({ owner: this });
    }
    /** @hidden @internal */
    handleClosing(event) {
        if (this.value && !this.value.start && !this.value.end) {
            this.value = null;
        }
        const args = { owner: this, cancel: event.cancel, event: event.event };
        this.onClosing.emit(args);
        event.cancel = args.cancel;
        if (args.cancel) {
            return;
        }
        if (this.mode === InteractionMode.DropDown && event.event && !this.element.nativeElement.contains(event.event.target)) {
            // outside click
            this.updateValidityOnBlur();
        }
        else {
            // input click
            if (this.hasProjectedInputs && this._focusedInput) {
                this._focusedInput.setFocus();
                this._focusedInput = null;
            }
            if (this.inputDirective) {
                this.inputDirective.focus();
            }
        }
    }
    /** @hidden @internal */
    handleClosed() {
        this._collapsed = true;
        this.onClosed.emit({ owner: this });
    }
    /** @hidden @internal */
    handleSelection(selectionData) {
        this.value = this.extractRange(selectionData);
        this.rangeSelected.emit(this.value);
        if (this.mode === InteractionMode.DropDown && (selectionData === null || selectionData === void 0 ? void 0 : selectionData.length) > 1) {
            this.close();
        }
    }
    updateValue(value) {
        this._value = value ? value : null;
        this.updateInputs();
    }
    updateValidityOnBlur() {
        this.onTouchCallback();
        if (this._ngControl) {
            if (this.hasProjectedInputs) {
                this.projectedInputs.forEach(i => {
                    if (!this._ngControl.valid) {
                        i.updateInputValidity(IgxInputState.INVALID);
                    }
                    else {
                        i.updateInputValidity(IgxInputState.INITIAL);
                    }
                });
            }
            if (this.inputDirective) {
                if (!this._ngControl.valid) {
                    this.inputDirective.valid = IgxInputState.INVALID;
                }
                else {
                    this.inputDirective.valid = IgxInputState.INITIAL;
                }
            }
        }
    }
    updateDisabledState() {
        if (this.hasProjectedInputs) {
            const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);
            const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);
            start.inputDirective.disabled = this.disabled;
            end.inputDirective.disabled = this.disabled;
            return;
        }
        if (this.inputDirective) {
            this.inputDirective.disabled = this.disabled;
        }
    }
    getInputState(focused) {
        if (focused) {
            return this._ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
        }
        else {
            return this._ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
        }
    }
    setRequiredToInputs() {
        // workaround for igxInput setting required
        Promise.resolve().then(() => {
            const isRequired = this.required;
            if (this.inputGroup && this.inputGroup.isRequired !== isRequired) {
                this.inputGroup.isRequired = isRequired;
            }
            else if (this.hasProjectedInputs && this._ngControl) {
                this.projectedInputs.forEach(i => i.isRequired = isRequired);
            }
        });
    }
    parseMinValue(value) {
        let minValue = DatePickerUtil.parseDate(value);
        if (!minValue && this.hasProjectedInputs) {
            const start = this.projectedInputs.filter(i => i instanceof IgxDateRangeStartComponent)[0];
            if (start) {
                minValue = DatePickerUtil.parseDate(start.dateTimeEditor.minValue);
            }
        }
        return minValue;
    }
    parseMaxValue(value) {
        let maxValue = DatePickerUtil.parseDate(value);
        if (!maxValue && this.projectedInputs) {
            const end = this.projectedInputs.filter(i => i instanceof IgxDateRangeEndComponent)[0];
            if (end) {
                maxValue = DatePickerUtil.parseDate(end.dateTimeEditor.maxValue);
            }
        }
        return maxValue;
    }
    updateCalendar() {
        var _a, _b;
        this.calendar.disabledDates = [];
        const minValue = this.parseMinValue(this.minValue);
        if (minValue) {
            this.calendar.disabledDates.push({ type: DateRangeType.Before, dateRange: [minValue] });
        }
        const maxValue = this.parseMaxValue(this.maxValue);
        if (maxValue) {
            this.calendar.disabledDates.push({ type: DateRangeType.After, dateRange: [maxValue] });
        }
        const range = [];
        if (((_a = this.value) === null || _a === void 0 ? void 0 : _a.start) && ((_b = this.value) === null || _b === void 0 ? void 0 : _b.end)) {
            if (DatePickerUtil.greaterThanMaxValue(this.value.start, this.value.end)) {
                this.swapEditorDates();
            }
            if (this.valueInRange(this.value, minValue, maxValue)) {
                range.push(this.value.start, this.value.end);
            }
        }
        if (range.length > 0) {
            this.calendar.selectDate(range);
        }
        else {
            this.calendar.deselectDate();
        }
        this.calendar.viewDate = range[0] || new Date();
    }
    swapEditorDates() {
        if (this.hasProjectedInputs) {
            const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);
            const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);
            [start.dateTimeEditor.value, end.dateTimeEditor.value] = [end.dateTimeEditor.value, start.dateTimeEditor.value];
            [this.value.start, this.value.end] = [this.value.end, this.value.start];
        }
    }
    valueInRange(value, minValue, maxValue) {
        if (minValue && DatePickerUtil.lessThanMinValue(value.start, minValue, false)) {
            return false;
        }
        if (maxValue && DatePickerUtil.greaterThanMaxValue(value.end, maxValue, false)) {
            return false;
        }
        return true;
    }
    extractRange(selection) {
        return {
            start: selection[0],
            end: selection.length > 0 ? selection[selection.length - 1] : null
        };
    }
    subscribeToDateEditorEvents() {
        if (this.hasProjectedInputs) {
            const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);
            const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);
            if (start && end) {
                start.dateTimeEditor.valueChange
                    .pipe(takeUntil(this.$destroy))
                    .subscribe(value => {
                    if (this.value) {
                        this.value = { start: value, end: this.value.end };
                    }
                    else {
                        this.value = { start: value, end: null };
                    }
                });
                end.dateTimeEditor.valueChange
                    .pipe(takeUntil(this.$destroy))
                    .subscribe(value => {
                    if (this.value) {
                        this.value = { start: this.value.start, end: value };
                    }
                    else {
                        this.value = { start: null, end: value };
                    }
                });
            }
        }
    }
    attachOnTouched() {
        if (this.hasProjectedInputs) {
            this.projectedInputs.forEach(i => {
                fromEvent(i.dateTimeEditor.nativeElement, 'blur')
                    .pipe(takeUntil(this.$destroy))
                    .subscribe(() => {
                    if (this.collapsed) {
                        this.updateValidityOnBlur();
                    }
                });
            });
        }
        else {
            fromEvent(this.inputDirective.nativeElement, 'blur')
                .pipe(takeUntil(this.$destroy))
                .subscribe(() => {
                if (this.collapsed) {
                    this.updateValidityOnBlur();
                }
            });
        }
    }
    cacheFocusedInput() {
        if (this.hasProjectedInputs) {
            this.projectedInputs.forEach(i => {
                fromEvent(i.dateTimeEditor.nativeElement, 'focus')
                    .pipe(takeUntil(this.$destroy))
                    .subscribe(() => this._focusedInput = i);
            });
        }
    }
    configPositionStrategy() {
        this._positionSettings = {
            openAnimation: fadeIn,
            closeAnimation: fadeOut
        };
        this._dropDownOverlaySettings.positionStrategy = new AutoPositionStrategy(this._positionSettings);
        this._dropDownOverlaySettings.target = this.element.nativeElement;
    }
    configOverlaySettings() {
        if (this.overlaySettings !== null) {
            this._dropDownOverlaySettings = Object.assign({}, this._dropDownOverlaySettings, this.overlaySettings);
            this._dialogOverlaySettings = Object.assign({}, this._dialogOverlaySettings, this.overlaySettings);
        }
    }
    initialSetValue() {
        // if there is no value and no ngControl on the picker but we have inputs we may have value set through
        // their ngModels - we should generate our initial control value
        if ((!this.value || (!this.value.start && !this.value.end)) && this.hasProjectedInputs && !this._ngControl) {
            const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);
            const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);
            this._value = {
                start: start.dateTimeEditor.value,
                end: end.dateTimeEditor.value
            };
        }
    }
    updateInputs() {
        var _a, _b, _c, _d, _e, _f;
        const start = (_a = this.projectedInputs) === null || _a === void 0 ? void 0 : _a.find(i => i instanceof IgxDateRangeStartComponent);
        const end = (_b = this.projectedInputs) === null || _b === void 0 ? void 0 : _b.find(i => i instanceof IgxDateRangeEndComponent);
        if (start && end) {
            start.updateInputValue((_d = (_c = this.value) === null || _c === void 0 ? void 0 : _c.start) !== null && _d !== void 0 ? _d : null);
            end.updateInputValue((_f = (_e = this.value) === null || _e === void 0 ? void 0 : _e.end) !== null && _f !== void 0 ? _f : null);
        }
    }
    updateDisplayFormat() {
        this.projectedInputs.forEach(i => {
            const input = i;
            input.dateTimeEditor.displayFormat = this.displayFormat;
        });
    }
    updateInputFormat() {
        this.projectedInputs.forEach(i => {
            const input = i;
            if (input.dateTimeEditor.inputFormat !== this.inputFormat) {
                input.dateTimeEditor.inputFormat = this.inputFormat;
            }
        });
    }
}
IgxDateRangePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-date-range-picker',
                template: "<div #toggle=\"toggle\" igxToggle class=\"igx-date-picker\" [class.igx-date-picker--dropdown]=\"mode === 'dropdown'\"\n    (onOpening)=\"handleOpening($event)\" (onOpened)=\"handleOpened()\"\n    (onClosing)=\"handleClosing($event)\" (onClosed)=\"handleClosed()\"\n    [style.flex-basis]=\"monthsViewNumber * 320 + 'px'\"\n    [style.width]=\"monthsViewNumber * 320 + 'px'\"\n    [style.max-width]=\"'90vw'\"\n>\n    <!-- TODO: use IgxCalendarContainerComponent instead -->\n    <igx-calendar #calendar (keydown)=\"onKeyDown($event)\" selection=\"range\" [weekStart]=\"weekStart\"\n        [hideOutsideDays]=\"hideOutsideDays\" [monthsViewNumber]=\"monthsViewNumber\" [locale]=\"locale\"\n        (selected)=\"handleSelection($event)\"></igx-calendar>\n    <div class=\"igx-date-range-picker-buttons\">\n        <ng-container *ngIf=\"mode === 'dialog'\">\n            <button igxButton type=\"button\" (click)=\"close()\">{{ doneButtonText }}</button>\n        </ng-container>\n    </div>\n</div>\n\n<ng-container *ngTemplateOutlet=\"this.hasProjectedInputs ? startEndTemplate : defTemplate\"></ng-container>\n\n<ng-template #singleTemplate>\n    <div (click)=\"open()\" class=\"content-wrap\">\n        <ng-content select=\"igx-date-single\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #startEndTemplate>\n    <ng-content select=\"igx-date-range-start\"></ng-content>\n    <div [className]=\"separatorClass\">\n        <ng-container *ngTemplateOutlet=\"dateSeparatorTemplate ? dateSeparatorTemplate : defDateSeparatorTemplate;\"></ng-container>\n    </div>\n    <ng-content select=\"igx-date-range-end\"></ng-content>\n</ng-template>\n\n<ng-template #defIcon>\n    <igx-icon>\n        calendar_today\n    </igx-icon>\n</ng-template>\n\n<ng-template #defDateSeparatorTemplate>{{ dateSeparator }}</ng-template>\n\n<ng-template #defTemplate>\n    <igx-input-group (click)=\"open()\">\n        <input #singleInput igxInput type=\"text\" readonly\n            [placeholder]=\"this.value ? '' : singleInputFormat\"\n            role=\"combobox\"\n            aria-haspopup=\"grid\"\n            [attr.aria-expanded]=\"!toggle.collapsed\"\n            [attr.aria-labelledby]=\"this.label?.id\"\n            [value]=\"this.value | dateRange: this.appliedFormat : this.locale : this.formatter\"\n        />\n\n        <igx-prefix *ngIf=\"!this.toggleComponents.length\">\n            <ng-container *ngTemplateOutlet=\"defIcon\"></ng-container>\n        </igx-prefix>\n\n        <ng-container ngProjectAs=\"[igxLabel]\">\n            <ng-content select=\"[igxLabel]\"></ng-content>\n        </ng-container>\n        <ng-container ngProjectAs=\"igx-prefix\">\n            <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n        </ng-container>\n        <ng-container ngProjectAs=\"igx-suffix\">\n            <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n        </ng-container>\n        <ng-container ngProjectAs=\"igx-hint\">\n            <ng-content select=\"igx-hint,[igxHint]\"></ng-content>\n        </ng-container>\n    </igx-input-group>\n</ng-template>\n",
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: IgxDateRangePickerComponent, multi: true },
                    { provide: NG_VALIDATORS, useExisting: IgxDateRangePickerComponent, multi: true }
                ]
            },] }
];
IgxDateRangePickerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: Injector }
];
IgxDateRangePickerComponent.propDecorators = {
    mode: [{ type: Input }],
    monthsViewNumber: [{ type: Input }],
    hideOutsideDays: [{ type: Input }],
    weekStart: [{ type: Input }],
    locale: [{ type: Input }],
    formatter: [{ type: Input }],
    doneButtonText: [{ type: Input }],
    overlaySettings: [{ type: Input }],
    displayFormat: [{ type: Input }],
    inputFormat: [{ type: Input }],
    minValue: [{ type: Input }],
    maxValue: [{ type: Input }],
    disabled: [{ type: Input }],
    placeholder: [{ type: Input }],
    rangeSelected: [{ type: Output }],
    onOpening: [{ type: Output }],
    onOpened: [{ type: Output }],
    onClosing: [{ type: Output }],
    onClosed: [{ type: Output }],
    cssClass: [{ type: HostBinding, args: ['class.igx-date-range-picker',] }],
    calendar: [{ type: ViewChild, args: [IgxCalendarComponent,] }],
    inputGroup: [{ type: ViewChild, args: [IgxInputGroupComponent,] }],
    inputDirective: [{ type: ViewChild, args: [IgxInputDirective,] }],
    toggleDirective: [{ type: ViewChild, args: [IgxToggleDirective,] }],
    toggleComponents: [{ type: ContentChildren, args: [IgxPickerToggleComponent, { descendants: true },] }],
    projectedInputs: [{ type: ContentChildren, args: [IgxDateRangeInputsBaseComponent,] }],
    label: [{ type: ContentChild, args: [IgxLabelDirective,] }],
    dateSeparatorTemplate: [{ type: ContentChild, args: [IgxDateRangeSeparatorDirective, { read: TemplateRef },] }],
    value: [{ type: Input }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * @hidden
 */
class IgxDateRangePickerModule {
}
IgxDateRangePickerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxDateRangePickerComponent,
                    IgxDateRangeStartComponent,
                    IgxDateRangeEndComponent,
                    IgxDateRangeInputsBaseComponent,
                    DateRangePickerFormatPipe,
                    IgxPickerToggleComponent,
                    IgxDateRangeSeparatorDirective
                ],
                imports: [
                    CommonModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxToggleModule,
                    IgxCalendarModule,
                    IgxInputGroupModule,
                    IgxDateTimeEditorModule
                ],
                exports: [
                    IgxDateRangePickerComponent,
                    IgxDateRangeStartComponent,
                    IgxDateRangeEndComponent,
                    IgxDateRangeSeparatorDirective,
                    IgxDateTimeEditorModule,
                    IgxPickerToggleComponent,
                    IgxInputGroupModule
                ]
            },] }
];

/*
 * Public API Surface of igniteui-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AbsolutePosition, AbsoluteScrollStrategy, AutoPositionStrategy, BaseFilteringStrategy, BaseProgressDirective, BlockScrollStrategy, ButtonGroupAlignment, Calendar, CalendarHammerConfig, CalendarSelection, CalendarView, CarouselAnimationType, CarouselHammerConfig, CarouselIndicatorsOrientation, CloseScrollStrategy, ColumnDisplayOrder, ColumnPinningPosition, ConnectedPositioningStrategy, ContainerPositionStrategy, CsvFileTypes, DataType, DataUtil, DatePart, DateRangePickerFormatPipe, DateRangeType, DefaultSortingStrategy, DisplayDensity, DisplayDensityBase, DisplayDensityToken, DragDirection, ElasticPositionStrategy, ExportRecordType, FilterListItem, FilterMode, FilteringExpressionsTree, FilteringExpressionsTreeType, FilteringLogic, FilteringStrategy, FormattedValuesFilteringStrategy, GlobalPositionStrategy, GridBaseAPIService, GridPagingMode, GridSelectionMode, GridSummaryCalculationMode, GridSummaryPosition, GroupedRecords, HorizontalAlignment, IGX_CHECKBOX_REQUIRED_VALIDATOR, IGX_INPUT_GROUP_TYPE, IGX_SWITCH_REQUIRED_VALIDATOR, IgxActionStripComponent, IgxActionStripModule, IgxAppendDropStrategy, IgxAutocompleteDirective, IgxAutocompleteModule, IgxAvatarComponent, IgxAvatarModule, IgxAvatarSize, IgxAvatarType, IgxBadgeComponent, IgxBadgeModule, IgxBadgeType, IgxBannerComponent, IgxBannerModule, IgxBaseExporter, IgxBaseTransactionService, IgxBooleanFilteringOperand, IgxBottomNavComponent, IgxBottomNavModule, IgxButtonDirective, IgxButtonGroupComponent, IgxButtonGroupModule, IgxButtonModule, IgxCSVTextDirective, IgxCalendarBaseDirective, IgxCalendarComponent, IgxCalendarHeaderTemplateDirective, IgxCalendarModule, IgxCalendarMonthDirective, IgxCalendarScrollMonthDirective, IgxCalendarSubheaderTemplateDirective, IgxCalendarView, IgxCalendarYearDirective, IgxCardActionsComponent, IgxCardActionsLayout, IgxCardComponent, IgxCardContentDirective, IgxCardFooterDirective, IgxCardHeaderComponent, IgxCardHeaderSubtitleDirective, IgxCardHeaderTitleDirective, IgxCardMediaDirective, IgxCardModule, IgxCardThumbnailDirective, IgxCardType, IgxCarouselComponent, IgxCarouselModule, IgxCellEditorTemplateDirective, IgxCellFooterTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellTemplateDirective, IgxCheckboxComponent, IgxCheckboxModule, IgxCheckboxRequiredDirective, IgxChipComponent, IgxChipsAreaComponent, IgxChipsModule, IgxCircularProgressBarComponent, IgxCollapsibleIndicatorTemplateDirective, IgxColumnActionsBaseDirective, IgxColumnActionsComponent, IgxColumnActionsModule, IgxColumnComponent, IgxColumnGroupComponent, IgxColumnLayoutComponent, IgxComboComponent, IgxComboModule, IgxComboState, IgxCsvExporterOptions, IgxCsvExporterService, IgxCurrencySummaryOperand, IgxDataLoadingTemplateDirective, IgxDataRecordSorting, IgxDateFilteringOperand, IgxDatePickerComponent, IgxDatePickerModule, IgxDateRangeEndComponent, IgxDateRangeInputsBaseComponent, IgxDateRangePickerComponent, IgxDateRangePickerModule, IgxDateRangeSeparatorDirective, IgxDateRangeStartComponent, IgxDateSummaryOperand, IgxDateTimeEditorDirective, IgxDateTimeEditorModule, IgxDaysViewComponent, IgxDefaultDropStrategy, IgxDialogComponent, IgxDialogModule, IgxDisplayDensityModule, IgxDividerDirective, IgxDividerModule, IgxDividerType, IgxDragDirective, IgxDragDropModule, IgxDragHandleDirective, IgxDragIgnoreDirective, IgxDragLocation, IgxDropDirective, IgxDropDownBaseDirective, IgxDropDownComponent, IgxDropDownGroupComponent, IgxDropDownItemBaseDirective, IgxDropDownItemComponent, IgxDropDownItemNavigationDirective, IgxDropDownModule, IgxEmptyListTemplateDirective, IgxExcelExporterOptions, IgxExcelExporterService, IgxExcelStyleClearFiltersComponent, IgxExcelStyleColumnOperationsTemplateDirective, IgxExcelStyleConditionalFilterComponent, IgxExcelStyleFilterOperationsTemplateDirective, IgxExcelStyleHeaderComponent, IgxExcelStyleHeaderIconDirective, IgxExcelStyleHidingComponent, IgxExcelStyleLoadingValuesTemplateDirective, IgxExcelStyleMovingComponent, IgxExcelStylePinningComponent, IgxExcelStyleSearchComponent, IgxExcelStyleSelectingComponent, IgxExcelStyleSortingComponent, IgxExcelTextDirective, IgxExpansionPanelBodyComponent, IgxExpansionPanelComponent, IgxExpansionPanelHeaderComponent, IgxExpansionPanelModule, IgxExporterOptionsBase, IgxFilterCellTemplateDirective, IgxFilterDirective, IgxFilterModule, IgxFilterOptions, IgxFilterPipe, IgxFilteringOperand, IgxFlexDirective, IgxFocusDirective, IgxFocusModule, IgxForOfContext, IgxForOfDirective, IgxForOfModule, IgxGridAPIService, IgxGridActionsBaseDirective, IgxGridBaseDirective, IgxGridBodyDirective, IgxGridCellComponent, IgxGridCommonModule, IgxGridComponent, IgxGridDetailTemplateDirective, IgxGridEditingActionsComponent, IgxGridExcelStyleFilteringComponent, IgxGridExpandableCellComponent, IgxGridForOfDirective, IgxGridGroupByRowComponent, IgxGridHierarchicalPagingPipe, IgxGridHierarchicalPipe, IgxGridModule, IgxGridPinningActionsComponent, IgxGridRowComponent, IgxGridStateDirective, IgxGridStateModule, IgxGridToolbarActionsDirective, IgxGridToolbarAdvancedFilteringComponent, IgxGridToolbarComponent, IgxGridToolbarDirective, IgxGridToolbarExporterComponent, IgxGridToolbarHidingComponent, IgxGridToolbarPinningComponent, IgxGridToolbarTitleDirective, IgxGridTransaction, IgxGroupAreaDropDirective, IgxGroupByRowTemplateDirective, IgxGrouping, IgxHeaderCollapseIndicatorDirective, IgxHeaderExpandIndicatorDirective, IgxHierarchicalGridAPIService, IgxHierarchicalGridBaseDirective, IgxHierarchicalGridCellComponent, IgxHierarchicalGridComponent, IgxHierarchicalGridModule, IgxHierarchicalRowComponent, IgxHierarchicalTransactionService, IgxHierarchicalTransactionServiceFactory, IgxHintDirective, IgxIconComponent, IgxIconModule, IgxIconService, IgxInputDirective, IgxInputGroupComponent, IgxInputGroupModule, IgxInputState, IgxInsertDropStrategy, IgxLabelDirective, IgxLayoutDirective, IgxLayoutModule, IgxLeftButtonStyleDirective, IgxLinearProgressBarComponent, IgxListActionDirective, IgxListBaseDirective, IgxListComponent, IgxListItemComponent, IgxListItemLeftPanningTemplateDirective, IgxListItemRightPanningTemplateDirective, IgxListLineDirective, IgxListLineSubTitleDirective, IgxListLineTitleDirective, IgxListModule, IgxListPanState, IgxListThumbnailDirective, IgxMaskDirective, IgxMaskModule, IgxMonthPickerBaseDirective, IgxMonthPickerComponent, IgxMonthsViewComponent, IgxNavDrawerItemDirective, IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective, IgxNavbarActionDirective, IgxNavbarComponent, IgxNavbarModule, IgxNavbarTitleDirective, IgxNavigationCloseDirective, IgxNavigationDrawerComponent, IgxNavigationDrawerModule, IgxNavigationModule, IgxNavigationService, IgxNavigationToggleDirective, IgxNumberFilteringOperand, IgxNumberSummaryOperand, IgxOverlayOutletDirective, IgxOverlayService, IgxPaginatorComponent, IgxPaginatorModule, IgxPercentSummaryOperand, IgxPickerToggleComponent, IgxPrefixDirective, IgxPrefixModule, IgxPrependDropStrategy, IgxProgressBarModule, IgxProgressType, IgxRadioComponent, IgxRadioGroupDirective, IgxRadioModule, IgxRightButtonStyleDirective, IgxRippleDirective, IgxRippleModule, IgxRowCollapsedIndicatorDirective, IgxRowDirective, IgxRowExpandedIndicatorDirective, IgxRowIslandAPIService, IgxRowIslandComponent, IgxSelectComponent, IgxSelectFooterDirective, IgxSelectGroupComponent, IgxSelectHeaderDirective, IgxSelectItemComponent, IgxSelectModule, IgxSelectToggleIconDirective, IgxSliderComponent, IgxSliderModule, IgxSliderType, IgxSnackbarComponent, IgxSnackbarModule, IgxSorting, IgxSplitterComponent, IgxSplitterModule, IgxSplitterPaneComponent, IgxStringFilteringOperand, IgxSuffixDirective, IgxSuffixModule, IgxSummaryOperand, IgxSwitchComponent, IgxSwitchModule, IgxSwitchRequiredDirective, IgxTabComponent, IgxTabItemComponent, IgxTabItemTemplateDirective, IgxTabPanelComponent, IgxTabTemplateDirective, IgxTabsComponent, IgxTabsGroupComponent, IgxTabsModule, IgxTabsType, IgxTextAlign, IgxTextHighlightDirective, IgxTextHighlightModule, IgxTextSelectionDirective, IgxTextSelectionModule, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, IgxTickLabelTemplateDirective, IgxTimePickerComponent, IgxTimePickerModule, IgxToastComponent, IgxToastModule, IgxToastPosition, IgxToggleActionDirective, IgxToggleDirective, IgxToggleModule, IgxTooltipDirective, IgxTooltipModule, IgxTooltipTargetDirective, IgxTransactionService, IgxTreeGridAPIService, IgxTreeGridCellComponent, IgxTreeGridComponent, IgxTreeGridModule, IgxTreeGridRowComponent, IgxYearsViewComponent, InteractionMode, LabelPosition, NoOpScrollStrategy, NoopFilteringStrategy, NoopSortingStrategy, PagingError, Point, PredefinedFormatOptions, RadioGroupAlignment, RadioLabelPosition, RelativePosition, RelativePositionStrategy, RowEditPositionStrategy, RowPinningPosition, ScrollMonth, ScrollStrategy, SliderHandle, SortingDirection, SplitterType, SwitchLabelPosition, TickLabelsOrientation, TicksOrientation, TimePickerHammerConfig, TransactionEventOrigin, TransactionType, TreeGridFilteringStrategy, TreeGridFormattedValuesFilteringStrategy, VerticalAlignment, WEEKDAYS, blink, changei18n, fadeIn, fadeOut, filteringStateDefaults, flipBottom, flipHorBck, flipHorFwd, flipLeft, flipRight, flipTop, flipVerBck, flipVerFwd, getCurrentResourceStrings, getTypeNameForDebugging, growVerIn, growVerOut, heartbeat, hierarchicalTransactionServiceFactory, isDateInRanges, isLeap, monthRange, pulsateBck, pulsateFwd, range, rotateInBl, rotateInBottom, rotateInBr, rotateInCenter, rotateInDiagonal1, rotateInDiagonal2, rotateInHor, rotateInLeft, rotateInRight, rotateInTl, rotateInTop, rotateInTr, rotateInVer, rotateOutBl, rotateOutBottom, rotateOutBr, rotateOutCenter, rotateOutDiagonal1, rotateOutDiagonal2, rotateOutHor, rotateOutLeft, rotateOutRight, rotateOutTl, rotateOutTop, rotateOutTr, rotateOutVer, scaleInBl, scaleInBottom, scaleInBr, scaleInCenter, scaleInHorCenter, scaleInHorLeft, scaleInHorRight, scaleInLeft, scaleInRight, scaleInTl, scaleInTop, scaleInTr, scaleInVerBottom, scaleInVerCenter, scaleInVerTop, scaleOutBl, scaleOutBottom, scaleOutBr, scaleOutCenter, scaleOutHorCenter, scaleOutHorLeft, scaleOutHorRight, scaleOutLeft, scaleOutRight, scaleOutTl, scaleOutTop, scaleOutTr, scaleOutVerBottom, scaleOutVerCenter, scaleOutVerTop, shakeBl, shakeBottom, shakeBr, shakeCenter, shakeHor, shakeLeft, shakeRight, shakeTl, shakeTop, shakeTr, shakeVer, slideInBl, slideInBottom, slideInBr, slideInLeft, slideInRight, slideInTl, slideInTop, slideInTr, slideOutBl, slideOutBottom, slideOutBr, slideOutLeft, slideOutRight, slideOutTl, slideOutTop, slideOutTr, swingInBottomBck, swingInBottomFwd, swingInLeftBck, swingInLeftFwd, swingInRightBck, swingInRightFwd, swingInTopBck, swingInTopFwd, swingOutBottomBck, swingOutBottomFwd, swingOutLeftBck, swingOutLefttFwd, swingOutRightBck, swingOutRightFwd, swingOutTopBck, swingOutTopFwd, toPercent, valueInRange, weekDay, ɵ0$3 as ɵ0, ɵ1$1 as ɵ1, ɵ2, IgxActionStripMenuItemDirective as ɵa, IGX_DROPDOWN_BASE as ɵb, IgxBannerActionsDirective as ɵba, IgxExpansionPanelTitleDirective as ɵbb, IgxExpansionPanelDescriptionDirective as ɵbc, IgxExpansionPanelIconDirective as ɵbd, IgxDaysViewNavigationService as ɵbe, IgxDayItemComponent as ɵbf, IgxMonthViewSlotsCalendar as ɵbg, IgxGetViewDateCalendar as ɵbh, IgxCarouselIndicatorDirective as ɵbi, IgxCarouselNextButtonDirective as ɵbj, IgxCarouselPrevButtonDirective as ɵbk, IgxSlideComponent as ɵbl, IgxComboAPIService as ɵbm, IGX_COMBO_COMPONENT as ɵbn, IgxComboDropDownComponent as ɵbp, IgxComboItemComponent as ɵbq, IgxComboHeaderDirective as ɵbr, IgxComboFooterDirective as ɵbs, IgxComboItemDirective as ɵbt, IgxComboEmptyDirective as ɵbu, IgxComboHeaderItemDirective as ɵbv, IgxComboAddItemDirective as ɵbw, IgxComboToggleIconDirective as ɵbx, IgxComboClearIconDirective as ɵby, IgxComboFilteringPipe as ɵbz, IgxComboGroupingPipe as ɵca, IgxComboAddItemComponent as ɵcb, IgxDatePickerTemplateDirective as ɵcc, IgxDatePickerActionsDirective as ɵcd, IgxCalendarContainerComponent as ɵce, DatePickerDisplayValuePipe as ɵcf, DatePickerInputValuePipe as ɵcg, IGX_DATE_PICKER_COMPONENT as ɵch, IgxDialogTitleDirective as ɵcj, IgxDialogActionsDirective as ɵck, IgxExcelStyleCustomDialogComponent as ɵcl, IgxExcelStyleDefaultExpressionComponent as ɵcm, IgxExcelStyleDateExpressionComponent as ɵcn, HammerGesturesManager as ɵco, WatchChanges as ɵcp, WatchColumnChanges as ɵcq, notifyChanges as ɵcr, IgxGridHeaderGroupComponent as ɵcs, IgxGridHeaderComponent as ɵct, IgxColumnResizingService as ɵcu, IgxGridFilteringCellComponent as ɵcv, IgxFilteringService as ɵcw, IgxGridColumnResizerComponent as ɵcx, IgxColumnResizerDirective as ɵcy, IgxRowSelectorDirective as ɵcz, IgxGridCRUDService as ɵd, IgxGroupByRowSelectorDirective as ɵda, IgxHeadSelectorDirective as ɵdb, IgxRowDragDirective as ɵdc, IgxDragIndicatorIconDirective as ɵdd, IgxRowDragGhostDirective as ɵde, IgxRowDragModule as ɵdf, IgxGridFilteringRowComponent as ɵdg, IgxTemplateOutletDirective as ɵdh, IgxTemplateOutletModule as ɵdi, IgxRowEditTemplateDirective as ɵdj, IgxRowEditTextDirective as ɵdk, IgxRowEditActionsDirective as ɵdl, IgxRowEditTabStopDirective as ɵdm, IgxSummaryRowComponent as ɵdn, IgxSummaryCellComponent as ɵdo, IgxGridNavigationService as ɵdp, IgxGridSummaryService as ɵdq, ConnectedPositioningStrategy as ɵdr, IgxGridFooterComponent as ɵds, IgxAdvancedFilteringDialogComponent as ɵdt, IgxColumnHidingDirective as ɵdu, IgxColumnPinningDirective as ɵdv, IgxGridSharedModules as ɵdw, IgxProcessBarTextTemplateDirective as ɵdx, IgxProgressBarGradientDirective as ɵdy, DIR_DOCUMENT_FACTORY as ɵdz, IgxGridSelectionService as ɵe, DIR_DOCUMENT as ɵea, IgxDirectionality as ɵeb, IgxSelectItemNavigationDirective as ɵec, IgxGridPipesModule as ɵed, IgxGridCellStyleClassesPipe as ɵee, IgxGridCellStylesPipe as ɵef, IgxGridNotGroupedPipe as ɵeg, IgxGridTopLevelColumns as ɵeh, IgxGridFilterConditionPipe as ɵei, IgxGridTransactionPipe as ɵej, IgxGridPaginatorOptionsPipe as ɵek, IgxHasVisibleColumnsPipe as ɵel, IgxGridRowPinningPipe as ɵem, IgxColumnActionEnabledPipe as ɵen, IgxFilterActionColumnsPipe as ɵeo, IgxSortActionColumnsPipe as ɵep, IgxGridDataMapperPipe as ɵeq, IgxStringReplacePipe as ɵer, IgxGridTransactionStatePipe as ɵes, IgxColumnFormatterPipe as ɵet, IgxGridAddRowPipe as ɵeu, IgxGridColumnModule as ɵev, IgxGridHeadersModule as ɵew, SortingIndexPipe as ɵex, IgxGridFilteringModule as ɵey, IgxColumnMovingModule as ɵez, IgxColumnMovingDropDirective as ɵfa, IgxColumnMovingService as ɵfb, IgxColumnMovingDragDirective as ɵfc, IgxGridResizingModule as ɵfd, IgxResizeHandleDirective as ɵfe, IgxGridExcelStyleFilteringModule as ɵff, IgxGridSelectionModule as ɵfg, IgxGridDragSelectDirective as ɵfh, IgxGridSummaryModule as ɵfi, IgxSummaryDataPipe as ɵfj, IgxGridToolbarModule as ɵfk, BaseToolbarDirective as ɵfl, BaseToolbarColumnActionsDirective as ɵfm, IgxGridSortingPipe as ɵfn, IgxGridGroupingPipe as ɵfo, IgxGridPagingPipe as ɵfp, IgxGridFilteringPipe as ɵfq, IgxGridSummaryPipe as ɵfr, IgxGridDetailsPipe as ɵfs, IgxTreeGridSelectionService as ɵft, IgxRowLoadingIndicatorTemplateDirective as ɵfu, IgxTreeGridHierarchizingPipe as ɵfv, IgxTreeGridFlatteningPipe as ɵfw, IgxTreeGridSortingPipe as ɵfx, IgxTreeGridPagingPipe as ɵfy, IgxTreeGridTransactionPipe as ɵfz, IGX_EXPANSION_PANEL_COMPONENT as ɵg, IgxTreeGridNormalizeRecordsPipe as ɵga, IgxTreeGridFilteringPipe as ɵgb, IgxTreeGridSummaryPipe as ɵgc, IgxHierarchicalGridNavigationService as ɵgd, IgxChildGridRowComponent as ɵge, IgxSliderThumbComponent as ɵgf, IgxThumbLabelComponent as ɵgg, IgxTicksComponent as ɵgh, IgxTickLabelsPipe as ɵgi, IgxTabsBase as ɵgj, IgxTabItemBase as ɵgk, IgxTabsGroupBase as ɵgl, IGX_TIME_PICKER_COMPONENT as ɵgm, IgxItemListDirective as ɵgo, IgxHourItemDirective as ɵgp, IgxMinuteItemDirective as ɵgq, IgxSecondsItemDirective as ɵgr, IgxAmPmItemDirective as ɵgs, IgxTimePickerTemplateDirective as ɵgt, IgxTimePickerActionsDirective as ɵgu, TimeDisplayFormatPipe as ɵgv, TimeInputFormatPipe as ɵgw, IgxSplitBarComponent as ɵgx, PlatformUtil as ɵh, EaseIn as ɵi, EaseOut as ɵj, IgxInputGroupBase as ɵk, IgxSelectionAPIService as ɵl, IgxForOfSyncService as ɵm, IgxForOfScrollSyncService as ɵn, DisplayContainerComponent as ɵo, VirtualHelperComponent as ɵp, VirtualHelperBaseDirective as ɵq, HVirtualHelperComponent as ɵr, IgxScrollInertiaDirective as ɵs, IgxScrollInertiaModule as ɵt, DeprecateMethod as ɵu, DeprecateProperty as ɵv, MaskParsingService as ɵw, isHierarchyMatch as ɵx, getHierarchy as ɵy, IgxGridActionButtonComponent as ɵz };
//# sourceMappingURL=igniteui-angular.js.map
