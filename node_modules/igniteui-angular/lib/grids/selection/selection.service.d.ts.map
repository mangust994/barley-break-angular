{"version":3,"file":"selection.service.d.ts","sources":["selection.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA","sourcesContent":["import { EventEmitter, NgZone } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { IGridEditEventArgs, IGridEditDoneEventArgs } from '../common/events';\nimport { GridType } from '../common/grid.interface';\nimport { IgxGridBaseDirective } from '../grid/public_api';\nexport interface GridSelectionRange {\n    rowStart: number;\n    rowEnd: number;\n    columnStart: string | number;\n    columnEnd: string | number;\n}\nexport interface ISelectionNode {\n    row: number;\n    column: number;\n    layout?: IMultiRowLayoutNode;\n    isSummaryRow?: boolean;\n}\nexport interface IMultiRowLayoutNode {\n    rowStart: number;\n    colStart: number;\n    rowEnd: number;\n    colEnd: number;\n    columnVisibleIndex: number;\n}\ninterface ISelectionKeyboardState {\n    node: null | ISelectionNode;\n    shift: boolean;\n    range: GridSelectionRange;\n    active: boolean;\n}\ninterface ISelectionPointerState extends ISelectionKeyboardState {\n    ctrl: boolean;\n    primaryButton: boolean;\n}\ninterface IColumnSelectionState {\n    field: null | string;\n    range: string[];\n}\ndeclare type SelectionState = ISelectionKeyboardState | ISelectionPointerState;\nexport declare class IgxRow {\n    id: any;\n    index: number;\n    data: any;\n    grid: IgxGridBaseDirective & GridType;\n    transactionState: any;\n    state: any;\n    newData: any;\n    isAddRow: boolean;\n    constructor(id: any, index: number, data: any, grid: IgxGridBaseDirective & GridType);\n    createEditEventArgs(includeNewValue?: boolean, event?: Event): IGridEditEventArgs;\n    createDoneEditEventArgs(cachedRowData: any, event?: Event): IGridEditDoneEventArgs;\n}\nexport declare class IgxCell {\n    id: any;\n    rowIndex: number;\n    column: any;\n    value: any;\n    editValue: any;\n    rowData: any;\n    grid: IgxGridBaseDirective & GridType;\n    primaryKey: any;\n    state: any;\n    constructor(id: any, rowIndex: number, column: any, value: any, editValue: any, rowData: any, grid: IgxGridBaseDirective & GridType);\n    castToNumber(value: any): any;\n    createEditEventArgs(includeNewValue?: boolean, event?: Event): IGridEditEventArgs;\n    createDoneEditEventArgs(value: any, event?: Event): IGridEditDoneEventArgs;\n}\nexport declare class IgxGridCRUDService {\n    grid: IgxGridBaseDirective & GridType;\n    cell: IgxCell | null;\n    row: IgxRow | null;\n    isInCompositionMode: boolean;\n    private _cellEditingBlocked;\n    private _rowEditingBlocked;\n    createCell(cell: any): IgxCell;\n    createRow(cell: IgxCell): IgxRow;\n    sameRow(rowID: any): boolean;\n    sameCell(cell: IgxCell): boolean;\n    get cellInEditMode(): boolean;\n    get rowInEditMode(): boolean;\n    get rowEditing(): boolean;\n    get primaryKey(): any;\n    get cellEditingBlocked(): boolean;\n    set cellEditingBlocked(val: boolean);\n    get rowEditingBlocked(): boolean;\n    set rowEditingBlocked(val: boolean);\n    enterEditMode(cell: any, event?: Event): void;\n    /** Enters row edit mode */\n    beginRowEdit(newCell: any, event?: Event): boolean;\n    /** Exit row edit mode */\n    exitRowEdit(commit: boolean, event?: Event): boolean;\n    /** Enters cell edit mode */\n    beginAddRow(cell: any, event?: Event): void;\n    beginCellEdit(newCell: any, event?: Event): void;\n    /** Exit cell edit mode */\n    exitCellEdit(event?: Event): boolean;\n    /** Clears cell editing state */\n    endCellEdit(): void;\n    /** Clears row editing state */\n    endRowEdit(): void;\n    /** Clears cell and row editing state and closes row editing template if it is open */\n    endEditMode(): void;\n    /** Returns whether the targeted cell is in edit mode */\n    targetInEdit(rowIndex: number, columnIndex: number): boolean;\n}\nexport declare class IgxGridSelectionService {\n    private zone;\n    grid: any;\n    dragMode: boolean;\n    activeElement: ISelectionNode | null;\n    keyboardState: ISelectionKeyboardState;\n    pointerState: ISelectionPointerState;\n    columnsState: IColumnSelectionState;\n    selection: Map<number, Set<number>>;\n    temp: Map<number, Set<number>>;\n    _ranges: Set<string>;\n    _selectionRange: Range;\n    rowSelection: Set<any>;\n    indeterminateRows: Set<any>;\n    columnSelection: Set<string>;\n    /**\n     * @hidden @internal\n     */\n    selectedRowsChange: Subject<unknown>;\n    private allRowsSelected;\n    /**\n     * Returns the current selected ranges in the grid from both\n     * keyboard and pointer interactions\n     */\n    get ranges(): GridSelectionRange[];\n    get primaryButton(): boolean;\n    set primaryButton(value: boolean);\n    constructor(zone: NgZone);\n    /**\n     * Resets the keyboard state\n     */\n    initKeyboardState(): void;\n    /**\n     * Resets the pointer state\n     */\n    initPointerState(): void;\n    /**\n     * Resets the columns state\n     */\n    initColumnsState(): void;\n    /**\n     * Adds a single node.\n     * Single clicks | Ctrl + single clicks on cells is the usual case.\n     */\n    add(node: ISelectionNode, addToRange?: boolean): void;\n    /**\n     * Adds the active keyboard range selection (if any) to the `ranges` meta.\n     */\n    addKeyboardRange(): void;\n    remove(node: ISelectionNode): void;\n    isInMap(node: ISelectionNode): boolean;\n    selected(node: ISelectionNode): boolean;\n    isActiveNode(node: ISelectionNode): boolean;\n    isActiveLayout(current: IMultiRowLayoutNode, target: IMultiRowLayoutNode): boolean;\n    addRangeMeta(node: ISelectionNode, state?: SelectionState): void;\n    removeRangeMeta(node: ISelectionNode, state?: SelectionState): void;\n    /**\n     * Generates a new selection range from the given `node`.\n     * If `state` is passed instead it will generate the range based on the passed `node`\n     * and the start node of the `state`.\n     */\n    generateRange(node: ISelectionNode, state?: SelectionState): GridSelectionRange;\n    /**\n     *\n     */\n    keyboardStateOnKeydown(node: ISelectionNode, shift: boolean, shiftTab: boolean): void;\n    keyboardStateOnFocus(node: ISelectionNode, emitter: EventEmitter<GridSelectionRange>, dom: any): void;\n    pointerDown(node: ISelectionNode, shift: boolean, ctrl: boolean): void;\n    pointerDownShiftKey(node: ISelectionNode): void;\n    mergeMap(target: Map<number, Set<number>>, source: Map<number, Set<number>>): void;\n    pointerEnter(node: ISelectionNode, event: PointerEvent): boolean;\n    pointerUp(node: ISelectionNode, emitter: EventEmitter<GridSelectionRange>): boolean;\n    selectRange(node: ISelectionNode, state: SelectionState, collection?: Map<number, Set<number>>): void;\n    dragSelect(node: ISelectionNode, state: SelectionState): void;\n    clear(clearAcriveEl?: boolean): void;\n    clearTextSelection(): void;\n    restoreTextSelection(): void;\n    /**\n     * (╯°□°）╯︵ ┻━┻\n     * Chrome and Chromium don't care about the active\n     * range after keyboard navigation, thus this.\n     */\n    _moveSelectionChrome(node: Node): void;\n    /** Returns array of the selected row id's. */\n    getSelectedRows(): Array<any>;\n    /** Returns array of the rows in indeterminate state. */\n    getIndeterminateRows(): Array<any>;\n    /** Clears row selection, if filtering is applied clears only selected rows from filtered data. */\n    clearRowSelection(event?: any): void;\n    /** Select all rows, if filtering is applied select only from filtered data. */\n    selectAllRows(event?: any): void;\n    /** Select the specified row and emit event. */\n    selectRowById(rowID: any, clearPrevSelection?: any, event?: any): void;\n    /** Deselect the specified row and emit event. */\n    deselectRow(rowID: any, event?: any): void;\n    /** Select specified rows. No event is emitted. */\n    selectRowsWithNoEvent(rowIDs: any[], clearPrevSelection?: any): void;\n    /** Deselect specified rows. No event is emitted. */\n    deselectRowsWithNoEvent(rowIDs: any[]): void;\n    isRowSelected(rowID: any): boolean;\n    isRowInIndeterminateState(rowID: any): boolean;\n    /** Select range from last selected row to the current specified row. */\n    selectMultipleRows(rowID: any, rowData: any, event?: any): void;\n    areAllRowSelected(): boolean;\n    hasSomeRowSelected(): boolean;\n    get filteredSelectedRowIds(): any[];\n    emitRowSelectionEvent(newSelection: any, added: any, removed: any, event?: any): boolean;\n    getRowDataById(rowID: any): any;\n    getRowIDs(data: any): Array<any>;\n    clearHeaderCBState(): void;\n    /** Clear rowSelection and update checkbox state */\n    clearAllSelectedRows(): void;\n    /** Returns all data in the grid, with applied filtering and sorting and without deleted rows. */\n    get allData(): Array<any>;\n    /** Returns array of the selected columns fields. */\n    getSelectedColumns(): Array<any>;\n    isColumnSelected(field: string): boolean;\n    /** Select the specified column and emit event. */\n    selectColumn(field: string, clearPrevSelection?: any, selectColumnsRange?: any, event?: any): void;\n    /** Select specified columns. And emit event. */\n    selectColumns(fields: string[], clearPrevSelection?: any, selectColumnsRange?: any, event?: any): void;\n    /** Select range from last clicked column to the current specified column. */\n    selectColumnsRange(field: string, event: any): void;\n    /** Select specified columns. No event is emitted. */\n    selectColumnsWithNoEvent(fields: string[], clearPrevSelection?: any): void;\n    /** Deselect the specified column and emit event. */\n    deselectColumn(field: string, event?: any): void;\n    /** Deselect specified columns. No event is emitted. */\n    deselectColumnsWithNoEvent(fields: string[]): void;\n    /** Deselect specified columns. And emit event. */\n    deselectColumns(fields: string[], event?: any): void;\n    emitColumnSelectionEvent(newSelection: any, added: any, removed: any, event?: any): boolean;\n    /** Clear columnSelection */\n    clearAllSelectedColumns(): void;\n    protected areEqualCollections(first: any, second: any): boolean;\n    private isFilteringApplied;\n    private isRowDeleted;\n}\nexport declare const isChromium: () => boolean;\nexport {};\n"]}