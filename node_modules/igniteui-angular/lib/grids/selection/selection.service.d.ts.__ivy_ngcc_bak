import { EventEmitter, NgZone } from '@angular/core';
import { Subject } from 'rxjs';
import { IGridEditEventArgs, IGridEditDoneEventArgs } from '../common/events';
import { GridType } from '../common/grid.interface';
import { IgxGridBaseDirective } from '../grid/public_api';
export interface GridSelectionRange {
    rowStart: number;
    rowEnd: number;
    columnStart: string | number;
    columnEnd: string | number;
}
export interface ISelectionNode {
    row: number;
    column: number;
    layout?: IMultiRowLayoutNode;
    isSummaryRow?: boolean;
}
export interface IMultiRowLayoutNode {
    rowStart: number;
    colStart: number;
    rowEnd: number;
    colEnd: number;
    columnVisibleIndex: number;
}
interface ISelectionKeyboardState {
    node: null | ISelectionNode;
    shift: boolean;
    range: GridSelectionRange;
    active: boolean;
}
interface ISelectionPointerState extends ISelectionKeyboardState {
    ctrl: boolean;
    primaryButton: boolean;
}
interface IColumnSelectionState {
    field: null | string;
    range: string[];
}
declare type SelectionState = ISelectionKeyboardState | ISelectionPointerState;
export declare class IgxRow {
    id: any;
    index: number;
    data: any;
    grid: IgxGridBaseDirective & GridType;
    transactionState: any;
    state: any;
    newData: any;
    isAddRow: boolean;
    constructor(id: any, index: number, data: any, grid: IgxGridBaseDirective & GridType);
    createEditEventArgs(includeNewValue?: boolean, event?: Event): IGridEditEventArgs;
    createDoneEditEventArgs(cachedRowData: any, event?: Event): IGridEditDoneEventArgs;
}
export declare class IgxCell {
    id: any;
    rowIndex: number;
    column: any;
    value: any;
    editValue: any;
    rowData: any;
    grid: IgxGridBaseDirective & GridType;
    primaryKey: any;
    state: any;
    constructor(id: any, rowIndex: number, column: any, value: any, editValue: any, rowData: any, grid: IgxGridBaseDirective & GridType);
    castToNumber(value: any): any;
    createEditEventArgs(includeNewValue?: boolean, event?: Event): IGridEditEventArgs;
    createDoneEditEventArgs(value: any, event?: Event): IGridEditDoneEventArgs;
}
export declare class IgxGridCRUDService {
    grid: IgxGridBaseDirective & GridType;
    cell: IgxCell | null;
    row: IgxRow | null;
    isInCompositionMode: boolean;
    private _cellEditingBlocked;
    private _rowEditingBlocked;
    createCell(cell: any): IgxCell;
    createRow(cell: IgxCell): IgxRow;
    sameRow(rowID: any): boolean;
    sameCell(cell: IgxCell): boolean;
    get cellInEditMode(): boolean;
    get rowInEditMode(): boolean;
    get rowEditing(): boolean;
    get primaryKey(): any;
    get cellEditingBlocked(): boolean;
    set cellEditingBlocked(val: boolean);
    get rowEditingBlocked(): boolean;
    set rowEditingBlocked(val: boolean);
    enterEditMode(cell: any, event?: Event): void;
    /** Enters row edit mode */
    beginRowEdit(newCell: any, event?: Event): boolean;
    /** Exit row edit mode */
    exitRowEdit(commit: boolean, event?: Event): boolean;
    /** Enters cell edit mode */
    beginAddRow(cell: any, event?: Event): void;
    beginCellEdit(newCell: any, event?: Event): void;
    /** Exit cell edit mode */
    exitCellEdit(event?: Event): boolean;
    /** Clears cell editing state */
    endCellEdit(): void;
    /** Clears row editing state */
    endRowEdit(): void;
    /** Clears cell and row editing state and closes row editing template if it is open */
    endEditMode(): void;
    /** Returns whether the targeted cell is in edit mode */
    targetInEdit(rowIndex: number, columnIndex: number): boolean;
}
export declare class IgxGridSelectionService {
    private zone;
    grid: any;
    dragMode: boolean;
    activeElement: ISelectionNode | null;
    keyboardState: ISelectionKeyboardState;
    pointerState: ISelectionPointerState;
    columnsState: IColumnSelectionState;
    selection: Map<number, Set<number>>;
    temp: Map<number, Set<number>>;
    _ranges: Set<string>;
    _selectionRange: Range;
    rowSelection: Set<any>;
    indeterminateRows: Set<any>;
    columnSelection: Set<string>;
    /**
     * @hidden @internal
     */
    selectedRowsChange: Subject<unknown>;
    private allRowsSelected;
    /**
     * Returns the current selected ranges in the grid from both
     * keyboard and pointer interactions
     */
    get ranges(): GridSelectionRange[];
    get primaryButton(): boolean;
    set primaryButton(value: boolean);
    constructor(zone: NgZone);
    /**
     * Resets the keyboard state
     */
    initKeyboardState(): void;
    /**
     * Resets the pointer state
     */
    initPointerState(): void;
    /**
     * Resets the columns state
     */
    initColumnsState(): void;
    /**
     * Adds a single node.
     * Single clicks | Ctrl + single clicks on cells is the usual case.
     */
    add(node: ISelectionNode, addToRange?: boolean): void;
    /**
     * Adds the active keyboard range selection (if any) to the `ranges` meta.
     */
    addKeyboardRange(): void;
    remove(node: ISelectionNode): void;
    isInMap(node: ISelectionNode): boolean;
    selected(node: ISelectionNode): boolean;
    isActiveNode(node: ISelectionNode): boolean;
    isActiveLayout(current: IMultiRowLayoutNode, target: IMultiRowLayoutNode): boolean;
    addRangeMeta(node: ISelectionNode, state?: SelectionState): void;
    removeRangeMeta(node: ISelectionNode, state?: SelectionState): void;
    /**
     * Generates a new selection range from the given `node`.
     * If `state` is passed instead it will generate the range based on the passed `node`
     * and the start node of the `state`.
     */
    generateRange(node: ISelectionNode, state?: SelectionState): GridSelectionRange;
    /**
     *
     */
    keyboardStateOnKeydown(node: ISelectionNode, shift: boolean, shiftTab: boolean): void;
    keyboardStateOnFocus(node: ISelectionNode, emitter: EventEmitter<GridSelectionRange>, dom: any): void;
    pointerDown(node: ISelectionNode, shift: boolean, ctrl: boolean): void;
    pointerDownShiftKey(node: ISelectionNode): void;
    mergeMap(target: Map<number, Set<number>>, source: Map<number, Set<number>>): void;
    pointerEnter(node: ISelectionNode, event: PointerEvent): boolean;
    pointerUp(node: ISelectionNode, emitter: EventEmitter<GridSelectionRange>): boolean;
    selectRange(node: ISelectionNode, state: SelectionState, collection?: Map<number, Set<number>>): void;
    dragSelect(node: ISelectionNode, state: SelectionState): void;
    clear(clearAcriveEl?: boolean): void;
    clearTextSelection(): void;
    restoreTextSelection(): void;
    /**
     * (╯°□°）╯︵ ┻━┻
     * Chrome and Chromium don't care about the active
     * range after keyboard navigation, thus this.
     */
    _moveSelectionChrome(node: Node): void;
    /** Returns array of the selected row id's. */
    getSelectedRows(): Array<any>;
    /** Returns array of the rows in indeterminate state. */
    getIndeterminateRows(): Array<any>;
    /** Clears row selection, if filtering is applied clears only selected rows from filtered data. */
    clearRowSelection(event?: any): void;
    /** Select all rows, if filtering is applied select only from filtered data. */
    selectAllRows(event?: any): void;
    /** Select the specified row and emit event. */
    selectRowById(rowID: any, clearPrevSelection?: any, event?: any): void;
    /** Deselect the specified row and emit event. */
    deselectRow(rowID: any, event?: any): void;
    /** Select specified rows. No event is emitted. */
    selectRowsWithNoEvent(rowIDs: any[], clearPrevSelection?: any): void;
    /** Deselect specified rows. No event is emitted. */
    deselectRowsWithNoEvent(rowIDs: any[]): void;
    isRowSelected(rowID: any): boolean;
    isRowInIndeterminateState(rowID: any): boolean;
    /** Select range from last selected row to the current specified row. */
    selectMultipleRows(rowID: any, rowData: any, event?: any): void;
    areAllRowSelected(): boolean;
    hasSomeRowSelected(): boolean;
    get filteredSelectedRowIds(): any[];
    emitRowSelectionEvent(newSelection: any, added: any, removed: any, event?: any): boolean;
    getRowDataById(rowID: any): any;
    getRowIDs(data: any): Array<any>;
    clearHeaderCBState(): void;
    /** Clear rowSelection and update checkbox state */
    clearAllSelectedRows(): void;
    /** Returns all data in the grid, with applied filtering and sorting and without deleted rows. */
    get allData(): Array<any>;
    /** Returns array of the selected columns fields. */
    getSelectedColumns(): Array<any>;
    isColumnSelected(field: string): boolean;
    /** Select the specified column and emit event. */
    selectColumn(field: string, clearPrevSelection?: any, selectColumnsRange?: any, event?: any): void;
    /** Select specified columns. And emit event. */
    selectColumns(fields: string[], clearPrevSelection?: any, selectColumnsRange?: any, event?: any): void;
    /** Select range from last clicked column to the current specified column. */
    selectColumnsRange(field: string, event: any): void;
    /** Select specified columns. No event is emitted. */
    selectColumnsWithNoEvent(fields: string[], clearPrevSelection?: any): void;
    /** Deselect the specified column and emit event. */
    deselectColumn(field: string, event?: any): void;
    /** Deselect specified columns. No event is emitted. */
    deselectColumnsWithNoEvent(fields: string[]): void;
    /** Deselect specified columns. And emit event. */
    deselectColumns(fields: string[], event?: any): void;
    emitColumnSelectionEvent(newSelection: any, added: any, removed: any, event?: any): boolean;
    /** Clear columnSelection */
    clearAllSelectedColumns(): void;
    protected areEqualCollections(first: any, second: any): boolean;
    private isFilteringApplied;
    private isRowDeleted;
}
export declare const isChromium: () => boolean;
export {};
