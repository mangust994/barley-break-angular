{"version":3,"file":"state.directive.d.ts","sources":["state.directive.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { ComponentFactoryResolver, ViewContainerRef } from '@angular/core';\nimport { ISortingExpression } from '../data-operations/sorting-expression.interface';\nimport { IFilteringExpressionsTree } from '../data-operations/filtering-expressions-tree';\nimport { IPagingState } from '../data-operations/paging-state.interface';\nimport { DataType } from '../data-operations/data-util';\nimport { GridSelectionRange } from './selection/selection.service';\nimport { IGroupingState } from '../data-operations/groupby-state.interface';\nimport { IgxGridBaseDirective } from './grid-base.directive';\nimport { IPinningConfig } from './grid.common';\nexport interface IGridState {\n    columns?: IColumnState[];\n    filtering?: IFilteringExpressionsTree;\n    advancedFiltering?: IFilteringExpressionsTree;\n    paging?: IPagingState;\n    sorting?: ISortingExpression[];\n    groupBy?: IGroupingState;\n    cellSelection?: GridSelectionRange[];\n    rowSelection?: any[];\n    columnSelection?: string[];\n    rowPinning?: any[];\n    pinningConfig?: IPinningConfig;\n    expansion?: any[];\n    rowIslands?: IGridStateCollection[];\n    id?: string;\n}\nexport interface IGridStateCollection {\n    id: string;\n    parentRowID: any;\n    state: IGridState;\n}\nexport interface IGridStateOptions {\n    columns?: boolean;\n    filtering?: boolean;\n    advancedFiltering?: boolean;\n    sorting?: boolean;\n    groupBy?: boolean;\n    paging?: boolean;\n    cellSelection?: boolean;\n    rowSelection?: boolean;\n    columnSelection?: boolean;\n    rowPinning?: boolean;\n    pinningConfig?: boolean;\n    expansion?: boolean;\n    rowIslands?: boolean;\n}\nexport interface IColumnState {\n    pinned: boolean;\n    sortable: boolean;\n    filterable: boolean;\n    editable: boolean;\n    sortingIgnoreCase: boolean;\n    filteringIgnoreCase: boolean;\n    headerClasses: string;\n    headerGroupClasses: string;\n    maxWidth: string;\n    groupable: boolean;\n    movable: boolean;\n    hidden: boolean;\n    dataType: DataType;\n    hasSummary: boolean;\n    field: string;\n    width: any;\n    header: string;\n    resizable: boolean;\n    searchable: boolean;\n}\nexport declare type GridFeatures = keyof IGridStateOptions;\nexport declare class IgxGridStateDirective {\n    grid: IgxGridBaseDirective;\n    private resolver;\n    private viewRef;\n    private featureKeys;\n    private state;\n    private currGrid;\n    private _options;\n    private FEATURES;\n    /**\n     *  An object with options determining if a certain feature state should be saved.\n     * ```html\n     * <igx-grid [igxGridState]=\"options\"></igx-grid>\n     * ```\n     * ```typescript\n     * public options = {selection: false, advancedFiltering: false};\n     * ```\n     */\n    get options(): IGridStateOptions;\n    set options(value: IGridStateOptions);\n    /**\n     * @hidden\n     */\n    constructor(grid: IgxGridBaseDirective, resolver: ComponentFactoryResolver, viewRef: ViewContainerRef);\n    /**\n     * Gets the state of a feature or states of all grid features, unless a certain feature is disabled through the `options` property.\n     *\n     * @param `serialize` determines whether the returned object will be serialized to JSON string. Default value is true.\n     * @param `feature` string or array of strings determining the features to be added in the state. If skipped, all features are added.\n     * @returns Returns the serialized to JSON string IGridState object, or the non-serialized IGridState object.\n     * ```html\n     * <igx-grid [igxGridState]=\"options\"></igx-grid>\n     * ```\n     * ```typescript\n     * @ViewChild(IgxGridStateDirective, { static: true }) public state;\n     * let state = this.state.getState(); // returns string\n     * let state = this.state(false) // returns `IGridState` object\n     * ```\n     */\n    getState(serialize?: boolean, features?: GridFeatures | GridFeatures[]): IGridState | string;\n    /**\n     * Restores grid features' state based on the IGridState object passed as an argument.\n     *\n     * @param IGridState object to restore state from.\n     * @returns\n     * ```html\n     * <igx-grid [igxGridState]=\"options\"></igx-grid>\n     * ```\n     * ```typescript\n     * @ViewChild(IgxGridStateDirective, { static: true }) public state;\n     * this.state.setState(gridState);\n     * ```\n     */\n    setState(state: IGridState | string, features?: GridFeatures | GridFeatures[]): void;\n    /**\n     * Builds an IGridState object.\n     */\n    private buildState;\n    /**\n     * The method that calls corresponding methods to restore features from the passed IGridState object.\n     */\n    private restoreGridState;\n    /**\n     * Returns a collection of all grid features.\n     */\n    private applyFeatures;\n    /**\n     * This method builds a FilteringExpressionsTree from a provided object.\n     */\n    private createExpressionsTreeFromObject;\n    /**\n     * Returns the filtering logic function for a given dataType and condition (contains, greaterThan, etc.)\n     */\n    private generateFilteringCondition;\n    private stringifyCallback;\n    private getFeature;\n}\n/**\n * @hidden\n */\nexport declare class IgxGridStateModule {\n}\n"]}