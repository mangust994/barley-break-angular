{"version":3,"file":"igx-transaction.d.ts","sources":["igx-transaction.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { Transaction, State, StateUpdateEvent, Action } from './transaction';\nimport { IgxBaseTransactionService } from './base-transaction';\nimport { EventEmitter } from '@angular/core';\nexport declare class IgxTransactionService<T extends Transaction, S extends State> extends IgxBaseTransactionService<T, S> {\n    /**\n     * @inheritdoc\n     */\n    onStateUpdate: EventEmitter<StateUpdateEvent>;\n    protected _transactions: T[];\n    protected _redoStack: Action<T>[][];\n    protected _undoStack: Action<T>[][];\n    protected _states: Map<any, S>;\n    /**\n     * @inheritdoc\n     */\n    get canUndo(): boolean;\n    /**\n     * @inheritdoc\n     */\n    get canRedo(): boolean;\n    /**\n     * @inheritdoc\n     */\n    add(transaction: T, recordRef?: any): void;\n    /**\n     * @inheritdoc\n     */\n    getTransactionLog(id?: any): T[];\n    /**\n     * @inheritdoc\n     */\n    getAggregatedChanges(mergeChanges: boolean): T[];\n    /**\n     * @inheritdoc\n     */\n    getState(id: any, pending?: boolean): S;\n    /**\n     * @inheritdoc\n     */\n    get enabled(): boolean;\n    /**\n     * @inheritdoc\n     */\n    getAggregatedValue(id: any, mergeChanges: boolean): any;\n    /**\n     * @inheritdoc\n     */\n    endPending(commit: boolean): void;\n    /**\n     * @inheritdoc\n     */\n    commit(data: any[], id?: any): void;\n    /**\n     * @inheritdoc\n     */\n    clear(id?: any): void;\n    /**\n     * @inheritdoc\n     */\n    undo(): void;\n    /**\n     * @inheritdoc\n     */\n    redo(): void;\n    protected addTransaction(transaction: T, states: Map<any, S>, recordRef?: any): void;\n    /**\n     * Verifies if the passed transaction is correct. If not throws an exception.\n     *\n     * @param transaction Transaction to be verified\n     */\n    protected verifyAddedTransaction(states: Map<any, S>, transaction: T, recordRef?: any): void;\n    /**\n     * Updates the provided states collection according to passed transaction and recordRef\n     *\n     * @param states States collection to apply the update to\n     * @param transaction Transaction to apply to the current state\n     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied\n     */\n    protected updateState(states: Map<any, S>, transaction: T, recordRef?: any): void;\n    /**\n     * Compares the state with recordRef and clears all duplicated values. If any state ends as\n     * empty object removes it from states.\n     *\n     * @param state State to clean\n     */\n    protected cleanState(id: any, states: Map<any, S>): void;\n    /**\n     * Updates state related record in the provided data\n     *\n     * @param data Data source to update\n     * @param state State to update data from\n     */\n    protected updateRecord(data: any[], state: S): void;\n}\n"]}