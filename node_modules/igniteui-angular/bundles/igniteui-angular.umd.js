(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/animations'), require('@angular/core'), require('@angular/forms'), require('@angular/common'), require('rxjs'), require('rxjs/operators'), require('lodash.mergewith'), require('resize-observer-polyfill'), require('jszip'), require('@angular/platform-browser'), require('@igniteui/material-icons-extended'), require('igniteui-trial-watermark'), require('uuid')) :
    typeof define === 'function' && define.amd ? define('igniteui-angular', ['exports', '@angular/animations', '@angular/core', '@angular/forms', '@angular/common', 'rxjs', 'rxjs/operators', 'lodash.mergewith', 'resize-observer-polyfill', 'jszip', '@angular/platform-browser', '@igniteui/material-icons-extended', 'igniteui-trial-watermark', 'uuid'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['igniteui-angular'] = {}, global.ng.animations, global.ng.core, global.ng.forms, global.ng.common, global.rxjs, global.rxjs.operators, global.mergeWith, global.ResizeObserver, global.JSZip, global.ng.platformBrowser, global.materialIconsExtended, null, global.uuid));
}(this, (function (exports, i1, i0, forms, i2, rxjs, operators, mergeWith, ResizeObserver, JSZip, i1$1, materialIconsExtended, igniteuiTrialWatermark, uuid) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var mergeWith__default = /*#__PURE__*/_interopDefaultLegacy(mergeWith);
    var ResizeObserver__default = /*#__PURE__*/_interopDefaultLegacy(ResizeObserver);
    var JSZip__default = /*#__PURE__*/_interopDefaultLegacy(JSZip);

    (function (EaseIn) {
        EaseIn[EaseIn["Quad"] = "cubic-bezier(0.550, 0.085, 0.680, 0.530)"] = "Quad";
        EaseIn[EaseIn["Cubic"] = "cubic-bezier(0.550, 0.055, 0.675, 0.190)"] = "Cubic";
        EaseIn[EaseIn["Quart"] = "cubic-bezier(0.895, 0.030, 0.685, 0.220)"] = "Quart";
        EaseIn[EaseIn["Quint"] = "cubic-bezier(0.755, 0.050, 0.855, 0.060)"] = "Quint";
        EaseIn[EaseIn["Sine"] = "cubic-bezier(0.470, 0.000, 0.745, 0.715)"] = "Sine";
        EaseIn[EaseIn["Expo"] = "cubic-bezier(0.950, 0.050, 0.795, 0.035)"] = "Expo";
        EaseIn[EaseIn["Circ"] = "cubic-bezier(0.600, 0.040, 0.980, 0.335)"] = "Circ";
        EaseIn[EaseIn["Back"] = "cubic-bezier(0.600, -0.280, 0.735, 0.045)"] = "Back";
    })(exports.ɵi || (exports.ɵi = {}));

    (function (EaseOut) {
        EaseOut[EaseOut["Quad"] = "cubic-bezier(0.250, 0.460, 0.450, 0.940)"] = "Quad";
        EaseOut[EaseOut["Cubic"] = "cubic-bezier(0.215, 0.610, 0.355, 1.000)"] = "Cubic";
        EaseOut[EaseOut["Quart"] = "cubic-bezier(0.165, 0.840, 0.440, 1.000)"] = "Quart";
        EaseOut[EaseOut["Quint"] = "cubic-bezier(0.230, 1.000, 0.320, 1.000)"] = "Quint";
        EaseOut[EaseOut["Sine"] = "cubic-bezier(0.390, 0.575, 0.565, 1.000)"] = "Sine";
        EaseOut[EaseOut["Expo"] = "cubic-bezier(0.190, 1.000, 0.220, 1.000)"] = "Expo";
        EaseOut[EaseOut["Circ"] = "cubic-bezier(0.075, 0.820, 0.165, 1.000)"] = "Circ";
        EaseOut[EaseOut["Back"] = "cubic-bezier(0.175, 0.885, 0.320, 1.275)"] = "Back";
    })(exports.ɵj || (exports.ɵj = {}));
    var EaseInOut;
    (function (EaseInOut) {
        EaseInOut[EaseInOut["Quad"] = "cubic-bezier(0.455, 0.030, 0.515, 0.955)"] = "Quad";
        EaseInOut[EaseInOut["Cubic"] = "cubic-bezier(0.645, 0.045, 0.355, 1.000)"] = "Cubic";
        EaseInOut[EaseInOut["Quart"] = "cubic-bezier(0.770, 0.000, 0.175, 1.000)"] = "Quart";
        EaseInOut[EaseInOut["Quint"] = "cubic-bezier(0.860, 0.000, 0.070, 1.000)"] = "Quint";
        EaseInOut[EaseInOut["Sine"] = "cubic-bezier(0.445, 0.050, 0.550, 0.950)"] = "Sine";
        EaseInOut[EaseInOut["Expo"] = "cubic-bezier(1.000, 0.000, 0.000, 1.000)"] = "Expo";
        EaseInOut[EaseInOut["Circ"] = "cubic-bezier(0.785, 0.135, 0.150, 0.860)"] = "Circ";
        EaseInOut[EaseInOut["Back"] = "cubic-bezier(0.680, -0.550, 0.265, 1.550)"] = "Back";
    })(EaseInOut || (EaseInOut = {}));

    var base = [
        i1.style({
            opacity: "{{startOpacity}}"
        }),
        i1.animate("{{duration}} {{delay}} {{easing}}", i1.style({
            opacity: "{{endOpacity}}"
        }))
    ];
    var baseParams = {
        delay: '0s',
        duration: '350ms',
        easing: exports.ɵj.Sine,
        endOpacity: 1,
        startOpacity: 0
    };
    var fadeIn = i1.animation(base, {
        params: baseParams
    });
    var fadeOut = i1.animation(base, {
        params: {
            delay: '0s',
            duration: '350ms',
            easing: exports.ɵj.Sine,
            endOpacity: 0,
            startOpacity: 1
        }
    });

    var baseRecipe = [
        i1.style({
            backfaceVisibility: 'hidden',
            transformStyle: 'preserve-3d'
        }),
        i1.animate("{{duration}} {{delay}} {{easing}}", i1.keyframes([
            i1.style({
                offset: 0,
                transform: "translateZ({{startDistance}})\n                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{startAngle}}deg)"
            }),
            i1.style({
                offset: 1,
                transform: "translateZ({{endDistance}})\n                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{endAngle}}deg)"
            })
        ]))
    ];
    var baseParams$1 = {
        delay: '0s',
        duration: '600ms',
        easing: exports.ɵj.Quad,
        endAngle: 180,
        endDistance: '0px',
        rotateX: 1,
        rotateY: 0,
        rotateZ: 0,
        startAngle: 0,
        startDistance: '0px'
    };
    var flipTop = i1.animation(baseRecipe, {
        params: Object.assign({}, baseParams$1)
    });
    var flipBottom = i1.animation(baseRecipe, {
        params: Object.assign(Object.assign({}, baseParams$1), { endAngle: -180 })
    });
    var flipLeft = i1.animation(baseRecipe, {
        params: Object.assign(Object.assign({}, baseParams$1), { rotateX: 0, rotateY: 1 })
    });
    var flipRight = i1.animation(baseRecipe, {
        params: Object.assign(Object.assign({}, baseParams$1), { endAngle: -180, rotateX: 0, rotateY: 1 })
    });
    var flipHorFwd = i1.animation(baseRecipe, {
        params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '170px' })
    });
    var flipHorBck = i1.animation(baseRecipe, {
        params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '-170px' })
    });
    var flipVerFwd = i1.animation(baseRecipe, {
        params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '170px', rotateX: 0, rotateY: 1 })
    });
    var flipVerBck = i1.animation(baseRecipe, {
        params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '-170px', rotateX: 0, rotateY: 1 })
    });

    var baseRecipe$1 = [
        i1.style({
            opacity: "{{startOpacity}}",
            transform: "rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{startAngle}}deg)",
            transformOrigin: "{{xPos}} {{yPos}}"
        }),
        i1.animate("{{duration}} {{delay}} {{easing}}", i1.style({
            offset: 0,
            opacity: "{{endOpacity}}",
            transform: "rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{endAngle}}deg)",
            transformOrigin: "{{xPos}} {{yPos}}"
        }))
    ];
    var baseInParams = {
        delay: '0s',
        duration: '600ms',
        easing: exports.ɵj.Quad,
        endAngle: 0,
        endOpacity: 1,
        rotateX: 0,
        rotateY: 0,
        rotateZ: 1,
        startAngle: -360,
        startOpacity: 0,
        xPos: 'center',
        yPos: 'center'
    };
    var baseOutParams = Object.assign(Object.assign({}, baseInParams), { easing: exports.ɵi.Quad, endOpacity: 0, startOpacity: 1 });
    var rotateInCenter = i1.animation(baseRecipe$1, {
        params: Object.assign({}, baseInParams)
    });
    var rotateOutCenter = i1.animation(baseRecipe$1, {
        params: Object.assign({}, baseOutParams)
    });
    var rotateInTop = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseInParams), { xPos: 'top' })
    });
    var rotateOutTop = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'top' })
    });
    var rotateInRight = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseInParams), { xPos: 'right' })
    });
    var rotateOutRight = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'right' })
    });
    var rotateInBottom = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseInParams), { xPos: 'bottom' })
    });
    var rotateOutBottom = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'bottom' })
    });
    var rotateInLeft = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseInParams), { xPos: 'left' })
    });
    var rotateOutLeft = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'left' })
    });
    var rotateInTr = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseInParams), { xPos: 'right', yPos: 'top' })
    });
    var rotateOutTr = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'right', yPos: 'top' })
    });
    var rotateInBr = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseInParams), { xPos: 'right', yPos: 'bottom' })
    });
    var rotateOutBr = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'right', yPos: 'bottom' })
    });
    var rotateInBl = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseInParams), { xPos: 'left', yPos: 'bottom' })
    });
    var rotateOutBl = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'left', yPos: 'bottom' })
    });
    var rotateInTl = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseInParams), { xPos: 'left', yPos: 'top' })
    });
    var rotateOutTl = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'left', yPos: 'top' })
    });
    var rotateInDiagonal1 = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseInParams), { rotateX: 1, rotateY: 1, rotateZ: 0 })
    });
    var rotateOutDiagonal1 = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseOutParams), { rotateX: 1, rotateY: 1, rotateZ: 0 })
    });
    var rotateInDiagonal2 = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseInParams), { rotateX: -1, rotateY: 1, rotateZ: 0 })
    });
    var rotateOutDiagonal2 = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseOutParams), { rotateX: -1, rotateY: 1, rotateZ: 0 })
    });
    var rotateInHor = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseInParams), { rotateX: 0, rotateY: 1, rotateZ: 0 })
    });
    var rotateOutHor = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseOutParams), { rotateX: 0, rotateY: 1, rotateZ: 0 })
    });
    var rotateInVer = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseInParams), { rotateX: 1, rotateY: 0, rotateZ: 0 })
    });
    var rotateOutVer = i1.animation(baseRecipe$1, {
        params: Object.assign(Object.assign({}, baseOutParams), { rotateX: 1, rotateY: 0, rotateZ: 0 })
    });

    var baseRecipe$2 = [
        i1.animate("{{duration}} {{delay}} {{easing}}", i1.keyframes([
            i1.style({
                offset: 0,
                transform: "rotate(0deg) translate{{direction}}(0)",
                transformOrigin: "{{xPos}} {{yPos}}"
            }),
            i1.style({
                offset: 0.1,
                transform: "rotate({{endAngle}}deg) translate{{direction}}(-{{startDistance}})"
            }),
            i1.style({
                offset: 0.2,
                transform: "rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})"
            }),
            i1.style({
                offset: 0.3,
                transform: "rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})"
            }),
            i1.style({
                offset: 0.4,
                transform: "rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})"
            }),
            i1.style({
                offset: 0.5,
                transform: "rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})"
            }),
            i1.style({
                offset: 0.6,
                transform: "rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})"
            }),
            i1.style({
                offset: 0.7,
                transform: "rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})"
            }),
            i1.style({
                offset: 0.8,
                transform: "rotate(-{{endAngle}}deg) translate{{direction}}({{endDistance}})"
            }),
            i1.style({
                offset: 0.9,
                transform: "rotate({{endAngle}}deg) translate{{direction}}(-{{endDistance}})"
            }),
            i1.style({
                offset: 1,
                transform: "rotate(0deg) translate{{direction}}(0)",
                transformOrigin: "{{xPos}} {{yPos}}"
            })
        ]))
    ];
    var baseParams$2 = {
        delay: '0s',
        direction: 'X',
        duration: '800ms',
        easing: EaseInOut.Quad,
        endAngle: 0,
        endDistance: '8px',
        startAngle: 0,
        startDistance: '10px',
        xPos: 'center',
        yPos: 'center'
    };
    var shakeHor = i1.animation(baseRecipe$2, {
        params: Object.assign(Object.assign({}, baseParams$2), { direction: 'X' })
    });
    var shakeVer = i1.animation(baseRecipe$2, {
        params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y' })
    });
    var shakeTop = i1.animation(baseRecipe$2, {
        params: Object.assign(Object.assign({}, baseParams$2), { endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'top' })
    });
    var shakeBottom = i1.animation(baseRecipe$2, {
        params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'bottom' })
    });
    var shakeRight = i1.animation(baseRecipe$2, {
        params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'center' })
    });
    var shakeLeft = i1.animation(baseRecipe$2, {
        params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'center' })
    });
    var shakeCenter = i1.animation(baseRecipe$2, {
        params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 8, endDistance: '0', startAngle: 10, startDistance: '0', xPos: 'center', yPos: 'center' })
    });
    var shakeTr = i1.animation(baseRecipe$2, {
        params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'top' })
    });
    var shakeBr = i1.animation(baseRecipe$2, {
        params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'bottom' })
    });
    var shakeBl = i1.animation(baseRecipe$2, {
        params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'bottom' })
    });
    var shakeTl = i1.animation(baseRecipe$2, {
        params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'top' })
    });

    var heartbeatBase = [
        i1.style({
            animationTimingFunction: "ease-out",
            transform: "scale(1)",
            transformOrigin: "center center"
        }),
        i1.animate("{{duration}} {{delay}} {{easing}}", i1.keyframes([
            i1.style({
                animationTimingFunction: "ease-in",
                offset: 0.1,
                transform: "scale(0.91)"
            }),
            i1.style({
                animationTimingFunction: "ease-out",
                offset: 0.17,
                transform: "scale(0.98)"
            }),
            i1.style({
                animationTimingFunction: "ease-in",
                offset: 0.33,
                transform: "scale(0.87)"
            }),
            i1.style({
                animationTimingFunction: "ease-out",
                offset: 0.45,
                transform: "scale(1)"
            })
        ]))
    ];
    var heartbeatParams = {
        delay: '0s',
        duration: '1.5s',
        easing: 'ease-in-out'
    };
    var pulsateBase = [
        i1.animate("{{duration}} {{delay}} {{easing}}", i1.keyframes([
            i1.style({
                offset: 0,
                transform: "scale({{fromScale}})"
            }),
            i1.style({
                offset: 0.5,
                transform: "scale({{toScale}})"
            }),
            i1.style({
                offset: 1,
                transform: "scale({{fromScale}})"
            })
        ]))
    ];
    var pulsateParams = {
        delay: '0s',
        duration: '.5s',
        easing: 'ease-in-out',
        fromScale: 1,
        toScale: 1.1
    };
    var blinkBase = [
        i1.animate("{{duration}} {{delay}} {{easing}}", i1.keyframes([
            i1.style({
                offset: 0,
                opacity: .8,
                transform: "scale({{fromScale}})"
            }),
            i1.style({
                offset: 0.8,
                opacity: 0,
                transform: "scale({{midScale}})"
            }),
            i1.style({
                offset: 1,
                opacity: 0,
                transform: "scale({{toScale}})"
            })
        ]))
    ];
    var blinkParams = {
        delay: '0s',
        duration: '.8s',
        easing: 'ease-in-out',
        fromScale: .2,
        midScale: 1.2,
        toScale: 2.2
    };
    var pulsateFwd = i1.animation(pulsateBase, {
        params: Object.assign({}, pulsateParams)
    });
    var pulsateBck = i1.animation(pulsateBase, {
        params: Object.assign(Object.assign({}, pulsateParams), { toScale: .9 })
    });
    var heartbeat = i1.animation(heartbeatBase, {
        params: Object.assign({}, heartbeatParams)
    });
    var blink = i1.animation(blinkBase, {
        params: Object.assign({}, blinkParams)
    });

    var base$1 = [
        i1.style({
            opacity: "{{startOpacity}}",
            transform: "scale{{direction}}({{fromScale}})",
            transformOrigin: "{{xPos}} {{yPos}}"
        }),
        i1.animate("{{duration}} {{delay}} {{easing}}", i1.style({
            opacity: "{{endOpacity}}",
            transform: "scale{{direction}}({{toScale}})",
            transformOrigin: "{{xPos}} {{yPos}}"
        }))
    ];
    var baseInParams$1 = {
        delay: '0s',
        direction: '',
        duration: '350ms',
        easing: exports.ɵj.Quad,
        endOpacity: 1,
        fromScale: .5,
        startOpacity: 0,
        toScale: 1,
        xPos: '50%',
        yPos: '50%'
    };
    var baseOutParams$1 = Object.assign(Object.assign({}, baseInParams$1), { easing: exports.ɵj.Sine, endOpacity: 0, fromScale: 1, startOpacity: 1, toScale: .5 });
    var scaleInCenter = i1.animation(base$1, { params: baseInParams$1 });
    var scaleInBl = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '0', yPos: '100%' })
    });
    var scaleInVerCenter = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'Y', fromScale: .4 })
    });
    var scaleInTop = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '50%', yPos: '0' })
    });
    var scaleInLeft = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '0', yPos: '50%' })
    });
    var scaleInVerTop = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'Y', fromScale: .4, xPos: '100%', yPos: '0' })
    });
    var scaleInTr = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '100%', yPos: '0' })
    });
    var scaleInTl = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '0', yPos: '0' })
    });
    var scaleInVerBottom = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'Y', fromScale: .4, xPos: '0', yPos: '100%' })
    });
    var scaleInRight = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '100%', yPos: '50%' })
    });
    var scaleInHorCenter = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'X', fromScale: .4 })
    });
    var scaleInBr = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '100%', yPos: '100%' })
    });
    var scaleInHorLeft = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'X', fromScale: .4, xPos: '0', yPos: '0' })
    });
    var scaleInBottom = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '50%', yPos: '100%' })
    });
    var scaleInHorRight = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'X', fromScale: .4, xPos: '100%', yPos: '100%' })
    });
    var scaleOutCenter = i1.animation(base$1, { params: baseOutParams$1 });
    var scaleOutBl = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '0', yPos: '100%' })
    });
    var scaleOutBr = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '100%', yPos: '100%' })
    });
    var scaleOutVerCenter = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'Y', toScale: .3 })
    });
    var scaleOutVerTop = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'Y', toScale: .3, xPos: '100%', yPos: '0' })
    });
    var scaleOutVerBottom = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'Y', toScale: .3, xPos: '0', yPos: '100%' })
    });
    var scaleOutTop = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '50%', yPos: '0' })
    });
    var scaleOutLeft = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '0', yPos: '50%' })
    });
    var scaleOutTr = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '100%', yPos: '0' })
    });
    var scaleOutTl = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '0', yPos: '0' })
    });
    var scaleOutRight = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '100%', yPos: '50%' })
    });
    var scaleOutBottom = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '50%', yPos: '100%' })
    });
    var scaleOutHorCenter = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'X', toScale: .3 })
    });
    var scaleOutHorLeft = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'X', toScale: .3, xPos: '0', yPos: '0' })
    });
    var scaleOutHorRight = i1.animation(base$1, {
        params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'X', toScale: .3, xPos: '100%', yPos: '100%' })
    });

    var base$2 = [
        i1.style({
            opacity: "{{startOpacity}}",
            transform: "{{fromPosition}}"
        }),
        i1.animate("{{duration}} {{delay}} {{easing}}", i1.style({
            opacity: "{{endOpacity}}",
            transform: "{{toPosition}}"
        }))
    ];
    var baseInParams$2 = {
        delay: '0s',
        duration: '350ms',
        easing: exports.ɵj.Quad,
        endOpacity: 1,
        fromPosition: 'translateY(-500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    };
    var baseOutParams$2 = {
        delay: '0s',
        duration: '350ms',
        easing: exports.ɵi.Quad,
        endOpacity: 0,
        fromPosition: 'translateY(0)',
        startOpacity: 1,
        toPosition: 'translateY(-500px)'
    };
    var slideInTop = i1.animation(base$2, { params: baseInParams$2 });
    var slideInLeft = i1.animation(base$2, {
        params: {
            delay: '0s',
            duration: '350ms',
            easing: exports.ɵj.Quad,
            endOpacity: 1,
            fromPosition: 'translateX(-500px)',
            startOpacity: 0,
            toPosition: 'translateY(0)'
        }
    });
    var slideInRight = i1.animation(base$2, {
        params: {
            delay: '0s',
            duration: '350ms',
            easing: exports.ɵj.Quad,
            endOpacity: 1,
            fromPosition: 'translateX(500px)',
            startOpacity: 0,
            toPosition: 'translateY(0)'
        }
    });
    var slideInBottom = i1.animation(base$2, {
        params: {
            delay: '0s',
            duration: '350ms',
            easing: exports.ɵj.Quad,
            endOpacity: 1,
            fromPosition: 'translateY(500px)',
            startOpacity: 0,
            toPosition: 'translateY(0)'
        }
    });
    var slideInTr = i1.animation(base$2, {
        params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(-500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
    });
    var slideInTl = i1.animation(base$2, {
        params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(-500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
    });
    var slideInBr = i1.animation(base$2, {
        params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
    });
    var slideInBl = i1.animation(base$2, {
        params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
    });
    var slideOutTop = i1.animation(base$2, { params: baseOutParams$2 });
    var slideOutRight = i1.animation(base$2, {
        params: Object.assign(Object.assign({}, baseOutParams$2), { toPosition: 'translateX(500px)' })
    });
    var slideOutBottom = i1.animation(base$2, {
        params: {
            delay: '0s',
            duration: '350ms',
            easing: exports.ɵi.Quad,
            endOpacity: 0,
            fromPosition: 'translateY(0)',
            startOpacity: 1,
            toPosition: 'translateY(500px)'
        }
    });
    var slideOutLeft = i1.animation(base$2, {
        params: Object.assign(Object.assign({}, baseOutParams$2), { toPosition: 'translateX(-500px)' })
    });
    var slideOutTr = i1.animation(base$2, {
        params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(500px)' })
    });
    var slideOutBr = i1.animation(base$2, {
        params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(500px)' })
    });
    var slideOutBl = i1.animation(base$2, {
        params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(-500px)' })
    });
    var slideOutTl = i1.animation(base$2, {
        params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(-500px)' })
    });

    var swingBase = [
        i1.style({
            opacity: "{{startOpacity}}",
            transform: "rotate{{direction}}({{startAngle}}deg)",
            transformOrigin: "{{xPos}} {{yPos}}"
        }),
        i1.animate("{{duration}} {{delay}} {{easing}}", i1.style({
            opacity: "{{endOpacity}}",
            transform: "rotate{{direction}}({{endAngle}}deg)",
            transformOrigin: "{{xPos}} {{yPos}}"
        }))
    ];
    var swingParams = {
        delay: '0s',
        direction: 'X',
        duration: '.5s',
        easing: exports.ɵj.Back,
        endAngle: 0,
        endOpacity: 1,
        startAngle: -100,
        startOpacity: 0,
        xPos: 'top',
        yPos: 'center'
    };
    var swingOutParams = Object.assign(Object.assign({}, swingParams), { duration: '.55s', easing: exports.ɵi.Back, endAngle: 70, endOpacity: 0, startAngle: 0, startOpacity: 1 });
    var swingInTopFwd = i1.animation(swingBase, {
        params: Object.assign({}, swingParams)
    });
    var swingInRightFwd = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', xPos: 'center', yPos: 'right' })
    });
    var swingInBottomFwd = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingParams), { startAngle: 100, xPos: 'bottom' })
    });
    var swingInLeftFwd = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', startAngle: 100, xPos: 'center', yPos: 'left' })
    });
    var swingInTopBck = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingParams), { duration: '.6s', startAngle: 70 })
    });
    var swingInRightBck = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', duration: '.6s', startAngle: 70, xPos: 'center', yPos: 'right' })
    });
    var swingInBottomBck = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingParams), { duration: '.6s', startAngle: -70, xPos: 'bottom' })
    });
    var swingInLeftBck = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', duration: '.6s', startAngle: -70, xPos: 'center', yPos: 'left' })
    });
    var swingOutTopFwd = i1.animation(swingBase, {
        params: Object.assign({}, swingOutParams)
    });
    var swingOutRightFwd = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', xPos: 'center', yPos: 'right' })
    });
    var swingOutBottomFwd = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingOutParams), { endAngle: -70, xPos: 'bottom' })
    });
    var swingOutLefttFwd = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', endAngle: -70, xPos: 'center', yPos: 'left' })
    });
    var swingOutTopBck = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingOutParams), { duration: '.45s', endAngle: -100 })
    });
    var swingOutRightBck = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', duration: '.45s', endAngle: -100, xPos: 'center', yPos: 'right' })
    });
    var swingOutBottomBck = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingOutParams), { duration: '.45s', endAngle: 100, xPos: 'bottom' })
    });
    var swingOutLeftBck = i1.animation(swingBase, {
        params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', duration: '.45s', endAngle: 100, xPos: 'center', yPos: 'left' })
    });

    var base$3 = [
        i1.style({
            opacity: "{{ startOpacity }}",
            height: "{{ startHeight }}"
        }),
        i1.animate("{{duration}} {{delay}} {{easing}}", i1.style({
            opacity: "{{ endOpacity }}",
            height: "{{ endHeight }}"
        }))
    ];
    var baseParams$3 = {
        delay: '0s',
        duration: '350ms',
        easing: exports.ɵi.Quad,
        startOpacity: 0,
        endOpacity: 1,
        startHeight: '',
        endHeight: ''
    };
    var growVerIn = i1.animation(base$3, {
        params: Object.assign(Object.assign({}, baseParams$3), { easing: exports.ɵj.Quad, startOpacity: 0, endOpacity: 1, startHeight: '0px', endHeight: '*' })
    });
    var growVerOut = i1.animation(base$3, {
        params: Object.assign(Object.assign({}, baseParams$3), { easing: exports.ɵj.Quad, startOpacity: 1, endOpacity: 0, startHeight: '*', endHeight: '0px' })
    });

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * Common service to be injected between components where those implementing common
     * ToggleView interface can register and toggle directives can call their methods.
     * TODO: Track currently active? Events?
     */
    var IgxNavigationService = /** @class */ (function () {
        function IgxNavigationService() {
            this.navs = {};
        }
        IgxNavigationService.prototype.add = function (id, navItem) {
            this.navs[id] = navItem;
        };
        IgxNavigationService.prototype.remove = function (id) {
            delete this.navs[id];
        };
        IgxNavigationService.prototype.get = function (id) {
            if (id) {
                return this.navs[id];
            }
        };
        IgxNavigationService.prototype.toggle = function (id) {
            var _a;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.navs[id]) {
                return (_a = this.navs[id]).toggle.apply(_a, __spread(args));
            }
        };
        IgxNavigationService.prototype.open = function (id) {
            var _a;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.navs[id]) {
                return (_a = this.navs[id]).open.apply(_a, __spread(args));
            }
        };
        IgxNavigationService.prototype.close = function (id) {
            var _a;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.navs[id]) {
                return (_a = this.navs[id]).close.apply(_a, __spread(args));
            }
        };
        return IgxNavigationService;
    }());
    IgxNavigationService.decorators = [
        { type: i0.Injectable }
    ];
    IgxNavigationService.ctorParameters = function () { return []; };

    /**
     * Directive that can toggle targets through provided NavigationService.
     *
     * Usage:
     * ```
     * <button igxNavToggle="ID"> Toggle </button>
     * ```
     * Where the `ID` matches the ID of compatible `IToggleView` component.
     */
    var IgxNavigationToggleDirective = /** @class */ (function () {
        function IgxNavigationToggleDirective(nav) {
            this.state = nav;
        }
        IgxNavigationToggleDirective.prototype.toggleNavigationDrawer = function () {
            this.state.toggle(this.target, true);
        };
        return IgxNavigationToggleDirective;
    }());
    IgxNavigationToggleDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[igxNavToggle]' },] }
    ];
    IgxNavigationToggleDirective.ctorParameters = function () { return [
        { type: IgxNavigationService }
    ]; };
    IgxNavigationToggleDirective.propDecorators = {
        target: [{ type: i0.Input, args: ['igxNavToggle',] }],
        toggleNavigationDrawer: [{ type: i0.HostListener, args: ['click',] }]
    };
    /**
     * Directive that can close targets through provided NavigationService.
     *
     * Usage:
     * ```
     * <button igxNavClose="ID"> Close </button>
     * ```
     * Where the `ID` matches the ID of compatible `IToggleView` component.
     */
    var IgxNavigationCloseDirective = /** @class */ (function () {
        function IgxNavigationCloseDirective(nav) {
            this.state = nav;
        }
        IgxNavigationCloseDirective.prototype.closeNavigationDrawer = function () {
            this.state.close(this.target, true);
        };
        return IgxNavigationCloseDirective;
    }());
    IgxNavigationCloseDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[igxNavClose]' },] }
    ];
    IgxNavigationCloseDirective.ctorParameters = function () { return [
        { type: IgxNavigationService }
    ]; };
    IgxNavigationCloseDirective.propDecorators = {
        target: [{ type: i0.Input, args: ['igxNavClose',] }],
        closeNavigationDrawer: [{ type: i0.HostListener, args: ['click',] }]
    };
    /**
     * @hidden
     */
    var IgxNavigationModule = /** @class */ (function () {
        function IgxNavigationModule() {
        }
        return IgxNavigationModule;
    }());
    IgxNavigationModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                    exports: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                    providers: [IgxNavigationService]
                },] }
    ];

    /* Copyright (c) 2014-2020 Denis Pushkarev
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE
     */
    // Note: Originally copied from core-js-pure package and modified. (https://github.com/zloirock/core-js)
    var queue = {};
    var counter = 0;
    var eventListenerAdded = false;
    var run = function (id) {
        if (queue.hasOwnProperty(id)) {
            var fn = queue[id];
            delete queue[id];
            fn();
        }
    };
    var ɵ0 = run;
    var listener = function (event) { return run(event.data); };
    var ɵ1 = listener;
    // Use function instead of arrow function to workaround an issue in codesandbox
    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
    function setImmediate(cb) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (window.setImmediate) {
            return window.setImmediate(cb);
        }
        if (!eventListenerAdded) {
            eventListenerAdded = true;
            window.addEventListener('message', listener, false);
        }
        queue[++counter] = function () {
            cb.apply(undefined, args);
        };
        var windowLocation = window.location;
        window.postMessage(counter + '', windowLocation.protocol + '//' + windowLocation.host);
        return counter;
    }
    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
    function clearImmediate(id) {
        if (window.clearImmediate) {
            return window.clearImmediate(id);
        }
        delete queue[id];
    }

    /**
     * @hidden
     */
    var cloneArray = function (array, deep) {
        var arr = [];
        if (!array) {
            return arr;
        }
        var i = array.length;
        while (i--) {
            arr[i] = deep ? cloneValue(array[i]) : array[i];
        }
        return arr;
    };
    /**
     * Doesn't clone leaf items
     *
     * @hidden
     */
    var cloneHierarchicalArray = function (array, childDataKey) {
        var e_1, _b;
        var result = [];
        if (!array) {
            return result;
        }
        try {
            for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
                var item = array_1_1.value;
                var clonedItem = cloneValue(item);
                if (Array.isArray(item[childDataKey])) {
                    clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
                }
                result.push(clonedItem);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (array_1_1 && !array_1_1.done && (_b = array_1.return)) _b.call(array_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    };
    /**
     * Deep clones all first level keys of Obj2 and merges them to Obj1
     *
     * @param obj1 Object to merge into
     * @param obj2 Object to merge from
     * @returns Obj1 with merged cloned keys from Obj2
     * @hidden
     */
    var mergeObjects = function (obj1, obj2) { return mergeWith__default['default'](obj1, obj2, function (objValue, srcValue) {
        if (Array.isArray(srcValue)) {
            return objValue = srcValue;
        }
    }); };
    /**
     * Creates deep clone of provided value.
     * Supports primitive values, dates and objects.
     * If passed value is array returns shallow copy of the array.
     *
     * @param value value to clone
     * @returns Deep copy of provided value
     * @hidden
     */
    var cloneValue = function (value) {
        var e_2, _b;
        if (isDate(value)) {
            return new Date(value.getTime());
        }
        if (Array.isArray(value)) {
            return __spread(value);
        }
        if (value instanceof Map || value instanceof Set) {
            return value;
        }
        if (isObject(value)) {
            var result = {};
            try {
                for (var _c = __values(Object.keys(value)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var key = _d.value;
                    result[key] = cloneValue(value[key]);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return result;
        }
        return value;
    };
    /**
     * Parse provided input to Date.
     *
     * @param value input to parse
     * @returns Date if parse succeed or null
     * @hidden
     */
    var parseDate = function (value) {
        // if value is Invalid Date return null
        if (isDate(value)) {
            return !isNaN(value.getTime()) ? value : null;
        }
        return value ? new Date(value) : null;
    };
    /**
     * Returns an array with unique dates only.
     *
     * @param columnValues collection of date values (might be numbers or ISO 8601 strings)
     * @returns collection of unique dates.
     * @hidden
     */
    var uniqueDates = function (columnValues) { return columnValues.reduce(function (a, c) {
        if (!a.cache[c.label]) {
            a.result.push(c);
        }
        a.cache[c.label] = true;
        return a;
    }, { result: [], cache: {} }).result; };
    /**
     * Checks if provided variable is Object
     *
     * @param value Value to check
     * @returns true if provided variable is Object
     * @hidden
     */
    var isObject = function (value) { return value && value.toString() === '[object Object]'; };
    /**
     * Checks if provided variable is Date
     *
     * @param value Value to check
     * @returns true if provided variable is Date
     * @hidden
     */
    var isDate = function (value) { return value instanceof Date; };
    /**
     * Checks if the two passed arguments are equal
     * Currently supports date objects
     *
     * @param obj1
     * @param obj2
     * @returns: `boolean`
     * @hidden
     */
    var isEqual = function (obj1, obj2) {
        if (isDate(obj1) && isDate(obj2)) {
            return obj1.getTime() === obj2.getTime();
        }
        return obj1 === obj2;
    };
    /* eslint-enable @typescript-eslint/naming-convention */
    /**
     * @hidden
     * Returns the actual size of the node content, using Range
     * ```typescript
     * let range = document.createRange();
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     *
     * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
     * ```
     */
    var getNodeSizeViaRange = function (range, node) {
        var overflow = null;
        if (!isFirefox()) {
            overflow = node.style.overflow;
            // we need that hack - otherwise content won't be measured correctly in IE/Edge
            node.style.overflow = 'visible';
        }
        range.selectNodeContents(node);
        var width = range.getBoundingClientRect().width;
        if (!isFirefox()) {
            // we need that hack - otherwise content won't be measured correctly in IE/Edge
            node.style.overflow = overflow;
        }
        return width;
    };
    /**
     * @hidden
     * Returns the actual size of the node content, using Canvas
     * ```typescript
     * let ctx = document.createElement('canvas').getContext('2d');
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     *
     * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
     * ```
     */
    function getNodeSizeViaCanvas(canvas2dCtx, node) {
        var s = this.grid.document.defaultView.getComputedStyle(node);
        // need to set the font to get correct width
        canvas2dCtx.font = s.fontSize + ' ' + s.fontFamily;
        return canvas2dCtx.measureText(node.textContent).width;
    }
    /**
     * @hidden
     */
    var isIE = function () { return navigator.appVersion.indexOf('Trident/') > 0; };
    /**
     * @hidden
     */
    var isEdge = function () {
        var edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
        return edgeBrowser;
    };
    /**
     * @hidden
     */
    var isFirefox = function () {
        var firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
        return firefoxBrowser;
    };
    /**
     * @hidden
     */
    var PlatformUtil = /** @class */ (function () {
        function PlatformUtil(platformId) {
            this.platformId = platformId;
            this.isBrowser = i2.isPlatformBrowser(this.platformId);
            this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
        }
        return PlatformUtil;
    }());
    PlatformUtil.ɵprov = i0.ɵɵdefineInjectable({ factory: function PlatformUtil_Factory() { return new PlatformUtil(i0.ɵɵinject(i0.PLATFORM_ID)); }, token: PlatformUtil, providedIn: "root" });
    PlatformUtil.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    PlatformUtil.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
    ]; };
    /**
     * @hidden
     */
    var isLeftClick = function (event) { return event.button === 0; };
    /** @hidden */
    var isNavigationKey = function (key) { return [
        'down',
        'up',
        'left',
        'right',
        'arrowdown',
        'arrowup',
        'arrowleft',
        'arrowright',
        'home',
        'end',
        'space',
        'spacebar',
        ' '
    ].indexOf(key) !== -1; };
    /**
     * @hidden
     */
    var flatten = function (arr) {
        var result = [];
        arr.forEach(function (el) {
            result.push(el);
            if (el.children) {
                var children = Array.isArray(el.children) ? el.children : el.children.toArray();
                result = result.concat(flatten(children));
            }
        });
        return result;
    };
    var HORIZONTAL_NAV_KEYS = new Set(['arrowleft', 'left', 'arrowright', 'right', 'home', 'end']);
    var NAVIGATION_KEYS = new Set([
        'down',
        'up',
        'left',
        'right',
        'arrowdown',
        'arrowup',
        'arrowleft',
        'arrowright',
        'home',
        'end',
        'space',
        'spacebar',
        ' '
    ]);
    var ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
    var ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
    var ROW_ADD_KEYS = new Set(['+', 'add', '≠', '±', '=']);
    var SUPPORTED_KEYS = new Set(__spread(Array.from(NAVIGATION_KEYS), Array.from(ROW_ADD_KEYS), ['enter', 'f2', 'escape', 'esc', 'pagedown', 'pageup']));
    var HEADER_KEYS = new Set(__spread(Array.from(NAVIGATION_KEYS), ['escape', 'esc', 'l',
        /** This symbol corresponds to the Alt + L combination under MAC. */
        '¬']));
    /**
     * @hidden
     * @internal
     *
     * Creates a new ResizeObserver on `target` and returns it as an Observable.
     * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.
     * Related issue: https://github.com/angular/angular/issues/31712
     */
    var resizeObservable = function (target) { return new rxjs.Observable(function (observer) {
        var instance = new ResizeObserver__default['default'](function (entries) {
            observer.next(entries);
        });
        instance.observe(target);
        var unsubscribe = function () { return instance.disconnect(); };
        return unsubscribe;
    }); };
    /**
     * @hidden
     * @internal
     *
     * Compares two maps.
     */
    var compareMaps = function (map1, map2) {
        var e_3, _b;
        if (!map2) {
            return !map1 ? true : false;
        }
        if (map1.size !== map2.size) {
            return false;
        }
        var match = true;
        var keys = Array.from(map2.keys());
        try {
            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                var key = keys_1_1.value;
                if (map1.has(key)) {
                    match = map1.get(key) === map2.get(key);
                }
                else {
                    match = false;
                }
                if (!match) {
                    break;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (keys_1_1 && !keys_1_1.done && (_b = keys_1.return)) _b.call(keys_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return match;
    };
    /**
     *
     * Given a property access path in the format `x.y.z` resolves and returns
     * the value of the `z` property in the passed object.
     *
     * @hidden
     * @internal
     */
    var resolveNestedPath = function (obj, path) {
        var _a;
        var parts = (_a = path === null || path === void 0 ? void 0 : path.split('.')) !== null && _a !== void 0 ? _a : [];
        var current = obj[parts.shift()];
        parts.forEach(function (prop) {
            if (current) {
                current = current[prop];
            }
        });
        return current;
    };
    /**
     *
     * Given a property access path in the format `x.y.z` and a value
     * this functions builds and returns an object following the access path.
     *
     * @example
     * ```typescript
     * console.log('x.y.z.', 42);
     * >> { x: { y: { z: 42 } } }
     * ```
     *
     * @hidden
     * @internal
     */
    var reverseMapper = function (path, value) {
        var _a;
        var obj = {};
        var parts = (_a = path === null || path === void 0 ? void 0 : path.split('.')) !== null && _a !== void 0 ? _a : [];
        var _prop = parts.shift();
        var mapping;
        // Initial binding for first level bindings
        obj[_prop] = value;
        mapping = obj;
        parts.forEach(function (prop) {
            // Start building the hierarchy
            mapping[_prop] = {};
            // Go down a level
            mapping = mapping[_prop];
            // Bind the value and move the key
            mapping[prop] = value;
            _prop = prop;
        });
        return obj;
    };
    var yieldingLoop = function (count, chunkSize, callback, done) {
        var i = 0;
        var chunk = function () {
            var end = Math.min(i + chunkSize, count);
            for (; i < end; ++i) {
                callback(i);
            }
            if (i < count) {
                setImmediate(chunk);
            }
            else {
                done();
            }
        };
        chunk();
    };
    var mkenum = function (x) { return x; };
    var reverseAnimationResolver = function (animation) { var _a; return (_a = oppositeAnimation.get(animation)) !== null && _a !== void 0 ? _a : animation; };
    var isHorizontalAnimation = function (animation) { return horizontalAnimations.includes(animation); };
    var isVerticalAnimation = function (animation) { return verticalAnimations.includes(animation); };
    var oppositeAnimation = new Map([
        [fadeIn, fadeIn],
        [fadeOut, fadeOut],
        [flipTop, flipBottom],
        [flipBottom, flipTop],
        [flipRight, flipLeft],
        [flipLeft, flipRight],
        [flipHorFwd, flipHorBck],
        [flipHorBck, flipHorFwd],
        [flipVerFwd, flipVerBck],
        [flipVerBck, flipVerFwd],
        [growVerIn, growVerIn],
        [growVerOut, growVerOut],
        [heartbeat, heartbeat],
        [pulsateFwd, pulsateBck],
        [pulsateBck, pulsateFwd],
        [blink, blink],
        [shakeHor, shakeHor],
        [shakeVer, shakeVer],
        [shakeTop, shakeTop],
        [shakeBottom, shakeBottom],
        [shakeRight, shakeRight],
        [shakeLeft, shakeLeft],
        [shakeCenter, shakeCenter],
        [shakeTr, shakeTr],
        [shakeBr, shakeBr],
        [shakeBl, shakeBl],
        [shakeTl, shakeTl],
        [rotateInCenter, rotateInCenter],
        [rotateOutCenter, rotateOutCenter],
        [rotateInTop, rotateInBottom],
        [rotateOutTop, rotateOutBottom],
        [rotateInRight, rotateInLeft],
        [rotateOutRight, rotateOutLeft],
        [rotateInLeft, rotateInRight],
        [rotateOutLeft, rotateOutRight],
        [rotateInBottom, rotateInTop],
        [rotateOutBottom, rotateOutTop],
        [rotateInTr, rotateInBl],
        [rotateOutTr, rotateOutBl],
        [rotateInBr, rotateInTl],
        [rotateOutBr, rotateOutTl],
        [rotateInBl, rotateInTr],
        [rotateOutBl, rotateOutTr],
        [rotateInTl, rotateInBr],
        [rotateOutTl, rotateOutBr],
        [rotateInDiagonal1, rotateInDiagonal1],
        [rotateOutDiagonal1, rotateOutDiagonal1],
        [rotateInDiagonal2, rotateInDiagonal2],
        [rotateOutDiagonal2, rotateOutDiagonal2],
        [rotateInHor, rotateInHor],
        [rotateOutHor, rotateOutHor],
        [rotateInVer, rotateInVer],
        [rotateOutVer, rotateOutVer],
        [scaleInTop, scaleInBottom],
        [scaleOutTop, scaleOutBottom],
        [scaleInRight, scaleInLeft],
        [scaleOutRight, scaleOutLeft],
        [scaleInBottom, scaleInTop],
        [scaleOutBottom, scaleOutTop],
        [scaleInLeft, scaleInRight],
        [scaleOutLeft, scaleOutRight],
        [scaleInCenter, scaleInCenter],
        [scaleOutCenter, scaleOutCenter],
        [scaleInTr, scaleInBl],
        [scaleOutTr, scaleOutBl],
        [scaleInBr, scaleInTl],
        [scaleOutBr, scaleOutTl],
        [scaleInBl, scaleInTr],
        [scaleOutBl, scaleOutTr],
        [scaleInTl, scaleInBr],
        [scaleOutTl, scaleOutBr],
        [scaleInVerTop, scaleInVerBottom],
        [scaleOutVerTop, scaleOutVerBottom],
        [scaleInVerBottom, scaleInVerTop],
        [scaleOutVerBottom, scaleOutVerTop],
        [scaleInVerCenter, scaleInVerCenter],
        [scaleOutVerCenter, scaleOutVerCenter],
        [scaleInHorCenter, scaleInHorCenter],
        [scaleOutHorCenter, scaleOutHorCenter],
        [scaleInHorLeft, scaleInHorRight],
        [scaleOutHorLeft, scaleOutHorRight],
        [scaleInHorRight, scaleInHorLeft],
        [scaleOutHorRight, scaleOutHorLeft],
        [slideInTop, slideInBottom],
        [slideOutTop, slideOutBottom],
        [slideInRight, slideInLeft],
        [slideOutRight, slideOutLeft],
        [slideInBottom, slideInTop],
        [slideOutBottom, slideOutTop],
        [slideInLeft, slideInRight],
        [slideOutLeft, slideOutRight],
        [slideInTr, slideInBl],
        [slideOutTr, slideOutBl],
        [slideInBr, slideInTl],
        [slideOutBr, slideOutTl],
        [slideInBl, slideInTr],
        [slideOutBl, slideOutTr],
        [slideInTl, slideInBr],
        [slideOutTl, slideOutBr],
        [swingInTopFwd, swingInBottomFwd],
        [swingOutTopFwd, swingOutBottomFwd],
        [swingInRightFwd, swingInLeftFwd],
        [swingOutRightFwd, swingOutLefttFwd],
        [swingInLeftFwd, swingInRightFwd],
        [swingOutLefttFwd, swingOutRightFwd],
        [swingInBottomFwd, swingInTopFwd],
        [swingOutBottomFwd, swingOutTopFwd],
        [swingInTopBck, swingInBottomBck],
        [swingOutTopBck, swingOutBottomBck],
        [swingInRightBck, swingInLeftBck],
        [swingOutRightBck, swingOutLeftBck],
        [swingInBottomBck, swingInTopBck],
        [swingOutBottomBck, swingOutTopBck],
        [swingInLeftBck, swingInRightBck],
        [swingOutLeftBck, swingOutRightBck],
    ]);
    var horizontalAnimations = [
        flipRight,
        flipLeft,
        flipVerFwd,
        flipVerBck,
        rotateInRight,
        rotateOutRight,
        rotateInLeft,
        rotateOutLeft,
        rotateInTr,
        rotateOutTr,
        rotateInBr,
        rotateOutBr,
        rotateInBl,
        rotateOutBl,
        rotateInTl,
        rotateOutTl,
        scaleInRight,
        scaleOutRight,
        scaleInLeft,
        scaleOutLeft,
        scaleInTr,
        scaleOutTr,
        scaleInBr,
        scaleOutBr,
        scaleInBl,
        scaleOutBl,
        scaleInTl,
        scaleOutTl,
        scaleInHorLeft,
        scaleOutHorLeft,
        scaleInHorRight,
        scaleOutHorRight,
        slideInRight,
        slideOutRight,
        slideInLeft,
        slideOutLeft,
        slideInTr,
        slideOutTr,
        slideInBr,
        slideOutBr,
        slideInBl,
        slideOutBl,
        slideInTl,
        slideOutTl,
        swingInRightFwd,
        swingOutRightFwd,
        swingInLeftFwd,
        swingOutLefttFwd,
        swingInRightBck,
        swingOutRightBck,
        swingInLeftBck,
        swingOutLeftBck,
    ];
    var verticalAnimations = [
        flipTop,
        flipBottom,
        flipHorFwd,
        flipHorBck,
        growVerIn,
        growVerOut,
        rotateInTop,
        rotateOutTop,
        rotateInBottom,
        rotateOutBottom,
        rotateInTr,
        rotateOutTr,
        rotateInBr,
        rotateOutBr,
        rotateInBl,
        rotateOutBl,
        rotateInTl,
        rotateOutTl,
        scaleInTop,
        scaleOutTop,
        scaleInBottom,
        scaleOutBottom,
        scaleInTr,
        scaleOutTr,
        scaleInBr,
        scaleOutBr,
        scaleInBl,
        scaleOutBl,
        scaleInTl,
        scaleOutTl,
        scaleInVerTop,
        scaleOutVerTop,
        scaleInVerBottom,
        scaleOutVerBottom,
        slideInTop,
        slideOutTop,
        slideInBottom,
        slideOutBottom,
        slideInTr,
        slideOutTr,
        slideInBr,
        slideOutBr,
        slideInBl,
        slideOutBl,
        slideInTl,
        slideOutTl,
        swingInTopFwd,
        swingOutTopFwd,
        swingInBottomFwd,
        swingOutBottomFwd,
        swingInTopBck,
        swingOutTopBck,
        swingInBottomBck,
        swingOutBottomBck,
    ];

    /**
     * Represents sorting expressions.
     */
    (function (SortingDirection) {
        SortingDirection[SortingDirection["None"] = 0] = "None";
        SortingDirection[SortingDirection["Asc"] = 1] = "Asc";
        SortingDirection[SortingDirection["Desc"] = 2] = "Desc";
    })(exports.SortingDirection || (exports.SortingDirection = {}));

    var isHierarchyMatch = function (h1, h2) {
        if (h1.length !== h2.length) {
            return false;
        }
        return h1.every(function (level, index) { return level.fieldName === h2[index].fieldName && level.value === h2[index].value; });
    };
    var getHierarchy = function (gRow) {
        var hierarchy = [];
        if (gRow !== undefined && gRow.expression) {
            hierarchy.push({ fieldName: gRow.expression.fieldName, value: gRow.value });
            while (gRow.groupParent) {
                gRow = gRow.groupParent;
                hierarchy.unshift({ fieldName: gRow.expression.fieldName, value: gRow.value });
            }
        }
        return hierarchy;
    };

    var DATE_TYPE = 'date';
    var DefaultSortingStrategy = /** @class */ (function () {
        function DefaultSortingStrategy() {
        }
        DefaultSortingStrategy.instance = function () {
            return this._instance || (this._instance = new this());
        };
        DefaultSortingStrategy.prototype.sort = function (data, fieldName, dir, ignoreCase, valueResolver, isDate) {
            var _this = this;
            var key = fieldName;
            var reverse = (dir === exports.SortingDirection.Desc ? -1 : 1);
            var cmpFunc = function (obj1, obj2) { return _this.compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver, isDate); };
            return this.arraySort(data, cmpFunc);
        };
        DefaultSortingStrategy.prototype.compareValues = function (a, b) {
            var an = (a === null || a === undefined);
            var bn = (b === null || b === undefined);
            if (an) {
                if (bn) {
                    return 0;
                }
                return -1;
            }
            else if (bn) {
                return 1;
            }
            return a > b ? 1 : a < b ? -1 : 0;
        };
        DefaultSortingStrategy.prototype.compareObjects = function (obj1, obj2, key, reverse, ignoreCase, valueResolver, isDate) {
            var a = valueResolver(obj1, key, isDate);
            var b = valueResolver(obj2, key, isDate);
            if (ignoreCase) {
                a = a && a.toLowerCase ? a.toLowerCase() : a;
                b = b && b.toLowerCase ? b.toLowerCase() : b;
            }
            return reverse * this.compareValues(a, b);
        };
        DefaultSortingStrategy.prototype.arraySort = function (data, compareFn) {
            return data.sort(compareFn);
        };
        return DefaultSortingStrategy;
    }());
    DefaultSortingStrategy._instance = null;
    var NoopSortingStrategy = /** @class */ (function () {
        function NoopSortingStrategy() {
        }
        NoopSortingStrategy.instance = function () {
            return this._instance || (this._instance = new NoopSortingStrategy());
        };
        NoopSortingStrategy.prototype.sort = function (data, expressions) {
            return data;
        };
        return NoopSortingStrategy;
    }());
    NoopSortingStrategy._instance = null;
    var IgxSorting = /** @class */ (function () {
        function IgxSorting() {
        }
        IgxSorting.prototype.sort = function (data, expressions, grid) {
            return this.sortDataRecursive(data, expressions, 0, grid);
        };
        IgxSorting.prototype.groupDataRecursive = function (data, state, level, parent, metadata, grid, groupsRecords, fullResult) {
            if (grid === void 0) { grid = null; }
            if (groupsRecords === void 0) { groupsRecords = []; }
            if (fullResult === void 0) { fullResult = { data: [], metadata: [] }; }
            var expressions = state.expressions;
            var expansion = state.expansion;
            var i = 0;
            var result = [];
            var _loop_1 = function () {
                var e_1, _a;
                var column = grid ? grid.getColumnByName(expressions[level].fieldName) : null;
                var isDate = (column === null || column === void 0 ? void 0 : column.dataType) === DATE_TYPE;
                var group = this_1.groupedRecordsByExpression(data, i, expressions[level], isDate);
                var groupRow = {
                    expression: expressions[level],
                    level: level,
                    records: cloneArray(group),
                    value: this_1.getFieldValue(group[0], expressions[level].fieldName, isDate),
                    groupParent: parent,
                    groups: [],
                    height: grid ? grid.renderedRowHeight : null,
                    column: column
                };
                if (parent) {
                    parent.groups.push(groupRow);
                }
                else {
                    groupsRecords.push(groupRow);
                }
                var hierarchy = getHierarchy(groupRow);
                var expandState = expansion.find(function (s) { return isHierarchyMatch(s.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy); });
                var expanded = expandState ? expandState.expanded : state.defaultExpanded;
                var recursiveResult = void 0;
                result.push(groupRow);
                metadata.push(null);
                fullResult.data.push(groupRow);
                fullResult.metadata.push(null);
                if (level < expressions.length - 1) {
                    recursiveResult = this_1.groupDataRecursive(group, state, level + 1, groupRow, expanded ? metadata : [], grid, groupsRecords, fullResult);
                    if (expanded) {
                        result = result.concat(recursiveResult);
                    }
                }
                else {
                    try {
                        for (var group_1 = (e_1 = void 0, __values(group)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {
                            var groupItem = group_1_1.value;
                            fullResult.metadata.push(groupRow);
                            fullResult.data.push(groupItem);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (group_1_1 && !group_1_1.done && (_a = group_1.return)) _a.call(group_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    if (expanded) {
                        metadata.push.apply(metadata, __spread(fullResult.metadata.slice(fullResult.metadata.length - group.length)));
                        result.push.apply(result, __spread(fullResult.data.slice(fullResult.data.length - group.length)));
                    }
                }
                i += group.length;
            };
            var this_1 = this;
            while (i < data.length) {
                _loop_1();
            }
            return result;
        };
        IgxSorting.prototype.getFieldValue = function (obj, key, isDate) {
            if (isDate === void 0) { isDate = false; }
            return isDate ? parseDate(resolveNestedPath(obj, key)) : resolveNestedPath(obj, key);
        };
        IgxSorting.prototype.groupedRecordsByExpression = function (data, index, expression, isDate) {
            if (isDate === void 0) { isDate = false; }
            var res = [];
            var key = expression.fieldName;
            var len = data.length;
            var groupval = this.getFieldValue(data[index], key, isDate);
            res.push(data[index]);
            index++;
            var comparer = expression.groupingComparer || DefaultSortingStrategy.instance().compareValues;
            for (var i = index; i < len; i++) {
                if (comparer(this.getFieldValue(data[i], key, isDate), groupval) === 0) {
                    res.push(data[i]);
                }
                else {
                    break;
                }
            }
            return res;
        };
        IgxSorting.prototype.sortDataRecursive = function (data, expressions, expressionIndex, grid) {
            if (expressionIndex === void 0) { expressionIndex = 0; }
            var i;
            var j;
            var gbData;
            var gbDataLen;
            var exprsLen = expressions.length;
            var dataLen = data.length;
            expressionIndex = expressionIndex || 0;
            if (expressionIndex >= exprsLen || dataLen <= 1) {
                return data;
            }
            var expr = expressions[expressionIndex];
            if (!expr.strategy) {
                expr.strategy = DefaultSortingStrategy.instance();
            }
            var isDate = grid && grid.getColumnByName(expr.fieldName) ?
                grid.getColumnByName(expr.fieldName).dataType === DATE_TYPE : false;
            data = expr.strategy.sort(data, expr.fieldName, expr.dir, expr.ignoreCase, this.getFieldValue, isDate);
            if (expressionIndex === exprsLen - 1) {
                return data;
            }
            // in case of multiple sorting
            for (i = 0; i < dataLen; i++) {
                gbData = this.groupedRecordsByExpression(data, i, expr, isDate);
                gbDataLen = gbData.length;
                if (gbDataLen > 1) {
                    gbData = this.sortDataRecursive(gbData, expressions, expressionIndex + 1, grid);
                }
                for (j = 0; j < gbDataLen; j++) {
                    data[i + j] = gbData[j];
                }
                i += gbDataLen - 1;
            }
            return data;
        };
        return IgxSorting;
    }());
    var IgxDataRecordSorting = /** @class */ (function (_super) {
        __extends(IgxDataRecordSorting, _super);
        function IgxDataRecordSorting() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxDataRecordSorting.prototype.getFieldValue = function (obj, key, isDate) {
            if (isDate === void 0) { isDate = false; }
            return isDate ? parseDate(resolveNestedPath(obj.data, key)) : resolveNestedPath(obj.data, key);
        };
        return IgxDataRecordSorting;
    }(IgxSorting));

    var IgxGrouping = /** @class */ (function (_super) {
        __extends(IgxGrouping, _super);
        function IgxGrouping() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxGrouping.prototype.groupBy = function (data, state, grid, groupsRecords, fullResult) {
            if (fullResult === void 0) { fullResult = { data: [], metadata: [] }; }
            var metadata = [];
            var grouping = this.groupDataRecursive(data, state, 0, null, metadata, grid, groupsRecords, fullResult);
            return {
                data: grouping,
                metadata: metadata
            };
        };
        return IgxGrouping;
    }(IgxSorting));

    (function (PagingError) {
        PagingError[PagingError["None"] = 0] = "None";
        PagingError[PagingError["IncorrectPageIndex"] = 1] = "IncorrectPageIndex";
        PagingError[PagingError["IncorrectRecordsPerPage"] = 2] = "IncorrectRecordsPerPage";
    })(exports.PagingError || (exports.PagingError = {}));

    (function (FilteringLogic) {
        FilteringLogic[FilteringLogic["And"] = 0] = "And";
        FilteringLogic[FilteringLogic["Or"] = 1] = "Or";
    })(exports.FilteringLogic || (exports.FilteringLogic = {}));

    (function (FilteringExpressionsTreeType) {
        FilteringExpressionsTreeType[FilteringExpressionsTreeType["Regular"] = 0] = "Regular";
        FilteringExpressionsTreeType[FilteringExpressionsTreeType["Advanced"] = 1] = "Advanced";
    })(exports.FilteringExpressionsTreeType || (exports.FilteringExpressionsTreeType = {}));
    var FilteringExpressionsTree = /** @class */ (function () {
        function FilteringExpressionsTree(operator, fieldName) {
            /**
             * Sets/gets the filtering operands.
             * ```typescript
             * const gridExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
             * const expression = [
             * {
             *   condition: IgxStringFilteringOperand.instance().condition('contains'),
             *   fieldName: 'Column Field',
             *   searchVal: 'Value',
             *   ignoreCase: false
             * }];
             * gridExpressionsTree.filteringOperands.push(expression);
             * this.grid.filteringExpressionsTree = gridExpressionsTree;
             * ```
             * ```typescript
             * let filteringOperands = gridExpressionsTree.filteringOperands;
             * ```
             *
             * @memberof FilteringExpressionsTree
             */
            this.filteringOperands = [];
            this.operator = operator;
            this.fieldName = fieldName;
        }
        /**
         * Checks if filtering expressions tree is empty.
         *
         * @param expressionTree filtering expressions tree.
         */
        FilteringExpressionsTree.empty = function (expressionTree) {
            return !expressionTree || !expressionTree.filteringOperands || !expressionTree.filteringOperands.length;
        };
        /**
         * Returns the filtering expression for a column with the provided fieldName.
         * ```typescript
         * let filteringExpression = gridExpressionTree.find('Column Field');
         * ```
         *
         * @memberof FilteringExpressionsTree
         */
        FilteringExpressionsTree.prototype.find = function (fieldName) {
            var index = this.findIndex(fieldName);
            if (index > -1) {
                return this.filteringOperands[index];
            }
            return null;
        };
        /**
         * Returns the index of the filtering expression for a column with the provided fieldName.
         * ```typescript
         * let filteringExpressionIndex = gridExpressionTree.findIndex('Column Field');
         * ```
         *
         * @memberof FilteringExpressionsTree
         */
        FilteringExpressionsTree.prototype.findIndex = function (fieldName) {
            var expr;
            for (var i = 0; i < this.filteringOperands.length; i++) {
                expr = this.filteringOperands[i];
                if (expr instanceof FilteringExpressionsTree) {
                    if (this.isFilteringExpressionsTreeForColumn(expr, fieldName)) {
                        return i;
                    }
                }
                else {
                    if (expr.fieldName === fieldName) {
                        return i;
                    }
                }
            }
            return -1;
        };
        FilteringExpressionsTree.prototype.isFilteringExpressionsTreeForColumn = function (expressionsTree, fieldName) {
            var e_1, _a;
            if (expressionsTree.fieldName === fieldName) {
                return true;
            }
            try {
                for (var _b = __values(expressionsTree.filteringOperands), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var expr = _c.value;
                    if ((expr instanceof FilteringExpressionsTree)) {
                        return this.isFilteringExpressionsTreeForColumn(expr, fieldName);
                    }
                    else {
                        return expr.fieldName === fieldName;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return false;
        };
        return FilteringExpressionsTree;
    }());

    var DateType = 'date';
    var NoopFilteringStrategy = /** @class */ (function () {
        function NoopFilteringStrategy() {
        }
        NoopFilteringStrategy.instance = function () {
            return this._instance || (this._instance = new NoopFilteringStrategy());
        };
        NoopFilteringStrategy.prototype.filter = function (data, _, __) {
            return data;
        };
        return NoopFilteringStrategy;
    }());
    NoopFilteringStrategy._instance = null;
    var BaseFilteringStrategy = /** @class */ (function () {
        function BaseFilteringStrategy() {
        }
        BaseFilteringStrategy.prototype.findMatchByExpression = function (rec, expr, isDate, grid) {
            var cond = expr.condition;
            var val = this.getFieldValue(rec, expr.fieldName, isDate, grid);
            return cond.logic(val, expr.searchVal, expr.ignoreCase);
        };
        BaseFilteringStrategy.prototype.matchRecord = function (rec, expressions, grid) {
            var e_1, _a;
            if (expressions) {
                if (expressions instanceof FilteringExpressionsTree) {
                    var expressionsTree = expressions;
                    var operator = expressionsTree.operator;
                    var matchOperand = void 0;
                    if (expressionsTree.filteringOperands && expressionsTree.filteringOperands.length) {
                        try {
                            for (var _b = __values(expressionsTree.filteringOperands), _c = _b.next(); !_c.done; _c = _b.next()) {
                                var operand = _c.value;
                                matchOperand = this.matchRecord(rec, operand, grid);
                                // Return false if at least one operand does not match and the filtering logic is And
                                if (!matchOperand && operator === exports.FilteringLogic.And) {
                                    return false;
                                }
                                // Return true if at least one operand matches and the filtering logic is Or
                                if (matchOperand && operator === exports.FilteringLogic.Or) {
                                    return true;
                                }
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        return matchOperand;
                    }
                    return true;
                }
                else {
                    var expression = expressions;
                    var isDate = grid && grid.getColumnByName(expression.fieldName) ?
                        grid.getColumnByName(expression.fieldName).dataType === DateType : false;
                    return this.findMatchByExpression(rec, expression, isDate, grid);
                }
            }
            return true;
        };
        return BaseFilteringStrategy;
    }());
    var FilteringStrategy = /** @class */ (function (_super) {
        __extends(FilteringStrategy, _super);
        function FilteringStrategy() {
            return _super.call(this) || this;
        }
        FilteringStrategy.instance = function () {
            return this._instace || (this._instace = new this());
        };
        FilteringStrategy.prototype.filter = function (data, expressionsTree, advancedExpressionsTree, grid) {
            var i;
            var rec;
            var len = data.length;
            var res = [];
            if ((FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree)) || !len) {
                return data;
            }
            for (i = 0; i < len; i++) {
                rec = data[i];
                if (this.matchRecord(rec, expressionsTree, grid) && this.matchRecord(rec, advancedExpressionsTree, grid)) {
                    res.push(rec);
                }
            }
            return res;
        };
        FilteringStrategy.prototype.getFieldValue = function (rec, fieldName, isDate) {
            if (isDate === void 0) { isDate = false; }
            var value = resolveNestedPath(rec, fieldName);
            value = value && isDate ? parseDate(value) : value;
            return value;
        };
        return FilteringStrategy;
    }(BaseFilteringStrategy));
    FilteringStrategy._instace = null;
    var FormattedValuesFilteringStrategy = /** @class */ (function (_super) {
        __extends(FormattedValuesFilteringStrategy, _super);
        /**
         * Creates a new instance of FormattedValuesFilteringStrategy.
         *
         * @param fields An array of column field names that should be formatted.
         * If omitted the values of all columns which has formatter will be formatted.
         */
        function FormattedValuesFilteringStrategy(fields) {
            var _this = _super.call(this) || this;
            _this.fields = fields;
            return _this;
        }
        /** @hidden */
        FormattedValuesFilteringStrategy.prototype.shouldApplyFormatter = function (fieldName) {
            return !this.fields || this.fields.length === 0 || this.fields.some(function (f) { return f === fieldName; });
        };
        FormattedValuesFilteringStrategy.prototype.getFieldValue = function (rec, fieldName, isDate, grid) {
            if (isDate === void 0) { isDate = false; }
            var column = grid.getColumnByName(fieldName);
            var value = resolveNestedPath(rec, fieldName);
            value = column.formatter && this.shouldApplyFormatter(fieldName) ?
                column.formatter(value) :
                value && isDate ? parseDate(value) : value;
            return value;
        };
        return FormattedValuesFilteringStrategy;
    }(FilteringStrategy));

    (function (TransactionType) {
        TransactionType["ADD"] = "add";
        TransactionType["DELETE"] = "delete";
        TransactionType["UPDATE"] = "update";
    })(exports.TransactionType || (exports.TransactionType = {}));
    (function (TransactionEventOrigin) {
        TransactionEventOrigin["UNDO"] = "undo";
        TransactionEventOrigin["REDO"] = "redo";
        TransactionEventOrigin["CLEAR"] = "clear";
        TransactionEventOrigin["ADD"] = "add";
        TransactionEventOrigin["END"] = "endPending";
    })(exports.TransactionEventOrigin || (exports.TransactionEventOrigin = {}));

    /**
     * @hidden
     */
    var DataType = mkenum({
        String: 'string',
        Number: 'number',
        Boolean: 'boolean',
        Date: 'date',
        Currency: 'currency',
        Percent: 'percent'
    });
    /**
     * @hidden
     */
    var DataUtil = /** @class */ (function () {
        function DataUtil() {
        }
        DataUtil.sort = function (data, expressions, sorting, grid) {
            if (sorting === void 0) { sorting = new IgxSorting(); }
            return sorting.sort(data, expressions, grid);
        };
        DataUtil.treeGridSort = function (hierarchicalData, expressions, sorting, parent, grid) {
            if (sorting === void 0) { sorting = new IgxDataRecordSorting(); }
            var res = [];
            hierarchicalData.forEach(function (hr) {
                var rec = DataUtil.cloneTreeGridRecord(hr);
                rec.parent = parent;
                if (rec.children) {
                    rec.children = DataUtil.treeGridSort(rec.children, expressions, sorting, rec, grid);
                }
                res.push(rec);
            });
            res = DataUtil.sort(res, expressions, sorting, grid);
            return res;
        };
        DataUtil.cloneTreeGridRecord = function (hierarchicalRecord) {
            var rec = {
                rowID: hierarchicalRecord.rowID,
                data: hierarchicalRecord.data,
                children: hierarchicalRecord.children,
                isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
                level: hierarchicalRecord.level,
                expanded: hierarchicalRecord.expanded
            };
            return rec;
        };
        DataUtil.group = function (data, state, grid, groupsRecords, fullResult) {
            if (grid === void 0) { grid = null; }
            if (groupsRecords === void 0) { groupsRecords = []; }
            if (fullResult === void 0) { fullResult = { data: [], metadata: [] }; }
            var grouping = new IgxGrouping();
            groupsRecords.splice(0, groupsRecords.length);
            return grouping.groupBy(data, state, grid, groupsRecords, fullResult);
        };
        DataUtil.page = function (data, state, dataLength) {
            if (!state) {
                return data;
            }
            var len = dataLength !== undefined ? dataLength : data.length;
            var index = state.index;
            var res = [];
            var recordsPerPage = dataLength !== undefined && state.recordsPerPage > dataLength ? dataLength : state.recordsPerPage;
            state.metadata = {
                countPages: 0,
                countRecords: len,
                error: exports.PagingError.None
            };
            if (index < 0 || isNaN(index)) {
                state.metadata.error = exports.PagingError.IncorrectPageIndex;
                return res;
            }
            if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
                state.metadata.error = exports.PagingError.IncorrectRecordsPerPage;
                return res;
            }
            state.metadata.countPages = Math.ceil(len / recordsPerPage);
            if (!len) {
                return data;
            }
            if (index >= state.metadata.countPages) {
                state.metadata.error = exports.PagingError.IncorrectPageIndex;
                return res;
            }
            return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
        };
        DataUtil.filter = function (data, state, grid) {
            if (!state.strategy) {
                state.strategy = new FilteringStrategy();
            }
            return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree, grid);
        };
        DataUtil.correctPagingState = function (state, length) {
            var maxPage = Math.ceil(length / state.recordsPerPage) - 1;
            if (!isNaN(maxPage) && state.index > maxPage) {
                state.index = maxPage;
            }
        };
        DataUtil.getHierarchy = function (gRow) {
            return getHierarchy(gRow);
        };
        DataUtil.isHierarchyMatch = function (h1, h2) {
            return isHierarchyMatch(h1, h2);
        };
        /**
         * Merges all changes from provided transactions into provided data collection
         *
         * @param data Collection to merge
         * @param transactions Transactions to merge into data
         * @param primaryKey Primary key of the collection, if any
         * @param deleteRows Should delete rows with DELETE transaction type from data
         * @returns Provided data collections updated with all provided transactions
         */
        DataUtil.mergeTransactions = function (data, transactions, primaryKey, deleteRows) {
            if (deleteRows === void 0) { deleteRows = false; }
            data.forEach(function (item, index) {
                var rowId = primaryKey ? item[primaryKey] : item;
                var transaction = transactions.find(function (t) { return t.id === rowId; });
                if (transaction && transaction.type === exports.TransactionType.UPDATE) {
                    data[index] = transaction.newValue;
                }
            });
            if (deleteRows) {
                transactions
                    .filter(function (t) { return t.type === exports.TransactionType.DELETE; })
                    .forEach(function (t) {
                    var index = primaryKey ? data.findIndex(function (d) { return d[primaryKey] === t.id; }) : data.findIndex(function (d) { return d === t.id; });
                    if (0 <= index && index < data.length) {
                        data.splice(index, 1);
                    }
                });
            }
            data.push.apply(data, __spread(transactions
                .filter(function (t) { return t.type === exports.TransactionType.ADD; })
                .map(function (t) { return t.newValue; })));
            return data;
        };
        /**
         * Merges all changes from provided transactions into provided hierarchical data collection
         *
         * @param data Collection to merge
         * @param transactions Transactions to merge into data
         * @param childDataKey Data key of child collections
         * @param primaryKey Primary key of the collection, if any
         * @param deleteRows Should delete rows with DELETE transaction type from data
         * @returns Provided data collections updated with all provided transactions
         */
        DataUtil.mergeHierarchicalTransactions = function (data, transactions, childDataKey, primaryKey, deleteRows) {
            var e_1, _a;
            if (deleteRows === void 0) { deleteRows = false; }
            var _loop_1 = function (transaction) {
                if (transaction.path) {
                    var parent = this_1.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                    var collection = parent ? parent[childDataKey] : data;
                    switch (transaction.type) {
                        case exports.TransactionType.ADD:
                            //  if there is no parent this is ADD row at root level
                            if (parent && !parent[childDataKey]) {
                                parent[childDataKey] = collection = [];
                            }
                            collection.push(transaction.newValue);
                            break;
                        case exports.TransactionType.UPDATE:
                            var updateIndex = collection.findIndex(function (x) { return x[primaryKey] === transaction.id; });
                            if (updateIndex !== -1) {
                                collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                            }
                            break;
                        case exports.TransactionType.DELETE:
                            if (deleteRows) {
                                var deleteIndex = collection.findIndex(function (r) { return r[primaryKey] === transaction.id; });
                                if (deleteIndex !== -1) {
                                    collection.splice(deleteIndex, 1);
                                }
                            }
                            break;
                    }
                }
                else {
                    //  if there is no path this is ADD row in root. Push the newValue to data
                    data.push(transaction.newValue);
                }
            };
            var this_1 = this;
            try {
                for (var transactions_1 = __values(transactions), transactions_1_1 = transactions_1.next(); !transactions_1_1.done; transactions_1_1 = transactions_1.next()) {
                    var transaction = transactions_1_1.value;
                    _loop_1(transaction);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (transactions_1_1 && !transactions_1_1.done && (_a = transactions_1.return)) _a.call(transactions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return data;
        };
        DataUtil.parseValue = function (dataType, value) {
            if (dataType === DataType.Number || dataType === DataType.Currency || dataType === DataType.Percent) {
                value = parseFloat(value);
            }
            return value;
        };
        DataUtil.findParentFromPath = function (data, primaryKey, childDataKey, path) {
            var e_2, _a;
            var collection = data;
            var result;
            var _loop_2 = function (id) {
                result = collection && collection.find(function (x) { return x[primaryKey] === id; });
                if (!result) {
                    return "break";
                }
                collection = result[childDataKey];
            };
            try {
                for (var path_1 = __values(path), path_1_1 = path_1.next(); !path_1_1.done; path_1_1 = path_1.next()) {
                    var id = path_1_1.value;
                    var state_1 = _loop_2(id);
                    if (state_1 === "break")
                        break;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (path_1_1 && !path_1_1.done && (_a = path_1.return)) _a.call(path_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return result;
        };
        return DataUtil;
    }());

    /**
     * @hidden
     */
    var ExportUtilities = /** @class */ (function () {
        function ExportUtilities() {
        }
        ExportUtilities.getKeysFromData = function (data) {
            var length = data.length;
            if (length === 0) {
                return [];
            }
            var dataEntry = data[0];
            var dataEntryMiddle = data[Math.floor(length / 2)];
            var dataEntryLast = data[length - 1];
            var keys1 = Object.keys(dataEntry);
            var keys2 = Object.keys(dataEntryMiddle);
            var keys3 = Object.keys(dataEntryLast);
            var keys = new Set(keys1.concat(keys2).concat(keys3));
            return !ExportUtilities.isSpecialData(data) ? Array.from(keys) : ['Column 1'];
        };
        ExportUtilities.saveBlobToFile = function (blob, fileName) {
            var a = document.createElement('a');
            if (window.navigator && window.navigator.msSaveOrOpenBlob) {
                window.navigator.msSaveOrOpenBlob(blob, fileName);
            }
            else {
                var url = window.URL.createObjectURL(blob);
                a.download = fileName;
                a.href = url;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }
        };
        ExportUtilities.stringToArrayBuffer = function (s) {
            var buf = new ArrayBuffer(s.length);
            var view = new Uint8Array(buf);
            for (var i = 0; i !== s.length; ++i) {
                /* eslint-disable  no-bitwise */
                view[i] = s.charCodeAt(i) & 0xFF;
                /* eslint-enable  no-bitwise */
            }
            return buf;
        };
        ExportUtilities.isSpecialData = function (data) {
            var dataEntry = data[0];
            return (typeof dataEntry === 'string' ||
                typeof dataEntry === 'number' ||
                dataEntry instanceof Date);
        };
        ExportUtilities.hasValue = function (value) {
            return value !== undefined && value !== null;
        };
        ExportUtilities.isNullOrWhitespaces = function (value) {
            return value === undefined || value === null || !value.trim();
        };
        return ExportUtilities;
    }());

    var TreeGridFilteringStrategy = /** @class */ (function (_super) {
        __extends(TreeGridFilteringStrategy, _super);
        function TreeGridFilteringStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TreeGridFilteringStrategy.prototype.filter = function (data, expressionsTree, advancedExpressionsTree, grid) {
            return this.filterImpl(data, expressionsTree, advancedExpressionsTree, undefined, grid);
        };
        TreeGridFilteringStrategy.prototype.getFieldValue = function (rec, fieldName, isDate) {
            if (isDate === void 0) { isDate = false; }
            var hierarchicalRecord = rec;
            var value = resolveNestedPath(hierarchicalRecord.data, fieldName);
            value = value && isDate ? parseDate(value) : value;
            return value;
        };
        TreeGridFilteringStrategy.prototype.filterImpl = function (data, expressionsTree, advancedExpressionsTree, parent, grid) {
            var i;
            var rec;
            var len = data.length;
            var res = [];
            if ((FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree)) || !len) {
                return data;
            }
            for (i = 0; i < len; i++) {
                rec = DataUtil.cloneTreeGridRecord(data[i]);
                rec.parent = parent;
                if (rec.children) {
                    var filteredChildren = this.filterImpl(rec.children, expressionsTree, advancedExpressionsTree, rec, grid);
                    rec.children = filteredChildren.length > 0 ? filteredChildren : null;
                }
                if (this.matchRecord(rec, expressionsTree, grid) && this.matchRecord(rec, advancedExpressionsTree, grid)) {
                    res.push(rec);
                }
                else if (rec.children && rec.children.length > 0) {
                    rec.isFilteredOutParent = true;
                    res.push(rec);
                }
            }
            return res;
        };
        return TreeGridFilteringStrategy;
    }(BaseFilteringStrategy));
    var TreeGridFormattedValuesFilteringStrategy = /** @class */ (function (_super) {
        __extends(TreeGridFormattedValuesFilteringStrategy, _super);
        /**
         * Creates a new instance of FormattedValuesFilteringStrategy.
         *
         * @param fields An array of column field names that should be formatted.
         * If omitted the values of all columns which has formatter will be formatted.
         */
        function TreeGridFormattedValuesFilteringStrategy(fields) {
            var _this = _super.call(this) || this;
            _this.fields = fields;
            return _this;
        }
        /** @hidden */
        TreeGridFormattedValuesFilteringStrategy.prototype.shouldApplyFormatter = function (fieldName) {
            return !this.fields || this.fields.length === 0 || this.fields.some(function (f) { return f === fieldName; });
        };
        TreeGridFormattedValuesFilteringStrategy.prototype.getFieldValue = function (rec, fieldName, isDate, grid) {
            if (isDate === void 0) { isDate = false; }
            var column = grid.getColumnByName(fieldName);
            var hierarchicalRecord = rec;
            var value = resolveNestedPath(hierarchicalRecord.data, fieldName);
            value = column.formatter && this.shouldApplyFormatter(fieldName) ?
                column.formatter(value) :
                value && isDate ? parseDate(value) : value;
            return value;
        };
        return TreeGridFormattedValuesFilteringStrategy;
    }(TreeGridFilteringStrategy));

    (function (ExportRecordType) {
        ExportRecordType[ExportRecordType["GroupedRecord"] = 1] = "GroupedRecord";
        ExportRecordType[ExportRecordType["TreeGridRecord"] = 2] = "TreeGridRecord";
        ExportRecordType[ExportRecordType["DataRecord"] = 3] = "DataRecord";
    })(exports.ExportRecordType || (exports.ExportRecordType = {}));
    var DEFAULT_COLUMN_WIDTH = 8.43;
    var IgxBaseExporter = /** @class */ (function () {
        function IgxBaseExporter() {
            this.exportEnded = new i0.EventEmitter();
            /**
             * This event is emitted when a row is exported.
             * ```typescript
             * this.exporterService.rowExporting.subscribe((args: IRowExportingEventArgs) => {
             * // put event handler code here
             * });
             * ```
             *
             * @memberof IgxBaseExporter
             */
            this.rowExporting = new i0.EventEmitter();
            /**
             * This event is emitted when a column is exported.
             * ```typescript
             * this.exporterService.columnExporting.subscribe((args: IColumnExportingEventArgs) => {
             * // put event handler code here
             * });
             * ```
             *
             * @memberof IgxBaseExporter
             */
            this.columnExporting = new i0.EventEmitter();
            this._indexOfLastPinnedColumn = -1;
            this._sort = null;
            this.flatRecords = [];
        }
        Object.defineProperty(IgxBaseExporter.prototype, "columnWidthList", {
            get: function () {
                return this._columnWidthList;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Method for exporting IgxGrid component's data.
         * ```typescript
         * this.exporterService.export(this.igxGridForExport, this.exportOptions);
         * ```
         *
         * @memberof IgxBaseExporter
         */
        IgxBaseExporter.prototype.export = function (grid, options) {
            var _this = this;
            if (options === undefined || options === null) {
                throw Error('No options provided!');
            }
            var columns = grid.columnList.toArray();
            this._columnList = new Array(columns.length);
            this._columnWidthList = new Array(columns.filter(function (c) { return !c.hidden; }).length);
            var hiddenColumns = [];
            var lastVisibleColumnIndex = -1;
            columns.forEach(function (column) {
                var columnHeader = !ExportUtilities.isNullOrWhitespaces(column.header) ? column.header : column.field;
                var exportColumn = !column.hidden || options.ignoreColumnsVisibility;
                var index = options.ignoreColumnsOrder || options.ignoreColumnsVisibility ? column.index : column.visibleIndex;
                var columnWidth = Number(column.width.slice(0, -2));
                var columnInfo = {
                    header: columnHeader,
                    dataType: column.dataType,
                    field: column.field,
                    skip: !exportColumn,
                    formatter: column.formatter,
                    skipFormatter: false
                };
                if (index !== -1) {
                    _this._columnList[index] = columnInfo;
                    _this._columnWidthList[index] = columnWidth;
                    lastVisibleColumnIndex = Math.max(lastVisibleColumnIndex, index);
                }
                else {
                    hiddenColumns.push(columnInfo);
                }
                if (column.pinned && exportColumn) {
                    _this._indexOfLastPinnedColumn++;
                }
            });
            // Append the hidden columns to the end of the list
            hiddenColumns.forEach(function (hiddenColumn) {
                _this._columnList[++lastVisibleColumnIndex] = hiddenColumn;
            });
            this.prepareData(grid, options);
            this.exportGridRecordsData(this.flatRecords, options);
        };
        /**
         * Method for exporting any kind of array data.
         * ```typescript
         * this.exporterService.exportData(this.arrayForExport, this.exportOptions);
         * ```
         *
         * @memberof IgxBaseExporter
         */
        IgxBaseExporter.prototype.exportData = function (data, options) {
            if (options === undefined || options === null) {
                throw Error('No options provided!');
            }
            var records = data.map(function (d) {
                var record = {
                    data: d,
                    type: exports.ExportRecordType.DataRecord,
                    level: 0
                };
                return record;
            });
            this.exportGridRecordsData(records, options);
        };
        IgxBaseExporter.prototype.exportGridRecordsData = function (records, options) {
            var _this = this;
            if (options === undefined || options === null) {
                throw Error('No options provided!');
            }
            if (!this._columnList || this._columnList.length === 0) {
                var recordsData = records.map(function (r) { return r.data; });
                var keys = ExportUtilities.getKeysFromData(recordsData);
                this._columnList = keys.map(function (k) { return ({ header: k, field: k, skip: false }); });
                this._columnWidthList = new Array(keys.length).fill(DEFAULT_COLUMN_WIDTH);
            }
            var skippedPinnedColumnsCount = 0;
            var columnsWithoutHeaderCount = 1;
            this._columnList.forEach(function (column, index) {
                if (!column.skip) {
                    var columnExportArgs = {
                        header: !ExportUtilities.isNullOrWhitespaces(column.header) ?
                            column.header :
                            'Column' + columnsWithoutHeaderCount++,
                        field: column.field,
                        columnIndex: index,
                        cancel: false,
                        skipFormatter: false
                    };
                    _this.columnExporting.emit(columnExportArgs);
                    column.header = columnExportArgs.header;
                    column.skip = columnExportArgs.cancel;
                    column.skipFormatter = columnExportArgs.skipFormatter;
                    if (column.skip && index <= _this._indexOfLastPinnedColumn) {
                        skippedPinnedColumnsCount++;
                    }
                    if (_this._sort && _this._sort.fieldName === column.field) {
                        if (column.skip) {
                            _this._sort = null;
                        }
                        else {
                            _this._sort.fieldName = column.header;
                        }
                    }
                }
            });
            this._indexOfLastPinnedColumn -= skippedPinnedColumnsCount;
            var dataToExport = new Array();
            var actualData = records.map(function (r) { return r.data; });
            var isSpecialData = ExportUtilities.isSpecialData(actualData);
            yieldingLoop(records.length, 100, function (i) {
                var row = records[i];
                _this.exportRow(dataToExport, row, i, isSpecialData);
            }, function () {
                _this.exportDataImplementation(dataToExport, options);
                _this.resetDefaults();
            });
        };
        IgxBaseExporter.prototype.exportRow = function (data, record, index, isSpecialData) {
            if (!isSpecialData) {
                record.data = this._columnList.reduce(function (a, e) {
                    if (!e.skip) {
                        var rawValue = resolveNestedPath(record.data, e.field);
                        var shouldApplyFormatter = e.formatter && !e.skipFormatter && record.type !== exports.ExportRecordType.GroupedRecord;
                        if (e.dataType === 'date' &&
                            !(rawValue instanceof Date) &&
                            !shouldApplyFormatter &&
                            rawValue !== undefined &&
                            rawValue !== null) {
                            rawValue = new Date(rawValue);
                        }
                        else if (e.dataType === 'string' && rawValue instanceof Date) {
                            rawValue = rawValue.toString();
                        }
                        a[e.header] = shouldApplyFormatter ? e.formatter(rawValue) : rawValue;
                    }
                    return a;
                }, {});
            }
            var rowArgs = {
                rowData: record.data,
                rowIndex: index,
                cancel: false
            };
            this.rowExporting.emit(rowArgs);
            if (!rowArgs.cancel) {
                data.push(record);
            }
        };
        IgxBaseExporter.prototype.prepareData = function (grid, options) {
            this.flatRecords = [];
            var tagName = grid.nativeElement.tagName.toLowerCase();
            var hasFiltering = (grid.filteringExpressionsTree && grid.filteringExpressionsTree.filteringOperands.length > 0) ||
                (grid.advancedFilteringExpressionsTree && grid.advancedFilteringExpressionsTree.filteringOperands.length > 0);
            var hasSorting = grid.sortingExpressions &&
                grid.sortingExpressions.length > 0;
            if (tagName === 'igx-grid') {
                this.prepareGridData(grid, options, hasFiltering, hasSorting);
            }
            if (tagName === 'igx-tree-grid') {
                this.prepareTreeGridData(grid, options, hasFiltering, hasSorting);
            }
        };
        IgxBaseExporter.prototype.prepareGridData = function (grid, options, hasFiltering, hasSorting) {
            var groupedGridGroupingState = {
                expressions: grid.groupingExpressions,
                expansion: grid.groupingExpansionState,
                defaultExpanded: grid.groupsExpanded,
            };
            var hasGrouping = grid.groupingExpressions &&
                grid.groupingExpressions.length > 0;
            var skipOperations = (!hasFiltering || !options.ignoreFiltering) &&
                (!hasSorting || !options.ignoreSorting) &&
                (!hasGrouping || !options.ignoreGrouping);
            if (skipOperations) {
                if (hasGrouping) {
                    this.addGroupedData(grid, grid.groupsRecords, groupedGridGroupingState);
                }
                else {
                    this.addFlatData(grid.filteredSortedData);
                }
            }
            else {
                var gridData = grid.data;
                if (hasFiltering && !options.ignoreFiltering) {
                    var filteringState = {
                        expressionsTree: grid.filteringExpressionsTree,
                        advancedExpressionsTree: grid.advancedFilteringExpressionsTree,
                    };
                    filteringState.strategy = grid.filterStrategy;
                    gridData = DataUtil.filter(gridData, filteringState, grid);
                }
                if (hasSorting && !options.ignoreSorting) {
                    // TODO: We should drop support for this since in a grouped grid it doesn't make sense
                    // this._sort = !isGroupedGrid ?
                    //     cloneValue(grid.sortingExpressions[0]) :
                    //     grid.sortingExpressions.length > 1 ?
                    //         cloneValue(grid.sortingExpressions[1]) :
                    //         cloneValue(grid.sortingExpressions[0]);
                    gridData = DataUtil.sort(gridData, grid.sortingExpressions, grid.sortStrategy, grid);
                }
                if (hasGrouping && !options.ignoreGrouping) {
                    var groupsRecords = [];
                    DataUtil.group(cloneArray(gridData), groupedGridGroupingState, grid, groupsRecords);
                    gridData = groupsRecords;
                }
                if (hasGrouping && !options.ignoreGrouping) {
                    this.addGroupedData(grid, gridData, groupedGridGroupingState);
                }
                else {
                    this.addFlatData(gridData);
                }
            }
        };
        IgxBaseExporter.prototype.prepareTreeGridData = function (grid, options, hasFiltering, hasSorting) {
            var skipOperations = (!hasFiltering || !options.ignoreFiltering) &&
                (!hasSorting || !options.ignoreSorting);
            if (skipOperations) {
                this.addTreeGridData(grid.processedRootRecords);
            }
            else {
                var gridData = grid.rootRecords;
                if (hasFiltering && !options.ignoreFiltering) {
                    var filteringState = {
                        expressionsTree: grid.filteringExpressionsTree,
                        advancedExpressionsTree: grid.advancedFilteringExpressionsTree,
                    };
                    filteringState.strategy = (grid.filterStrategy) ? grid.filterStrategy : new TreeGridFilteringStrategy();
                    gridData = filteringState.strategy
                        .filter(gridData, filteringState.expressionsTree, filteringState.advancedExpressionsTree);
                }
                if (hasSorting && !options.ignoreSorting) {
                    this._sort = cloneValue(grid.sortingExpressions[0]);
                    gridData = DataUtil.treeGridSort(gridData, grid.sortingExpressions, grid.sortStrategy);
                }
                this.addTreeGridData(gridData);
            }
        };
        IgxBaseExporter.prototype.addTreeGridData = function (records, parentExpanded) {
            var e_1, _a;
            if (parentExpanded === void 0) { parentExpanded = true; }
            if (!records) {
                return;
            }
            try {
                for (var records_1 = __values(records), records_1_1 = records_1.next(); !records_1_1.done; records_1_1 = records_1.next()) {
                    var record = records_1_1.value;
                    var hierarchicalRecord = {
                        data: record.data,
                        level: record.level,
                        hidden: !parentExpanded,
                        type: exports.ExportRecordType.TreeGridRecord
                    };
                    this.flatRecords.push(hierarchicalRecord);
                    this.addTreeGridData(record.children, parentExpanded && record.expanded);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (records_1_1 && !records_1_1.done && (_a = records_1.return)) _a.call(records_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        IgxBaseExporter.prototype.addFlatData = function (records) {
            var e_2, _a;
            if (!records) {
                return;
            }
            try {
                for (var records_2 = __values(records), records_2_1 = records_2.next(); !records_2_1.done; records_2_1 = records_2.next()) {
                    var record = records_2_1.value;
                    var data = {
                        data: record,
                        type: exports.ExportRecordType.DataRecord,
                        level: 0
                    };
                    this.flatRecords.push(data);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (records_2_1 && !records_2_1.done && (_a = records_2.return)) _a.call(records_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        IgxBaseExporter.prototype.addGroupedData = function (grid, records, groupingState, parentExpanded) {
            var e_3, _a;
            if (parentExpanded === void 0) { parentExpanded = true; }
            if (!records) {
                return;
            }
            var firstCol = this._columnList[0].field;
            var _loop_1 = function (record) {
                var _a, e_4, _b;
                var recordVal = record.value;
                var hierarchy = getHierarchy(record);
                var expandState = groupingState.expansion.find(function (s) { return isHierarchyMatch(s.hierarchy || [{ fieldName: record.expression.fieldName, value: recordVal }], hierarchy); });
                var expanded = expandState ? expandState.expanded : groupingState.defaultExpanded;
                var isDate = recordVal instanceof Date;
                if (isDate) {
                    var timeZoneOffset = recordVal.getTimezoneOffset() * 60000;
                    var isoString = (new Date(recordVal - timeZoneOffset)).toISOString();
                    var pipe = new i2.DatePipe(grid.locale);
                    recordVal = pipe.transform(isoString);
                }
                var groupExpressionName = record.column && record.column.header ?
                    record.column.header :
                    record.expression.fieldName;
                recordVal = recordVal !== null ? recordVal : '';
                var groupExpression = {
                    data: (_a = {}, _a[firstCol] = groupExpressionName + ": " + recordVal + " (" + record.records.length + ")", _a),
                    level: record.level,
                    hidden: !parentExpanded,
                    type: exports.ExportRecordType.GroupedRecord,
                };
                this_1.flatRecords.push(groupExpression);
                if (record.groups.length > 0) {
                    this_1.addGroupedData(grid, record.groups, groupingState, expanded && parentExpanded);
                }
                else {
                    var rowRecords = record.records;
                    try {
                        for (var rowRecords_1 = (e_4 = void 0, __values(rowRecords)), rowRecords_1_1 = rowRecords_1.next(); !rowRecords_1_1.done; rowRecords_1_1 = rowRecords_1.next()) {
                            var rowRecord = rowRecords_1_1.value;
                            var currentRecord = {
                                data: rowRecord,
                                level: record.level + 1,
                                hidden: !(expanded && parentExpanded),
                                type: exports.ExportRecordType.DataRecord
                            };
                            this_1.flatRecords.push(currentRecord);
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (rowRecords_1_1 && !rowRecords_1_1.done && (_b = rowRecords_1.return)) _b.call(rowRecords_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            };
            var this_1 = this;
            try {
                for (var records_3 = __values(records), records_3_1 = records_3.next(); !records_3_1.done; records_3_1 = records_3.next()) {
                    var record = records_3_1.value;
                    _loop_1(record);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (records_3_1 && !records_3_1.done && (_a = records_3.return)) _a.call(records_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
        };
        IgxBaseExporter.prototype.resetDefaults = function () {
            this._columnList = [];
            this._indexOfLastPinnedColumn = -1;
            this._sort = null;
            this.flatRecords = [];
        };
        return IgxBaseExporter;
    }());

    /**
     * @hidden
     */
    var CharSeparatedValueData = /** @class */ (function () {
        function CharSeparatedValueData(_data, valueDelimiter) {
            this._data = _data;
            this._headerRecord = '';
            this._dataRecords = '';
            this._eor = '\r\n';
            this._escapeCharacters = ['\r', '\n', '\r\n'];
            this._delimiterLength = 1;
            this._isSpecialData = false;
            this.setDelimiter(valueDelimiter);
        }
        CharSeparatedValueData.prototype.prepareData = function (key) {
            if (!this._data || this._data.length === 0) {
                return '';
            }
            var keys = [];
            if (key) {
                keys = key;
            }
            else {
                keys = ExportUtilities.getKeysFromData(this._data);
            }
            if (keys.length === 0) {
                return '';
            }
            this._isSpecialData = ExportUtilities.isSpecialData(this._data);
            this._escapeCharacters.push(this._delimiter);
            this._headerRecord = this.processHeaderRecord(keys);
            this._dataRecords = this.processDataRecords(this._data, keys);
            return this._headerRecord + this._dataRecords;
        };
        CharSeparatedValueData.prototype.prepareDataAsync = function (done) {
            var _this = this;
            if (!this._data || this._data.length === 0) {
                done('');
            }
            var keys = ExportUtilities.getKeysFromData(this._data);
            if (keys.length === 0) {
                done('');
            }
            this._isSpecialData = ExportUtilities.isSpecialData(this._data);
            this._escapeCharacters.push(this._delimiter);
            this._headerRecord = this.processHeaderRecord(keys);
            this.processDataRecordsAsync(this._data, keys, function (dr) {
                done(_this._headerRecord + dr);
            });
        };
        CharSeparatedValueData.prototype.processField = function (value, escapeChars) {
            var safeValue = ExportUtilities.hasValue(value) ? String(value) : '';
            if (escapeChars.some(function (v) { return safeValue.includes(v); })) {
                safeValue = "\"" + safeValue + "\"";
            }
            return safeValue + this._delimiter;
        };
        CharSeparatedValueData.prototype.processHeaderRecord = function (keys) {
            var e_1, _a;
            var recordData = '';
            try {
                for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                    var keyName = keys_1_1.value;
                    recordData += this.processField(keyName, this._escapeCharacters);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return recordData.slice(0, -this._delimiterLength) + this._eor;
        };
        CharSeparatedValueData.prototype.processRecord = function (record, keys) {
            var recordData = new Array(keys.length);
            for (var index = 0; index < keys.length; index++) {
                var value = (record[keys[index]] !== undefined) ? record[keys[index]] : this._isSpecialData ? record : '';
                recordData[index] = this.processField(value, this._escapeCharacters);
            }
            return recordData.join('').slice(0, -this._delimiterLength) + this._eor;
        };
        CharSeparatedValueData.prototype.processDataRecords = function (currentData, keys) {
            var dataRecords = new Array(currentData.length);
            for (var i = 0; i < currentData.length; i++) {
                var row = currentData[i];
                dataRecords[i] = this.processRecord(row, keys);
            }
            return dataRecords.join('');
        };
        CharSeparatedValueData.prototype.processDataRecordsAsync = function (currentData, keys, done) {
            var _this = this;
            var dataRecords = new Array(currentData.length);
            yieldingLoop(currentData.length, 1000, function (i) {
                var row = currentData[i];
                dataRecords[i] = _this.processRecord(row, keys);
            }, function () {
                done(dataRecords.join(''));
            });
        };
        CharSeparatedValueData.prototype.setDelimiter = function (value) {
            this._delimiter = value;
            this._delimiterLength = value.length;
        };
        return CharSeparatedValueData;
    }());

    var IgxExporterOptionsBase = /** @class */ (function () {
        function IgxExporterOptionsBase(fileName, _fileExtension) {
            this._fileExtension = _fileExtension;
            /**
             * Specifies whether hidden columns should be exported.
             * ```typescript
             * let ignoreColumnsVisibility = this.exportOptions.ignoreColumnsVisibility;
             * this.exportOptions.ignoreColumnsVisibility = true;
             * ```
             *
             * @memberof IgxExporterOptionsBase
             */
            this.ignoreColumnsVisibility = false;
            /**
             * Specifies whether filtered out rows should be exported.
             * ```typescript
             * let ignoreFiltering = this.exportOptions.ignoreFiltering;
             * this.exportOptions.ignoreFiltering = true;
             * ```
             *
             * @memberof IgxExporterOptionsBase
             */
            this.ignoreFiltering = false;
            /**
             * Specifies if the exporter should ignore the current column order in the IgxGrid.
             * ```typescript
             * let ignoreColumnsOrder = this.exportOptions.ignoreColumnsOrder;
             * this.exportOptions.ignoreColumnsOrder = true;
             * ```
             *
             * @memberof IgxExporterOptionsBase
             */
            this.ignoreColumnsOrder = false;
            /**
             * Specifies whether the exported data should be sorted as in the provided IgxGrid.
             * When you export grouped data, setting ignoreSorting to true will cause
             * the grouping to fail because it relies on the sorting of the records.
             * ```typescript
             * let ignoreSorting = this.exportOptions.ignoreSorting;
             * this.exportOptions.ignoreSorting = true;
             * ```
             *
             * @memberof IgxExporterOptionsBase
             */
            this.ignoreSorting = false;
            /**
             * Specifies whether the exported data should be grouped as in the provided IgxGrid.
             * ```typescript
             * let ignoreGrouping = this.exportOptions.ignoreGrouping;
             * this.exportOptions.ignoreGrouping = true;
             * ```
             *
             * @memberof IgxExporterOptionsBase
             */
            this.ignoreGrouping = false;
            this.setFileName(fileName);
        }
        IgxExporterOptionsBase.prototype.setFileName = function (fileName) {
            this._fileName = fileName + (fileName.endsWith(this._fileExtension) === false ? this._fileExtension : '');
        };
        Object.defineProperty(IgxExporterOptionsBase.prototype, "fileName", {
            /**
             * Gets the file name which will be used for the exporting operation.
             * ```typescript
             * let fileName = this.exportOptions.fileName;
             * ```
             *
             * @memberof IgxExporterOptionsBase
             */
            get: function () {
                return this._fileName;
            },
            /**
             * Sets the file name which will be used for the exporting operation.
             * ```typescript
             * this.exportOptions.fileName = 'exportedData01';
             * ```
             *
             * @memberof IgxExporterOptionsBase
             */
            set: function (value) {
                this.setFileName(value);
            },
            enumerable: false,
            configurable: true
        });
        return IgxExporterOptionsBase;
    }());

    /**
     * Objects of this class are used to configure the CSV exporting process.
     */
    var IgxCsvExporterOptions = /** @class */ (function (_super) {
        __extends(IgxCsvExporterOptions, _super);
        function IgxCsvExporterOptions(fileName, fileType) {
            var _this = _super.call(this, fileName, IgxCsvExporterOptions.getExtensionFromFileType(fileType)) || this;
            _this.setFileType(fileType);
            _this.setDelimiter();
            return _this;
        }
        IgxCsvExporterOptions.getExtensionFromFileType = function (fType) {
            var extension = '';
            switch (fType) {
                case exports.CsvFileTypes.CSV:
                    extension = '.csv';
                    break;
                case exports.CsvFileTypes.TSV:
                    extension = '.tsv';
                    break;
                case exports.CsvFileTypes.TAB:
                    extension = '.tab';
                    break;
                default:
                    throw Error('Unsupported CSV file type!');
            }
            return extension;
        };
        Object.defineProperty(IgxCsvExporterOptions.prototype, "valueDelimiter", {
            /**
             * Gets the value delimiter which will be used for the exporting operation.
             * ```typescript
             * let delimiter = this.exportOptions.valueDelimiter;
             * ```
             *
             * @memberof IgxCsvExporterOptions
             */
            get: function () {
                return this._valueDelimiter;
            },
            /**
             * Sets a value delimiter which will overwrite the default delimiter of the selected export format.
             * ```typescript
             * this.exportOptions.valueDelimiter = '|';
             * ```
             *
             * @memberof IgxCsvExporterOptions
             */
            set: function (value) {
                this.setDelimiter(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCsvExporterOptions.prototype, "fileType", {
            /**
             * Gets the CSV export format.
             * ```typescript
             * let filetype = this.exportOptions.fileType;
             * ```
             *
             * @memberof IgxCsvExporterOptions
             */
            get: function () {
                return this._fileType;
            },
            /**
             * Sets the CSV export format.
             * ```typescript
             * this.exportOptions.fileType = CsvFileTypes.TAB;
             * ```
             *
             * @memberof IgxCsvExporterOptions
             */
            set: function (value) {
                this.setFileType(value);
            },
            enumerable: false,
            configurable: true
        });
        IgxCsvExporterOptions.prototype.setFileType = function (value) {
            if (value !== undefined && value !== null && value !== this._fileType) {
                this._fileType = value;
                var extension = IgxCsvExporterOptions.getExtensionFromFileType(value);
                if (!this.fileName.endsWith(extension)) {
                    var oldExt = '.' + this.fileName.split('.').pop();
                    var newName = this.fileName.replace(oldExt, extension);
                    this._fileExtension = extension;
                    this.fileName = newName;
                }
            }
        };
        IgxCsvExporterOptions.prototype.setDelimiter = function (value) {
            if (value !== undefined && value !== '' && value !== null) {
                this._valueDelimiter = value;
            }
            else {
                switch (this.fileType) {
                    case exports.CsvFileTypes.CSV:
                        this._valueDelimiter = ',';
                        break;
                    case exports.CsvFileTypes.TSV:
                    case exports.CsvFileTypes.TAB:
                        this._valueDelimiter = '\t';
                        break;
                }
            }
        };
        return IgxCsvExporterOptions;
    }(IgxExporterOptionsBase));
    (function (CsvFileTypes) {
        /**
         * Character Separated Values, default separator is "comma", default file extension is .csv
         */
        CsvFileTypes[CsvFileTypes["CSV"] = 0] = "CSV";
        /**
         * Tab Separated Values, default separator is tab, default file extension is .tsv
         */
        CsvFileTypes[CsvFileTypes["TSV"] = 1] = "TSV";
        /**
         * Tab Separated Values, default separator is tab, default file extension is .tab
         */
        CsvFileTypes[CsvFileTypes["TAB"] = 2] = "TAB";
    })(exports.CsvFileTypes || (exports.CsvFileTypes = {}));

    /**
     * **Ignite UI for Angular CSV Exporter Service** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter-csv)
     *
     * The Ignite UI for Angular CSV Exporter service can export data in a Character Separated Values format from
     * both raw data (array) or from an `IgxGrid`.
     *
     * Example:
     * ```typescript
     * public localData = [
     *   { Name: "Eric Ridley", Age: "26" },
     *   { Name: "Alanis Brook", Age: "22" },
     *   { Name: "Jonathan Morris", Age: "23" }
     * ];
     *
     * constructor(private csvExportService: IgxCsvExporterService) {
     * }
     *
     * const opt: IgxCsvExporterOptions = new IgxCsvExporterOptions("FileName", CsvFileTypes.CSV);
     * this.csvExportService.exportData(this.localData, opt);
     * ```
     */
    var IgxCsvExporterService = /** @class */ (function (_super) {
        __extends(IgxCsvExporterService, _super);
        function IgxCsvExporterService() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            /**
             * This event is emitted when the export process finishes.
             * ```typescript
             * this.exporterService.exportEnded.subscribe((args: ICsvExportEndedEventArgs) => {
             * // put event handler code here
             * });
             * ```
             *
             * @memberof IgxCsvExporterService
             */
            _this.exportEnded = new i0.EventEmitter();
            return _this;
        }
        IgxCsvExporterService.prototype.exportDataImplementation = function (data, options) {
            var _this = this;
            data = data.map(function (item) { return item.data; });
            var csvData = new CharSeparatedValueData(data, options.valueDelimiter);
            csvData.prepareDataAsync(function (r) {
                _this._stringData = r;
                _this.saveFile(options);
                _this.exportEnded.emit({ csvData: _this._stringData });
            });
        };
        IgxCsvExporterService.prototype.saveFile = function (options) {
            switch (options.fileType) {
                case exports.CsvFileTypes.CSV:
                    this.exportFile(this._stringData, options.fileName, 'text/csv;charset=utf-8;');
                    break;
                case exports.CsvFileTypes.TSV:
                case exports.CsvFileTypes.TAB:
                    this.exportFile(this._stringData, options.fileName, 'text/tab-separated-values;charset=utf-8;');
                    break;
            }
        };
        IgxCsvExporterService.prototype.exportFile = function (data, fileName, fileType) {
            var blob = new Blob(['\ufeff', data], { type: fileType });
            ExportUtilities.saveBlobToFile(blob, fileName);
        };
        return IgxCsvExporterService;
    }(IgxBaseExporter));
    IgxCsvExporterService.decorators = [
        { type: i0.Injectable }
    ];

    /**
     * @hidden
     */
    var ExcelFolderTypes;
    (function (ExcelFolderTypes) {
        ExcelFolderTypes[ExcelFolderTypes["RootExcelFolder"] = 0] = "RootExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["RootRelsExcelFolder"] = 1] = "RootRelsExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["DocPropsExcelFolder"] = 2] = "DocPropsExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["XLExcelFolder"] = 3] = "XLExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["XLRelsExcelFolder"] = 4] = "XLRelsExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["ThemeExcelFolder"] = 5] = "ThemeExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["WorksheetsExcelFolder"] = 6] = "WorksheetsExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["WorksheetsRelsExcelFolder"] = 7] = "WorksheetsRelsExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["TablesExcelFolder"] = 8] = "TablesExcelFolder";
    })(ExcelFolderTypes || (ExcelFolderTypes = {}));
    /**
     * @hidden
     */
    var ExcelFileTypes;
    (function (ExcelFileTypes) {
        ExcelFileTypes[ExcelFileTypes["RootRelsFile"] = 0] = "RootRelsFile";
        ExcelFileTypes[ExcelFileTypes["AppFile"] = 1] = "AppFile";
        ExcelFileTypes[ExcelFileTypes["CoreFile"] = 2] = "CoreFile";
        ExcelFileTypes[ExcelFileTypes["WorkbookRelsFile"] = 3] = "WorkbookRelsFile";
        ExcelFileTypes[ExcelFileTypes["ThemeFile"] = 4] = "ThemeFile";
        ExcelFileTypes[ExcelFileTypes["WorksheetFile"] = 5] = "WorksheetFile";
        ExcelFileTypes[ExcelFileTypes["StyleFile"] = 6] = "StyleFile";
        ExcelFileTypes[ExcelFileTypes["WorkbookFile"] = 7] = "WorkbookFile";
        ExcelFileTypes[ExcelFileTypes["ContentTypesFile"] = 8] = "ContentTypesFile";
        ExcelFileTypes[ExcelFileTypes["SharedStringsFile"] = 9] = "SharedStringsFile";
        ExcelFileTypes[ExcelFileTypes["WorksheetRelsFile"] = 10] = "WorksheetRelsFile";
        ExcelFileTypes[ExcelFileTypes["TablesFile"] = 11] = "TablesFile";
    })(ExcelFileTypes || (ExcelFileTypes = {}));

    /** @hidden */
    var ExcelStrings = /** @class */ (function () {
        function ExcelStrings() {
        }
        ExcelStrings.getRels = function () {
            return ExcelStrings.XML_STRING + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>';
        };
        ExcelStrings.getApp = function (worksheetName) {
            return ExcelStrings.XML_STRING + ("<Properties xmlns=\"http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\" xmlns:vt=\"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size=\"2\" baseType=\"variant\"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size=\"1\" baseType=\"lpstr\"><vt:lpstr>" + worksheetName + "</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>");
        };
        ExcelStrings.getCore = function () {
            return ExcelStrings.XML_STRING + '<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator></dc:creator><cp:lastModifiedBy></cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">2015-06-05T18:17:20Z</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">2015-06-05T18:17:26Z</dcterms:modified></cp:coreProperties>';
        };
        ExcelStrings.getTheme = function () {
            return ExcelStrings.XML_STRING + '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="5B9BD5"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="4472C4"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック Light"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线 Light"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>';
        };
        ExcelStrings.getStyles = function (hasNumberValues, hasDateValues) {
            var cellXFCount = hasDateValues ? 3 : hasNumberValues ? 2 : 1;
            var additionalCellXF = '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0" applyNumberFormat="1"/>';
            if (hasDateValues) {
                additionalCellXF = additionalCellXF + ' <xf numFmtId="14" fontId="0" fillId="0" borderId="0" xfId="0" applyNumberFormat="1"/>';
            }
            return ExcelStrings.XML_STRING + '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="' + cellXFCount + '"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/>' + additionalCellXF + '</cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles><dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>';
        };
        ExcelStrings.getWorkbook = function (worksheetName) {
            return ExcelStrings.XML_STRING + ("<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x15\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\"><fileVersion appName=\"xl\" lastEdited=\"6\" lowestEdited=\"6\" rupBuild=\"14420\"/><workbookPr filterPrivacy=\"1\" defaultThemeVersion=\"164011\"/><bookViews><workbookView xWindow=\"0\" yWindow=\"0\" windowWidth=\"22260\" windowHeight=\"12645\"/></bookViews><sheets><sheet name=\"" + worksheetName + "\" sheetId=\"1\" r:id=\"rId1\"/></sheets><calcPr calcId=\"162913\"/><extLst><ext uri=\"{140A7094-0E35-4892-8432-C4D2E57EDEB5}\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\"><x15:workbookPr chartTrackingRefBase=\"1\"/></ext></extLst></workbook>");
        };
        ExcelStrings.getWorksheetRels = function () {
            return ExcelStrings.XML_STRING + "<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\"><Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/table\" Target=\"../tables/table1.xml\"/></Relationships>";
        };
        ExcelStrings.getWorkbookRels = function (hasSharedStrings) {
            var retVal = ExcelStrings.XML_STRING + "<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\"><Relationship Id=\"rId3\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\" Target=\"styles.xml\"/><Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme\" Target=\"theme/theme1.xml\"/><Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\" Target=\"worksheets/sheet1.xml\"/>";
            if (hasSharedStrings) {
                retVal += ExcelStrings.SHARED_STRING_RELATIONSHIP;
            }
            retVal += '</Relationships>';
            return retVal;
        };
        ExcelStrings.getSheetXML = function (dimension, freezePane, cols, sheetData, hasTable, outlineLevel) {
            if (outlineLevel === void 0) { outlineLevel = 0; }
            var hasOutline = outlineLevel > 0;
            var tableParts = hasTable ? '<tableParts count="1"><tablePart r:id="rId1"/></tableParts>' : '';
            var sheetOutlineProp = hasOutline ? '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>' : '';
            var sOutlineLevel = hasOutline ? "outlineLevelRow=\"" + outlineLevel + "\"" : '';
            // return ExcelStrings.XML_STRING +
            //     '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"><dimension ref="' + dimension + '"/><sheetViews><sheetView tabSelected="1" workbookViewId="0">' + freezePane + '</sheetView></sheetViews><sheetFormatPr defaultRowHeight="15" x14ac:dyDescent="0.25"/>' + cols + sheetData + '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>' + tableParts + '</worksheet>';
            return ExcelStrings.XML_STRING + "\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">\n" + sheetOutlineProp + "\n<dimension ref=\"" + dimension + "\"/>\n<sheetViews><sheetView tabSelected=\"1\" workbookViewId=\"0\">" + freezePane + "</sheetView></sheetViews>\n<sheetFormatPr defaultRowHeight=\"15\" " + sOutlineLevel + " x14ac:dyDescent=\"0.25\"/>\n" + cols + "\n" + sheetData + "\n<pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\"/>\n" + tableParts + "</worksheet>";
        };
        ExcelStrings.getSharedStringXML = function (count, uniqueCount, table) {
            return ExcelStrings.XML_STRING + '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="' + count + '" uniqueCount="' + uniqueCount + '">' + table + '</sst>';
        };
        ExcelStrings.getContentTypesXML = function (hasSharedStrings, hasTable) {
            var contentTypes = ExcelStrings.XML_STRING +
                "<Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\">\n            <Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\"/>\n            <Default Extension=\"xml\" ContentType=\"application/xml\"/>\n            <Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\"/>\n            <Override PartName=\"/xl/worksheets/sheet1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\"/>\n            <Override PartName=\"/xl/theme/theme1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.theme+xml\"/>\n            <Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\"/>\n            <Override PartName=\"/docProps/core.xml\" ContentType=\"application/vnd.openxmlformats-package.core-properties+xml\"/>\n            <Override PartName=\"/docProps/app.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.extended-properties+xml\"/>";
            contentTypes += hasSharedStrings ?
                "\t<Override PartName=\"/xl/sharedStrings.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\"/>" : '';
            contentTypes += hasTable ?
                "<Override PartName=\"/xl/tables/table1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml\"/>" : '';
            contentTypes += "</Types>";
            return contentTypes;
        };
        ExcelStrings.getTablesXML = function (dimension, tableColumns, sort) {
            return ExcelStrings.XML_STRING + "<table xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" id=\"1\" name=\"Table1\" displayName=\"Table1\" ref=\"" + dimension + "\" totalsRowShown=\"0\">\n    <autoFilter ref=\"" + dimension + "\"/>" + sort + tableColumns + "<tableStyleInfo name=\"TableStyleMedium2\" showFirstColumn=\"0\" showLastColumn=\"0\" showRowStripes=\"1\" showColumnStripes=\"0\"/>\n</table>";
        };
        /* eslint-enable  max-len */
        ExcelStrings.getExcelColumn = function (index) {
            // Returns the excel column name for given 0-based index
            // For example 27 should return "AB"
            var returnString = '';
            while (index >= 0) {
                var char = index % 26;
                returnString = String.fromCharCode(65 + char) + returnString;
                index = Math.floor(index / 26) - 1;
            }
            return returnString;
        };
        return ExcelStrings;
    }());
    /* eslint-disable  max-len */
    ExcelStrings.XML_STRING = '<?xml version="1.0" encoding="UTF-8"?>\r\n';
    ExcelStrings.SHARED_STRING_RELATIONSHIP = '<Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml" />';

    /**
     * @hidden
     */
    var RootRelsFile = /** @class */ (function () {
        function RootRelsFile() {
        }
        RootRelsFile.prototype.writeElement = function (folder) {
            folder.file('.rels', ExcelStrings.getRels());
        };
        return RootRelsFile;
    }());
    /**
     * @hidden
     */
    var AppFile = /** @class */ (function () {
        function AppFile() {
        }
        AppFile.prototype.writeElement = function (folder, worksheetData) {
            folder.file('app.xml', ExcelStrings.getApp(worksheetData.options.worksheetName));
        };
        return AppFile;
    }());
    /**
     * @hidden
     */
    var CoreFile = /** @class */ (function () {
        function CoreFile() {
        }
        CoreFile.prototype.writeElement = function (folder) {
            folder.file('core.xml', ExcelStrings.getCore());
        };
        return CoreFile;
    }());
    /**
     * @hidden
     */
    var WorkbookRelsFile = /** @class */ (function () {
        function WorkbookRelsFile() {
        }
        WorkbookRelsFile.prototype.writeElement = function (folder, worksheetData) {
            var hasSharedStrings = worksheetData.isEmpty === false;
            folder.file('workbook.xml.rels', ExcelStrings.getWorkbookRels(hasSharedStrings));
        };
        return WorkbookRelsFile;
    }());
    /**
     * @hidden
     */
    var ThemeFile = /** @class */ (function () {
        function ThemeFile() {
        }
        ThemeFile.prototype.writeElement = function (folder) {
            folder.file('theme1.xml', ExcelStrings.getTheme());
        };
        return ThemeFile;
    }());
    /**
     * @hidden
     */
    var WorksheetFile = /** @class */ (function () {
        function WorksheetFile() {
            this.maxOutlineLevel = 0;
            this.dimension = '';
            this.freezePane = '';
            this.rowHeight = '';
            /* eslint-enable  @typescript-eslint/member-ordering */
        }
        WorksheetFile.prototype.writeElement = function () { };
        WorksheetFile.prototype.writeElementAsync = function (folder, worksheetData) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2 /*return*/, new Promise(function (resolve) {
                            _this.prepareDataAsync(worksheetData, function (cols, rows) {
                                var hasTable = !worksheetData.isEmpty && worksheetData.options.exportAsTable;
                                folder.file('sheet1.xml', ExcelStrings.getSheetXML(_this.dimension, _this.freezePane, cols, rows, hasTable, _this.maxOutlineLevel));
                                resolve();
                            });
                        })];
                });
            });
        };
        WorksheetFile.prototype.prepareDataAsync = function (worksheetData, done) {
            var sheetData = '';
            var cols = '';
            var dictionary = worksheetData.dataDictionary;
            if (worksheetData.isEmpty) {
                sheetData += '<sheetData/>';
                this.dimension = 'A1';
                done('', sheetData);
            }
            else {
                sheetData += '<sheetData>';
                var height = worksheetData.options.rowHeight;
                this.rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
                sheetData += "<row r=\"1\"" + this.rowHeight + ">";
                for (var i = 0; i < worksheetData.columnCount; i++) {
                    var column = ExcelStrings.getExcelColumn(i) + 1;
                    var value = dictionary.saveValue(worksheetData.keys[i], i, true);
                    sheetData += "<c r=\"" + column + "\" t=\"s\"><v>" + value + "</v></c>";
                }
                sheetData += '</row>';
                this.dimension = 'A1:' + ExcelStrings.getExcelColumn(worksheetData.columnCount - 1) + worksheetData.rowCount;
                cols += '<cols>';
                for (var i = 0; i < worksheetData.columnCount; i++) {
                    var width = dictionary.columnWidths[i];
                    // Use the width provided in the options if it exists
                    var widthInTwips = worksheetData.options.columnWidth !== undefined ?
                        worksheetData.options.columnWidth :
                        Math.max(((width / 96) * 14.4), WorksheetFile.MIN_WIDTH);
                    if (!(widthInTwips > 0)) {
                        widthInTwips = WorksheetFile.MIN_WIDTH;
                    }
                    cols += "<col min=\"" + (i + 1) + "\" max=\"" + (i + 1) + "\" width=\"" + widthInTwips + "\" customWidth=\"1\"/>";
                }
                cols += '</cols>';
                if (worksheetData.indexOfLastPinnedColumn !== -1 &&
                    !worksheetData.options.ignorePinning &&
                    !worksheetData.options.ignoreColumnsOrder) {
                    var frozenColumnCount = worksheetData.indexOfLastPinnedColumn + 1;
                    var firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + '1';
                    this.freezePane = "<pane xSplit=\"" + frozenColumnCount + "\" topLeftCell=\"" + firstCell + "\" activePane=\"topRight\" state=\"frozen\"/>";
                }
                this.processDataRecordsAsync(worksheetData, function (rows) {
                    sheetData += rows;
                    sheetData += '</sheetData>';
                    done(cols, sheetData);
                });
            }
        };
        WorksheetFile.prototype.processDataRecordsAsync = function (worksheetData, done) {
            var _this = this;
            var rowDataArr = new Array(worksheetData.rowCount - 1);
            var height = worksheetData.options.rowHeight;
            this.rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
            yieldingLoop(worksheetData.rowCount - 1, 1000, function (i) {
                rowDataArr[i] = _this.processRow(worksheetData, i + 1);
            }, function () {
                done(rowDataArr.join(''));
            });
        };
        WorksheetFile.prototype.processRow = function (worksheetData, i) {
            var rowData = new Array(worksheetData.columnCount + 2);
            var record = worksheetData.data[i - 1];
            var sHidden = record.hidden ? " hidden=\"1\"" : '';
            var rowLevel = record.level;
            var outlineLevel = rowLevel > 0 ? " outlineLevel=\"" + rowLevel + "\"" : '';
            this.maxOutlineLevel = this.maxOutlineLevel < rowLevel ? rowLevel : this.maxOutlineLevel;
            rowData[0] = "<row r=\"" + (i + 1) + "\"" + this.rowHeight + outlineLevel + sHidden + ">";
            for (var j = 0; j < worksheetData.columnCount; j++) {
                var cellData = WorksheetFile.getCellData(worksheetData, i, j);
                rowData[j + 1] = cellData;
            }
            rowData[worksheetData.columnCount + 1] = '</row>';
            return rowData.join('');
        };
        /* eslint-disable  @typescript-eslint/member-ordering */
        WorksheetFile.getCellData = function (worksheetData, row, column) {
            var dictionary = worksheetData.dataDictionary;
            var columnName = ExcelStrings.getExcelColumn(column) + (row + 1);
            var columnHeader = worksheetData.keys[column];
            var fullRow = worksheetData.data[row - 1];
            var cellValue = worksheetData.isSpecialData ?
                fullRow.data :
                fullRow.data[columnHeader];
            if (cellValue === undefined || cellValue === null) {
                return "<c r=\"" + columnName + "\" s=\"1\"/>";
            }
            else {
                var savedValue = dictionary.saveValue(cellValue, column, false);
                var isSavedAsString = savedValue !== -1;
                var isSavedAsDate = !isSavedAsString && cellValue instanceof Date;
                var value = isSavedAsString ? savedValue : cellValue;
                if (isSavedAsDate) {
                    var timeZoneOffset = value.getTimezoneOffset() * 60000;
                    var isoString = (new Date(value - timeZoneOffset)).toISOString();
                    value = isoString.substring(0, isoString.indexOf('.'));
                }
                var type = isSavedAsString ? " t=\"s\"" : isSavedAsDate ? " t=\"d\"" : '';
                var format = isSavedAsString ? '' : isSavedAsDate ? " s=\"2\"" : " s=\"1\"";
                return "<c r=\"" + columnName + "\"" + type + format + "><v>" + value + "</v></c>";
            }
        };
        return WorksheetFile;
    }());
    WorksheetFile.MIN_WIDTH = 8.43;
    /**
     * @hidden
     */
    var StyleFile = /** @class */ (function () {
        function StyleFile() {
        }
        StyleFile.prototype.writeElement = function (folder, worksheetData) {
            var hasNumberValues = worksheetData.dataDictionary && worksheetData.dataDictionary.hasNumberValues;
            var hasDateValues = worksheetData.dataDictionary && worksheetData.dataDictionary.hasDateValues;
            folder.file('styles.xml', ExcelStrings.getStyles(hasNumberValues, hasDateValues));
        };
        return StyleFile;
    }());
    /**
     * @hidden
     */
    var WorkbookFile = /** @class */ (function () {
        function WorkbookFile() {
        }
        WorkbookFile.prototype.writeElement = function (folder, worksheetData) {
            folder.file('workbook.xml', ExcelStrings.getWorkbook(worksheetData.options.worksheetName));
        };
        return WorkbookFile;
    }());
    /**
     * @hidden
     */
    var ContentTypesFile = /** @class */ (function () {
        function ContentTypesFile() {
        }
        ContentTypesFile.prototype.writeElement = function (folder, worksheetData) {
            folder.file('[Content_Types].xml', ExcelStrings.getContentTypesXML(!worksheetData.isEmpty, worksheetData.options.exportAsTable));
        };
        return ContentTypesFile;
    }());
    /**
     * @hidden
     */
    var SharedStringsFile = /** @class */ (function () {
        function SharedStringsFile() {
        }
        SharedStringsFile.prototype.writeElement = function (folder, worksheetData) {
            var e_1, _a;
            var dict = worksheetData.dataDictionary;
            var sortedValues = dict.getKeys();
            var sharedStrings = new Array(sortedValues.length);
            try {
                for (var sortedValues_1 = __values(sortedValues), sortedValues_1_1 = sortedValues_1.next(); !sortedValues_1_1.done; sortedValues_1_1 = sortedValues_1.next()) {
                    var value = sortedValues_1_1.value;
                    sharedStrings[dict.getSanitizedValue(value)] = '<si><t>' + value + '</t></si>';
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (sortedValues_1_1 && !sortedValues_1_1.done && (_a = sortedValues_1.return)) _a.call(sortedValues_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            folder.file('sharedStrings.xml', ExcelStrings.getSharedStringXML(dict.stringsCount, sortedValues.length, sharedStrings.join('')));
        };
        return SharedStringsFile;
    }());
    /**
     * @hidden
     */
    var TablesFile = /** @class */ (function () {
        function TablesFile() {
        }
        TablesFile.prototype.writeElement = function (folder, worksheetData) {
            var columnCount = worksheetData.columnCount;
            var lastColumn = ExcelStrings.getExcelColumn(columnCount - 1) + worksheetData.rowCount;
            var dimension = 'A1:' + lastColumn;
            var values = worksheetData.keys;
            var sortString = '';
            var tableColumns = '<tableColumns count="' + columnCount + '">';
            for (var i = 0; i < columnCount; i++) {
                var value = values[i];
                tableColumns += '<tableColumn id="' + (i + 1) + '" name="' + value + '"/>';
            }
            tableColumns += '</tableColumns>';
            if (worksheetData.sort) {
                var sortingExpression = worksheetData.sort;
                var sc = ExcelStrings.getExcelColumn(values.indexOf(sortingExpression.fieldName));
                var dir = sortingExpression.dir - 1;
                sortString = "<sortState ref=\"A2:" + lastColumn + "\"><sortCondition descending=\"" + dir + "\" ref=\"" + sc + "1:" + sc + "15\"/></sortState>";
            }
            folder.file('table1.xml', ExcelStrings.getTablesXML(dimension, tableColumns, sortString));
        };
        return TablesFile;
    }());
    /**
     * @hidden
     */
    var WorksheetRelsFile = /** @class */ (function () {
        function WorksheetRelsFile() {
        }
        WorksheetRelsFile.prototype.writeElement = function (folder) {
            folder.file('sheet1.xml.rels', ExcelStrings.getWorksheetRels());
        };
        return WorksheetRelsFile;
    }());

    /** @hidden */
    var RootExcelFolder = /** @class */ (function () {
        function RootExcelFolder() {
        }
        Object.defineProperty(RootExcelFolder.prototype, "folderName", {
            get: function () {
                return '';
            },
            enumerable: false,
            configurable: true
        });
        RootExcelFolder.prototype.childFiles = function () {
            return [ExcelFileTypes.ContentTypesFile];
        };
        RootExcelFolder.prototype.childFolders = function () {
            return [
                ExcelFolderTypes.RootRelsExcelFolder,
                ExcelFolderTypes.DocPropsExcelFolder,
                ExcelFolderTypes.XLExcelFolder
            ];
        };
        return RootExcelFolder;
    }());
    /** @hidden */
    var RootRelsExcelFolder = /** @class */ (function () {
        function RootRelsExcelFolder() {
        }
        Object.defineProperty(RootRelsExcelFolder.prototype, "folderName", {
            get: function () {
                return '_rels';
            },
            enumerable: false,
            configurable: true
        });
        RootRelsExcelFolder.prototype.childFiles = function () {
            return [ExcelFileTypes.RootRelsFile];
        };
        RootRelsExcelFolder.prototype.childFolders = function () {
            return [];
        };
        return RootRelsExcelFolder;
    }());
    /** @hidden */
    var DocPropsExcelFolder = /** @class */ (function () {
        function DocPropsExcelFolder() {
        }
        Object.defineProperty(DocPropsExcelFolder.prototype, "folderName", {
            get: function () {
                return 'docProps';
            },
            enumerable: false,
            configurable: true
        });
        DocPropsExcelFolder.prototype.childFiles = function () {
            return [
                ExcelFileTypes.AppFile,
                ExcelFileTypes.CoreFile
            ];
        };
        DocPropsExcelFolder.prototype.childFolders = function () {
            return [];
        };
        return DocPropsExcelFolder;
    }());
    /** @hidden */
    var XLExcelFolder = /** @class */ (function () {
        function XLExcelFolder() {
        }
        Object.defineProperty(XLExcelFolder.prototype, "folderName", {
            get: function () {
                return 'xl';
            },
            enumerable: false,
            configurable: true
        });
        XLExcelFolder.prototype.childFiles = function (data) {
            var retVal = [
                ExcelFileTypes.StyleFile,
                ExcelFileTypes.WorkbookFile
            ];
            if (!data.isEmpty) {
                retVal.push(ExcelFileTypes.SharedStringsFile);
            }
            return retVal;
        };
        XLExcelFolder.prototype.childFolders = function (data) {
            var retVal = [
                ExcelFolderTypes.XLRelsExcelFolder,
                ExcelFolderTypes.ThemeExcelFolder,
                ExcelFolderTypes.WorksheetsExcelFolder
            ];
            if (!data.isEmpty && data.options.exportAsTable) {
                retVal.push(ExcelFolderTypes.TablesExcelFolder);
            }
            return retVal;
        };
        return XLExcelFolder;
    }());
    /** @hidden */
    var XLRelsExcelFolder = /** @class */ (function () {
        function XLRelsExcelFolder() {
        }
        Object.defineProperty(XLRelsExcelFolder.prototype, "folderName", {
            get: function () {
                return '_rels';
            },
            enumerable: false,
            configurable: true
        });
        XLRelsExcelFolder.prototype.childFiles = function () {
            return [ExcelFileTypes.WorkbookRelsFile];
        };
        XLRelsExcelFolder.prototype.childFolders = function () {
            return [];
        };
        return XLRelsExcelFolder;
    }());
    /** @hidden */
    var ThemeExcelFolder = /** @class */ (function () {
        function ThemeExcelFolder() {
        }
        Object.defineProperty(ThemeExcelFolder.prototype, "folderName", {
            get: function () {
                return 'theme';
            },
            enumerable: false,
            configurable: true
        });
        ThemeExcelFolder.prototype.childFiles = function () {
            return [ExcelFileTypes.ThemeFile];
        };
        ThemeExcelFolder.prototype.childFolders = function () {
            return [];
        };
        return ThemeExcelFolder;
    }());
    /** @hidden */
    var WorksheetsExcelFolder = /** @class */ (function () {
        function WorksheetsExcelFolder() {
        }
        Object.defineProperty(WorksheetsExcelFolder.prototype, "folderName", {
            get: function () {
                return 'worksheets';
            },
            enumerable: false,
            configurable: true
        });
        WorksheetsExcelFolder.prototype.childFiles = function () {
            return [ExcelFileTypes.WorksheetFile];
        };
        WorksheetsExcelFolder.prototype.childFolders = function (data) {
            return data.isEmpty || !data.options.exportAsTable ? [] : [ExcelFolderTypes.WorksheetsRelsExcelFolder];
        };
        return WorksheetsExcelFolder;
    }());
    /** @hidden */
    var TablesExcelFolder = /** @class */ (function () {
        function TablesExcelFolder() {
        }
        Object.defineProperty(TablesExcelFolder.prototype, "folderName", {
            get: function () {
                return 'tables';
            },
            enumerable: false,
            configurable: true
        });
        TablesExcelFolder.prototype.childFiles = function () {
            return [ExcelFileTypes.TablesFile];
        };
        TablesExcelFolder.prototype.childFolders = function () {
            return [];
        };
        return TablesExcelFolder;
    }());
    /** @hidden */
    var WorksheetsRelsExcelFolder = /** @class */ (function () {
        function WorksheetsRelsExcelFolder() {
        }
        Object.defineProperty(WorksheetsRelsExcelFolder.prototype, "folderName", {
            get: function () {
                return '_rels';
            },
            enumerable: false,
            configurable: true
        });
        WorksheetsRelsExcelFolder.prototype.childFiles = function () {
            return [ExcelFileTypes.WorksheetRelsFile];
        };
        WorksheetsRelsExcelFolder.prototype.childFolders = function () {
            return [];
        };
        return WorksheetsRelsExcelFolder;
    }());

    /** @hidden */
    var ExcelElementsFactory = /** @class */ (function () {
        function ExcelElementsFactory() {
        }
        ExcelElementsFactory.getExcelFolder = function (type) {
            switch (type) {
                case ExcelFolderTypes.RootExcelFolder:
                    return new RootExcelFolder();
                case ExcelFolderTypes.RootRelsExcelFolder:
                    return new RootRelsExcelFolder();
                case ExcelFolderTypes.DocPropsExcelFolder:
                    return new DocPropsExcelFolder();
                case ExcelFolderTypes.XLExcelFolder:
                    return new XLExcelFolder();
                case ExcelFolderTypes.XLRelsExcelFolder:
                    return new XLRelsExcelFolder();
                case ExcelFolderTypes.ThemeExcelFolder:
                    return new ThemeExcelFolder();
                case ExcelFolderTypes.WorksheetsExcelFolder:
                    return new WorksheetsExcelFolder();
                case ExcelFolderTypes.WorksheetsRelsExcelFolder:
                    return new WorksheetsRelsExcelFolder();
                case ExcelFolderTypes.TablesExcelFolder:
                    return new TablesExcelFolder();
                default:
                    throw new Error('Unknown excel folder type!');
            }
        };
        ExcelElementsFactory.getExcelFile = function (type) {
            switch (type) {
                case ExcelFileTypes.RootRelsFile:
                    return new RootRelsFile();
                case ExcelFileTypes.AppFile:
                    return new AppFile();
                case ExcelFileTypes.CoreFile:
                    return new CoreFile();
                case ExcelFileTypes.WorkbookRelsFile:
                    return new WorkbookRelsFile();
                case ExcelFileTypes.ThemeFile:
                    return new ThemeFile();
                case ExcelFileTypes.WorksheetFile:
                    return new WorksheetFile();
                case ExcelFileTypes.StyleFile:
                    return new StyleFile();
                case ExcelFileTypes.WorkbookFile:
                    return new WorkbookFile();
                case ExcelFileTypes.ContentTypesFile:
                    return new ContentTypesFile();
                case ExcelFileTypes.SharedStringsFile:
                    return new SharedStringsFile();
                case ExcelFileTypes.WorksheetRelsFile:
                    return new WorksheetRelsFile();
                case ExcelFileTypes.TablesFile:
                    return new TablesFile();
                default:
                    throw Error('Unknown excel file type!');
            }
        };
        return ExcelElementsFactory;
    }());

    /** @hidden */
    var WorksheetDataDictionary = /** @class */ (function () {
        function WorksheetDataDictionary(columnCount, columnWidth, columnWidthsList) {
            this.hasNumberValues = false;
            this.hasDateValues = false;
            this._dictionary = {};
            this._widthsDictionary = {};
            this._counter = 0;
            this.dirtyKeyCollections();
            this._columnWidths = new Array(columnCount);
            this._columnTypeInfo = new Array(columnCount);
            if (columnWidth) {
                this._columnWidths.fill(columnWidth);
            }
            else {
                this._columnWidths = columnWidthsList;
            }
            this.stringsCount = 0;
        }
        Object.defineProperty(WorksheetDataDictionary.prototype, "columnWidths", {
            get: function () {
                return this._columnWidths;
            },
            enumerable: false,
            configurable: true
        });
        WorksheetDataDictionary.prototype.saveValue = function (value, column, isHeader) {
            if (this._columnTypeInfo[column] === undefined && isHeader === false) {
                this._columnTypeInfo[column] = typeof value !== 'number' && value !== Number(value) && !Number.isFinite(value);
            }
            var sanitizedValue = '';
            var isDate = value instanceof Date;
            var isSavedAsString = (this._columnTypeInfo[column] || isHeader) && !isDate;
            if (isSavedAsString) {
                sanitizedValue = this.sanitizeValue(value);
                if (this._dictionary[sanitizedValue] === undefined) {
                    this._dictionary[sanitizedValue] = this._counter++;
                    this.dirtyKeyCollections();
                }
                this.stringsCount++;
            }
            else if (isDate) {
                this.hasDateValues = true;
            }
            else {
                this.hasNumberValues = true;
            }
            return isSavedAsString ? this.getSanitizedValue(sanitizedValue) : -1;
        };
        WorksheetDataDictionary.prototype.getValue = function (value) {
            return this.getSanitizedValue(this.sanitizeValue(value));
        };
        WorksheetDataDictionary.prototype.getSanitizedValue = function (sanitizedValue) {
            return this._dictionary[sanitizedValue];
        };
        WorksheetDataDictionary.prototype.getKeys = function () {
            if (!this._keysAreValid) {
                this._keys = Object.keys(this._dictionary);
                this._keysAreValid = true;
            }
            return this._keys;
        };
        WorksheetDataDictionary.prototype.getTextWidth = function (value) {
            if (this._widthsDictionary[value] === undefined) {
                var context = this.getContext();
                var metrics = context.measureText(value);
                this._widthsDictionary[value] = metrics.width + WorksheetDataDictionary.TEXT_PADDING;
            }
            return this._widthsDictionary[value];
        };
        WorksheetDataDictionary.prototype.getContext = function () {
            if (!this._context) {
                var canvas = document.createElement('canvas');
                this._context = canvas.getContext('2d');
                this._context.font = WorksheetDataDictionary.DEFAULT_FONT;
            }
            return this._context;
        };
        WorksheetDataDictionary.prototype.sanitizeValue = function (value) {
            if (ExportUtilities.hasValue(value) === false) {
                return '';
            }
            else {
                var stringValue = String(value);
                return stringValue.replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            }
        };
        WorksheetDataDictionary.prototype.dirtyKeyCollections = function () {
            this._keysAreValid = false;
        };
        return WorksheetDataDictionary;
    }());
    WorksheetDataDictionary.DEFAULT_FONT = '11pt Calibri';
    WorksheetDataDictionary.TEXT_PADDING = 5;

    /** @hidden */
    var WorksheetData = /** @class */ (function () {
        function WorksheetData(_data, _columnWidths, options, indexOfLastPinnedColumn, sort) {
            this._data = _data;
            this._columnWidths = _columnWidths;
            this.options = options;
            this.indexOfLastPinnedColumn = indexOfLastPinnedColumn;
            this.sort = sort;
            this.initializeData();
        }
        Object.defineProperty(WorksheetData.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WorksheetData.prototype, "columnCount", {
            get: function () {
                return this._columnCount;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WorksheetData.prototype, "rowCount", {
            get: function () {
                return this._rowCount;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WorksheetData.prototype, "isEmpty", {
            get: function () {
                return !this.rowCount || !this._columnCount;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WorksheetData.prototype, "keys", {
            get: function () {
                return this._keys;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WorksheetData.prototype, "isSpecialData", {
            get: function () {
                return this._isSpecialData;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WorksheetData.prototype, "dataDictionary", {
            get: function () {
                return this._dataDictionary;
            },
            enumerable: false,
            configurable: true
        });
        WorksheetData.prototype.initializeData = function () {
            if (!this._data || this._data.length === 0) {
                return;
            }
            var actualData = this._data.map(function (item) { return item.data; });
            this._keys = ExportUtilities.getKeysFromData(actualData);
            if (this._keys.length === 0) {
                return;
            }
            this._isSpecialData = ExportUtilities.isSpecialData(actualData);
            this._columnCount = this._keys.length;
            this._rowCount = this._data.length + 1;
            this._dataDictionary = new WorksheetDataDictionary(this._columnCount, this.options.columnWidth, this._columnWidths);
        };
        return WorksheetData;
    }());

    /**
     * **Ignite UI for Angular Excel Exporter Service** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_excel.html)
     *
     * The Ignite UI for Angular Excel Exporter service can export data in Microsoft® Excel® format from both raw data
     * (array) or from an `IgxGrid`.
     *
     * Example:
     * ```typescript
     * public localData = [
     *   { Name: "Eric Ridley", Age: "26" },
     *   { Name: "Alanis Brook", Age: "22" },
     *   { Name: "Jonathan Morris", Age: "23" }
     * ];
     *
     * constructor(private excelExportService: IgxExcelExporterService) {
     * }
     *
     * this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions("FileName"));
     * ```
     */
    var IgxExcelExporterService = /** @class */ (function (_super) {
        __extends(IgxExcelExporterService, _super);
        function IgxExcelExporterService() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            /**
             * This event is emitted when the export process finishes.
             * ```typescript
             * this.exporterService.exportEnded.subscribe((args: IExcelExportEndedEventArgs) => {
             * // put event handler code here
             * });
             * ```
             *
             * @memberof IgxExcelExporterService
             */
            _this.exportEnded = new i0.EventEmitter();
            return _this;
        }
        IgxExcelExporterService.populateFolderAsync = function (folder, zip, worksheetData) {
            return __awaiter(this, void 0, void 0, function () {
                var _b, _c, childFolder, folderInstance, zipFolder, e_1_1, _d, _e, childFile, fileInstance, e_2_1;
                var e_1, _f, e_2, _g;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            _h.trys.push([0, 5, 6, 7]);
                            _b = __values(folder.childFolders(worksheetData)), _c = _b.next();
                            _h.label = 1;
                        case 1:
                            if (!!_c.done) return [3 /*break*/, 4];
                            childFolder = _c.value;
                            folderInstance = ExcelElementsFactory.getExcelFolder(childFolder);
                            zipFolder = zip.folder(folderInstance.folderName);
                            return [4 /*yield*/, IgxExcelExporterService.populateFolderAsync(folderInstance, zipFolder, worksheetData)];
                        case 2:
                            _h.sent();
                            _h.label = 3;
                        case 3:
                            _c = _b.next();
                            return [3 /*break*/, 1];
                        case 4: return [3 /*break*/, 7];
                        case 5:
                            e_1_1 = _h.sent();
                            e_1 = { error: e_1_1 };
                            return [3 /*break*/, 7];
                        case 6:
                            try {
                                if (_c && !_c.done && (_f = _b.return)) _f.call(_b);
                            }
                            finally { if (e_1) throw e_1.error; }
                            return [7 /*endfinally*/];
                        case 7:
                            _h.trys.push([7, 13, 14, 15]);
                            _d = __values(folder.childFiles(worksheetData)), _e = _d.next();
                            _h.label = 8;
                        case 8:
                            if (!!_e.done) return [3 /*break*/, 12];
                            childFile = _e.value;
                            fileInstance = ExcelElementsFactory.getExcelFile(childFile);
                            if (!(fileInstance instanceof WorksheetFile)) return [3 /*break*/, 10];
                            return [4 /*yield*/, fileInstance.writeElementAsync(zip, worksheetData)];
                        case 9:
                            _h.sent();
                            return [3 /*break*/, 11];
                        case 10:
                            fileInstance.writeElement(zip, worksheetData);
                            _h.label = 11;
                        case 11:
                            _e = _d.next();
                            return [3 /*break*/, 8];
                        case 12: return [3 /*break*/, 15];
                        case 13:
                            e_2_1 = _h.sent();
                            e_2 = { error: e_2_1 };
                            return [3 /*break*/, 15];
                        case 14:
                            try {
                                if (_e && !_e.done && (_g = _d.return)) _g.call(_d);
                            }
                            finally { if (e_2) throw e_2.error; }
                            return [7 /*endfinally*/];
                        case 15: return [2 /*return*/];
                    }
                });
            });
        };
        IgxExcelExporterService.prototype.exportDataImplementation = function (data, options) {
            var _this = this;
            var _a;
            var level = (_a = data[0]) === null || _a === void 0 ? void 0 : _a.level;
            if (typeof level !== 'undefined') {
                var maxLevel_1 = 0;
                data.forEach(function (r) {
                    maxLevel_1 = Math.max(maxLevel_1, r.level);
                });
                if (maxLevel_1 > 7) {
                    throw Error('Can create an outline of up to eight levels!');
                }
            }
            var worksheetData = new WorksheetData(data, this.columnWidthList, options, this._indexOfLastPinnedColumn, this._sort);
            this._xlsx = new JSZip__default['default']();
            var rootFolder = ExcelElementsFactory.getExcelFolder(ExcelFolderTypes.RootExcelFolder);
            IgxExcelExporterService.populateFolderAsync(rootFolder, this._xlsx, worksheetData)
                .then(function () {
                _this._xlsx.generateAsync(IgxExcelExporterService.ZIP_OPTIONS).then(function (result) {
                    _this.saveFile(result, options.fileName);
                    _this.exportEnded.emit({ xlsx: _this._xlsx });
                });
            });
        };
        IgxExcelExporterService.prototype.saveFile = function (data, fileName) {
            var blob = new Blob([ExportUtilities.stringToArrayBuffer(atob(data))], {
                type: ''
            });
            ExportUtilities.saveBlobToFile(blob, fileName);
        };
        return IgxExcelExporterService;
    }(IgxBaseExporter));
    IgxExcelExporterService.ZIP_OPTIONS = { compression: 'DEFLATE', type: 'base64' };
    IgxExcelExporterService.decorators = [
        { type: i0.Injectable }
    ];

    /**
     * Objects of this class are used to configure the Excel exporting process.
     */
    var IgxExcelExporterOptions = /** @class */ (function (_super) {
        __extends(IgxExcelExporterOptions, _super);
        function IgxExcelExporterOptions(fileName) {
            var _this = _super.call(this, fileName, '.xlsx') || this;
            /**
             * Specifies if column pinning should be ignored. If ignoreColumnsOrder is set to true,
             * this option will always be considered as set to true.
             * ```typescript
             * let ignorePinning = this.exportOptions.ignorePinning;
             * this.exportOptions.ignorePinning = true;
             * ```
             *
             * @memberof IgxExcelExporterOptions
             */
            _this.ignorePinning = false;
            /**
             * Specifies whether the exported data should be formatted as Excel table. (True by default)
             * ```typescript
             * let exportAsTable = this.exportOptions.exportAsTable;
             * this.exportOptions.exportAsTable = false;
             * ```
             *
             * @memberof IgxExcelExporterOptions
             */
            _this.exportAsTable = true;
            return _this;
        }
        Object.defineProperty(IgxExcelExporterOptions.prototype, "columnWidth", {
            /**
             * Gets the width of the columns in the exported excel file.
             * ```typescript
             * let width = this.exportOptions.columnWidth;
             * ```
             *
             * @memberof IgxExcelExporterOptions
             */
            get: function () {
                return this._columnWidth;
            },
            /**
             * Sets the width of the columns in the exported excel file. If left unspecified,
             * the width of the column or the default width of the excel columns will be used.
             * ```typescript
             * this.exportOptions.columnWidth = 55;
             * ```
             *
             * @memberof IgxExcelExporterOptions
             */
            set: function (value) {
                if (value < 0) {
                    throw Error('Invalid value for column width!');
                }
                this._columnWidth = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelExporterOptions.prototype, "rowHeight", {
            /**
             * Gets the height of the rows in the exported excel file.
             * ```typescript
             * let height = this.exportOptions.rowHeight;
             * ```
             *
             * @memberof IgxExcelExporterOptions
             */
            get: function () {
                return this._rowHeight;
            },
            /**
             * Sets the height of the rows in the exported excel file. If left unspecified or 0,
             * the default height of the excel rows will be used.
             * ```typescript
             * this.exportOptions.rowHeight = 25;
             * ```
             *
             * @memberof IgxExcelExporterOptions
             */
            set: function (value) {
                if (value < 0) {
                    throw Error('Invalid value for row height!');
                }
                this._rowHeight = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelExporterOptions.prototype, "worksheetName", {
            /**
             * Gets the name of the worksheet in the exported excel file.
             * ```typescript
             * let worksheetName = this.exportOptions.worksheetName;
             * ```
             *
             * @memberof IgxExcelExporterOptions
             */
            get: function () {
                if (this._worksheetName === undefined || this._worksheetName === null) {
                    return 'Sheet1';
                }
                return this._worksheetName;
            },
            /**
             * Sets the name of the worksheet in the exported excel file.
             * ```typescript
             * this.exportOptions.worksheetName = "Worksheet";
             * ```
             *
             * @memberof IgxExcelExporterOptions
             */
            set: function (value) {
                this._worksheetName = value;
            },
            enumerable: false,
            configurable: true
        });
        return IgxExcelExporterOptions;
    }(IgxExporterOptionsBase));

    /**
     * @hidden
     */
    var DeprecateClass = function (message) {
        var isMessageShown = false;
        return function (originalClass) { return /** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = this;
                var target = originalClass;
                var targetName = typeof target === 'function' ? target.name : target.constructor.name;
                isMessageShown = showMessage(targetName + ": " + message, isMessageShown);
                _this = _super.apply(this, __spread(args)) || this;
                return _this;
            }
            return class_1;
        }(originalClass)); };
    };
    /**
     * @hidden
     */
    function DeprecateMethod(message) {
        var isMessageShown = false;
        return function (target, key, descriptor) {
            if (descriptor && descriptor.value) {
                var originalMethod_1 = descriptor.value;
                descriptor.value = function () {
                    var e_1, _a;
                    var targetName = typeof target === 'function' ? target.name : target.constructor.name;
                    isMessageShown = showMessage(targetName + "." + key + ": " + message, isMessageShown);
                    var args = [];
                    try {
                        for (var arguments_1 = __values(arguments), arguments_1_1 = arguments_1.next(); !arguments_1_1.done; arguments_1_1 = arguments_1.next()) {
                            var x = arguments_1_1.value;
                            args.push(x);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (arguments_1_1 && !arguments_1_1.done && (_a = arguments_1.return)) _a.call(arguments_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    return originalMethod_1.call(this, args);
                };
                return descriptor;
            }
        };
    }
    /**
     * @hidden
     */
    function DeprecateProperty(message) {
        return function (target, key) {
            var isMessageShown = false;
            var messageToDisplay = target.constructor.name + "." + key + ": " + message;
            // if the target already has the property defined
            var originalDescriptor = Object.getOwnPropertyDescriptor(target, key);
            if (originalDescriptor) {
                var getter_1 = originalDescriptor.get;
                var setter_1 = originalDescriptor.set;
                if (getter_1) {
                    originalDescriptor.get = function () {
                        isMessageShown = showMessage(messageToDisplay, isMessageShown);
                        return getter_1.call(this);
                    };
                }
                if (setter_1) {
                    originalDescriptor.set = function (value) {
                        isMessageShown = showMessage(messageToDisplay, isMessageShown);
                        setter_1.call(this, value);
                    };
                }
                return originalDescriptor;
            }
            // the target doesn't contain a descriptor for that property, so create one
            // use backing field to set/get the value of the property to ensure there won't be infinite recursive calls
            var newKey = generateUniqueKey(target, key);
            Object.defineProperty(target, key, {
                configurable: true,
                enumerable: true,
                set: function (value) {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    this[newKey] = value;
                },
                get: function () {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    return this[newKey];
                }
            });
        };
    }
    /**
     * @hidden
     */
    var generateUniqueKey = function (target, key) {
        var newKey = '_' + key;
        while (target.hasOwnProperty(newKey)) {
            newKey = '_' + newKey;
        }
        return newKey;
    };
    var ɵ0$1 = generateUniqueKey;
    /**
     * @hidden
     */
    var showMessage = function (message, isMessageShown) {
        if (!isMessageShown && i0.isDevMode()) {
            console.warn(message);
        }
        return true;
    };

    (function (HorizontalAlignment) {
        HorizontalAlignment[HorizontalAlignment["Left"] = -1] = "Left";
        HorizontalAlignment[HorizontalAlignment["Center"] = -0.5] = "Center";
        HorizontalAlignment[HorizontalAlignment["Right"] = 0] = "Right";
    })(exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));
    (function (VerticalAlignment) {
        VerticalAlignment[VerticalAlignment["Top"] = -1] = "Top";
        VerticalAlignment[VerticalAlignment["Middle"] = -0.5] = "Middle";
        VerticalAlignment[VerticalAlignment["Bottom"] = 0] = "Bottom";
    })(exports.VerticalAlignment || (exports.VerticalAlignment = {}));
    (function (RelativePositionStrategy) {
        RelativePositionStrategy["Connected"] = "connected";
        RelativePositionStrategy["Auto"] = "auto";
        RelativePositionStrategy["Elastic"] = "elastic";
    })(exports.RelativePositionStrategy || (exports.RelativePositionStrategy = {}));
    (function (RelativePosition) {
        RelativePosition["Above"] = "above";
        RelativePosition["Below"] = "below";
        RelativePosition["Before"] = "before";
        RelativePosition["After"] = "after";
        RelativePosition["Default"] = "default";
    })(exports.RelativePosition || (exports.RelativePosition = {}));
    (function (AbsolutePosition) {
        AbsolutePosition["Bottom"] = "bottom";
        AbsolutePosition["Top"] = "top";
        AbsolutePosition["Center"] = "center";
    })(exports.AbsolutePosition || (exports.AbsolutePosition = {}));
    var Point = /** @class */ (function () {
        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        return Point;
    }());
    /** @hidden */
    var Util = /** @class */ (function () {
        function Util() {
        }
        /**
         * @hidden
         * Calculates the rectangle of target for provided overlay settings. Defaults to 0,0,0,0,0,0 rectangle
         * if no target is provided
         * @param settings Overlay settings for which to calculate target rectangle
         */
        Util.getTargetRect = function (target) {
            var targetRect = {
                bottom: 0,
                height: 0,
                left: 0,
                right: 0,
                top: 0,
                width: 0
            };
            if (target instanceof HTMLElement) {
                targetRect = target.getBoundingClientRect();
            }
            else if (target instanceof Point) {
                var targetPoint = target;
                targetRect = {
                    bottom: targetPoint.y,
                    height: 0,
                    left: targetPoint.x,
                    right: targetPoint.x,
                    top: targetPoint.y,
                    width: 0
                };
            }
            return targetRect;
        };
        /** @hidden @internal */
        Util.getViewportRect = function (document) {
            var width = document.documentElement.clientWidth;
            var height = document.documentElement.clientHeight;
            var scrollPosition = Util.getViewportScrollPosition(document);
            return {
                top: scrollPosition.y,
                left: scrollPosition.x,
                right: scrollPosition.x + width,
                bottom: scrollPosition.y + height,
                width: width,
                height: height,
            };
        };
        /** @hidden @internal */
        Util.getViewportScrollPosition = function (document) {
            var documentElement = document.documentElement;
            var documentRect = documentElement.getBoundingClientRect();
            var horizontalScrollPosition = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;
            var verticalScrollPosition = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;
            return new Point(horizontalScrollPosition, verticalScrollPosition);
        };
        /** @hidden @internal */
        Util.cloneInstance = function (object) {
            var clonedObj = Object.assign(Object.create(Object.getPrototypeOf(object)), object);
            clonedObj.settings = cloneValue(clonedObj.settings);
            return clonedObj;
        };
        return Util;
    }());

    /**
     * Positions the element based on the directions and start point passed in trough PositionSettings.
     * It is possible to either pass a start point or an HTMLElement as a positioning base.
     */
    var ConnectedPositioningStrategy = /** @class */ (function () {
        function ConnectedPositioningStrategy(settings) {
            this._defaultSettings = {
                horizontalDirection: exports.HorizontalAlignment.Right,
                verticalDirection: exports.VerticalAlignment.Bottom,
                horizontalStartPoint: exports.HorizontalAlignment.Left,
                verticalStartPoint: exports.VerticalAlignment.Bottom,
                openAnimation: scaleInVerTop,
                closeAnimation: scaleOutVerTop,
                minSize: { width: 0, height: 0 }
            };
            this.settings = Object.assign({}, this._defaultSettings, settings);
        }
        /** @inheritdoc */
        ConnectedPositioningStrategy.prototype.position = function (contentElement, size, document, initialCall, target) {
            var targetElement = target || this.settings.target;
            var rects = this.calculateElementRectangles(contentElement, targetElement);
            this.setStyle(contentElement, rects.targetRect, rects.elementRect, {});
        };
        /**
         * @inheritdoc
         * Creates clone of this position strategy
         * @returns clone of this position strategy
         */
        ConnectedPositioningStrategy.prototype.clone = function () {
            return Util.cloneInstance(this);
        };
        /**
         * Obtains the ClientRect objects for the required elements - target and element to position
         *
         * @returns target and element ClientRect objects
         */
        ConnectedPositioningStrategy.prototype.calculateElementRectangles = function (contentElement, target) {
            return {
                targetRect: Util.getTargetRect(target),
                elementRect: contentElement.getBoundingClientRect()
            };
        };
        /**
         * Sets element's style which effectively positions provided element according
         * to provided position settings
         *
         * @param element Element to position
         * @param targetRect Bounding rectangle of strategy target
         * @param elementRect Bounding rectangle of the element
         */
        ConnectedPositioningStrategy.prototype.setStyle = function (element, targetRect, elementRect, connectedFit) {
            var horizontalOffset = connectedFit.horizontalOffset ? connectedFit.horizontalOffset : 0;
            var verticalOffset = connectedFit.verticalOffset ? connectedFit.verticalOffset : 0;
            var startPoint = {
                x: targetRect.right + targetRect.width * this.settings.horizontalStartPoint + horizontalOffset,
                y: targetRect.bottom + targetRect.height * this.settings.verticalStartPoint + verticalOffset
            };
            var wrapperRect = element.parentElement.getBoundingClientRect();
            //  clean up styles - if auto position strategy is chosen we may pass here several times
            element.style.right = '';
            element.style.left = '';
            element.style.bottom = '';
            element.style.top = '';
            switch (this.settings.horizontalDirection) {
                case exports.HorizontalAlignment.Left:
                    element.style.right = Math.round(wrapperRect.right - startPoint.x) + "px";
                    break;
                case exports.HorizontalAlignment.Center:
                    element.style.left = Math.round(startPoint.x - wrapperRect.left - elementRect.width / 2) + "px";
                    break;
                case exports.HorizontalAlignment.Right:
                    element.style.left = Math.round(startPoint.x - wrapperRect.left) + "px";
                    break;
            }
            switch (this.settings.verticalDirection) {
                case exports.VerticalAlignment.Top:
                    element.style.bottom = Math.round(wrapperRect.bottom - startPoint.y) + "px";
                    break;
                case exports.VerticalAlignment.Middle:
                    element.style.top = Math.round(startPoint.y - wrapperRect.top - elementRect.height / 2) + "px";
                    break;
                case exports.VerticalAlignment.Bottom:
                    element.style.top = Math.round(startPoint.y - wrapperRect.top) + "px";
                    break;
            }
        };
        return ConnectedPositioningStrategy;
    }());

    /**
     * Positions the element based on the directions passed in trough PositionSettings.
     * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
     */
    var GlobalPositionStrategy = /** @class */ (function () {
        function GlobalPositionStrategy(settings) {
            this._defaultSettings = {
                horizontalDirection: exports.HorizontalAlignment.Center,
                verticalDirection: exports.VerticalAlignment.Middle,
                horizontalStartPoint: exports.HorizontalAlignment.Center,
                verticalStartPoint: exports.VerticalAlignment.Middle,
                openAnimation: fadeIn,
                closeAnimation: fadeOut,
                minSize: { width: 0, height: 0 }
            };
            this.settings = Object.assign({}, this._defaultSettings, settings);
        }
        /** @inheritdoc */
        GlobalPositionStrategy.prototype.position = function (contentElement, size, document, initialCall) {
            contentElement.classList.add('igx-overlay__content--relative');
            contentElement.parentElement.classList.add('igx-overlay__wrapper--flex');
            this.setPosition(contentElement, this.settings);
        };
        /** @inheritdoc */
        GlobalPositionStrategy.prototype.clone = function () {
            return Util.cloneInstance(this);
        };
        GlobalPositionStrategy.prototype.setPosition = function (contentElement, settings) {
            switch (this.settings.horizontalDirection) {
                case exports.HorizontalAlignment.Left:
                    contentElement.parentElement.style.justifyContent = 'flex-start';
                    break;
                case exports.HorizontalAlignment.Center:
                    contentElement.parentElement.style.justifyContent = 'center';
                    break;
                case exports.HorizontalAlignment.Right:
                    contentElement.parentElement.style.justifyContent = 'flex-end';
                    break;
                default:
                    break;
            }
            switch (this.settings.verticalDirection) {
                case exports.VerticalAlignment.Top:
                    contentElement.parentElement.style.alignItems = 'flex-start';
                    break;
                case exports.VerticalAlignment.Middle:
                    contentElement.parentElement.style.alignItems = 'center';
                    break;
                case exports.VerticalAlignment.Bottom:
                    contentElement.parentElement.style.alignItems = 'flex-end';
                    break;
                default:
                    break;
            }
        };
        return GlobalPositionStrategy;
    }());

    var ScrollStrategy = /** @class */ (function () {
        function ScrollStrategy(scrollContainer) {
        }
        return ScrollStrategy;
    }());

    /**
     * Empty scroll strategy. Does nothing.
     */
    var NoOpScrollStrategy = /** @class */ (function (_super) {
        __extends(NoOpScrollStrategy, _super);
        function NoOpScrollStrategy(scrollContainer) {
            return _super.call(this, scrollContainer) || this;
        }
        /** @inheritdoc */
        NoOpScrollStrategy.prototype.initialize = function (document, overlayService, id) { };
        /** @inheritdoc */
        NoOpScrollStrategy.prototype.attach = function () { };
        /** @inheritdoc */
        NoOpScrollStrategy.prototype.detach = function () { };
        return NoOpScrollStrategy;
    }(ScrollStrategy));

    /**
     * Positions the element inside the containing outlet based on the directions passed in trough PositionSettings.
     * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
     */
    var ContainerPositionStrategy = /** @class */ (function (_super) {
        __extends(ContainerPositionStrategy, _super);
        function ContainerPositionStrategy(settings) {
            return _super.call(this, settings) || this;
        }
        /** @inheritdoc */
        ContainerPositionStrategy.prototype.position = function (contentElement, size, document, initialCall) {
            contentElement.classList.add('igx-overlay__content--relative');
            contentElement.parentElement.classList.add('igx-overlay__wrapper--flex-container');
            this.setPosition(contentElement, this.settings);
        };
        return ContainerPositionStrategy;
    }(GlobalPositionStrategy));

    var BaseFitPositionStrategy = /** @class */ (function (_super) {
        __extends(BaseFitPositionStrategy, _super);
        function BaseFitPositionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /** @inheritdoc */
        BaseFitPositionStrategy.prototype.position = function (contentElement, size, document, initialCall, target) {
            var targetElement = target || this.settings.target;
            var rects = _super.prototype.calculateElementRectangles.call(this, contentElement, targetElement);
            var connectedFit = {};
            if (initialCall) {
                connectedFit.targetRect = rects.targetRect;
                connectedFit.contentElementRect = rects.elementRect;
                this._initialSettings = this._initialSettings || Object.assign({}, this.settings);
                this.settings = Object.assign({}, this._initialSettings);
                connectedFit.viewPortRect = Util.getViewportRect(document);
                this.updateViewPortFit(connectedFit);
                if (this.shouldFitInViewPort(connectedFit)) {
                    this.fitInViewport(contentElement, connectedFit);
                }
            }
            this.setStyle(contentElement, rects.targetRect, rects.elementRect, connectedFit);
        };
        /**
         * Checks if element can fit in viewport and updates provided connectedFit
         * with the result
         *
         * @param connectedFit connectedFit to update
         */
        BaseFitPositionStrategy.prototype.updateViewPortFit = function (connectedFit) {
            connectedFit.left = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.horizontalStartPoint, this.settings.horizontalDirection, connectedFit.horizontalOffset ? connectedFit.horizontalOffset : 0);
            connectedFit.right = connectedFit.left + connectedFit.contentElementRect.width;
            connectedFit.fitHorizontal = {
                back: Math.round(connectedFit.left),
                forward: Math.round(connectedFit.viewPortRect.width - connectedFit.right)
            };
            connectedFit.top = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.verticalStartPoint, this.settings.verticalDirection, connectedFit.verticalOffset ? connectedFit.verticalOffset : 0);
            connectedFit.bottom = connectedFit.top + connectedFit.contentElementRect.height;
            connectedFit.fitVertical = {
                back: Math.round(connectedFit.top),
                forward: Math.round(connectedFit.viewPortRect.height - connectedFit.bottom)
            };
        };
        /**
         * Calculates the position of the left border of the element if it gets positioned
         * with provided start point and direction
         *
         * @param targetRect Rectangle of the target where element is attached
         * @param elementRect Rectangle of the element
         * @param startPoint Start point of the target
         * @param direction Direction in which to show the element
         */
        BaseFitPositionStrategy.prototype.calculateLeft = function (targetRect, elementRect, startPoint, direction, offset) {
            return targetRect.right + targetRect.width * startPoint + elementRect.width * direction + offset;
        };
        /**
         * Calculates the position of the top border of the element if it gets positioned
         * with provided position settings related to the target
         *
         * @param targetRect Rectangle of the target where element is attached
         * @param elementRect Rectangle of the element
         * @param startPoint Start point of the target
         * @param direction Direction in which to show the element
         */
        BaseFitPositionStrategy.prototype.calculateTop = function (targetRect, elementRect, startPoint, direction, offset) {
            return targetRect.bottom + targetRect.height * startPoint + elementRect.height * direction + offset;
        };
        /**
         * Returns whether the element should fit in viewport
         *
         * @param connectedFit connectedFit object containing all necessary parameters
         */
        BaseFitPositionStrategy.prototype.shouldFitInViewPort = function (connectedFit) {
            return connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0 ||
                connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0;
        };
        return BaseFitPositionStrategy;
    }(ConnectedPositioningStrategy));

    /**
     * Positions the element as in **Connected** positioning strategy and resize the element
     * to fit in the view port in case the element is partially getting out of view
     */
    var ElasticPositionStrategy = /** @class */ (function (_super) {
        __extends(ElasticPositionStrategy, _super);
        function ElasticPositionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /** @inheritdoc */
        ElasticPositionStrategy.prototype.fitInViewport = function (element, connectedFit) {
            element.classList.add('igx-overlay__content--elastic');
            var transformString = [];
            if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
                var maxReduction = Math.max(0, connectedFit.contentElementRect.width - this.settings.minSize.width);
                var leftExtend = Math.max(0, -connectedFit.fitHorizontal.back);
                var rightExtend = Math.max(0, -connectedFit.fitHorizontal.forward);
                var reduction = Math.min(maxReduction, leftExtend + rightExtend);
                element.style.width = connectedFit.contentElementRect.width - reduction + "px";
                //  if direction is center and element goes off the screen in left direction we should push the
                //  element to the right. Prevents left still going out of view when normally positioned
                if (this.settings.horizontalDirection === exports.HorizontalAlignment.Center) {
                    //  the amount of translation depends on whether element goes off the screen to the left,
                    //  to the right or in both directions, as well as how much it goes of the screen and finally
                    //  on the minSize. The translation should be proportional between left and right extend
                    //  taken from the reduction
                    var translation = leftExtend * reduction / (leftExtend + rightExtend);
                    if (translation > 0) {
                        transformString.push("translateX(" + translation + "px)");
                    }
                }
            }
            if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
                var maxReduction = Math.max(0, connectedFit.contentElementRect.height - this.settings.minSize.height);
                var topExtend = Math.max(0, -connectedFit.fitVertical.back);
                var bottomExtend = Math.max(0, -connectedFit.fitVertical.forward);
                var reduction = Math.min(maxReduction, topExtend + bottomExtend);
                element.style.height = connectedFit.contentElementRect.height - reduction + "px";
                //  if direction is middle and element goes off the screen in top direction we should push the
                //  element to the bottom. Prevents top still going out of view when normally positioned
                if (this.settings.verticalDirection === exports.VerticalAlignment.Middle) {
                    //  the amount of translation depends on whether element goes off the screen to the top,
                    //  to the bottom or in both directions, as well as how much it goes of the screen and finally
                    //  on the minSize. The translation should be proportional between top and bottom extend
                    //  taken from the reduction
                    var translation = topExtend * reduction / (topExtend + bottomExtend);
                    if (translation > 0) {
                        transformString.push("translateY(" + translation + "px)");
                    }
                }
            }
            element.style.transform = transformString.join(' ').trim();
        };
        return ElasticPositionStrategy;
    }(BaseFitPositionStrategy));

    /**
     * Positions the element as in **Connected** positioning strategy and re-positions the element in
     * the view port (calculating a different start point) in case the element is partially getting out of view
     */
    var AutoPositionStrategy = /** @class */ (function (_super) {
        __extends(AutoPositionStrategy, _super);
        function AutoPositionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /** @inheritdoc */
        AutoPositionStrategy.prototype.fitInViewport = function (element, connectedFit) {
            var transformString = [];
            if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
                if (this.canFlipHorizontal(connectedFit)) {
                    this.flipHorizontal();
                    this.flipAnimation(FlipDirection.Horizontal);
                }
                else {
                    var horizontalPush = this.horizontalPush(connectedFit);
                    transformString.push("translateX(" + horizontalPush + "px)");
                }
            }
            if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
                if (this.canFlipVertical(connectedFit)) {
                    this.flipVertical();
                    this.flipAnimation(FlipDirection.Vertical);
                }
                else {
                    var verticalPush = this.verticalPush(connectedFit);
                    transformString.push("translateY(" + verticalPush + "px)");
                }
            }
            element.style.transform = transformString.join(' ').trim();
        };
        /**
         * Checks if element can be flipped without get off the viewport
         *
         * @param connectedFit connectedFit object containing all necessary parameters
         * @returns true if element can be flipped and stain in viewport
         */
        AutoPositionStrategy.prototype.canFlipHorizontal = function (connectedFit) {
            //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
            //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
            //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
            //  this way:
            //  (-1) * (Left + 1) = 0 = Right
            //  (-1) * (Center + 1) = -0.5 = Center
            //  (-1) * (Right + 1) = -1 = Left
            var flippedStartPoint = (-1) * (this.settings.horizontalStartPoint + 1);
            var flippedDirection = (-1) * (this.settings.horizontalDirection + 1);
            var leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
            var rightBorder = leftBorder + connectedFit.contentElementRect.width;
            return 0 < leftBorder && rightBorder < connectedFit.viewPortRect.width;
        };
        /**
         * Checks if element can be flipped without get off the viewport
         *
         * @param connectedFit connectedFit object containing all necessary parameters
         * @returns true if element can be flipped and stain in viewport
         */
        AutoPositionStrategy.prototype.canFlipVertical = function (connectedFit) {
            var flippedStartPoint = (-1) * (this.settings.verticalStartPoint + 1);
            var flippedDirection = (-1) * (this.settings.verticalDirection + 1);
            var topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
            var bottomBorder = topBorder + connectedFit.contentElementRect.height;
            return 0 < topBorder && bottomBorder < connectedFit.viewPortRect.height;
        };
        /**
         * Flips direction and start point of the position settings
         */
        AutoPositionStrategy.prototype.flipHorizontal = function () {
            switch (this.settings.horizontalDirection) {
                case exports.HorizontalAlignment.Left:
                    this.settings.horizontalDirection = exports.HorizontalAlignment.Right;
                    break;
                case exports.HorizontalAlignment.Right:
                    this.settings.horizontalDirection = exports.HorizontalAlignment.Left;
                    break;
            }
            switch (this.settings.horizontalStartPoint) {
                case exports.HorizontalAlignment.Left:
                    this.settings.horizontalStartPoint = exports.HorizontalAlignment.Right;
                    break;
                case exports.HorizontalAlignment.Right:
                    this.settings.horizontalStartPoint = exports.HorizontalAlignment.Left;
                    break;
            }
        };
        /**
         * Flips direction and start point of the position settings
         */
        AutoPositionStrategy.prototype.flipVertical = function () {
            switch (this.settings.verticalDirection) {
                case exports.VerticalAlignment.Top:
                    this.settings.verticalDirection = exports.VerticalAlignment.Bottom;
                    break;
                case exports.VerticalAlignment.Bottom:
                    this.settings.verticalDirection = exports.VerticalAlignment.Top;
                    break;
            }
            switch (this.settings.verticalStartPoint) {
                case exports.VerticalAlignment.Top:
                    this.settings.verticalStartPoint = exports.VerticalAlignment.Bottom;
                    break;
                case exports.VerticalAlignment.Bottom:
                    this.settings.verticalStartPoint = exports.VerticalAlignment.Top;
                    break;
            }
        };
        /**
         * Calculates necessary horizontal push according to provided connectedFit
         *
         * @param connectedFit connectedFit object containing all necessary parameters
         * @returns amount of necessary translation which will push the element into viewport
         */
        AutoPositionStrategy.prototype.horizontalPush = function (connectedFit) {
            var leftExtend = connectedFit.left;
            var rightExtend = connectedFit.right - connectedFit.viewPortRect.width;
            //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
            //  as much as it is beyond the screen.
            //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
            //  extend but with amount not bigger than what left between left border of screen and left border of
            //  overlay, e.g. leftExtend
            if (leftExtend < 0) {
                return Math.abs(leftExtend);
            }
            else if (rightExtend > 0) {
                return -Math.min(rightExtend, leftExtend);
            }
            else {
                return 0;
            }
        };
        /**
         * Calculates necessary vertical push according to provided connectedFit
         *
         * @param connectedFit connectedFit object containing all necessary parameters
         * @returns amount of necessary translation which will push the element into viewport
         */
        AutoPositionStrategy.prototype.verticalPush = function (connectedFit) {
            var topExtend = connectedFit.top;
            var bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.height;
            if (topExtend < 0) {
                return Math.abs(topExtend);
            }
            else if (bottomExtend > 0) {
                return -Math.min(bottomExtend, topExtend);
            }
            else {
                return 0;
            }
        };
        /**
         * Changes open and close animation with reverse animation if one exists
         *
         * @param flipDirection direction for which to change the animations
         */
        AutoPositionStrategy.prototype.flipAnimation = function (flipDirection) {
            if (this.settings.openAnimation) {
                this.settings.openAnimation = this.updateAnimation(this.settings.openAnimation, flipDirection);
            }
            if (this.settings.closeAnimation) {
                this.settings.closeAnimation = this.updateAnimation(this.settings.closeAnimation, flipDirection);
            }
        };
        /**
         * Tries to find the reverse animation according to provided direction
         *
         * @param animation animation to update
         * @param direction required animation direction
         * @returns reverse animation in given direction if one exists
         */
        AutoPositionStrategy.prototype.updateAnimation = function (animation, direction) {
            switch (direction) {
                case FlipDirection.Horizontal:
                    if (isHorizontalAnimation(animation)) {
                        return reverseAnimationResolver(animation);
                    }
                    break;
                case FlipDirection.Vertical:
                    if (isVerticalAnimation(animation)) {
                        return reverseAnimationResolver(animation);
                    }
                    break;
            }
            return animation;
        };
        return AutoPositionStrategy;
    }(BaseFitPositionStrategy));
    var FlipDirection;
    (function (FlipDirection) {
        FlipDirection[FlipDirection["Horizontal"] = 0] = "Horizontal";
        FlipDirection[FlipDirection["Vertical"] = 1] = "Vertical";
    })(FlipDirection || (FlipDirection = {}));

    var warningShown = false;
    /**
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/overlay-main)
     * The overlay service allows users to show components on overlay div above all other elements in the page.
     */
    var IgxOverlayService = /** @class */ (function () {
        function IgxOverlayService(_factoryResolver, _appRef, _injector, builder, document, _zone, platformUtil) {
            var _this = this;
            this._factoryResolver = _factoryResolver;
            this._appRef = _appRef;
            this._injector = _injector;
            this.builder = builder;
            this.document = document;
            this._zone = _zone;
            this.platformUtil = platformUtil;
            /**
             * Emitted before the component is opened.
             * ```typescript
             * onOpening(event: OverlayCancelableEventArgs){
             *     const onOpening = event;
             * }
             * ```
             */
            this.onOpening = new i0.EventEmitter();
            /**
             * Emitted after the component is appended to the overlay, and before animations are started.
             * ```typescript
             * onAppended(event: OverlayEventArgs){
             *     const onAppended = event;
             * }
             * ```
             */
            this.onAppended = new i0.EventEmitter();
            /**
             * Emitted after the component is opened and all animations are finished.
             * ```typescript
             * onOpened(event: OverlayEventArgs){
             *     const onOpened = event;
             * }
             * ```
             */
            this.onOpened = new i0.EventEmitter();
            /**
             * Emitted before the component is closed.
             * ```typescript
             * onClosing(event: OverlayCancelableEventArgs){
             *     const onClosing = event;
             * }
             * ```
             */
            this.onClosing = new i0.EventEmitter();
            /**
             * Emitted after the component is closed and all animations are finished.
             * ```typescript
             * onClosed(event: OverlayEventArgs){
             *     const onClosed = event;
             * }
             * ```
             */
            this.onClosed = new i0.EventEmitter();
            /**
             * Emitted before animation is started
             * ```typescript
             * onAnimation(event: OverlayAnimationEventArgs){
             *     const onAnimation = event;
             * }
             * ```
             */
            this.onAnimation = new i0.EventEmitter();
            this._componentId = 0;
            this._overlayInfos = [];
            this.destroy$ = new rxjs.Subject();
            this._cursorStyleIsSet = false;
            this._defaultSettings = {
                excludeFromOutsideClick: [],
                positionStrategy: new GlobalPositionStrategy(),
                scrollStrategy: new NoOpScrollStrategy(),
                modal: true,
                closeOnOutsideClick: true,
                closeOnEscape: false
            };
            /** @hidden */
            this.repositionAll = function () {
                for (var i = _this._overlayInfos.length; i--;) {
                    _this.reposition(_this._overlayInfos[i].id);
                }
            };
            this.documentClicked = function (ev) {
                var _loop_1 = function (i) {
                    var info = _this._overlayInfos[i];
                    if (info.settings.modal) {
                        return { value: void 0 };
                    }
                    if (info.settings.closeOnOutsideClick) {
                        var target_1 = ev.composed ? ev.composedPath()[0] : ev.target;
                        var overlayElement = info.elementRef.nativeElement;
                        // check if the click is on the overlay element or on an element from the exclusion list, and if so do not close the overlay
                        var excludeElements = info.settings.excludeFromOutsideClick ? __spread(info.settings.excludeFromOutsideClick, [overlayElement]) : [overlayElement];
                        var isInsideClick = excludeElements.some(function (e) { return e.contains(target_1); });
                        if (isInsideClick) {
                            return { value: void 0 };
                            //  if the click is outside click, but close animation has started do nothing
                        }
                        else if (!(info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted())) {
                            _this._hide(info.id, ev);
                        }
                    }
                };
                //  if we get to modal overlay just return - we should not close anything under it
                //  if we get to non-modal overlay do the next:
                //   1. Check it has close on outside click. If not go on to next overlay;
                //   2. If true check if click is on the element. If it is on the element we have closed
                //  already all previous non-modal with close on outside click elements, so we return. If
                //  not close the overlay and check next
                for (var i = _this._overlayInfos.length; i--;) {
                    var state_1 = _loop_1(i);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            };
            this._document = this.document;
        }
        /**
         * Creates overlay settings with global or container position strategy and preset position settings
         *
         * @param position Preset position settings. Default position is 'center'
         * @param outlet The outlet container to attach the overlay to
         * @returns Non-modal overlay settings based on Global or Container position strategy and the provided position.
         */
        IgxOverlayService.createAbsoluteOverlaySettings = function (position, outlet) {
            var positionSettings = this.createAbsolutePositionSettings(position);
            var strategy = outlet ? new ContainerPositionStrategy(positionSettings) : new GlobalPositionStrategy(positionSettings);
            var overlaySettings = {
                positionStrategy: strategy,
                scrollStrategy: new NoOpScrollStrategy(),
                modal: false,
                closeOnOutsideClick: true,
                outlet: outlet
            };
            return overlaySettings;
        };
        /**
         * Creates overlay settings with auto, connected or elastic position strategy and preset position settings
         *
         * @param target Attaching target for the component to show
         * @param strategy The relative position strategy to be applied to the overlay settings. Default is Auto positioning strategy.
         * @param position Preset position settings. By default the element is positioned below the target, left aligned.
         * @returns Non-modal overlay settings based on the provided target, strategy and position.
         */
        IgxOverlayService.createRelativeOverlaySettings = function (target, position, strategy) {
            var positionSettings = this.createRelativePositionSettings(position);
            var overlaySettings = {
                target: target,
                positionStrategy: this.createPositionStrategy(strategy, positionSettings),
                scrollStrategy: new NoOpScrollStrategy(),
                modal: false,
                closeOnOutsideClick: true
            };
            return overlaySettings;
        };
        IgxOverlayService.createAbsolutePositionSettings = function (position) {
            var positionSettings;
            switch (position) {
                case exports.AbsolutePosition.Bottom:
                    positionSettings = {
                        horizontalDirection: exports.HorizontalAlignment.Center,
                        verticalDirection: exports.VerticalAlignment.Bottom,
                        openAnimation: slideInBottom,
                        closeAnimation: slideOutBottom
                    };
                    break;
                case exports.AbsolutePosition.Top:
                    positionSettings = {
                        horizontalDirection: exports.HorizontalAlignment.Center,
                        verticalDirection: exports.VerticalAlignment.Top,
                        openAnimation: slideInTop,
                        closeAnimation: slideOutTop
                    };
                    break;
                case exports.AbsolutePosition.Center:
                default:
                    positionSettings = {
                        horizontalDirection: exports.HorizontalAlignment.Center,
                        verticalDirection: exports.VerticalAlignment.Middle,
                        openAnimation: fadeIn,
                        closeAnimation: fadeOut
                    };
            }
            return positionSettings;
        };
        IgxOverlayService.createRelativePositionSettings = function (position) {
            var positionSettings;
            switch (position) {
                case exports.RelativePosition.Above:
                    positionSettings = {
                        horizontalStartPoint: exports.HorizontalAlignment.Center,
                        verticalStartPoint: exports.VerticalAlignment.Top,
                        horizontalDirection: exports.HorizontalAlignment.Center,
                        verticalDirection: exports.VerticalAlignment.Top,
                        openAnimation: scaleInVerBottom,
                        closeAnimation: scaleOutVerBottom,
                    };
                    break;
                case exports.RelativePosition.Below:
                    positionSettings = {
                        horizontalStartPoint: exports.HorizontalAlignment.Center,
                        verticalStartPoint: exports.VerticalAlignment.Bottom,
                        horizontalDirection: exports.HorizontalAlignment.Center,
                        verticalDirection: exports.VerticalAlignment.Bottom,
                        openAnimation: scaleInVerTop,
                        closeAnimation: scaleOutVerTop
                    };
                    break;
                case exports.RelativePosition.After:
                    positionSettings = {
                        horizontalStartPoint: exports.HorizontalAlignment.Right,
                        verticalStartPoint: exports.VerticalAlignment.Middle,
                        horizontalDirection: exports.HorizontalAlignment.Right,
                        verticalDirection: exports.VerticalAlignment.Middle,
                        openAnimation: scaleInHorLeft,
                        closeAnimation: scaleOutHorLeft
                    };
                    break;
                case exports.RelativePosition.Before:
                    positionSettings = {
                        horizontalStartPoint: exports.HorizontalAlignment.Left,
                        verticalStartPoint: exports.VerticalAlignment.Middle,
                        horizontalDirection: exports.HorizontalAlignment.Left,
                        verticalDirection: exports.VerticalAlignment.Middle,
                        openAnimation: scaleInHorRight,
                        closeAnimation: scaleOutHorRight
                    };
                    break;
                case exports.RelativePosition.Default:
                default:
                    positionSettings = {
                        horizontalStartPoint: exports.HorizontalAlignment.Left,
                        verticalStartPoint: exports.VerticalAlignment.Bottom,
                        horizontalDirection: exports.HorizontalAlignment.Right,
                        verticalDirection: exports.VerticalAlignment.Bottom,
                        openAnimation: scaleInVerTop,
                        closeAnimation: scaleOutVerTop,
                    };
                    break;
            }
            return positionSettings;
        };
        IgxOverlayService.createPositionStrategy = function (strategy, positionSettings) {
            switch (strategy) {
                case exports.RelativePositionStrategy.Connected:
                    return new ConnectedPositioningStrategy(positionSettings);
                case exports.RelativePositionStrategy.Elastic:
                    return new ElasticPositionStrategy(positionSettings);
                case exports.RelativePositionStrategy.Auto:
                default:
                    return new AutoPositionStrategy(positionSettings);
            }
        };
        IgxOverlayService.prototype.attach = function (component, settings, moduleRef) {
            var info = this.getOverlayInfo(component, moduleRef);
            //  if there is no info most probably wrong type component was provided and we just go out
            if (!info) {
                return null;
            }
            info.id = (this._componentId++).toString();
            settings = Object.assign({}, this._defaultSettings, settings);
            info.settings = settings;
            this._overlayInfos.push(info);
            return info.id;
        };
        IgxOverlayService.prototype.show = function (compOrId, settings) {
            var info;
            var id;
            if (typeof compOrId === 'string') {
                id = compOrId;
                info = this.getOverlayById(compOrId);
                if (!info) {
                    console.warn('igxOverlay.show was called with wrong id: ' + compOrId);
                    return null;
                }
            }
            else {
                warningShown = showMessage('`show(component, settings?)` overload is deprecated. Use `attach(component)` to obtain an Id.' +
                    'Then `show(id, settings?)` with provided Id.', warningShown);
                id = (this._componentId++).toString();
                info = this.getOverlayInfo(compOrId);
                //  if there is no info most probably wrong type component was provided and we just go out
                if (!info) {
                    return;
                }
                info.id = id;
            }
            settings = Object.assign({}, this._defaultSettings, info.settings, settings);
            info.settings = settings;
            this._show(info);
            return id;
        };
        /**
         * Hides the component with the ID provided as a parameter.
         * ```typescript
         * this.overlay.hide(id);
         * ```
         */
        IgxOverlayService.prototype.hide = function (id, event) {
            this._hide(id, event);
        };
        /**
         * Hides all the components and the overlay.
         * ```typescript
         * this.overlay.hideAll();
         * ```
         */
        IgxOverlayService.prototype.hideAll = function () {
            // since overlays are removed on animation done, que all hides
            for (var i = this._overlayInfos.length; i--;) {
                this.hide(this._overlayInfos[i].id);
            }
        };
        /**
         * Repositions the component with ID provided as a parameter.
         * ```typescript
         * this.overlay.reposition(id);
         * ```
         */
        IgxOverlayService.prototype.reposition = function (id) {
            var overlayInfo = this.getOverlayById(id);
            if (!overlayInfo || !overlayInfo.settings) {
                console.error('Wrong id provided in overlay.reposition method. Id: ' + id);
                return;
            }
            var contentElement = overlayInfo.elementRef.nativeElement.parentElement;
            var contentElementRect = contentElement.getBoundingClientRect();
            overlayInfo.settings.positionStrategy.position(contentElement, {
                width: contentElementRect.width,
                height: contentElementRect.height
            }, this._document, false, overlayInfo.settings.target);
        };
        /**
         * Offsets the content along the corresponding axis by the provided amount
         * ```typescript
         * this.overlay.setOffset(id, deltaX, deltaY);
         * ```
         */
        IgxOverlayService.prototype.setOffset = function (id, deltaX, deltaY) {
            var info = this.getOverlayById(id);
            if (!info) {
                return;
            }
            info.transformX += deltaX;
            info.transformY += deltaY;
            var transformX = info.transformX;
            var transformY = info.transformY;
            var translate = "translate(" + transformX + "px, " + transformY + "px)";
            info.elementRef.nativeElement.parentElement.style.transform = translate;
        };
        /** @hidden @internal */
        IgxOverlayService.prototype.getOverlayById = function (id) {
            if (!id) {
                return null;
            }
            var info = this._overlayInfos.find(function (e) { return e.id === id; });
            return info;
        };
        /**
         * @hidden
         */
        IgxOverlayService.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        IgxOverlayService.prototype._show = function (info) {
            var eventArgs = { id: info.id, componentRef: info.componentRef, cancel: false };
            this.onOpening.emit(eventArgs);
            if (eventArgs.cancel) {
                if (info.componentRef) {
                    this._appRef.detachView(info.componentRef.hostView);
                    info.componentRef.destroy();
                }
                return;
            }
            //  if there is no close animation player, or there is one but it is not started yet we are in clear
            //  opening. Otherwise, if there is close animation player playing animation now we should not setup
            //  overlay this is already done
            if (!info.closeAnimationPlayer || (info.closeAnimationPlayer && !info.closeAnimationPlayer.hasStarted())) {
                var elementRect = info.elementRef.nativeElement.getBoundingClientRect();
                info.initialSize = { width: elementRect.width, height: elementRect.height };
                info.hook = this.placeElementHook(info.elementRef.nativeElement);
                this.moveElementToOverlay(info);
                if (info.componentRef) {
                    info.componentRef.changeDetectorRef.detectChanges();
                }
                this.onAppended.emit({ id: info.id, componentRef: info.componentRef });
                this.updateSize(info);
                if (this._overlayInfos.indexOf(info) === -1) {
                    this._overlayInfos.push(info);
                }
                info.settings.positionStrategy.position(info.elementRef.nativeElement.parentElement, { width: info.initialSize.width, height: info.initialSize.height }, document, true, info.settings.target);
                info.settings.scrollStrategy.initialize(this._document, this, info.id);
                info.settings.scrollStrategy.attach();
            }
            this.addOutsideClickListener(info);
            this.addResizeHandler();
            this.addCloseOnEscapeListener(info);
            if (info.settings.modal) {
                var wrapperElement = info.elementRef.nativeElement.parentElement.parentElement;
                wrapperElement.classList.remove('igx-overlay__wrapper');
                this.applyAnimationParams(wrapperElement, info.settings.positionStrategy.settings.openAnimation);
                wrapperElement.classList.add('igx-overlay__wrapper--modal');
            }
            if (info.settings.positionStrategy.settings.openAnimation) {
                this.playOpenAnimation(info);
            }
            else {
                //  to eliminate flickering show the element just before onOpened fire
                info.elementRef.nativeElement.parentElement.style.visibility = '';
                this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
            }
        };
        IgxOverlayService.prototype._hide = function (id, event) {
            var info = this.getOverlayById(id);
            if (!info) {
                console.warn('igxOverlay.hide was called with wrong id: ' + id);
                return;
            }
            var eventArgs = { id: id, componentRef: info.componentRef, cancel: false, event: event };
            this.onClosing.emit(eventArgs);
            if (eventArgs.cancel) {
                return;
            }
            //  TODO: synchronize where these are added/attached and where removed/detached
            info.settings.scrollStrategy.detach();
            this.removeOutsideClickListener(info);
            this.removeResizeHandler();
            var child = info.elementRef.nativeElement;
            if (info.settings.modal) {
                var parent = child.parentNode.parentNode;
                this.applyAnimationParams(parent, info.settings.positionStrategy.settings.closeAnimation);
                parent.classList.remove('igx-overlay__wrapper--modal');
                parent.classList.add('igx-overlay__wrapper');
            }
            if (info.settings.positionStrategy.settings.closeAnimation) {
                this.playCloseAnimation(info, event);
            }
            else {
                this.onCloseDone(info, event);
            }
        };
        IgxOverlayService.prototype.getOverlayInfo = function (component, moduleRef) {
            var info = { ngZone: this._zone, transformX: 0, transformY: 0 };
            if (component instanceof i0.ElementRef) {
                info.elementRef = component;
            }
            else {
                var dynamicFactory = void 0;
                var factoryResolver = moduleRef ? moduleRef.componentFactoryResolver : this._factoryResolver;
                try {
                    dynamicFactory = factoryResolver.resolveComponentFactory(component);
                }
                catch (error) {
                    console.error(error);
                    return null;
                }
                var injector = moduleRef ? moduleRef.injector : this._injector;
                var dynamicComponent = dynamicFactory.create(injector);
                this._appRef.attachView(dynamicComponent.hostView);
                // If the element is newly created from a Component, it is wrapped in 'ng-component' tag - we do not want that.
                var element = dynamicComponent.location.nativeElement;
                info.elementRef = { nativeElement: element };
                info.componentRef = dynamicComponent;
            }
            return info;
        };
        IgxOverlayService.prototype.placeElementHook = function (element) {
            if (!element.parentElement) {
                return null;
            }
            var hook = this._document.createElement('div');
            element.parentElement.insertBefore(hook, element);
            return hook;
        };
        IgxOverlayService.prototype.moveElementToOverlay = function (info) {
            var wrapperElement = this.getWrapperElement();
            var contentElement = this.getContentElement(wrapperElement, info.settings.modal);
            this.getOverlayElement(info).appendChild(wrapperElement);
            contentElement.appendChild(info.elementRef.nativeElement);
        };
        IgxOverlayService.prototype.getWrapperElement = function () {
            var wrapper = this._document.createElement('div');
            wrapper.classList.add('igx-overlay__wrapper');
            return wrapper;
        };
        IgxOverlayService.prototype.getContentElement = function (wrapperElement, modal) {
            var content = this._document.createElement('div');
            if (modal) {
                content.classList.add('igx-overlay__content--modal');
                content.addEventListener('click', function (ev) {
                    ev.stopPropagation();
                });
            }
            else {
                content.classList.add('igx-overlay__content');
            }
            content.addEventListener('scroll', function (ev) {
                ev.stopPropagation();
            });
            //  hide element to eliminate flickering. Show the element exactly before animation starts
            content.style.visibility = 'hidden';
            wrapperElement.appendChild(content);
            return content;
        };
        IgxOverlayService.prototype.getOverlayElement = function (info) {
            if (info.settings.outlet) {
                return info.settings.outlet.nativeElement || info.settings.outlet;
            }
            if (!this._overlayElement) {
                this._overlayElement = this._document.createElement('div');
                this._overlayElement.classList.add('igx-overlay');
                this._document.body.appendChild(this._overlayElement);
            }
            return this._overlayElement;
        };
        IgxOverlayService.prototype.updateSize = function (info) {
            if (info.componentRef) {
                //  if we are positioning component this is first time it gets visible
                //  and we can finally get its size
                info.initialSize = info.elementRef.nativeElement.getBoundingClientRect();
            }
            // set content div width only if element to show has width
            if (info.initialSize.width !== 0) {
                info.elementRef.nativeElement.parentElement.style.width = info.initialSize.width + 'px';
            }
        };
        IgxOverlayService.prototype.onCloseDone = function (info, event) {
            this.cleanUp(info);
            this.onClosed.emit({ id: info.id, componentRef: info.componentRef, event: event });
        };
        IgxOverlayService.prototype.cleanUp = function (info) {
            var child = info.elementRef.nativeElement;
            var outlet = this.getOverlayElement(info);
            if (!outlet.contains(child)) {
                console.warn('Component with id:' + info.id + ' is already removed!');
                return;
            }
            outlet.removeChild(child.parentNode.parentNode);
            if (info.componentRef) {
                this._appRef.detachView(info.componentRef.hostView);
                info.componentRef.destroy();
            }
            if (info.hook) {
                info.hook.parentElement.insertBefore(info.elementRef.nativeElement, info.hook);
                info.hook.parentElement.removeChild(info.hook);
            }
            var index = this._overlayInfos.indexOf(info);
            this._overlayInfos.splice(index, 1);
            // this._overlayElement.parentElement check just for tests that manually delete the element
            if (this._overlayInfos.length === 0) {
                if (this._overlayElement && this._overlayElement.parentElement) {
                    this._overlayElement.parentElement.removeChild(this._overlayElement);
                    this._overlayElement = null;
                }
                this.removeCloseOnEscapeListener();
            }
        };
        IgxOverlayService.prototype.playOpenAnimation = function (info) {
            var _this = this;
            if (!info.openAnimationPlayer) {
                var animationBuilder = this.builder.build(info.settings.positionStrategy.settings.openAnimation);
                info.openAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
                //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
                //  and then getting the positions from it.
                //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
                //  As soon as this is resolved we can remove this hack
                var innerRenderer = info.openAnimationPlayer._renderer;
                info.openAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
                info.openAnimationPlayer.onDone(function () {
                    _this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
                    if (info.openAnimationPlayer) {
                        info.openAnimationPlayer.reset();
                        info.openAnimationPlayer = null;
                    }
                    if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
                        info.closeAnimationPlayer.reset();
                    }
                });
            }
            //  if there is opening animation already started do nothing
            if (info.openAnimationPlayer.hasStarted()) {
                return;
            }
            //  if there is closing animation already started start open animation from where close one has reached
            //  and remove close animation
            if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
                //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
                //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
                //  the previous has finished we need the amount up to 1, therefore we are subtracting what
                //  getPosition() returns from one
                var position = 1 - info.closeAnimationInnerPlayer.getPosition();
                info.closeAnimationPlayer.reset();
                info.closeAnimationPlayer = null;
                info.openAnimationPlayer.init();
                info.openAnimationPlayer.setPosition(position);
            }
            this.onAnimation.emit({ id: info.id, animationPlayer: info.openAnimationPlayer, animationType: 'open' });
            //  to eliminate flickering show the element just before animation start
            info.elementRef.nativeElement.parentElement.style.visibility = '';
            info.openAnimationPlayer.play();
        };
        IgxOverlayService.prototype.playCloseAnimation = function (info, ev) {
            var _this = this;
            if (!info.closeAnimationPlayer) {
                var animationBuilder = this.builder.build(info.settings.positionStrategy.settings.closeAnimation);
                info.closeAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
                //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
                //  and then getting the positions from it.
                //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
                //  As soon as this is resolved we can remove this hack
                var innerRenderer = info.closeAnimationPlayer._renderer;
                info.closeAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
                info.closeAnimationPlayer.onDone(function () {
                    if (info.closeAnimationPlayer) {
                        info.closeAnimationPlayer.reset();
                        info.closeAnimationPlayer = null;
                    }
                    if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
                        info.openAnimationPlayer.reset();
                    }
                    _this.onCloseDone(info, ev);
                });
            }
            //  if there is closing animation already started do nothing
            if (info.closeAnimationPlayer.hasStarted()) {
                return;
            }
            //  if there is opening animation already started start close animation from where open one has reached
            //  and remove open animation
            if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
                //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
                //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
                //  the previous has finished we need the amount up to 1, therefore we are subtracting what
                //  getPosition() returns from one
                var position = 1 - info.openAnimationInnerPlayer.getPosition();
                info.openAnimationPlayer.reset();
                info.openAnimationPlayer = null;
                info.closeAnimationPlayer.init();
                info.closeAnimationPlayer.setPosition(position);
            }
            this.onAnimation.emit({ id: info.id, animationPlayer: info.closeAnimationPlayer, animationType: 'close' });
            info.closeAnimationPlayer.play();
        };
        //  TODO: check if applyAnimationParams will work with complex animations
        IgxOverlayService.prototype.applyAnimationParams = function (wrapperElement, animationOptions) {
            if (!animationOptions) {
                wrapperElement.style.transitionDuration = '0ms';
                return;
            }
            if (animationOptions.type === 10 /* AnimateRef */) {
                animationOptions = animationOptions.animation;
            }
            if (!animationOptions.options || !animationOptions.options.params) {
                return;
            }
            var params = animationOptions.options.params;
            if (params.duration) {
                wrapperElement.style.transitionDuration = params.duration;
            }
            if (params.easing) {
                wrapperElement.style.transitionTimingFunction = params.easing;
            }
        };
        IgxOverlayService.prototype.addOutsideClickListener = function (info) {
            var _this = this;
            if (info.settings.closeOnOutsideClick) {
                if (info.settings.modal) {
                    rxjs.fromEvent(info.elementRef.nativeElement.parentElement.parentElement, 'click')
                        .pipe(operators.takeUntil(this.destroy$))
                        .subscribe(function (e) { return _this._hide(info.id, e); });
                }
                else if (
                //  if all overlays minus closing overlays equals one add the handler
                this._overlayInfos.filter(function (x) { return x.settings.closeOnOutsideClick && !x.settings.modal; }).length -
                    this._overlayInfos.filter(function (x) { return x.settings.closeOnOutsideClick && !x.settings.modal &&
                        x.closeAnimationPlayer &&
                        x.closeAnimationPlayer.hasStarted(); }).length === 1) {
                    // click event is not fired on iOS. To make element "clickable" we are
                    // setting the cursor to pointer
                    if (this.platformUtil.isIOS && !this._cursorStyleIsSet) {
                        this._cursorOriginalValue = this._document.body.style.cursor;
                        this._document.body.style.cursor = 'pointer';
                        this._cursorStyleIsSet = true;
                    }
                    this._document.addEventListener('click', this.documentClicked, true);
                }
            }
        };
        IgxOverlayService.prototype.removeOutsideClickListener = function (info) {
            if (info.settings.modal === false) {
                var shouldRemoveClickEventListener_1 = true;
                this._overlayInfos.forEach(function (o) {
                    if (o.settings.modal === false && o.id !== info.id) {
                        shouldRemoveClickEventListener_1 = false;
                    }
                });
                if (shouldRemoveClickEventListener_1) {
                    if (this._cursorStyleIsSet) {
                        this._document.body.style.cursor = this._cursorOriginalValue;
                        this._cursorOriginalValue = '';
                        this._cursorStyleIsSet = false;
                    }
                    this._document.removeEventListener('click', this.documentClicked, true);
                }
            }
        };
        IgxOverlayService.prototype.addResizeHandler = function () {
            var closingOverlaysCount = this._overlayInfos
                .filter(function (o) { return o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted(); })
                .length;
            if (this._overlayInfos.length - closingOverlaysCount === 1) {
                this._document.defaultView.addEventListener('resize', this.repositionAll);
            }
        };
        IgxOverlayService.prototype.removeResizeHandler = function () {
            var closingOverlaysCount = this._overlayInfos
                .filter(function (o) { return o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted(); })
                .length;
            if (this._overlayInfos.length - closingOverlaysCount === 1) {
                this._document.defaultView.removeEventListener('resize', this.repositionAll);
            }
        };
        IgxOverlayService.prototype.addCloseOnEscapeListener = function (info) {
            var _this = this;
            if (info.settings.closeOnEscape && !this._keyPressEventListener) {
                this._keyPressEventListener = rxjs.fromEvent(this._document, 'keydown').pipe(operators.filter(function (ev) { return ev.key === 'Escape' || ev.key === 'Esc'; })).subscribe(function (ev) {
                    var targetOverlay = _this._overlayInfos[_this._overlayInfos.length - 1];
                    if (targetOverlay.settings.closeOnEscape) {
                        _this.hide(targetOverlay.id, ev);
                    }
                });
            }
        };
        IgxOverlayService.prototype.removeCloseOnEscapeListener = function () {
            if (this._keyPressEventListener) {
                this._keyPressEventListener.unsubscribe();
                this._keyPressEventListener = null;
            }
        };
        return IgxOverlayService;
    }());
    IgxOverlayService.ɵprov = i0.ɵɵdefineInjectable({ factory: function IgxOverlayService_Factory() { return new IgxOverlayService(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.ApplicationRef), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.AnimationBuilder), i0.ɵɵinject(i2.DOCUMENT), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PlatformUtil)); }, token: IgxOverlayService, providedIn: "root" });
    IgxOverlayService.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    IgxOverlayService.ctorParameters = function () { return [
        { type: i0.ComponentFactoryResolver },
        { type: i0.ApplicationRef },
        { type: i0.Injector },
        { type: i1.AnimationBuilder },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: i0.NgZone },
        { type: PlatformUtil }
    ]; };

    // Export position strategies

    /**
     * On scroll reposition the overlay content.
     */
    var AbsoluteScrollStrategy = /** @class */ (function (_super) {
        __extends(AbsoluteScrollStrategy, _super);
        function AbsoluteScrollStrategy(scrollContainer) {
            var _this = _super.call(this, scrollContainer) || this;
            _this._initialized = false;
            _this.onScroll = function (e) {
                var overlayInfo = _this._overlayService.getOverlayById(_this._id);
                if (!overlayInfo) {
                    return;
                }
                if (!overlayInfo.elementRef.nativeElement.contains(e.target)) {
                    _this._overlayService.reposition(_this._id);
                }
            };
            _this._scrollContainer = scrollContainer;
            return _this;
        }
        /** @inheritdoc */
        AbsoluteScrollStrategy.prototype.initialize = function (document, overlayService, id) {
            if (this._initialized) {
                return;
            }
            this._overlayService = overlayService;
            this._id = id;
            this._document = document;
            this._zone = overlayService.getOverlayById(id).ngZone;
            this._initialized = true;
        };
        /** @inheritdoc */
        AbsoluteScrollStrategy.prototype.attach = function () {
            var _this = this;
            if (this._zone) {
                this._zone.runOutsideAngular(function () {
                    _this.addScrollEventListener();
                });
            }
            else {
                this.addScrollEventListener();
            }
        };
        /** @inheritdoc */
        AbsoluteScrollStrategy.prototype.detach = function () {
            var _a;
            if (this._scrollContainer) {
                this._scrollContainer.removeEventListener('scroll', this.onScroll, true);
            }
            else {
                // Tired of this thing throwing every other time. Fix it ffs!
                (_a = this._document) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', this.onScroll, true);
            }
            this._initialized = false;
        };
        AbsoluteScrollStrategy.prototype.addScrollEventListener = function () {
            if (this._scrollContainer) {
                this._scrollContainer.addEventListener('scroll', this.onScroll, true);
            }
            else {
                this._document.addEventListener('scroll', this.onScroll, true);
            }
        };
        return AbsoluteScrollStrategy;
    }(ScrollStrategy));

    /**
     * Prevents scrolling while the overlay content is shown.
     */
    var BlockScrollStrategy = /** @class */ (function (_super) {
        __extends(BlockScrollStrategy, _super);
        function BlockScrollStrategy(scrollContainer) {
            var _this = _super.call(this, scrollContainer) || this;
            _this._initialized = false;
            _this.onScroll = function (ev) {
                ev.preventDefault();
                if (!_this._sourceElement || _this._sourceElement !== ev.target) {
                    _this._sourceElement = ev.target;
                    _this._initialScrollTop = _this._sourceElement.scrollTop;
                    _this._initialScrollLeft = _this._sourceElement.scrollLeft;
                }
                _this._sourceElement.scrollTop = _this._initialScrollTop;
                _this._sourceElement.scrollLeft = _this._initialScrollLeft;
            };
            return _this;
        }
        /** @inheritdoc */
        BlockScrollStrategy.prototype.initialize = function (document, overlayService, id) {
            if (this._initialized) {
                return;
            }
            this._document = document;
            this._initialized = true;
        };
        /** @inheritdoc */
        BlockScrollStrategy.prototype.attach = function () {
            this._document.addEventListener('scroll', this.onScroll, true);
        };
        /** @inheritdoc */
        BlockScrollStrategy.prototype.detach = function () {
            this._document.removeEventListener('scroll', this.onScroll, true);
            this._sourceElement = null;
            this._initialScrollTop = 0;
            this._initialScrollLeft = 0;
            this._initialized = false;
        };
        return BlockScrollStrategy;
    }(ScrollStrategy));

    /**
     * Uses a tolerance and closes the shown component upon scrolling if the tolerance is exceeded
     */
    var CloseScrollStrategy = /** @class */ (function (_super) {
        __extends(CloseScrollStrategy, _super);
        function CloseScrollStrategy(scrollContainer) {
            var _this = _super.call(this, scrollContainer) || this;
            _this._initialized = false;
            _this.onScroll = function (ev) {
                if (!_this._sourceElement) {
                    return;
                }
                _this.cumulativeScrollTop += _this._sourceElement.scrollTop;
                _this.cumulativeScrollLeft += _this._sourceElement.scrollLeft;
                if (Math.abs(_this.cumulativeScrollTop - _this.initialScrollTop) > _this._threshold ||
                    Math.abs(_this.cumulativeScrollLeft - _this.initialScrollLeft) > _this._threshold) {
                    _this._document.removeEventListener('scroll', _this.onScroll, true);
                    _this._overlayService.hide(_this._id);
                }
            };
            _this._scrollContainer = scrollContainer;
            _this._threshold = 10;
            _this.cumulativeScrollTop = 0;
            _this.cumulativeScrollLeft = 0;
            return _this;
        }
        /** @inheritdoc */
        CloseScrollStrategy.prototype.initialize = function (document, overlayService, id) {
            if (this._initialized) {
                return;
            }
            this._overlayService = overlayService;
            this._id = id;
            this._document = document;
            this._initialized = true;
        };
        /** @inheritdoc */
        CloseScrollStrategy.prototype.attach = function () {
            if (this._scrollContainer) {
                this._scrollContainer.addEventListener('scroll', this.onScroll);
                this._sourceElement = this._scrollContainer;
            }
            else {
                this._document.addEventListener('scroll', this.onScroll);
                if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
                    this._sourceElement = document.documentElement;
                }
                else if (document.body.scrollHeight > document.body.clientHeight) {
                    this._sourceElement = document.body;
                }
            }
            if (!this._sourceElement) {
                return;
            }
            this.cumulativeScrollTop = 0;
            this.cumulativeScrollLeft = 0;
            this.initialScrollTop = this._sourceElement.scrollTop;
            this.initialScrollLeft = this._sourceElement.scrollLeft;
        };
        /** @inheritdoc */
        CloseScrollStrategy.prototype.detach = function () {
            // TODO: check why event listener removes only on first call and remains on each next!!!
            if (this._scrollContainer) {
                this._scrollContainer.removeEventListener('scroll', this.onScroll);
            }
            else {
                this._document.removeEventListener('scroll', this.onScroll);
            }
            this._sourceElement = null;
            this.cumulativeScrollTop = 0;
            this.cumulativeScrollLeft = 0;
            this.initialScrollTop = 0;
            this.initialScrollLeft = 0;
            this._initialized = false;
        };
        return CloseScrollStrategy;
    }(ScrollStrategy));

    // Export scroll strategies

    var IgxBaseTransactionService = /** @class */ (function () {
        function IgxBaseTransactionService() {
            /**
             * @inheritdoc
             */
            this.onStateUpdate = new i0.EventEmitter();
            this._isPending = false;
            this._pendingTransactions = [];
            this._pendingStates = new Map();
        }
        Object.defineProperty(IgxBaseTransactionService.prototype, "canRedo", {
            /**
             * @inheritdoc
             */
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxBaseTransactionService.prototype, "canUndo", {
            /**
             * @inheritdoc
             */
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxBaseTransactionService.prototype, "enabled", {
            /**
             * @inheritdoc
             */
            get: function () {
                return this._isPending;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.add = function (transaction, recordRef) {
            if (this._isPending) {
                this.updateState(this._pendingStates, transaction, recordRef);
                this._pendingTransactions.push(transaction);
            }
        };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.getTransactionLog = function (id) {
            return [];
        };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.undo = function () { };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.redo = function () { };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.getAggregatedChanges = function (mergeChanges) {
            var _this = this;
            var result = [];
            this._pendingStates.forEach(function (state, key) {
                var value = mergeChanges ? _this.getAggregatedValue(key, mergeChanges) : state.value;
                result.push({ id: key, newValue: value, type: state.type });
            });
            return result;
        };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.getState = function (id) {
            return this._pendingStates.get(id);
        };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.getAggregatedValue = function (id, mergeChanges) {
            var state = this._pendingStates.get(id);
            if (!state) {
                return null;
            }
            if (mergeChanges) {
                return this.updateValue(state);
            }
            return state.value;
        };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.commit = function (data, id) { };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.clear = function (id) {
            this._pendingStates.clear();
            this._pendingTransactions = [];
        };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.startPending = function () {
            this._isPending = true;
        };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.endPending = function (commit) {
            this._isPending = false;
            this._pendingStates.clear();
            this._pendingTransactions = [];
        };
        /**
         * Updates the provided states collection according to passed transaction and recordRef
         *
         * @param states States collection to apply the update to
         * @param transaction Transaction to apply to the current state
         * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
         */
        IgxBaseTransactionService.prototype.updateState = function (states, transaction, recordRef) {
            var state = states.get(transaction.id);
            if (state) {
                if (isObject(state.value)) {
                    mergeObjects(state.value, transaction.newValue);
                }
                else {
                    state.value = transaction.newValue;
                }
            }
            else {
                state = { value: cloneValue(transaction.newValue), recordRef: recordRef, type: transaction.type };
                states.set(transaction.id, state);
            }
        };
        /**
         * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types
         *
         * @param state State to update value for
         * @returns updated value including all the changes in provided state
         */
        IgxBaseTransactionService.prototype.updateValue = function (state) {
            return this.mergeValues(state.recordRef, state.value);
        };
        /**
         * Merges second values in first value and the result in empty object. If values are primitive type
         * returns second value if exists, or first value.
         *
         * @param first Value to merge into
         * @param second Value to merge
         */
        IgxBaseTransactionService.prototype.mergeValues = function (first, second) {
            if (isObject(first) || isObject(second)) {
                return mergeObjects(cloneValue(first), second);
            }
            else {
                return second ? second : first;
            }
        };
        return IgxBaseTransactionService;
    }());
    IgxBaseTransactionService.decorators = [
        { type: i0.Injectable }
    ];

    var IgxTransactionService = /** @class */ (function (_super) {
        __extends(IgxTransactionService, _super);
        function IgxTransactionService() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            /**
             * @inheritdoc
             */
            _this.onStateUpdate = new i0.EventEmitter();
            _this._transactions = [];
            _this._redoStack = [];
            _this._undoStack = [];
            _this._states = new Map();
            return _this;
        }
        Object.defineProperty(IgxTransactionService.prototype, "canUndo", {
            /**
             * @inheritdoc
             */
            get: function () {
                return this._undoStack.length > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTransactionService.prototype, "canRedo", {
            /**
             * @inheritdoc
             */
            get: function () {
                return this._redoStack.length > 0;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.add = function (transaction, recordRef) {
            var states = this._isPending ? this._pendingStates : this._states;
            this.verifyAddedTransaction(states, transaction, recordRef);
            this.addTransaction(transaction, states, recordRef);
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.getTransactionLog = function (id) {
            if (id !== undefined) {
                return this._transactions.filter(function (t) { return t.id === id; });
            }
            return __spread(this._transactions);
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.getAggregatedChanges = function (mergeChanges) {
            var _this = this;
            var result = [];
            this._states.forEach(function (state, key) {
                var value = mergeChanges ? _this.mergeValues(state.recordRef, state.value) : state.value;
                result.push({ id: key, newValue: value, type: state.type });
            });
            return result;
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.getState = function (id, pending) {
            if (pending === void 0) { pending = false; }
            return pending ? this._pendingStates.get(id) : this._states.get(id);
        };
        Object.defineProperty(IgxTransactionService.prototype, "enabled", {
            /**
             * @inheritdoc
             */
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.getAggregatedValue = function (id, mergeChanges) {
            var state = this._states.get(id);
            var pendingState = _super.prototype.getState.call(this, id);
            //  if there is no state and there is no pending state return null
            if (!state && !pendingState) {
                return null;
            }
            var pendingChange = _super.prototype.getAggregatedValue.call(this, id, false);
            var change = state && state.value;
            var aggregatedValue = this.mergeValues(change, pendingChange);
            if (mergeChanges) {
                var originalValue = state ? state.recordRef : pendingState.recordRef;
                aggregatedValue = this.mergeValues(originalValue, aggregatedValue);
            }
            return aggregatedValue;
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.endPending = function (commit) {
            var e_1, _a;
            this._isPending = false;
            if (commit) {
                var actions = [];
                try {
                    // don't use addTransaction due to custom undo handling
                    for (var _b = __values(this._pendingTransactions), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var transaction = _c.value;
                        var pendingState = this._pendingStates.get(transaction.id);
                        this._transactions.push(transaction);
                        this.updateState(this._states, transaction, pendingState.recordRef);
                        actions.push({ transaction: transaction, recordRef: pendingState.recordRef });
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                this._undoStack.push(actions);
                this._redoStack = [];
                this.onStateUpdate.emit({ origin: exports.TransactionEventOrigin.END, actions: actions });
            }
            _super.prototype.endPending.call(this, commit);
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.commit = function (data, id) {
            var _this = this;
            if (id !== undefined) {
                var state = this.getState(id);
                if (state) {
                    this.updateRecord(data, state);
                }
            }
            else {
                this._states.forEach(function (s) {
                    _this.updateRecord(data, s);
                });
            }
            this.clear(id);
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.clear = function (id) {
            if (id !== undefined) {
                this._transactions = this._transactions.filter(function (t) { return t.id !== id; });
                this._states.delete(id);
                //  Undo stack is an array of actions. Each action is array of transaction like objects
                //  We are going trough all the actions. For each action we are filtering out transactions
                //  with provided id. Finally if any action ends up as empty array we are removing it from
                //  undo stack
                this._undoStack = this._undoStack.map(function (a) { return a.filter(function (t) { return t.transaction.id !== id; }); }).filter(function (a) { return a.length > 0; });
            }
            else {
                this._transactions = [];
                this._states.clear();
                this._undoStack = [];
            }
            this._redoStack = [];
            this.onStateUpdate.emit({ origin: exports.TransactionEventOrigin.CLEAR, actions: [] });
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.undo = function () {
            var e_2, _a, e_3, _b;
            if (this._undoStack.length <= 0) {
                return;
            }
            var lastActions = this._undoStack.pop();
            this._transactions.splice(this._transactions.length - lastActions.length);
            this._redoStack.push(lastActions);
            this._states.clear();
            try {
                for (var _c = __values(this._undoStack), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var currentActions = _d.value;
                    try {
                        for (var currentActions_1 = (e_3 = void 0, __values(currentActions)), currentActions_1_1 = currentActions_1.next(); !currentActions_1_1.done; currentActions_1_1 = currentActions_1.next()) {
                            var transaction = currentActions_1_1.value;
                            this.updateState(this._states, transaction.transaction, transaction.recordRef);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (currentActions_1_1 && !currentActions_1_1.done && (_b = currentActions_1.return)) _b.call(currentActions_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this.onStateUpdate.emit({ origin: exports.TransactionEventOrigin.UNDO, actions: lastActions });
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.redo = function () {
            var e_4, _a;
            if (this._redoStack.length > 0) {
                var actions = this._redoStack.pop();
                try {
                    for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                        var action = actions_1_1.value;
                        this.updateState(this._states, action.transaction, action.recordRef);
                        this._transactions.push(action.transaction);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                this._undoStack.push(actions);
                this.onStateUpdate.emit({ origin: exports.TransactionEventOrigin.REDO, actions: actions });
            }
        };
        IgxTransactionService.prototype.addTransaction = function (transaction, states, recordRef) {
            this.updateState(states, transaction, recordRef);
            var transactions = this._isPending ? this._pendingTransactions : this._transactions;
            transactions.push(transaction);
            if (!this._isPending) {
                var actions = [{ transaction: transaction, recordRef: recordRef }];
                this._undoStack.push(actions);
                this._redoStack = [];
                this.onStateUpdate.emit({ origin: exports.TransactionEventOrigin.ADD, actions: actions });
            }
        };
        /**
         * Verifies if the passed transaction is correct. If not throws an exception.
         *
         * @param transaction Transaction to be verified
         */
        IgxTransactionService.prototype.verifyAddedTransaction = function (states, transaction, recordRef) {
            var state = states.get(transaction.id);
            switch (transaction.type) {
                case exports.TransactionType.ADD:
                    if (state) {
                        //  cannot add same item twice
                        throw new Error("Cannot add this transaction. Transaction with id: " + transaction.id + " has been already added.");
                    }
                    break;
                case exports.TransactionType.DELETE:
                case exports.TransactionType.UPDATE:
                    if (state && state.type === exports.TransactionType.DELETE) {
                        //  cannot delete or update deleted items
                        throw new Error("Cannot add this transaction. Transaction with id: " + transaction.id + " has been already deleted.");
                    }
                    if (!state && !recordRef && !this._isPending) {
                        //  cannot initially add transaction or delete item with no recordRef
                        throw new Error("Cannot add this transaction. This is first transaction of type " + transaction.type + " " +
                            ("for id " + transaction.id + ". For first transaction of this type recordRef is mandatory."));
                    }
                    break;
            }
        };
        /**
         * Updates the provided states collection according to passed transaction and recordRef
         *
         * @param states States collection to apply the update to
         * @param transaction Transaction to apply to the current state
         * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
         */
        IgxTransactionService.prototype.updateState = function (states, transaction, recordRef) {
            var state = states.get(transaction.id);
            //  if TransactionType is ADD simply add transaction to states;
            //  if TransactionType is DELETE:
            //    - if there is state with this id of type ADD remove it from the states;
            //    - if there is state with this id of type UPDATE change its type to DELETE;
            //    - if there is no state with this id add transaction to states;
            //  if TransactionType is UPDATE:
            //    - if there is state with this id of type ADD merge new value and state recordRef into state new value
            //    - if there is state with this id of type UPDATE merge new value into state new value
            //    - if there is state with this id and state type is DELETE change its type to UPDATE
            //    - if there is no state with this id add transaction to states;
            if (state) {
                switch (transaction.type) {
                    case exports.TransactionType.DELETE:
                        if (state.type === exports.TransactionType.ADD) {
                            states.delete(transaction.id);
                        }
                        else if (state.type === exports.TransactionType.UPDATE) {
                            state.value = transaction.newValue;
                            state.type = exports.TransactionType.DELETE;
                        }
                        break;
                    case exports.TransactionType.UPDATE:
                        if (isObject(state.value)) {
                            if (state.type === exports.TransactionType.ADD) {
                                state.value = this.mergeValues(state.value, transaction.newValue);
                            }
                            if (state.type === exports.TransactionType.UPDATE) {
                                mergeObjects(state.value, transaction.newValue);
                            }
                        }
                        else {
                            state.value = transaction.newValue;
                        }
                }
            }
            else {
                state = { value: cloneValue(transaction.newValue), recordRef: recordRef, type: transaction.type };
                states.set(transaction.id, state);
            }
            //  should not clean pending state. This will happen automatically on endPending call
            if (!this._isPending) {
                this.cleanState(transaction.id, states);
            }
        };
        /**
         * Compares the state with recordRef and clears all duplicated values. If any state ends as
         * empty object removes it from states.
         *
         * @param state State to clean
         */
        IgxTransactionService.prototype.cleanState = function (id, states) {
            var e_5, _a;
            var state = states.get(id);
            //  do nothing if
            //  there is no state, or
            //  there is no state value (e.g. DELETED transaction), or
            //  there is no recordRef (e.g. ADDED transaction)
            if (state && state.value && state.recordRef) {
                //  if state's value is object compare each key with the ones in recordRef
                //  if values in any key are the same delete it from state's value
                //  if state's value is not object, simply compare with recordRef and remove
                //  the state if they are equal
                if (isObject(state.recordRef)) {
                    try {
                        for (var _b = __values(Object.keys(state.value)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var key = _c.value;
                            if (JSON.stringify(state.recordRef[key]) === JSON.stringify(state.value[key])) {
                                delete state.value[key];
                            }
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                    //  if state's value is empty remove the state from the states, only if state is not DELETE type
                    if (state.type !== exports.TransactionType.DELETE && Object.keys(state.value).length === 0) {
                        states.delete(id);
                    }
                }
                else {
                    if (state.recordRef === state.value) {
                        states.delete(id);
                    }
                }
            }
        };
        /**
         * Updates state related record in the provided data
         *
         * @param data Data source to update
         * @param state State to update data from
         */
        IgxTransactionService.prototype.updateRecord = function (data, state) {
            var index = data.findIndex(function (i) { return JSON.stringify(i) === JSON.stringify(state.recordRef || {}); });
            switch (state.type) {
                case exports.TransactionType.ADD:
                    data.push(state.value);
                    break;
                case exports.TransactionType.DELETE:
                    if (0 <= index && index < data.length) {
                        data.splice(index, 1);
                    }
                    break;
                case exports.TransactionType.UPDATE:
                    if (0 <= index && index < data.length) {
                        data[index] = this.updateValue(state);
                    }
                    break;
            }
        };
        return IgxTransactionService;
    }(IgxBaseTransactionService));
    IgxTransactionService.decorators = [
        { type: i0.Injectable }
    ];

    /** @experimental @hidden */
    var IgxHierarchicalTransactionService = /** @class */ (function (_super) {
        __extends(IgxHierarchicalTransactionService, _super);
        function IgxHierarchicalTransactionService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxHierarchicalTransactionService.prototype.getAggregatedChanges = function (mergeChanges) {
            var _this = this;
            var result = [];
            this._states.forEach(function (state, key) {
                var value = mergeChanges ? _this.mergeValues(state.recordRef, state.value) : cloneValue(state.value);
                _this.clearArraysFromObject(value);
                result.push({ id: key, path: state.path, newValue: value, type: state.type });
            });
            return result;
        };
        IgxHierarchicalTransactionService.prototype.commit = function (data, primaryKeyOrId, childDataKey, id) {
            if (childDataKey !== undefined) {
                var transactions = this.getAggregatedChanges(true);
                if (id !== undefined) {
                    transactions = transactions.filter(function (t) { return t.id === id; });
                }
                DataUtil.mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKeyOrId, true);
                this.clear(id);
            }
            else {
                _super.prototype.commit.call(this, data, primaryKeyOrId);
            }
        };
        IgxHierarchicalTransactionService.prototype.updateState = function (states, transaction, recordRef) {
            _super.prototype.updateState.call(this, states, transaction, recordRef);
            //  if transaction has no path, e.g. flat data source, get out
            if (!transaction.path) {
                return;
            }
            var currentState = states.get(transaction.id);
            if (currentState) {
                currentState.path = transaction.path;
            }
            //  if transaction has path, Hierarchical data source, and it is DELETE
            //  type transaction for all child rows remove ADD states and update
            //  transaction type and value of UPDATE states
            if (transaction.type === exports.TransactionType.DELETE) {
                states.forEach(function (v, k) {
                    if (v.path && v.path.indexOf(transaction.id) !== -1) {
                        switch (v.type) {
                            case exports.TransactionType.ADD:
                                states.delete(k);
                                break;
                            case exports.TransactionType.UPDATE:
                                states.get(k).type = exports.TransactionType.DELETE;
                                states.get(k).value = null;
                        }
                    }
                });
            }
        };
        //  TODO: remove this method. Force cloning to strip child arrays when needed instead
        IgxHierarchicalTransactionService.prototype.clearArraysFromObject = function (obj) {
            var e_1, _a;
            if (obj) {
                try {
                    for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var prop = _c.value;
                        if (Array.isArray(obj[prop])) {
                            delete obj[prop];
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        };
        return IgxHierarchicalTransactionService;
    }(IgxTransactionService));
    IgxHierarchicalTransactionService.decorators = [
        { type: i0.Injectable }
    ];

    // Export services

    var IgxToggleDirective = /** @class */ (function () {
        /**
         * @hidden
         */
        function IgxToggleDirective(elementRef, cdr, overlayService, navigationService) {
            var _this = this;
            this.elementRef = elementRef;
            this.cdr = cdr;
            this.overlayService = overlayService;
            this.navigationService = navigationService;
            /**
             * Emits an event after the toggle container is opened.
             *
             * ```typescript
             * onToggleOpened(event) {
             *    alert("Toggle opened!");
             * }
             * ```
             *
             * ```html
             * <div
             *   igxToggle
             *   (onOpened)='onToggleOpened($event)'>
             * </div>
             * ```
             */
            this.onOpened = new i0.EventEmitter();
            /**
             * Emits an event before the toggle container is opened.
             *
             * ```typescript
             * onToggleOpening(event) {
             *  alert("Toggle opening!");
             * }
             * ```
             *
             * ```html
             * <div
             *   igxToggle
             *   (onOpening)='onToggleOpening($event)'>
             * </div>
             * ```
             */
            this.onOpening = new i0.EventEmitter();
            /**
             * Emits an event after the toggle container is closed.
             *
             * ```typescript
             * onToggleClosed(event) {
             *  alert("Toggle closed!");
             * }
             * ```
             *
             * ```html
             * <div
             *   igxToggle
             *   (onClosed)='onToggleClosed($event)'>
             * </div>
             * ```
             */
            this.onClosed = new i0.EventEmitter();
            /**
             * Emits an event before the toggle container is closed.
             *
             * ```typescript
             * onToggleClosing(event) {
             *  alert("Toggle closing!");
             * }
             * ```
             *
             * ```html
             * <div
             *  igxToggle
             *  (onClosing)='onToggleClosing($event)'>
             * </div>
             * ```
             */
            this.onClosing = new i0.EventEmitter();
            /**
             * Emits an event after the toggle element is appended to the overlay container.
             *
             * ```typescript
             * onAppended() {
             *  alert("Content appended!");
             * }
             * ```
             *
             * ```html
             * <div
             *   igxToggle
             *   (onAppended)='onToggleAppended()'>
             * </div>
             * ```
             */
            this.onAppended = new i0.EventEmitter();
            this._collapsed = true;
            this.destroy$ = new rxjs.Subject();
            this._overlaySubFilter = [
                operators.filter(function (x) { return x.id === _this._overlayId; }),
                operators.takeUntil(this.destroy$)
            ];
            this.overlayClosed = function (ev) {
                _this._collapsed = true;
                _this.cdr.detectChanges();
                delete _this._overlayId;
                _this.unsubscribe();
                var closedEventArgs = { owner: _this, id: _this._overlayId, event: ev.event };
                _this.onClosed.emit(closedEventArgs);
            };
        }
        Object.defineProperty(IgxToggleDirective.prototype, "collapsed", {
            /**
             * @hidden
             */
            get: function () {
                return this._collapsed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxToggleDirective.prototype, "element", {
            /**
             * @hidden
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxToggleDirective.prototype, "hiddenClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.collapsed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxToggleDirective.prototype, "defaultClass", {
            /**
             * @hidden
             */
            get: function () {
                return !this.collapsed;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Opens the toggle.
         *
         * ```typescript
         * this.myToggle.open();
         * ```
         */
        IgxToggleDirective.prototype.open = function (overlaySettings) {
            var _a, _b, _c, _d;
            var _this = this;
            //  if there is open animation do nothing
            //  if toggle is not collapsed and there is no close animation do nothing
            var info = this.overlayService.getOverlayById(this._overlayId);
            var hasOpenAnimation = info ? info.openAnimationPlayer : false;
            var hasCloseAnimation = info ? info.closeAnimationPlayer : false;
            if (hasOpenAnimation || !(this._collapsed || hasCloseAnimation)) {
                return;
            }
            if (!info) {
                this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);
            }
            var openEventArgs = { cancel: false, owner: this, id: this._overlayId };
            this.onOpening.emit(openEventArgs);
            if (openEventArgs.cancel) {
                return;
            }
            this._collapsed = false;
            this.cdr.detectChanges();
            this.unsubscribe();
            this._overlayAppendedSub = (_a = this.overlayService.onAppended).pipe.apply(_a, __spread(this._overlaySubFilter)).subscribe(function () {
                var appendedEventArgs = { owner: _this, id: _this._overlayId };
                _this.onAppended.emit(appendedEventArgs);
            });
            this._overlayOpenedSub = (_b = this.overlayService.onOpened).pipe.apply(_b, __spread(this._overlaySubFilter)).subscribe(function () {
                var openedEventArgs = { owner: _this, id: _this._overlayId };
                _this.onOpened.emit(openedEventArgs);
            });
            this._overlayClosingSub = (_c = this.overlayService
                .onClosing)
                .pipe.apply(_c, __spread(this._overlaySubFilter)).subscribe(function (e) {
                var eventArgs = { cancel: false, event: e.event, owner: _this, id: _this._overlayId };
                _this.onClosing.emit(eventArgs);
                e.cancel = eventArgs.cancel;
                //  in case event is not canceled this will close the toggle and we need to unsubscribe.
                //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
                //  onClosed was fired we will end with calling onClosing more than once
                if (!e.cancel) {
                    _this.clearSubscription(_this._overlayClosingSub);
                }
            });
            this._overlayClosedSub = (_d = this.overlayService.onClosed)
                .pipe.apply(_d, __spread(this._overlaySubFilter)).subscribe(this.overlayClosed);
            this.overlayService.show(this._overlayId, overlaySettings);
        };
        /**
         * Closes the toggle.
         *
         * ```typescript
         * this.myToggle.close();
         * ```
         */
        IgxToggleDirective.prototype.close = function () {
            //  if toggle is collapsed do nothing
            //  if there is close animation do nothing, toggle will close anyway
            var info = this.overlayService.getOverlayById(this._overlayId);
            var hasCloseAnimation = info ? info.closeAnimationPlayer : false;
            if (this._collapsed || hasCloseAnimation) {
                return;
            }
            this.overlayService.hide(this._overlayId);
        };
        /**
         * Opens or closes the toggle, depending on its current state.
         *
         * ```typescript
         * this.myToggle.toggle();
         * ```
         */
        IgxToggleDirective.prototype.toggle = function (overlaySettings) {
            //  if toggle is collapsed call open
            //  if there is close animation call open
            if (this.collapsed || this.isClosing) {
                this.open(overlaySettings);
            }
            else {
                this.close();
            }
        };
        Object.defineProperty(IgxToggleDirective.prototype, "isClosing", {
            /** @hidden @internal */
            get: function () {
                var info = this.overlayService.getOverlayById(this._overlayId);
                return info ? info.closeAnimationPlayer : false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxToggleDirective.prototype, "overlayId", {
            /**
             * Returns the id of the overlay the content is rendered in.
             * ```typescript
             * this.myToggle.overlayId;
             * ```
             */
            get: function () {
                return this._overlayId;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Repositions the toggle.
         * ```typescript
         * this.myToggle.reposition();
         * ```
         */
        IgxToggleDirective.prototype.reposition = function () {
            this.overlayService.reposition(this._overlayId);
        };
        /**
         * Offsets the content along the corresponding axis by the provided amount
         */
        IgxToggleDirective.prototype.setOffset = function (deltaX, deltaY) {
            this.overlayService.setOffset(this._overlayId, deltaX, deltaY);
        };
        /**
         * @hidden
         */
        IgxToggleDirective.prototype.ngOnInit = function () {
            if (this.navigationService && this.id) {
                this.navigationService.add(this.id, this);
            }
        };
        /**
         * @hidden
         */
        IgxToggleDirective.prototype.ngOnDestroy = function () {
            if (this.navigationService && this.id) {
                this.navigationService.remove(this.id);
            }
            if (!this.collapsed && this._overlayId) {
                this.overlayService.hide(this._overlayId);
            }
            this.unsubscribe();
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        IgxToggleDirective.prototype.unsubscribe = function () {
            this.clearSubscription(this._overlayOpenedSub);
            this.clearSubscription(this._overlayClosingSub);
            this.clearSubscription(this._overlayClosedSub);
            this.clearSubscription(this._overlayAppendedSub);
        };
        IgxToggleDirective.prototype.clearSubscription = function (subscription) {
            if (subscription && !subscription.closed) {
                subscription.unsubscribe();
            }
        };
        return IgxToggleDirective;
    }());
    IgxToggleDirective.decorators = [
        { type: i0.Directive, args: [{
                    exportAs: 'toggle',
                    selector: '[igxToggle]'
                },] }
    ];
    IgxToggleDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: IgxOverlayService, decorators: [{ type: i0.Inject, args: [IgxOverlayService,] }] },
        { type: IgxNavigationService, decorators: [{ type: i0.Optional }] }
    ]; };
    IgxToggleDirective.propDecorators = {
        onOpened: [{ type: i0.Output }],
        onOpening: [{ type: i0.Output }],
        onClosed: [{ type: i0.Output }],
        onClosing: [{ type: i0.Output }],
        onAppended: [{ type: i0.Output }],
        id: [{ type: i0.Input }],
        hiddenClass: [{ type: i0.HostBinding, args: ['class.igx-toggle--hidden',] }, { type: i0.HostBinding, args: ['attr.aria-hidden',] }],
        defaultClass: [{ type: i0.HostBinding, args: ['class.igx-toggle',] }]
    };
    var IgxToggleActionDirective = /** @class */ (function () {
        function IgxToggleActionDirective(element, navigationService) {
            this.element = element;
            this.navigationService = navigationService;
        }
        Object.defineProperty(IgxToggleActionDirective.prototype, "target", {
            /**
             * @hidden
             */
            get: function () {
                if (typeof this._target === 'string') {
                    return this.navigationService.get(this._target);
                }
                return this._target;
            },
            /**
             * @hidden
             */
            set: function (target) {
                if (target !== null && target !== '') {
                    this._target = target;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxToggleActionDirective.prototype.onClick = function () {
            if (this.outlet) {
                this._overlayDefaults.outlet = this.outlet;
            }
            var clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);
            this.updateOverlaySettings(clonedSettings);
            this.target.toggle(clonedSettings);
        };
        /**
         * @hidden
         */
        IgxToggleActionDirective.prototype.ngOnInit = function () {
            var targetElement = this.element.nativeElement;
            this._overlayDefaults = {
                target: targetElement,
                positionStrategy: new ConnectedPositioningStrategy(),
                scrollStrategy: new AbsoluteScrollStrategy(),
                closeOnOutsideClick: true,
                modal: false,
                excludeFromOutsideClick: [targetElement]
            };
        };
        /**
         * Updates provided overlay settings
         *
         * @param settings settings to update
         * @returns returns updated copy of provided overlay settings
         */
        IgxToggleActionDirective.prototype.updateOverlaySettings = function (settings) {
            if (settings && settings.positionStrategy) {
                var positionStrategyClone = settings.positionStrategy.clone();
                settings.target = this.element.nativeElement;
                settings.positionStrategy = positionStrategyClone;
            }
            return settings;
        };
        return IgxToggleActionDirective;
    }());
    IgxToggleActionDirective.decorators = [
        { type: i0.Directive, args: [{
                    exportAs: 'toggle-action',
                    selector: '[igxToggleAction]'
                },] }
    ];
    IgxToggleActionDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: IgxNavigationService, decorators: [{ type: i0.Optional }] }
    ]; };
    IgxToggleActionDirective.propDecorators = {
        overlaySettings: [{ type: i0.Input }],
        outlet: [{ type: i0.Input, args: ['igxToggleOutlet',] }],
        target: [{ type: i0.Input, args: ['igxToggleAction',] }],
        onClick: [{ type: i0.HostListener, args: ['click',] }]
    };
    /**
     * Mark an element as an igxOverlay outlet container.
     * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
     * ```html
     * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
     * ```
     */
    var IgxOverlayOutletDirective = /** @class */ (function () {
        function IgxOverlayOutletDirective(element) {
            this.element = element;
        }
        Object.defineProperty(IgxOverlayOutletDirective.prototype, "nativeElement", {
            /** @hidden */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        return IgxOverlayOutletDirective;
    }());
    IgxOverlayOutletDirective.decorators = [
        { type: i0.Directive, args: [{
                    exportAs: 'overlay-outlet',
                    selector: '[igxOverlayOutlet]'
                },] }
    ];
    IgxOverlayOutletDirective.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    /**
     * @hidden
     */
    var IgxToggleModule = /** @class */ (function () {
        function IgxToggleModule() {
        }
        return IgxToggleModule;
    }());
    IgxToggleModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                    exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                    providers: [IgxNavigationService]
                },] }
    ];

    /** @hidden */
    var Navigate;
    (function (Navigate) {
        Navigate[Navigate["Up"] = -1] = "Up";
        Navigate[Navigate["Down"] = 1] = "Down";
    })(Navigate || (Navigate = {}));
    /** Key actions that have designated handlers in IgxDropDownComponent */
    var DropDownActionKey = mkenum({
        ESCAPE: 'escape',
        ENTER: 'enter',
        SPACE: 'space'
    });
    var IGX_DROPDOWN_BASE = new i0.InjectionToken('IgxDropDownBaseToken');

    /** @hidden */
    var IgxSelectionAPIService = /** @class */ (function () {
        function IgxSelectionAPIService() {
            /**
             * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.
             * If the primaryKey is omitted, then selection is based on the item data
             */
            this.selection = new Map();
        }
        /**
         * Get current component selection.
         *
         * @param componentID ID of the component.
         */
        IgxSelectionAPIService.prototype.get = function (componentID) {
            return this.selection.get(componentID);
        };
        /**
         * Set new component selection.
         *
         * @param componentID ID of the component.
         * @param newSelection The new component selection to be set.
         */
        IgxSelectionAPIService.prototype.set = function (componentID, newSelection) {
            if (!componentID) {
                throw Error('Invalid value for component id!');
            }
            this.selection.set(componentID, newSelection);
        };
        /**
         * Clears selection for component.
         *
         * @param componentID ID of the component.
         */
        IgxSelectionAPIService.prototype.clear = function (componentID) {
            this.selection.set(componentID, this.get_empty());
        };
        /**
         * Get current component selection length.
         *
         * @param componentID ID of the component.
         */
        IgxSelectionAPIService.prototype.size = function (componentID) {
            var sel = this.get(componentID);
            return sel ? sel.size : 0;
        };
        /**
         * Creates new selection that consist of the new item added to the current component selection.
         * The returned collection is new Set,
         * therefore if you want to update component selection you need to call in addition the set_selection() method
         * or instead use the select_item() one.
         *
         * @param componentID ID of the component, which we add new item to.
         * @param itemID ID of the item to add to component selection.
         * @param sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
         *
         * @returns Selection after the new item is added.
         */
        IgxSelectionAPIService.prototype.add_item = function (componentID, itemID, sel) {
            if (!sel) {
                sel = new Set(this.get(componentID));
            }
            if (sel === undefined) {
                sel = this.get_empty();
            }
            if (!itemID && itemID !== 0) {
                throw Error('Invalid value for item id!');
            }
            sel.add(itemID);
            return sel;
        };
        /**
         * Creates new selection that consist of the new items added to the current component selection.
         * The returned collection is new Set,
         * therefore if you want to update component selection you need to call in addition the set_selection() method
         * or instead use the select_items() one.
         *
         * @param componentID ID of the component, which we add new items to.
         * @param itemIDs Array of IDs of the items to add to component selection.
         * @param clearSelection If true it will clear previous selection.
         *
         * @returns Selection after the new items are added.
         */
        IgxSelectionAPIService.prototype.add_items = function (componentID, itemIDs, clearSelection) {
            var _this = this;
            var selection;
            if (clearSelection) {
                selection = this.get_empty();
            }
            else if (itemIDs && itemIDs.length === 0) {
                selection = new Set(this.get(componentID));
            }
            itemIDs.forEach(function (item) { return selection = _this.add_item(componentID, item, selection); });
            return selection;
        };
        /**
         * Add item to the current component selection.
         *
         * @param componentID ID of the component, which we add new item to.
         * @param itemID ID of the item to add to component selection.
         * @param sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
         */
        IgxSelectionAPIService.prototype.select_item = function (componentID, itemID, sel) {
            this.set(componentID, this.add_item(componentID, itemID, sel));
        };
        /**
         * Add items to the current component selection.
         *
         * @param componentID ID of the component, which we add new items to.
         * @param itemIDs Array of IDs of the items to add to component selection.
         * @param clearSelection If true it will clear previous selection.
         */
        IgxSelectionAPIService.prototype.select_items = function (componentID, itemID, clearSelection) {
            this.set(componentID, this.add_items(componentID, itemID, clearSelection));
        };
        /**
         * Creates new selection that consist of the new items excluded from the current component selection.
         * The returned collection is new Set,
         * therefore if you want to update component selection you need to call in addition the set_selection() method
         * or instead use the deselect_item() one.
         *
         * @param componentID ID of the component, which we remove items from.
         * @param itemID ID of the item to remove from component selection.
         * @param sel Used internally only by the selection (delete_items method) to accumulate deselected items.
         *
         * @returns Selection after the item is removed.
         */
        IgxSelectionAPIService.prototype.delete_item = function (componentID, itemID, sel) {
            if (!sel) {
                sel = new Set(this.get(componentID));
            }
            if (sel === undefined) {
                return;
            }
            sel.delete(itemID);
            return sel;
        };
        /**
         * Creates new selection that consist of the new items removed to the current component selection.
         * The returned collection is new Set,
         * therefore if you want to update component selection you need to call in addition the set_selection() method
         * or instead use the deselect_items() one.
         *
         * @param componentID ID of the component, which we remove items from.
         * @param itemID ID of the items to remove from component selection.
         *
         * @returns Selection after the items are removed.
         */
        IgxSelectionAPIService.prototype.delete_items = function (componentID, itemIDs) {
            var _this = this;
            var selection;
            itemIDs.forEach(function (deselectedItem) { return selection = _this.delete_item(componentID, deselectedItem, selection); });
            return selection;
        };
        /**
         * Remove item from the current component selection.
         *
         * @param componentID ID of the component, which we remove item from.
         * @param itemID ID of the item to remove from component selection.
         * @param sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
         */
        IgxSelectionAPIService.prototype.deselect_item = function (componentID, itemID, sel) {
            this.set(componentID, this.delete_item(componentID, itemID, sel));
        };
        /**
         * Remove items to the current component selection.
         *
         * @param componentID ID of the component, which we add new items to.
         * @param itemIDs Array of IDs of the items to add to component selection.
         */
        IgxSelectionAPIService.prototype.deselect_items = function (componentID, itemID, clearSelection) {
            this.set(componentID, this.delete_items(componentID, itemID));
        };
        /**
         * Check if the item is selected in the component selection.
         *
         * @param componentID ID of the component.
         * @param itemID ID of the item to search.
         *
         * @returns If item is selected.
         */
        IgxSelectionAPIService.prototype.is_item_selected = function (componentID, itemID) {
            var sel = this.get(componentID);
            if (!sel) {
                return false;
            }
            return sel.has(itemID);
        };
        /**
         * Get first element in the selection.
         * This is correct when we have only one item in the collection (for single selection purposes)
         * and the method returns that item.
         *
         * @param componentID ID of the component.
         *
         * @returns First element in the set.
         */
        IgxSelectionAPIService.prototype.first_item = function (componentID) {
            var sel = this.get(componentID);
            if (sel && sel.size > 0) {
                return sel.values().next().value;
            }
        };
        /**
         * Returns whether all items are selected.
         *
         * @param componentID ID of the component.
         * @param dataCount: number Number of items in the data.
         *
         * @returns If all items are selected.
         */
        IgxSelectionAPIService.prototype.are_all_selected = function (componentID, dataCount) {
            return dataCount > 0 && dataCount === this.size(componentID);
        };
        /**
         * Returns whether any of the items is selected.
         *
         * @param componentID ID of the component.
         * @param data Entire data array.
         *
         * @returns If there is any item selected.
         */
        IgxSelectionAPIService.prototype.are_none_selected = function (componentID) {
            return this.size(componentID) === 0;
        };
        /**
         * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
         *
         * @param data Entire data array.
         * @param primaryKey Data primary key.
         *
         * @returns Array of identifiers, either primary key values or the entire data array.
         */
        IgxSelectionAPIService.prototype.get_all_ids = function (data, primaryKey) {
            // If primaryKey is 0, this should still map to the property
            return primaryKey !== undefined && primaryKey !== null ? data.map(function (x) { return x[primaryKey]; }) : data;
        };
        /**
         * Returns empty selection collection.
         *
         * @returns empty set.
         */
        IgxSelectionAPIService.prototype.get_empty = function () {
            return new Set();
        };
        return IgxSelectionAPIService;
    }());
    IgxSelectionAPIService.ɵprov = i0.ɵɵdefineInjectable({ factory: function IgxSelectionAPIService_Factory() { return new IgxSelectionAPIService(); }, token: IgxSelectionAPIService, providedIn: "root" });
    IgxSelectionAPIService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    var NEXT_ID = 0;
    /**
     * The `<igx-drop-down-item>` is a container intended for row items in
     * a `<igx-drop-down>` container.
     */
    var IgxDropDownGroupComponent = /** @class */ (function () {
        function IgxDropDownGroupComponent() {
            /**
             * @hidden @internal
             */
            this.role = 'group';
            /** @hidden @internal */
            this.groupClass = true;
            /**
             * Sets/gets if the item group is disabled
             *
             * ```typescript
             * const myDropDownGroup: IgxDropDownGroupComponent = this.dropdownGroup;
             * // get
             * ...
             * const groupState: boolean = myDropDownGroup.disabled;
             * ...
             * //set
             * ...
             * myDropDownGroup,disabled = false;
             * ...
             * ```
             *
             * ```html
             * <igx-drop-down-item-group [label]="'My Items'" [disabled]="true">
             *     <igx-drop-down-item *ngFor="let item of items[index]" [value]="item.value">
             *         {{ item.text }}
             *     </igx-drop-down-item>
             * </igx-drop-down-item-group>
             * ```
             *
             * **NOTE:** All items inside of a disabled drop down group will be treated as disabled
             */
            this.disabled = false;
            this._id = NEXT_ID++;
        }
        Object.defineProperty(IgxDropDownGroupComponent.prototype, "labelId", {
            /**
             * @hidden @internal
             */
            get: function () {
                return "igx-item-group-label-" + this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownGroupComponent.prototype, "labelledBy", {
            get: function () {
                return this.labelId;
            },
            enumerable: false,
            configurable: true
        });
        return IgxDropDownGroupComponent;
    }());
    IgxDropDownGroupComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-drop-down-item-group',
                    template: "\n        <label id=\"{{labelId}}\">{{ label }}</label>\n        <ng-content select=\"igx-drop-down-item\"></ng-content>\n    "
                },] }
    ];
    IgxDropDownGroupComponent.propDecorators = {
        labelledBy: [{ type: i0.HostBinding, args: ["attr.aria-labelledby",] }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        groupClass: [{ type: i0.HostBinding, args: ['class.igx-drop-down__group',] }],
        disabled: [{ type: i0.Input }, { type: i0.HostBinding, args: ["attr.aria-disabled",] }, { type: i0.HostBinding, args: ['class.igx-drop-down__group--disabled',] }],
        label: [{ type: i0.Input }]
    };

    var NEXT_ID$1 = 0;
    var warningShown$1 = false;
    /**
     * An abstract class defining a drop-down item:
     * With properties / styles for selection, highlight, height
     * Bindable property for passing data (`value: any`)
     * Parent component (has to be used under a parent with type `IDropDownBase`)
     * Method for handling click on Host()
     */
    var IgxDropDownItemBaseDirective = /** @class */ (function () {
        function IgxDropDownItemBaseDirective(dropDown, elementRef, group, selection) {
            this.dropDown = dropDown;
            this.elementRef = elementRef;
            this.group = group;
            this.selection = selection;
            /**
             * Sets/gets the `id` of the item.
             * ```html
             * <igx-drop-down-item [id] = 'igx-drop-down-item-0'></igx-drop-down-item>
             * ```
             * ```typescript
             * let itemId =  this.item.id;
             * ```
             *
             * @memberof IgxSelectItemComponent
             */
            this.id = "igx-drop-down-item-" + NEXT_ID$1++;
            /**
             * @hidden
             */
            this.selectedChange = new i0.EventEmitter();
            /**
             * Gets/sets the `role` attribute of the item. Default is 'option'.
             *
             * ```html
             *  <igx-drop-down-item [role]="customRole"></igx-drop-down-item>
             * ```
             */
            this.role = 'option';
            /**
             * @hidden
             */
            this._focused = false;
            this._selected = false;
            this._index = null;
            this._disabled = false;
        }
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "itemID", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "index", {
            /**
             * The data index of the dropdown item.
             *
             * ```typescript
             * // get the data index of the selected dropdown item
             * let selectedItemIndex = this.dropdown.selectedItem.index
             * ```
             */
            get: function () {
                if (this._index === null) {
                    warningShown$1 = showMessage('IgxDropDownItemBaseDirective: Automatic index is deprecated.' +
                        'Bind in the template instead using `<igx-drop-down-item [index]="i"` instead.`', warningShown$1);
                    return this.itemIndex;
                }
                return this._index;
            },
            set: function (value) {
                this._index = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "itemStyle", {
            /**
             * @hidden @internal
             */
            get: function () {
                return !this.isHeader;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "itemStyleCosy", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.dropDown.displayDensity === 'cosy' && !this.isHeader;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "itemStyleCompact", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.dropDown.displayDensity === 'compact' && !this.isHeader;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "selected", {
            /**
             * Sets/Gets if the item is the currently selected one in the dropdown
             *
             * ```typescript
             *  let mySelectedItem = this.dropdown.selectedItem;
             *  let isMyItemSelected = mySelectedItem.selected; // true
             * ```
             *
             * Two-way data binding
             * ```html
             * <igx-drop-down-item [(selected)]='model.isSelected'></igx-drop-down-item>
             * ```
             */
            get: function () {
                return this._selected;
            },
            set: function (value) {
                if (this.isHeader) {
                    return;
                }
                this._selected = value;
                this.selectedChange.emit(this._selected);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "focused", {
            /**
             * Sets/gets if the given item is focused
             * ```typescript
             *  let mySelectedItem = this.dropdown.selectedItem;
             *  let isMyItemFocused = mySelectedItem.focused;
             * ```
             */
            get: function () {
                return this.isSelectable && this._focused;
            },
            /**
             * ```html
             *  <igx-drop-down-item *ngFor="let item of items" focused={{!item.focused}}>
             *      <div>
             *          {{item.field}}
             *      </div>
             *  </igx-drop-down-item>
             * ```
             */
            set: function (value) {
                this._focused = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "headerClassCosy", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.isHeader && this.dropDown.displayDensity === 'cosy';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "headerClassCompact", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.isHeader && this.dropDown.displayDensity === 'compact';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "disabled", {
            /**
             * Sets/gets if the given item is disabled
             *
             * ```typescript
             *  // get
             *  let mySelectedItem = this.dropdown.selectedItem;
             *  let myItemIsDisabled = mySelectedItem.disabled;
             * ```
             *
             * ```html
             *  <igx-drop-down-item *ngFor="let item of items" disabled={{!item.disabled}}>
             *      <div>
             *          {{item.field}}
             *      </div>
             *  </igx-drop-down-item>
             * ```
             * **NOTE:** Drop-down items inside of a disabled `IgxDropDownGroup` will always count as disabled
             */
            get: function () {
                return this.group ? this.group.disabled || this._disabled : this._disabled;
            },
            set: function (value) {
                this._disabled = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "itemIndex", {
            /**
             * Gets item index
             *
             * @hidden @internal
             */
            get: function () {
                return this.dropDown.items.indexOf(this);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "elementHeight", {
            /**
             * Gets item element height
             *
             * @hidden @internal
             */
            get: function () {
                return this.elementRef.nativeElement.clientHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "element", {
            /**
             * Get item html element
             *
             * @hidden @internal
             */
            get: function () {
                return this.elementRef;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "hasIndex", {
            get: function () {
                return this._index !== null && this._index !== undefined;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxDropDownItemBaseDirective.prototype.clicked = function (event) {
        };
        IgxDropDownItemBaseDirective.prototype.ngDoCheck = function () {
            if (this._selected) {
                var dropDownSelectedItem = this.dropDown.selectedItem;
                if (!dropDownSelectedItem) {
                    this.dropDown.selectItem(this);
                }
                else if (this.hasIndex
                    ? this._index !== dropDownSelectedItem.index || this.value !== dropDownSelectedItem.value :
                    this !== dropDownSelectedItem) {
                    this.dropDown.selectItem(this);
                }
            }
        };
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "isSelectable", {
            /** Returns true if the items is not a header or disabled  */
            get: function () {
                return !(this.disabled || this.isHeader);
            },
            enumerable: false,
            configurable: true
        });
        /** If `allowItemsFocus` is enabled, keep the browser focus on the active item */
        IgxDropDownItemBaseDirective.prototype.ensureItemFocus = function () {
            if (this.dropDown.allowItemsFocus) {
                var focusedItem = this.dropDown.items.find(function (item) { return item.focused; });
                if (!focusedItem) {
                    return;
                }
                focusedItem.element.nativeElement.focus({ preventScroll: true });
            }
        };
        return IgxDropDownItemBaseDirective;
    }());
    IgxDropDownItemBaseDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDropDownItemBase]'
                },] }
    ];
    IgxDropDownItemBaseDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_DROPDOWN_BASE,] }] },
        { type: i0.ElementRef },
        { type: IgxDropDownGroupComponent, decorators: [{ type: i0.Optional }] },
        { type: IgxSelectionAPIService, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [IgxSelectionAPIService,] }] }
    ]; };
    IgxDropDownItemBaseDirective.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        index: [{ type: i0.Input }],
        value: [{ type: i0.Input }],
        itemStyle: [{ type: i0.HostBinding, args: ['class.igx-drop-down__item',] }],
        itemStyleCosy: [{ type: i0.HostBinding, args: ['class.igx-drop-down__item--cosy',] }],
        itemStyleCompact: [{ type: i0.HostBinding, args: ['class.igx-drop-down__item--compact',] }],
        selected: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.aria-selected',] }, { type: i0.HostBinding, args: ['class.igx-drop-down__item--selected',] }],
        selectedChange: [{ type: i0.Output }],
        focused: [{ type: i0.HostBinding, args: ['class.igx-drop-down__item--focused',] }],
        isHeader: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.igx-drop-down__header',] }],
        headerClassCosy: [{ type: i0.HostBinding, args: ['class.igx-drop-down__header--cosy',] }],
        headerClassCompact: [{ type: i0.HostBinding, args: ['class.igx-drop-down__header--compact',] }],
        disabled: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.aria-disabled',] }, { type: i0.HostBinding, args: ['class.igx-drop-down__item--disabled',] }],
        role: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.role',] }],
        clicked: [{ type: i0.HostListener, args: ['click', ['$event'],] }]
    };

    /**
     * The `<igx-drop-down-item>` is a container intended for row items in
     * a `<igx-drop-down>` container.
     */
    var IgxDropDownItemComponent = /** @class */ (function (_super) {
        __extends(IgxDropDownItemComponent, _super);
        function IgxDropDownItemComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IgxDropDownItemComponent.prototype, "focused", {
            /**
             * @inheritdoc
             */
            get: function () {
                var focusedState = this._focused;
                if (this.hasIndex) {
                    var focusedItem = this.selection.first_item(this.dropDown.id + "-active");
                    var focusedIndex = focusedItem ? focusedItem.index : -1;
                    focusedState = this._index === focusedIndex;
                }
                return this.isSelectable && focusedState;
            },
            /**
             * @inheritdoc
             */
            set: function (value) {
                this._focused = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemComponent.prototype, "selected", {
            /**
             * @inheritdoc
             */
            get: function () {
                if (this.hasIndex) {
                    var item = this.selection.first_item("" + this.dropDown.id);
                    return item ? item.index === this._index && item.value === this.value : false;
                }
                return this._selected;
            },
            /**
             * @inheritdoc
             */
            set: function (value) {
                if (this.isHeader) {
                    return;
                }
                this._selected = value;
                this.selectedChange.emit(this._selected);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemComponent.prototype, "setTabIndex", {
            /**
             * @hidden @internal
             */
            get: function () {
                var shouldSetTabIndex = this.dropDown.allowItemsFocus && this.isSelectable;
                if (shouldSetTabIndex) {
                    return 0;
                }
                else {
                    return null;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @inheritdoc
         */
        IgxDropDownItemComponent.prototype.clicked = function (event) {
            if (!this.isSelectable) {
                this.ensureItemFocus();
                return;
            }
            if (this.selection) {
                this.dropDown.selectItem(this, event);
            }
        };
        return IgxDropDownItemComponent;
    }(IgxDropDownItemBaseDirective));
    IgxDropDownItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-drop-down-item',
                    template: "<span class=\"igx-drop-down__content\">\n    <ng-content select=\"igx-prefix, [igxPrefix]\"></ng-content>\n    <span class=\"igx-drop-down__inner\">\n        <ng-content></ng-content>\n    </span>\n    <ng-content select=\"igx-suffix, [igxSuffix]\"></ng-content>\n    <ng-content select=\"igx-divider\"></ng-content>\n</span>\n"
                },] }
    ];
    IgxDropDownItemComponent.propDecorators = {
        setTabIndex: [{ type: i0.HostBinding, args: ['attr.tabindex',] }]
    };

    /**
     * Defines the possible values of the components' display density.
     */
    var DisplayDensity = mkenum({
        comfortable: 'comfortable',
        cosy: 'cosy',
        compact: 'compact'
    });
    /**
     * Defines the DisplayDensity DI token.
     */
    var DisplayDensityToken = new i0.InjectionToken('DisplayDensity');
    /**
     * Base class containing all logic required for implementing DisplayDensity.
     */
    // eslint-disable-next-line @angular-eslint/directive-class-suffix
    var DisplayDensityBase = /** @class */ (function () {
        function DisplayDensityBase(displayDensityOptions) {
            this.displayDensityOptions = displayDensityOptions;
            this.onDensityChanged = new i0.EventEmitter();
            this.oldDisplayDensityOptions = { displayDensity: DisplayDensity.comfortable };
            Object.assign(this.oldDisplayDensityOptions, displayDensityOptions);
        }
        Object.defineProperty(DisplayDensityBase.prototype, "displayDensity", {
            /**
             * Returns the theme of the component.
             * The default theme is `comfortable`.
             * Available options are `comfortable`, `cosy`, `compact`.
             * ```typescript
             * let componentTheme = this.component.displayDensity;
             * ```
             */
            get: function () {
                return this._displayDensity ||
                    ((this.displayDensityOptions && this.displayDensityOptions.displayDensity) || DisplayDensity.comfortable);
            },
            /**
             * Sets the theme of the component.
             */
            set: function (val) {
                var currentDisplayDensity = this._displayDensity;
                this._displayDensity = val;
                if (currentDisplayDensity !== this._displayDensity) {
                    var densityChangedArgs = {
                        oldDensity: currentDisplayDensity,
                        newDensity: this._displayDensity
                    };
                    this.onDensityChanged.emit(densityChangedArgs);
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        DisplayDensityBase.prototype.ngOnInit = function () {
            this.initialDensity = this._displayDensity;
        };
        DisplayDensityBase.prototype.ngDoCheck = function () {
            if (!this._displayDensity && this.displayDensityOptions &&
                this.oldDisplayDensityOptions.displayDensity !== this.displayDensityOptions.displayDensity) {
                var densityChangedArgs = {
                    oldDensity: this.oldDisplayDensityOptions.displayDensity,
                    newDensity: this.displayDensityOptions.displayDensity
                };
                this.onDensityChanged.emit(densityChangedArgs);
                this.oldDisplayDensityOptions = Object.assign(this.oldDisplayDensityOptions, this.displayDensityOptions);
            }
        };
        /**
         * Given a style class of a component/element returns the modified version of it based
         * on the current display density.
         */
        DisplayDensityBase.prototype.getComponentDensityClass = function (baseStyleClass) {
            switch (this.displayDensity) {
                case DisplayDensity.cosy:
                    return baseStyleClass + "--" + DisplayDensity.cosy;
                case DisplayDensity.compact:
                    return baseStyleClass + "--" + DisplayDensity.compact;
                default:
                    return baseStyleClass;
            }
        };
        return DisplayDensityBase;
    }());
    DisplayDensityBase.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDisplayDensityBase]'
                },] }
    ];
    DisplayDensityBase.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] }
    ]; };
    DisplayDensityBase.propDecorators = {
        onDensityChanged: [{ type: i0.Output }],
        displayDensity: [{ type: i0.Input }]
    };
    var IgxDisplayDensityModule = /** @class */ (function () {
        function IgxDisplayDensityModule() {
        }
        return IgxDisplayDensityModule;
    }());
    IgxDisplayDensityModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        DisplayDensityBase
                    ],
                    exports: [
                        DisplayDensityBase
                    ]
                },] }
    ];

    var NEXT_ID$2 = 0;
    /**
     * An abstract class, defining a drop-down component, with:
     * Properties for display styles and classes
     * A collection items of type `IgxDropDownItemBaseDirective`
     * Properties and methods for navigating (highlighting/focusing) items from the collection
     * Properties and methods for selecting items from the collection
     */
    var IgxDropDownBaseDirective = /** @class */ (function (_super) {
        __extends(IgxDropDownBaseDirective, _super);
        function IgxDropDownBaseDirective(elementRef, cdr, _displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            _this._displayDensityOptions = _displayDensityOptions;
            /**
             * Emitted when item selection is changing, before the selection completes
             *
             * ```html
             * <igx-drop-down (onSelection)='handleSelection()'></igx-drop-down>
             * ```
             */
            _this.onSelection = new i0.EventEmitter();
            /**
             * Gets/Sets the drop down's container max height.
             *
             * ```typescript
             * // get
             * let maxHeight = this.dropdown.maxHeight;
             * ```
             * ```html
             * <!--set-->
             * <igx-drop-down [maxHeight]='200px'></igx-drop-down>
             * ```
             */
            _this.maxHeight = null;
            /**
             * @hidden @internal
             */
            _this.cssClass = true;
            _this._focusedItem = null;
            _this._id = "igx-drop-down-" + NEXT_ID$2++;
            return _this;
        }
        Object.defineProperty(IgxDropDownBaseDirective.prototype, "id", {
            /**
             * Gets/Sets the drop down's id
             *
             * ```typescript
             * // get
             * let myDropDownCurrentId = this.dropdown.id;
             * ```
             * ```html
             * <!--set-->
             * <igx-drop-down [id]='newDropDownId'></igx-drop-down>
             * ```
             */
            get: function () {
                return this._id;
            },
            set: function (value) {
                this._id = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownBaseDirective.prototype, "items", {
            /**
             * Get all non-header items
             *
             * ```typescript
             * let myDropDownItems = this.dropdown.items;
             * ```
             */
            get: function () {
                var e_1, _a;
                var items = [];
                if (this.children !== undefined) {
                    try {
                        for (var _b = __values(this.children.toArray()), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var child = _c.value;
                            if (!child.isHeader) {
                                items.push(child);
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                return items;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownBaseDirective.prototype, "headers", {
            /**
             * Get all header items
             *
             * ```typescript
             * let myDropDownHeaderItems = this.dropdown.headers;
             * ```
             */
            get: function () {
                var e_2, _a;
                var headers = [];
                if (this.children !== undefined) {
                    try {
                        for (var _b = __values(this.children.toArray()), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var child = _c.value;
                            if (child.isHeader) {
                                headers.push(child);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                return headers;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownBaseDirective.prototype, "element", {
            /**
             * Get dropdown html element
             *
             * ```typescript
             * let myDropDownElement = this.dropdown.element;
             * ```
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownBaseDirective.prototype, "scrollContainer", {
            /**
             * @hidden @internal
             * Get dropdown's html element of its scroll container
             */
            get: function () {
                return this.element;
            },
            enumerable: false,
            configurable: true
        });
        /** Keydown Handler */
        IgxDropDownBaseDirective.prototype.onItemActionKey = function (key, event) {
            switch (key) {
                case DropDownActionKey.ENTER:
                case DropDownActionKey.SPACE:
                    this.selectItem(this.focusedItem, event);
                    break;
                case DropDownActionKey.ESCAPE:
            }
        };
        /**
         * Emits onSelection with the target item & event
         *
         * @hidden @internal
         * @param newSelection the item selected
         * @param event the event that triggered the call
         */
        IgxDropDownBaseDirective.prototype.selectItem = function (newSelection, event) {
            this.onSelection.emit({
                newSelection: newSelection,
                oldSelection: null,
                cancel: false
            });
        };
        Object.defineProperty(IgxDropDownBaseDirective.prototype, "focusedItem", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._focusedItem;
            },
            /**
             * @hidden @internal
             */
            set: function (item) {
                this._focusedItem = item;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Navigates to the item on the specified index
         *
         * @param newIndex number - the index of the item in the `items` collection
         */
        IgxDropDownBaseDirective.prototype.navigateItem = function (newIndex) {
            if (newIndex !== -1) {
                var oldItem = this._focusedItem;
                var newItem = this.items[newIndex];
                if (oldItem) {
                    oldItem.focused = false;
                }
                this.focusedItem = newItem;
                this.scrollToHiddenItem(newItem);
                this.focusedItem.focused = true;
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownBaseDirective.prototype.navigateFirst = function () {
            this.navigate(Navigate.Down, -1);
        };
        /**
         * @hidden @internal
         */
        IgxDropDownBaseDirective.prototype.navigateLast = function () {
            this.navigate(Navigate.Up, this.items.length);
        };
        /**
         * @hidden @internal
         */
        IgxDropDownBaseDirective.prototype.navigateNext = function () {
            this.navigate(Navigate.Down);
        };
        /**
         * @hidden @internal
         */
        IgxDropDownBaseDirective.prototype.navigatePrev = function () {
            this.navigate(Navigate.Up);
        };
        IgxDropDownBaseDirective.prototype.scrollToHiddenItem = function (newItem) {
            var elementRect = newItem.element.nativeElement.getBoundingClientRect();
            var parentRect = this.scrollContainer.getBoundingClientRect();
            if (parentRect.top > elementRect.top) {
                this.scrollContainer.scrollTop -= (parentRect.top - elementRect.top);
            }
            if (parentRect.bottom < elementRect.bottom) {
                this.scrollContainer.scrollTop += (elementRect.bottom - parentRect.bottom);
            }
        };
        IgxDropDownBaseDirective.prototype.navigate = function (direction, currentIndex) {
            var index = -1;
            if (this._focusedItem) {
                index = currentIndex ? currentIndex : this.focusedItem.itemIndex;
            }
            var newIndex = this.getNearestSiblingFocusableItemIndex(index, direction);
            this.navigateItem(newIndex);
        };
        IgxDropDownBaseDirective.prototype.getNearestSiblingFocusableItemIndex = function (startIndex, direction) {
            var index = startIndex;
            var items = this.items;
            while (items[index + direction] && items[index + direction].disabled) {
                index += direction;
            }
            index += direction;
            if (index >= 0 && index < items.length) {
                return index;
            }
            else {
                return -1;
            }
        };
        return IgxDropDownBaseDirective;
    }(DisplayDensityBase));
    IgxDropDownBaseDirective.decorators = [
        { type: i0.Directive }
    ];
    IgxDropDownBaseDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxDropDownBaseDirective.propDecorators = {
        onSelection: [{ type: i0.Output }],
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        id: [{ type: i0.Input }],
        maxHeight: [{ type: i0.Input }, { type: i0.HostBinding, args: ['style.maxHeight',] }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-drop-down',] }]
    };

    var DisplayContainerComponent = /** @class */ (function () {
        function DisplayContainerComponent(cdr, _viewContainer) {
            this.cdr = cdr;
            this._viewContainer = _viewContainer;
            this.cssClass = 'igx-display-container';
            this.notVirtual = true;
        }
        return DisplayContainerComponent;
    }());
    DisplayContainerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-display-container',
                    template: "\n        <ng-template\n            #display_container\n            igxScrollInertia\n            [IgxScrollInertiaScrollContainer]=\"scrollContainer\"\n            [IgxScrollInertiaDirection]=\"scrollDirection\">\n        </ng-template>\n    "
                },] }
    ];
    DisplayContainerComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef },
        { type: i0.ViewContainerRef }
    ]; };
    DisplayContainerComponent.propDecorators = {
        _vcr: [{ type: i0.ViewChild, args: ['display_container', { read: i0.ViewContainerRef, static: true },] }],
        cssClass: [{ type: i0.HostBinding, args: ['class',] }],
        notVirtual: [{ type: i0.HostBinding, args: ['class.igx-display-container--inactive',] }]
    };

    var VirtualHelperBaseDirective = /** @class */ (function () {
        function VirtualHelperBaseDirective(elementRef, cdr, _zone, document, platformUtil) {
            this.elementRef = elementRef;
            this.cdr = cdr;
            this._zone = _zone;
            this.document = document;
            this.platformUtil = platformUtil;
            this.scrollAmount = 0;
            this._size = 0;
            this.destroy$ = new rxjs.Subject();
            this._afterViewInit = false;
            this._detached = false;
            this._scrollNativeSize = this.calculateScrollNativeSize();
        }
        VirtualHelperBaseDirective.prototype.onScroll = function (event) {
            this.scrollAmount = event.target.scrollTop || event.target.scrollLeft;
        };
        VirtualHelperBaseDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            this._afterViewInit = true;
            if (!this.platformUtil.isBrowser) {
                return;
            }
            var delayTime = isIE() ? 40 : 0;
            this._zone.runOutsideAngular(function () {
                resizeObservable(_this.nativeElement).pipe(operators.throttleTime(delayTime), operators.takeUntil(_this.destroy$)).subscribe(function (event) { return _this.handleMutations(event); });
            });
        };
        Object.defineProperty(VirtualHelperBaseDirective.prototype, "nativeElement", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        VirtualHelperBaseDirective.prototype.ngOnDestroy = function () {
            this.destroyed = true;
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        VirtualHelperBaseDirective.prototype.calculateScrollNativeSize = function () {
            var div = this.document.createElement('div');
            var style = div.style;
            style.width = '100px';
            style.height = '100px';
            style.position = 'absolute';
            style.top = '-10000px';
            style.top = '-10000px';
            style.overflow = 'scroll';
            this.document.body.appendChild(div);
            var scrollWidth = div.offsetWidth - div.clientWidth;
            this.document.body.removeChild(div);
            return scrollWidth ? scrollWidth + 1 : 1;
        };
        Object.defineProperty(VirtualHelperBaseDirective.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (value) {
                if (this.destroyed) {
                    return;
                }
                this._size = value;
                if (this._afterViewInit) {
                    this.cdr.detectChanges();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VirtualHelperBaseDirective.prototype, "scrollNativeSize", {
            get: function () {
                return this._scrollNativeSize;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VirtualHelperBaseDirective.prototype, "isAttachedToDom", {
            get: function () {
                return this.document.body.contains(this.nativeElement);
            },
            enumerable: false,
            configurable: true
        });
        VirtualHelperBaseDirective.prototype.handleMutations = function (event) {
            var hasSize = !(event[0].contentRect.height === 0 && event[0].contentRect.width === 0);
            if (!hasSize && !this.isAttachedToDom) {
                // scroll bar detached from DOM
                this._detached = true;
            }
            else if (this._detached && hasSize && this.isAttachedToDom) {
                // attached back now.
                this.restoreScroll();
            }
        };
        VirtualHelperBaseDirective.prototype.restoreScroll = function () { };
        return VirtualHelperBaseDirective;
    }());
    VirtualHelperBaseDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxVirtualHelperBase]'
                },] }
    ];
    VirtualHelperBaseDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: i0.NgZone },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: PlatformUtil }
    ]; };
    VirtualHelperBaseDirective.propDecorators = {
        onScroll: [{ type: i0.HostListener, args: ['scroll', ['$event'],] }]
    };

    /**
     * @hidden
     */
    var HVirtualHelperComponent = /** @class */ (function (_super) {
        __extends(HVirtualHelperComponent, _super);
        function HVirtualHelperComponent(elementRef, cdr, zone, document, platformUtil) {
            var _this = _super.call(this, elementRef, cdr, zone, document, platformUtil) || this;
            _this.cssClasses = 'igx-vhelper--horizontal';
            return _this;
        }
        HVirtualHelperComponent.prototype.restoreScroll = function () {
            this.nativeElement.scrollLeft = this.scrollAmount;
        };
        return HVirtualHelperComponent;
    }(VirtualHelperBaseDirective));
    HVirtualHelperComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-horizontal-virtual-helper',
                    template: '<div #horizontal_container class="igx-vhelper__placeholder-content" [style.width.px]="size"></div>'
                },] }
    ];
    HVirtualHelperComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: i0.NgZone },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: PlatformUtil }
    ]; };
    HVirtualHelperComponent.propDecorators = {
        _vcr: [{ type: i0.ViewChild, args: ['horizontal_container', { read: i0.ViewContainerRef, static: true },] }],
        width: [{ type: i0.Input }],
        cssClasses: [{ type: i0.HostBinding, args: ['class',] }]
    };

    var VirtualHelperComponent = /** @class */ (function (_super) {
        __extends(VirtualHelperComponent, _super);
        function VirtualHelperComponent(elementRef, cdr, zone, document, platformUtil) {
            var _this = _super.call(this, elementRef, cdr, zone, document, platformUtil) || this;
            _this.cssClasses = 'igx-vhelper--vertical';
            return _this;
        }
        VirtualHelperComponent.prototype.ngOnInit = function () {
            this.scrollWidth = this.scrollNativeSize;
        };
        VirtualHelperComponent.prototype.restoreScroll = function () {
            this.nativeElement.scrollTop = this.scrollAmount;
        };
        return VirtualHelperComponent;
    }(VirtualHelperBaseDirective));
    VirtualHelperComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-virtual-helper',
                    template: '<div #container class="igx-vhelper__placeholder-content" [style.height.px]="size"></div>'
                },] }
    ];
    VirtualHelperComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: i0.NgZone },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: PlatformUtil }
    ]; };
    VirtualHelperComponent.propDecorators = {
        scrollTop: [{ type: i0.HostBinding, args: ['scrollTop',] }],
        scrollWidth: [{ type: i0.HostBinding, args: ['style.width.px',] }],
        _vcr: [{ type: i0.ViewChild, args: ['container', { read: i0.ViewContainerRef, static: true },] }],
        itemsLength: [{ type: i0.Input }],
        cssClasses: [{ type: i0.HostBinding, args: ['class',] }]
    };

    /**
     * @hidden
     */
    var IgxScrollInertiaDirective = /** @class */ (function () {
        function IgxScrollInertiaDirective(element, _zone) {
            this.element = element;
            this._zone = _zone;
            this.wheelStep = 50;
            this.inertiaStep = 1.5;
            this.swipeToleranceX = 20;
            this.inertiaDeltaY = 3;
            this.inertiaDeltaX = 2;
            this.inertiaDuration = 0.5;
            this._savedSpeedsX = [];
            this.setPointerCaptureFName = typeof Element.prototype['msSetPointerCapture'] === 'function' ?
                'msSetPointerCapture' :
                'setPointerCapture';
            this.releasePointerCaptureFName = typeof Element.prototype['msReleasePointerCapture'] === 'function' ?
                'msReleasePointerCapture' :
                'releasePointerCapture';
            this.baseDeltaMultiplier = 1 / 120;
            this.firefoxDeltaMultiplier = 1 / 30;
        }
        IgxScrollInertiaDirective.prototype.ngOnInit = function () {
            var _this = this;
            this._zone.runOutsideAngular(function () {
                _this.parentElement = _this.element.nativeElement.parentElement || _this.element.nativeElement.parentNode;
                if (!_this.parentElement) {
                    return;
                }
                var targetElem = _this.parentElement;
                targetElem.addEventListener('wheel', _this.onWheel.bind(_this));
                targetElem.addEventListener('touchstart', _this.onTouchStart.bind(_this));
                targetElem.addEventListener('touchmove', _this.onTouchMove.bind(_this));
                targetElem.addEventListener('touchend', _this.onTouchEnd.bind(_this));
                targetElem.addEventListener('pointerdown', _this.onPointerDown.bind(_this));
                targetElem.addEventListener('pointerup', _this.onPointerUp.bind(_this));
                targetElem.addEventListener('MSGestureStart', _this.onMSGestureStart.bind(_this));
                targetElem.addEventListener('MSGestureChange', _this.onMSGestureChange.bind(_this));
            });
        };
        IgxScrollInertiaDirective.prototype.ngOnDestroy = function () {
            var _this = this;
            this._zone.runOutsideAngular(function () {
                var targetElem = _this.parentElement;
                if (!targetElem) {
                    return;
                }
                targetElem.removeEventListener('wheel', _this.onWheel);
                targetElem.removeEventListener('touchstart', _this.onTouchStart);
                targetElem.removeEventListener('touchmove', _this.onTouchMove);
                targetElem.removeEventListener('touchend', _this.onTouchEnd);
                targetElem.removeEventListener('pointerdown', _this.onPointerDown);
                targetElem.removeEventListener('pointerup', _this.onPointerUp);
                targetElem.removeEventListener('MSGestureStart', _this.onMSGestureStart);
                targetElem.removeEventListener('MSGestureChange', _this.onMSGestureChange);
            });
        };
        /**
         * @hidden
         * Function that is called when scrolling with the mouse wheel or using touchpad
         */
        IgxScrollInertiaDirective.prototype.onWheel = function (evt) {
            // if no scrollbar return
            if (!this.IgxScrollInertiaScrollContainer) {
                return;
            }
            // if ctrl key is pressed and the user want to zoom in/out the page
            if (evt.ctrlKey) {
                return;
            }
            if (evt.shiftKey && isIE()) {
                evt.preventDefault();
            }
            var scrollDeltaX;
            var scrollDeltaY;
            var scrollStep = this.wheelStep;
            var minWheelStep = 1 / this.wheelStep;
            this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
            this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
            if (evt.wheelDeltaX) {
                /* Option supported on Chrome, Safari, Opera.
                /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
                scrollDeltaX = -evt.wheelDeltaX * this.baseDeltaMultiplier;
                if (-minWheelStep < scrollDeltaX && scrollDeltaX < minWheelStep) {
                    scrollDeltaX = Math.sign(scrollDeltaX) * minWheelStep;
                }
            }
            else if (evt.deltaX) {
                /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
                var deltaScaledX = evt.deltaX * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);
                scrollDeltaX = this.calcAxisCoords(deltaScaledX, -1, 1);
            }
            /** Get delta for the Y axis */
            if (evt.wheelDeltaY) {
                /* Option supported on Chrome, Safari, Opera.
                /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
                scrollDeltaY = -evt.wheelDeltaY * this.baseDeltaMultiplier;
                if (-minWheelStep < scrollDeltaY && scrollDeltaY < minWheelStep) {
                    scrollDeltaY = Math.sign(scrollDeltaY) * minWheelStep;
                }
            }
            else if (evt.deltaY) {
                /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
                var deltaScaledY = evt.deltaY * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);
                scrollDeltaY = this.calcAxisCoords(deltaScaledY, -1, 1);
            }
            if (scrollDeltaX && this.IgxScrollInertiaDirection === 'horizontal') {
                this._scrollToX(this._startX + scrollDeltaX * scrollStep);
                var curScrollLeft = this.IgxScrollInertiaScrollContainer.scrollLeft;
                var maxScrollLeft = parseInt(this.IgxScrollInertiaScrollContainer.children[0].style.width, 10);
                if (0 < curScrollLeft && curScrollLeft < maxScrollLeft) {
                    // Prevent navigating through pages when scrolling on Mac
                    evt.preventDefault();
                }
            }
            else if (evt.shiftKey && scrollDeltaY && this.IgxScrollInertiaDirection === 'horizontal') {
                var step = this._startX + scrollDeltaY * scrollStep;
                this._scrollToX(step);
            }
            else if (!evt.shiftKey && scrollDeltaY && this.IgxScrollInertiaDirection === 'vertical') {
                this._scrollToY(this._startY + scrollDeltaY * scrollStep);
                this.preventParentScroll(evt, true);
            }
        };
        /**
         * @hidden
         * When there is still room to scroll up/down prevent the parent elements from scrolling too.
         */
        IgxScrollInertiaDirective.prototype.preventParentScroll = function (evt, preventDefault) {
            var curScrollTop = this.IgxScrollInertiaScrollContainer.scrollTop;
            var maxScrollTop = this.IgxScrollInertiaScrollContainer.children[0].scrollHeight -
                this.IgxScrollInertiaScrollContainer.offsetHeight;
            if (0 < curScrollTop && curScrollTop < maxScrollTop) {
                if (preventDefault) {
                    evt.preventDefault();
                }
                if (evt.stopPropagation) {
                    evt.stopPropagation();
                }
            }
        };
        /**
         * @hidden
         * Function that is called the first moment we start interacting with the content on a touch device
         */
        IgxScrollInertiaDirective.prototype.onTouchStart = function (event) {
            if (typeof MSGesture === 'function' || !this.IgxScrollInertiaScrollContainer) {
                return false;
            }
            // stops any current ongoing inertia
            cancelAnimationFrame(this._touchInertiaAnimID);
            var touch = event.touches[0];
            this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
            this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
            this._touchStartX = touch.pageX;
            this._touchStartY = touch.pageY;
            this._lastTouchEnd = new Date().getTime();
            this._lastTouchX = touch.pageX;
            this._lastTouchY = touch.pageY;
            this._savedSpeedsX = [];
            this._savedSpeedsY = [];
            // Vars regarding swipe offset
            this._totalMovedX = 0;
            this._offsetRecorded = false;
            this._offsetDirection = 0;
            this._touchPrevented = false;
            if (this.IgxScrollInertiaDirection === 'vertical') {
                this.preventParentScroll(event, false);
            }
        };
        /**
         * @hidden
         * Function that is called when we need to scroll the content based on touch interactions
         */
        IgxScrollInertiaDirective.prototype.onTouchMove = function (event) {
            if (typeof MSGesture === 'function') {
                this._touchPrevented = false;
                return false;
            }
            if (!this.IgxScrollInertiaScrollContainer) {
                return;
            }
            var touch = event.touches[0];
            var destX = this._startX + (this._touchStartX - touch.pageX) * Math.sign(this.inertiaStep);
            var destY = this._startY + (this._touchStartY - touch.pageY) * Math.sign(this.inertiaStep);
            /* Handle complex touchmoves when swipe stops but the toch doesn't end and then a swipe is initiated again */
            /* **********************************************************/
            var timeFromLastTouch = (new Date().getTime()) - this._lastTouchEnd;
            if (timeFromLastTouch !== 0 && timeFromLastTouch < 100) {
                var speedX = (this._lastTouchX - touch.pageX) / timeFromLastTouch;
                var speedY = (this._lastTouchY - touch.pageY) / timeFromLastTouch;
                // Save the last 5 speeds between two touchmoves on X axis
                if (this._savedSpeedsX.length < 5) {
                    this._savedSpeedsX.push(speedX);
                }
                else {
                    this._savedSpeedsX.shift();
                    this._savedSpeedsX.push(speedX);
                }
                // Save the last 5 speeds between two touchmoves on Y axis
                if (this._savedSpeedsY.length < 5) {
                    this._savedSpeedsY.push(speedY);
                }
                else {
                    this._savedSpeedsY.shift();
                    this._savedSpeedsY.push(speedY);
                }
            }
            this._lastTouchEnd = new Date().getTime();
            this._lastMovedX = this._lastTouchX - touch.pageX;
            this._lastMovedY = this._lastTouchY - touch.pageY;
            this._lastTouchX = touch.pageX;
            this._lastTouchY = touch.pageY;
            this._totalMovedX += this._lastMovedX;
            var scrolledXY; // Object: {x, y}
            /*	Do not scroll using touch untill out of the swipeToleranceX bounds */
            if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
                scrolledXY = this._scrollTo(this._startX, destY);
            }
            else {
                /*	Record the direction the first time we are out of the swipeToleranceX bounds.
                *	That way we know which direction we apply the offset so it doesn't hickup when moving out of the swipeToleranceX bounds */
                if (!this._offsetRecorded) {
                    this._offsetDirection = Math.sign(destX - this._startX);
                    this._offsetRecorded = true;
                }
                /*	Scroll with offset ammout of swipeToleranceX in the direction we have exited the bounds and
                don't change it after that ever until touchend and again touchstart */
                scrolledXY = this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
            }
            if (scrolledXY.x === 0 && scrolledXY.y === 0) {
                this._touchPrevented = true;
            }
            // On Safari preventing the touchmove would prevent default page scroll behaviour even if there is the element doesn't have overflow
            if (this.IgxScrollInertiaDirection === 'vertical') {
                this.preventParentScroll(event, true);
            }
        };
        IgxScrollInertiaDirective.prototype.onTouchEnd = function (event) {
            if (typeof MSGesture === 'function') {
                return;
            }
            var speedX = 0;
            var speedY = 0;
            // savedSpeedsX and savedSpeedsY have same length
            for (var i = 0; i < this._savedSpeedsX.length; i++) {
                speedX += this._savedSpeedsX[i];
                speedY += this._savedSpeedsY[i];
            }
            speedX = this._savedSpeedsX.length ? speedX / this._savedSpeedsX.length : 0;
            speedY = this._savedSpeedsX.length ? speedY / this._savedSpeedsY.length : 0;
            // Use the lastMovedX and lastMovedY to determine if the swipe stops without lifting the finger so we don't start inertia
            if ((Math.abs(speedX) > 0.1 || Math.abs(speedY) > 0.1) &&
                (Math.abs(this._lastMovedX) > 2 || Math.abs(this._lastMovedY) > 2)) {
                this._inertiaInit(speedX, speedY);
            }
            if (this.IgxScrollInertiaDirection === 'vertical') {
                this.preventParentScroll(event, false);
            }
        };
        /**
         * @hidden
         * Function that is called when we need to detect touch starting on a touch device on IE/Edge
         */
        IgxScrollInertiaDirective.prototype.onPointerDown = function (event) {
            if (!event || (event.pointerType !== 2 && event.pointerType !== 'touch') ||
                typeof MSGesture !== 'function') {
                return true;
            }
            if (!this.IgxScrollInertiaScrollContainer) {
                return;
            }
            // setPointerCaptureFName is the name of the function that is supported
            event.target[this.setPointerCaptureFName](this._pointer = event.pointerId);
            // create gestureObject only one time to prevent overlapping during intertia
            if (!this._gestureObject) {
                this._gestureObject = new MSGesture();
                this._gestureObject.target = this.parentElement;
            }
            this._gestureObject.addPointer(this._pointer);
        };
        /**
         * @hidden
         * Function that is called when we need to detect touch ending on a touch device on IE/Edge
         */
        IgxScrollInertiaDirective.prototype.onPointerUp = function (event) {
            if (!this._pointer) {
                return true;
            }
            if (!this.IgxScrollInertiaScrollContainer) {
                return;
            }
            /* releasePointerCaptureFName is the name of the function that is supported */
            event.target[this.releasePointerCaptureFName](this._pointer);
            delete this._pointer;
        };
        /**
         * @hidden
         *  Function that is called when a gesture begins on IE/Edge
         */
        IgxScrollInertiaDirective.prototype.onMSGestureStart = function (event) {
            if (!this.IgxScrollInertiaScrollContainer) {
                return;
            }
            this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
            this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
            this._touchStartX = event.screenX;
            this._touchStartY = event.screenY;
            // Vars regarding swipe offset
            this._totalMovedX = 0;
            this._offsetRecorded = false;
            this._offsetDirection = 0;
            return false;
        };
        /**
         * @hidden
         * Function that is called when a we need to scroll based on the gesture performed on IE/Edge
         */
        IgxScrollInertiaDirective.prototype.onMSGestureChange = function (event) {
            if (!this.IgxScrollInertiaScrollContainer) {
                return;
            }
            var touchPos = event;
            var destX = this._startX + this._touchStartX - touchPos.screenX;
            var destY = this._startY + this._touchStartY - touchPos.screenY;
            /* Logic regarding x tolerance to prevent accidental horizontal scrolling when scrolling vertically */
            this._totalMovedX = this._touchStartX - touchPos.screenX;
            if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
                /* Do not scroll horizontally yet while in the tolerance range */
                this._scrollToY(destY);
            }
            else {
                if (!this._offsetRecorded) {
                    this._offsetDirection = Math.sign(destX - this._startX);
                    this._offsetRecorded = true;
                }
                /* Once the tolerance is exceeded it can be scrolled horizontally */
                this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
            }
            return false;
        };
        IgxScrollInertiaDirective.prototype._inertiaInit = function (speedX, speedY) {
            var _this = this;
            var stepModifer = this.inertiaStep;
            var inertiaDuration = this.inertiaDuration;
            var x = 0;
            this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;
            this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop;
            // Sets timeout until executing next movement iteration of the inertia
            var inertiaStep = function () {
                if (x > 6) {
                    cancelAnimationFrame(_this._touchInertiaAnimID);
                    return;
                }
                if (Math.abs(speedX) > Math.abs(speedY)) {
                    x += 0.05 / (1 * inertiaDuration);
                }
                else {
                    x += 0.05 / (1 * inertiaDuration);
                }
                if (x <= 1) {
                    // We use constant quation to determine the offset without speed falloff befor x reaches 1
                    if (Math.abs(speedY) <= Math.abs(speedX) * _this.inertiaDeltaY) {
                        _this._nextX += 1 * speedX * 15 * stepModifer;
                    }
                    if (Math.abs(speedY) >= Math.abs(speedX) * _this.inertiaDeltaX) {
                        _this._nextY += 1 * speedY * 15 * stepModifer;
                    }
                }
                else {
                    // We use the quation "y = 2 / (x + 0.55) - 0.3" to determine the offset
                    if (Math.abs(speedY) <= Math.abs(speedX) * _this.inertiaDeltaY) {
                        _this._nextX += Math.abs(2 / (x + 0.55) - 0.3) * speedX * 15 * stepModifer;
                    }
                    if (Math.abs(speedY) >= Math.abs(speedX) * _this.inertiaDeltaX) {
                        _this._nextY += Math.abs(2 / (x + 0.55) - 0.3) * speedY * 15 * stepModifer;
                    }
                }
                // If we have mixed environment we use the default behaviour. i.e. touchscreen + mouse
                _this._scrollTo(_this._nextX, _this._nextY);
                _this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
            };
            // Start inertia and continue it recursively
            this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
        };
        IgxScrollInertiaDirective.prototype.calcAxisCoords = function (target, min, max) {
            if (target === undefined || target < min) {
                target = min;
            }
            else if (target > max) {
                target = max;
            }
            return target;
        };
        IgxScrollInertiaDirective.prototype._scrollTo = function (destX, destY) {
            // TODO Trigger scrolling event?
            var scrolledX = this._scrollToX(destX);
            var scrolledY = this._scrollToY(destY);
            return { x: scrolledX, y: scrolledY };
        };
        IgxScrollInertiaDirective.prototype._scrollToX = function (dest) {
            this.IgxScrollInertiaScrollContainer.scrollLeft = dest;
        };
        IgxScrollInertiaDirective.prototype._scrollToY = function (dest) {
            this.IgxScrollInertiaScrollContainer.scrollTop = dest;
        };
        return IgxScrollInertiaDirective;
    }());
    IgxScrollInertiaDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[igxScrollInertia]' },] }
    ];
    IgxScrollInertiaDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.NgZone }
    ]; };
    IgxScrollInertiaDirective.propDecorators = {
        IgxScrollInertiaDirection: [{ type: i0.Input }],
        IgxScrollInertiaScrollContainer: [{ type: i0.Input }],
        wheelStep: [{ type: i0.Input }],
        inertiaStep: [{ type: i0.Input }],
        swipeToleranceX: [{ type: i0.Input }],
        inertiaDeltaY: [{ type: i0.Input }],
        inertiaDeltaX: [{ type: i0.Input }],
        inertiaDuration: [{ type: i0.Input }]
    };
    /**
     * @hidden
     */
    var IgxScrollInertiaModule = /** @class */ (function () {
        function IgxScrollInertiaModule() {
        }
        return IgxScrollInertiaModule;
    }());
    IgxScrollInertiaModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxScrollInertiaDirective],
                    exports: [IgxScrollInertiaDirective],
                    imports: [i2.CommonModule]
                },] }
    ];

    var IgxForOfSyncService = /** @class */ (function () {
        function IgxForOfSyncService() {
            this._master = new Map();
        }
        /**
         * @hidden
         */
        IgxForOfSyncService.prototype.isMaster = function (directive) {
            return this._master.get(directive.igxForScrollOrientation) === directive;
        };
        /**
         * @hidden
         */
        IgxForOfSyncService.prototype.setMaster = function (directive, forced) {
            if (forced === void 0) { forced = false; }
            var orientation = directive.igxForScrollOrientation;
            if (orientation && (forced || !this._master.has(orientation))) {
                this._master.set(orientation, directive);
            }
        };
        /**
         * @hidden
         */
        IgxForOfSyncService.prototype.resetMaster = function () {
            this._master.clear();
        };
        /**
         * @hidden
         */
        IgxForOfSyncService.prototype.sizesCache = function (dir) {
            return this._master.get(dir).sizesCache;
        };
        /**
         * @hidden
         */
        IgxForOfSyncService.prototype.chunkSize = function (dir) {
            return this._master.get(dir).state.chunkSize;
        };
        return IgxForOfSyncService;
    }());
    IgxForOfSyncService.ɵprov = i0.ɵɵdefineInjectable({ factory: function IgxForOfSyncService_Factory() { return new IgxForOfSyncService(); }, token: IgxForOfSyncService, providedIn: "root" });
    IgxForOfSyncService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    var IgxForOfScrollSyncService = /** @class */ (function () {
        function IgxForOfScrollSyncService() {
            this._masterScroll = new Map();
        }
        IgxForOfScrollSyncService.prototype.setScrollMaster = function (dir, scroll) {
            this._masterScroll.set(dir, scroll);
        };
        IgxForOfScrollSyncService.prototype.getScrollMaster = function (dir) {
            return this._masterScroll.get(dir);
        };
        return IgxForOfScrollSyncService;
    }());
    IgxForOfScrollSyncService.ɵprov = i0.ɵɵdefineInjectable({ factory: function IgxForOfScrollSyncService_Factory() { return new IgxForOfScrollSyncService(); }, token: IgxForOfScrollSyncService, providedIn: "root" });
    IgxForOfScrollSyncService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    var MAX_PERF_SCROLL_DIFF = 4;
    /**
     *  @publicApi
     */
    var IgxForOfContext = /** @class */ (function () {
        function IgxForOfContext($implicit, index, count) {
            this.$implicit = $implicit;
            this.index = index;
            this.count = count;
        }
        Object.defineProperty(IgxForOfContext.prototype, "first", {
            /**
             * A function that returns whether the element is the first or not
             */
            get: function () {
                return this.index === 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxForOfContext.prototype, "last", {
            /**
             * A function that returns whether the element is the last or not
             */
            get: function () {
                return this.index === this.count - 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxForOfContext.prototype, "even", {
            /**
             * A function that returns whether the element is even or not
             */
            get: function () {
                return this.index % 2 === 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxForOfContext.prototype, "odd", {
            /**
             * A function that returns whether the element is odd or not
             */
            get: function () {
                return !this.even;
            },
            enumerable: false,
            configurable: true
        });
        return IgxForOfContext;
    }());
    // eslint-disable @angular-eslint/no-conflicting-lifecycle
    var IgxForOfDirective = /** @class */ (function () {
        function IgxForOfDirective(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService, platformUtil, document) {
            this._viewContainer = _viewContainer;
            this._template = _template;
            this._differs = _differs;
            this.resolver = resolver;
            this.cdr = cdr;
            this._zone = _zone;
            this.syncScrollService = syncScrollService;
            this.platformUtil = platformUtil;
            this.document = document;
            /**
             * An @Input property that specifies the scroll orientation.
             * Scroll orientation can be "vertical" or "horizontal".
             * ```html
             * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'"></ng-template>
             * ```
             */
            this.igxForScrollOrientation = 'vertical';
            /**
             * An event that is emitted after a new chunk has been loaded.
             * ```html
             * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkLoad)="chunkLoad($event)"></ng-template>
             * ```
             * ```typescript
             * chunkLoad(e){
             * alert("chunk loaded!");
             * }
             * ```
             */
            this.onChunkLoad = new i0.EventEmitter();
            /**
             * @hidden @internal
             * An event that is emitted when scrollbar visibility has changed.
             */
            this.onScrollbarVisibilityChanged = new i0.EventEmitter();
            /**
             * An event that is emitted after the rendered content size of the igxForOf has been changed.
             */
            this.onContentSizeChange = new i0.EventEmitter();
            /**
             * An event that is emitted after data has been changed.
             * ```html
             * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onDataChanged)="dataChanged($event)"></ng-template>
             * ```
             * ```typescript
             * dataChanged(e){
             * alert("data changed!");
             * }
             * ```
             */
            this.onDataChanged = new i0.EventEmitter();
            this.onBeforeViewDestroyed = new i0.EventEmitter();
            /**
             * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
             * Can be used for implementing remote load on demand for the igxFor data.
             * ```html
             * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkPreload)="chunkPreload($event)"></ng-template>
             * ```
             * ```typescript
             * chunkPreload(e){
             * alert("chunk is loading!");
             * }
             * ```
             */
            this.onChunkPreload = new i0.EventEmitter();
            /**
             * The current state of the directive. It contains `startIndex` and `chunkSize`.
             * state.startIndex - The index of the item at which the current visible chunk begins.
             * state.chunkSize - The number of items the current visible chunk holds.
             * These options can be used when implementing remote virtualization as they provide the necessary state information.
             * ```typescript
             * const gridState = this.parentVirtDir.state;
             * ```
             */
            this.state = {
                startIndex: 0,
                chunkSize: 0
            };
            this._sizesCache = [];
            this._differ = null;
            this.heightCache = [];
            /** Internal track for scroll top that is being virtualized */
            this._virtScrollTop = 0;
            /** If the next onScroll event is triggered due to internal setting of scrollTop */
            this._bScrollInternal = false;
            // End properties related to virtual height handling
            this._embeddedViews = [];
            this.contentResizeNotify = new rxjs.Subject();
            /** Height that is being virtualized. */
            this._virtHeight = 0;
            /**
             * @hidden
             */
            this.destroy$ = new rxjs.Subject();
            this._totalItemCount = null;
            /**
             * Ratio for height that's being virtualizaed and the one visible
             * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxHeight > _virtHeight.
             */
            this._virtHeightRatio = 1;
        }
        Object.defineProperty(IgxForOfDirective.prototype, "igxForTotalItemCount", {
            /**
             * The total count of the virtual data items, when using remote service.
             * Similar to the property totalItemCount, but this will allow setting the data count into the template.
             * ```html
             * <ng-template igxFor let-item [igxForOf]="data | async" [igxForTotalItemCount]="count | async"
             *  [igxForContainerSize]="'500px'" [igxForItemSize]="'50px'"></ng-template>
             * ```
             */
            get: function () {
                return this.totalItemCount;
            },
            set: function (value) {
                this.totalItemCount = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "totalItemCount", {
            /**
             * The total count of the virtual data items, when using remote service.
             * ```typescript
             * this.parentVirtDir.totalItemCount = data.Count;
             * ```
             */
            get: function () {
                return this._totalItemCount;
            },
            set: function (val) {
                if (this._totalItemCount !== val) {
                    this._totalItemCount = val;
                    // update sizes in case total count changes.
                    var newSize = this.initSizesCache(this.igxForOf);
                    var sizeDiff = this.scrollComponent.size - newSize;
                    this.scrollComponent.size = newSize;
                    var lastChunkExceeded = this.state.startIndex + this.state.chunkSize > val;
                    if (lastChunkExceeded) {
                        this.state.startIndex = val - this.state.chunkSize;
                    }
                    this._adjustScrollPositionAfterSizeChange(sizeDiff);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "displayContainer", {
            get: function () {
                var _a, _b, _c, _d;
                return (_d = (_c = (_b = (_a = this.dc) === null || _a === void 0 ? void 0 : _a.instance) === null || _b === void 0 ? void 0 : _b._viewContainer) === null || _c === void 0 ? void 0 : _c.element) === null || _d === void 0 ? void 0 : _d.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "virtualHelper", {
            get: function () {
                return this.scrollComponent.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "isRemote", {
            /**
             * @hidden
             */
            get: function () {
                return this.totalItemCount !== null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "scrollPosition", {
            /**
             *
             * Gets/Sets the scroll position.
             * ```typescript
             * const position = directive.scrollPosition;
             * directive.scrollPosition = value;
             * ```
             */
            get: function () {
                return this.scrollComponent.scrollAmount;
            },
            set: function (val) {
                if (val === this.scrollComponent.scrollAmount) {
                    return;
                }
                if (this.igxForScrollOrientation === 'horizontal' && this.scrollComponent) {
                    this.scrollComponent.nativeElement.scrollLeft = val;
                }
                else if (this.scrollComponent) {
                    this.scrollComponent.nativeElement.scrollTop = val;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "sizesCache", {
            get: function () {
                return this._sizesCache;
            },
            set: function (value) {
                this._sizesCache = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "_isScrolledToBottom", {
            get: function () {
                if (!this.getScroll()) {
                    return true;
                }
                var scrollHeight = this.getScroll().scrollHeight;
                // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.
                // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.
                return Math.round(this.getScroll().scrollTop + this.igxForContainerSize) === scrollHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "_isAtBottomIndex", {
            get: function () {
                return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;
            },
            enumerable: false,
            configurable: true
        });
        IgxForOfDirective.prototype.verticalScrollHandler = function (event) {
            this.onScroll(event);
        };
        IgxForOfDirective.prototype.isScrollable = function () {
            return this.scrollComponent.size > parseInt(this.igxForContainerSize, 10);
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.ngOnInit = function () {
            var _this = this;
            var totalSize = 0;
            var vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;
            this.igxForSizePropName = this.igxForSizePropName || 'width';
            var dcFactory = this.resolver.resolveComponentFactory(DisplayContainerComponent);
            this.dc = this._viewContainer.createComponent(dcFactory, 0);
            this.dc.instance.scrollDirection = this.igxForScrollOrientation;
            if (typeof MSGesture === 'function') {
                // On Edge and IE when scrolling on touch the page scroll instead of the grid.
                this.dc.instance._viewContainer.element.nativeElement.style.touchAction = 'none';
            }
            if (this.igxForOf && this.igxForOf.length) {
                totalSize = this.initSizesCache(this.igxForOf);
                this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
                this.state.chunkSize = this._calculateChunkSize();
                this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);
                if (this.scrollComponent && !this.scrollComponent.destroyed) {
                    this.state.startIndex = Math.min(this.getIndexAt(this.scrollPosition, this.sizesCache), this.igxForOf.length - this.state.chunkSize);
                }
                for (var i = this.state.startIndex; i < this.state.startIndex + this.state.chunkSize &&
                    this.igxForOf[i] !== undefined; i++) {
                    var input = this.igxForOf[i];
                    var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
                    this._embeddedViews.push(embeddedView);
                }
            }
            if (this.igxForScrollOrientation === 'vertical') {
                this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
                var factory = this.resolver.resolveComponentFactory(VirtualHelperComponent);
                this.scrollComponent = vc.createComponent(factory).instance;
                this._maxHeight = this._calcMaxBrowserHeight();
                this.scrollComponent.size = this.igxForOf ? this._calcHeight() : 0;
                this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
                this._zone.runOutsideAngular(function () {
                    _this.verticalScrollHandler = _this.verticalScrollHandler.bind(_this);
                    _this.scrollComponent.nativeElement.addEventListener('scroll', _this.verticalScrollHandler);
                    _this.dc.instance.scrollContainer = _this.scrollComponent.nativeElement;
                });
                var destructor = operators.takeUntil(this.destroy$);
                this.contentResizeNotify.pipe(destructor, operators.filter(function () { return _this.igxForContainerSize && _this.igxForOf && _this.igxForOf.length > 0; }), operators.throttleTime(40, undefined, { leading: true, trailing: true })).subscribe(function () { return _this._zone.runTask(function () { return _this.updateSizes(); }); });
            }
            if (this.igxForScrollOrientation === 'horizontal') {
                this.func = function (evt) { return _this.onHScroll(evt); };
                this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
                if (!this.scrollComponent) {
                    var hvFactory = this.resolver.resolveComponentFactory(HVirtualHelperComponent);
                    this.scrollComponent = vc.createComponent(hvFactory).instance;
                    this.scrollComponent.size = totalSize;
                    this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
                    this._zone.runOutsideAngular(function () {
                        _this.scrollComponent.nativeElement.addEventListener('scroll', _this.func);
                        _this.dc.instance.scrollContainer = _this.scrollComponent.nativeElement;
                    });
                }
                else {
                    this._zone.runOutsideAngular(function () {
                        _this.scrollComponent.nativeElement.addEventListener('scroll', _this.func);
                        _this.dc.instance.scrollContainer = _this.scrollComponent.nativeElement;
                    });
                }
                this._updateHScrollOffset();
            }
        };
        IgxForOfDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this.igxForScrollOrientation === 'vertical') {
                this._zone.runOutsideAngular(function () {
                    _this.contentObserver = new ResizeObserver__default['default'](function () { return _this.contentResizeNotify.next(); });
                    _this.contentObserver.observe(_this.dc.instance._viewContainer.element.nativeElement);
                });
            }
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.ngOnDestroy = function () {
            this.removeScrollEventListeners();
            this.destroy$.next(true);
            this.destroy$.complete();
            if (this.contentObserver) {
                this.contentObserver.disconnect();
            }
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.ngOnChanges = function (changes) {
            var forOf = 'igxForOf';
            if (forOf in changes) {
                var value = changes[forOf].currentValue;
                if (!this._differ && value) {
                    try {
                        this._differ = this._differs.find(value).create(this.igxForTrackBy);
                    }
                    catch (e) {
                        throw new Error("Cannot find a differ supporting object \"" + value + "\" of type \"" + getTypeNameForDebugging(value) + "\".\n                     NgFor only supports binding to Iterables such as Arrays.");
                    }
                }
            }
            var defaultItemSize = 'igxForItemSize';
            if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
                this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
                // handle default item size changed.
                this.initSizesCache(this.igxForOf);
                this._applyChanges();
            }
            var containerSize = 'igxForContainerSize';
            if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
                this._recalcOnContainerChange(changes);
            }
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.ngDoCheck = function () {
            var _this = this;
            if (this._differ) {
                var changes = this._differ.diff(this.igxForOf);
                if (changes) {
                    //  re-init cache.
                    if (!this.igxForOf) {
                        this.igxForOf = [];
                    }
                    this._updateSizeCache();
                    this._zone.run(function () {
                        _this._applyChanges();
                        _this.cdr.markForCheck();
                        _this._updateScrollOffset();
                        _this.onDataChanged.emit();
                    });
                }
            }
        };
        /**
         * Shifts the scroll thumb position.
         * ```typescript
         * this.parentVirtDir.addScrollTop(5);
         * ```
         *
         * @param addTop negative value to scroll up and positive to scroll down;
         */
        IgxForOfDirective.prototype.addScrollTop = function (addTop) {
            if (addTop === 0 && this.igxForScrollOrientation === 'horizontal') {
                return false;
            }
            var originalVirtScrollTop = this._virtScrollTop;
            var containerSize = parseInt(this.igxForContainerSize, 10);
            var maxVirtScrollTop = this._virtHeight - containerSize;
            this._bScrollInternal = true;
            this._virtScrollTop += addTop;
            this._virtScrollTop = this._virtScrollTop > 0 ?
                (this._virtScrollTop < maxVirtScrollTop ? this._virtScrollTop : maxVirtScrollTop) :
                0;
            this.scrollPosition += addTop / this._virtHeightRatio;
            if (Math.abs(addTop / this._virtHeightRatio) < 1) {
                // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px
                var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
                // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;
                this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
            }
            var maxRealScrollTop = this.scrollComponent.nativeElement.scrollHeight - containerSize;
            if ((this._virtScrollTop > 0 && this.scrollPosition === 0) ||
                (this._virtScrollTop < maxVirtScrollTop && this.scrollPosition === maxRealScrollTop)) {
                // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)
                // Recalculate actual scroll position based on the virtual scroll.
                this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
            }
            else if (this._virtScrollTop === 0 && this.scrollPosition > 0) {
                // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll
                this.scrollPosition = 0;
            }
            else if (this._virtScrollTop === maxVirtScrollTop && this.scrollPosition < maxRealScrollTop) {
                // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll
                this.scrollPosition = maxRealScrollTop;
            }
            return this._virtScrollTop !== originalVirtScrollTop;
        };
        /**
         * Scrolls to the specified index.
         * ```typescript
         * this.parentVirtDir.scrollTo(5);
         * ```
         *
         * @param index
         */
        IgxForOfDirective.prototype.scrollTo = function (index) {
            if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {
                return;
            }
            var containerSize = parseInt(this.igxForContainerSize, 10);
            var isPrevItem = index < this.state.startIndex || this.scrollPosition > this.sizesCache[index];
            var nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;
            if (nextScroll < 0) {
                return;
            }
            if (this.igxForScrollOrientation === 'horizontal') {
                this.scrollPosition = nextScroll;
            }
            else {
                var maxVirtScrollTop = this._virtHeight - containerSize;
                if (nextScroll > maxVirtScrollTop) {
                    nextScroll = maxVirtScrollTop;
                }
                this._bScrollInternal = true;
                this._virtScrollTop = nextScroll;
                this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
                this._adjustToIndex = !isPrevItem ? index : null;
            }
        };
        /**
         * Scrolls by one item into the appropriate next direction.
         * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
         * ```typescript
         * this.parentVirtDir.scrollNext();
         * ```
         */
        IgxForOfDirective.prototype.scrollNext = function () {
            var scr = Math.ceil(this.scrollPosition);
            var endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache);
            this.scrollTo(endIndex);
        };
        /**
         * Scrolls by one item into the appropriate previous direction.
         * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
         * ```typescript
         * this.parentVirtDir.scrollPrev();
         * ```
         */
        IgxForOfDirective.prototype.scrollPrev = function () {
            this.scrollTo(this.state.startIndex - 1);
        };
        /**
         * Scrolls by one page into the appropriate next direction.
         * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
         * ```typescript
         * this.parentVirtDir.scrollNextPage();
         * ```
         */
        IgxForOfDirective.prototype.scrollNextPage = function () {
            if (this.igxForScrollOrientation === 'horizontal') {
                this.scrollPosition += parseInt(this.igxForContainerSize, 10);
            }
            else {
                this.addScrollTop(parseInt(this.igxForContainerSize, 10));
            }
        };
        /**
         * Scrolls by one page into the appropriate previous direction.
         * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
         * ```typescript
         * this.parentVirtDir.scrollPrevPage();
         * ```
         */
        IgxForOfDirective.prototype.scrollPrevPage = function () {
            if (this.igxForScrollOrientation === 'horizontal') {
                this.scrollPosition -= parseInt(this.igxForContainerSize, 10);
            }
            else {
                var containerSize = (parseInt(this.igxForContainerSize, 10));
                this.addScrollTop(-containerSize);
            }
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.getColumnScrollLeft = function (colIndex) {
            return this.sizesCache[colIndex];
        };
        /**
         * Returns the total number of items that are fully visible.
         * ```typescript
         * this.parentVirtDir.getItemCountInView();
         * ```
         */
        IgxForOfDirective.prototype.getItemCountInView = function () {
            var startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache);
            if (this.scrollPosition - this.sizesCache[startIndex] > 0) {
                // fisrt item is not fully in view
                startIndex++;
            }
            var endIndex = this.getIndexAt(this.scrollPosition + parseInt(this.igxForContainerSize, 10), this.sizesCache);
            return endIndex - startIndex;
        };
        /**
         * Returns a reference to the scrollbar DOM element.
         * This is either a vertical or horizontal scrollbar depending on the specified igxForScrollOrientation.
         * ```typescript
         * dir.getScroll();
         * ```
         */
        IgxForOfDirective.prototype.getScroll = function () {
            var _a;
            return (_a = this.scrollComponent) === null || _a === void 0 ? void 0 : _a.nativeElement;
        };
        /**
         * Returns the size of the element at the specified index.
         * ```typescript
         * this.parentVirtDir.getSizeAt(1);
         * ```
         */
        IgxForOfDirective.prototype.getSizeAt = function (index) {
            return this.sizesCache[index + 1] - this.sizesCache[index];
        };
        /**
         * @hidden
         * Function that is called to get the native scrollbar size that the browsers renders.
         */
        IgxForOfDirective.prototype.getScrollNativeSize = function () {
            return this.scrollComponent ? this.scrollComponent.scrollNativeSize : 0;
        };
        /**
         * Returns the scroll offset of the element at the specified index.
         * ```typescript
         * this.parentVirtDir.getScrollForIndex(1);
         * ```
         */
        IgxForOfDirective.prototype.getScrollForIndex = function (index, bottom) {
            var containerSize = parseInt(this.igxForContainerSize, 10);
            var scroll = bottom ? Math.max(0, this.sizesCache[index + 1] - containerSize) : this.sizesCache[index];
            return scroll;
        };
        /**
         * @hidden
         * Function that recaculates and updates cache sizes.
         */
        IgxForOfDirective.prototype.recalcUpdateSizes = function () {
            var dimension = this.igxForScrollOrientation === 'horizontal' ?
                this.igxForSizePropName : 'height';
            var diffs = [];
            var totalDiff = 0;
            var l = this._embeddedViews.length;
            var rNodes = this._embeddedViews.map(function (view) { return view.rootNodes.find(function (node) { return node.nodeType === Node.ELEMENT_NODE; }) || view.rootNodes[0].nextElementSibling; });
            for (var i = 0; i < l; i++) {
                var rNode = rNodes[i];
                if (rNode) {
                    var h = rNode.offsetHeight || parseInt(this.igxForItemSize, 10);
                    var index = this.state.startIndex + i;
                    if (!this.isRemote && !this.igxForOf[index]) {
                        continue;
                    }
                    var oldVal = dimension === 'height' ? this.heightCache[index] : this.igxForOf[index][dimension];
                    var newVal = dimension === 'height' ? h : rNode.clientWidth;
                    if (dimension === 'height') {
                        this.heightCache[index] = newVal;
                    }
                    else {
                        this.igxForOf[index][dimension] = newVal;
                    }
                    var currDiff = newVal - oldVal;
                    diffs.push(currDiff);
                    totalDiff += currDiff;
                    this.sizesCache[index + 1] += totalDiff;
                }
            }
            // update cache
            if (Math.abs(totalDiff) > 0) {
                for (var j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {
                    this.sizesCache[j] += totalDiff;
                }
                // update scrBar heights/widths
                if (this.igxForScrollOrientation === 'horizontal') {
                    var totalWidth = parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10) + totalDiff;
                    this.scrollComponent.nativeElement.children[0].style.width = totalWidth + 'px';
                }
                var reducer = function (acc, val) { return acc + val; };
                if (this.igxForScrollOrientation === 'vertical') {
                    var scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;
                    var hSum = this.heightCache.reduce(reducer);
                    if (hSum > this._maxHeight) {
                        this._virtHeightRatio = hSum / this._maxHeight;
                    }
                    this.scrollComponent.size = Math.min(this.scrollComponent.size + totalDiff, this._maxHeight);
                    this._virtHeight = hSum;
                    if (!this.scrollComponent.destroyed) {
                        this.scrollComponent.cdr.detectChanges();
                    }
                    if (scrToBottom && !this._isAtBottomIndex) {
                        var containerSize = parseInt(this.igxForContainerSize, 10);
                        var maxVirtScrollTop = this._virtHeight - containerSize;
                        this._bScrollInternal = true;
                        this._virtScrollTop = maxVirtScrollTop;
                        this.scrollPosition = maxVirtScrollTop;
                        return;
                    }
                    if (this._adjustToIndex) {
                        // in case scrolled to specific index where after scroll heights are changed
                        // need to adjust the offsets so that item is last in view.
                        var updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;
                        var sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);
                        if (sumDiffs !== 0) {
                            this.addScrollTop(sumDiffs);
                        }
                        this._adjustToIndex = null;
                    }
                }
            }
        };
        /**
         * @hidden
         * Reset scroll position.
         * Needed in case scrollbar is hidden/detached but we still need to reset it.
         */
        IgxForOfDirective.prototype.resetScrollPosition = function () {
            this.scrollPosition = 0;
            this.scrollComponent.scrollAmount = 0;
            this.state.startIndex = 0;
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.removeScrollEventListeners = function () {
            var _this = this;
            if (this.igxForScrollOrientation === 'horizontal') {
                this._zone.runOutsideAngular(function () { var _a, _b; return (_b = (_a = _this.scrollComponent) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.removeEventListener('scroll', _this.func); });
            }
            else {
                this._zone.runOutsideAngular(function () { var _a, _b; return (_b = (_a = _this.scrollComponent) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.removeEventListener('scroll', _this.verticalScrollHandler); });
            }
        };
        /**
         * @hidden
         * Function that is called when scrolling vertically
         */
        IgxForOfDirective.prototype.onScroll = function (event) {
            /* in certain situations this may be called when no scrollbar is visible */
            if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
                return;
            }
            if (!this._bScrollInternal) {
                this._calcVirtualScrollTop(event.target.scrollTop);
            }
            else {
                this._bScrollInternal = false;
            }
            var prevStartIndex = this.state.startIndex;
            var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
            this.dc.changeDetectorRef.detectChanges();
            if (prevStartIndex !== this.state.startIndex) {
                this.onChunkLoad.emit(this.state);
            }
        };
        IgxForOfDirective.prototype.updateSizes = function () {
            this.recalcUpdateSizes();
            this._applyChanges();
            this._updateScrollOffset();
            this.onContentSizeChange.emit();
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.fixedUpdateAllElements = function (inScrollTop) {
            var count = this.isRemote ? this.totalItemCount : this.igxForOf.length;
            var newStart = this.getIndexAt(inScrollTop, this.sizesCache);
            if (newStart + this.state.chunkSize > count) {
                newStart = count - this.state.chunkSize;
            }
            var prevStart = this.state.startIndex;
            var diff = newStart - this.state.startIndex;
            this.state.startIndex = newStart;
            if (diff) {
                this.onChunkPreload.emit(this.state);
                if (!this.isRemote) {
                    // recalculate and apply page size.
                    if (diff && Math.abs(diff) <= MAX_PERF_SCROLL_DIFF) {
                        if (diff > 0) {
                            this.moveApplyScrollNext(prevStart);
                        }
                        else {
                            this.moveApplyScrollPrev(prevStart);
                        }
                    }
                    else {
                        this.fixedApplyScroll();
                    }
                }
            }
            return inScrollTop - this.sizesCache[this.state.startIndex];
        };
        /**
         * @hidden
         * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
         */
        IgxForOfDirective.prototype.moveApplyScrollNext = function (prevIndex) {
            var start = prevIndex + this.state.chunkSize;
            var end = start + this.state.startIndex - prevIndex;
            var container = this.dc.instance._vcr;
            for (var i = start; i < end && this.igxForOf[i] !== undefined; i++) {
                var embView = this._embeddedViews.shift();
                this.scrollFocus(embView.rootNodes.find(function (node) { return node.nodeType === Node.ELEMENT_NODE; })
                    || embView.rootNodes[0].nextElementSibling);
                var view = container.detach(0);
                this.updateTemplateContext(embView.context, i);
                container.insert(view);
                this._embeddedViews.push(embView);
            }
        };
        /**
         * @hidden
         * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
         */
        IgxForOfDirective.prototype.moveApplyScrollPrev = function (prevIndex) {
            var container = this.dc.instance._vcr;
            for (var i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {
                var embView = this._embeddedViews.pop();
                this.scrollFocus(embView.rootNodes.find(function (node) { return node.nodeType === Node.ELEMENT_NODE; })
                    || embView.rootNodes[0].nextElementSibling);
                var view = container.detach(container.length - 1);
                this.updateTemplateContext(embView.context, i);
                container.insert(view, 0);
                this._embeddedViews.unshift(embView);
            }
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.getContextIndex = function (input) {
            return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);
        };
        /**
         * @hidden
         * Function which updates the passed context of an embedded view with the provided index
         * from the view container.
         * Often, called while handling a scroll event.
         */
        IgxForOfDirective.prototype.updateTemplateContext = function (context, index) {
            if (index === void 0) { index = 0; }
            context.$implicit = this.igxForOf[index];
            context.index = this.getContextIndex(this.igxForOf[index]);
            context.count = this.igxForOf.length;
        };
        /**
         * @hidden
         * The function applies an optimized state change through context change for each view
         */
        IgxForOfDirective.prototype.fixedApplyScroll = function () {
            var j = 0;
            var endIndex = this.state.startIndex + this.state.chunkSize;
            for (var i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                var embView = this._embeddedViews[j++];
                this.updateTemplateContext(embView.context, i);
            }
        };
        /**
         * @hidden
         * @internal
         *
         * Clears focus inside the virtualized container on small scroll swaps.
         */
        IgxForOfDirective.prototype.scrollFocus = function (node) {
            var activeElement = this.document.activeElement;
            // Remove focus in case the the active element is inside the view container.
            // Otherwise we hit an exception while doing the 'small' scrolls swapping.
            // For more information:
            //
            // https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild
            // https://bugs.chromium.org/p/chromium/issues/detail?id=432392
            if (node && node.contains(this.document.activeElement)) {
                activeElement.blur();
            }
        };
        /**
         * @hidden
         * Function that is called when scrolling horizontally
         */
        IgxForOfDirective.prototype.onHScroll = function (event) {
            /* in certain situations this may be called when no scrollbar is visible */
            if (!parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
                return;
            }
            var prevStartIndex = this.state.startIndex;
            // Updating horizontal chunks
            var scrollOffset = this.fixedUpdateAllElements(event.target.scrollLeft);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
            this.dc.changeDetectorRef.detectChanges();
            if (prevStartIndex !== this.state.startIndex) {
                this.onChunkLoad.emit(this.state);
            }
        };
        Object.defineProperty(IgxForOfDirective.prototype, "igxForTrackBy", {
            /**
             * Gets the function used to track changes in the items collection.
             * By default the object references are compared. However this can be optimized if you have unique identifier
             * value that can be used for the comparison instead of the object ref or if you have some other property values
             * in the item object that should be tracked for changes.
             * This option is similar to ngForTrackBy.
             * ```typescript
             * const trackFunc = this.parentVirtDir.igxForTrackBy;
             * ```
             */
            get: function () {
                return this._trackByFn;
            },
            /**
             * Sets the function used to track changes in the items collection.
             * This function can be set in scenarios where you want to optimize or
             * customize the tracking of changes for the items in the collection.
             * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
             * ```typescript
             * this.parentVirtDir.igxForTrackBy = (index, item) => {
             *      return item.id + item.width;
             * };
             * ```
             */
            set: function (fn) {
                this._trackByFn = fn;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxForOfDirective.prototype._applyChanges = function () {
            var prevChunkSize = this.state.chunkSize;
            this.applyChunkSizeChange();
            this._recalcScrollBarSize();
            if (this.igxForOf && this.igxForOf.length && this.dc) {
                var embeddedViewCopy = Object.assign([], this._embeddedViews);
                var startIndex = this.state.startIndex;
                var endIndex = this.state.chunkSize + this.state.startIndex;
                if (this.isRemote) {
                    startIndex = 0;
                    endIndex = this.igxForOf.length;
                }
                for (var i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                    var embView = embeddedViewCopy.shift();
                    this.updateTemplateContext(embView.context, i);
                }
                if (prevChunkSize !== this.state.chunkSize) {
                    this.onChunkLoad.emit(this.state);
                }
            }
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype._calcMaxBrowserHeight = function () {
            if (!this.platformUtil.isBrowser) {
                return 0;
            }
            var div = this.document.createElement('div');
            var style = div.style;
            style.position = 'absolute';
            style.top = '9999999999999999px';
            this.document.body.appendChild(div);
            var size = Math.abs(div.getBoundingClientRect()['top']);
            this.document.body.removeChild(div);
            return size;
        };
        /**
         * @hidden
         * Recalculates the chunkSize based on current startIndex and returns the new size.
         * This should be called after this.state.startIndex is updated, not before.
         */
        IgxForOfDirective.prototype._calculateChunkSize = function () {
            var chunkSize = 0;
            if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {
                if (!this.sizesCache) {
                    this.initSizesCache(this.igxForOf);
                }
                chunkSize = this._calcMaxChunkSize();
                if (this.igxForOf && chunkSize > this.igxForOf.length) {
                    chunkSize = this.igxForOf.length;
                }
            }
            else {
                if (this.igxForOf) {
                    chunkSize = this.igxForOf.length;
                }
            }
            return chunkSize;
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.getElement = function (viewref, nodeName) {
            var elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);
            return elem.length > 0 ? elem[0] : null;
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.initSizesCache = function (items) {
            var totalSize = 0;
            var size = 0;
            var dimension = this.igxForScrollOrientation === 'horizontal' ?
                this.igxForSizePropName : 'height';
            var i = 0;
            this.sizesCache = [];
            this.heightCache = [];
            this.sizesCache.push(0);
            var count = this.isRemote ? this.totalItemCount : items.length;
            for (i; i < count; i++) {
                if (dimension === 'height') {
                    // cols[i][dimension] = parseInt(this.igxForItemSize, 10) || 0;
                    size = parseInt(this.igxForItemSize, 10) || 0;
                    this.heightCache.push(size);
                }
                else {
                    size = this._getItemSize(items[i], dimension);
                }
                totalSize += size;
                this.sizesCache.push(totalSize);
            }
            return totalSize;
        };
        IgxForOfDirective.prototype._updateSizeCache = function () {
            if (this.igxForScrollOrientation === 'horizontal') {
                this.initSizesCache(this.igxForOf);
                return;
            }
            var oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce(function (acc, val) { return acc + val; }) : 0;
            var newHeight = this.initSizesCache(this.igxForOf);
            var diff = oldHeight - newHeight;
            this._adjustScrollPositionAfterSizeChange(diff);
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype._calcMaxChunkSize = function () {
            var _this = this;
            var i = 0;
            var length = 0;
            var maxLength = 0;
            var arr = [];
            var sum = 0;
            var availableSize = parseInt(this.igxForContainerSize, 10);
            if (!availableSize) {
                return 0;
            }
            var dimension = this.igxForScrollOrientation === 'horizontal' ?
                this.igxForSizePropName : 'height';
            var reducer = function (accumulator, currentItem) { return accumulator + _this._getItemSize(currentItem, dimension); };
            for (i; i < this.igxForOf.length; i++) {
                var item = this.igxForOf[i];
                if (dimension === 'height') {
                    item = { value: this.igxForOf[i], height: this.heightCache[i] };
                }
                var size = dimension === 'height' ?
                    this.heightCache[i] :
                    this._getItemSize(item, dimension);
                sum = arr.reduce(reducer, size);
                if (sum < availableSize) {
                    arr.push(item);
                    length = arr.length;
                    if (i === this.igxForOf.length - 1) {
                        // reached end without exceeding
                        // include prev items until size is filled or first item is reached.
                        var curItem = dimension === 'height' ? arr[0].value : arr[0];
                        var prevIndex = this.igxForOf.indexOf(curItem) - 1;
                        while (prevIndex >= 0 && sum <= availableSize) {
                            curItem = dimension === 'height' ? arr[0].value : arr[0];
                            prevIndex = this.igxForOf.indexOf(curItem) - 1;
                            var prevItem = this.igxForOf[prevIndex];
                            var prevSize = dimension === 'height' ?
                                this.heightCache[prevIndex] :
                                parseInt(prevItem[dimension], 10);
                            sum = arr.reduce(reducer, prevSize);
                            arr.unshift(prevItem);
                            length = arr.length;
                        }
                    }
                }
                else {
                    arr.push(item);
                    length = arr.length + 1;
                    arr.shift();
                }
                if (length > maxLength) {
                    maxLength = length;
                }
            }
            return maxLength;
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.getIndexAt = function (left, set) {
            var start = 0;
            var end = set.length - 1;
            if (left === 0) {
                return 0;
            }
            while (start <= end) {
                var midIdx = Math.floor((start + end) / 2);
                var midLeft = set[midIdx];
                var cmp = left - midLeft;
                if (cmp > 0) {
                    start = midIdx + 1;
                }
                else if (cmp < 0) {
                    end = midIdx - 1;
                }
                else {
                    return midIdx;
                }
            }
            return end;
        };
        IgxForOfDirective.prototype._recalcScrollBarSize = function () {
            var count = this.isRemote ? this.totalItemCount : (this.igxForOf ? this.igxForOf.length : 0);
            this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);
            var scrollable = this.isScrollable();
            if (this.igxForScrollOrientation === 'horizontal') {
                var totalWidth = this.igxForContainerSize ? this.initSizesCache(this.igxForOf) : 0;
                this.scrollComponent.nativeElement.style.width = this.igxForContainerSize + 'px';
                this.scrollComponent.size = totalWidth;
                if (totalWidth <= parseInt(this.igxForContainerSize, 10)) {
                    this.resetScrollPosition();
                }
            }
            if (this.igxForScrollOrientation === 'vertical') {
                this.scrollComponent.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';
                this.scrollComponent.size = this._calcHeight();
                if (this.scrollComponent.size <= parseInt(this.igxForContainerSize, 10)) {
                    this.resetScrollPosition();
                }
            }
            if (scrollable !== this.isScrollable()) {
                // scrollbar visibility has changed
                this.onScrollbarVisibilityChanged.emit();
            }
        };
        IgxForOfDirective.prototype._calcHeight = function () {
            var height;
            if (this.heightCache) {
                height = this.heightCache.reduce(function (acc, val) { return acc + val; }, 0);
            }
            else {
                height = this.initSizesCache(this.igxForOf);
            }
            this._virtHeight = height;
            if (height > this._maxHeight) {
                this._virtHeightRatio = height / this._maxHeight;
                height = this._maxHeight;
            }
            return height;
        };
        IgxForOfDirective.prototype._recalcOnContainerChange = function (changes) {
            this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
            this.dc.instance._viewContainer.element.nativeElement.style.left = '0px';
            var prevChunkSize = this.state.chunkSize;
            this.applyChunkSizeChange();
            this._recalcScrollBarSize();
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
            if (this.sizesCache && this.igxForScrollOrientation === 'horizontal') {
                // Updating horizontal chunks and offsets based on the new scrollLeft
                var scrollOffset = this.fixedUpdateAllElements(this.scrollPosition);
                this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
            }
        };
        /**
         * @hidden
         * Removes an elemenet from the embedded views and updates chunkSize.
         */
        IgxForOfDirective.prototype.removeLastElem = function () {
            var oldElem = this._embeddedViews.pop();
            this.onBeforeViewDestroyed.emit(oldElem);
            // also detach from ViewContainerRef to make absolutely sure this is removed from the view container.
            this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
            oldElem.destroy();
            this.state.chunkSize--;
        };
        /**
         * @hidden
         * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
         */
        IgxForOfDirective.prototype.addLastElem = function () {
            var _this = this;
            var elemIndex = this.state.startIndex + this.state.chunkSize;
            if (!this.isRemote && !this.igxForOf) {
                return;
            }
            if (elemIndex >= this.igxForOf.length) {
                elemIndex = this.igxForOf.length - this.state.chunkSize;
            }
            var input = this.igxForOf[elemIndex];
            var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
            this._embeddedViews.push(embeddedView);
            this.state.chunkSize++;
            this._zone.run(function () { return _this.cdr.markForCheck(); });
        };
        /**
         * Recalculates chunkSize and adds/removes elements if need due to the change.
         * this.state.chunkSize is updated in @addLastElem() or @removeLastElem()
         */
        IgxForOfDirective.prototype.applyChunkSizeChange = function () {
            var chunkSize = this.isRemote ? (this.igxForOf ? this.igxForOf.length : 0) : this._calculateChunkSize();
            if (chunkSize > this.state.chunkSize) {
                var diff = chunkSize - this.state.chunkSize;
                for (var i = 0; i < diff; i++) {
                    this.addLastElem();
                }
            }
            else if (chunkSize < this.state.chunkSize) {
                var diff = this.state.chunkSize - chunkSize;
                for (var i = 0; i < diff; i++) {
                    this.removeLastElem();
                }
            }
        };
        IgxForOfDirective.prototype._updateScrollOffset = function () {
            if (this.igxForScrollOrientation === 'horizontal') {
                this._updateHScrollOffset();
            }
            else {
                this._updateVScrollOffset();
            }
        };
        IgxForOfDirective.prototype._calcVirtualScrollTop = function (scrollTop) {
            var containerSize = parseInt(this.igxForContainerSize, 10);
            var maxRealScrollTop = this.scrollComponent.size - containerSize;
            var realPercentScrolled = maxRealScrollTop !== 0 ? scrollTop / maxRealScrollTop : 0;
            var maxVirtScrollTop = this._virtHeight - containerSize;
            this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
        };
        IgxForOfDirective.prototype._updateVScrollOffset = function () {
            var scrollOffset = 0;
            var currentScrollTop = this.scrollPosition;
            if (this._virtHeightRatio !== 1) {
                this._calcVirtualScrollTop(this.scrollPosition);
                currentScrollTop = this._virtScrollTop;
            }
            var vScroll = this.scrollComponent.nativeElement;
            scrollOffset = vScroll && this.scrollComponent.size ?
                currentScrollTop - this.sizesCache[this.state.startIndex] : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        };
        IgxForOfDirective.prototype._updateHScrollOffset = function () {
            var scrollOffset = 0;
            scrollOffset = this.scrollComponent.nativeElement &&
                this.scrollComponent.size ?
                this.scrollPosition - this.sizesCache[this.state.startIndex] : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        };
        IgxForOfDirective.prototype._getItemSize = function (item, dimension) {
            var dim = item[dimension];
            return typeof dim === 'number' ? dim : parseInt(this.igxForItemSize, 10) || 0;
        };
        IgxForOfDirective.prototype._adjustScrollPositionAfterSizeChange = function (sizeDiff) {
            // if data has been changed while container is scrolled
            // should update scroll top/left according to change so that same startIndex is in view
            if (Math.abs(sizeDiff) > 0 && this.scrollPosition > 0) {
                this.recalcUpdateSizes();
                var offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                var newSize = this.sizesCache[this.state.startIndex] - offset;
                this.scrollPosition = newSize === this.scrollPosition ? newSize + 1 : newSize;
            }
        };
        return IgxForOfDirective;
    }());
    IgxForOfDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[igxFor][igxForOf]',
                    providers: [IgxForOfScrollSyncService] },] }
    ];
    IgxForOfDirective.ctorParameters = function () { return [
        { type: i0.ViewContainerRef },
        { type: i0.TemplateRef },
        { type: i0.IterableDiffers },
        { type: i0.ComponentFactoryResolver },
        { type: i0.ChangeDetectorRef },
        { type: i0.NgZone },
        { type: IgxForOfScrollSyncService },
        { type: PlatformUtil },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] }
    ]; };
    IgxForOfDirective.propDecorators = {
        igxForOf: [{ type: i0.Input }],
        igxForSizePropName: [{ type: i0.Input }],
        igxForScrollOrientation: [{ type: i0.Input }],
        igxForScrollContainer: [{ type: i0.Input }],
        igxForContainerSize: [{ type: i0.Input }],
        igxForItemSize: [{ type: i0.Input }],
        onChunkLoad: [{ type: i0.Output }],
        onScrollbarVisibilityChanged: [{ type: i0.Output }],
        onContentSizeChange: [{ type: i0.Output }],
        onDataChanged: [{ type: i0.Output }],
        onBeforeViewDestroyed: [{ type: i0.Output }],
        onChunkPreload: [{ type: i0.Output }],
        igxForTotalItemCount: [{ type: i0.Input }],
        igxForTrackBy: [{ type: i0.Input }]
    };
    var getTypeNameForDebugging = function (type) { return type.name || typeof type; };
    var IgxGridForOfDirective = /** @class */ (function (_super) {
        __extends(IgxGridForOfDirective, _super);
        function IgxGridForOfDirective(_viewContainer, _template, _differs, resolver, cdr, _zone, _platformUtil, _document, syncScrollService, syncService) {
            var _this = _super.call(this, _viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService, _platformUtil, _document) || this;
            _this.syncScrollService = syncScrollService;
            _this.syncService = syncService;
            /**
             * @hidden @internal
             * An event that is emitted after data has been changed but before the view is refreshed
             */
            _this.onDataChanging = new i0.EventEmitter();
            return _this;
        }
        Object.defineProperty(IgxGridForOfDirective.prototype, "igxGridForOf", {
            get: function () {
                return this.igxForOf;
            },
            set: function (value) {
                this.igxForOf = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridForOfDirective.prototype, "sizesCache", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.syncService.isMaster(this)) {
                    return this._sizesCache;
                }
                return this.syncService.sizesCache(this.igxForScrollOrientation);
            },
            /**
             * @hidden
             * @internal
             */
            set: function (value) {
                this._sizesCache = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridForOfDirective.prototype, "itemsDimension", {
            get: function () {
                return this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
            },
            enumerable: false,
            configurable: true
        });
        IgxGridForOfDirective.prototype.ngOnInit = function () {
            this.syncService.setMaster(this);
            _super.prototype.ngOnInit.call(this);
            this.removeScrollEventListeners();
        };
        IgxGridForOfDirective.prototype.ngOnChanges = function (changes) {
            var forOf = 'igxGridForOf';
            this.syncService.setMaster(this);
            if (forOf in changes) {
                var value = changes[forOf].currentValue;
                if (!this._differ && value) {
                    try {
                        this._differ = this._differs.find(value).create(this.igxForTrackBy);
                    }
                    catch (e) {
                        throw new Error("Cannot find a differ supporting object \"" + value + "\" of type \"" + getTypeNameForDebugging(value) + "\".\n                     NgFor only supports binding to Iterables such as Arrays.");
                    }
                }
            }
            var defaultItemSize = 'igxForItemSize';
            if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
                this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
                // handle default item size changed.
                this.initSizesCache(this.igxForOf);
            }
            var containerSize = 'igxForContainerSize';
            if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
                this._recalcOnContainerChange(changes);
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridForOfDirective.prototype.assumeMaster = function () {
            this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
            this.syncService.setMaster(this, true);
        };
        IgxGridForOfDirective.prototype.ngDoCheck = function () {
            if (this._differ) {
                var changes = this._differ.diff(this.igxForOf);
                if (changes) {
                    var args = {
                        containerSize: this.igxForContainerSize
                    };
                    this.onDataChanging.emit(args);
                    //  re-init cache.
                    if (!this.igxForOf) {
                        this.igxForOf = [];
                    }
                    /* we need to reset the master dir if all rows are removed
                    (e.g. because of filtering); if all columns are hidden, rows are
                    still rendered empty, so we should not reset master */
                    if (!this.igxForOf.length &&
                        this.igxForScrollOrientation === 'vertical') {
                        this.syncService.resetMaster();
                    }
                    this.syncService.setMaster(this);
                    this.igxForContainerSize = args.containerSize;
                    this._updateSizeCache(changes);
                    this._applyChanges();
                    this._updateScrollOffset();
                    this.onDataChanged.emit();
                }
            }
        };
        IgxGridForOfDirective.prototype.onScroll = function (event) {
            if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
                return;
            }
            if (!this._bScrollInternal) {
                this._calcVirtualScrollTop(event.target.scrollTop);
            }
            else {
                this._bScrollInternal = false;
            }
            var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
            this._zone.onStable.pipe(operators.first()).subscribe(this.recalcUpdateSizes.bind(this));
            this.cdr.markForCheck();
        };
        IgxGridForOfDirective.prototype.onHScroll = function (scrollAmount) {
            /* in certain situations this may be called when no scrollbar is visible */
            if (!this.scrollComponent || !parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
                return;
            }
            // Updating horizontal chunks
            var scrollOffset = this.fixedUpdateAllElements(scrollAmount);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        };
        IgxGridForOfDirective.prototype.getItemSize = function (item) {
            var size = 0;
            var dimension = this.igxForScrollOrientation === 'horizontal' ?
                this.igxForSizePropName : 'height';
            if (dimension === 'height') {
                size = parseInt(this.igxForItemSize, 10) || 0;
                if (item && item.summaries) {
                    size = item.max;
                }
                else if (item && item.groups && item.height) {
                    size = item.height;
                }
            }
            else {
                size = parseInt(item[dimension], 10) || 0;
            }
            return size;
        };
        IgxGridForOfDirective.prototype.initSizesCache = function (items) {
            if (!this.syncService.isMaster(this)) {
                var masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
                return masterSizesCache[masterSizesCache.length - 1];
            }
            var totalSize = 0;
            var size = 0;
            var i = 0;
            this.sizesCache = [];
            this.heightCache = [];
            this.sizesCache.push(0);
            var count = this.isRemote ? this.totalItemCount : items.length;
            for (i; i < count; i++) {
                size = this.getItemSize(items[i]);
                if (this.itemsDimension === 'height') {
                    this.heightCache.push(size);
                }
                totalSize += size;
                this.sizesCache.push(totalSize);
            }
            return totalSize;
        };
        IgxGridForOfDirective.prototype._updateSizeCache = function (changes) {
            var _this = this;
            if (changes === void 0) { changes = null; }
            if (this.igxForScrollOrientation === 'horizontal') {
                this.initSizesCache(this.igxForOf);
                return;
            }
            var oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce(function (acc, val) { return acc + val; }) : 0;
            var newHeight = oldHeight;
            if (changes && !this.isRemote) {
                newHeight = this.handleCacheChanges(changes);
            }
            else {
                return;
            }
            var diff = oldHeight - newHeight;
            // if data has been changed while container is scrolled
            // should update scroll top/left according to change so that same startIndex is in view
            if (Math.abs(diff) > 0 && this.platformUtil.isBrowser) {
                // TODO: This code can be removed. However tests need to be rewritten in a way that they wait for ResizeObserved to complete.
                // So leaving as is for the moment.
                requestAnimationFrame(function () {
                    _this.recalcUpdateSizes();
                    var offset = parseInt(_this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                    if (_this.scrollPosition !== 0) {
                        _this.scrollPosition = _this.sizesCache[_this.state.startIndex] - offset;
                    }
                    else {
                        _this._updateScrollOffset();
                    }
                });
            }
        };
        IgxGridForOfDirective.prototype.handleCacheChanges = function (changes) {
            var _this = this;
            var identityChanges = [];
            var newHeightCache = [];
            var newSizesCache = [];
            newSizesCache.push(0);
            var newHeight = 0;
            // When there are more than one removed items the changes are not reliable so those with identity change should be default size.
            var numRemovedItems = 0;
            changes.forEachRemovedItem(function () { return numRemovedItems++; });
            // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.
            changes.forEachIdentityChange(function (item) {
                if (item.currentIndex !== item.previousIndex) {
                    // Filter out ones that have not changed their index.
                    identityChanges[item.currentIndex] = item;
                }
            });
            // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.
            changes.forEachItem(function (item) {
                if (item.previousIndex !== null &&
                    (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])) {
                    // Reuse cache on those who have previousIndex.
                    // When there are more than one removed items currently the changes are not readable so ones with identity change
                    // should be racalculated.
                    newHeightCache[item.currentIndex] = _this.heightCache[item.previousIndex];
                }
                else {
                    // Assign default item size.
                    newHeightCache[item.currentIndex] = _this.getItemSize(item.item);
                }
                newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];
                newHeight += newHeightCache[item.currentIndex];
            });
            this.heightCache = newHeightCache;
            this.sizesCache = newSizesCache;
            return newHeight;
        };
        IgxGridForOfDirective.prototype.addLastElem = function () {
            var elemIndex = this.state.startIndex + this.state.chunkSize;
            if (!this.isRemote && !this.igxForOf) {
                return;
            }
            if (elemIndex >= this.igxForOf.length) {
                elemIndex = this.igxForOf.length - this.state.chunkSize;
            }
            var input = this.igxForOf[elemIndex];
            var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
            this._embeddedViews.push(embeddedView);
            this.state.chunkSize++;
        };
        IgxGridForOfDirective.prototype._updateViews = function (prevChunkSize) {
            if (this.igxForOf && this.igxForOf.length && this.dc) {
                var embeddedViewCopy = Object.assign([], this._embeddedViews);
                var startIndex = void 0;
                var endIndex = void 0;
                if (this.isRemote) {
                    startIndex = 0;
                    endIndex = this.igxForOf.length;
                }
                else {
                    startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache);
                    if (startIndex + this.state.chunkSize > this.igxForOf.length) {
                        startIndex = this.igxForOf.length - this.state.chunkSize;
                    }
                    this.state.startIndex = startIndex;
                    endIndex = this.state.chunkSize + this.state.startIndex;
                }
                for (var i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                    var embView = embeddedViewCopy.shift();
                    this.updateTemplateContext(embView.context, i);
                }
                if (prevChunkSize !== this.state.chunkSize) {
                    this.onChunkLoad.emit(this.state);
                }
            }
        };
        IgxGridForOfDirective.prototype._applyChanges = function () {
            var prevChunkSize = this.state.chunkSize;
            this.applyChunkSizeChange();
            this._recalcScrollBarSize();
            this._updateViews(prevChunkSize);
        };
        /**
         * @hidden
         */
        IgxGridForOfDirective.prototype._calcMaxChunkSize = function () {
            if (this.syncService.isMaster(this)) {
                return _super.prototype._calcMaxChunkSize.call(this);
            }
            return this.syncService.chunkSize(this.igxForScrollOrientation);
        };
        return IgxGridForOfDirective;
    }(IgxForOfDirective));
    IgxGridForOfDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxGridFor][igxGridForOf]'
                },] }
    ];
    IgxGridForOfDirective.ctorParameters = function () { return [
        { type: i0.ViewContainerRef },
        { type: i0.TemplateRef },
        { type: i0.IterableDiffers },
        { type: i0.ComponentFactoryResolver },
        { type: i0.ChangeDetectorRef },
        { type: i0.NgZone },
        { type: PlatformUtil },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: IgxForOfScrollSyncService },
        { type: IgxForOfSyncService }
    ]; };
    IgxGridForOfDirective.propDecorators = {
        igxGridForOf: [{ type: i0.Input }],
        onDataChanging: [{ type: i0.Output }]
    };
    /**
     * @hidden
     */
    var IgxForOfModule = /** @class */ (function () {
        function IgxForOfModule() {
        }
        return IgxForOfModule;
    }());
    IgxForOfModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxForOfDirective, IgxGridForOfDirective, DisplayContainerComponent, VirtualHelperComponent,
                        HVirtualHelperComponent, VirtualHelperBaseDirective],
                    entryComponents: [DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent],
                    exports: [IgxForOfDirective, IgxGridForOfDirective],
                    imports: [IgxScrollInertiaModule, i2.CommonModule]
                },] }
    ];

    /**
     * **Ignite UI for Angular DropDown** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/drop-down)
     *
     * The Ignite UI for Angular Drop Down displays a scrollable list of items which may be visually grouped and
     * supports selection of a single item. Clicking or tapping an item selects it and closes the Drop Down
     *
     * Example:
     * ```html
     * <igx-drop-down>
     *   <igx-drop-down-item *ngFor="let item of items" disabled={{item.disabled}} isHeader={{item.header}}>
     *     {{ item.value }}
     *   </igx-drop-down-item>
     * </igx-drop-down>
     * ```
     */
    var IgxDropDownComponent = /** @class */ (function (_super) {
        __extends(IgxDropDownComponent, _super);
        function IgxDropDownComponent(elementRef, cdr, selection, _displayDensityOptions) {
            var _this = _super.call(this, elementRef, cdr, _displayDensityOptions) || this;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            _this.selection = selection;
            _this._displayDensityOptions = _displayDensityOptions;
            /**
             * Emitted before the dropdown is opened
             *
             * ```html
             * <igx-drop-down (onOpening)='handleOpening()'></igx-drop-down>
             * ```
             */
            _this.onOpening = new i0.EventEmitter();
            /**
             * Emitted after the dropdown is opened
             *
             * ```html
             * <igx-drop-down (onOpened)='handleOpened()'></igx-drop-down>
             * ```
             */
            _this.onOpened = new i0.EventEmitter();
            /**
             * Emitted before the dropdown is closed
             *
             * ```html
             * <igx-drop-down (onClosing)='handleClosing()'></igx-drop-down>
             * ```
             */
            _this.onClosing = new i0.EventEmitter();
            /**
             * Emitted after the dropdown is closed
             *
             * ```html
             * <igx-drop-down (onClosed)='handleClosed()'></igx-drop-down>
             * ```
             */
            _this.onClosed = new i0.EventEmitter();
            /**
             * Gets/sets whether items take focus. Disabled by default.
             * When enabled, drop down items gain tab index and are focused when active -
             * this includes activating the selected item when opening the drop down and moving with keyboard navigation.
             *
             * Note: Keep that focus shift in mind when using the igxDropDownItemNavigation directive
             * and ensure it's placed either on each focusable item or a common ancestor to allow it to handle keyboard events.
             *
             * ```typescript
             * // get
             * let dropDownAllowsItemFocus = this.dropdown.allowItemsFocus;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-drop-down [allowItemsFocus]='true'></igx-drop-down>
             * ```
             */
            _this.allowItemsFocus = false;
            _this.destroy$ = new rxjs.Subject();
            return _this;
        }
        Object.defineProperty(IgxDropDownComponent.prototype, "focusedItem", {
            /**
             * @hidden @internal
             */
            get: function () {
                var _this = this;
                if (this.virtDir) {
                    return this._focusedItem && this._focusedItem.index !== -1 ?
                        (this.children.find(function (e) { return e.index === _this._focusedItem.index; }) || null) :
                        null;
                }
                return this._focusedItem;
            },
            set: function (value) {
                if (!value) {
                    this.selection.clear(this.id + "-active");
                    this._focusedItem = null;
                    return;
                }
                this._focusedItem = value;
                if (this.virtDir) {
                    this._focusedItem = {
                        value: value.value,
                        index: value.index
                    };
                }
                this.selection.set(this.id + "-active", new Set([this._focusedItem]));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownComponent.prototype, "id", {
            get: function () {
                return this._id;
            },
            set: function (value) {
                this.selection.set(value, this.selection.get(this.id));
                this.selection.clear(this.id);
                this.selection.set(value, this.selection.get(this.id + "-active"));
                this.selection.clear(this.id + "-active");
                this._id = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownComponent.prototype, "listId", {
            /** Id of the internal listbox of the drop down */
            get: function () {
                return this.id + '-list';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownComponent.prototype, "selectedItem", {
            /**
             * Get currently selected item
             *
             * ```typescript
             * let currentItem = this.dropdown.selectedItem;
             * ```
             */
            get: function () {
                var selectedItem = this.selection.first_item(this.id);
                if (selectedItem) {
                    return selectedItem;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownComponent.prototype, "collapsed", {
            /**
             * Gets if the dropdown is collapsed
             *
             * ```typescript
             * let isCollapsed = this.dropdown.collapsed;
             * ```
             */
            get: function () {
                return this.toggleDirective.collapsed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownComponent.prototype, "scrollContainer", {
            /** @hidden @internal */
            get: function () {
                return this.scrollContainerRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDownComponent.prototype, "collectionLength", {
            get: function () {
                if (this.virtDir) {
                    return this.virtDir.totalItemCount || this.virtDir.igxForOf.length;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Opens the dropdown
         *
         * ```typescript
         * this.dropdown.open();
         * ```
         */
        IgxDropDownComponent.prototype.open = function (overlaySettings) {
            this.toggleDirective.open(overlaySettings);
            this.updateScrollPosition();
        };
        /**
         * Closes the dropdown
         *
         * ```typescript
         * this.dropdown.close();
         * ```
         */
        IgxDropDownComponent.prototype.close = function () {
            this.toggleDirective.close();
        };
        /**
         * Toggles the dropdown
         *
         * ```typescript
         * this.dropdown.toggle();
         * ```
         */
        IgxDropDownComponent.prototype.toggle = function (overlaySettings) {
            if (this.collapsed || this.toggleDirective.isClosing) {
                this.open(overlaySettings);
            }
            else {
                this.close();
            }
        };
        /**
         * Select an item by index
         *
         * @param index of the item to select; If the drop down uses *igxFor, pass the index in data
         */
        IgxDropDownComponent.prototype.setSelectedItem = function (index) {
            if (index < 0 || index >= this.items.length) {
                return;
            }
            var newSelection;
            if (this.virtDir) {
                newSelection = {
                    value: this.virtDir.igxForOf[index],
                    index: index
                };
            }
            else {
                newSelection = this.items[index];
            }
            this.selectItem(newSelection);
        };
        /**
         * Navigates to the item on the specified index
         * If the data in the drop-down is virtualized, pass the index of the item in the virtualized data.
         *
         * @param newIndex number
         */
        IgxDropDownComponent.prototype.navigateItem = function (index) {
            var _this = this;
            if (this.virtDir) {
                if (index === -1 || index >= this.collectionLength) {
                    return;
                }
                var direction_1 = index > (this.focusedItem ? this.focusedItem.index : -1) ? Navigate.Down : Navigate.Up;
                var subRequired = this.isIndexOutOfBounds(index, direction_1);
                this.focusedItem = {
                    value: this.virtDir.igxForOf[index],
                    index: index
                };
                if (subRequired) {
                    this.virtDir.scrollTo(index);
                }
                if (subRequired) {
                    this.virtDir.onChunkLoad.pipe(operators.take(1)).subscribe(function () {
                        _this.skipHeader(direction_1);
                    });
                }
                else {
                    this.skipHeader(direction_1);
                }
            }
            else {
                _super.prototype.navigateItem.call(this, index);
            }
            if (this.allowItemsFocus && this.focusedItem) {
                this.focusedItem.element.nativeElement.focus();
                this.cdr.markForCheck();
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.updateScrollPosition = function () {
            if (!this.virtDir) {
                return;
            }
            if (!this.selectedItem) {
                this.virtDir.scrollTo(0);
                return;
            }
            var targetScroll = this.virtDir.getScrollForIndex(this.selectedItem.index);
            var itemsInView = this.virtDir.igxForContainerSize / this.virtDir.igxForItemSize;
            targetScroll -= (itemsInView / 2 - 1) * this.virtDir.igxForItemSize;
            this.virtDir.getScroll().scrollTop = targetScroll;
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.onToggleOpening = function (e) {
            // do not mutate passed event args
            var eventArgs = Object.assign({}, e, { owner: this });
            this.onOpening.emit(eventArgs);
            e.cancel = eventArgs.cancel;
            if (e.cancel) {
                return;
            }
            if (this.virtDir) {
                this.virtDir.scrollPosition = this._scrollPosition;
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.onToggleContentAppended = function () {
            if (!this.virtDir && this.selectedItem) {
                this.scrollToItem(this.selectedItem);
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.onToggleOpened = function () {
            this.updateItemFocus();
            this.onOpened.emit();
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.onToggleClosing = function (e) {
            var eventArgs = Object.assign({}, e, { owner: this });
            this.onClosing.emit(eventArgs);
            e.cancel = eventArgs.cancel;
            if (e.cancel) {
                return;
            }
            if (this.virtDir) {
                this._scrollPosition = this.virtDir.scrollPosition;
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.onToggleClosed = function () {
            this.focusItem(false);
            this.onClosed.emit();
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
            this.selection.clear(this.id);
            this.selection.clear(this.id + "-active");
        };
        /** @hidden @internal */
        IgxDropDownComponent.prototype.calculateScrollPosition = function (item) {
            if (!item) {
                return 0;
            }
            var elementRect = item.element.nativeElement.getBoundingClientRect();
            var parentRect = this.scrollContainer.getBoundingClientRect();
            var scrollDelta = parentRect.top - elementRect.top;
            var scrollPosition = this.scrollContainer.scrollTop - scrollDelta;
            var dropDownHeight = this.scrollContainer.clientHeight;
            scrollPosition -= dropDownHeight / 2;
            scrollPosition += item.elementHeight / 2;
            return Math.floor(scrollPosition);
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.ngOnChanges = function (changes) {
            if (changes.id) {
                // temp workaround until fix --> https://github.com/angular/angular/issues/34992
                this.toggleDirective.id = changes.id.currentValue;
            }
        };
        IgxDropDownComponent.prototype.ngAfterViewInit = function () {
            if (this.virtDir) {
                this.virtDir.igxForItemSize = 28;
            }
        };
        /** Keydown Handler */
        IgxDropDownComponent.prototype.onItemActionKey = function (key, event) {
            _super.prototype.onItemActionKey.call(this, key, event);
            this.close();
        };
        /**
         * Virtual scroll implementation
         *
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.navigateFirst = function () {
            if (this.virtDir) {
                this.navigateItem(0);
            }
            else {
                _super.prototype.navigateFirst.call(this);
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.navigateLast = function () {
            if (this.virtDir) {
                this.navigateItem(this.virtDir.totalItemCount ? this.virtDir.totalItemCount - 1 : this.virtDir.igxForOf.length - 1);
            }
            else {
                _super.prototype.navigateLast.call(this);
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.navigateNext = function () {
            if (this.virtDir) {
                this.navigateItem(this._focusedItem ? this._focusedItem.index + 1 : 0);
            }
            else {
                _super.prototype.navigateNext.call(this);
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.navigatePrev = function () {
            if (this.virtDir) {
                this.navigateItem(this._focusedItem ? this._focusedItem.index - 1 : 0);
            }
            else {
                _super.prototype.navigatePrev.call(this);
            }
        };
        /**
         * Handles the `onSelection` emit and the drop down toggle when selection changes
         *
         * @hidden
         * @internal
         * @param newSelection
         * @param event
         */
        IgxDropDownComponent.prototype.selectItem = function (newSelection, event) {
            var oldSelection = this.selectedItem;
            if (!newSelection) {
                newSelection = this.focusedItem;
            }
            if (newSelection === null) {
                return;
            }
            if (newSelection instanceof IgxDropDownItemBaseDirective && newSelection.isHeader) {
                return;
            }
            if (this.virtDir) {
                newSelection = {
                    value: newSelection.value,
                    index: newSelection.index
                };
            }
            var args = { oldSelection: oldSelection, newSelection: newSelection, cancel: false };
            this.onSelection.emit(args);
            if (!args.cancel) {
                if (this.isSelectionValid(args.newSelection)) {
                    this.selection.set(this.id, new Set([args.newSelection]));
                    if (!this.virtDir) {
                        if (oldSelection) {
                            oldSelection.selected = false;
                        }
                        if (args.newSelection) {
                            args.newSelection.selected = true;
                        }
                    }
                    if (event) {
                        this.toggleDirective.close();
                    }
                }
                else {
                    throw new Error('Please provide a valid drop-down item for the selection!');
                }
            }
        };
        /**
         * Clears the selection of the dropdown
         * ```typescript
         * this.dropdown.clearSelection();
         * ```
         */
        IgxDropDownComponent.prototype.clearSelection = function () {
            var oldSelection = this.selectedItem;
            var newSelection = null;
            var args = { oldSelection: oldSelection, newSelection: newSelection, cancel: false };
            this.onSelection.emit(args);
            if (this.selectedItem && !args.cancel) {
                this.selectedItem.selected = false;
                this.selection.clear(this.id);
            }
        };
        /**
         * Checks whether the selection is valid
         * `null` - the selection should be emptied
         * Virtual? - the selection should at least have and `index` and `value` property
         * Non-virtual? - the selection should be a valid drop-down item and **not** be a header
         */
        IgxDropDownComponent.prototype.isSelectionValid = function (selection) {
            return selection === null
                || (this.virtDir && selection.hasOwnProperty('value') && selection.hasOwnProperty('index'))
                || (selection instanceof IgxDropDownItemComponent && !selection.isHeader);
        };
        IgxDropDownComponent.prototype.scrollToItem = function (item) {
            var _this = this;
            var itemPosition = this.calculateScrollPosition(item);
            //  in IE11 setting sctrollTop is somehow slow and forces dropdown
            //  to appear on screen before animation start. As a result dropdown
            //  flickers badly. This is why we set scrollTop just a little later
            //  allowing animation to start and prevent dropdown flickering
            if (isIE()) {
                setTimeout(function () {
                    _this.scrollContainer.scrollTop = (itemPosition);
                }, 1);
            }
            else {
                this.scrollContainer.scrollTop = (itemPosition);
            }
        };
        IgxDropDownComponent.prototype.focusItem = function (value) {
            if (value || this._focusedItem) {
                this._focusedItem.focused = value;
            }
        };
        IgxDropDownComponent.prototype.updateItemFocus = function () {
            if (this.selectedItem) {
                this.focusedItem = this.selectedItem;
                this.focusItem(true);
            }
            else if (this.allowItemsFocus) {
                this.navigateFirst();
            }
        };
        IgxDropDownComponent.prototype.skipHeader = function (direction) {
            if (!this.focusedItem) {
                return;
            }
            if (this.focusedItem.isHeader || this.focusedItem.disabled) {
                if (direction === Navigate.Up) {
                    this.navigatePrev();
                }
                else {
                    this.navigateNext();
                }
            }
        };
        IgxDropDownComponent.prototype.isIndexOutOfBounds = function (index, direction) {
            var virtState = this.virtDir.state;
            var currentPosition = this.virtDir.getScroll().scrollTop;
            var itemPosition = this.virtDir.getScrollForIndex(index, direction === Navigate.Down);
            var indexOutOfChunk = index < virtState.startIndex || index > virtState.chunkSize + virtState.startIndex;
            var scrollNeeded = direction === Navigate.Down ? currentPosition < itemPosition : currentPosition > itemPosition;
            var subRequired = indexOutOfChunk || scrollNeeded;
            return subRequired;
        };
        return IgxDropDownComponent;
    }(IgxDropDownBaseDirective));
    IgxDropDownComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-drop-down',
                    template: "<div class=\"igx-drop-down__list\" [style.width]=\"width\"\nigxToggle\n(onAppended)=\"onToggleContentAppended()\"\n(onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n(onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <div class=\"igx-drop-down__list-scroll\" #scrollContainer [attr.id]=\"this.listId\" role=\"listbox\"\n    [style.height]=\"height\"\n    [style.maxHeight]=\"maxHeight\">\n        <ng-container *ngIf=\"!collapsed\">\n            <ng-content></ng-content>\n        </ng-container>\n    </div>\n</div>\n",
                    providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxDropDownComponent }]
                },] }
    ];
    IgxDropDownComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: IgxSelectionAPIService },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxDropDownComponent.propDecorators = {
        children: [{ type: i0.ContentChildren, args: [i0.forwardRef(function () { return IgxDropDownItemComponent; }), { descendants: true },] }],
        onOpening: [{ type: i0.Output }],
        onOpened: [{ type: i0.Output }],
        onClosing: [{ type: i0.Output }],
        onClosed: [{ type: i0.Output }],
        allowItemsFocus: [{ type: i0.Input }],
        virtDir: [{ type: i0.ContentChild, args: [IgxForOfDirective, { read: IgxForOfDirective },] }],
        toggleDirective: [{ type: i0.ViewChild, args: [IgxToggleDirective, { static: true },] }],
        scrollContainerRef: [{ type: i0.ViewChild, args: ['scrollContainer', { static: true },] }]
    };

    /**
     * Navigation Directive that handles keyboard events on its host and controls a targeted IgxDropDownBaseDirective component
     */
    var IgxDropDownItemNavigationDirective = /** @class */ (function () {
        function IgxDropDownItemNavigationDirective(dropdown) {
            this.dropdown = dropdown;
            this._target = null;
        }
        Object.defineProperty(IgxDropDownItemNavigationDirective.prototype, "target", {
            /**
             * Gets the target of the navigation directive;
             *
             * ```typescript
             * // Get
             * export class MyComponent {
             *  ...
             *  @ContentChild(IgxDropDownNavigationDirective)
             *  navDirective: IgxDropDownNavigationDirective = null
             *  ...
             *  const navTarget: IgxDropDownBaseDirective = navDirective.navTarget
             * }
             * ```
             */
            get: function () {
                return this._target;
            },
            /**
             * Sets the target of the navigation directive;
             * If no valid target is passed, it falls back to the drop down context
             *
             * ```html
             * <!-- Set -->
             * <input [igxDropDownItemNavigation]="dropdown" />
             * ...
             * <igx-drop-down #dropdown>
             * ...
             * </igx-drop-down>
             * ```
             */
            set: function (target) {
                this._target = target ? target : this.dropdown;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Captures keydown events and calls the appropriate handlers on the target component
         */
        IgxDropDownItemNavigationDirective.prototype.handleKeyDown = function (event) {
            if (event) {
                var key = event.key.toLowerCase();
                if (!this.target.collapsed) { // If dropdown is opened
                    var navKeys = ['esc', 'escape', 'enter', 'space', 'spacebar', ' ',
                        'arrowup', 'up', 'arrowdown', 'down', 'home', 'end'];
                    if (navKeys.indexOf(key) === -1) { // If key has appropriate function in DD
                        return;
                    }
                    event.preventDefault();
                    event.stopPropagation();
                }
                else { // If dropdown is closed, do nothing
                    return;
                }
                switch (key) {
                    case 'esc':
                    case 'escape':
                        this.target.onItemActionKey(DropDownActionKey.ESCAPE, event);
                        break;
                    case 'enter':
                        this.target.onItemActionKey(DropDownActionKey.ENTER, event);
                        break;
                    case 'space':
                    case 'spacebar':
                    case ' ':
                        this.target.onItemActionKey(DropDownActionKey.SPACE, event);
                        break;
                    case 'arrowup':
                    case 'up':
                        this.onArrowUpKeyDown();
                        break;
                    case 'arrowdown':
                    case 'down':
                        this.onArrowDownKeyDown();
                        break;
                    case 'home':
                        this.onHomeKeyDown();
                        break;
                    case 'end':
                        this.onEndKeyDown();
                        break;
                    default:
                        return;
                }
            }
        };
        /**
         * Navigates to previous item
         */
        IgxDropDownItemNavigationDirective.prototype.onArrowDownKeyDown = function () {
            this.target.navigateNext();
        };
        /**
         * Navigates to previous item
         */
        IgxDropDownItemNavigationDirective.prototype.onArrowUpKeyDown = function () {
            this.target.navigatePrev();
        };
        /**
         * Navigates to target's last item
         */
        IgxDropDownItemNavigationDirective.prototype.onEndKeyDown = function () {
            this.target.navigateLast();
        };
        /**
         * Navigates to target's first item
         */
        IgxDropDownItemNavigationDirective.prototype.onHomeKeyDown = function () {
            this.target.navigateFirst();
        };
        return IgxDropDownItemNavigationDirective;
    }());
    IgxDropDownItemNavigationDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDropDownItemNavigation]'
                },] }
    ];
    IgxDropDownItemNavigationDirective.ctorParameters = function () { return [
        { type: IgxDropDownBaseDirective, decorators: [{ type: i0.Self }, { type: i0.Optional }, { type: i0.Inject, args: [IGX_DROPDOWN_BASE,] }] }
    ]; };
    IgxDropDownItemNavigationDirective.propDecorators = {
        target: [{ type: i0.Input, args: ['igxDropDownItemNavigation',] }],
        handleKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
    };

    /**
     * @hidden
     */
    var IgxDropDownModule = /** @class */ (function () {
        function IgxDropDownModule() {
        }
        return IgxDropDownModule;
    }());
    IgxDropDownModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxDropDownComponent,
                        IgxDropDownItemBaseDirective,
                        IgxDropDownItemComponent,
                        IgxDropDownGroupComponent,
                        IgxDropDownItemNavigationDirective
                    ],
                    exports: [
                        IgxDropDownComponent,
                        IgxDropDownItemComponent,
                        IgxDropDownGroupComponent,
                        IgxDropDownItemNavigationDirective
                    ],
                    imports: [
                        i2.CommonModule,
                        IgxToggleModule
                    ]
                },] }
    ];

    var IgxHintPosition;
    (function (IgxHintPosition) {
        IgxHintPosition[IgxHintPosition["START"] = 0] = "START";
        IgxHintPosition[IgxHintPosition["END"] = 1] = "END";
    })(IgxHintPosition || (IgxHintPosition = {}));
    var IgxHintDirective = /** @class */ (function () {
        function IgxHintDirective() {
            /**
             * Sets/gets whether the hint position is at the start.
             * Default value is `false`.
             * ```typescript
             * @ViewChild('hint', {read: IgxHintDirective})
             * public igxHint: IgxHintDirective;
             * this.igxHint.isPositionStart = true;
             * ```
             * ```typescript
             * let isHintPositionStart = this.igxHint.isPositionStart;
             * ```
             *
             * @memberof IgxHintDirective
             */
            this.isPositionStart = false;
            /**
             * Sets/gets whether the hint position is at the end.
             * Default value is `false`.
             * ```typescript
             * @ViewChild('hint', {read: IgxHintDirective})
             * public igxHint: IgxHintDirective;
             * this.igxHint.isPositionEnd = true;
             * ```
             * ```typescript
             * let isHintPositionEnd = this.igxHint.isPositionEnd;
             * ```
             *
             * @memberof IgxHintDirective
             */
            this.isPositionEnd = false;
            this._position = IgxHintPosition.START;
        }
        Object.defineProperty(IgxHintDirective.prototype, "position", {
            /**
             * Gets the position of the hint.
             * ```typescript
             * @ViewChild('hint', {read: IgxHintDirective})
             * public igxHint: IgxHintDirective;
             * let hintPosition =  this.igxHint.position;
             * ```
             *
             * @memberof IgxHintDirective
             */
            get: function () {
                return this._position.toString();
            },
            /**
             * Sets the position of the hint.
             * ```html
             * <igx-input-group>
             *  <input igxInput type="text"/>
             *  <igx-hint #hint [position]="'start'">IgxHint displayed at the start</igx-hint>
             * </igx-input-group>
             * ```
             *
             * @memberof IgxHintDirective
             */
            set: function (value) {
                var position = IgxHintPosition[value.toUpperCase()];
                if (position !== undefined) {
                    this._position = position;
                    this._applyPosition(this._position);
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxHintDirective.prototype.ngOnInit = function () {
            this._applyPosition(this._position);
        };
        IgxHintDirective.prototype._applyPosition = function (position) {
            this.isPositionStart = this.isPositionEnd = false;
            switch (position) {
                case IgxHintPosition.START:
                    this.isPositionStart = true;
                    break;
                case IgxHintPosition.END:
                    this.isPositionEnd = true;
                    break;
                default: break;
            }
        };
        return IgxHintDirective;
    }());
    IgxHintDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'igx-hint,[igxHint]'
                },] }
    ];
    IgxHintDirective.propDecorators = {
        isPositionStart: [{ type: i0.HostBinding, args: ['class.igx-input-group__hint-item--start',] }],
        isPositionEnd: [{ type: i0.HostBinding, args: ['class.igx-input-group__hint-item--end',] }],
        position: [{ type: i0.Input, args: ['position',] }]
    };

    /** @hidden */
    var IgxInputGroupBase = /** @class */ (function () {
        function IgxInputGroupBase() {
        }
        return IgxInputGroupBase;
    }());

    var nativeValidationAttributes = [
        'required',
        'pattern',
        'minlength',
        'maxlength',
        'min',
        'max',
        'step',
    ];
    (function (IgxInputState) {
        IgxInputState[IgxInputState["INITIAL"] = 0] = "INITIAL";
        IgxInputState[IgxInputState["VALID"] = 1] = "VALID";
        IgxInputState[IgxInputState["INVALID"] = 2] = "INVALID";
    })(exports.IgxInputState || (exports.IgxInputState = {}));
    /**
     * The `igxInput` directive creates single- or multiline text elements, covering common scenarios when dealing with form inputs.
     *
     * @igxModule IgxInputGroupModule
     *
     * @igxParent Data Entry & Display
     *
     * @igxTheme igx-input-group-theme
     *
     * @igxKeywords input, input group, form, field, validation
     *
     * @igxGroup presentation
     *
     * @example
     * ```html
     * <input-group>
     *  <label for="address">Address</label>
     *  <input igxInput name="address" type="text" [(ngModel)]="customer.address">
     * </input-group>
     * ```
     */
    var IgxInputDirective = /** @class */ (function () {
        function IgxInputDirective(inputGroup, ngModel, formControl, element, cdr) {
            this.inputGroup = inputGroup;
            this.ngModel = ngModel;
            this.formControl = formControl;
            this.element = element;
            this.cdr = cdr;
            /**
             * Sets/gets whether the `"igx-input-group__input"` class is added to the host element.
             * Default value is `false`.
             *
             * @example
             * ```typescript
             * this.igxInput.isInput = true;
             * ```
             *
             * @example
             * ```typescript
             * let isCLassAdded = this.igxInput.isInput;
             * ```
             */
            this.isInput = false;
            /**
             * Sets/gets whether the `"class.igx-input-group__textarea"` class is added to the host element.
             * Default value is `false`.
             *
             * @example
             * ```typescript
             * this.igxInput.isTextArea = true;
             * ```
             *
             * @example
             * ```typescript
             * let isCLassAdded = this.igxInput.isTextArea;
             * ```
             */
            this.isTextArea = false;
            this._valid = exports.IgxInputState.INITIAL;
        }
        Object.defineProperty(IgxInputDirective.prototype, "ngControl", {
            get: function () {
                return this.ngModel ? this.ngModel : this.formControl;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputDirective.prototype, "value", {
            /**
             * Gets the `value` property.
             *
             * @example
             * ```typescript
             * @ViewChild('igxInput', {read: IgxInputDirective})
             *  public igxInput: IgxInputDirective;
             * let inputValue = this.igxInput.value;
             * ```
             */
            get: function () {
                return this.nativeElement.value;
            },
            /**
             * Sets the `value` property.
             *
             * @example
             * ```html
             * <input-group>
             *  <input igxInput #igxInput [value]="'IgxInput Value'">
             * </input-group>
             * ```
             */
            set: function (value) {
                this.nativeElement.value = value !== null && value !== void 0 ? value : '';
                this.updateValidityState();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputDirective.prototype, "disabled", {
            /**
             * Gets the `disabled` property
             *
             * @example
             * ```typescript
             * @ViewChild('igxInput', {read: IgxInputDirective})
             *  public igxInput: IgxInputDirective;
             * let isDisabled = this.igxInput.disabled;
             * ```
             */
            get: function () {
                return this.nativeElement.hasAttribute('disabled');
            },
            /**
             * Sets the `disabled` property.
             *
             * @example
             * ```html
             * <input-group>
             *  <input igxInput #igxInput [disabled]="true">
             * </input-group>
             * ```
             */
            set: function (value) {
                this.nativeElement.disabled = value;
                this.inputGroup.disabled = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputDirective.prototype, "required", {
            /**
             * Gets whether the igxInput is required.
             *
             * @example
             * ```typescript
             * let isRequired = this.igxInput.required;
             * ```
             */
            get: function () {
                return this.nativeElement.hasAttribute('required');
            },
            /**
             * Sets the `required` property.
             *
             * @example
             * ```html
             * <input-group>
             *  <input igxInput #igxInput [required]="true">
             * </input-group>
             * ```
             */
            set: function (value) {
                this.nativeElement.required = this.inputGroup.isRequired = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxInputDirective.prototype.onFocus = function () {
            this.inputGroup.isFocused = true;
        };
        /**
         * @param event The event to invoke the handler
         *
         * @hidden
         * @internal
         */
        IgxInputDirective.prototype.onBlur = function () {
            this.inputGroup.isFocused = false;
            this.updateValidityState();
        };
        /** @hidden @internal */
        IgxInputDirective.prototype.onInput = function () {
            this.checkNativeValidity();
        };
        /** @hidden @internal */
        IgxInputDirective.prototype.change = function (event) {
            var e_1, _a;
            if (this.type === 'file') {
                var fileList = event.target
                    .files;
                var fileArray = [];
                if (fileList) {
                    try {
                        for (var _b = __values(Array.from(fileList)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var file = _c.value;
                            fileArray.push(file);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                this._fileNames = (fileArray || []).map(function (f) { return f.name; }).join(', ');
                if (this.required && (fileList === null || fileList === void 0 ? void 0 : fileList.length) > 0) {
                    this._valid = exports.IgxInputState.INITIAL;
                }
            }
        };
        Object.defineProperty(IgxInputDirective.prototype, "fileNames", {
            /** @hidden @internal */
            get: function () {
                return this._fileNames;
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden @internal */
        IgxInputDirective.prototype.clear = function () {
            this.nativeElement.value = null;
            this._fileNames = '';
        };
        /** @hidden @internal */
        IgxInputDirective.prototype.ngAfterViewInit = function () {
            this.inputGroup.hasPlaceholder = this.nativeElement.hasAttribute('placeholder');
            this.inputGroup.disabled =
                this.inputGroup.disabled ||
                    this.nativeElement.hasAttribute('disabled');
            this.inputGroup.isRequired = this.nativeElement.hasAttribute('required');
            // Make sure we do not invalidate the input on init
            if (!this.ngControl) {
                this._valid = exports.IgxInputState.INITIAL;
            }
            // Also check the control's validators for required
            if (!this.inputGroup.isRequired &&
                this.ngControl &&
                this.ngControl.control.validator) {
                var validation = this.ngControl.control.validator({});
                this.inputGroup.isRequired = validation && validation.required;
            }
            var elTag = this.nativeElement.tagName.toLowerCase();
            if (elTag === 'textarea') {
                this.isTextArea = true;
            }
            else {
                this.isInput = true;
            }
            if (this.ngControl) {
                this._statusChanges$ = this.ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
            }
            this.cdr.detectChanges();
        };
        /** @hidden @internal */
        IgxInputDirective.prototype.ngOnDestroy = function () {
            if (this._statusChanges$) {
                this._statusChanges$.unsubscribe();
            }
        };
        /**
         * Sets a focus on the igxInput.
         *
         * @example
         * ```typescript
         * this.igxInput.focus();
         * ```
         */
        IgxInputDirective.prototype.focus = function () {
            this.nativeElement.focus();
        };
        Object.defineProperty(IgxInputDirective.prototype, "nativeElement", {
            /**
             * Gets the `nativeElement` of the igxInput.
             *
             * @example
             * ```typescript
             * let igxInputNativeElement = this.igxInput.nativeElement;
             * ```
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden @internal */
        IgxInputDirective.prototype.onStatusChanged = function () {
            // Enable/Disable control based on ngControl #7086
            if (this.disabled !== this.ngControl.disabled) {
                this.disabled = this.ngControl.disabled;
            }
            this.updateValidityState();
        };
        /**
         * @hidden
         * @internal
         */
        IgxInputDirective.prototype.updateValidityState = function () {
            if (this.ngControl) {
                if (this.ngControl.control.validator || this.ngControl.control.asyncValidator) {
                    if (!this.disabled && (this.ngControl.control.touched || this.ngControl.control.dirty)) {
                        // the control is not disabled and is touched or dirty
                        this._valid = this.ngControl.invalid ?
                            exports.IgxInputState.INVALID : this.focused ? exports.IgxInputState.VALID :
                            exports.IgxInputState.INITIAL;
                    }
                    else {
                        //  if control is untouched, pristine, or disabled its state is initial. This is when user did not interact
                        //  with the input or when form/control is reset
                        this._valid = exports.IgxInputState.INITIAL;
                    }
                }
            }
            else {
                this.checkNativeValidity();
            }
        };
        Object.defineProperty(IgxInputDirective.prototype, "hasPlaceholder", {
            /**
             * Gets whether the igxInput has a placeholder.
             *
             * @example
             * ```typescript
             * let hasPlaceholder = this.igxInput.hasPlaceholder;
             * ```
             */
            get: function () {
                return this.nativeElement.hasAttribute('placeholder');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputDirective.prototype, "placeholder", {
            /**
             * Gets the placeholder element of the igxInput.
             *
             * @example
             * ```typescript
             * let igxInputPlaceholder = this.igxInput.placeholder;
             * ```
             */
            get: function () {
                return this.nativeElement.placeholder;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @returns An indicator of whether the input has validator attributes or not
         *
         * @hidden
         * @internal
         */
        IgxInputDirective.prototype._hasValidators = function () {
            var e_2, _a;
            try {
                for (var nativeValidationAttributes_1 = __values(nativeValidationAttributes), nativeValidationAttributes_1_1 = nativeValidationAttributes_1.next(); !nativeValidationAttributes_1_1.done; nativeValidationAttributes_1_1 = nativeValidationAttributes_1.next()) {
                    var nativeValidationAttribute = nativeValidationAttributes_1_1.value;
                    if (this.nativeElement.hasAttribute(nativeValidationAttribute)) {
                        return true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (nativeValidationAttributes_1_1 && !nativeValidationAttributes_1_1.done && (_a = nativeValidationAttributes_1.return)) _a.call(nativeValidationAttributes_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return false;
        };
        Object.defineProperty(IgxInputDirective.prototype, "focused", {
            /**
             * Gets whether the igxInput is focused.
             *
             * @example
             * ```typescript
             * let isFocused = this.igxInput.focused;
             * ```
             */
            get: function () {
                return this.inputGroup.isFocused;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputDirective.prototype, "valid", {
            /**
             * Gets the state of the igxInput.
             *
             * @example
             * ```typescript
             * let igxInputState = this.igxInput.valid;
             * ```
             */
            get: function () {
                return this._valid;
            },
            /**
             * Sets the state of the igxInput.
             *
             * @example
             * ```typescript
             * this.igxInput.valid = IgxInputState.INVALID;
             * ```
             */
            set: function (value) {
                this._valid = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputDirective.prototype, "isValid", {
            /**
             * Gets whether the igxInput is valid.
             *
             * @example
             * ```typescript
             * let valid = this.igxInput.isValid;
             * ```
             */
            get: function () {
                return this.valid !== exports.IgxInputState.INVALID;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * A function to assign a native validity property of an input.
         * This should be used when there's no ngControl
         *
         * @hidden
         * @internal
         */
        IgxInputDirective.prototype.checkNativeValidity = function () {
            if (!this.disabled && this._hasValidators()) {
                this._valid = this.nativeElement.checkValidity() ?
                    this.focused ? exports.IgxInputState.VALID : exports.IgxInputState.INITIAL :
                    exports.IgxInputState.INVALID;
            }
        };
        Object.defineProperty(IgxInputDirective.prototype, "type", {
            /**
             * Returns the input type.
             *
             * @hidden
             * @internal
             */
            get: function () {
                return this.nativeElement.type;
            },
            enumerable: false,
            configurable: true
        });
        return IgxInputDirective;
    }());
    IgxInputDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxInput]',
                    exportAs: 'igxInput',
                },] }
    ];
    IgxInputDirective.ctorParameters = function () { return [
        { type: IgxInputGroupBase },
        { type: forms.NgModel, decorators: [{ type: i0.Optional }, { type: i0.Self }, { type: i0.Inject, args: [forms.NgModel,] }] },
        { type: forms.FormControlName, decorators: [{ type: i0.Optional }, { type: i0.Self }, { type: i0.Inject, args: [forms.FormControlName,] }] },
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxInputDirective.propDecorators = {
        isInput: [{ type: i0.HostBinding, args: ['class.igx-input-group__input',] }],
        isTextArea: [{ type: i0.HostBinding, args: ['class.igx-input-group__textarea',] }],
        value: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        required: [{ type: i0.Input }],
        onFocus: [{ type: i0.HostListener, args: ['focus',] }],
        onBlur: [{ type: i0.HostListener, args: ['blur',] }],
        onInput: [{ type: i0.HostListener, args: ['input',] }],
        change: [{ type: i0.HostListener, args: ['change', ['$event'],] }]
    };

    var NEXT_ID$3 = 0;
    var IgxLabelDirective = /** @class */ (function () {
        function IgxLabelDirective() {
            this.defaultClass = true;
            /**
             * @hidden
             */
            this.id = "igx-label-" + NEXT_ID$3++;
        }
        return IgxLabelDirective;
    }());
    IgxLabelDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxLabel]'
                },] }
    ];
    IgxLabelDirective.propDecorators = {
        defaultClass: [{ type: i0.HostBinding, args: ['class.igx-input-group__label',] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }]
    };

    /**
     * The Button directive provides the Ignite UI Button functionality to every component that's intended to be used as a button.
     *
     * @igxModule IgxButtonModule
     *
     * @igxParent Data Entry & Display
     *
     * @igxTheme igx-button-theme
     *
     * @igxKeywords button, span, div, click
     *
     * @remarks
     * The Ignite UI Button directive is intended to be used by any button, span or div and turn it into a fully functional button.
     *
     * @example
     * ```html
     * <button igxButton="outlined">A Button</button>
     * ```
     */
    var IgxButtonDirective = /** @class */ (function (_super) {
        __extends(IgxButtonDirective, _super);
        function IgxButtonDirective(element, _renderer, _displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.element = element;
            _this._renderer = _renderer;
            _this._displayDensityOptions = _displayDensityOptions;
            /**
             * Gets or sets whether the button is selected.
             * Mainly used in the IgxButtonGroup component and it will have no effect if set separately.
             *
             * @example
             * ```html
             * <button igxButton="flat" [selected]="button.selected"></button>
             * ```
             */
            _this.selected = false;
            /**
             * Called when the button is clicked.
             */
            _this.buttonClick = new i0.EventEmitter();
            /**
             * Sets/gets the `role` attribute.
             *
             * @example
             * ```typescript
             * this.button.role = 'navbutton';
             * let buttonRole = this.button.role;
             * ```
             */
            _this.role = 'button';
            /**
             * @hidden
             * @internal
             */
            _this._defaultType = 'flat';
            /**
             * @hidden
             * @internal
             */
            _this._cssClassPrefix = 'igx-button';
            return _this;
        }
        Object.defineProperty(IgxButtonDirective.prototype, "nativeElement", {
            /**
             * Returns the underlying DOM element.
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "type", {
            /**
             * Sets the type of the button.
             *
             * @example
             * ```html
             * <button igxButton="icon"></button>
             * ```
             */
            set: function (value) {
                var newValue = value ? value : this._defaultType;
                if (this._type !== newValue) {
                    this._renderer.removeClass(this.nativeElement, this._cssClassPrefix + "--" + this._type);
                    this._type = newValue;
                    this._renderer.addClass(this.nativeElement, this._cssClassPrefix + "--" + this._type);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "color", {
            /**
             * Sets the button text color.
             *
             * @example
             * ```html
             * <button igxButton="gradient" igxButtonColor="blue"></button>
             * ```
             */
            set: function (value) {
                this._color = value || this.nativeElement.style.color;
                this._renderer.setStyle(this.nativeElement, 'color', this._color);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "background", {
            /**
             * Sets the background color of the button.
             *
             * @example
             *  ```html
             * <button igxButton="raised" igxButtonBackground="red"></button>
             * ```
             */
            set: function (value) {
                this._backgroundColor = value || this._backgroundColor;
                this._renderer.setStyle(this.nativeElement, 'background', this._backgroundColor);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "label", {
            /**
             * Sets the `aria-label` attribute.
             *
             * @example
             *  ```html
             * <button igxButton= "flat" igxLabel="Label"></button>
             * ```
             */
            set: function (value) {
                this._label = value || this._label;
                this._renderer.setAttribute(this.nativeElement, "aria-label", this._label);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "disabled", {
            /**
             * Enables/disables the button.
             *
             * @example
             * ```html
             * <button igxButton= "fab" [disabled]="true"></button>
             * ```
             */
            set: function (val) {
                val = !!val;
                this._disabled = val;
                if (val) {
                    this._renderer.addClass(this.nativeElement, this._cssClassPrefix + "--disabled");
                }
                else {
                    this._renderer.removeClass(this.nativeElement, this._cssClassPrefix + "--disabled");
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "cssClassCosy", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return (this._type === 'flat' || this._type === 'raised') &&
                    this.displayDensity === DisplayDensity.cosy;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "cssClassCompact", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return (this._type === 'flat' || this._type === 'raised') &&
                    this.displayDensity === DisplayDensity.compact;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "cssClassCosyOutlined", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this._type === 'outlined' && this.displayDensity === DisplayDensity.cosy;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "cssClassCompactOutlined", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this._type === 'outlined' && this.displayDensity === DisplayDensity.compact;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "cssClassCosyFab", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this._type === 'fab' && this.displayDensity === DisplayDensity.cosy;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "cssClassCompactFab", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this._type === 'fab' && this.displayDensity === DisplayDensity.compact;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "disabledAttribute", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this._disabled ? this._disabled : null;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxButtonDirective.prototype.onClick = function (ev) {
            this.buttonClick.emit(ev);
        };
        return IgxButtonDirective;
    }(DisplayDensityBase));
    IgxButtonDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxButton]'
                },] }
    ];
    IgxButtonDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxButtonDirective.propDecorators = {
        selected: [{ type: i0.Input }],
        buttonClick: [{ type: i0.Output }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        type: [{ type: i0.Input, args: ['igxButton',] }],
        color: [{ type: i0.Input, args: ['igxButtonColor',] }],
        background: [{ type: i0.Input, args: ['igxButtonBackground',] }],
        label: [{ type: i0.Input, args: ['igxLabel',] }],
        disabled: [{ type: i0.Input }],
        cssClassCosy: [{ type: i0.HostBinding, args: ['class.igx-button--cosy',] }],
        cssClassCompact: [{ type: i0.HostBinding, args: ['class.igx-button--compact',] }],
        cssClassCosyOutlined: [{ type: i0.HostBinding, args: ['class.igx-button--outlined-cosy',] }],
        cssClassCompactOutlined: [{ type: i0.HostBinding, args: ['class.igx-button--outlined-compact',] }],
        cssClassCosyFab: [{ type: i0.HostBinding, args: ['class.igx-button--fab-cosy',] }],
        cssClassCompactFab: [{ type: i0.HostBinding, args: ['class.igx-button--fab-compact',] }],
        disabledAttribute: [{ type: i0.HostBinding, args: ['attr.disabled',] }],
        onClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }]
    };
    /**
     * @hidden
     */
    var IgxButtonModule = /** @class */ (function () {
        function IgxButtonModule() {
        }
        return IgxButtonModule;
    }());
    IgxButtonModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxButtonDirective],
                    exports: [IgxButtonDirective]
                },] }
    ];

    /**
     * **Ignite UI for Angular Icon Service** -
     *
     * The Ignite UI Icon Service makes it easy for developers to include custom SVG images and use them with IgxIconComponent.
     * In addition it could be used to associate a custom class to be applied on IgxIconComponent according to given font-family.
     *
     * Example:
     * ```typescript
     * this.iconService.registerFamilyAlias('material', 'material-icons');
     * this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
     * ```
     */
    var IgxIconService = /** @class */ (function () {
        function IgxIconService(_sanitizer, _document) {
            this._sanitizer = _sanitizer;
            this._document = _document;
            this._family = 'material-icons';
            this._familyAliases = new Map();
            this._cachedSvgIcons = new Set();
            this._iconLoaded = new rxjs.Subject();
            this.iconLoaded = this._iconLoaded.asObservable();
        }
        Object.defineProperty(IgxIconService.prototype, "defaultFamily", {
            /**
             *  Returns the default font-family.
             * ```typescript
             *   const defaultFamily = this.iconService.defaultFamily;
             * ```
             */
            get: function () {
                return this._family;
            },
            /**
             *  Sets the default font-family.
             * ```typescript
             *   this.iconService.defaultFamily = 'svg-flags';
             * ```
             */
            set: function (className) {
                this._family = className;
            },
            enumerable: false,
            configurable: true
        });
        /**
         *  Registers a custom class to be applied to IgxIconComponent for a given font-family.
         * ```typescript
         *   this.iconService.registerFamilyAlias('material', 'material-icons');
         * ```
         */
        IgxIconService.prototype.registerFamilyAlias = function (alias, className) {
            if (className === void 0) { className = alias; }
            this._familyAliases.set(alias, className);
            return this;
        };
        /**
         *  Returns the custom class, if any, associated to a given font-family.
         * ```typescript
         *   const familyClass = this.iconService.familyClassName('material');
         * ```
         */
        IgxIconService.prototype.familyClassName = function (alias) {
            return this._familyAliases.get(alias) || alias;
        };
        /**
         *  Adds an SVG image to the cache. SVG source is an url.
         * ```typescript
         *   this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
         * ```
         */
        IgxIconService.prototype.addSvgIcon = function (name, url, family) {
            if (family === void 0) { family = ''; }
            if (name && url) {
                var safeUrl = this._sanitizer.bypassSecurityTrustResourceUrl(url);
                if (!safeUrl) {
                    throw new Error("The provided URL could not be processed as trusted resource URL by Angular's DomSanitizer: \"" + url + "\".");
                }
                var sanitizedUrl = this._sanitizer.sanitize(i0.SecurityContext.RESOURCE_URL, safeUrl);
                if (!sanitizedUrl) {
                    throw new Error("The URL provided was not trusted as a resource URL: \"" + url + "\".");
                }
                this.fetchSvg(name, url, family);
            }
            else {
                throw new Error('You should provide at least `name` and `url` to register an svg icon.');
            }
        };
        /**
         *  Adds an SVG image to the cache. SVG source is its text.
         * ```typescript
         *   this.iconService.addSvgIcon('simple', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
         *   <path d="M74 74h54v54H74" /></svg>', 'svg-flags');
         * ```
         */
        IgxIconService.prototype.addSvgIconFromText = function (name, iconText, family) {
            if (family === void 0) { family = ''; }
            if (name && iconText) {
                this.cacheSvgIcon(name, iconText, family);
            }
            else {
                throw new Error('You should provide at least `name` and `iconText` to register an svg icon.');
            }
        };
        /**
         *  Returns whether a given SVG image is present in the cache.
         * ```typescript
         *   const isSvgCached = this.iconService.isSvgIconCached('aruba', 'svg-flags');
         * ```
         */
        IgxIconService.prototype.isSvgIconCached = function (name, family) {
            if (family === void 0) { family = ''; }
            var iconKey = this.getSvgIconKey(name, family);
            return this._cachedSvgIcons.has(iconKey);
        };
        /**
         *  Returns the key of a cached SVG image.
         * ```typescript
         *   const svgIconKey = this.iconService.getSvgIconKey('aruba', 'svg-flags');
         * ```
         */
        IgxIconService.prototype.getSvgIconKey = function (name, family) {
            if (family === void 0) { family = ''; }
            return family + '_' + name;
        };
        /**
         * @hidden
         */
        IgxIconService.prototype.fetchSvg = function (name, url, family) {
            if (family === void 0) { family = ''; }
            var instance = this;
            var httpRequest = new XMLHttpRequest();
            httpRequest.open('GET', url, true);
            httpRequest.responseType = 'text';
            // load – when the result is ready, that includes HTTP errors like 404.
            httpRequest.onload = function (event) {
                if (event) {
                    var request = event.target;
                    if (request.status === 200) {
                        instance.cacheSvgIcon(name, request.responseText, family);
                        instance._iconLoaded.next({ name: name, value: request.responseText, family: family });
                    }
                    else {
                        throw new Error("Could not fetch SVG from url: " + url + "; error: " + request.status + " (" + request.statusText + ")");
                    }
                }
                else {
                    throw new Error("Could not fetch SVG from url: " + url + ";");
                }
            };
            // error – when the request couldn’t be made, e.g.network down or invalid URL.
            httpRequest.onerror = function (event) {
                if (event) {
                    var request = event.target;
                    throw new Error("Could not fetch SVG from url: " + url + "; error status code: " + request.status + " (" + request.statusText + ")");
                }
                throw new Error("Could not fetch SVG from url: " + url + ";");
            };
            httpRequest.send();
        };
        /**
         * @hidden
         */
        IgxIconService.prototype.cacheSvgIcon = function (name, value, family) {
            if (family === void 0) { family = ''; }
            if (name && value) {
                this.ensureSvgContainerCreated();
                var div = this._document.createElement('DIV');
                div.innerHTML = value;
                var svg = div.querySelector('svg');
                if (svg) {
                    var iconKey = this.getSvgIconKey(name, family);
                    svg.setAttribute('id', iconKey);
                    svg.setAttribute('fit', '');
                    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
                    if (this._cachedSvgIcons.has(iconKey)) {
                        var oldChild = this._svgContainer.querySelector("svg[id='" + iconKey + "']");
                        this._svgContainer.removeChild(oldChild);
                    }
                    this._svgContainer.appendChild(svg);
                    this._cachedSvgIcons.add(iconKey);
                }
            }
        };
        /**
         * @hidden
         */
        IgxIconService.prototype.ensureSvgContainerCreated = function () {
            if (!this._svgContainer) {
                this._svgContainer = this._document.documentElement.querySelector('.igx-svg-container');
                if (!this._svgContainer) {
                    this._svgContainer = this._document.createElement('DIV');
                    this._svgContainer.classList.add('igx-svg-container');
                    this._document.documentElement.appendChild(this._svgContainer);
                }
            }
        };
        return IgxIconService;
    }());
    IgxIconService.ɵprov = i0.ɵɵdefineInjectable({ factory: function IgxIconService_Factory() { return new IgxIconService(i0.ɵɵinject(i1$1.DomSanitizer), i0.ɵɵinject(i2.DOCUMENT)); }, token: IgxIconService, providedIn: "root" });
    IgxIconService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    IgxIconService.ctorParameters = function () { return [
        { type: i1$1.DomSanitizer },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] }
    ]; };

    /**
     * Icon provides a way to include material icons to markup
     *
     * @igxModule IgxIconModule
     *
     * @igxTheme igx-icon-theme
     *
     * @igxKeywords icon, picture
     *
     * @igxGroup Display
     *
     * @remarks
     *
     * The Ignite UI Icon makes it easy for developers to include material design icons directly in their markup. The icons
     * support different icon families and can be marked as active or disabled using the `active` property. This will change the appearance
     * of the icon.
     *
     * @example
     * ```html
     * <igx-icon family="filter-icons" active="true">home</igx-icon>
     * ```
     */
    var IgxIconComponent = /** @class */ (function () {
        function IgxIconComponent(el, iconService, ref) {
            var _this = this;
            this.el = el;
            this.iconService = iconService;
            this.ref = ref;
            /**
             *  This allows you to change the value of `class.igx-icon`. By default it's `igx-icon`.
             *
             * @hidden
             * @internal
             */
            this.cssClass = 'igx-icon';
            /**
             *  This allows you to disable the `aria-hidden` attribute. By default it's applied.
             *
             * @example
             * ```typescript
             * @ViewChild("MyIcon") public icon: IgxIconComponent;
             * constructor(private cdRef:ChangeDetectorRef) {}
             * ngAfterViewInit() {
             *     this.icon.ariaHidden = false;
             *     this.cdRef.detectChanges();
             * }
             * ```
             */
            this.ariaHidden = true;
            /**
             * An @Input property that allows you to disable the `active` property. By default it's applied.
             *
             * @example
             * ```html
             * <igx-icon [active]="false">settings</igx-icon>
             * ```
             */
            this.active = true;
            this.destroy$ = new rxjs.Subject();
            this.family = this.iconService.defaultFamily;
            this.iconService.registerFamilyAlias('material', 'material-icons');
            this.iconService.iconLoaded.pipe(operators.first(function (e) { return e.name === _this.name && e.family === _this.family; }), operators.takeUntil(this.destroy$))
                .subscribe(function () { return _this.ref.detectChanges(); });
        }
        /**
         * @hidden
         * @internal
         */
        IgxIconComponent.prototype.ngOnInit = function () {
            this.updateIconClass();
        };
        /**
         * @hidden
         * @internal
         */
        IgxIconComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next();
            this.destroy$.complete();
        };
        Object.defineProperty(IgxIconComponent.prototype, "getFamily", {
            /**
             *  An accessor that returns the value of the family property.
             *
             * @example
             * ```typescript
             *  @ViewChild("MyIcon")
             * public icon: IgxIconComponent;
             * ngAfterViewInit() {
             *    let iconFamily = this.icon.getFamily;
             * }
             * ```
             */
            get: function () {
                return this.family;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxIconComponent.prototype, "getActive", {
            /**
             *  An accessor that returns the value of the active property.
             *
             * @example
             * ```typescript
             * @ViewChild("MyIcon")
             * public icon: IgxIconComponent;
             * ngAfterViewInit() {
             *    let iconActive = this.icon.getActive;
             * }
             * ```
             */
            get: function () {
                return this.active;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxIconComponent.prototype, "getInactive", {
            /**
             *  An accessor that returns inactive property.
             *
             * @example
             * ```typescript
             * @ViewChild("MyIcon")
             * public icon: IgxIconComponent;
             * ngAfterViewInit() {
             *    let iconActive = this.icon.getInactive;
             * }
             * ```
             */
            get: function () {
                return !this.active;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxIconComponent.prototype, "getColor", {
            /**
             * An accessor that returns the opposite value of the `color` property.
             *
             * @example
             * ```typescript
             * @ViewChild("MyIcon")
             * public icon: IgxIconComponent;
             * ngAfterViewInit() {
             *    let color = this.icon.getColor;
             * }
             * ```
             */
            get: function () {
                return this.color;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxIconComponent.prototype, "getName", {
            /**
             * An accessor that returns the value of the iconName property.
             *
             * @example
             * ```typescript
             * @ViewChild("MyIcon")
             * public icon: IgxIconComponent;
             * ngAfterViewInit() {
             *    let name = this.icon.getName;
             * }
             * ```
             */
            get: function () {
                return this.name;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxIconComponent.prototype, "getSvgKey", {
            /**
             *  An accessor that returns the key of the SVG image.
             *  The key consists of the font-family and the name separated by underscore.
             *
             * @example
             * ```typescript
             * @ViewChild("MyIcon")
             * public icon: IgxIconComponent;
             * ngAfterViewInit() {
             *    let svgKey = this.icon.getSvgKey;
             * }
             * ```
             */
            get: function () {
                if (this.iconService.isSvgIconCached(this.name, this.family)) {
                    return '#' + this.iconService.getSvgIconKey(this.name, this.family);
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxIconComponent.prototype, "template", {
            /**
             *   An accessor that returns a TemplateRef to explicit, svg or no ligature.
             *
             * @example
             * ```typescript
             * @ViewChild("MyIcon")
             * public icon: IgxIconComponent;
             * ngAfterViewInit() {
             *    let iconTemplate = this.icon.template;
             * }
             * ```
             */
            get: function () {
                if (this.name) {
                    if (this.iconService.isSvgIconCached(this.name, this.family)) {
                        return this.svgImage;
                    }
                    return this.noLigature;
                }
                return this.explicitLigature;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxIconComponent.prototype.updateIconClass = function () {
            var className = this.iconService.familyClassName(this.family);
            this.el.nativeElement.classList.add(className);
            if (this.name && !this.iconService.isSvgIconCached(this.name, this.family)) {
                this.el.nativeElement.classList.add(this.name);
            }
        };
        return IgxIconComponent;
    }());
    IgxIconComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-icon',
                    template: "<ng-template #noLigature></ng-template>\n\n<ng-template #explicitLigature>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #svgImage>\n    <svg>\n        <use [attr.href]=\"getSvgKey\"></use>\n    </svg>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
                },] }
    ];
    IgxIconComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: IgxIconService },
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxIconComponent.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-icon',] }],
        ariaHidden: [{ type: i0.HostBinding, args: ['attr.aria-hidden',] }],
        family: [{ type: i0.Input, args: ['family',] }],
        active: [{ type: i0.Input, args: ['active',] }],
        color: [{ type: i0.Input, args: ['color',] }],
        name: [{ type: i0.Input, args: ['name',] }],
        noLigature: [{ type: i0.ViewChild, args: ['noLigature', { read: i0.TemplateRef, static: true },] }],
        explicitLigature: [{ type: i0.ViewChild, args: ['explicitLigature', { read: i0.TemplateRef, static: true },] }],
        svgImage: [{ type: i0.ViewChild, args: ['svgImage', { read: i0.TemplateRef, static: true },] }],
        getInactive: [{ type: i0.HostBinding, args: ['class.igx-icon--inactive',] }],
        getColor: [{ type: i0.HostBinding, args: ['style.color',] }]
    };
    __decorate([
        DeprecateProperty('`color` is deprecated.')
    ], IgxIconComponent.prototype, "color", void 0);

    /**
     * @hidden
     */
    var IgxIconModule = /** @class */ (function () {
        function IgxIconModule() {
        }
        return IgxIconModule;
    }());
    IgxIconModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxIconComponent],
                    exports: [IgxIconComponent],
                    imports: [i2.CommonModule]
                },] }
    ];

    /**
     * @hidden
     */
    var IgxPrefixDirective = /** @class */ (function () {
        function IgxPrefixDirective() {
        }
        return IgxPrefixDirective;
    }());
    IgxPrefixDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'igx-prefix,[igxPrefix]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxPrefixModule = /** @class */ (function () {
        function IgxPrefixModule() {
        }
        return IgxPrefixModule;
    }());
    IgxPrefixModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxPrefixDirective],
                    exports: [IgxPrefixDirective]
                },] }
    ];

    /**
     * @hidden
     */
    var IgxSuffixDirective = /** @class */ (function () {
        function IgxSuffixDirective() {
        }
        return IgxSuffixDirective;
    }());
    IgxSuffixDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'igx-suffix,[igxSuffix]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxSuffixModule = /** @class */ (function () {
        function IgxSuffixModule() {
        }
        return IgxSuffixModule;
    }());
    IgxSuffixModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxSuffixDirective],
                    exports: [IgxSuffixDirective]
                },] }
    ];

    var IgxInputGroupEnum = mkenum({
        Line: 'line',
        Box: 'box',
        Border: 'border',
        Search: 'search'
    });
    /**
     * Defines the InputGroupType DI token.
     */
    // Should this go trough Interface https://angular.io/api/core/InjectionToken
    var IGX_INPUT_GROUP_TYPE = new i0.InjectionToken('InputGroupType');

    var DateRangePickerResourceStringsEN = {
        igx_date_range_picker_date_separator: 'to'
    };

    var GridResourceStringsEN = {
        igx_grid_groupByArea_message: 'Drag a column header and drop it here to group by that column.',
        igx_grid_groupByArea_select_message: 'Select all rows in the group with field name {0} and value {1}.',
        igx_grid_groupByArea_deselect_message: 'Deselect all rows in the group with field name {0} and value {1}.',
        igx_grid_emptyFilteredGrid_message: 'No records found.',
        igx_grid_emptyGrid_message: 'Grid has no data.',
        igx_grid_filter: 'Filter',
        igx_grid_filter_row_close: 'Close',
        igx_grid_filter_row_reset: 'Reset',
        igx_grid_filter_row_placeholder: 'Add filter value',
        igx_grid_filter_row_boolean_placeholder: 'All',
        igx_grid_filter_row_date_placeholder: 'Pick up date',
        igx_grid_filter_operator_and: 'And',
        igx_grid_filter_operator_or: 'Or',
        igx_grid_complex_filter: 'Complex Filter',
        igx_grid_filter_contains: 'Contains',
        igx_grid_filter_doesNotContain: 'Does Not Contain',
        igx_grid_filter_startsWith: 'Starts With',
        igx_grid_filter_endsWith: 'Ends With',
        igx_grid_filter_equals: 'Equals',
        igx_grid_filter_doesNotEqual: 'Does Not Equal',
        igx_grid_filter_empty: 'Empty',
        igx_grid_filter_notEmpty: 'Not Empty',
        igx_grid_filter_null: 'Null',
        igx_grid_filter_notNull: 'Not Null',
        igx_grid_filter_before: 'Before',
        igx_grid_filter_after: 'After',
        igx_grid_filter_today: 'Today',
        igx_grid_filter_yesterday: 'Yesterday',
        igx_grid_filter_thisMonth: 'This Month',
        igx_grid_filter_lastMonth: 'Last Month',
        igx_grid_filter_nextMonth: 'Next Month',
        igx_grid_filter_thisYear: 'This Year',
        igx_grid_filter_lastYear: 'Last Year',
        igx_grid_filter_nextYear: 'Next Year',
        igx_grid_filter_greaterThan: 'Greater Than',
        igx_grid_filter_lessThan: 'Less Than',
        igx_grid_filter_greaterThanOrEqualTo: 'Greater Than Or Equal To',
        igx_grid_filter_lessThanOrEqualTo: 'Less Than Or Equal To',
        igx_grid_filter_true: 'True',
        igx_grid_filter_false: 'False',
        igx_grid_filter_all: 'All',
        igx_grid_filter_condition_placeholder: 'Select filter',
        igx_grid_summary_count: 'Count',
        igx_grid_summary_min: 'Min',
        igx_grid_summary_max: 'Max',
        igx_grid_summary_sum: 'Sum',
        igx_grid_summary_average: 'Avg',
        igx_grid_summary_earliest: 'Earliest',
        igx_grid_summary_latest: 'Latest',
        igx_grid_excel_filter_moving_left: 'move left',
        igx_grid_excel_filter_moving_left_short: 'left',
        igx_grid_excel_filter_moving_right: 'move right',
        igx_grid_excel_filter_moving_right_short: 'right',
        igx_grid_excel_filter_moving_header: 'move',
        igx_grid_excel_filter_sorting_asc: 'ascending',
        igx_grid_excel_filter_sorting_asc_short: 'asc',
        igx_grid_excel_filter_sorting_desc: 'descending',
        igx_grid_excel_filter_sorting_desc_short: 'desc',
        igx_grid_excel_filter_sorting_header: 'sort',
        igx_grid_excel_filter_clear: 'Clear column filters',
        igx_grid_excel_custom_dialog_add: 'add filter',
        igx_grid_excel_custom_dialog_clear: 'Clear filter',
        igx_grid_excel_custom_dialog_header: 'Custom auto-filter on column: ',
        igx_grid_excel_cancel: 'cancel',
        igx_grid_excel_apply: 'apply',
        igx_grid_excel_search_placeholder: 'Search',
        igx_grid_excel_select_all: 'Select All',
        igx_grid_excel_select_all_search_results: 'Select all search results',
        igx_grid_excel_add_to_filter: 'Add current selection to filter',
        igx_grid_excel_blanks: '(Blanks)',
        igx_grid_excel_hide: 'Hide column',
        igx_grid_excel_show: 'Show column',
        igx_grid_excel_pin: 'Pin column',
        igx_grid_excel_unpin: 'Unpin column',
        igx_grid_excel_select: 'Select column',
        igx_grid_excel_text_filter: 'Text filter',
        igx_grid_excel_number_filter: 'Number filter',
        igx_grid_excel_date_filter: 'Date filter',
        igx_grid_excel_boolean_filter: 'Boolean filter',
        igx_grid_excel_currency_filter: 'Currency filter',
        igx_grid_excel_custom_filter: 'Custom filter...',
        igx_grid_advanced_filter_title: 'Advanced Filtering',
        igx_grid_advanced_filter_and_group: '"And" Group',
        igx_grid_advanced_filter_or_group: '"Or" Group',
        igx_grid_advanced_filter_end_group: 'End Group',
        igx_grid_advanced_filter_create_and_group: 'Create "And" Group',
        igx_grid_advanced_filter_create_or_group: 'Create "Or" Group',
        igx_grid_advanced_filter_and_label: 'and',
        igx_grid_advanced_filter_or_label: 'or',
        igx_grid_advanced_filter_add_condition: 'Condition',
        igx_grid_advanced_filter_ungroup: 'Ungroup',
        igx_grid_advanced_filter_delete: 'Delete',
        igx_grid_advanced_filter_delete_filters: 'Delete filters',
        igx_grid_advanced_filter_initial_text: 'Start with creating a group of conditions linked with "And" or "Or"',
        igx_grid_advanced_filter_column_placeholder: 'Select column',
        igx_grid_advanced_filter_value_placeholder: 'Value',
        igx_grid_pinned_row_indicator: 'Pinned',
        igx_grid_hiding_check_all_label: 'Show All',
        igx_grid_hiding_uncheck_all_label: 'Hide All',
        igx_grid_pinning_check_all_label: 'Pin All',
        igx_grid_pinning_uncheck_all_label: 'Unpin All',
        igx_grid_toolbar_actions_filter_prompt: 'Filter columns list ...',
        igx_grid_toolbar_pinning_button_tooltip: 'Open column pinning dropdown',
        igx_grid_toolbar_hiding_button_tooltip: 'Open column hiding dropdown',
        igx_grid_toolbar_pinning_title: 'Pinned columns',
        igx_grid_toolbar_hiding_title: 'Visible columns',
        igx_grid_toolbar_advanced_filtering_button_tooltip: 'Open advanced filtering dialog',
        igx_grid_toolbar_advanced_filtering_button_label: 'Advanced filtering',
        igx_grid_toolbar_exporter_button_tooltip: 'Open exporter dropdown',
        igx_grid_toolbar_exporter_button_label: 'Export',
        igx_grid_toolbar_exporter_excel_entry_text: 'Export to Excel',
        igx_grid_toolbar_exporter_csv_entry_text: 'Export to CSV',
        igx_grid_snackbar_addrow_label: 'Row added',
        igx_grid_snackbar_addrow_actiontext: 'SHOW',
        igx_grid_actions_edit_label: 'Edit',
        igx_grid_actions_add_label: 'Add',
        igx_grid_add_row_label: 'ADD ROW',
        igx_grid_actions_add_child_label: 'Add Child',
        igx_grid_actions_delete_label: 'Delete',
        igx_grid_actions_pin_label: 'Pin',
        igx_grid_actions_unpin_label: 'Unpin',
        igx_grid_actions_jumpUp_label: 'Jump up',
        igx_grid_actions_jumpDown_label: 'Jump down'
    };

    var TimePickerResourceStringsEN = {
        igx_time_picker_ok: 'OK',
        igx_time_picker_cancel: 'Cancel'
    };

    var PaginatorResourceStringsEN = {
        igx_paginator_label: 'Items per page',
        igx_paginator_pager_text: 'of',
        igx_paginator_first_page_button_text: 'Go to first page',
        igx_paginator_previous_page_button_text: 'Previous page',
        igx_paginator_last_page_button_text: 'Go to last page',
        igx_paginator_next_page_button_text: 'Next page',
    };

    var CarouselResourceStringsEN = {
        igx_carousel_of: 'of',
        igx_carousel_slide: 'slide',
        igx_carousel_previous_slide: 'previous slide',
        igx_carousel_next_slide: 'next slide'
    };

    var ListResourceStringsEN = {
        igx_list_no_items: 'There are no items in the list.',
        igx_list_loading: 'Loading data from the server...'
    };

    var CalendarResourceStringsEN = {
        igx_calendar_previous_month: 'Previous Month',
        igx_calendar_next_month: 'Next Month',
        igx_calendar_select_month: 'Select Month',
        igx_calendar_select_year: 'Select Year',
        igx_calendar_range_start: 'Range start',
        igx_calendar_range_end: 'Range end',
        igx_calendar_selected_month_is: 'Selected month is ',
        igx_calendar_first_picker_of: 'First picker of {0} starts from',
        igx_calendar_multi_selection: 'Multi selection calendar with {0} date pickers',
        igx_calendar_range_selection: 'Range selection calendar with {0} date pickers',
        igx_calendar_single_selection: 'Calendar with {0} date pickers',
        igx_calendar_singular_multi_selection: 'Multi selection calendar',
        igx_calendar_singular_range_selection: 'Range selection calendar',
        igx_calendar_singular_single_selection: 'Calendar',
    };

    var InputResourceStringsEN = {
        igx_input_upload_button: 'Upload File',
        igx_input_clear_button: 'clear',
        igx_input_file_placeholder: 'No file chosen',
    };

    /**
     * @hidden
     */
    var CurrentResourceStrings = {
        GridResStrings: cloneValue(GridResourceStringsEN),
        PaginatorResStrings: cloneValue(PaginatorResourceStringsEN),
        TimePickerResStrings: cloneValue(TimePickerResourceStringsEN),
        CalendarResStrings: cloneValue(CalendarResourceStringsEN),
        DateRangePickerResStrings: cloneValue(DateRangePickerResourceStringsEN),
        CarouselResStrings: cloneValue(CarouselResourceStringsEN),
        ListResStrings: cloneValue(ListResourceStringsEN),
        InputResStrings: cloneValue(InputResourceStringsEN),
    };
    var updateResourceStrings = function (currentStrings, newStrings) {
        var e_1, _a;
        try {
            for (var _b = __values(Object.keys(newStrings)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (key in currentStrings) {
                    currentStrings[key] = newStrings[key];
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    var ɵ0$2 = updateResourceStrings;
    /**
     * Changes the resource strings for all components in the application
     * ```
     * @param resourceStrings to be applied
     */
    var changei18n = function (resourceStrings) {
        var e_2, _a;
        try {
            for (var _b = __values(Object.keys(CurrentResourceStrings)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                updateResourceStrings(CurrentResourceStrings[key], resourceStrings);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * Returns current resource strings for all components
     */
    var getCurrentResourceStrings = function () { return (Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, CurrentResourceStrings.CalendarResStrings), CurrentResourceStrings.CarouselResStrings), CurrentResourceStrings.DateRangePickerResStrings), CurrentResourceStrings.GridResStrings), CurrentResourceStrings.InputResStrings), CurrentResourceStrings.ListResStrings), CurrentResourceStrings.PaginatorResStrings), CurrentResourceStrings.TimePickerResStrings)); };

    var IgxInputGroupTheme = mkenum({
        Material: 'material',
        Fluent: 'fluent',
        Bootstrap: 'bootstrap',
        IndigoDesign: 'indigo-design'
    });
    var IgxInputGroupComponent = /** @class */ (function (_super) {
        __extends(IgxInputGroupComponent, _super);
        function IgxInputGroupComponent(element, _displayDensityOptions, _inputGroupType, document, renderer) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.element = element;
            _this._inputGroupType = _inputGroupType;
            _this.document = document;
            _this.renderer = renderer;
            /**
             * Property that enables/disables the autogenerated class of the `IgxInputGroupComponent`.
             * By default applied the class is applied.
             * ```typescript
             *  @ViewChild("MyInputGroup")
             *  public inputGroup: IgxInputGroupComponent;
             *  ngAfterViewInit(){
             *  this.inputGroup.defaultClass = false;
             * ```
             * }
             */
            _this.defaultClass = true;
            /** @hidden */
            _this.hasPlaceholder = false;
            /** @hidden */
            _this.isRequired = false;
            /** @hidden */
            _this.isFocused = false;
            /**
             * An @Input property that disables the `IgxInputGroupComponent`.
             * ```html
             * <igx-input-group [disabled]="'true'"></igx-input-group>
             * ```
             */
            _this.disabled = false;
            /**
             * Prevents automatically focusing the input when clicking on other elements in the input group (e.g. prefix or suffix).
             *
             * @remarks Automatic focus causes software keyboard to show on mobile devices.
             *
             * @example
             * ```html
             * <igx-input-group [suppressInputAutofocus]="true"></igx-input-group>
             * ```
             */
            _this.suppressInputAutofocus = false;
            /** @hidden */
            _this.hasWarning = false;
            _this._type = null;
            _this._filled = false;
            _this._resourceStrings = CurrentResourceStrings.InputResStrings;
            return _this;
        }
        Object.defineProperty(IgxInputGroupComponent.prototype, "resourceStrings", {
            /**
             * Returns the resource strings.
             */
            get: function () {
                return this._resourceStrings;
            },
            /**
             * Sets the resource strings.
             * By default it uses EN resources.
             */
            set: function (value) {
                this._resourceStrings = Object.assign({}, this._resourceStrings, value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "validClass", {
            /** @hidden */
            get: function () {
                return this.input.valid === exports.IgxInputState.VALID;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "invalidClass", {
            /** @hidden */
            get: function () {
                return this.input.valid === exports.IgxInputState.INVALID;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isFilled", {
            /** @hidden */
            get: function () {
                return this._filled || (this.input && this.input.value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isDisplayDensityCosy", {
            /** @hidden */
            get: function () {
                return this.displayDensity === DisplayDensity.cosy;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isDisplayDensityComfortable", {
            /** @hidden */
            get: function () {
                return this.displayDensity === DisplayDensity.comfortable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isDisplayDensityCompact", {
            /** @hidden */
            get: function () {
                return this.displayDensity === DisplayDensity.compact;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "type", {
            /**
             * Returns the type of the `IgxInputGroupComponent`. How the input is styled.
             * The default is `line`.
             * ```typescript
             * @ViewChild("MyInputGroup")
             * public inputGroup: IgxInputGroupComponent;
             * ngAfterViewInit(){
             *    let inputType = this.inputGroup.type;
             * }
             * ```
             */
            get: function () {
                return this._type || this._inputGroupType || 'line';
            },
            /**
             * An @Input property that sets how the input will be styled.
             * Allowed values of type IgxInputGroupType.
             * ```html
             * <igx-input-group [type]="'search'">
             * ```
             */
            set: function (value) {
                this._type = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "theme", {
            /**
             * Returns the theme of the input.
             * The returned value is of tyep IgxInputGroupType.
             * ```typescript
             * @ViewChild("MyInputGroup")
             * public inputGroup: IgxInputGroupComponent;
             * ngAfterViewInit() {
             *  let inputTheme = this.inputGroup.theme;
             * }
             */
            get: function () {
                return this._variant;
            },
            /**
             * Sets the theme of the input.
             * Allowed values of type IgxInputGroupTheme.
             * ```typescript
             * @ViewChild("MyInputGroup")
             * public inputGroup: IgxInputGroupComponent;
             * ngAfterViewInit() {
             *  let inputTheme = 'fluent';
             * }
             */
            set: function (variant) {
                this._variant = variant;
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden */
        IgxInputGroupComponent.prototype.onClick = function (event) {
            if (!this.isFocused &&
                event.target !== this.input.nativeElement &&
                !this.suppressInputAutofocus) {
                this.input.focus();
            }
        };
        /** @hidden */
        IgxInputGroupComponent.prototype.onPointerDown = function (event) {
            if (this.isFocused && event.target !== this.input.nativeElement) {
                event.preventDefault();
            }
        };
        /** @hidden @internal */
        IgxInputGroupComponent.prototype.hintClickHandler = function (event) {
            event.stopPropagation();
        };
        /** @hidden @internal */
        IgxInputGroupComponent.prototype.ngAfterContentInit = function () {
            if (!this.theme) {
                if (isIE()) {
                    this._variant = IgxInputGroupTheme.Material;
                }
                else {
                    this._variant = this.document.defaultView
                        .getComputedStyle(this.element.nativeElement)
                        .getPropertyValue('--igx-input-group-variant')
                        .trim();
                }
            }
        };
        Object.defineProperty(IgxInputGroupComponent.prototype, "hasHints", {
            /**
             * Returns whether the `IgxInputGroupComponent` has hints.
             * ```typescript
             * @ViewChild("MyInputGroup")
             * public inputGroup: IgxInputGroupComponent;
             * ngAfterViewInit(){
             *    let inputHints = this.inputGroup.hasHints;
             * }
             * ```
             */
            get: function () {
                return this.hints.length > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "hasBorder", {
            /**
             * Returns whether the `IgxInputGroupComponent` has border.
             * ```typescript
             * @ViewChild("MyInputGroup")
             * public inputGroup: IgxInputGroupComponent;
             * ngAfterViewInit(){
             *    let inputBorder = this.inputGroup.hasBorder;
             * }
             * ```
             */
            get: function () {
                return ((this.type === 'line' || this.type === 'box') &&
                    this._variant === 'material');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeLine", {
            /**
             * Returns whether the `IgxInputGroupComponent` type is line.
             * ```typescript
             * @ViewChild("MyInputGroup1")
             * public inputGroup: IgxInputGroupComponent;
             * ngAfterViewInit(){
             *    let isTypeLine = this.inputGroup.isTypeLine;
             * }
             * ```
             */
            get: function () {
                return this.type === 'line' && this._variant === 'material';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeBox", {
            /**
             * Returns whether the `IgxInputGroupComponent` type is box.
             * ```typescript
             * @ViewChild("MyInputGroup1")
             * public inputGroup: IgxInputGroupComponent;
             * ngAfterViewInit(){
             *    let isTypeBox = this.inputGroup.isTypeBox;
             * }
             * ```
             */
            get: function () {
                return this.type === 'box' && this._variant === 'material';
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden @internal */
        IgxInputGroupComponent.prototype.uploadButtonHandler = function () {
            this.input.nativeElement.click();
        };
        /** @hidden @internal */
        IgxInputGroupComponent.prototype.clearValueHandler = function () {
            this.input.clear();
        };
        Object.defineProperty(IgxInputGroupComponent.prototype, "isFileType", {
            /** @hidden @internal */
            get: function () {
                return this.input.type === 'file';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "fileNames", {
            /** @hidden @internal */
            get: function () {
                return this.input.fileNames || this._resourceStrings.igx_input_file_placeholder;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeBorder", {
            /**
             * Returns whether the `IgxInputGroupComponent` type is border.
             * ```typescript
             * @ViewChild("MyInputGroup1")
             * public inputGroup: IgxInputGroupComponent;
             * ngAfterViewInit(){
             *    let isTypeBorder = this.inputGroup.isTypeBorder;
             * }
             * ```
             */
            get: function () {
                return this.type === 'border' && this._variant === 'material';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeFluent", {
            /**
             * Returns true if the `IgxInputGroupComponent` theme is Fluent.
             * ```typescript
             * @ViewChild("MyInputGroup1")
             * public inputGroup: IgxInputGroupComponent;
             * ngAfterViewInit(){
             *    let isTypeFluent = this.inputGroup.isTypeFluent;
             * }
             * ```
             */
            get: function () {
                return this._variant === 'fluent';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeBootstrap", {
            /**
             * Returns true if the `IgxInputGroupComponent` theme is Bootstrap.
             * ```typescript
             * @ViewChild("MyInputGroup1")
             * public inputGroup: IgxInputGroupComponent;
             * ngAfterViewInit(){
             *    let isTypeBootstrap = this.inputGroup.isTypeBootstrap;
             * }
             * ```
             */
            get: function () {
                return this._variant === 'bootstrap';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeIndigo", {
            /**
             * Returns true if the `IgxInputGroupComponent` theme is Indigo.
             * ```typescript
             * @ViewChild("MyInputGroup1")
             * public inputGroup: IgxInputGroupComponent;
             * ngAfterViewInit(){
             *    let isTypeIndigo = this.inputGroup.isTypeIndigo;
             * }
             * ```
             */
            get: function () {
                return this._variant === 'indigo-design';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeSearch", {
            /**
             * Returns whether the `IgxInputGroupComponent` type is search.
             * ```typescript
             * @ViewChild("MyInputGroup1")
             * public inputGroup: IgxInputGroupComponent;
             * ngAfterViewInit(){
             *    let isTypeSearch = this.inputGroup.isTypeSearch;
             * }
             * ```
             */
            get: function () {
                return this.type === 'search';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "filled", {
            /** @hidden */
            get: function () {
                return this._filled;
            },
            /** @hidden */
            set: function (val) {
                this._filled = val;
            },
            enumerable: false,
            configurable: true
        });
        return IgxInputGroupComponent;
    }(DisplayDensityBase));
    IgxInputGroupComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-input-group',
                    template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n\n<div class=\"igx-input-group__hint\" (click)=\"hintClickHandler($event)\">\n    <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n</div>\n\n<ng-template #label>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #input>\n    <ng-content select=\"[igxInput]\"></ng-content>\n</ng-template>\n\n<ng-template #prefix>\n    <ng-content select=\"igx-prefix, [igxPrefix]\"></ng-content>\n</ng-template>\n\n<ng-template #uploadButton>\n    <igx-prefix *ngIf=\"isFileType\">\n        <button\n            igxButton=\"raised\"\n            (click)=\"uploadButtonHandler()\"\n            [displayDensity]=\"displayDensity\"\n            [disabled]=\"disabled\"\n            [ngClass]=\"{ 'igx-input-group__upload-button': isTypeLine }\"\n        >\n            {{ resourceStrings.igx_input_upload_button }}\n        </button>\n    </igx-prefix>\n</ng-template>\n\n<ng-template #files>\n    <div\n        *ngIf=\"isFileType\"\n        class=\"igx-input-group__file-input\"\n        [title]=\"fileNames\"\n    >\n        <span>{{ fileNames }}</span>\n    </div>\n</ng-template>\n\n<ng-template #clear>\n    <igx-suffix\n        class=\"igx-input-group__clear-icon\"\n        *ngIf=\"isFileType && isFilled\"\n        (click)=\"clearValueHandler()\"\n        (keydown.Enter)=\"clearValueHandler()\"\n        title=\"clear files\"\n        tabindex=\"0\"\n    >\n        <igx-icon>{{ resourceStrings.igx_input_clear_button }}</igx-icon>\n    </igx-suffix>\n</ng-template>\n\n<ng-template #suffix>\n    <ng-content select=\"igx-suffix, [igxSuffix]\"></ng-content>\n</ng-template>\n\n<ng-template #materialBundle>\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #fluentBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bootstrapBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bundle>\n    <ng-container [ngSwitch]=\"theme\">\n        <ng-container *ngSwitchCase=\"'bootstrap'\">\n            <ng-container *ngTemplateOutlet=\"bootstrapBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'fluent'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'indigo-design'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"materialBundle\"></ng-container>\n        </ng-container>\n    </ng-container>\n</ng-template>\n",
                    providers: [
                        { provide: IgxInputGroupBase, useExisting: IgxInputGroupComponent },
                    ]
                },] }
    ];
    IgxInputGroupComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [IGX_INPUT_GROUP_TYPE,] }] },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: i0.Renderer2 }
    ]; };
    IgxInputGroupComponent.propDecorators = {
        resourceStrings: [{ type: i0.Input }],
        defaultClass: [{ type: i0.HostBinding, args: ['class.igx-input-group',] }],
        hasPlaceholder: [{ type: i0.HostBinding, args: ['class.igx-input-group--placeholder',] }],
        isRequired: [{ type: i0.HostBinding, args: ['class.igx-input-group--required',] }],
        isFocused: [{ type: i0.HostBinding, args: ['class.igx-input-group--focused',] }],
        disabled: [{ type: i0.HostBinding, args: ['class.igx-input-group--disabled',] }, { type: i0.Input }],
        suppressInputAutofocus: [{ type: i0.Input }],
        hasWarning: [{ type: i0.HostBinding, args: ['class.igx-input-group--warning',] }],
        hints: [{ type: i0.ContentChildren, args: [IgxHintDirective, { read: IgxHintDirective },] }],
        input: [{ type: i0.ContentChild, args: [IgxInputDirective, { read: IgxInputDirective, static: true },] }],
        validClass: [{ type: i0.HostBinding, args: ['class.igx-input-group--valid',] }],
        invalidClass: [{ type: i0.HostBinding, args: ['class.igx-input-group--invalid',] }],
        isFilled: [{ type: i0.HostBinding, args: ['class.igx-input-group--filled',] }],
        isDisplayDensityCosy: [{ type: i0.HostBinding, args: ['class.igx-input-group--cosy',] }],
        isDisplayDensityComfortable: [{ type: i0.HostBinding, args: ['class.igx-input-group--comfortable',] }],
        isDisplayDensityCompact: [{ type: i0.HostBinding, args: ['class.igx-input-group--compact',] }],
        type: [{ type: i0.Input, args: ['type',] }],
        theme: [{ type: i0.Input }],
        onClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }],
        onPointerDown: [{ type: i0.HostListener, args: ['pointerdown', ['$event'],] }],
        isTypeBox: [{ type: i0.HostBinding, args: ['class.igx-input-group--box',] }],
        isFileType: [{ type: i0.HostBinding, args: ['class.igx-input-group--file',] }],
        isTypeBorder: [{ type: i0.HostBinding, args: ['class.igx-input-group--border',] }],
        isTypeFluent: [{ type: i0.HostBinding, args: ['class.igx-input-group--fluent',] }],
        isTypeBootstrap: [{ type: i0.HostBinding, args: ['class.igx-input-group--bootstrap',] }],
        isTypeIndigo: [{ type: i0.HostBinding, args: ['class.igx-input-group--indigo',] }],
        isTypeSearch: [{ type: i0.HostBinding, args: ['class.igx-input-group--search',] }]
    };
    /** @hidden */
    var IgxInputGroupModule = /** @class */ (function () {
        function IgxInputGroupModule() {
        }
        return IgxInputGroupModule;
    }());
    IgxInputGroupModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxInputGroupComponent,
                        IgxHintDirective,
                        IgxInputDirective,
                        IgxLabelDirective,
                    ],
                    exports: [
                        IgxInputGroupComponent,
                        IgxHintDirective,
                        IgxInputDirective,
                        IgxLabelDirective,
                        IgxPrefixModule,
                        IgxSuffixModule,
                        IgxButtonModule,
                        IgxIconModule
                    ],
                    imports: [i2.CommonModule, IgxPrefixModule, IgxSuffixModule, IgxButtonModule, IgxIconModule],
                },] }
    ];

    /**
     * **Ignite UI for Angular Autocomplete** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/autocomplete.html)
     *
     * The igxAutocomplete directive provides a way to enhance a text input
     * by showing a drop down of suggested options, provided by the developer.
     *
     * Example:
     * ```html
     * <input type="text" [igxAutocomplete]="townsPanel" #autocompleteRef="igxAutocomplete"/>
     * <igx-drop-down #townsPanel>
     *     <igx-drop-down-item *ngFor="let town of towns | startsWith:townSelected" [value]="town">
     *         {{town}}
     *     </igx-drop-down-item>
     * </igx-drop-down>
     * ```
     */
    var IgxAutocompleteDirective = /** @class */ (function (_super) {
        __extends(IgxAutocompleteDirective, _super);
        function IgxAutocompleteDirective(ngModel, formControl, group, elementRef, cdr) {
            var _this = _super.call(this, null) || this;
            _this.ngModel = ngModel;
            _this.formControl = formControl;
            _this.group = group;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            /** @hidden @internal */
            _this.autofill = 'off';
            /** @hidden  @internal */
            _this.role = 'combobox';
            /**
             * Enables/disables autocomplete component
             *
             * ```typescript
             * // get
             * let disabled = this.autocomplete.disabled;
             * ```
             * ```html
             * <!--set-->
             * <input type="text" [igxAutocomplete]="townsPanel" [igxAutocompleteDisabled]="disabled"/>
             * ```
             * ```typescript
             * // set
             * public disabled = true;
             * ```
             */
            _this.disabled = false;
            /**
             * Emitted after item from the drop down is selected
             *
             * ```html
             * <input igxInput [igxAutocomplete]="townsPanel" (onItemSelected)='itemSelected($event)' />
             * ```
             */
            _this.onItemSelected = new i0.EventEmitter();
            _this._shouldBeOpen = false;
            _this.destroy$ = new rxjs.Subject();
            return _this;
        }
        Object.defineProperty(IgxAutocompleteDirective.prototype, "target", {
            /**
             * Sets the target of the autocomplete directive
             *
             * ```html
             * <!-- Set -->
             * <input [igxAutocomplete]="dropdown" />
             * ...
             * <igx-drop-down #dropdown>
             * ...
             * </igx-drop-down>
             * ```
             */
            get: function () {
                return this._target;
            },
            set: function (v) {
                this._target = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "nativeElement", {
            /** @hidden @internal */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "parentElement", {
            /** @hidden @internal */
            get: function () {
                return this.group ? this.group.element.nativeElement : this.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "settings", {
            get: function () {
                var settings = Object.assign({}, this.defaultSettings, this.autocompleteSettings);
                var target = settings.target || settings.positionStrategy.settings.target;
                if (!target) {
                    var positionStrategyClone = settings.positionStrategy.clone();
                    settings.target = this.parentElement;
                    settings.positionStrategy = positionStrategyClone;
                }
                return settings;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "ariaExpanded", {
            /** @hidden  @internal */
            get: function () {
                return !this.collapsed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "hasPopUp", {
            /** @hidden  @internal */
            get: function () {
                return 'listbox';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "ariaOwns", {
            /** @hidden  @internal */
            get: function () {
                return this.target.listId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "ariaActiveDescendant", {
            /** @hidden  @internal */
            get: function () {
                return !this.target.collapsed && this.target.focusedItem ? this.target.focusedItem.id : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "ariaAutocomplete", {
            /** @hidden  @internal */
            get: function () {
                return 'list';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "model", {
            get: function () {
                return this.ngModel || this.formControl;
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onInput = function () {
            this.open();
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onArrowDown = function (event) {
            event.preventDefault();
            this.open();
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onTab = function () {
            this.close();
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.handleKeyDown = function (event) {
            if (!this.collapsed) {
                switch (event.key.toLowerCase()) {
                    case 'space':
                    case 'spacebar':
                    case ' ':
                    case 'home':
                    case 'end':
                        return;
                    default:
                        _super.prototype.handleKeyDown.call(this, event);
                }
            }
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onArrowDownKeyDown = function () {
            _super.prototype.onArrowDownKeyDown.call(this);
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onArrowUpKeyDown = function () {
            _super.prototype.onArrowUpKeyDown.call(this);
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onEndKeyDown = function () {
            _super.prototype.onEndKeyDown.call(this);
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onHomeKeyDown = function () {
            _super.prototype.onHomeKeyDown.call(this);
        };
        /**
         * Closes autocomplete drop down
         */
        IgxAutocompleteDirective.prototype.close = function () {
            this._shouldBeOpen = false;
            if (this.collapsed) {
                return;
            }
            this.target.close();
        };
        /**
         * Opens autocomplete drop down
         */
        IgxAutocompleteDirective.prototype.open = function () {
            this._shouldBeOpen = true;
            if (this.disabled || !this.collapsed || this.target.children.length === 0) {
                return;
            }
            // if no drop-down width is set, the drop-down will be as wide as the autocomplete input;
            this.target.width = this.target.width || (this.parentElement.clientWidth + 'px');
            this.target.open(this.settings);
            this.highlightFirstItem();
        };
        /** @hidden @internal */
        IgxAutocompleteDirective.prototype.ngOnInit = function () {
            var targetElement = this.parentElement;
            this.defaultSettings = {
                target: targetElement,
                modal: false,
                scrollStrategy: new AbsoluteScrollStrategy(),
                positionStrategy: new AutoPositionStrategy(),
                excludeFromOutsideClick: [targetElement]
            };
        };
        /** @hidden */
        IgxAutocompleteDirective.prototype.ngOnDestroy = function () {
            this.destroy$.next();
            this.destroy$.complete();
        };
        IgxAutocompleteDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.target.children.changes.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                if (_this.target.children.length) {
                    if (!_this.collapsed) {
                        _this.highlightFirstItem();
                    }
                    else if (_this._shouldBeOpen) {
                        _this.open();
                    }
                }
                else {
                    // _shouldBeOpen flag should remain unchanged since this state change doesn't come from outside of the component
                    // (like in the case of public API or user interaction).
                    _this.target.close();
                }
            });
            this.target.onSelection.pipe(operators.takeUntil(this.destroy$)).subscribe(this.select.bind(this));
        };
        Object.defineProperty(IgxAutocompleteDirective.prototype, "collapsed", {
            get: function () {
                return this.target ? this.target.collapsed : true;
            },
            enumerable: false,
            configurable: true
        });
        IgxAutocompleteDirective.prototype.select = function (value) {
            if (!value.newSelection) {
                return;
            }
            value.cancel = true; // Disable selection in the drop down, because in autocomplete we do not save selection.
            var newValue = value.newSelection.value;
            var args = { value: newValue, cancel: false };
            this.onItemSelected.emit(args);
            if (args.cancel) {
                return;
            }
            this.close();
            this.nativeElement.focus();
            // Update model after the input is re-focused, in order to have proper valid styling.
            // Otherwise when item is selected using mouse (and input is blurred), then valid style will be removed.
            if (this.model) {
                this.model.control.setValue(newValue);
            }
            else {
                this.nativeElement.value = newValue;
            }
        };
        ;
        IgxAutocompleteDirective.prototype.highlightFirstItem = function () {
            if (this.target.focusedItem) {
                this.target.focusedItem.focused = false;
                this.target.focusedItem = null;
            }
            this.target.navigateFirst();
            this.cdr.detectChanges();
        };
        ;
        return IgxAutocompleteDirective;
    }(IgxDropDownItemNavigationDirective));
    IgxAutocompleteDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxAutocomplete]',
                    exportAs: 'igxAutocomplete'
                },] }
    ];
    IgxAutocompleteDirective.ctorParameters = function () { return [
        { type: forms.NgModel, decorators: [{ type: i0.Self }, { type: i0.Optional }, { type: i0.Inject, args: [forms.NgModel,] }] },
        { type: forms.FormControlName, decorators: [{ type: i0.Self }, { type: i0.Optional }, { type: i0.Inject, args: [forms.FormControlName,] }] },
        { type: IgxInputGroupComponent, decorators: [{ type: i0.Optional }] },
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxAutocompleteDirective.propDecorators = {
        target: [{ type: i0.Input, args: ['igxAutocomplete',] }],
        autocompleteSettings: [{ type: i0.Input, args: ['igxAutocompleteSettings',] }],
        autofill: [{ type: i0.HostBinding, args: ['attr.autocomplete',] }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        disabled: [{ type: i0.Input, args: ['igxAutocompleteDisabled',] }],
        onItemSelected: [{ type: i0.Output }],
        ariaExpanded: [{ type: i0.HostBinding, args: ['attr.aria-expanded',] }],
        hasPopUp: [{ type: i0.HostBinding, args: ['attr.aria-haspopup',] }],
        ariaOwns: [{ type: i0.HostBinding, args: ['attr.aria-owns',] }],
        ariaActiveDescendant: [{ type: i0.HostBinding, args: ['attr.aria-activedescendant',] }],
        ariaAutocomplete: [{ type: i0.HostBinding, args: ['attr.aria-autocomplete',] }],
        onInput: [{ type: i0.HostListener, args: ['input',] }],
        onArrowDown: [{ type: i0.HostListener, args: ['keydown.ArrowDown', ['$event'],] }, { type: i0.HostListener, args: ['keydown.Alt.ArrowDown', ['$event'],] }, { type: i0.HostListener, args: ['keydown.ArrowUp', ['$event'],] }, { type: i0.HostListener, args: ['keydown.Alt.ArrowUp', ['$event'],] }],
        onTab: [{ type: i0.HostListener, args: ['keydown.Tab',] }, { type: i0.HostListener, args: ['keydown.Shift.Tab',] }]
    };
    /** @hidden */
    var IgxAutocompleteModule = /** @class */ (function () {
        function IgxAutocompleteModule() {
        }
        return IgxAutocompleteModule;
    }());
    IgxAutocompleteModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [IgxDropDownModule, i2.CommonModule],
                    declarations: [IgxAutocompleteDirective],
                    exports: [IgxAutocompleteDirective]
                },] }
    ];

    var IgxDividerType = mkenum({
        SOLID: 'solid',
        DASHED: 'dashed'
    });
    var NEXT_ID$4 = 0;
    var IgxDividerDirective = /** @class */ (function () {
        function IgxDividerDirective() {
            /**
             * Sets/gets the `id` of the divider.
             * If not set, `id` will have value `"igx-divider-0"`;
             * ```html
             * <igx-divider id="my-divider"></igx-divider>
             * ```
             * ```typescript
             * let dividerId =  this.divider.id;
             * ```
             */
            this.id = "igx-divider-" + NEXT_ID$4++;
            /**
             * An @Input property that sets the value of `role` attribute.
             * If not the default value of `separator` will be used.
             */
            this.role = 'separator';
            /**
             * Sets the type of the divider. The default value
             * is `default`. The divider can also be `dashed`;
             * ```html
             * <igx-divider type="dashed"></igx-divider>
             * ```
             */
            this.type = IgxDividerType.SOLID;
            /**
             * An @Input that sets the `middle` attribute of the divider.
             * If set to `true` and an `inset` value has been provided,
             * the divider will start shrinking from both ends.
             * ```html
             * <igx-divider [middle]="true"></igx-divider>
             * ```
             */
            this.middle = false;
            /**
             * An @Input that sets the vertical attribute of the divider.
             * ```html
             * <igx-divider [vertical]="true"></igx-divider>
             * ```
             */
            this.vertical = false;
            /**
             * An @Input property that sets the value of the `inset` attribute.
             * If not provided it will be set to `'0'`.
             * ```html
             * <igx-divider inset="16px"></igx-divider>
             * ```
             */
            this._inset = '0';
        }
        Object.defineProperty(IgxDividerDirective.prototype, "isDashed", {
            get: function () {
                return this.type === IgxDividerType.DASHED;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDividerDirective.prototype, "inset", {
            /**
             * Gets the current divider inset in terms of
             * margin representation as applied to the divider.
             * ```typescript
             * const inset = this.divider.inset;
             * ```
             */
            get: function () {
                var baseMargin = '0';
                if (this.middle) {
                    if (this.vertical) {
                        return this._inset + " " + baseMargin;
                    }
                    return baseMargin + " " + this._inset;
                }
                else {
                    if (this.vertical) {
                        return this._inset + " " + baseMargin + " 0 " + baseMargin;
                    }
                    return baseMargin + " 0 " + baseMargin + " " + this._inset;
                }
            },
            /**
             * Sets the inset of the divider from the side(s).
             * If the divider attribute `middle` is set to `true`,
             * it will inset the divider on both sides.
             * ```typescript
             * this.divider.inset = '32px';
             * ```
             */
            set: function (value) {
                this._inset = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDividerDirective.prototype, "isSolid", {
            /**
             * A getter that returns `true` if the type of the divider is `default`;
             * ```typescript
             * const isDefault = this.divider.isDefault;
             * ```
             */
            get: function () {
                return this.type === IgxDividerType.SOLID;
            },
            enumerable: false,
            configurable: true
        });
        return IgxDividerDirective;
    }());
    IgxDividerDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'igx-divider'
                },] }
    ];
    IgxDividerDirective.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }, { type: i0.Input }],
        type: [{ type: i0.HostBinding, args: ['class.igx-divider',] }, { type: i0.Input }],
        isDashed: [{ type: i0.HostBinding, args: ['class.igx-divider--dashed',] }],
        middle: [{ type: i0.HostBinding, args: ['class.igx-divider--inset',] }, { type: i0.Input }],
        vertical: [{ type: i0.HostBinding, args: ['class.igx-divider--vertical',] }, { type: i0.Input }],
        inset: [{ type: i0.HostBinding, args: ['style.margin',] }],
        _inset: [{ type: i0.Input, args: ['inset',] }]
    };
    var IgxDividerModule = /** @class */ (function () {
        function IgxDividerModule() {
        }
        return IgxDividerModule;
    }());
    IgxDividerModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxDividerDirective],
                    exports: [IgxDividerDirective]
                },] }
    ];

    // @dynamic
    var IgxDefaultDropStrategy = /** @class */ (function () {
        function IgxDefaultDropStrategy() {
        }
        IgxDefaultDropStrategy.prototype.dropAction = function (drag, drop, atIndex) { };
        return IgxDefaultDropStrategy;
    }());
    // @dynamic
    var IgxAppendDropStrategy = /** @class */ (function () {
        function IgxAppendDropStrategy(_renderer) {
            this._renderer = _renderer;
        }
        IgxAppendDropStrategy.prototype.dropAction = function (drag, drop, atIndex) {
            var dragElement = drag.element.nativeElement;
            var dropAreaElement = drop.element.nativeElement;
            this._renderer.removeChild(dragElement.parentNode, dragElement);
            this._renderer.appendChild(dropAreaElement, dragElement);
        };
        return IgxAppendDropStrategy;
    }());
    // @dynamic
    var IgxPrependDropStrategy = /** @class */ (function () {
        function IgxPrependDropStrategy(_renderer) {
            this._renderer = _renderer;
        }
        IgxPrependDropStrategy.prototype.dropAction = function (drag, drop, atIndex) {
            var dragElement = drag.element.nativeElement;
            var dropAreaElement = drop.element.nativeElement;
            this._renderer.removeChild(dragElement.parentNode, dragElement);
            if (dropAreaElement.children.length) {
                this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[0]);
            }
            else {
                this._renderer.appendChild(dropAreaElement, dragElement);
            }
        };
        return IgxPrependDropStrategy;
    }());
    // @dynamic
    var IgxInsertDropStrategy = /** @class */ (function () {
        function IgxInsertDropStrategy(_renderer) {
            this._renderer = _renderer;
        }
        IgxInsertDropStrategy.prototype.dropAction = function (drag, drop, atIndex) {
            if (drag.element.nativeElement.parentElement === drop.element.nativeElement && atIndex === -1) {
                return;
            }
            var dragElement = drag.element.nativeElement;
            var dropAreaElement = drop.element.nativeElement;
            this._renderer.removeChild(dragElement.parentNode, dragElement);
            if (atIndex !== -1 && dropAreaElement.children.length > atIndex) {
                this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[atIndex]);
            }
            else {
                this._renderer.appendChild(dropAreaElement, dragElement);
            }
        };
        return IgxInsertDropStrategy;
    }());

    (function (DragDirection) {
        DragDirection[DragDirection["VERTICAL"] = 0] = "VERTICAL";
        DragDirection[DragDirection["HORIZONTAL"] = 1] = "HORIZONTAL";
        DragDirection[DragDirection["BOTH"] = 2] = "BOTH";
    })(exports.DragDirection || (exports.DragDirection = {}));
    var IgxDragLocation = /** @class */ (function () {
        function IgxDragLocation(_pageX, _pageY) {
            this._pageX = _pageX;
            this._pageY = _pageY;
            this.pageX = parseFloat(_pageX);
            this.pageY = parseFloat(_pageY);
        }
        return IgxDragLocation;
    }());
    var IgxDragHandleDirective = /** @class */ (function () {
        function IgxDragHandleDirective(element) {
            this.element = element;
            this.baseClass = true;
        }
        return IgxDragHandleDirective;
    }());
    IgxDragHandleDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDragHandle]'
                },] }
    ];
    IgxDragHandleDirective.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxDragHandleDirective.propDecorators = {
        baseClass: [{ type: i0.HostBinding, args: ['class.igx-drag__handle',] }]
    };
    var IgxDragIgnoreDirective = /** @class */ (function () {
        function IgxDragIgnoreDirective(element) {
            this.element = element;
            this.baseClass = true;
        }
        return IgxDragIgnoreDirective;
    }());
    IgxDragIgnoreDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDragIgnore]'
                },] }
    ];
    IgxDragIgnoreDirective.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxDragIgnoreDirective.propDecorators = {
        baseClass: [{ type: i0.HostBinding, args: ['class.igx-drag__ignore',] }]
    };
    var IgxDragDirective = /** @class */ (function () {
        function IgxDragDirective(cdr, element, viewContainer, zone, renderer, platformUtil) {
            this.cdr = cdr;
            this.element = element;
            this.viewContainer = viewContainer;
            this.zone = zone;
            this.renderer = renderer;
            this.platformUtil = platformUtil;
            /**
             * An @Input property that indicates when the drag should start.
             * By default the drag starts after the draggable element is moved by 5px.
             * ```html
             * <div igxDrag [dragTolerance]="100">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             *
             * @memberof IgxDragDirective
             */
            this.dragTolerance = 5;
            /**
             * An @Input property that indicates the directions that the element can be dragged.
             * By default it is set to both horizontal and vertical directions.
             * ```html
             * <div igxDrag [dragDirection]="dragDir">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public dragDir = DragDirection.HORIZONTAL;
             * ```
             *
             * @memberof IgxDragDirective
             */
            this.dragDirection = exports.DragDirection.BOTH;
            /**
             * An @Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
             * By default it is set to `true`.
             * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
             * ```html
             * <div igxDrag [ghost]="false">
             *      <span>Drag Me!</span>
             * </div>
             * ```
             *
             * @memberof IgxDragDirective
             */
            this.ghost = true;
            /**
             * Sets a custom class that will be added to the `ghostElement` element.
             * ```html
             * <div igxDrag [ghostClass]="'ghostElement'">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             *
             * @memberof IgxDragDirective
             */
            this.ghostClass = '';
            /**
             * Event triggered when the draggable element drag starts.
             * ```html
             * <div igxDrag (dragStart)="onDragStart()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public onDragStart(){
             *      alert("The drag has stared!");
             * }
             * ```
             *
             * @memberof IgxDragDirective
             */
            this.dragStart = new i0.EventEmitter();
            /**
             * Event triggered when the draggable element has been moved.
             * ```html
             * <div igxDrag  (dragMove)="onDragMove()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public onDragMove(){
             *      alert("The element has moved!");
             * }
             * ```
             *
             * @memberof IgxDragDirective
             */
            this.dragMove = new i0.EventEmitter();
            /**
             * Event triggered when the draggable element is released.
             * ```html
             * <div igxDrag (dragEnd)="onDragEnd()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public onDragEnd(){
             *      alert("The drag has ended!");
             * }
             * ```
             *
             * @memberof IgxDragDirective
             */
            this.dragEnd = new i0.EventEmitter();
            /**
             * Event triggered when the draggable element is clicked.
             * ```html
             * <div igxDrag (dragClick)="onDragClick()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public onDragClick(){
             *      alert("The element has been clicked!");
             * }
             * ```
             *
             * @memberof IgxDragDirective
             */
            this.dragClick = new i0.EventEmitter();
            /**
             * Event triggered when the drag ghost element is created.
             * ```html
             * <div igxDrag (ghostCreate)="ghostCreated()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public ghostCreated(){
             *      alert("The ghost has been created!");
             * }
             * ```
             *
             * @memberof IgxDragDirective
             */
            this.ghostCreate = new i0.EventEmitter();
            /**
             * Event triggered when the drag ghost element is created.
             * ```html
             * <div igxDrag (ghostDestroy)="ghostDestroyed()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public ghostDestroyed(){
             *      alert("The ghost has been destroyed!");
             * }
             * ```
             *
             * @memberof IgxDragDirective
             */
            this.ghostDestroy = new i0.EventEmitter();
            /**
             * Event triggered after the draggable element is released and after its animation has finished.
             * ```html
             * <div igxDrag (transitioned)="onMoveEnd()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public onMoveEnd(){
             *      alert("The move has ended!");
             * }
             * ```
             *
             * @memberof IgxDragDirective
             */
            this.transitioned = new i0.EventEmitter();
            /**
             * @hidden
             */
            this.baseClass = true;
            /**
             * @hidden
             */
            this.selectDisabled = false;
            /**
             * @hidden
             */
            this.defaultReturnDuration = '0.5s';
            /**
             * @hidden
             */
            this.animInProgress = false;
            this.ghostContext = null;
            this._startX = 0;
            this._startY = 0;
            this._lastX = 0;
            this._lastY = 0;
            this._dragStarted = false;
            this._ghostHostX = 0;
            this._ghostHostY = 0;
            this._pointerDownId = null;
            this._clicked = false;
            this._lastDropArea = null;
            this._destroy = new rxjs.Subject();
            this._removeOnDestroy = true;
        }
        Object.defineProperty(IgxDragDirective.prototype, "location", {
            /**
             * Gets the current location of the element relative to the page.
             */
            get: function () {
                return new IgxDragLocation(this.pageX, this.pageY);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "originLocation", {
            /**
             * Gets the original location of the element before dragging started.
             */
            get: function () {
                return new IgxDragLocation(this.baseOriginLeft, this.baseOriginTop);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "pointerEventsEnabled", {
            /**
             * @hidden
             */
            get: function () {
                return typeof PointerEvent !== 'undefined';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "touchEventsEnabled", {
            /**
             * @hidden
             */
            get: function () {
                return 'ontouchstart' in window;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "pageX", {
            /**
             * @hidden
             */
            get: function () {
                if (this.ghost && this.ghostElement) {
                    return this.ghostLeft;
                }
                return this.baseLeft;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "pageY", {
            /**
             * @hidden
             */
            get: function () {
                if (this.ghost && this.ghostElement) {
                    return this.ghostTop;
                }
                return this.baseTop;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "baseLeft", {
            get: function () {
                return this.element.nativeElement.getBoundingClientRect().left;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "baseTop", {
            get: function () {
                return this.element.nativeElement.getBoundingClientRect().top;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "baseOriginLeft", {
            get: function () {
                return this.baseLeft - this.getTransformX(this.element.nativeElement);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "baseOriginTop", {
            get: function () {
                return this.baseTop - this.getTransformY(this.element.nativeElement);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "ghostLeft", {
            get: function () {
                return parseInt(this.ghostElement.style.left, 10) + this._ghostHostX;
            },
            set: function (pageX) {
                if (this.ghostElement) {
                    // We need to take into account marginLeft, since top style does not include margin, but pageX includes the margin.
                    var ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
                    // If ghost host is defined it needs to be taken into account.
                    this.ghostElement.style.left = (pageX - ghostMarginLeft - this._ghostHostX) + 'px';
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "ghostTop", {
            get: function () {
                return parseInt(this.ghostElement.style.top, 10) + this._ghostHostY;
            },
            set: function (pageY) {
                if (this.ghostElement) {
                    // We need to take into account marginTop, since top style does not include margin, but pageY includes the margin.
                    var ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
                    // If ghost host is defined it needs to be taken into account.
                    this.ghostElement.style.top = (pageY - ghostMarginTop - this._ghostHostY) + 'px';
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "ghostOffsetX", {
            get: function () {
                return this._offsetX !== undefined ? this._offsetX : this._defaultOffsetX;
            },
            /**
             * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
             * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
             * ```html
             * <div #hostDiv></div>
             * <div igxDrag [ghostOffsetX]="0">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             *
             * @memberof IgxDragDirective
             */
            set: function (value) {
                this._offsetX = parseInt(value, 10);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "ghostOffsetY", {
            get: function () {
                return this._offsetY !== undefined ? this._offsetY : this._defaultOffsetY;
            },
            /**
             * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
             * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
             * ```html
             * <div #hostDiv></div>
             * <div igxDrag [ghostOffsetY]="0">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             *
             * @memberof IgxDragDirective
             */
            set: function (value) {
                this._offsetY = parseInt(value, 10);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxDragDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (!this.dragHandles || !this.dragHandles.length) {
                // Set user select none to the whole draggable element if no drag handles are defined.
                this.selectDisabled = true;
            }
            // Bind events
            this.zone.runOutsideAngular(function () {
                if (!_this.platformUtil.isBrowser) {
                    return;
                }
                var targetElements = _this.dragHandles && _this.dragHandles.length ?
                    _this.dragHandles.map(function (item) { return item.element.nativeElement; }) : [_this.element.nativeElement];
                targetElements.forEach(function (element) {
                    if (_this.pointerEventsEnabled) {
                        rxjs.fromEvent(element, 'pointerdown').pipe(operators.takeUntil(_this._destroy))
                            .subscribe(function (res) { return _this.onPointerDown(res); });
                        rxjs.fromEvent(element, 'pointermove').pipe(operators.throttle(function () { return rxjs.interval(0, rxjs.animationFrameScheduler); }), operators.takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                        rxjs.fromEvent(element, 'pointerup').pipe(operators.takeUntil(_this._destroy))
                            .subscribe(function (res) { return _this.onPointerUp(res); });
                        if (!_this.ghost) {
                            // Do not bind `lostpointercapture` to the target, because we will bind it on the ghost later.
                            rxjs.fromEvent(element, 'lostpointercapture').pipe(operators.takeUntil(_this._destroy))
                                .subscribe(function (res) { return _this.onPointerLost(res); });
                        }
                    }
                    else if (_this.touchEventsEnabled) {
                        rxjs.fromEvent(element, 'touchstart').pipe(operators.takeUntil(_this._destroy))
                            .subscribe(function (res) { return _this.onPointerDown(res); });
                    }
                    else {
                        // We don't have pointer events and touch events. Use then mouse events.
                        rxjs.fromEvent(element, 'mousedown').pipe(operators.takeUntil(_this._destroy))
                            .subscribe(function (res) { return _this.onPointerDown(res); });
                    }
                });
                // We should bind to document events only once when there are no pointer events.
                if (!_this.pointerEventsEnabled && _this.touchEventsEnabled) {
                    rxjs.fromEvent(document.defaultView, 'touchmove').pipe(operators.throttle(function () { return rxjs.interval(0, rxjs.animationFrameScheduler); }), operators.takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                    rxjs.fromEvent(document.defaultView, 'touchend').pipe(operators.takeUntil(_this._destroy))
                        .subscribe(function (res) { return _this.onPointerUp(res); });
                }
                else if (!_this.pointerEventsEnabled) {
                    rxjs.fromEvent(document.defaultView, 'mousemove').pipe(operators.throttle(function () { return rxjs.interval(0, rxjs.animationFrameScheduler); }), operators.takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                    rxjs.fromEvent(document.defaultView, 'mouseup').pipe(operators.takeUntil(_this._destroy))
                        .subscribe(function (res) { return _this.onPointerUp(res); });
                }
                _this.element.nativeElement.addEventListener('transitionend', function (args) {
                    _this.onTransitionEnd(args);
                });
            });
            // Set transition duration to 0s. This also helps with setting `visibility: hidden` to the base to not lag.
            this.element.nativeElement.style.transitionDuration = '0.0s';
        };
        /**
         * @hidden
         */
        IgxDragDirective.prototype.ngOnDestroy = function () {
            this._destroy.next(true);
            this._destroy.complete();
            if (this.ghost && this.ghostElement && this._removeOnDestroy) {
                this.ghostElement.parentNode.removeChild(this.ghostElement);
                this.ghostElement = null;
            }
        };
        /**
         * Sets desired location of the base element or ghost element if rended relative to the document.
         *
         * @param newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
         */
        IgxDragDirective.prototype.setLocation = function (newLocation) {
            // We do not subtract marginLeft and marginTop here because here we calculate deltas.
            if (this.ghost && this.ghostElement) {
                var offsetHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
                var offsetHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
                this.ghostLeft = newLocation.pageX - offsetHostX + this.getWindowScrollLeft();
                this.ghostTop = newLocation.pageY - offsetHostY + this.getWindowScrollTop();
            }
            else if (!this.ghost) {
                var deltaX = newLocation.pageX - this.pageX;
                var deltaY = newLocation.pageY - this.pageY;
                var transformX = this.getTransformX(this.element.nativeElement);
                var transformY = this.getTransformY(this.element.nativeElement);
                this.setTransformXY(transformX + deltaX, transformY + deltaY);
            }
            this._startX = this.baseLeft;
            this._startY = this.baseTop;
        };
        /**
         * Animates the base or ghost element depending on the `ghost` input to its initial location.
         * If `ghost` is true but there is not ghost rendered, it will be created and animated.
         * If the base element has changed its DOM position its initial location will be changed accordingly.
         *
         * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
         * @param startLocation Start location from where the transition should start.
         */
        IgxDragDirective.prototype.transitionToOrigin = function (customAnimArgs, startLocation) {
            var _this = this;
            if ((!!startLocation && startLocation.pageX === this.baseOriginLeft && startLocation.pageY === this.baseOriginLeft) ||
                (!startLocation && this.ghost && !this.ghostElement)) {
                return;
            }
            if (!!startLocation && startLocation.pageX !== this.pageX && startLocation.pageY !== this.pageY) {
                if (this.ghost && !this.ghostElement) {
                    this._startX = startLocation.pageX;
                    this._startY = startLocation.pageY;
                    this._ghostStartX = this._startX;
                    this._ghostStartY = this._startY;
                    this.createGhost(this._startX, this._startY);
                }
                this.setLocation(startLocation);
            }
            this.animInProgress = true;
            // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
            setTimeout(function () {
                if (_this.ghost) {
                    _this.ghostElement.style.transitionProperty = 'top, left';
                    _this.ghostElement.style.transitionDuration =
                        customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : _this.defaultReturnDuration;
                    _this.ghostElement.style.transitionTimingFunction =
                        customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                    _this.ghostElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                    _this.setLocation(new IgxDragLocation(_this.baseLeft, _this.baseTop));
                }
                else if (!_this.ghost) {
                    _this.element.nativeElement.style.transitionProperty = 'transform';
                    _this.element.nativeElement.style.transitionDuration =
                        customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : _this.defaultReturnDuration;
                    _this.element.nativeElement.style.transitionTimingFunction =
                        customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                    _this.element.nativeElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                    _this._startX = _this.baseLeft;
                    _this._startY = _this.baseTop;
                    _this.setTransformXY(0, 0);
                }
            }, 0);
        };
        /**
         * Animates the base or ghost element to a specific target location or other element using transition.
         * If `ghost` is true but there is not ghost rendered, it will be created and animated.
         * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
         *
         * @param target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
         * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
         * @param startLocation Start location from where the transition should start.
         */
        IgxDragDirective.prototype.transitionTo = function (target, customAnimArgs, startLocation) {
            var _this = this;
            if (!!startLocation && this.ghost && !this.ghostElement) {
                this._startX = startLocation.pageX;
                this._startY = startLocation.pageY;
                this._ghostStartX = this._startX;
                this._ghostStartY = this._startY;
            }
            else if (!!startLocation && (!this.ghost || this.ghostElement)) {
                this.setLocation(startLocation);
            }
            else if (this.ghost && !this.ghostElement) {
                this._startX = this.baseLeft;
                this._startY = this.baseTop;
                this._ghostStartX = this._startX + this.getWindowScrollLeft();
                this._ghostStartY = this._startY + this.getWindowScrollTop();
            }
            if (this.ghost && !this.ghostElement) {
                this.createGhost(this._startX, this._startY);
            }
            this.animInProgress = true;
            // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
            setTimeout(function () {
                var movedElem = _this.ghost ? _this.ghostElement : _this.element.nativeElement;
                movedElem.style.transitionProperty = _this.ghost && _this.ghostElement ? 'left, top' : 'transform';
                movedElem.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : _this.defaultReturnDuration;
                movedElem.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                movedElem.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                if (target instanceof IgxDragLocation) {
                    _this.setLocation(new IgxDragLocation(target.pageX, target.pageY));
                }
                else {
                    var targetRects = target.nativeElement.getBoundingClientRect();
                    _this.setLocation(new IgxDragLocation(targetRects.left - _this.getWindowScrollLeft(), targetRects.top - _this.getWindowScrollTop()));
                }
            }, 0);
        };
        /**
         * @hidden
         * Method bound to the PointerDown event of the base element igxDrag is initialized.
         * @param event PointerDown event captured
         */
        IgxDragDirective.prototype.onPointerDown = function (event) {
            var ignoredElement = this.dragIgnoredElems.find(function (elem) { return elem.element.nativeElement === event.target; });
            if (ignoredElement) {
                return;
            }
            this._clicked = true;
            this._pointerDownId = event.pointerId;
            // Set pointer capture so we detect pointermove even if mouse is out of bounds until ghostElement is created.
            var handleFound = this.dragHandles.find(function (handle) { return handle.element.nativeElement === event.currentTarget; });
            var targetElement = handleFound ? handleFound.element.nativeElement : this.element.nativeElement;
            if (this.pointerEventsEnabled) {
                targetElement.setPointerCapture(this._pointerDownId);
            }
            else {
                targetElement.focus();
                event.preventDefault();
            }
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                this._startX = event.pageX;
                this._startY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                this._startX = event.touches[0].pageX;
                this._startY = event.touches[0].pageY;
            }
            this._defaultOffsetX = this.baseLeft - this._startX + this.getWindowScrollLeft();
            this._defaultOffsetY = this.baseTop - this._startY + this.getWindowScrollTop();
            this._ghostStartX = this._startX + this.ghostOffsetX;
            this._ghostStartY = this._startY + this.ghostOffsetY;
            this._lastX = this._startX;
            this._lastY = this._startY;
        };
        /**
         * @hidden
         * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
         * This method is bound at first at the base element.
         * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
         * @param event PointerMove event captured
         */
        IgxDragDirective.prototype.onPointerMove = function (event) {
            var _this = this;
            if (this._clicked) {
                var pageX = void 0;
                var pageY = void 0;
                if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                    // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                    pageX = event.pageX;
                    pageY = event.pageY;
                }
                else if (this.touchEventsEnabled) {
                    pageX = event.touches[0].pageX;
                    pageY = event.touches[0].pageY;
                    // Prevent scrolling on touch while dragging
                    event.preventDefault();
                }
                var totalMovedX = pageX - this._startX;
                var totalMovedY = pageY - this._startY;
                if (!this._dragStarted &&
                    (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                    var dragStartArgs_1 = {
                        originalEvent: event,
                        owner: this,
                        startX: pageX - totalMovedX,
                        startY: pageY - totalMovedY,
                        pageX: pageX,
                        pageY: pageY,
                        cancel: false
                    };
                    this.zone.run(function () {
                        _this.dragStart.emit(dragStartArgs_1);
                    });
                    if (!dragStartArgs_1.cancel) {
                        this._dragStarted = true;
                        if (this.ghost) {
                            // We moved enough so ghostElement can be rendered and actual dragging to start.
                            // When creating it will take into account any offset set by the user by default.
                            this.createGhost(pageX, pageY);
                        }
                        else if (this._offsetX !== undefined || this._offsetY !== undefined) {
                            // There is no need for ghost, but we will need to position initially the base element to reflect any offset.
                            var transformX = (this._offsetX !== undefined ? this._offsetX - this._defaultOffsetX : 0) +
                                this.getTransformX(this.element.nativeElement);
                            var transformY = (this._offsetY !== undefined ? this._offsetY - this._defaultOffsetY : 0) +
                                this.getTransformY(this.element.nativeElement);
                            this.setTransformXY(transformX, transformY);
                        }
                    }
                    else {
                        return;
                    }
                }
                else if (!this._dragStarted) {
                    return;
                }
                var moveArgs = {
                    originalEvent: event,
                    owner: this,
                    startX: this._startX,
                    startY: this._startY,
                    pageX: this._lastX,
                    pageY: this._lastY,
                    nextPageX: pageX,
                    nextPageY: pageY,
                    cancel: false
                };
                this.dragMove.emit(moveArgs);
                var setPageX = moveArgs.nextPageX;
                var setPageY = moveArgs.nextPageY;
                if (!moveArgs.cancel) {
                    if (this.ghost) {
                        var updatedTotalMovedX = this.dragDirection === exports.DragDirection.VERTICAL ? 0 : setPageX - this._startX;
                        var updatedTotalMovedY = this.dragDirection === exports.DragDirection.HORIZONTAL ? 0 : setPageY - this._startY;
                        this.ghostLeft = this._ghostStartX + updatedTotalMovedX;
                        this.ghostTop = this._ghostStartY + updatedTotalMovedY;
                    }
                    else {
                        var lastMovedX = this.dragDirection === exports.DragDirection.VERTICAL ? 0 : setPageX - this._lastX;
                        var lastMovedY = this.dragDirection === exports.DragDirection.HORIZONTAL ? 0 : setPageY - this._lastY;
                        var translateX = this.getTransformX(this.element.nativeElement) + lastMovedX;
                        var translateY = this.getTransformY(this.element.nativeElement) + lastMovedY;
                        this.setTransformXY(translateX, translateY);
                    }
                    this.dispatchDragEvents(pageX, pageY, event);
                }
                this._lastX = setPageX;
                this._lastY = setPageY;
            }
        };
        /**
         * @hidden
         * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
         * This method is bound at first at the base element.
         * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
         * @param event PointerUp event captured
         */
        IgxDragDirective.prototype.onPointerUp = function (event) {
            var _this = this;
            if (!this._clicked) {
                return;
            }
            var pageX;
            var pageY;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            var eventArgs = {
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: pageX,
                pageY: pageY
            };
            this._pointerDownId = null;
            this._clicked = false;
            if (this._dragStarted) {
                if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                    this.dispatchDropEvent(event.pageX, event.pageY, event);
                }
                this.zone.run(function () {
                    _this.dragEnd.emit(eventArgs);
                });
                if (!this.animInProgress) {
                    this.onTransitionEnd(null);
                }
            }
            else {
                // Trigger our own click event because when there is no ghost, native click cannot be prevented when dragging.
                this.zone.run(function () {
                    _this.dragClick.emit(eventArgs);
                });
            }
        };
        /**
         * @hidden
         * Execute this method whe the pointer capture has been lost.
         * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
         * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
         * @param event Event captured
         */
        IgxDragDirective.prototype.onPointerLost = function (event) {
            var _this = this;
            if (!this._clicked) {
                return;
            }
            var eventArgs = {
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: event.pageX,
                pageY: event.pageY
            };
            this._pointerDownId = null;
            this._clicked = false;
            if (this._dragStarted) {
                this.zone.run(function () {
                    _this.dragEnd.emit(eventArgs);
                });
                if (!this.animInProgress) {
                    this.onTransitionEnd(null);
                }
            }
        };
        /**
         * @hidden
         */
        IgxDragDirective.prototype.onTransitionEnd = function (event) {
            var _this = this;
            if ((!this._dragStarted && !this.animInProgress) || this._clicked) {
                // Return if no dragging started and there is no animation in progress.
                return;
            }
            if (this.ghost && this.ghostElement) {
                this._ghostStartX = this.baseLeft + this.getWindowScrollLeft();
                this._ghostStartY = this.baseTop + this.getWindowScrollTop();
                var ghostDestroyArgs = {
                    owner: this,
                    ghostElement: this.ghostElement,
                    cancel: false
                };
                this.ghostDestroy.emit(ghostDestroyArgs);
                if (ghostDestroyArgs.cancel) {
                    return;
                }
                this.ghostElement.parentNode.removeChild(this.ghostElement);
                this.ghostElement = null;
            }
            else if (!this.ghost) {
                this.element.nativeElement.style.transitionProperty = '';
                this.element.nativeElement.style.transitionDuration = '0.0s';
                this.element.nativeElement.style.transitionTimingFunction = '';
                this.element.nativeElement.style.transitionDelay = '';
            }
            this.animInProgress = false;
            this._dragStarted = false;
            // Execute transitioned after everything is reset so if the user sets new location on the base now it would work as expected.
            this.zone.run(function () {
                _this.transitioned.emit({
                    originalEvent: event,
                    owner: _this,
                    startX: _this._startX,
                    startY: _this._startY,
                    pageX: _this._startX,
                    pageY: _this._startY
                });
            });
        };
        /**
         * @hidden
         * Create ghost element - if a Node object is provided it creates a clone of that node,
         * otherwise it clones the host element.
         * Bind all needed events.
         * @param pageX Latest pointer position on the X axis relative to the page.
         * @param pageY Latest pointer position on the Y axis relative to the page.
         * @param node The Node object to be cloned.
         */
        IgxDragDirective.prototype.createGhost = function (pageX, pageY, node) {
            var _this = this;
            if (node === void 0) { node = null; }
            if (!this.ghost) {
                return;
            }
            var dynamicGhostRef;
            if (this.ghostTemplate) {
                dynamicGhostRef = this.viewContainer.createEmbeddedView(this.ghostTemplate, this.ghostContext);
                this.ghostElement = dynamicGhostRef.rootNodes[0];
            }
            else {
                this.ghostElement = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);
            }
            var totalMovedX = pageX - this._startX;
            var totalMovedY = pageY - this._startY;
            this._ghostHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
            this._ghostHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
            this.ghostElement.style.transitionDuration = '0.0s';
            this.ghostElement.style.position = 'absolute';
            if (this.ghostClass) {
                this.renderer.addClass(this.ghostElement, this.ghostClass);
            }
            var createEventArgs = {
                owner: this,
                ghostElement: this.ghostElement,
                cancel: false
            };
            this.ghostCreate.emit(createEventArgs);
            if (createEventArgs.cancel) {
                this.ghostElement = null;
                if (this.ghostTemplate && dynamicGhostRef) {
                    dynamicGhostRef.destroy();
                }
                return;
            }
            if (this.ghostHost) {
                this.ghostHost.appendChild(this.ghostElement);
            }
            else {
                document.body.appendChild(this.ghostElement);
            }
            var ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
            var ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
            this.ghostElement.style.left = (this._ghostStartX - ghostMarginLeft + totalMovedX - this._ghostHostX) + 'px';
            this.ghostElement.style.top = (this._ghostStartY - ghostMarginTop + totalMovedY - this._ghostHostX) + 'px';
            if (this.pointerEventsEnabled) {
                // The ghostElement takes control for moving and dragging after it has been rendered.
                if (this._pointerDownId !== null) {
                    this.ghostElement.setPointerCapture(this._pointerDownId);
                }
                this.ghostElement.addEventListener('pointermove', function (args) {
                    _this.onPointerMove(args);
                });
                this.ghostElement.addEventListener('pointerup', function (args) {
                    _this.onPointerUp(args);
                });
                this.ghostElement.addEventListener('lostpointercapture', function (args) {
                    _this.onPointerLost(args);
                });
            }
            // Transition animation when the ghostElement is released and it returns to it's original position.
            this.ghostElement.addEventListener('transitionend', function (args) {
                _this.onTransitionEnd(args);
            });
            this.cdr.detectChanges();
        };
        /**
         * @hidden
         * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
         */
        IgxDragDirective.prototype.dispatchDragEvents = function (pageX, pageY, originalEvent) {
            var e_1, _a;
            var topDropArea;
            var customEventArgs = {
                startX: this._startX,
                startY: this._startY,
                pageX: pageX,
                pageY: pageY,
                owner: this,
                originalEvent: originalEvent
            };
            var elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
            try {
                for (var elementsFromPoint_1 = __values(elementsFromPoint), elementsFromPoint_1_1 = elementsFromPoint_1.next(); !elementsFromPoint_1_1.done; elementsFromPoint_1_1 = elementsFromPoint_1.next()) {
                    var element = elementsFromPoint_1_1.value;
                    if (element.getAttribute('droppable') === 'true' &&
                        element !== this.ghostElement && element !== this.element.nativeElement) {
                        topDropArea = element;
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (elementsFromPoint_1_1 && !elementsFromPoint_1_1.done && (_a = elementsFromPoint_1.return)) _a.call(elementsFromPoint_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (topDropArea &&
                (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
                if (this._lastDropArea) {
                    this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
                }
                this._lastDropArea = topDropArea;
                this.dispatchEvent(this._lastDropArea, 'igxDragEnter', customEventArgs);
            }
            else if (!topDropArea && this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
                this._lastDropArea = null;
                return;
            }
            if (topDropArea) {
                this.dispatchEvent(topDropArea, 'igxDragOver', customEventArgs);
            }
        };
        /**
         * @hidden
         * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
         * Last recorder drop area is updated in @dispatchDragEvents method.
         */
        IgxDragDirective.prototype.dispatchDropEvent = function (pageX, pageY, originalEvent) {
            var eventArgs = {
                startX: this._startX,
                startY: this._startY,
                pageX: pageX,
                pageY: pageY,
                owner: this,
                originalEvent: originalEvent
            };
            this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
            this._lastDropArea = null;
        };
        /**
         * @hidden
         */
        IgxDragDirective.prototype.getElementsAtPoint = function (pageX, pageY) {
            // correct the coordinates with the current scroll position, because
            // document.elementsFromPoint consider position within the current viewport
            // window.pageXOffset == window.scrollX; // always true
            // using window.pageXOffset for IE9 compatibility
            var viewPortX = pageX - window.pageXOffset;
            var viewPortY = pageY - window.pageYOffset;
            if (document['msElementsFromPoint']) {
                // Edge and IE special snowflakes
                var elements = document['msElementsFromPoint'](viewPortX, viewPortY);
                return elements === null ? [] : elements;
            }
            else {
                // Other browsers like Chrome, Firefox, Opera
                return document.elementsFromPoint(viewPortX, viewPortY);
            }
        };
        /**
         * @hidden
         */
        IgxDragDirective.prototype.dispatchEvent = function (target, eventName, eventArgs) {
            // This way is IE11 compatible.
            var dragLeaveEvent = document.createEvent('CustomEvent');
            dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
            target.dispatchEvent(dragLeaveEvent);
            // Otherwise can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
        };
        IgxDragDirective.prototype.getTransformX = function (elem) {
            var posX = 0;
            if (elem.style.transform) {
                var matrix = elem.style.transform;
                var values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
                posX = values ? Number(values[1]) : 0;
            }
            return posX;
        };
        IgxDragDirective.prototype.getTransformY = function (elem) {
            var posY = 0;
            if (elem.style.transform) {
                var matrix = elem.style.transform;
                var values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
                posY = values ? Number(values[2]) : 0;
            }
            return posY;
        };
        /** Method setting transformation to the base draggable element. */
        IgxDragDirective.prototype.setTransformXY = function (x, y) {
            this.element.nativeElement.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)';
        };
        IgxDragDirective.prototype.getWindowScrollTop = function () {
            return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
        };
        IgxDragDirective.prototype.getWindowScrollLeft = function () {
            return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
        };
        IgxDragDirective.prototype.ghostHostOffsetLeft = function (ghostHost) {
            var ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
            if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
                return 0;
            }
            else if (ghostPosition === 'static' && ghostHost.offsetParent) {
                return ghostHost.offsetParent.getBoundingClientRect().left - this.getWindowScrollLeft();
            }
            return ghostHost.getBoundingClientRect().left - this.getWindowScrollLeft();
        };
        IgxDragDirective.prototype.ghostHostOffsetTop = function (ghostHost) {
            var ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
            if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
                return 0;
            }
            else if (ghostPosition === 'static' && ghostHost.offsetParent) {
                return ghostHost.offsetParent.getBoundingClientRect().top - this.getWindowScrollTop();
            }
            return ghostHost.getBoundingClientRect().top - this.getWindowScrollTop();
        };
        return IgxDragDirective;
    }());
    IgxDragDirective.decorators = [
        { type: i0.Directive, args: [{
                    exportAs: 'drag',
                    selector: '[igxDrag]'
                },] }
    ];
    IgxDragDirective.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef },
        { type: i0.ElementRef },
        { type: i0.ViewContainerRef },
        { type: i0.NgZone },
        { type: i0.Renderer2 },
        { type: PlatformUtil }
    ]; };
    IgxDragDirective.propDecorators = {
        data: [{ type: i0.Input, args: ['igxDrag',] }],
        dragTolerance: [{ type: i0.Input }],
        dragDirection: [{ type: i0.Input }],
        dragChannel: [{ type: i0.Input }],
        ghost: [{ type: i0.Input }],
        ghostClass: [{ type: i0.Input }],
        ghostTemplate: [{ type: i0.Input }],
        ghostHost: [{ type: i0.Input }],
        dragStart: [{ type: i0.Output }],
        dragMove: [{ type: i0.Output }],
        dragEnd: [{ type: i0.Output }],
        dragClick: [{ type: i0.Output }],
        ghostCreate: [{ type: i0.Output }],
        ghostDestroy: [{ type: i0.Output }],
        transitioned: [{ type: i0.Output }],
        dragHandles: [{ type: i0.ContentChildren, args: [IgxDragHandleDirective, { descendants: true },] }],
        dragIgnoredElems: [{ type: i0.ContentChildren, args: [IgxDragIgnoreDirective, { descendants: true },] }],
        baseClass: [{ type: i0.HostBinding, args: ['class.igx-drag',] }],
        selectDisabled: [{ type: i0.HostBinding, args: ['class.igx-drag--select-disabled',] }],
        ghostOffsetX: [{ type: i0.Input }],
        ghostOffsetY: [{ type: i0.Input }]
    };
    var IgxDropDirective = /** @class */ (function () {
        function IgxDropDirective(element, _renderer, _zone) {
            this.element = element;
            this._renderer = _renderer;
            this._zone = _zone;
            /**
             * Event triggered when dragged element enters the area of the element.
             * ```html
             * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
             * </div>
             * ```
             * ```typescript
             * public dragEnter(){
             *     alert("A draggable element has entered the chip area!");
             * }
             * ```
             *
             * @memberof IgxDropDirective
             */
            this.enter = new i0.EventEmitter();
            /**
             * Event triggered when dragged element enters the area of the element.
             * ```html
             * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
             * </div>
             * ```
             * ```typescript
             * public dragEnter(){
             *     alert("A draggable element has entered the chip area!");
             * }
             * ```
             *
             * @memberof IgxDropDirective
             */
            this.over = new i0.EventEmitter();
            /**
             * Event triggered when dragged element leaves the area of the element.
             * ```html
             * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
             * </div>
             * ```
             * ```typescript
             * public dragLeave(){
             *     alert("A draggable element has left the chip area!");
             * }
             * ```
             *
             * @memberof IgxDropDirective
             */
            this.leave = new i0.EventEmitter();
            /**
             * Event triggered when dragged element is dropped in the area of the element.
             * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
             * To cancel the default logic the `cancel` property of the event needs to be set to true.
             * ```html
             * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
             * </div>
             * ```
             * ```typescript
             * public dragDrop(){
             *     alert("A draggable element has been dropped in the chip area!");
             * }
             * ```
             *
             * @memberof IgxDropDirective
             */
            this.dropped = new i0.EventEmitter();
            /**
             * @hidden
             */
            this.droppable = true;
            /**
             * @hidden
             */
            this.dragover = false;
            /**
             * @hidden
             */
            this._destroy = new rxjs.Subject();
            this._dropStrategy = new IgxDefaultDropStrategy();
        }
        Object.defineProperty(IgxDropDirective.prototype, "data", {
            get: function () {
                return this._data;
            },
            /**
             * - Save data inside the `igxDrop` directive. This can be set when instancing `igxDrop` on an element.
             * ```html
             * <div [igxDrop]="{ source: myElement }"></div>
             * ```
             *
             * @memberof IgxDropDirective
             */
            set: function (v) {
                this._data = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDropDirective.prototype, "dropStrategy", {
            get: function () {
                return this._dropStrategy;
            },
            /**
             * An @Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
             *  the current drop area. The provided strategies are:
             *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
             *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
             *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
             *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
             *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
             * ```html
             * <div igxDrag>
             *      <span>DragMe</span>
             * </div>
             * <div igxDrop [dropStrategy]="myDropStrategy">
             *         <span>Numbers drop area!</span>
             * </div>
             * ```
             * ```typescript
             * import { IgxAppendDropStrategy } from 'igniteui-angular';
             *
             * export class App {
             *      public myDropStrategy = IgxAppendDropStrategy;
             * }
             * ```
             *
             * @memberof IgxDropDirective
             */
            set: function (classRef) {
                this._dropStrategy = new classRef(this._renderer);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxDropDirective.prototype.onDragDrop = function (event) {
            var _this = this;
            if (!this.isDragLinked(event.detail.owner)) {
                return;
            }
            var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
            var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
            var offsetX = event.detail.pageX - elementPosX;
            var offsetY = event.detail.pageY - elementPosY;
            var args = {
                owner: this,
                originalEvent: event.detail.originalEvent,
                drag: event.detail.owner,
                dragData: event.detail.owner.data,
                startX: event.detail.startX,
                startY: event.detail.startY,
                pageX: event.detail.pageX,
                pageY: event.detail.pageY,
                offsetX: offsetX,
                offsetY: offsetY,
                cancel: false
            };
            this._zone.run(function () {
                _this.dropped.emit(args);
            });
            if (this._dropStrategy && !args.cancel) {
                var elementsAtPoint = event.detail.owner.getElementsAtPoint(event.detail.pageX, event.detail.pageY);
                var insertIndex = this.getInsertIndexAt(event.detail.owner, elementsAtPoint);
                this._dropStrategy.dropAction(event.detail.owner, this, insertIndex);
            }
        };
        /**
         * @hidden
         */
        IgxDropDirective.prototype.ngOnInit = function () {
            var _this = this;
            this._zone.runOutsideAngular(function () {
                rxjs.fromEvent(_this.element.nativeElement, 'igxDragEnter').pipe(operators.takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onDragEnter(res); });
                rxjs.fromEvent(_this.element.nativeElement, 'igxDragLeave').pipe(operators.takeUntil(_this._destroy)).subscribe(function (res) { return _this.onDragLeave(res); });
                rxjs.fromEvent(_this.element.nativeElement, 'igxDragOver').pipe(operators.takeUntil(_this._destroy)).subscribe(function (res) { return _this.onDragOver(res); });
            });
        };
        /**
         * @hidden
         */
        IgxDropDirective.prototype.ngOnDestroy = function () {
            this._destroy.next(true);
            this._destroy.complete();
        };
        /**
         * @hidden
         */
        IgxDropDirective.prototype.onDragOver = function (event) {
            var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
            var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
            var offsetX = event.detail.pageX - elementPosX;
            var offsetY = event.detail.pageY - elementPosY;
            var eventArgs = {
                originalEvent: event.detail.originalEvent,
                owner: this,
                drag: event.detail.owner,
                dragData: event.detail.owner.data,
                startX: event.detail.startX,
                startY: event.detail.startY,
                pageX: event.detail.pageX,
                pageY: event.detail.pageY,
                offsetX: offsetX,
                offsetY: offsetY
            };
            this.over.emit(eventArgs);
        };
        /**
         * @hidden
         */
        IgxDropDirective.prototype.onDragEnter = function (event) {
            var _this = this;
            if (!this.isDragLinked(event.detail.owner)) {
                return;
            }
            this.dragover = true;
            var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
            var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
            var offsetX = event.detail.pageX - elementPosX;
            var offsetY = event.detail.pageY - elementPosY;
            var eventArgs = {
                originalEvent: event.detail.originalEvent,
                owner: this,
                drag: event.detail.owner,
                dragData: event.detail.owner.data,
                startX: event.detail.startX,
                startY: event.detail.startY,
                pageX: event.detail.pageX,
                pageY: event.detail.pageY,
                offsetX: offsetX,
                offsetY: offsetY
            };
            this._zone.run(function () {
                _this.enter.emit(eventArgs);
            });
        };
        /**
         * @hidden
         */
        IgxDropDirective.prototype.onDragLeave = function (event) {
            var _this = this;
            if (!this.isDragLinked(event.detail.owner)) {
                return;
            }
            this.dragover = false;
            var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
            var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
            var offsetX = event.detail.pageX - elementPosX;
            var offsetY = event.detail.pageY - elementPosY;
            var eventArgs = {
                originalEvent: event.detail.originalEvent,
                owner: this,
                drag: event.detail.owner,
                dragData: event.detail.owner.data,
                startX: event.detail.startX,
                startY: event.detail.startY,
                pageX: event.detail.pageX,
                pageY: event.detail.pageY,
                offsetX: offsetX,
                offsetY: offsetY
            };
            this._zone.run(function () {
                _this.leave.emit(eventArgs);
            });
        };
        IgxDropDirective.prototype.getWindowScrollTop = function () {
            return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
        };
        IgxDropDirective.prototype.getWindowScrollLeft = function () {
            return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
        };
        IgxDropDirective.prototype.isDragLinked = function (drag) {
            var e_2, _a, e_3, _b, e_4, _c, e_5, _d;
            var dragLinkArray = drag.dragChannel instanceof Array;
            var dropLinkArray = this.dropChannel instanceof Array;
            if (!dragLinkArray && !dropLinkArray) {
                return this.dropChannel === drag.dragChannel;
            }
            else if (!dragLinkArray && dropLinkArray) {
                var dropLinks = this.dropChannel;
                try {
                    for (var dropLinks_1 = __values(dropLinks), dropLinks_1_1 = dropLinks_1.next(); !dropLinks_1_1.done; dropLinks_1_1 = dropLinks_1.next()) {
                        var link = dropLinks_1_1.value;
                        if (link === drag.dragChannel) {
                            return true;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (dropLinks_1_1 && !dropLinks_1_1.done && (_a = dropLinks_1.return)) _a.call(dropLinks_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            else if (dragLinkArray && !dropLinkArray) {
                var dragLinks = drag.dragChannel;
                try {
                    for (var dragLinks_1 = __values(dragLinks), dragLinks_1_1 = dragLinks_1.next(); !dragLinks_1_1.done; dragLinks_1_1 = dragLinks_1.next()) {
                        var link = dragLinks_1_1.value;
                        if (link === this.dropChannel) {
                            return true;
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (dragLinks_1_1 && !dragLinks_1_1.done && (_b = dragLinks_1.return)) _b.call(dragLinks_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
            else {
                var dragLinks = drag.dragChannel;
                var dropLinks = this.dropChannel;
                try {
                    for (var dragLinks_2 = __values(dragLinks), dragLinks_2_1 = dragLinks_2.next(); !dragLinks_2_1.done; dragLinks_2_1 = dragLinks_2.next()) {
                        var draglink = dragLinks_2_1.value;
                        try {
                            for (var dropLinks_2 = (e_5 = void 0, __values(dropLinks)), dropLinks_2_1 = dropLinks_2.next(); !dropLinks_2_1.done; dropLinks_2_1 = dropLinks_2.next()) {
                                var droplink = dropLinks_2_1.value;
                                if (draglink === droplink) {
                                    return true;
                                }
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (dropLinks_2_1 && !dropLinks_2_1.done && (_d = dropLinks_2.return)) _d.call(dropLinks_2);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (dragLinks_2_1 && !dragLinks_2_1.done && (_c = dragLinks_2.return)) _c.call(dragLinks_2);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
            return false;
        };
        IgxDropDirective.prototype.getInsertIndexAt = function (draggedDir, elementsAtPoint) {
            var insertIndex = -1;
            var dropChildren = Array.prototype.slice.call(this.element.nativeElement.children);
            if (!dropChildren.length) {
                return insertIndex;
            }
            var i = 0;
            var childUnder = null;
            while (!childUnder && i < elementsAtPoint.length) {
                if (elementsAtPoint[i].parentElement === this.element.nativeElement) {
                    childUnder = elementsAtPoint[i];
                }
                i++;
            }
            var draggedElemIndex = dropChildren.indexOf(draggedDir.element.nativeElement);
            insertIndex = dropChildren.indexOf(childUnder);
            if (draggedElemIndex !== -1 && draggedElemIndex < insertIndex) {
                insertIndex++;
            }
            return insertIndex;
        };
        return IgxDropDirective;
    }());
    IgxDropDirective.decorators = [
        { type: i0.Directive, args: [{
                    exportAs: 'drop',
                    selector: '[igxDrop]'
                },] }
    ];
    IgxDropDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: i0.NgZone }
    ]; };
    IgxDropDirective.propDecorators = {
        data: [{ type: i0.Input, args: ['igxDrop',] }],
        dropChannel: [{ type: i0.Input }],
        dropStrategy: [{ type: i0.Input }],
        enter: [{ type: i0.Output }],
        over: [{ type: i0.Output }],
        leave: [{ type: i0.Output }],
        dropped: [{ type: i0.Output }],
        droppable: [{ type: i0.HostBinding, args: ['attr.droppable',] }],
        dragover: [{ type: i0.HostBinding, args: ['class.dragOver',] }],
        onDragDrop: [{ type: i0.HostListener, args: ['igxDrop', ['$event'],] }]
    };
    /**
     * @hidden
     */
    var IgxDragDropModule = /** @class */ (function () {
        function IgxDragDropModule() {
        }
        return IgxDragDropModule;
    }());
    IgxDragDropModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective],
                    exports: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective]
                },] }
    ];

    var IgxFilterOptions = /** @class */ (function () {
        function IgxFilterOptions() {
            // Input text value that will be used as a filtering pattern (matching condition is based on it)
            this.inputValue = '';
        }
        // Function - get value to be tested from the item
        // item - single item of the list to be filtered
        // key - property name of item, which value should be tested
        // Default behavior - returns "key"- named property value of item if key si provided,
        // otherwise textContent of the item's html element
        IgxFilterOptions.prototype.get_value = function (item, key) {
            var result = '';
            if (key && item[key]) {
                result = item[key].toString();
            }
            else if (item.element) {
                if (item.element.nativeElement) {
                    result = item.element.nativeElement.textContent.trim();
                    // Check if element doesn't return the DOM element directly
                }
                else if (item.element.textContent) {
                    result = item.element.textContent.trim();
                }
            }
            return result;
        };
        // Function - formats the original text before matching process
        // Default behavior - returns text to lower case
        IgxFilterOptions.prototype.formatter = function (valueToTest) {
            return valueToTest.toLowerCase();
        };
        // Function - determines whether the item met the condition
        // valueToTest - text value that should be tested
        // inputValue - text value from input that condition is based on
        // Default behavior - "contains"
        IgxFilterOptions.prototype.matchFn = function (valueToTest, inputValue) {
            return valueToTest.indexOf(inputValue && inputValue.toLowerCase() || '') > -1;
        };
        // Function - executed after matching test for every matched item
        // Default behavior - shows the item
        IgxFilterOptions.prototype.metConditionFn = function (item) {
            if (item.hasOwnProperty('hidden')) {
                item.hidden = false;
            }
        };
        // Function - executed for every NOT matched item after matching test
        // Default behavior - hides the item
        IgxFilterOptions.prototype.overdueConditionFn = function (item) {
            if (item.hasOwnProperty('hidden')) {
                item.hidden = true;
            }
        };
        return IgxFilterOptions;
    }());
    var IgxFilterDirective = /** @class */ (function () {
        function IgxFilterDirective(element, renderer) {
            this.element = element;
            this.filtering = new i0.EventEmitter(false); // synchronous event emitter
            this.filtered = new i0.EventEmitter();
        }
        IgxFilterDirective.prototype.ngOnChanges = function (changes) {
            // Detect only changes of input value
            if (changes.filterOptions &&
                changes.filterOptions.currentValue &&
                changes.filterOptions.currentValue.inputValue !== undefined &&
                changes.filterOptions.previousValue &&
                changes.filterOptions.currentValue.inputValue !== changes.filterOptions.previousValue.inputValue) {
                this.filter();
            }
        };
        IgxFilterDirective.prototype.filter = function () {
            if (!this.filterOptions.items) {
                return;
            }
            var args = { cancel: false, items: this.filterOptions.items };
            this.filtering.emit(args);
            if (args.cancel) {
                return;
            }
            var pipe = new IgxFilterPipe();
            var filtered = pipe.transform(this.filterOptions.items, this.filterOptions);
            this.filtered.emit({ filteredItems: filtered });
        };
        return IgxFilterDirective;
    }());
    IgxFilterDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxFilter]'
                },] }
    ];
    IgxFilterDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    IgxFilterDirective.propDecorators = {
        filtering: [{ type: i0.Output }],
        filtered: [{ type: i0.Output }],
        filterOptions: [{ type: i0.Input, args: ['igxFilter',] }]
    };
    var IgxFilterPipe = /** @class */ (function () {
        function IgxFilterPipe() {
        }
        IgxFilterPipe.prototype.transform = function (items, 
        // options - initial settings of filter functionality
        options) {
            var result = [];
            if (!items || !items.length || !options) {
                return;
            }
            if (options.items) {
                items = options.items;
            }
            result = items.filter(function (item) {
                var match = options.matchFn(options.formatter(options.get_value(item, options.key)), options.inputValue);
                if (match) {
                    if (options.metConditionFn) {
                        options.metConditionFn(item);
                    }
                }
                else {
                    if (options.overdueConditionFn) {
                        options.overdueConditionFn(item);
                    }
                }
                return match;
            });
            return result;
        };
        return IgxFilterPipe;
    }());
    IgxFilterPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'igxFilter',
                    pure: false
                },] }
    ];
    /**
     * @hidden
     */
    var IgxFilterModule = /** @class */ (function () {
        function IgxFilterModule() {
        }
        return IgxFilterModule;
    }());
    IgxFilterModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxFilterDirective, IgxFilterPipe],
                    exports: [IgxFilterDirective, IgxFilterPipe],
                    imports: [i2.CommonModule]
                },] }
    ];

    var IgxFocusDirective = /** @class */ (function () {
        function IgxFocusDirective(element, comp) {
            this.element = element;
            this.comp = comp;
            this.focusState = true;
        }
        Object.defineProperty(IgxFocusDirective.prototype, "focused", {
            /**
             * Returns the state of the igxFocus.
             * ```typescript
             * @ViewChild('focusContainer', {read: IgxFocusDirective})
             * public igxFocus: IgxFocusDirective;
             * let isFocusOn = this.igxFocus.focused;
             * ```
             *
             * @memberof IgxFocusDirective
             */
            get: function () {
                return this.focusState;
            },
            /**
             * Sets the state of the igxFocus.
             * ```html
             * <igx-input-group >
             *  <input #focusContainer igxInput [igxFocus]="true"/>
             * </igx-input-group>
             * ```
             *
             * @memberof IgxFocusDirective
             */
            set: function (val) {
                this.focusState = val;
                this.trigger();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxFocusDirective.prototype, "nativeElement", {
            /**
             * Gets the native element of the igxFocus.
             * ```typescript
             * @ViewChild('focusContainer', {read: IgxFocusDirective})
             * public igxFocus: IgxFocusDirective;
             * let igxFocusNativeElement = this.igxFocus.nativeElement;
             * ```
             *
             * @memberof IgxFocusDirective
             */
            get: function () {
                if (this.comp && this.comp[0] && this.comp[0].getEditElement) {
                    return this.comp[0].getEditElement();
                }
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Triggers the igxFocus state.
         * ```typescript
         * @ViewChild('focusContainer', {read: IgxFocusDirective})
         * public igxFocus: IgxFocusDirective;
         * this.igxFocus.trigger();
         * ```
         *
         * @memberof IgxFocusDirective
         */
        IgxFocusDirective.prototype.trigger = function () {
            var _this = this;
            if (this.focusState) {
                requestAnimationFrame(function () { return _this.nativeElement.focus({ preventScroll: true }); });
            }
        };
        return IgxFocusDirective;
    }());
    IgxFocusDirective.decorators = [
        { type: i0.Directive, args: [{
                    exportAs: 'igxFocus',
                    selector: '[igxFocus]'
                },] }
    ];
    IgxFocusDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: Array, decorators: [{ type: i0.Inject, args: [forms.NG_VALUE_ACCESSOR,] }, { type: i0.Self }, { type: i0.Optional }] }
    ]; };
    IgxFocusDirective.propDecorators = {
        focused: [{ type: i0.Input, args: ['igxFocus',] }]
    };
    /**
     * @hidden
     */
    var IgxFocusModule = /** @class */ (function () {
        function IgxFocusModule() {
        }
        return IgxFocusModule;
    }());
    IgxFocusModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxFocusDirective],
                    exports: [IgxFocusDirective]
                },] }
    ];

    var IgxLayoutDirective = /** @class */ (function () {
        function IgxLayoutDirective() {
            /**
             * Sets the default flow direction of the container's children.
             *
             * Defaults to `rows`.
             *
             * ```html
             *  <div
             *   igxLayout
             *   igxLayoutDir="row">
             *    <div igxFlex>1</div>
             *    <div igxFlex>2</div>
             *    <div igxFlex>3</div>
             *  </div>
             * ```
             */
            this.dir = 'row';
            /**
             * Defines the direction flex children are placed in the flex container.
             *
             * When set to `true`, the `rows` direction goes right to left and `columns` goes bottom to top.
             *
             * ```html
             * <div
             *   igxLayout
             *   igxLayoutReverse="true">
             *    <div igxFlex>1</div>
             *    <div igxFlex>2</div>
             *    <div igxFlex>3</div>
             * </div>
             * ```
             */
            this.reverse = false;
            /**
             * By default the immediate children will all try to fit onto one line.
             *
             * The default value `nowrap` sets this behavior.
             *
             * Other accepted values are `wrap` and `wrap-reverse`.
             *
             * ```html
             * <div
             *   igxLayout
             *   igxLayoutDir="row"
             *   igxLayoutWrap="wrap">
             *    <div igxFlex igxFlexGrow="0">1</div>
             *    <div igxFlex igxFlexGrow="0">2</div>
             *    <div igxFlex igxFlexGrow="0">3</div>
             * </div>
             * ```
             */
            this.wrap = 'nowrap';
            /**
             * Defines the alignment along the main axis.
             *
             * Defaults to `flex-start` which packs the children toward the start line.
             *
             * Other possible values are `flex-end`, `center`, `space-between`, `space-around`.
             *
             * ```html
             * <div
             *   igxLayout
             *   igxLayoutDir="column"
             *   igxLayoutJustify="space-between">
             *    <div>1</div>
             *    <div>2</div>
             *    <div>3</div>
             * </div>
             * ```
             */
            this.justify = 'flex-start';
            /**
             * Defines the default behavior for how children are laid out along the corss axis of the current line.
             *
             * Defaults to `flex-start`.
             *
             * Other possible values are `flex-end`, `center`, `baseline`, and `stretch`.
             *
             * ```html
             * <div
             *   igxLayout
             *   igxLayoutDir="column"
             *   igxLayoutItemAlign="start">
             *    <div igxFlex igxFlexGrow="0">1</div>
             *    <div igxFlex igxFlexGrow="0">2</div>
             *    <div igxFlex igxFlexGrow="0">3</div>
             * </div>
             * ```
             */
            this.itemAlign = 'stretch';
            /**
             * @hidden
             */
            this.display = 'flex';
        }
        Object.defineProperty(IgxLayoutDirective.prototype, "flexwrap", {
            /**
             * @hidden
             */
            get: function () {
                return this.wrap;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxLayoutDirective.prototype, "justifycontent", {
            /**
             * @hidden
             */
            get: function () {
                return this.justify;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxLayoutDirective.prototype, "align", {
            /**
             * @hidden
             */
            get: function () {
                return this.itemAlign;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxLayoutDirective.prototype, "direction", {
            /**
             * @hidden
             */
            get: function () {
                if (this.reverse) {
                    return (this.dir === 'row') ? 'row-reverse' : 'column-reverse';
                }
                return (this.dir === 'row') ? 'row' : 'column';
            },
            enumerable: false,
            configurable: true
        });
        return IgxLayoutDirective;
    }());
    IgxLayoutDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxLayout]'
                },] }
    ];
    IgxLayoutDirective.propDecorators = {
        dir: [{ type: i0.Input, args: ['igxLayoutDir',] }],
        reverse: [{ type: i0.Input, args: ['igxLayoutReverse',] }],
        wrap: [{ type: i0.Input, args: ['igxLayoutWrap',] }],
        justify: [{ type: i0.Input, args: ['igxLayoutJustify',] }],
        itemAlign: [{ type: i0.Input, args: ['igxLayoutItemAlign',] }],
        display: [{ type: i0.HostBinding, args: ['style.display',] }],
        flexwrap: [{ type: i0.HostBinding, args: ['style.flex-wrap',] }],
        justifycontent: [{ type: i0.HostBinding, args: ['style.justify-content',] }],
        align: [{ type: i0.HostBinding, args: ['style.align-items',] }],
        direction: [{ type: i0.HostBinding, args: ['style.flex-direction',] }]
    };
    var IgxFlexDirective = /** @class */ (function () {
        function IgxFlexDirective() {
            /**
             * Applies the `grow` attribute to an element that uses the directive.
             *
             * Default value is `1`.
             *
             * ```html
             * <div>
             *    <div igxFlex igxFlexGrow="0">Content1</div>
             *    <div igxFlex igxFlexGrow="1">Content2</div>
             *    <div igxFlex igxFlexGrow="0">Content3</div>
             * </div>
             * ```
             */
            this.grow = 1;
            /**
             * Applies the `shrink` attribute to an element that uses the directive.
             *
             * Default value is `1`.
             *
             * ```html
             * <div>
             *    <div igxFlex igxFlexShrink="1">Content1</div>
             *    <div igxFlex igxFlexShrink="0">Content2</div>
             *    <div igxFlex igxFlexShrink="1">Content3</div>
             * </div>
             * ```
             */
            this.shrink = 1;
            /**
             * Applies the directive to an element.
             *
             * Possible values include `igxFlexGrow`, `igxFlexShrink`, `igxFlexOrder`, `igxFlexBasis`.
             *
             * ```html
             * <div igxFlex>Content</div>
             * ```
             */
            this.flex = '';
            /**
             * Applies the `order` attribute to an element that uses the directive.
             *
             * Default value is `0`.
             *
             * ```html
             * <div>
             *    <div igxFlex igxFlexOrder="1">Content1</div>
             *    <div igxFlex igxFlexOrder="0">Content2</div>
             *    <div igxFlex igxFlexOrder="2">Content3</div>
             * </div>
             * ```
             */
            this.order = 0;
            /**
             * Applies the `flex-basis` attribute to an element that uses the directive.
             *
             * Default value is `auto`.
             *
             * Other possible values include `content`, `max-content`, `min-content`, `fit-content`.
             *
             * ```html
             * <div igxFlex igxFlexBasis="fit-content">Content</div>
             * ```
             */
            this.basis = 'auto';
        }
        Object.defineProperty(IgxFlexDirective.prototype, "style", {
            /**
             * @hidden
             */
            get: function () {
                if (this.flex) {
                    return "" + this.flex;
                }
                return this.grow + " " + this.shrink + " " + this.basis;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxFlexDirective.prototype, "itemorder", {
            /**
             * @hidden
             */
            get: function () {
                return this.order || 0;
            },
            enumerable: false,
            configurable: true
        });
        return IgxFlexDirective;
    }());
    IgxFlexDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxFlex]'
                },] }
    ];
    IgxFlexDirective.propDecorators = {
        grow: [{ type: i0.Input, args: ['igxFlexGrow',] }],
        shrink: [{ type: i0.Input, args: ['igxFlexShrink',] }],
        flex: [{ type: i0.Input, args: ['igxFlex',] }],
        order: [{ type: i0.Input, args: ['igxFlexOrder',] }],
        basis: [{ type: i0.Input, args: ['igxFlexBasis',] }],
        style: [{ type: i0.HostBinding, args: ['style.flex',] }],
        itemorder: [{ type: i0.HostBinding, args: ['style.order',] }]
    };
    /**
     * @hidden
     */
    var IgxLayoutModule = /** @class */ (function () {
        function IgxLayoutModule() {
        }
        return IgxLayoutModule;
    }());
    IgxLayoutModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxFlexDirective, IgxLayoutDirective],
                    exports: [IgxFlexDirective, IgxLayoutDirective]
                },] }
    ];

    /** @hidden */
    var MASK_FLAGS = ['C', '&', 'a', 'A', '?', 'L', '9', '0', '#'];
    /** @hidden */
    var MaskParsingService = /** @class */ (function () {
        function MaskParsingService() {
        }
        MaskParsingService.prototype.applyMask = function (inputVal, maskOptions) {
            var e_1, _a, e_2, _b;
            var _this = this;
            var outputVal = '';
            var value = '';
            var mask = maskOptions.format;
            var literals = this.getMaskLiterals(mask);
            var literalKeys = Array.from(literals.keys());
            var nonLiteralIndices = this.getNonLiteralIndices(mask, literalKeys);
            var literalValues = Array.from(literals.values());
            if (inputVal != null) {
                value = inputVal.toString();
            }
            try {
                for (var mask_1 = __values(mask), mask_1_1 = mask_1.next(); !mask_1_1.done; mask_1_1 = mask_1.next()) {
                    var maskSym = mask_1_1.value;
                    outputVal += maskOptions.promptChar;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (mask_1_1 && !mask_1_1.done && (_a = mask_1.return)) _a.call(mask_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            literals.forEach(function (val, key) {
                outputVal = _this.replaceCharAt(outputVal, key, val);
            });
            if (!value) {
                return outputVal;
            }
            var nonLiteralValues = this.getNonLiteralValues(value, literalValues);
            for (var i = 0; i < nonLiteralValues.length; i++) {
                var char = nonLiteralValues[i];
                var isCharValid = this.validateCharOnPosition(char, nonLiteralIndices[i], mask);
                if (!isCharValid && char !== maskOptions.promptChar) {
                    nonLiteralValues[i] = maskOptions.promptChar;
                }
            }
            if (nonLiteralValues.length > nonLiteralIndices.length) {
                nonLiteralValues.splice(nonLiteralIndices.length);
            }
            var pos = 0;
            try {
                for (var nonLiteralValues_1 = __values(nonLiteralValues), nonLiteralValues_1_1 = nonLiteralValues_1.next(); !nonLiteralValues_1_1.done; nonLiteralValues_1_1 = nonLiteralValues_1.next()) {
                    var nonLiteralValue = nonLiteralValues_1_1.value;
                    var char = nonLiteralValue;
                    outputVal = this.replaceCharAt(outputVal, nonLiteralIndices[pos++], char);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (nonLiteralValues_1_1 && !nonLiteralValues_1_1.done && (_b = nonLiteralValues_1.return)) _b.call(nonLiteralValues_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return outputVal;
        };
        MaskParsingService.prototype.parseValueFromMask = function (maskedValue, maskOptions) {
            var e_3, _a;
            var outputVal = '';
            var mask = maskOptions.format;
            var literals = this.getMaskLiterals(mask);
            var literalValues = Array.from(literals.values());
            try {
                for (var maskedValue_1 = __values(maskedValue), maskedValue_1_1 = maskedValue_1.next(); !maskedValue_1_1.done; maskedValue_1_1 = maskedValue_1.next()) {
                    var val = maskedValue_1_1.value;
                    if (literalValues.indexOf(val) === -1) {
                        if (val !== maskOptions.promptChar) {
                            outputVal += val;
                        }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (maskedValue_1_1 && !maskedValue_1_1.done && (_a = maskedValue_1.return)) _a.call(maskedValue_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return outputVal;
        };
        MaskParsingService.prototype.replaceInMask = function (maskedValue, value, maskOptions, start, end) {
            var literalsPositions = Array.from(this.getMaskLiterals(maskOptions.format).keys());
            var chars = Array.from(value);
            var cursor = start;
            end = Math.min(end, maskedValue.length);
            for (var i = start; i < end || (chars.length && i < maskedValue.length); i++) {
                if (literalsPositions.indexOf(i) !== -1) {
                    if (chars[0] === maskedValue[i]) {
                        cursor = i + 1;
                        chars.shift();
                    }
                    continue;
                }
                if (chars[0]
                    && !this.validateCharOnPosition(chars[0], i, maskOptions.format)
                    && chars[0] !== maskOptions.promptChar) {
                    break;
                }
                var char = maskOptions.promptChar;
                if (chars.length) {
                    cursor = i + 1;
                    char = chars.shift();
                }
                maskedValue = this.replaceCharAt(maskedValue, i, char);
            }
            return { value: maskedValue, end: cursor };
        };
        MaskParsingService.prototype.replaceCharAt = function (strValue, index, char) {
            if (strValue !== undefined) {
                return strValue.substring(0, index) + char + strValue.substring(index + 1);
            }
        };
        /** Validates only non literal positions. */
        MaskParsingService.prototype.validateCharOnPosition = function (inputChar, position, mask) {
            var regex;
            var isValid;
            var letterOrDigitRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
            var letterDigitOrSpaceRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
            var letterRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
            var letterSpaceRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
            var digitRegEx = '[\\d]';
            var digitSpaceRegEx = '[\\d\\u0020]';
            var digitSpecialRegEx = '[\\d-\\+]';
            switch (mask.charAt(position)) {
                case 'C':
                    isValid = inputChar !== '';
                    break;
                case '&':
                    regex = new RegExp('[\\u0020]');
                    isValid = !regex.test(inputChar);
                    break;
                case 'a':
                    regex = new RegExp(letterDigitOrSpaceRegEx);
                    isValid = regex.test(inputChar);
                    break;
                case 'A':
                    regex = new RegExp(letterOrDigitRegEx);
                    isValid = regex.test(inputChar);
                    break;
                case '?':
                    regex = new RegExp(letterSpaceRegEx);
                    isValid = regex.test(inputChar);
                    break;
                case 'L':
                    regex = new RegExp(letterRegEx);
                    isValid = regex.test(inputChar);
                    break;
                case '0':
                    regex = new RegExp(digitRegEx);
                    isValid = regex.test(inputChar);
                    break;
                case '9':
                    regex = new RegExp(digitSpaceRegEx);
                    isValid = regex.test(inputChar);
                    break;
                case '#':
                    regex = new RegExp(digitSpecialRegEx);
                    isValid = regex.test(inputChar);
                    break;
                default: {
                    isValid = null;
                }
            }
            return isValid;
        };
        MaskParsingService.prototype.getMaskLiterals = function (mask) {
            var literals = new Map();
            for (var i = 0; i < mask.length; i++) {
                var char = mask.charAt(i);
                if (MASK_FLAGS.indexOf(char) === -1) {
                    literals.set(i, char);
                }
            }
            return literals;
        };
        MaskParsingService.prototype.getNonLiteralIndices = function (mask, literalKeys) {
            var nonLiteralsIndices = new Array();
            for (var i = 0; i < mask.length; i++) {
                if (literalKeys.indexOf(i) === -1) {
                    nonLiteralsIndices.push(i);
                }
            }
            return nonLiteralsIndices;
        };
        MaskParsingService.prototype.getNonLiteralValues = function (value, literalValues) {
            var e_4, _a;
            var nonLiteralValues = new Array();
            try {
                for (var value_1 = __values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                    var val = value_1_1.value;
                    if (literalValues.indexOf(val) === -1) {
                        nonLiteralValues.push(val);
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (value_1_1 && !value_1_1.done && (_a = value_1.return)) _a.call(value_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
            return nonLiteralValues;
        };
        return MaskParsingService;
    }());
    MaskParsingService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MaskParsingService_Factory() { return new MaskParsingService(); }, token: MaskParsingService, providedIn: "root" });
    MaskParsingService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];

    var IgxMaskDirective = /** @class */ (function () {
        function IgxMaskDirective(elementRef, maskParser, renderer) {
            this.elementRef = elementRef;
            this.maskParser = maskParser;
            this.renderer = renderer;
            /**
             * Sets the character representing a fillable spot in the input mask.
             * Default value is "'_'".
             * ```html
             * <input [promptChar] = "'/'">
             * ```
             */
            this.promptChar = '_';
            /**
             * Emits an event each time the value changes.
             * Provides `rawValue: string` and `formattedValue: string` as event arguments.
             * ```html
             * <input (onValueChange) = "onValueChange(rawValue: string, formattedValue: string)">
             * ```
             */
            this.onValueChange = new i0.EventEmitter();
            this._end = 0;
            this._start = 0;
            this._oldText = '';
            this._dataValue = '';
            this._focused = false;
            this._onTouchedCallback = rxjs.noop;
            this._onChangeCallback = rxjs.noop;
        }
        Object.defineProperty(IgxMaskDirective.prototype, "placeholder", {
            get: function () {
                return this.nativeElement.placeholder;
            },
            /**
             * Specifies a placeholder.
             * ```html
             * <input placeholder = "enter text...">
             * ```
             */
            set: function (val) {
                this.renderer.setAttribute(this.nativeElement, 'placeholder', val);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMaskDirective.prototype, "nativeElement", {
            /** @hidden */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMaskDirective.prototype, "inputValue", {
            /** @hidden @internal; */
            get: function () {
                return this.nativeElement.value;
            },
            /** @hidden @internal */
            set: function (val) {
                this.nativeElement.value = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMaskDirective.prototype, "maskOptions", {
            /** @hidden */
            get: function () {
                var format = this.mask || 'CCCCCCCCCC';
                var promptChar = this.promptChar && this.promptChar.substring(0, 1);
                return { format: format, promptChar: promptChar };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMaskDirective.prototype, "selectionStart", {
            /** @hidden */
            get: function () {
                // Edge(classic) and FF don't select text on drop
                return this.nativeElement.selectionStart === this.nativeElement.selectionEnd && this._hasDropAction ?
                    this.nativeElement.selectionEnd - this._droppedData.length :
                    this.nativeElement.selectionStart;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMaskDirective.prototype, "selectionEnd", {
            /** @hidden */
            get: function () {
                return this.nativeElement.selectionEnd;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMaskDirective.prototype, "start", {
            /** @hidden */
            get: function () {
                return this._start;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMaskDirective.prototype, "end", {
            /** @hidden */
            get: function () {
                return this._end;
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden */
        IgxMaskDirective.prototype.onKeyDown = function (event) {
            var key = event.keyCode || event.charCode;
            if (!key) {
                return;
            }
            if (isIE() && this._stopPropagation) {
                this._stopPropagation = false;
            }
            if ((key === 17 /* CTRL */ && key === 90 /* Z */) || (key === 17 /* CTRL */ && key === 89 /* Y */)) {
                event.preventDefault();
            }
            this._key = key;
            this._start = this.selectionStart;
            this._end = this.selectionEnd;
        };
        /** @hidden */
        IgxMaskDirective.prototype.onInputChanged = function () {
            /**
             * '!this._focused' is a fix for #8165
             * On page load IE triggers input events before focus events and
             * it does so for every single input on the page.
             * The mask needs to be prevented from doing anything while this is happening because
             * the end user will be unable to blur the input.
             * https://stackoverflow.com/questions/21406138/input-event-triggered-on-internet-explorer-when-placeholder-changed
             */
            if (isIE() && (this._stopPropagation || !this._focused)) {
                this._stopPropagation = false;
                return;
            }
            if (this._hasDropAction) {
                this._start = this.selectionStart;
            }
            if (this.inputValue.length < this._oldText.length && this._key === 229 /* INPUT_METHOD */) {
                // software keyboard input delete
                this._key = 8 /* BACKSPACE */;
            }
            var valueToParse = '';
            switch (this._key) {
                case 46 /* DELETE */:
                    this._end = this._start === this._end ? ++this._end : this._end;
                    break;
                case 8 /* BACKSPACE */:
                    this._start = this.selectionStart;
                    break;
                default:
                    valueToParse = this.inputValue.substring(this._start, this.selectionEnd);
                    break;
            }
            var replacedData = this.maskParser.replaceInMask(this._oldText, valueToParse, this.maskOptions, this._start, this._end);
            this.inputValue = replacedData.value;
            if (this._key === 8 /* BACKSPACE */) {
                replacedData.end = this._start;
            }
            this.setSelectionRange(replacedData.end);
            var rawVal = this.maskParser.parseValueFromMask(this.inputValue, this.maskOptions);
            this._dataValue = this.includeLiterals ? this.inputValue : rawVal;
            this._onChangeCallback(this._dataValue);
            this.onValueChange.emit({ rawValue: rawVal, formattedValue: this.inputValue });
            this.afterInput();
        };
        /** @hidden */
        IgxMaskDirective.prototype.onPaste = function () {
            this._oldText = this.inputValue;
            this._start = this.selectionStart;
        };
        /** @hidden */
        IgxMaskDirective.prototype.onFocus = function () {
            this._focused = true;
            this.showMask(this._dataValue);
        };
        /** @hidden */
        IgxMaskDirective.prototype.onBlur = function (value) {
            this._focused = false;
            this.showDisplayValue(value);
            this._onTouchedCallback();
        };
        /** @hidden */
        IgxMaskDirective.prototype.onDragEnter = function () {
            if (!this._focused) {
                this.showMask(this._dataValue);
            }
        };
        /** @hidden */
        IgxMaskDirective.prototype.onDragLeave = function () {
            if (!this._focused) {
                this.showDisplayValue(this.inputValue);
            }
        };
        /** @hidden */
        IgxMaskDirective.prototype.onDrop = function (event) {
            this._hasDropAction = true;
            this._droppedData = event.dataTransfer.getData('text');
        };
        /** @hidden */
        IgxMaskDirective.prototype.ngOnInit = function () {
            if (!this.nativeElement.placeholder) {
                this.renderer.setAttribute(this.nativeElement, 'placeholder', this.maskOptions.format);
            }
        };
        /**
         * TODO: Remove after date/time picker integration refactor
         *
         * @hidden
         */
        IgxMaskDirective.prototype.ngAfterViewChecked = function () {
            this._oldText = this.inputValue;
        };
        /** @hidden */
        IgxMaskDirective.prototype.writeValue = function (value) {
            if (this.promptChar && this.promptChar.length > 1) {
                this.maskOptions.promptChar = this.promptChar.substring(0, 1);
            }
            this.inputValue = value ? this.maskParser.applyMask(value, this.maskOptions) : '';
            if (this.displayValuePipe) {
                this.inputValue = this.displayValuePipe.transform(this.inputValue);
            }
            this._dataValue = this.includeLiterals ? this.inputValue : value;
            this.onValueChange.emit({ rawValue: value, formattedValue: this.inputValue });
        };
        /** @hidden */
        IgxMaskDirective.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /** @hidden */
        IgxMaskDirective.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /** @hidden */
        IgxMaskDirective.prototype.showMask = function (value) {
            if (this.focusedValuePipe) {
                if (isIE()) {
                    this._stopPropagation = true;
                }
                // TODO(D.P.): focusedValuePipe should be deprecated or force-checked to match mask format
                this.inputValue = this.focusedValuePipe.transform(value);
            }
            else {
                this.inputValue = this.maskParser.applyMask(this.inputValue, this.maskOptions);
            }
            this._oldText = this.inputValue;
        };
        /** @hidden */
        IgxMaskDirective.prototype.setSelectionRange = function (start, end) {
            if (end === void 0) { end = start; }
            this.nativeElement.setSelectionRange(start, end);
        };
        /** @hidden */
        IgxMaskDirective.prototype.afterInput = function () {
            this._oldText = this.inputValue;
            this._hasDropAction = false;
            this._start = 0;
            this._end = 0;
            this._key = null;
        };
        IgxMaskDirective.prototype.showDisplayValue = function (value) {
            if (this.displayValuePipe) {
                this.inputValue = this.displayValuePipe.transform(value);
            }
            else if (value === this.maskParser.applyMask(null, this.maskOptions)) {
                this.inputValue = '';
            }
        };
        return IgxMaskDirective;
    }());
    IgxMaskDirective.decorators = [
        { type: i0.Directive, args: [{
                    providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxMaskDirective, multi: true }],
                    selector: '[igxMask]',
                    exportAs: 'igxMask'
                },] }
    ];
    IgxMaskDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: MaskParsingService },
        { type: i0.Renderer2 }
    ]; };
    IgxMaskDirective.propDecorators = {
        mask: [{ type: i0.Input, args: ['igxMask',] }],
        promptChar: [{ type: i0.Input }],
        includeLiterals: [{ type: i0.Input }],
        displayValuePipe: [{ type: i0.Input }],
        focusedValuePipe: [{ type: i0.Input }],
        onValueChange: [{ type: i0.Output }],
        onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }],
        onInputChanged: [{ type: i0.HostListener, args: ['input',] }],
        onPaste: [{ type: i0.HostListener, args: ['paste',] }],
        onFocus: [{ type: i0.HostListener, args: ['focus',] }],
        onBlur: [{ type: i0.HostListener, args: ['blur', ['$event.target.value'],] }],
        onDragEnter: [{ type: i0.HostListener, args: ['dragenter',] }],
        onDragLeave: [{ type: i0.HostListener, args: ['dragleave',] }],
        onDrop: [{ type: i0.HostListener, args: ['drop', ['$event'],] }]
    };
    __decorate([
        DeprecateProperty('"placeholder" is deprecated, use native placeholder instead.')
    ], IgxMaskDirective.prototype, "placeholder", null);
    /** @hidden */
    var IgxMaskModule = /** @class */ (function () {
        function IgxMaskModule() {
        }
        return IgxMaskModule;
    }());
    IgxMaskModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxMaskDirective],
                    exports: [IgxMaskDirective],
                    imports: [i2.CommonModule]
                },] }
    ];

    var RadioLabelPosition = mkenum({
        BEFORE: 'before',
        AFTER: 'after'
    });
    var nextId = 0;
    /**
     * **Ignite UI for Angular Radio Button** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/radio_button.html)
     *
     * The Ignite UI Radio Button allows the user to select a single option from an available set of options that are listed side by side.
     *
     * Example:
     * ```html
     * <igx-radio>
     *   Simple radio button
     * </igx-radio>
     * ```
     */
    var IgxRadioComponent = /** @class */ (function () {
        function IgxRadioComponent(cdr) {
            this.cdr = cdr;
            /**
             * Sets/gets the `id` of the radio component.
             * If not set, the `id` of the first radio component will be `"igx-radio-0"`.
             * ```html
             * <igx-radio id = "my-first-radio"></igx-radio>
             * ```
             * ```typescript
             * let radioId =  this.radio.id;
             * ```
             *
             * @memberof IgxRadioComponent
             */
            this.id = "igx-radio-" + nextId++;
            /**
             * Sets/gets the id of the `label` element in the radio component.
             * If not set, the id of the `label` in the first radio component will be `"igx-radio-0-label"`.
             * ```html
             * <igx-radio labelId = "Label1"></igx-radio>
             * ```
             * ```typescript
             * let labelId =  this.radio.labelId;
             * ```
             *
             * @memberof IgxRadioComponent
             */
            this.labelId = this.id + "-label";
            /**
             * Sets/gets the position of the `label` in the radio component.
             * If not set, `labelPosition` will have value `"after"`.
             * ```html
             * <igx-radio labelPosition = "before"></igx-radio>
             * ```
             * ```typescript
             * let labelPosition =  this.radio.labelPosition;
             * ```
             *
             * @memberof IgxRadioComponent
             */
            this.labelPosition = 'after';
            /**
             * Sets the value of the `tabindex` attribute.
             * ```html
             * <igx-radio [tabindex] = "1"></igx-radio>
             * ```
             * ```typescript
             * let tabIndex =  this.radio.tabindex;
             * ```
             *
             * @memberof IgxRadioComponent
             */
            this.tabindex = null;
            /**
             * Enables/disables the ripple effect on the radio button..
             * If not set, the `disableRipple` will have value `false`.
             * ```html
             * <igx-radio [disableRipple] = "true"></igx-radio>
             * ```
             * ```typescript
             * let isDisabledRipple =  this.radio.disableRipple;
             * ```
             *
             * @memberof IgxRadioComponent
             */
            this.disableRipple = false;
            /**
             * Sets/gets whether the radio button is required.
             * If not set, `required` will have value `false`.
             * ```html
             * <igx-radio [required] = "true"></igx-radio>
             * ```
             * ```typescript
             * let isRequired =  this.radio.required;
             * ```
             *
             * @memberof IgxRadioComponent
             */
            this.required = false;
            /**
             * Sets/gets the `aria-labelledby` attribute of the radio component.
             * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
             * ```html
             * <igx-radio aria-labelledby = "Radio1"></igx-radio>
             * ```
             * ```typescript
             * let ariaLabelledBy = this.radio.ariaLabelledBy;
             * ```
             *
             * @memberof IgxRadioComponent
             */
            this.ariaLabelledBy = this.labelId;
            /**
             * Sets/gets the `aria-label` attribute of the radio component.
             * ```html
             * <igx-radio aria-label = "Radio1"></igx-radio>
             * ```
             * ```typescript
             * let ariaLabel =  this.radio.ariaLabel;
             * ```
             *
             * @memberof IgxRadioComponent
             */
            this.ariaLabel = null;
            /**
             * An event that is emitted after the radio `value` is changed.
             * Provides references to the `IgxRadioComponent` and the `value` property as event arguments.
             *
             * @memberof IgxRadioComponent
             */
            // eslint-disable-next-line @angular-eslint/no-output-native
            this.change = new i0.EventEmitter();
            /**
             * Returns the class of the radio component.
             * ```typescript
             * let radioClass = this.radio.cssClass;
             * ```
             *
             * @memberof IgxRadioComponent
             */
            this.cssClass = 'igx-radio';
            /**
             * Sets/gets  the `checked` attribute.
             * Default value is `false`.
             * ```html
             * <igx-radio [checked] = "true"></igx-radio>
             * ```
             * ```typescript
             * let isChecked =  this.radio.checked;
             * ```
             *
             * @memberof IgxRadioComponent
             */
            this.checked = false;
            /**
             * Sets/gets  the `disabled` attribute.
             * Default value is `false`.
             * ```html
             * <igx-radio [disabled] = "true"></igx-radio>
             * ```
             * ```typescript
             * let isDisabled =  this.radio.disabled;
             * ```
             *
             * @memberof IgxRadioComponent
             */
            this.disabled = false;
            /**
             * Sets/gets whether the radio component is on focus.
             * Default value is `false`.
             * ```typescript
             * this.radio.focus = true;
             * ```
             * ```typescript
             * let isFocused =  this.radio.focused;
             * ```
             *
             * @memberof IgxRadioComponent
             */
            this.focused = false;
            /**
             * @hidden
             */
            this.inputId = this.id + "-input";
            /**
             * @hidden
             */
            this._onTouchedCallback = rxjs.noop;
            /**
             * @hidden
             */
            this._onChangeCallback = rxjs.noop;
        }
        /**
         * @hidden
         * @internal
         */
        IgxRadioComponent.prototype.onKeyUp = function (event) {
            event.stopPropagation();
            this.focused = true;
            this.select();
        };
        /**
         * @hidden
         */
        IgxRadioComponent.prototype._clicked = function (event) {
            event.stopPropagation();
            this.select();
        };
        /**
         * Selects the current radio button.
         * ```typescript
         * this.radio.select();
         * ```
         *
         * @memberof IgxRadioComponent
         */
        IgxRadioComponent.prototype.select = function () {
            this.nativeRadio.nativeElement.focus();
            if (isIE()) {
                this.nativeRadio.nativeElement.blur();
            }
            if (!this.checked) {
                this.checked = true;
                this.change.emit({ value: this.value, radio: this });
                this._onChangeCallback(this.value);
            }
        };
        /**
         * Deselects the current radio button.
         * ```typescript
         * this.radio.deselect();
         * ```
         *
         * @memberof IgxRadioComponent
         */
        IgxRadioComponent.prototype.deselect = function () {
            this.checked = false;
            this.focused = false;
            this.cdr.markForCheck();
        };
        /**
         * Checks whether the provided value is consistent to the current radio button.
         * If it is, the checked attribute will have value `true`;
         * ```typescript
         * this.radio.writeValue('radioButtonValue');
         * ```
         */
        IgxRadioComponent.prototype.writeValue = function (value) {
            this.value = this.value || value;
            if (value === this.value) {
                this.select();
            }
            else {
                this.deselect();
            }
        };
        /** @hidden */
        IgxRadioComponent.prototype.getEditElement = function () {
            return this.nativeRadio.nativeElement;
        };
        Object.defineProperty(IgxRadioComponent.prototype, "labelClass", {
            /**
             * @hidden
             */
            get: function () {
                switch (this.labelPosition) {
                    case RadioLabelPosition.BEFORE:
                        return this.cssClass + "__label--before";
                    case RadioLabelPosition.AFTER:
                    default:
                        return this.cssClass + "__label";
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxRadioComponent.prototype.onBlur = function () {
            this.focused = false;
            this._onTouchedCallback();
        };
        /**
         * @hidden
         */
        IgxRadioComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /**
         * @hidden
         */
        IgxRadioComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /**
         * @hidden
         */
        IgxRadioComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        return IgxRadioComponent;
    }());
    IgxRadioComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: IgxRadioComponent,
                            multi: true,
                        },
                    ],
                    selector: 'igx-radio',
                    template: "<input #radio class=\"igx-radio__input\" type=\"radio\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (blur)=\"onBlur()\" />\n\n<label #nativeLabel class=\"igx-radio__composite\" igxRipple\n    (click)=\"_clicked($event)\"\n    igxRippleTarget=\".igx-radio__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    [for]=\"inputId\">\n    <div class=\"igx-radio__ripple\"></div>\n</label>\n\n<span #placeholderLabel\n    (click)=\"_clicked($event)\"\n    [id]=\"labelId\"\n    [class]=\"labelClass\">\n    <ng-content></ng-content>\n</span>\n"
                },] }
    ];
    IgxRadioComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxRadioComponent.propDecorators = {
        nativeRadio: [{ type: i0.ViewChild, args: ['radio', { static: true },] }],
        nativeLabel: [{ type: i0.ViewChild, args: ['nativeLabel', { static: true },] }],
        placeholderLabel: [{ type: i0.ViewChild, args: ['placeholderLabel', { static: true },] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        labelId: [{ type: i0.Input }],
        labelPosition: [{ type: i0.Input }],
        value: [{ type: i0.Input }],
        name: [{ type: i0.Input }],
        tabindex: [{ type: i0.Input }],
        disableRipple: [{ type: i0.Input }],
        required: [{ type: i0.Input }],
        ariaLabelledBy: [{ type: i0.Input, args: ['aria-labelledby',] }],
        ariaLabel: [{ type: i0.Input, args: ['aria-label',] }],
        change: [{ type: i0.Output }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-radio',] }],
        checked: [{ type: i0.HostBinding, args: ['class.igx-radio--checked',] }, { type: i0.Input }],
        disabled: [{ type: i0.HostBinding, args: ['class.igx-radio--disabled',] }, { type: i0.Input }],
        focused: [{ type: i0.HostBinding, args: ['class.igx-radio--focused',] }],
        onKeyUp: [{ type: i0.HostListener, args: ['keyup', ['$event'],] }]
    };

    var IgxRippleDirective = /** @class */ (function () {
        function IgxRippleDirective(builder, elementRef, renderer, zone) {
            this.builder = builder;
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.zone = zone;
            /**
             * Sets/gets the ripple target.
             * ```html
             * <div  #rippleContainer class="div-1" igxRipple [igxRippleTarget] = "'.div-1'"></div>
             * ```
             * ```typescript
             * @ViewChild('rippleContainer', {read: IgxRippleDirective})
             * public ripple: IgxRippleDirective;
             * let rippleTarget = this.ripple.rippleTarget;
             * ```
             * Can set the ripple to activate on a child element inside the parent where igxRipple is defined.
             * ```html
             * <div #rippleContainer [igxRippleTarget] = "'#child"'>
             *  <button id="child">Click</button>
             * </div>
             * ```
             *
             * @memberof IgxRippleDirective
             */
            this.rippleTarget = '';
            /**
             * Sets/gets the ripple duration(in milliseconds).
             * Default value is `600`.
             * ```html
             * <button #rippleContainer igxRipple [igxRippleDuration] = "800"></button>
             * ```
             * ```typescript
             * @ViewChild('rippleContainer', {read: IgxRippleDirective})
             * public ripple: IgxRippleDirective;
             * let rippleDuration = this.ripple.rippleDuration;
             * ```
             *
             * @memberof IgxRippleDirective
             */
            this.rippleDuration = 600;
            /**
             * Sets/gets whether the ripple is disabled.
             * Default value is `false`.
             * ```html
             * <button #rippleContainer igxRipple [igxRippleDisabled] = "true"></button>
             * ```
             * ```typescript
             * @ViewChild('rippleContainer', {read: IgxRippleDirective})
             * public ripple: IgxRippleDirective;
             * let isRippleDisabled = this.ripple.rippleDisabled;
             * ```
             *
             * @memberof IgxRippleDirective
             */
            this.rippleDisabled = false;
            this.rippleElementClass = 'igx-ripple__inner';
            this.rippleHostClass = 'igx-ripple';
            this._centered = false;
            this.animationQueue = [];
        }
        Object.defineProperty(IgxRippleDirective.prototype, "centered", {
            /**
             * Enables/disables the ripple to be centered.
             * ```html
             * <button #rippleContainer igxRipple [igxRippleCentered] = "true"></button>
             * ```
             *
             * @memberof IgxRippleDirective
             */
            set: function (value) {
                this._centered = value || this.centered;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRippleDirective.prototype, "nativeElement", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxRippleDirective.prototype.onMouseDown = function (event) {
            var _this = this;
            this.zone.runOutsideAngular(function () { return _this._ripple(event); });
        };
        IgxRippleDirective.prototype.setStyles = function (rippleElement, styleParams) {
            this.renderer.addClass(rippleElement, this.rippleElementClass);
            this.renderer.setStyle(rippleElement, 'width', styleParams.radius + "px");
            this.renderer.setStyle(rippleElement, 'height', styleParams.radius + "px");
            this.renderer.setStyle(rippleElement, 'top', styleParams.top + "px");
            this.renderer.setStyle(rippleElement, 'left', styleParams.left + "px");
            if (this.rippleColor) {
                this.renderer.setStyle(rippleElement, 'background', this.rippleColor);
            }
        };
        IgxRippleDirective.prototype._ripple = function (event) {
            var _this = this;
            if (this.rippleDisabled) {
                return;
            }
            var target = (this.rippleTarget ? this.nativeElement.querySelector(this.rippleTarget) || this.nativeElement : this.nativeElement);
            var rectBounds = target.getBoundingClientRect();
            var radius = Math.max(rectBounds.width, rectBounds.height);
            var left = Math.round(event.clientX - rectBounds.left - radius / 2);
            var top = Math.round(event.clientY - rectBounds.top - radius / 2);
            if (this._centered) {
                left = top = 0;
            }
            var dimensions = {
                radius: radius,
                top: top,
                left: left
            };
            var rippleElement = this.renderer.createElement('span');
            this.setStyles(rippleElement, dimensions);
            this.renderer.addClass(target, this.rippleHostClass);
            this.renderer.appendChild(target, rippleElement);
            var animation = this.builder.build([
                i1.style({ opacity: 0.5, transform: 'scale(.3)' }),
                i1.animate(this.rippleDuration, i1.style({ opacity: 0, transform: 'scale(2)' }))
            ]).create(rippleElement);
            this.animationQueue.push(animation);
            animation.onDone(function () {
                _this.animationQueue.splice(_this.animationQueue.indexOf(animation), 1);
                target.removeChild(rippleElement);
                if (_this.animationQueue.length < 1) {
                    _this.renderer.removeClass(target, _this.rippleHostClass);
                }
            });
            animation.play();
        };
        return IgxRippleDirective;
    }());
    IgxRippleDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxRipple]'
                },] }
    ];
    IgxRippleDirective.ctorParameters = function () { return [
        { type: i1.AnimationBuilder },
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: i0.NgZone }
    ]; };
    IgxRippleDirective.propDecorators = {
        rippleTarget: [{ type: i0.Input, args: ['igxRippleTarget',] }],
        rippleColor: [{ type: i0.Input, args: ['igxRipple',] }],
        rippleDuration: [{ type: i0.Input, args: ['igxRippleDuration',] }],
        centered: [{ type: i0.Input, args: ['igxRippleCentered',] }],
        rippleDisabled: [{ type: i0.Input, args: ['igxRippleDisabled',] }],
        onMouseDown: [{ type: i0.HostListener, args: ['mousedown', ['$event'],] }]
    };
    /**
     * @hidden
     */
    var IgxRippleModule = /** @class */ (function () {
        function IgxRippleModule() {
        }
        return IgxRippleModule;
    }());
    IgxRippleModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxRippleDirective],
                    exports: [IgxRippleDirective]
                },] }
    ];

    /**
     * Determines the Radio Group alignment
     */
    var RadioGroupAlignment = mkenum({
        horizontal: 'horizontal',
        vertical: 'vertical'
    });
    var nextId$1 = 0;
    /**
     * Radio group directive renders set of radio buttons.
     *
     * @igxModule IgxRadioModule
     *
     * @igxTheme igx-radio-theme
     *
     * @igxKeywords radiogroup, radio, button, input
     *
     * @igxGroup Data Entry & Display
     *
     * @remarks
     * The Ignite UI Radio Group allows the user to select a single option from an available set of options that are listed side by side.
     *
     * @example:
     * ```html
     * <igx-radio-group name="radioGroup">
     *   <igx-radio *ngFor="let item of ['Foo', 'Bar', 'Baz']" value="{{item}}">
     *      {{item}}
     *   </igx-radio>
     * </igx-radio-group>
     * ```
     */
    var IgxRadioGroupDirective = /** @class */ (function () {
        function IgxRadioGroupDirective() {
            /**
             * An event that is emitted after the radio group `value` is changed.
             *
             * @remarks
             * Provides references to the selected `IgxRadioComponent` and the `value` property as event arguments.
             *
             * @example
             * ```html
             * <igx-radio-group (change)="handler($event)"></igx-radio-group>
             * ```
             */
            // eslint-disable-next-line @angular-eslint/no-output-native
            this.change = new i0.EventEmitter();
            /**
             * The css class applied to the component.
             *
             * @hidden
             * @internal
             */
            this.cssClass = 'igx-radio-group';
            /**
             * Sets vertical alignment to the radio group, if `alignment` is set to `vertical`.
             * By default the alignment is horizontal.
             *
             * @example
             * ```html
             * <igx-radio-group alignment="vertical"></igx-radio-group>
             * ```
             */
            this.vertical = false;
            /**
             * @hidden
             * @internal
             */
            this._onChangeCallback = rxjs.noop;
            /**
             * @hidden
             * @internal
             */
            this._name = "igx-radio-group-" + nextId$1++;
            /**
             * @hidden
             * @internal
             */
            this._value = null;
            /**
             * @hidden
             * @internal
             */
            this._selected = null;
            /**
             * @hidden
             * @internal
             */
            this._isInitialized = false;
            /**
             * @hidden
             * @internal
             */
            this._labelPosition = 'after';
            /**
             * @hidden
             * @internal
             */
            this._disabled = false;
            /**
             * @hidden
             * @internal
             */
            this._required = false;
            /**
             * @hidden
             * @internal
             */
            this.destroy$ = new rxjs.Subject();
        }
        Object.defineProperty(IgxRadioGroupDirective.prototype, "value", {
            /**
             * Sets/gets the `value` attribute.
             *
             * @example
             * ```html
             * <igx-radio-group [value] = "'radioButtonValue'"></igx-radio-group>
             * ```
             */
            get: function () {
                return this._value;
            },
            set: function (newValue) {
                if (this._value !== newValue) {
                    this._value = newValue;
                    this._selectRadioButton();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRadioGroupDirective.prototype, "name", {
            /**
             * Sets/gets the `name` attribute of the radio group component. All child radio buttons inherits this name.
             *
             * @example
             * ```html
             * <igx-radio-group name = "Radio1"></igx-radio-group>
             *  ```
             */
            get: function () {
                return this._name;
            },
            set: function (newValue) {
                if (this._name !== newValue) {
                    this._name = newValue;
                    this._setRadioButtonNames();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRadioGroupDirective.prototype, "required", {
            /**
             * Sets/gets whether the radio group is required.
             *
             * @remarks
             * If not set, `required` will have value `false`.
             *
             * @example
             * ```html
             * <igx-radio-group [required] = "true"></igx-radio-group>
             * ```
             */
            get: function () {
                return this._required;
            },
            set: function (newValue) {
                if (this._required !== newValue) {
                    this._required = newValue;
                    this._setRadioButtonsRequired();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRadioGroupDirective.prototype, "disabled", {
            /**
             * An @Input property that allows you to disable the radio group. By default it's false.
             *
             * @example
             *  ```html
             * <igx-radio-group [disabled]="true"></igx-radio-group>
             * ```
             */
            get: function () {
                return this._disabled;
            },
            set: function (newValue) {
                if (this._disabled !== newValue) {
                    this._disabled = newValue;
                    this.setDisabledState(newValue);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRadioGroupDirective.prototype, "labelPosition", {
            /**
             * Sets/gets the position of the `label` in the child radio buttons.
             *
             * @remarks
             * If not set, `labelPosition` will have value `"after"`.
             *
             * @example
             * ```html
             * <igx-radio-group labelPosition = "before"></igx-radio-group>
             * ```
             */
            get: function () {
                return this._labelPosition;
            },
            set: function (newValue) {
                if (this._labelPosition !== newValue) {
                    this._labelPosition = newValue === RadioLabelPosition.BEFORE ? RadioLabelPosition.BEFORE : RadioLabelPosition.AFTER;
                    this._setRadioButtonLabelPosition();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRadioGroupDirective.prototype, "selected", {
            /**
             * Sets/gets the selected child radio button.
             *
             * @example
             * ```typescript
             * let selectedButton = this.radioGroup.selected;
             * this.radioGroup.selected = selectedButton;
             * ```
             */
            get: function () {
                return this._selected;
            },
            set: function (selected) {
                if (this._selected !== selected) {
                    this._selected = selected;
                    this.value = selected ? selected.value : null;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRadioGroupDirective.prototype, "alignment", {
            /**
             * Returns the alignment of the `igx-radio-group`.
             * ```typescript
             * @ViewChild("MyRadioGroup")
             * public radioGroup: IgxRadioGroupDirective;
             * ngAfterViewInit(){
             *    let radioAlignment = this.radioGroup.alignment;
             * }
             * ```
             */
            get: function () {
                return this.vertical ? RadioGroupAlignment.vertical : RadioGroupAlignment.horizontal;
            },
            /**
             * Allows you to set the radio group alignment.
             * Available options are `RadioGroupAlignment.horizontal` (default) and `RadioGroupAlignment.vertical`.
             * ```typescript
             * public alignment = RadioGroupAlignment.vertical;
             * //..
             * ```
             * ```html
             * <igx-radio-group [alignment]="alignment"></igx-radio-group>
             * ```
             */
            set: function (value) {
                this.vertical = value === RadioGroupAlignment.vertical;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            // The initial value can possibly be set by NgModel and it is possible that
            // the OnInit of the NgModel occurs after the OnInit of this class.
            this._isInitialized = true;
            setTimeout(function () {
                _this._initRadioButtons();
            });
        };
        /**
         * Sets the "checked" property value on the radio input element.
         *
         * @remarks
         * Checks whether the provided value is consistent to the current radio button.
         * If it is, the checked attribute will have value `true` and selected property will contain the selected `IgxRadioComponent`.
         *
         * @example
         * ```typescript
         * this.radioGroup.writeValue('radioButtonValue');
         * ```
         */
        IgxRadioGroupDirective.prototype.writeValue = function (value) {
            this.value = value;
        };
        /**
         * Registers a function called when the control value changes.
         *
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype.setDisabledState = function (isDisabled) {
            if (this.radioButtons) {
                this.radioButtons.forEach(function (button) {
                    button.disabled = isDisabled;
                });
            }
        };
        /**
         * Registers a function called when the control is touched.
         *
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype.registerOnTouched = function (fn) {
            if (this.radioButtons) {
                this.radioButtons.forEach(function (button) {
                    button.registerOnTouched(fn);
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype._initRadioButtons = function () {
            var _this = this;
            if (this.radioButtons) {
                var props_1 = { name: this._name, labelPosition: this._labelPosition, disabled: this._disabled, required: this._required };
                this.radioButtons.forEach(function (button) {
                    Object.assign(button, props_1);
                    if (button.value === _this._value) {
                        button.checked = true;
                        _this._selected = button;
                    }
                    button.change.pipe(operators.takeUntil(_this.destroy$)).subscribe(function (ev) { return _this._selectedRadioButtonChanged(ev); });
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype._selectedRadioButtonChanged = function (args) {
            this.radioButtons.forEach(function (button) {
                button.checked = button.id === args.radio.id;
            });
            this._selected = args.radio;
            this._value = args.value;
            if (this._isInitialized) {
                this.change.emit(args);
                this._onChangeCallback(this.value);
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype._setRadioButtonNames = function () {
            var _this = this;
            if (this.radioButtons) {
                this.radioButtons.forEach(function (button) {
                    button.name = _this._name;
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype._selectRadioButton = function () {
            var _this = this;
            if (this.radioButtons) {
                this.radioButtons.forEach(function (button) {
                    if (!_this._value) {
                        // no value - uncheck all radio buttons
                        if (button.checked) {
                            button.checked = false;
                        }
                    }
                    else {
                        if (_this._value === button.value) {
                            // selected button
                            if (_this._selected !== button) {
                                _this._selected = button;
                            }
                            if (!button.checked) {
                                button.select();
                            }
                        }
                        else {
                            // non-selected button
                            if (button.checked) {
                                button.checked = false;
                            }
                        }
                    }
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype._setRadioButtonLabelPosition = function () {
            var _this = this;
            if (this.radioButtons) {
                this.radioButtons.forEach(function (button) {
                    button.labelPosition = _this._labelPosition;
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype._setRadioButtonsRequired = function () {
            var _this = this;
            if (this.radioButtons) {
                this.radioButtons.forEach(function (button) {
                    button.required = _this._required;
                });
            }
        };
        return IgxRadioGroupDirective;
    }());
    IgxRadioGroupDirective.decorators = [
        { type: i0.Directive, args: [{
                    exportAs: 'igxRadioGroup',
                    selector: 'igx-radio-group, [igxRadioGroup]',
                    providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxRadioGroupDirective, multi: true }]
                },] }
    ];
    IgxRadioGroupDirective.propDecorators = {
        radioButtons: [{ type: i0.ContentChildren, args: [IgxRadioComponent, { descendants: true },] }],
        value: [{ type: i0.Input }],
        name: [{ type: i0.Input }],
        required: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        labelPosition: [{ type: i0.Input }],
        selected: [{ type: i0.Input }],
        change: [{ type: i0.Output }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-radio-group',] }],
        vertical: [{ type: i0.HostBinding, args: ['class.igx-radio-group--vertical',] }],
        alignment: [{ type: i0.Input }]
    };
    /**
     * @hidden
     */
    var IgxRadioModule = /** @class */ (function () {
        function IgxRadioModule() {
        }
        return IgxRadioModule;
    }());
    IgxRadioModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxRadioGroupDirective, IgxRadioComponent],
                    exports: [IgxRadioGroupDirective, IgxRadioComponent],
                    imports: [IgxRippleModule]
                },] }
    ];

    var IgxTextHighlightDirective = /** @class */ (function () {
        function IgxTextHighlightDirective(element, renderer) {
            var _this = this;
            this.element = element;
            this.renderer = renderer;
            /**
             * Identifies the highlight within a unique group.
             * This allows it to have several different highlight groups,
             * with each of them having their own active highlight.
             *
             * ```html
             * <div
             *   igxTextHighlight
             *   [groupName]="myGroupName">
             * </div>
             * ```
             */
            this.groupName = '';
            this.destroy$ = new rxjs.Subject();
            this._value = '';
            this._div = null;
            this._observer = null;
            this._nodeWasRemoved = false;
            this._forceEvaluation = false;
            this._activeElementIndex = -1;
            this._defaultCssClass = 'igx-highlight';
            this._defaultActiveCssClass = 'igx-highlight--active';
            IgxTextHighlightDirective.onActiveElementChanged.pipe(operators.takeUntil(this.destroy$)).subscribe(function (groupName) {
                if (_this.groupName === groupName) {
                    if (_this._activeElementIndex !== -1) {
                        _this.deactivate();
                    }
                    _this.activateIfNecessary();
                }
            });
        }
        Object.defineProperty(IgxTextHighlightDirective.prototype, "value", {
            /**
             * The underlying value of the element that will be highlighted.
             *
             * ```typescript
             * // get
             * const elementValue = this.textHighlight.value;
             * ```
             *
             * ```html
             * <!--set-->
             * <div
             *   igxTextHighlight
             *   [value]="newValue">
             * </div>
             * ```
             */
            get: function () {
                return this._value;
            },
            set: function (value) {
                if (value === undefined || value === null) {
                    this._value = '';
                }
                else {
                    this._value = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTextHighlightDirective.prototype, "lastSearchInfo", {
            /**
             * @hidden
             */
            get: function () {
                return this._lastSearchInfo;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Activates the highlight at a given index.
         * (if such index exists)
         */
        IgxTextHighlightDirective.setActiveHighlight = function (groupName, highlight) {
            IgxTextHighlightDirective.highlightGroupsMap.set(groupName, highlight);
            IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);
        };
        /**
         * Clears any existing highlight.
         */
        IgxTextHighlightDirective.clearActiveHighlight = function (groupName) {
            IgxTextHighlightDirective.highlightGroupsMap.set(groupName, {
                index: -1
            });
            IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);
        };
        /**
         * @hidden
         */
        IgxTextHighlightDirective.prototype.ngOnDestroy = function () {
            this.clearHighlight();
            if (this._observer !== null) {
                this._observer.disconnect();
            }
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden
         */
        IgxTextHighlightDirective.prototype.ngOnChanges = function (changes) {
            if (changes.value && !changes.value.firstChange) {
                this._valueChanged = true;
            }
            else if ((changes.row !== undefined && !changes.row.firstChange) ||
                (changes.column !== undefined && !changes.column.firstChange) ||
                (changes.page !== undefined && !changes.page.firstChange)) {
                if (this._activeElementIndex !== -1) {
                    this.deactivate();
                }
                this.activateIfNecessary();
            }
        };
        /**
         * @hidden
         */
        IgxTextHighlightDirective.prototype.ngAfterViewInit = function () {
            this.parentElement = this.renderer.parentNode(this.element.nativeElement);
            if (IgxTextHighlightDirective.highlightGroupsMap.has(this.groupName) === false) {
                IgxTextHighlightDirective.highlightGroupsMap.set(this.groupName, {
                    index: -1
                });
            }
            this._lastSearchInfo = {
                searchedText: '',
                content: this.value,
                matchCount: 0,
                caseSensitive: false,
                exactMatch: false
            };
            this._container = this.parentElement.firstElementChild;
        };
        /**
         * @hidden
         */
        IgxTextHighlightDirective.prototype.ngAfterViewChecked = function () {
            if (this._valueChanged) {
                this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
                this.activateIfNecessary();
                this._valueChanged = false;
            }
        };
        /**
         * Clears the existing highlight and highlights the searched text.
         * Returns how many times the element contains the searched text.
         */
        IgxTextHighlightDirective.prototype.highlight = function (text, caseSensitive, exactMatch) {
            var caseSensitiveResolved = caseSensitive ? true : false;
            var exactMatchResolved = exactMatch ? true : false;
            if (this.searchNeedsEvaluation(text, caseSensitiveResolved, exactMatchResolved)) {
                this._lastSearchInfo.searchedText = text;
                this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
                this._lastSearchInfo.exactMatch = exactMatchResolved;
                this._lastSearchInfo.content = this.value;
                if (text === '' || text === undefined || text === null) {
                    this.clearHighlight();
                }
                else {
                    this.clearChildElements(true);
                    this._lastSearchInfo.matchCount = this.getHighlightedText(text, caseSensitive, exactMatch);
                }
            }
            else if (this._nodeWasRemoved) {
                this._lastSearchInfo.searchedText = text;
                this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
                this._lastSearchInfo.exactMatch = exactMatchResolved;
            }
            return this._lastSearchInfo.matchCount;
        };
        /**
         * Clears any existing highlight.
         */
        IgxTextHighlightDirective.prototype.clearHighlight = function () {
            this.clearChildElements(false);
            this._lastSearchInfo.searchedText = '';
            this._lastSearchInfo.matchCount = 0;
        };
        /**
         * Activates the highlight if it is on the currently active row and column.
         */
        IgxTextHighlightDirective.prototype.activateIfNecessary = function () {
            var group = IgxTextHighlightDirective.highlightGroupsMap.get(this.groupName);
            if (group.column === this.column && group.row === this.row && compareMaps(this.metadata, group.metadata)) {
                this.activate(group.index);
            }
        };
        /**
         * Attaches a MutationObserver to the parentElement and watches for when the container element is removed/readded to the DOM.
         * Should be used only when necessary as using many observers may lead to performance degradation.
         */
        IgxTextHighlightDirective.prototype.observe = function () {
            var _this = this;
            if (this._observer === null) {
                var callback = function (mutationList) {
                    mutationList.forEach(function (mutation) {
                        var removedNodes = Array.from(mutation.removedNodes);
                        removedNodes.forEach(function (n) {
                            if (n === _this._container) {
                                _this._nodeWasRemoved = true;
                                _this.clearChildElements(false);
                            }
                        });
                        var addedNodes = Array.from(mutation.addedNodes);
                        addedNodes.forEach(function (n) {
                            if (n === _this.parentElement.firstElementChild && _this._nodeWasRemoved) {
                                _this._container = _this.parentElement.firstElementChild;
                                _this._nodeWasRemoved = false;
                                _this._forceEvaluation = true;
                                _this.highlight(_this._lastSearchInfo.searchedText, _this._lastSearchInfo.caseSensitive, _this._lastSearchInfo.exactMatch);
                                _this._forceEvaluation = false;
                                _this.activateIfNecessary();
                                _this._observer.disconnect();
                                _this._observer = null;
                            }
                        });
                    });
                };
                this._observer = new MutationObserver(callback);
                this._observer.observe(this.parentElement, { childList: true });
            }
        };
        IgxTextHighlightDirective.prototype.activate = function (index) {
            this.deactivate();
            if (this._div !== null) {
                var spans = this._div.querySelectorAll('span');
                this._activeElementIndex = index;
                if (spans.length <= index) {
                    return;
                }
                var elementToActivate = spans[index];
                this.renderer.addClass(elementToActivate, this._defaultActiveCssClass);
                this.renderer.addClass(elementToActivate, this.activeCssClass);
            }
        };
        IgxTextHighlightDirective.prototype.deactivate = function () {
            if (this._activeElementIndex === -1) {
                return;
            }
            var spans = this._div.querySelectorAll('span');
            if (spans.length <= this._activeElementIndex) {
                this._activeElementIndex = -1;
                return;
            }
            var elementToDeactivate = spans[this._activeElementIndex];
            this.renderer.removeClass(elementToDeactivate, this._defaultActiveCssClass);
            this.renderer.removeClass(elementToDeactivate, this.activeCssClass);
            this._activeElementIndex = -1;
        };
        IgxTextHighlightDirective.prototype.clearChildElements = function (originalContentHidden) {
            this.renderer.setProperty(this.element.nativeElement, 'hidden', originalContentHidden);
            if (this._div !== null) {
                this.renderer.removeChild(this.parentElement, this._div);
                this._div = null;
                this._activeElementIndex = -1;
            }
        };
        IgxTextHighlightDirective.prototype.getHighlightedText = function (searchText, caseSensitive, exactMatch) {
            this.appendDiv();
            var stringValue = String(this.value);
            var contentStringResolved = !caseSensitive ? stringValue.toLowerCase() : stringValue;
            var searchTextResolved = !caseSensitive ? searchText.toLowerCase() : searchText;
            var matchCount = 0;
            if (exactMatch) {
                if (contentStringResolved === searchTextResolved) {
                    this.appendSpan("<span class=\"" + this._defaultCssClass + " " + (this.cssClass ? this.cssClass : '') + "\">" + stringValue + "</span>");
                    matchCount++;
                }
                else {
                    this.appendText(stringValue);
                }
            }
            else {
                var foundIndex = contentStringResolved.indexOf(searchTextResolved, 0);
                var previousMatchEnd = 0;
                while (foundIndex !== -1) {
                    var start = foundIndex;
                    var end = foundIndex + searchTextResolved.length;
                    this.appendText(stringValue.substring(previousMatchEnd, start));
                    // eslint-disable-next-line max-len
                    this.appendSpan("<span class=\"" + this._defaultCssClass + " " + (this.cssClass ? this.cssClass : '') + "\">" + stringValue.substring(start, end) + "</span>");
                    previousMatchEnd = end;
                    matchCount++;
                    foundIndex = contentStringResolved.indexOf(searchTextResolved, end);
                }
                this.appendText(stringValue.substring(previousMatchEnd, stringValue.length));
            }
            return matchCount;
        };
        IgxTextHighlightDirective.prototype.appendText = function (text) {
            var textElement = this.renderer.createText(text);
            this.renderer.appendChild(this._div, textElement);
        };
        IgxTextHighlightDirective.prototype.appendSpan = function (outerHTML) {
            var span = this.renderer.createElement('span');
            this.renderer.appendChild(this._div, span);
            this.renderer.setProperty(span, 'outerHTML', outerHTML);
        };
        IgxTextHighlightDirective.prototype.appendDiv = function () {
            this._div = this.renderer.createElement('div');
            if (this.containerClass) {
                this.renderer.addClass(this._div, this.containerClass);
            }
            this.renderer.appendChild(this.parentElement, this._div);
        };
        IgxTextHighlightDirective.prototype.searchNeedsEvaluation = function (text, caseSensitive, exactMatch) {
            var searchedText = this._lastSearchInfo.searchedText;
            return !this._nodeWasRemoved &&
                (searchedText === null ||
                    searchedText !== text ||
                    this._lastSearchInfo.content !== this.value ||
                    this._lastSearchInfo.caseSensitive !== caseSensitive ||
                    this._lastSearchInfo.exactMatch !== exactMatch ||
                    this._forceEvaluation);
        };
        return IgxTextHighlightDirective;
    }());
    IgxTextHighlightDirective.highlightGroupsMap = new Map();
    IgxTextHighlightDirective.onActiveElementChanged = new i0.EventEmitter();
    IgxTextHighlightDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxTextHighlight]'
                },] }
    ];
    IgxTextHighlightDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    IgxTextHighlightDirective.propDecorators = {
        cssClass: [{ type: i0.Input, args: ['cssClass',] }],
        activeCssClass: [{ type: i0.Input, args: ['activeCssClass',] }],
        containerClass: [{ type: i0.Input, args: ['containerClass',] }],
        groupName: [{ type: i0.Input, args: ['groupName',] }],
        value: [{ type: i0.Input, args: ['value',] }],
        row: [{ type: i0.Input, args: ['row',] }],
        column: [{ type: i0.Input, args: ['column',] }],
        metadata: [{ type: i0.Input }]
    };
    /**
     * @hidden
     */
    var IgxTextHighlightModule = /** @class */ (function () {
        function IgxTextHighlightModule() {
        }
        return IgxTextHighlightModule;
    }());
    IgxTextHighlightModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxTextHighlightDirective],
                    exports: [IgxTextHighlightDirective]
                },] }
    ];

    var IgxTextSelectionDirective = /** @class */ (function () {
        function IgxTextSelectionDirective(element) {
            this.element = element;
            this.selectionState = true;
        }
        Object.defineProperty(IgxTextSelectionDirective.prototype, "selected", {
            /**
             * Returns whether the input element is selectable through the directive.
             *
             * ```typescript
             * // get
             * @ViewChild('firstName',
             *  {read: IgxTextSelectionDirective})
             * public firstName: IgxTextSelectionDirective;
             *
             * public getFirstNameSelectionStatus() {
             *  return this.firstName.selected;
             * }
             * ```
             */
            get: function () {
                return this.selectionState;
            },
            /**
             *  Determines whether the input element could be selected through the directive.
             *
             * ```html
             * <!--set-->
             * <input
             *   type="text"
             *   id="firstName"
             *   [igxTextSelection]="true">
             * </input>
             *
             * <input
             *   type="text"
             *   id="lastName"
             *   igxTextSelection
             *   [selected]="true">
             * </input>
             * ```
             */
            set: function (val) {
                this.selectionState = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTextSelectionDirective.prototype, "nativeElement", {
            /**
             * Returns the nativeElement of the element where the directive was applied.
             *
             * ```html
             * <input
             *   type="text"
             *   id="firstName"
             *   igxTextSelection>
             * </input>
             * ```
             *
             * ```typescript
             * @ViewChild('firstName',
             *  {read: IgxTextSelectionDirective})
             * public inputElement: IgxTextSelectionDirective;
             *
             * public getNativeElement() {
             *  return this.inputElement.nativeElement;
             * }
             * ```
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTextSelectionDirective.prototype.onFocus = function () {
            this.trigger();
        };
        /**
         * Triggers the selection of the element if it is marked as selectable.
         *
         * ```html
         * <input
         *   type="text"
         *   id="firstName"
         *   igxTextSelection>
         * </input>
         * ```
         *
         * ```typescript
         * @ViewChild('firstName',
         *  {read: IgxTextSelectionDirective})
         * public inputElement: IgxTextSelectionDirective;
         *
         * public triggerElementSelection() {
         *  this.inputElement.trigger();
         * }
         * ```
         */
        IgxTextSelectionDirective.prototype.trigger = function () {
            var _this = this;
            if (this.selected && this.nativeElement.value.length) {
                requestAnimationFrame(function () { return _this.nativeElement.setSelectionRange(0, _this.nativeElement.value.length); });
            }
        };
        return IgxTextSelectionDirective;
    }());
    IgxTextSelectionDirective.decorators = [
        { type: i0.Directive, args: [{
                    exportAs: 'igxTextSelection',
                    selector: '[igxTextSelection]'
                },] }
    ];
    IgxTextSelectionDirective.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxTextSelectionDirective.propDecorators = {
        selected: [{ type: i0.Input, args: ['igxTextSelection',] }],
        onFocus: [{ type: i0.HostListener, args: ['focus',] }]
    };
    /**
     * @hidden
     */
    var IgxTextSelectionModule = /** @class */ (function () {
        function IgxTextSelectionModule() {
        }
        return IgxTextSelectionModule;
    }());
    IgxTextSelectionModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxTextSelectionDirective],
                    exports: [IgxTextSelectionDirective]
                },] }
    ];

    /**
     * **Ignite UI for Angular Tooltip Target** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip)
     *
     * The Ignite UI for Angular Tooltip Target directive is used to mark an HTML element in the markup as one that has a tooltip.
     * The tooltip target is used in combination with the Ignite UI for Angular Tooltip by assigning the exported tooltip reference to the
     * target's selector property.
     *
     * Example:
     * ```html
     * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
     * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
     * ```
     */
    var IgxTooltipTargetDirective = /** @class */ (function (_super) {
        __extends(IgxTooltipTargetDirective, _super);
        function IgxTooltipTargetDirective(_element, _navigationService) {
            var _this = _super.call(this, _element, _navigationService) || this;
            _this._element = _element;
            _this._navigationService = _navigationService;
            /**
             * Gets/sets the amount of milliseconds that should pass before showing the tooltip.
             *
             * ```typescript
             * // get
             * let tooltipShowDelay = this.tooltipTarget.showDelay;
             * ```
             *
             * ```html
             * <!--set-->
             * <button [igxTooltipTarget]="tooltipRef" showDelay="1500">Hover me</button>
             * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
             * ```
             */
            _this.showDelay = 500;
            /**
             * Gets/sets the amount of milliseconds that should pass before hiding the tooltip.
             *
             * ```typescript
             * // get
             * let tooltipHideDelay = this.tooltipTarget.hideDelay;
             * ```
             *
             * ```html
             * <!--set-->
             * <button [igxTooltipTarget]="tooltipRef" hideDelay="1500">Hover me</button>
             * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
             * ```
             */
            _this.hideDelay = 500;
            /**
             * Specifies if the tooltip should not show when hovering its target with the mouse. (defaults to false)
             * While setting this property to 'true' will disable the user interactions that shows/hides the tooltip,
             * the developer will still be able to show/hide the tooltip through the API.
             *
             * ```typescript
             * // get
             * let tooltipDisabledValue = this.tooltipTarget.tooltipDisabled;
             * ```
             *
             * ```html
             * <!--set-->
             * <button [igxTooltipTarget]="tooltipRef" [tooltipDisabled]="true">Hover me</button>
             * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
             * ```
             */
            _this.tooltipDisabled = false;
            /**
             * Emits an event when the tooltip that is associated with this target starts showing.
             * This event is fired before the start of the countdown to showing the tooltip.
             *
             * ```typescript
             * tooltipShowing(args: ITooltipShowEventArgs) {
             *    alert("Tooltip started showing!");
             * }
             * ```
             *
             * ```html
             * <button [igxTooltipTarget]="tooltipRef"
             *         (tooltipShow)='tooltipShowing($event)'>Hover me</button>
             * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
             * ```
             */
            _this.tooltipShow = new i0.EventEmitter();
            /**
             * Emits an event when the tooltip that is associated with this target starts hiding.
             * This event is fired before the start of the countdown to hiding the tooltip.
             *
             * ```typescript
             * tooltipHiding(args: ITooltipHideEventArgs) {
             *    alert("Tooltip started hiding!");
             * }
             * ```
             *
             * ```html
             * <button [igxTooltipTarget]="tooltipRef"
             *         (tooltipHide)='tooltipHiding($event)'>Hover me</button>
             * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
             * ```
             */
            _this.tooltipHide = new i0.EventEmitter();
            _this.destroy$ = new rxjs.Subject();
            return _this;
        }
        Object.defineProperty(IgxTooltipTargetDirective.prototype, "target", {
            /**
             * @hidden
             */
            get: function () {
                if (typeof this._target === 'string') {
                    return this._navigationService.get(this._target);
                }
                return this._target;
            },
            /**
             * @hidden
             */
            set: function (target) {
                if (target !== null && target !== '') {
                    this._target = target;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTooltipTargetDirective.prototype, "nativeElement", {
            /**
             * Gets the respective native element of the directive.
             *
             * ```typescript
             * let tooltipTargetElement = this.tooltipTarget.nativeElement;
             * ```
             */
            get: function () {
                return this._element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTooltipTargetDirective.prototype, "tooltipHidden", {
            /**
             * Indicates if the tooltip that is is associated with this target is currently hidden.
             *
             * ```typescript
             * let tooltipHiddenValue = this.tooltipTarget.tooltipHidden;
             * ```
             */
            get: function () {
                return !this.target || this.target.collapsed;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.onClick = function () {
            if (!this.target.collapsed) {
                this.target.forceClose(this.mergedOverlaySettings);
            }
        };
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.onMouseEnter = function () {
            var _this = this;
            if (this.tooltipDisabled) {
                return;
            }
            this.checkOutletAndOutsideClick();
            var shouldReturn = this.preMouseEnterCheck();
            if (shouldReturn) {
                return;
            }
            var showingArgs = { target: this, tooltip: this.target, cancel: false };
            this.tooltipShow.emit(showingArgs);
            if (showingArgs.cancel) {
                return;
            }
            this.target.toBeShown = true;
            this.target.timeoutId = setTimeout(function () {
                _this.target.open(_this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
                _this.target.toBeShown = false;
            }, this.showDelay);
        };
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.onMouseLeave = function () {
            var _this = this;
            if (this.tooltipDisabled) {
                return;
            }
            this.checkOutletAndOutsideClick();
            var shouldReturn = this.preMouseLeaveCheck();
            if (shouldReturn || this.target.collapsed) {
                return;
            }
            this.target.toBeHidden = true;
            this.target.timeoutId = setTimeout(function () {
                _this.target.close(); // Call close() of IgxTooltipDirective
                _this.target.toBeHidden = false;
            }, this.hideDelay);
        };
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.onTouchStart = function () {
            if (this.tooltipDisabled) {
                return;
            }
            this.showTooltip();
        };
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.onDocumentTouchStart = function (event) {
            if (this.tooltipDisabled) {
                return;
            }
            if (this.nativeElement !== event.target &&
                !this.nativeElement.contains(event.target)) {
                this.hideTooltip();
            }
        };
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.ngOnInit = function () {
            var _this = this;
            _super.prototype.ngOnInit.call(this);
            var positionSettings = {
                horizontalDirection: exports.HorizontalAlignment.Center,
                horizontalStartPoint: exports.HorizontalAlignment.Center,
                openAnimation: i1.useAnimation(scaleInCenter, { params: { duration: '150ms' } }),
                closeAnimation: i1.useAnimation(fadeOut, { params: { duration: '75ms' } })
            };
            this._overlayDefaults.positionStrategy = new AutoPositionStrategy(positionSettings);
            this._overlayDefaults.closeOnOutsideClick = false;
            this._overlayDefaults.closeOnEscape = true;
            this.target.onClosing.pipe(operators.takeUntil(this.destroy$)).subscribe(function (event) {
                var hidingArgs = { target: _this, tooltip: _this.target, cancel: false };
                _this.tooltipHide.emit(hidingArgs);
                if (hidingArgs.cancel) {
                    event.cancel = true;
                }
            });
        };
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.ngOnDestroy = function () {
            this.destroy$.next();
            this.destroy$.complete();
        };
        /**
         * Shows the tooltip by respecting the 'showDelay' property.
         *
         * ```typescript
         * this.tooltipTarget.showTooltip();
         * ```
         */
        IgxTooltipTargetDirective.prototype.showTooltip = function () {
            var _this = this;
            clearTimeout(this.target.timeoutId);
            if (!this.target.collapsed) {
                //  if close animation has started finish it, or close the tooltip with no animation
                this.target.forceClose(this.mergedOverlaySettings);
                this.target.toBeHidden = false;
            }
            var showingArgs = { target: this, tooltip: this.target, cancel: false };
            this.tooltipShow.emit(showingArgs);
            if (showingArgs.cancel) {
                return;
            }
            this.target.toBeShown = true;
            this.target.timeoutId = setTimeout(function () {
                _this.target.open(_this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
                _this.target.toBeShown = false;
            }, this.showDelay);
        };
        /**
         * Hides the tooltip by respecting the 'hideDelay' property.
         *
         * ```typescript
         * this.tooltipTarget.hideTooltip();
         * ```
         */
        IgxTooltipTargetDirective.prototype.hideTooltip = function () {
            var _this = this;
            if (this.target.collapsed && this.target.toBeShown) {
                clearTimeout(this.target.timeoutId);
            }
            if (this.target.collapsed || this.target.toBeHidden) {
                return;
            }
            this.target.toBeHidden = true;
            this.target.timeoutId = setTimeout(function () {
                _this.target.close(); // Call close() of IgxTooltipDirective
                _this.target.toBeHidden = false;
            }, this.hideDelay);
        };
        IgxTooltipTargetDirective.prototype.checkOutletAndOutsideClick = function () {
            if (this.outlet) {
                this._overlayDefaults.outlet = this.outlet;
            }
        };
        Object.defineProperty(IgxTooltipTargetDirective.prototype, "mergedOverlaySettings", {
            get: function () {
                return Object.assign({}, this._overlayDefaults, this.overlaySettings);
            },
            enumerable: false,
            configurable: true
        });
        // Return true if the execution in onMouseEnter should be terminated after this method
        IgxTooltipTargetDirective.prototype.preMouseEnterCheck = function () {
            // If tooltip is about to be opened
            if (this.target.toBeShown) {
                clearTimeout(this.target.timeoutId);
                this.target.toBeShown = false;
            }
            // If Tooltip is opened or about to be hidden
            if (!this.target.collapsed || this.target.toBeHidden) {
                clearTimeout(this.target.timeoutId);
                //  if close animation has started finish it, or close the tooltip with no animation
                this.target.forceClose(this.mergedOverlaySettings);
                this.target.toBeHidden = false;
            }
            return false;
        };
        // Return true if the execution in onMouseLeave should be terminated after this method
        IgxTooltipTargetDirective.prototype.preMouseLeaveCheck = function () {
            clearTimeout(this.target.timeoutId);
            // If tooltip is about to be opened
            if (this.target.toBeShown) {
                this.target.toBeShown = false;
                this.target.toBeHidden = false;
                return true;
            }
            return false;
        };
        return IgxTooltipTargetDirective;
    }(IgxToggleActionDirective));
    IgxTooltipTargetDirective.decorators = [
        { type: i0.Directive, args: [{
                    exportAs: 'tooltipTarget',
                    selector: '[igxTooltipTarget]'
                },] }
    ];
    IgxTooltipTargetDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: IgxNavigationService, decorators: [{ type: i0.Optional }] }
    ]; };
    IgxTooltipTargetDirective.propDecorators = {
        showDelay: [{ type: i0.Input, args: ['showDelay',] }],
        hideDelay: [{ type: i0.Input, args: ['hideDelay',] }],
        tooltipDisabled: [{ type: i0.Input, args: ['tooltipDisabled',] }],
        target: [{ type: i0.Input, args: ['igxTooltipTarget',] }],
        tooltipShow: [{ type: i0.Output }],
        tooltipHide: [{ type: i0.Output }],
        onClick: [{ type: i0.HostListener, args: ['click',] }],
        onMouseEnter: [{ type: i0.HostListener, args: ['mouseenter',] }],
        onMouseLeave: [{ type: i0.HostListener, args: ['mouseleave',] }],
        onTouchStart: [{ type: i0.HostListener, args: ['touchstart',] }],
        onDocumentTouchStart: [{ type: i0.HostListener, args: ['document:touchstart', ['$event'],] }]
    };
    var NEXT_ID$5 = 0;
    /**
     * **Ignite UI for Angular Tooltip** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip)
     *
     * The Ignite UI for Angular Tooltip directive is used to mark an HTML element in the markup as one that should behave as a tooltip.
     * The tooltip is used in combination with the Ignite UI for Angular Tooltip Target by assigning the exported tooltip reference to the
     * respective target's selector property.
     *
     * Example:
     * ```html
     * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
     * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
     * ```
     */
    var IgxTooltipDirective = /** @class */ (function (_super) {
        __extends(IgxTooltipDirective, _super);
        /** @hidden */
        function IgxTooltipDirective(elementRef, cdr, overlayService, navigationService) {
            var _this = 
            // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
            _super.call(this, elementRef, cdr, overlayService, navigationService) || this;
            /**
             * Identifier for the tooltip.
             * If this is property is not explicitly set, it will be automatically generated.
             *
             * ```typescript
             * let tooltipId = this.tooltip.id;
             * ```
             */
            _this.id = "igx-tooltip-" + NEXT_ID$5++;
            /**
             * @hidden
             * Returns whether close time out has started
             */
            _this.toBeHidden = false;
            /**
             * @hidden
             * Returns whether open time out has started
             */
            _this.toBeShown = false;
            return _this;
        }
        Object.defineProperty(IgxTooltipDirective.prototype, "hiddenClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.collapsed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTooltipDirective.prototype, "defaultClass", {
            /**
             * @hidden
             */
            get: function () {
                return !this.collapsed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTooltipDirective.prototype, "role", {
            /**
             * Get the role attribute of the tooltip.
             *
             * ```typescript
             * let tooltipRole = this.tooltip.role;
             * ```
             */
            get: function () {
                return 'tooltip';
            },
            enumerable: false,
            configurable: true
        });
        /**
         * If there is open animation in progress this method will finish is.
         * If there is no open animation in progress this method will open the toggle with no animation.
         *
         * @param overlaySettings setting to use for opening the toggle
         */
        IgxTooltipDirective.prototype.forceOpen = function (overlaySettings) {
            var info = this.overlayService.getOverlayById(this._overlayId);
            var hasOpenAnimation = info ? info.openAnimationPlayer : false;
            if (hasOpenAnimation) {
                info.openAnimationPlayer.finish();
                info.openAnimationPlayer.reset();
                info.openAnimationPlayer = null;
            }
            else if (this.collapsed) {
                var animation = overlaySettings.positionStrategy.settings.openAnimation;
                overlaySettings.positionStrategy.settings.openAnimation = null;
                this.open(overlaySettings);
                overlaySettings.positionStrategy.settings.openAnimation = animation;
            }
        };
        /**
         * If there is close animation in progress this method will finish is.
         * If there is no close animation in progress this method will close the toggle with no animation.
         *
         * @param overlaySettings settings to use for closing the toggle
         */
        IgxTooltipDirective.prototype.forceClose = function (overlaySettings) {
            var info = this.overlayService.getOverlayById(this._overlayId);
            var hasCloseAnimation = info ? info.closeAnimationPlayer : false;
            if (hasCloseAnimation) {
                info.closeAnimationPlayer.finish();
                info.closeAnimationPlayer.reset();
                info.closeAnimationPlayer = null;
            }
            else if (!this.collapsed) {
                var animation = overlaySettings.positionStrategy.settings.closeAnimation;
                overlaySettings.positionStrategy.settings.closeAnimation = null;
                this.close();
                overlaySettings.positionStrategy.settings.closeAnimation = animation;
            }
        };
        return IgxTooltipDirective;
    }(IgxToggleDirective));
    IgxTooltipDirective.decorators = [
        { type: i0.Directive, args: [{
                    exportAs: 'tooltip',
                    selector: '[igxTooltip]'
                },] }
    ];
    IgxTooltipDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: IgxOverlayService, decorators: [{ type: i0.Inject, args: [IgxOverlayService,] }] },
        { type: IgxNavigationService, decorators: [{ type: i0.Optional }] }
    ]; };
    IgxTooltipDirective.propDecorators = {
        hiddenClass: [{ type: i0.HostBinding, args: ['class.igx-tooltip--hidden',] }],
        defaultClass: [{ type: i0.HostBinding, args: ['class.igx-tooltip--desktop',] }],
        context: [{ type: i0.Input, args: ['context',] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }]
    };
    /**
     * @hidden
     */
    var IgxTooltipModule = /** @class */ (function () {
        function IgxTooltipModule() {
        }
        return IgxTooltipModule;
    }());
    IgxTooltipModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxTooltipDirective, IgxTooltipTargetDirective],
                    exports: [IgxTooltipDirective, IgxTooltipTargetDirective],
                    imports: [i2.CommonModule],
                    providers: [IgxOverlayService]
                },] }
    ];

    /**
     * Specify a particular date, time or AmPm part.
     */
    (function (DatePart) {
        DatePart["Date"] = "date";
        DatePart["Month"] = "month";
        DatePart["Year"] = "year";
        DatePart["Hours"] = "hour";
        DatePart["Minutes"] = "minute";
        DatePart["Seconds"] = "second";
        DatePart["AmPm"] = "ampm";
        DatePart["Literal"] = "literal";
    })(exports.DatePart || (exports.DatePart = {}));

    var DATE_CHARS = ['h', 'H', 'm', 's', 'S', 't', 'T'];
    var TIME_CHARS = ['d', 'D', 'M', 'y', 'Y'];
    /** @hidden */
    var DatePickerUtil = /** @class */ (function () {
        function DatePickerUtil() {
        }
        /**
         *  TODO: (in issue #6483) Unit tests and docs for all public methods.
         */
        /**
         * Parse a Date value from masked string input based on determined date parts
         *
         * @param inputData masked value to parse
         * @param dateTimeParts Date parts array for the mask
         */
        DatePickerUtil.parseValueFromMask = function (inputData, dateTimeParts, promptChar) {
            var parts = {};
            dateTimeParts.forEach(function (dp) {
                var value = parseInt(DatePickerUtil.getCleanVal(inputData, dp, promptChar), 10);
                if (!value) {
                    value = dp.type === exports.DatePart.Date || dp.type === exports.DatePart.Month ? 1 : 0;
                }
                parts[dp.type] = value;
            });
            parts[exports.DatePart.Month] -= 1;
            if (parts[exports.DatePart.Month] < 0 || 11 < parts[exports.DatePart.Month]) {
                return null;
            }
            // TODO: Century threshold
            if (parts[exports.DatePart.Year] < 50) {
                parts[exports.DatePart.Year] += 2000;
            }
            if (parts[exports.DatePart.Date] > DatePickerUtil.daysInMonth(parts[exports.DatePart.Year], parts[exports.DatePart.Month])) {
                return null;
            }
            if (parts[exports.DatePart.Hours] > 23 || parts[exports.DatePart.Minutes] > 59 || parts[exports.DatePart.Seconds] > 59) {
                return null;
            }
            return new Date(parts[exports.DatePart.Year] || 2000, parts[exports.DatePart.Month] || 0, parts[exports.DatePart.Date] || 1, parts[exports.DatePart.Hours] || 0, parts[exports.DatePart.Minutes] || 0, parts[exports.DatePart.Seconds] || 0);
        };
        /**
         * Parse the mask into date/time and literal parts
         */
        DatePickerUtil.parseDateTimeFormat = function (mask, locale) {
            if (locale === void 0) { locale = DatePickerUtil.DEFAULT_LOCALE; }
            var format = mask || DatePickerUtil.getDefaultInputFormat(locale);
            var dateTimeParts = [];
            var formatArray = Array.from(format);
            var currentPart = null;
            var position = 0;
            for (var i = 0; i < formatArray.length; i++, position++) {
                var type = DatePickerUtil.determineDatePart(formatArray[i]);
                if (currentPart) {
                    if (currentPart.type === type) {
                        currentPart.format += formatArray[i];
                        if (i < formatArray.length - 1) {
                            continue;
                        }
                    }
                    DatePickerUtil.ensureLeadingZero(currentPart);
                    currentPart.end = currentPart.start + currentPart.format.length;
                    position = currentPart.end;
                    dateTimeParts.push(currentPart);
                }
                currentPart = {
                    start: position,
                    end: position + formatArray[i].length,
                    type: type,
                    format: formatArray[i]
                };
            }
            return dateTimeParts;
        };
        DatePickerUtil.getDefaultInputFormat = function (locale) {
            if (!Intl || !Intl.DateTimeFormat || !Intl.DateTimeFormat.prototype.formatToParts) {
                // TODO: fallback with Intl.format for IE?
                return DatePickerUtil.SHORT_DATE_MASK;
            }
            var parts = DatePickerUtil.getDefaultLocaleMask(locale);
            parts.forEach(function (p) {
                if (p.type !== exports.DatePart.Year && p.type !== DatePickerUtil.SEPARATOR) {
                    p.formatType = "2-digit" /* TwoDigits */;
                }
            });
            return DatePickerUtil.getMask(parts);
        };
        DatePickerUtil.formatDate = function (value, format, locale, timezone) {
            var formattedDate;
            try {
                formattedDate = i2.formatDate(value, format, locale, timezone);
            }
            catch (_a) {
                DatePickerUtil.logMissingLocaleSettings(locale);
                var formatter = new Intl.DateTimeFormat(locale);
                formattedDate = formatter.format(value);
            }
            return formattedDate;
        };
        DatePickerUtil.getLocaleDateFormat = function (locale, displayFormat) {
            var formatKeys = Object.keys(i2.FormatWidth);
            var targetKey = formatKeys.find(function (k) { return k.toLowerCase() === (displayFormat === null || displayFormat === void 0 ? void 0 : displayFormat.toLowerCase().replace('date', '')); });
            if (!targetKey) {
                // if displayFormat is not shortDate, longDate, etc.
                // or if it is not set by the user
                return displayFormat;
            }
            var format;
            try {
                format = i2.getLocaleDateFormat(locale, i2.FormatWidth[targetKey]);
            }
            catch (_a) {
                DatePickerUtil.logMissingLocaleSettings(locale);
                format = DatePickerUtil.getDefaultInputFormat(locale);
            }
            return format;
        };
        DatePickerUtil.isDateOrTimeChar = function (char) {
            return DATE_CHARS.indexOf(char) !== -1 || TIME_CHARS.indexOf(char) !== -1;
        };
        DatePickerUtil.spinDate = function (delta, newDate, isSpinLoop) {
            var maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth());
            var date = newDate.getDate() + delta;
            if (date > maxDate) {
                date = isSpinLoop ? date % maxDate : maxDate;
            }
            else if (date < 1) {
                date = isSpinLoop ? maxDate + (date % maxDate) : 1;
            }
            newDate.setDate(date);
        };
        DatePickerUtil.spinMonth = function (delta, newDate, isSpinLoop) {
            var maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth() + delta);
            if (newDate.getDate() > maxDate) {
                newDate.setDate(maxDate);
            }
            var maxMonth = 11;
            var minMonth = 0;
            var month = newDate.getMonth() + delta;
            if (month > maxMonth) {
                month = isSpinLoop ? (month % maxMonth) - 1 : maxMonth;
            }
            else if (month < minMonth) {
                month = isSpinLoop ? maxMonth + (month % maxMonth) + 1 : minMonth;
            }
            newDate.setMonth(month);
        };
        DatePickerUtil.spinYear = function (delta, newDate) {
            var maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear() + delta, newDate.getMonth());
            if (newDate.getDate() > maxDate) {
                // clip to max to avoid leap year change shifting the entire value
                newDate.setDate(maxDate);
            }
            newDate.setFullYear(newDate.getFullYear() + delta);
        };
        DatePickerUtil.spinHours = function (delta, newDate, isSpinLoop) {
            var maxHour = 23;
            var minHour = 0;
            var hours = newDate.getHours() + delta;
            if (hours > maxHour) {
                hours = isSpinLoop ? hours % maxHour - 1 : maxHour;
            }
            else if (hours < minHour) {
                hours = isSpinLoop ? maxHour + (hours % maxHour) + 1 : minHour;
            }
            newDate.setHours(hours);
        };
        DatePickerUtil.spinMinutes = function (delta, newDate, isSpinLoop) {
            var maxMinutes = 59;
            var minMinutes = 0;
            var minutes = newDate.getMinutes() + delta;
            if (minutes > maxMinutes) {
                minutes = isSpinLoop ? minutes % maxMinutes - 1 : maxMinutes;
            }
            else if (minutes < minMinutes) {
                minutes = isSpinLoop ? maxMinutes + (minutes % maxMinutes) + 1 : minMinutes;
            }
            newDate.setMinutes(minutes);
        };
        DatePickerUtil.spinSeconds = function (delta, newDate, isSpinLoop) {
            var maxSeconds = 59;
            var minSeconds = 0;
            var seconds = newDate.getSeconds() + delta;
            if (seconds > maxSeconds) {
                seconds = isSpinLoop ? seconds % maxSeconds - 1 : maxSeconds;
            }
            else if (seconds < minSeconds) {
                seconds = isSpinLoop ? maxSeconds + (seconds % maxSeconds) + 1 : minSeconds;
            }
            newDate.setSeconds(seconds);
        };
        DatePickerUtil.spinAmPm = function (newDate, currentDate, amPmFromMask) {
            switch (amPmFromMask) {
                case 'AM':
                    newDate = new Date(newDate.setHours(newDate.getHours() + 12));
                    break;
                case 'PM':
                    newDate = new Date(newDate.setHours(newDate.getHours() - 12));
                    break;
            }
            if (newDate.getDate() !== currentDate.getDate()) {
                return currentDate;
            }
            return newDate;
        };
        /**
         * Determines whether the provided value is greater than the provided max value.
         *
         * @param includeTime set to false if you want to exclude time portion of the two dates
         * @param includeDate set to false if you want to exclude the date portion of the two dates
         * @returns true if provided value is greater than provided maxValue
         */
        DatePickerUtil.greaterThanMaxValue = function (value, maxValue, includeTime, includeDate) {
            if (includeTime === void 0) { includeTime = true; }
            if (includeDate === void 0) { includeDate = true; }
            // TODO: check if provided dates are valid dates and not Invalid Date
            // if maxValue is Invalid Date and value is valid date this will return:
            // - false if includeDate is true
            // - true if includeDate is false
            if (includeTime && includeDate) {
                return value.getTime() > maxValue.getTime();
            }
            var _value = new Date(value.getTime());
            var _maxValue = new Date(maxValue.getTime());
            if (!includeTime) {
                _value.setHours(0, 0, 0, 0);
                _maxValue.setHours(0, 0, 0, 0);
            }
            if (!includeDate) {
                _value.setFullYear(0, 0, 0);
                _maxValue.setFullYear(0, 0, 0);
            }
            return _value.getTime() > _maxValue.getTime();
        };
        /**
         * Determines whether the provided value is less than the provided min value.
         *
         * @param includeTime set to false if you want to exclude time portion of the two dates
         * @param includeDate set to false if you want to exclude the date portion of the two dates
         * @returns true if provided value is less than provided minValue
         */
        DatePickerUtil.lessThanMinValue = function (value, minValue, includeTime, includeDate) {
            if (includeTime === void 0) { includeTime = true; }
            if (includeDate === void 0) { includeDate = true; }
            // TODO: check if provided dates are valid dates and not Invalid Date
            // if value is Invalid Date and minValue is valid date this will return:
            // - false if includeDate is true
            // - true if includeDate is false
            if (includeTime && includeDate) {
                return value.getTime() < minValue.getTime();
            }
            var _value = new Date(value.getTime());
            var _minValue = new Date(minValue.getTime());
            if (!includeTime) {
                _value.setHours(0, 0, 0, 0);
                _minValue.setHours(0, 0, 0, 0);
            }
            if (!includeDate) {
                _value.setFullYear(0, 0, 0);
                _minValue.setFullYear(0, 0, 0);
            }
            return _value.getTime() < _minValue.getTime();
        };
        /**
         * This method generates date parts structure based on editor mask and locale.
         *
         * @param maskValue: string
         * @param locale: string
         * @returns array containing information about date parts - type, position, format
         */
        DatePickerUtil.parseDateFormat = function (maskValue, locale) {
            if (locale === void 0) { locale = DatePickerUtil.DEFAULT_LOCALE; }
            var dateStruct = [];
            if (maskValue === undefined && !isIE()) {
                dateStruct = DatePickerUtil.getDefaultLocaleMask(locale);
            }
            else {
                var mask = (maskValue) ? maskValue : DatePickerUtil.SHORT_DATE_MASK;
                var maskArray = Array.from(mask);
                var monthInitPosition = mask.indexOf("M" /* MonthChar */);
                var dayInitPosition = mask.indexOf("d" /* DayChar */);
                var yearInitPosition = mask.indexOf("y" /* YearChar */);
                if (yearInitPosition !== -1) {
                    dateStruct.push({
                        type: "year" /* Year */,
                        initialPosition: yearInitPosition,
                        formatType: DatePickerUtil.getYearFormatType(mask)
                    });
                }
                if (monthInitPosition !== -1) {
                    dateStruct.push({
                        type: "month" /* Month */,
                        initialPosition: monthInitPosition,
                        formatType: DatePickerUtil.getMonthFormatType(mask)
                    });
                }
                if (dayInitPosition !== -1) {
                    dateStruct.push({
                        type: "day" /* Day */,
                        initialPosition: dayInitPosition,
                        formatType: DatePickerUtil.getDayFormatType(mask)
                    });
                }
                for (var i = 0; i < maskArray.length; i++) {
                    if (!DatePickerUtil.isDateChar(maskArray[i])) {
                        dateStruct.push({
                            type: DatePickerUtil.SEPARATOR,
                            initialPosition: i,
                            value: maskArray[i]
                        });
                    }
                }
                dateStruct.sort(function (a, b) { return a.initialPosition - b.initialPosition; });
                DatePickerUtil.fillDatePartsPositions(dateStruct);
            }
            return dateStruct;
        };
        /**
         * This method generates input mask based on date parts.
         *
         * @param dateStruct array
         * @returns input mask
         */
        DatePickerUtil.getInputMask = function (dateStruct) {
            var e_1, _b;
            var inputMask = [];
            try {
                for (var dateStruct_1 = __values(dateStruct), dateStruct_1_1 = dateStruct_1.next(); !dateStruct_1_1.done; dateStruct_1_1 = dateStruct_1.next()) {
                    var part = dateStruct_1_1.value;
                    if (part.type === DatePickerUtil.SEPARATOR) {
                        inputMask.push(part.value);
                    }
                    else if (part.type === "day" /* Day */ || part.type === "month" /* Month */) {
                        inputMask.push('00');
                    }
                    else if (part.type === "year" /* Year */) {
                        switch (part.formatType) {
                            case "numeric" /* Numeric */: {
                                inputMask.push('0000');
                                break;
                            }
                            case "2-digit" /* TwoDigits */: {
                                inputMask.push('00');
                                break;
                            }
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (dateStruct_1_1 && !dateStruct_1_1.done && (_b = dateStruct_1.return)) _b.call(dateStruct_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return inputMask.join('');
        };
        /**
         * This method generates editor mask.
         *
         * @param dateStruct
         * @returns editor mask
         */
        DatePickerUtil.getMask = function (dateStruct) {
            var e_2, _b;
            var mask = [];
            try {
                for (var dateStruct_2 = __values(dateStruct), dateStruct_2_1 = dateStruct_2.next(); !dateStruct_2_1.done; dateStruct_2_1 = dateStruct_2.next()) {
                    var part = dateStruct_2_1.value;
                    switch (part.formatType) {
                        case "numeric" /* Numeric */: {
                            if (part.type === "day" /* Day */) {
                                mask.push('d');
                            }
                            else if (part.type === "month" /* Month */) {
                                mask.push('M');
                            }
                            else {
                                mask.push('yyyy');
                            }
                            break;
                        }
                        case "2-digit" /* TwoDigits */: {
                            if (part.type === "day" /* Day */) {
                                mask.push('dd');
                            }
                            else if (part.type === "month" /* Month */) {
                                mask.push('MM');
                            }
                            else {
                                mask.push('yy');
                            }
                        }
                    }
                    if (part.type === DatePickerUtil.SEPARATOR) {
                        mask.push(part.value);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (dateStruct_2_1 && !dateStruct_2_1.done && (_b = dateStruct_2.return)) _b.call(dateStruct_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return mask.join('');
        };
        /**
         * This method parses an input string base on date parts and returns a date and its validation state.
         *
         * @param dateFormatParts
         * @param prevDateValue
         * @param inputValue
         * @returns object containing a date and its validation state
         */
        DatePickerUtil.parseDateArray = function (dateFormatParts, prevDateValue, inputValue) {
            var dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, inputValue);
            var monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue);
            var yearStr = DatePickerUtil.getYearValueFromInput(dateFormatParts, inputValue);
            var yearFormat = DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType;
            var day = (dayStr !== '') ? parseInt(dayStr, 10) : 1;
            var month = (monthStr !== '') ? parseInt(monthStr, 10) - 1 : 0;
            var year;
            if (yearStr === '') {
                year = (yearFormat === "2-digit" /* TwoDigits */) ? '00' : '2000';
            }
            else {
                year = yearStr;
            }
            var yearPrefix;
            if (prevDateValue) {
                var originalYear = prevDateValue.getFullYear().toString();
                if (originalYear.length === 4) {
                    yearPrefix = originalYear.substring(0, 2);
                }
            }
            else {
                yearPrefix = '20';
            }
            var fullYear = (yearFormat === "2-digit" /* TwoDigits */) ? yearPrefix.concat(year) : year;
            if ((month < 0) || (month > 11) || isNaN(month)) {
                return { state: "invalid" /* Invalid */, value: inputValue };
            }
            if ((day < 1) || (day > DatePickerUtil.daysInMonth(fullYear, month)) || isNaN(day)) {
                return { state: "invalid" /* Invalid */, value: inputValue };
            }
            return { state: "valid" /* Valid */, date: new Date(fullYear, month, day) };
        };
        DatePickerUtil.maskToPromptChars = function (mask) {
            var result = mask.replace(/0|L/g, DatePickerUtil.PROMPT_CHAR);
            return result;
        };
        /**
         * This method replaces prompt chars with empty string.
         *
         * @param value
         */
        DatePickerUtil.trimEmptyPlaceholders = function (value, promptChar) {
            var result = value.replace(new RegExp(promptChar || '_', 'g'), '');
            return result;
        };
        /**
         * This method is used for spinning date parts.
         *
         * @param dateFormatParts
         * @param inputValue
         * @param position
         * @param delta
         * @param isSpinLoop
         * @return modified text input
         */
        DatePickerUtil.getModifiedDateInput = function (dateFormatParts, inputValue, position, delta, isSpinLoop) {
            var datePart = DatePickerUtil.getDatePartOnPosition(dateFormatParts, position);
            var datePartType = datePart.type;
            var datePartFormatType = datePart.formatType;
            var newValue;
            var datePartValue = DatePickerUtil.getDateValueFromInput(dateFormatParts, datePartType, inputValue);
            newValue = parseInt(datePartValue, 10);
            var minMax = DatePickerUtil.getMinMaxValue(dateFormatParts, datePart, inputValue);
            var minValue = minMax.min;
            var maxValue = minMax.max;
            if (isNaN(newValue)) {
                if (minValue === 'infinite') {
                    newValue = 2000;
                }
                else {
                    newValue = minValue;
                }
            }
            var tempValue = newValue;
            tempValue += delta;
            // Infinite loop for full years
            if (maxValue === 'infinite' && minValue === 'infinite') {
                newValue = tempValue;
            }
            if (isSpinLoop) {
                if (tempValue > maxValue) {
                    tempValue = minValue;
                }
                if (tempValue < minValue) {
                    tempValue = maxValue;
                }
                newValue = tempValue;
            }
            else {
                if (tempValue <= maxValue && tempValue >= minValue) {
                    newValue = tempValue;
                }
            }
            var startIdx = datePart.position[0];
            var endIdx = datePart.position[1];
            var start = inputValue.slice(0, startIdx);
            var end = inputValue.slice(endIdx, inputValue.length);
            var prefix = DatePickerUtil.getNumericFormatPrefix(datePartFormatType);
            var changedPart = (newValue < 10) ? "" + prefix + newValue : "" + newValue;
            return "" + start + changedPart + end;
        };
        /**
         * This method returns date input with prompt chars.
         *
         * @param dateFormatParts
         * @param date
         * @param inputValue
         * @returns date input including prompt chars
         */
        DatePickerUtil.addPromptCharsEditMode = function (dateFormatParts, date, inputValue) {
            var e_3, _b;
            var dateArray = Array.from(inputValue);
            try {
                for (var dateFormatParts_1 = __values(dateFormatParts), dateFormatParts_1_1 = dateFormatParts_1.next(); !dateFormatParts_1_1.done; dateFormatParts_1_1 = dateFormatParts_1.next()) {
                    var part = dateFormatParts_1_1.value;
                    if (part.formatType === "numeric" /* Numeric */) {
                        if ((part.type === "day" /* Day */ && date.getDate() < 10)
                            || (part.type === "month" /* Month */ && date.getMonth() + 1 < 10)) {
                            dateArray.splice(part.position[0], 0, DatePickerUtil.PROMPT_CHAR);
                            dateArray.join('');
                        }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (dateFormatParts_1_1 && !dateFormatParts_1_1.done && (_b = dateFormatParts_1.return)) _b.call(dateFormatParts_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return dateArray.join('');
        };
        /**
         * This method checks if date input is done.
         *
         * @param dateFormatParts
         * @param input
         * @returns input completeness
         */
        DatePickerUtil.checkForCompleteDateInput = function (dateFormatParts, input) {
            var dayValue = DatePickerUtil.getDayValueFromInput(dateFormatParts, input);
            var monthValue = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input);
            var yearValue = DatePickerUtil.getYearValueFromInput(dateFormatParts, input);
            var dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, input, false);
            var monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input, false);
            if (DatePickerUtil.isFullInput(dayValue, dayStr)
                && DatePickerUtil.isFullInput(monthValue, monthStr)
                && DatePickerUtil.isFullYearInput(dateFormatParts, yearValue)) {
                return 'complete';
            }
            else if (dayValue === '' && monthValue === '' && yearValue === '') {
                return 'empty';
            }
            else if (dayValue === '' || monthValue === '' || yearValue === '') {
                return 'partial';
            }
            return '';
        };
        DatePickerUtil.daysInMonth = function (fullYear, month) {
            return new Date(fullYear, month + 1, 0).getDate();
        };
        /**
         * Parse provided input to Date.
         *
         * @param value input to parse
         * @returns Date if parse succeed or null
         */
        DatePickerUtil.parseDate = function (value) {
            if (typeof value === 'number') {
                return new Date(value);
            }
            // if value is Invalid Date we should return null
            if (DatePickerUtil.isDate(value)) {
                return DatePickerUtil.isValidDate(value) ? value : null;
            }
            return value ? new Date(Date.parse(value)) : null;
        };
        /**
         * Returns whether provided input is date
         *
         * @param value input to check
         * @returns true if provided input is date
         */
        DatePickerUtil.isDate = function (value) {
            return Object.prototype.toString.call(value) === '[object Date]';
        };
        /**
         * Returns whether the input is valid date
         *
         * @param value input to check
         * @returns true if provided input is a valid date
         */
        DatePickerUtil.isValidDate = function (value) {
            if (DatePickerUtil.isDate(value)) {
                return !isNaN(value.getTime());
            }
            return false;
        };
        DatePickerUtil.logMissingLocaleSettings = function (locale) {
            console.warn("Missing locale data for the locale " + locale + ". Please refer to https://angular.io/guide/i18n#i18n-pipes");
            console.warn('Using default browser locale settings.');
        };
        DatePickerUtil.ensureLeadingZero = function (part) {
            switch (part.type) {
                case exports.DatePart.Date:
                case exports.DatePart.Month:
                case exports.DatePart.Hours:
                case exports.DatePart.Minutes:
                case exports.DatePart.Seconds:
                    if (part.format.length === 1) {
                        part.format = part.format.repeat(2);
                    }
                    break;
            }
        };
        DatePickerUtil.getCleanVal = function (inputData, datePart, promptChar) {
            return DatePickerUtil.trimEmptyPlaceholders(inputData.substring(datePart.start, datePart.end), promptChar);
        };
        DatePickerUtil.determineDatePart = function (char) {
            switch (char) {
                case 'd':
                case 'D':
                    return exports.DatePart.Date;
                case 'M':
                    return exports.DatePart.Month;
                case 'y':
                case 'Y':
                    return exports.DatePart.Year;
                case 'h':
                case 'H':
                    return exports.DatePart.Hours;
                case 'm':
                    return exports.DatePart.Minutes;
                case 's':
                case 'S':
                    return exports.DatePart.Seconds;
                case 't':
                case 'T':
                    return exports.DatePart.AmPm;
                default:
                    return exports.DatePart.Literal;
            }
        };
        DatePickerUtil.getYearFormatType = function (format) {
            switch (format.match(new RegExp("y" /* YearChar */, 'g')).length) {
                case 1: {
                    // y (2020)
                    return "numeric" /* Numeric */;
                }
                case 4: {
                    // yyyy (2020)
                    return "numeric" /* Numeric */;
                }
                case 2: {
                    // yy (20)
                    return "2-digit" /* TwoDigits */;
                }
            }
        };
        DatePickerUtil.getMonthFormatType = function (format) {
            switch (format.match(new RegExp("M" /* MonthChar */, 'g')).length) {
                case 1: {
                    // M (8)
                    return "numeric" /* Numeric */;
                }
                case 2: {
                    // MM (08)
                    return "2-digit" /* TwoDigits */;
                }
            }
        };
        DatePickerUtil.getDayFormatType = function (format) {
            switch (format.match(new RegExp("d" /* DayChar */, 'g')).length) {
                case 1: {
                    // d (6)
                    return "numeric" /* Numeric */;
                }
                case 2: {
                    // dd (06)
                    return "2-digit" /* TwoDigits */;
                }
            }
        };
        DatePickerUtil.getDefaultLocaleMask = function (locale) {
            var e_4, _b, e_5, _c;
            var dateStruct = [];
            var formatter = new Intl.DateTimeFormat(locale);
            var formatToParts = formatter.formatToParts(new Date());
            try {
                for (var formatToParts_1 = __values(formatToParts), formatToParts_1_1 = formatToParts_1.next(); !formatToParts_1_1.done; formatToParts_1_1 = formatToParts_1.next()) {
                    var part = formatToParts_1_1.value;
                    if (part.type === DatePickerUtil.SEPARATOR) {
                        dateStruct.push({
                            type: DatePickerUtil.SEPARATOR,
                            value: part.value
                        });
                    }
                    else {
                        dateStruct.push({
                            type: part.type
                        });
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (formatToParts_1_1 && !formatToParts_1_1.done && (_b = formatToParts_1.return)) _b.call(formatToParts_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
            var formatterOptions = formatter.resolvedOptions();
            try {
                for (var dateStruct_3 = __values(dateStruct), dateStruct_3_1 = dateStruct_3.next(); !dateStruct_3_1.done; dateStruct_3_1 = dateStruct_3.next()) {
                    var part = dateStruct_3_1.value;
                    switch (part.type) {
                        case "day" /* Day */: {
                            part.formatType = formatterOptions.day;
                            break;
                        }
                        case "month" /* Month */: {
                            part.formatType = formatterOptions.month;
                            break;
                        }
                        case "year" /* Year */: {
                            part.formatType = formatterOptions.year;
                            break;
                        }
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (dateStruct_3_1 && !dateStruct_3_1.done && (_c = dateStruct_3.return)) _c.call(dateStruct_3);
                }
                finally { if (e_5) throw e_5.error; }
            }
            DatePickerUtil.fillDatePartsPositions(dateStruct);
            return dateStruct;
        };
        DatePickerUtil.isDateChar = function (char) {
            return (char === "y" /* YearChar */ || char === "M" /* MonthChar */ || char === "d" /* DayChar */);
        };
        DatePickerUtil.getNumericFormatPrefix = function (formatType) {
            switch (formatType) {
                case "2-digit" /* TwoDigits */: {
                    return '0';
                }
                case "numeric" /* Numeric */: {
                    return DatePickerUtil.PROMPT_CHAR;
                }
            }
        };
        DatePickerUtil.getMinMaxValue = function (dateFormatParts, datePart, inputValue) {
            var maxValue;
            var minValue;
            switch (datePart.type) {
                case "month" /* Month */: {
                    minValue = 1;
                    maxValue = DatePickerUtil.NUMBER_OF_MONTHS;
                    break;
                }
                case "day" /* Day */: {
                    minValue = 1;
                    maxValue = DatePickerUtil.daysInMonth(DatePickerUtil.getFullYearFromString(DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */), inputValue), parseInt(DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue), 10));
                    break;
                }
                case "year" /* Year */: {
                    if (datePart.formatType === "2-digit" /* TwoDigits */) {
                        minValue = 0;
                        maxValue = 99;
                    }
                    else {
                        // Infinite loop
                        minValue = 'infinite';
                        maxValue = 'infinite';
                    }
                    break;
                }
            }
            return { min: minValue, max: maxValue };
        };
        DatePickerUtil.getDateValueFromInput = function (dateFormatParts, type, inputValue, trim) {
            if (trim === void 0) { trim = true; }
            var partPosition = DatePickerUtil.getDateFormatPart(dateFormatParts, type).position;
            var result = inputValue.substring(partPosition[0], partPosition[1]);
            return (trim) ? DatePickerUtil.trimEmptyPlaceholders(result) : result;
        };
        DatePickerUtil.getDayValueFromInput = function (dateFormatParts, inputValue, trim) {
            if (trim === void 0) { trim = true; }
            return DatePickerUtil.getDateValueFromInput(dateFormatParts, "day" /* Day */, inputValue, trim);
        };
        DatePickerUtil.getMonthValueFromInput = function (dateFormatParts, inputValue, trim) {
            if (trim === void 0) { trim = true; }
            return DatePickerUtil.getDateValueFromInput(dateFormatParts, "month" /* Month */, inputValue, trim);
        };
        DatePickerUtil.getYearValueFromInput = function (dateFormatParts, inputValue, trim) {
            if (trim === void 0) { trim = true; }
            return DatePickerUtil.getDateValueFromInput(dateFormatParts, "year" /* Year */, inputValue, trim);
        };
        DatePickerUtil.getDateFormatPart = function (dateFormatParts, type) {
            var result = dateFormatParts.filter(function (datePart) { return (datePart.type === type); })[0];
            return result;
        };
        DatePickerUtil.isFullInput = function (value, input) {
            return (value !== '' && input.length === 2 && input.charAt(1) !== DatePickerUtil.PROMPT_CHAR);
        };
        DatePickerUtil.isFullYearInput = function (dateFormatParts, value) {
            switch (DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType) {
                case "numeric" /* Numeric */: {
                    return (value !== '' && value.length === 4);
                }
                case "2-digit" /* TwoDigits */: {
                    return (value !== '' && value.length === 2);
                }
                default: {
                    return false;
                }
            }
        };
        DatePickerUtil.getDatePartOnPosition = function (dateFormatParts, position) {
            var result = dateFormatParts.filter(function (element) { return element.position[0] <= position && position <= element.position[1] && element.type !== DatePickerUtil.SEPARATOR; })[0];
            return result;
        };
        DatePickerUtil.getFullYearFromString = function (yearPart, inputValue) {
            return parseInt(inputValue.substring(yearPart.position[0], yearPart.position[1]), 10);
        };
        DatePickerUtil.fillDatePartsPositions = function (dateArray) {
            var e_6, _b;
            var currentPos = 0;
            try {
                for (var dateArray_1 = __values(dateArray), dateArray_1_1 = dateArray_1.next(); !dateArray_1_1.done; dateArray_1_1 = dateArray_1.next()) {
                    var part = dateArray_1_1.value;
                    // Day|Month part positions
                    if (part.type === "day" /* Day */ || part.type === "month" /* Month */) {
                        // Offset 2 positions for number
                        part.position = [currentPos, currentPos + 2];
                        currentPos += 2;
                    }
                    else if (part.type === "year" /* Year */) {
                        // Year part positions
                        switch (part.formatType) {
                            case "numeric" /* Numeric */: {
                                // Offset 4 positions for full year
                                part.position = [currentPos, currentPos + 4];
                                currentPos += 4;
                                break;
                            }
                            case "2-digit" /* TwoDigits */: {
                                // Offset 2 positions for short year
                                part.position = [currentPos, currentPos + 2];
                                currentPos += 2;
                                break;
                            }
                        }
                    }
                    else if (part.type === DatePickerUtil.SEPARATOR) {
                        // Separator positions
                        part.position = [currentPos, currentPos + 1];
                        currentPos++;
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (dateArray_1_1 && !dateArray_1_1.done && (_b = dateArray_1.return)) _b.call(dateArray_1);
                }
                finally { if (e_6) throw e_6.error; }
            }
        };
        return DatePickerUtil;
    }());
    DatePickerUtil.DEFAULT_INPUT_FORMAT = 'MM/dd/yyyy';
    // TODO: this is the def mask for the date-picker, should remove it during refactoring
    DatePickerUtil.SHORT_DATE_MASK = 'MM/dd/yy';
    DatePickerUtil.SEPARATOR = 'literal';
    DatePickerUtil.NUMBER_OF_MONTHS = 12;
    DatePickerUtil.PROMPT_CHAR = '_';
    DatePickerUtil.DEFAULT_LOCALE = 'en';

    /**
     * Date Time Editor provides a functionality to input, edit and format date and time.
     *
     * @igxModule IgxDateTimeEditorModule
     *
     * @igxParent IgxInputGroup
     *
     * @igxTheme igx-input-theme
     *
     * @igxKeywords date, time, editor
     *
     * @igxGroup Scheduling
     *
     * @remarks
     *
     * The Ignite UI Date Time Editor Directive makes it easy for developers to manipulate date/time user input.
     * It requires input in a specified or default input format which is visible in the input element as a placeholder.
     * It allows the input of only date (ex: 'dd/MM/yyyy'), only time (ex:'HH:mm tt') or both at once, if needed.
     * Supports display format that may differ from the input format.
     * Provides methods to increment and decrement any specific/targeted `DatePart`.
     *
     * @example
     * ```html
     * <igx-input-group>
     *   <input type="text" igxInput [igxDateTimeEditor]="'dd/MM/yyyy'" [displayFormat]="'shortDate'" [(ngModel)]="date"/>
     * </igx-input-group>
     * ```
     */
    var IgxDateTimeEditorDirective = /** @class */ (function (_super) {
        __extends(IgxDateTimeEditorDirective, _super);
        function IgxDateTimeEditorDirective(renderer, elementRef, maskParser, _document, _locale) {
            var _this = _super.call(this, elementRef, maskParser, renderer) || this;
            _this.renderer = renderer;
            _this.elementRef = elementRef;
            _this.maskParser = maskParser;
            _this._document = _document;
            _this._locale = _locale;
            /**
             * Specify if the currently spun date segment should loop over.
             *
             * @example
             * ```html
             * <input igxDateTimeEditor [isSpinLoop]="false">
             * ```
             */
            _this.isSpinLoop = true;
            /**
             * Emitted when the editor's value has changed.
             *
             * @example
             * ```html
             * <input igxDateTimeEditor (valueChange)="onValueChanged($event)"/>
             * ```
             */
            _this.valueChange = new i0.EventEmitter();
            /**
             * Emitted when the editor is not within a specified range or when the editor's value is in an invalid state.
             *
             * @example
             * ```html
             * <input igxDateTimeEditor [minValue]="minDate" [maxValue]="maxDate" (validationFailed)="onValidationFailed($event)"/>
             * ```
             */
            _this.validationFailed = new i0.EventEmitter();
            _this.onTouchCallback = rxjs.noop;
            _this.onChangeCallback = rxjs.noop;
            _this.onValidatorChange = rxjs.noop;
            _this.document = _this._document;
            _this.locale = _this.locale || _this._locale;
            return _this;
        }
        Object.defineProperty(IgxDateTimeEditorDirective.prototype, "minValue", {
            /**
             * Minimum value required for the editor to remain valid.
             *
             * @remarks
             * If a `string` value is passed, it must be in the defined input format.
             *
             * @example
             * ```html
             * <input igxDateTimeEditor [minValue]="minDate">
             * ```
             */
            get: function () {
                return this._minValue;
            },
            set: function (value) {
                this._minValue = value;
                this.onValidatorChange();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateTimeEditorDirective.prototype, "maxValue", {
            /**
             * Maximum value required for the editor to remain valid.
             *
             * @remarks
             * If a `string` value is passed in, it must be in the defined input format.
             *
             * @example
             * ```html
             * <input igxDateTimeEditor [maxValue]="maxDate">
             * ```
             */
            get: function () {
                return this._maxValue;
            },
            set: function (value) {
                this._maxValue = value;
                this.onValidatorChange();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateTimeEditorDirective.prototype, "inputFormat", {
            get: function () {
                return this._format;
            },
            /**
             * Expected user input format (and placeholder).
             *
             * @example
             * ```html
             * <input [igxDateTimeEditor]="'dd/MM/yyyy'">
             * ```
             */
            set: function (value) {
                if (value) {
                    this._format = value;
                }
                var mask = (this.inputFormat || DatePickerUtil.DEFAULT_INPUT_FORMAT)
                    .replace(new RegExp(/(?=[^t])[\w]/, 'g'), '0');
                this.mask = mask.indexOf('tt') !== -1 ? mask.replace(new RegExp('tt', 'g'), 'LL') : mask;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateTimeEditorDirective.prototype, "value", {
            get: function () {
                return this._value;
            },
            /**
             * Editor value.
             *
             * @example
             * ```html
             * <input igxDateTimeEditor [value]="date">
             * ```
             */
            set: function (value) {
                this._value = value;
                this.onChangeCallback(value);
                this.updateMask();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateTimeEditorDirective.prototype, "emptyMask", {
            get: function () {
                return this.maskParser.applyMask(null, this.maskOptions);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateTimeEditorDirective.prototype, "targetDatePart", {
            get: function () {
                var _this = this;
                var _a;
                if (this.document.activeElement === this.nativeElement) {
                    return (_a = this._inputDateParts
                        .find(function (p) { return p.start <= _this.selectionStart && _this.selectionStart <= p.end && p.type !== exports.DatePart.Literal; })) === null || _a === void 0 ? void 0 : _a.type;
                }
                else {
                    if (this._inputDateParts.some(function (p) { return p.type === exports.DatePart.Date; })) {
                        return exports.DatePart.Date;
                    }
                    else if (this._inputDateParts.some(function (p) { return p.type === exports.DatePart.Hours; })) {
                        return exports.DatePart.Hours;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateTimeEditorDirective.prototype, "hasDateParts", {
            get: function () {
                return this._inputDateParts.some(function (p) { return p.type === exports.DatePart.Date
                    || p.type === exports.DatePart.Month
                    || p.type === exports.DatePart.Year; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateTimeEditorDirective.prototype, "hasTimeParts", {
            get: function () {
                return this._inputDateParts.some(function (p) { return p.type === exports.DatePart.Hours
                    || p.type === exports.DatePart.Minutes
                    || p.type === exports.DatePart.Seconds; });
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden @internal */
        IgxDateTimeEditorDirective.prototype.ngOnChanges = function (changes) {
            if (changes['inputFormat'] || changes['locale']) {
                this.updateInputFormat();
            }
        };
        /** @hidden @internal */
        IgxDateTimeEditorDirective.prototype.ngDoCheck = function () {
            if (this._inputFormat !== this.inputFormat) {
                this.updateInputFormat();
            }
        };
        /** Clear the input element value. */
        IgxDateTimeEditorDirective.prototype.clear = function () {
            this.updateValue(null);
        };
        /**
         * Increment specified DatePart.
         *
         * @param datePart The optional DatePart to increment. Defaults to Date or Hours(when Date is absent from the inputFormat - ex:'HH:mm').
         */
        IgxDateTimeEditorDirective.prototype.increment = function (datePart) {
            var targetDatePart = this.targetDatePart;
            if (!targetDatePart) {
                return;
            }
            var newValue = datePart
                ? this.spinValue(datePart, 1)
                : this.spinValue(targetDatePart, 1);
            this.updateValue(newValue ? newValue : new Date());
        };
        /**
         * Decrement specified DatePart.
         *
         * @param datePart The optional DatePart to decrement. Defaults to Date or Hours(when Date is absent from the inputFormat - ex:'HH:mm').
         */
        IgxDateTimeEditorDirective.prototype.decrement = function (datePart) {
            var targetDatePart = this.targetDatePart;
            if (!targetDatePart) {
                return;
            }
            var newValue = datePart
                ? this.spinValue(datePart, -1)
                : this.spinValue(targetDatePart, -1);
            this.updateValue(newValue ? newValue : new Date());
        };
        /** @hidden @internal */
        IgxDateTimeEditorDirective.prototype.writeValue = function (value) {
            this._value = value;
            this.updateMask();
        };
        /** @hidden @internal */
        IgxDateTimeEditorDirective.prototype.validate = function (control) {
            if (!this.inputIsComplete() || !control.value) {
                return { value: true };
            }
            var maxValueAsDate = this.isDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);
            var minValueAsDate = this.isDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);
            if (minValueAsDate
                && DatePickerUtil.lessThanMinValue(control.value, minValueAsDate, this.hasTimeParts, this.hasDateParts)) {
                return { minValue: true };
            }
            if (maxValueAsDate
                && DatePickerUtil.greaterThanMaxValue(control.value, maxValueAsDate, this.hasTimeParts, this.hasDateParts)) {
                return { maxValue: true };
            }
            return null;
        };
        /** @hidden @internal */
        IgxDateTimeEditorDirective.prototype.registerOnValidatorChange = function (fn) {
            this.onValidatorChange = fn;
        };
        /** @hidden @internal */
        IgxDateTimeEditorDirective.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        /** @hidden @internal */
        IgxDateTimeEditorDirective.prototype.registerOnTouched = function (fn) {
            this.onTouchCallback = fn;
        };
        /** @hidden @internal */
        IgxDateTimeEditorDirective.prototype.setDisabledState = function (isDisabled) { };
        /** @hidden @internal */
        IgxDateTimeEditorDirective.prototype.onInputChanged = function () {
            var _a;
            _super.prototype.onInputChanged.call(this);
            if (this.inputIsComplete()) {
                var parsedDate = this.parseDate(this.inputValue);
                if (this.isValidDate(parsedDate)) {
                    this.updateValue(parsedDate);
                }
                else {
                    var oldValue = this.value && new Date(this.value.getTime());
                    var args = { oldValue: oldValue, newValue: parsedDate, userInput: this.inputValue };
                    this.validationFailed.emit(args);
                    if (((_a = args.newValue) === null || _a === void 0 ? void 0 : _a.getTime) && args.newValue.getTime() !== oldValue.getTime()) {
                        this.updateValue(args.newValue);
                    }
                    else {
                        this.updateValue(null);
                    }
                }
            }
            else {
                this.updateValue(null);
            }
        };
        /** @hidden @internal */
        IgxDateTimeEditorDirective.prototype.onKeyDown = function (event) {
            _super.prototype.onKeyDown.call(this, event);
            if (event.altKey) {
                return;
            }
            if (event.key === "ArrowUp" /* UP_ARROW */ || event.key === "Up" /* UP_ARROW_IE */ ||
                event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */) {
                this.spin(event);
                return;
            }
            if (event.ctrlKey && event.key === ";" /* SEMICOLON */) {
                this.updateValue(new Date());
            }
            this.moveCursor(event);
        };
        /** @hidden @internal */
        IgxDateTimeEditorDirective.prototype.onFocus = function () {
            this._isFocused = true;
            this.onTouchCallback();
            this.updateMask();
            _super.prototype.onFocus.call(this);
        };
        /** @hidden @internal */
        IgxDateTimeEditorDirective.prototype.onBlur = function (value) {
            this._isFocused = false;
            if (!this.inputIsComplete() && this.inputValue !== this.emptyMask) {
                this.updateValue(this.parseDate(this.inputValue));
            }
            else {
                this.updateMask();
            }
            _super.prototype.onBlur.call(this, value);
        };
        /** @hidden @internal */
        IgxDateTimeEditorDirective.prototype.updateMask = function () {
            if (this._isFocused) {
                if (!this.value) {
                    return;
                }
                // store the cursor position as it will be moved during masking
                var cursor = this.selectionEnd;
                this.inputValue = this.getMaskedValue();
                this.setSelectionRange(cursor);
            }
            else {
                if (!this.value || !this.isValidDate(this.value)) {
                    this.inputValue = '';
                    return;
                }
                var format = this.displayFormat || this.inputFormat;
                if (format) {
                    this.inputValue = DatePickerUtil.formatDate(this.value, format.replace('tt', 'aa'), this.locale);
                }
                else {
                    // TODO: formatter function?
                    this.inputValue = this.value.toLocaleString();
                }
            }
        };
        // TODO: move parseDate to utils
        IgxDateTimeEditorDirective.prototype.parseDate = function (val) {
            if (!val) {
                return null;
            }
            return DatePickerUtil.parseValueFromMask(val, this._inputDateParts, this.promptChar);
        };
        IgxDateTimeEditorDirective.prototype.getMaskedValue = function () {
            var e_1, _b;
            var mask = this.emptyMask;
            try {
                for (var _c = __values(this._inputDateParts), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var part = _d.value;
                    if (part.type === exports.DatePart.Literal) {
                        continue;
                    }
                    var targetValue = this.getPartValue(part, part.format.length);
                    mask = this.maskParser.replaceInMask(mask, targetValue, this.maskOptions, part.start, part.end).value;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return mask;
        };
        IgxDateTimeEditorDirective.prototype.updateInputFormat = function () {
            var defPlaceholder = this.inputFormat || DatePickerUtil.getDefaultInputFormat(this.locale);
            this._inputDateParts = DatePickerUtil.parseDateTimeFormat(this.inputFormat);
            this.inputFormat = this._inputDateParts.map(function (p) { return p.format; }).join('');
            if (!this.nativeElement.placeholder || this._inputFormat !== this.inputFormat) {
                this.renderer.setAttribute(this.nativeElement, 'placeholder', defPlaceholder);
            }
            // TODO: fill in partial dates?
            this.updateMask();
            this._inputFormat = this.inputFormat;
        };
        // TODO: move isDate to utils
        IgxDateTimeEditorDirective.prototype.isDate = function (value) {
            return value instanceof Date && typeof value === 'object';
        };
        IgxDateTimeEditorDirective.prototype.valueInRange = function (value) {
            if (!value) {
                return false;
            }
            var maxValueAsDate = this.isDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);
            var minValueAsDate = this.isDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);
            if (minValueAsDate
                && DatePickerUtil.lessThanMinValue(value, minValueAsDate, this.hasTimeParts, this.hasDateParts)) {
                return false;
            }
            if (maxValueAsDate
                && DatePickerUtil.greaterThanMaxValue(value, maxValueAsDate, this.hasTimeParts, this.hasDateParts)) {
                return false;
            }
            return true;
        };
        IgxDateTimeEditorDirective.prototype.spinValue = function (datePart, delta) {
            if (!this.value || !this.isValidDate(this.value)) {
                return null;
            }
            var newDate = new Date(this.value.getTime());
            switch (datePart) {
                case exports.DatePart.Date:
                    DatePickerUtil.spinDate(delta, newDate, this.isSpinLoop);
                    break;
                case exports.DatePart.Month:
                    DatePickerUtil.spinMonth(delta, newDate, this.isSpinLoop);
                    break;
                case exports.DatePart.Year:
                    DatePickerUtil.spinYear(delta, newDate);
                    break;
                case exports.DatePart.Hours:
                    DatePickerUtil.spinHours(delta, newDate, this.isSpinLoop);
                    break;
                case exports.DatePart.Minutes:
                    DatePickerUtil.spinMinutes(delta, newDate, this.isSpinLoop);
                    break;
                case exports.DatePart.Seconds:
                    DatePickerUtil.spinSeconds(delta, newDate, this.isSpinLoop);
                    break;
                case exports.DatePart.AmPm:
                    var formatPart = this._inputDateParts.find(function (dp) { return dp.type === exports.DatePart.AmPm; });
                    var amPmFromMask = this.inputValue.substring(formatPart.start, formatPart.end);
                    return DatePickerUtil.spinAmPm(newDate, this.value, amPmFromMask);
            }
            return newDate;
        };
        IgxDateTimeEditorDirective.prototype.updateValue = function (newDate) {
            this._oldValue = this.value;
            this.value = newDate;
            if (this.value && !this.valueInRange(this.value)) {
                this.validationFailed.emit({ oldValue: this._oldValue, newValue: this.value, userInput: this.inputValue });
            }
            if (this.inputIsComplete() || this.inputValue === this.emptyMask) {
                this.valueChange.emit(this.value);
            }
        };
        IgxDateTimeEditorDirective.prototype.toTwelveHourFormat = function (value) {
            var hour = parseInt(value.replace(new RegExp(this.promptChar, 'g'), '0'), 10);
            if (hour > 12) {
                hour -= 12;
            }
            else if (hour === 0) {
                hour = 12;
            }
            return hour;
        };
        IgxDateTimeEditorDirective.prototype.getPartValue = function (datePartInfo, partLength) {
            var maskedValue;
            var datePart = datePartInfo.type;
            switch (datePart) {
                case exports.DatePart.Date:
                    maskedValue = this.value.getDate();
                    break;
                case exports.DatePart.Month:
                    // months are zero based
                    maskedValue = this.value.getMonth() + 1;
                    break;
                case exports.DatePart.Year:
                    if (partLength === 2) {
                        maskedValue = this.prependValue(parseInt(this.value.getFullYear().toString().slice(-2), 10), partLength, '0');
                    }
                    else {
                        maskedValue = this.value.getFullYear();
                    }
                    break;
                case exports.DatePart.Hours:
                    if (datePartInfo.format.indexOf('h') !== -1) {
                        maskedValue = this.prependValue(this.toTwelveHourFormat(this.value.getHours().toString()), partLength, '0');
                    }
                    else {
                        maskedValue = this.value.getHours();
                    }
                    break;
                case exports.DatePart.Minutes:
                    maskedValue = this.value.getMinutes();
                    break;
                case exports.DatePart.Seconds:
                    maskedValue = this.value.getSeconds();
                    break;
                case exports.DatePart.AmPm:
                    maskedValue = this.value.getHours() >= 12 ? 'PM' : 'AM';
                    break;
            }
            if (datePartInfo.type !== exports.DatePart.AmPm) {
                return this.prependValue(maskedValue, partLength, '0');
            }
            return maskedValue;
        };
        IgxDateTimeEditorDirective.prototype.prependValue = function (value, partLength, prependChar) {
            return (prependChar + value.toString()).slice(-partLength);
        };
        IgxDateTimeEditorDirective.prototype.spin = function (event) {
            event.preventDefault();
            switch (event.key) {
                case "ArrowUp" /* UP_ARROW */:
                case "Up" /* UP_ARROW_IE */:
                    this.increment();
                    break;
                case "ArrowDown" /* DOWN_ARROW */:
                case "Down" /* DOWN_ARROW_IE */:
                    this.decrement();
                    break;
            }
        };
        IgxDateTimeEditorDirective.prototype.inputIsComplete = function () {
            return this.inputValue.indexOf(this.promptChar) === -1;
        };
        IgxDateTimeEditorDirective.prototype.isValidDate = function (date) {
            return date && date.getTime && !isNaN(date.getTime());
        };
        IgxDateTimeEditorDirective.prototype.moveCursor = function (event) {
            var value = event.target.value;
            switch (event.key) {
                case "ArrowLeft" /* LEFT_ARROW */:
                case "Left" /* LEFT_ARROW_IE */:
                    if (event.ctrlKey) {
                        event.preventDefault();
                        this.setSelectionRange(this.getNewPosition(value));
                    }
                    break;
                case "ArrowRight" /* RIGHT_ARROW */:
                case "Right" /* RIGHT_ARROW_IE */:
                    if (event.ctrlKey) {
                        event.preventDefault();
                        this.setSelectionRange(this.getNewPosition(value, 1));
                    }
                    break;
            }
        };
        /**
         * Move the cursor in a specific direction until it reaches a date/time separator.
         * Then return its index.
         *
         * @param value The string it operates on.
         * @param direction 0 is left, 1 is right. Default is 0.
         */
        IgxDateTimeEditorDirective.prototype.getNewPosition = function (value, direction) {
            if (direction === void 0) { direction = 0; }
            var literals = this._inputDateParts.filter(function (p) { return p.type === exports.DatePart.Literal; });
            var cursorPos = this.selectionStart;
            if (!direction) {
                do {
                    cursorPos = cursorPos > 0 ? --cursorPos : cursorPos;
                } while (!literals.some(function (l) { return l.end === cursorPos; }) && cursorPos > 0);
                return cursorPos;
            }
            else {
                do {
                    cursorPos++;
                } while (!literals.some(function (l) { return l.start === cursorPos; }) && cursorPos < value.length);
                return cursorPos;
            }
        };
        return IgxDateTimeEditorDirective;
    }(IgxMaskDirective));
    IgxDateTimeEditorDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDateTimeEditor]',
                    exportAs: 'igxDateTimeEditor',
                    providers: [
                        { provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxDateTimeEditorDirective, multi: true },
                        { provide: forms.NG_VALIDATORS, useExisting: IgxDateTimeEditorDirective, multi: true }
                    ]
                },] }
    ];
    IgxDateTimeEditorDirective.ctorParameters = function () { return [
        { type: i0.Renderer2 },
        { type: i0.ElementRef },
        { type: MaskParsingService },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i0.LOCALE_ID,] }] }
    ]; };
    IgxDateTimeEditorDirective.propDecorators = {
        locale: [{ type: i0.Input }],
        minValue: [{ type: i0.Input }],
        maxValue: [{ type: i0.Input }],
        isSpinLoop: [{ type: i0.Input }],
        displayFormat: [{ type: i0.Input }],
        inputFormat: [{ type: i0.Input, args: ["igxDateTimeEditor",] }],
        value: [{ type: i0.Input }],
        valueChange: [{ type: i0.Output }],
        validationFailed: [{ type: i0.Output }]
    };
    var IgxDateTimeEditorModule = /** @class */ (function () {
        function IgxDateTimeEditorModule() {
        }
        return IgxDateTimeEditorModule;
    }());
    IgxDateTimeEditorModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxDateTimeEditorDirective],
                    exports: [IgxDateTimeEditorDirective]
                },] }
    ];

    /**
     * Provides base filtering operations
     * Implementations should be Singleton
     *
     * @export
     */
    var IgxFilteringOperand = /** @class */ (function () {
        function IgxFilteringOperand() {
            var _this = this;
            this.operations = [{
                    name: 'null',
                    isUnary: true,
                    iconName: 'is-null',
                    logic: function (target) { return target === null; }
                }, {
                    name: 'notNull',
                    isUnary: true,
                    iconName: 'is-not-null',
                    logic: function (target) { return target !== null; }
                }, {
                    name: 'in',
                    isUnary: false,
                    iconName: 'is-in',
                    hidden: true,
                    logic: function (target, searchVal) { return _this.findValueInSet(target, searchVal); }
                }];
        }
        IgxFilteringOperand.instance = function () {
            return this._instance || (this._instance = new this());
        };
        /**
         * Returns an array of names of the conditions which are visible in the UI
         */
        IgxFilteringOperand.prototype.conditionList = function () {
            return this.operations.filter(function (f) { return !f.hidden; }).map(function (element) { return element.name; });
        };
        /**
         * Returns an instance of the condition with the specified name.
         *
         * @param name The name of the condition.
         */
        IgxFilteringOperand.prototype.condition = function (name) {
            return this.operations.find(function (element) { return element.name === name; });
        };
        /**
         * Adds a new condition to the filtering operations.
         *
         * @param operation The filtering operation.
         */
        IgxFilteringOperand.prototype.append = function (operation) {
            this.operations.push(operation);
        };
        /**
         * @hidden
         */
        IgxFilteringOperand.prototype.findValueInSet = function (target, searchVal) {
            return searchVal.has(target);
        };
        return IgxFilteringOperand;
    }());
    IgxFilteringOperand._instance = null;
    /**
     * Provides filtering operations for booleans
     *
     * @export
     */
    var IgxBooleanFilteringOperand = /** @class */ (function (_super) {
        __extends(IgxBooleanFilteringOperand, _super);
        function IgxBooleanFilteringOperand() {
            var _this = _super.call(this) || this;
            _this.operations = [{
                    name: 'all',
                    isUnary: true,
                    iconName: 'select-all',
                    logic: function (target) { return true; }
                }, {
                    name: 'true',
                    isUnary: true,
                    iconName: 'is-true',
                    logic: function (target) { return !!(target && target !== null && target !== undefined); }
                }, {
                    name: 'false',
                    isUnary: true,
                    iconName: 'is-false',
                    logic: function (target) { return !target && target !== null && target !== undefined; }
                }, {
                    name: 'empty',
                    isUnary: true,
                    iconName: 'is-empty',
                    logic: function (target) { return target === null || target === undefined; }
                }, {
                    name: 'notEmpty',
                    isUnary: true,
                    iconName: 'not-empty',
                    logic: function (target) { return target !== null && target !== undefined; }
                }].concat(_this.operations);
            return _this;
        }
        return IgxBooleanFilteringOperand;
    }(IgxFilteringOperand));
    /**
     * Provides filtering operations for Dates
     *
     * @export
     */
    var IgxDateFilteringOperand = /** @class */ (function (_super) {
        __extends(IgxDateFilteringOperand, _super);
        function IgxDateFilteringOperand() {
            var _this = _super.call(this) || this;
            _this.operations = [{
                    name: 'equals',
                    isUnary: false,
                    iconName: 'equals',
                    logic: function (target, searchVal) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                        var searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                        return targetp.year === searchp.year &&
                            targetp.month === searchp.month &&
                            targetp.day === searchp.day;
                    }
                }, {
                    name: 'doesNotEqual',
                    isUnary: false,
                    iconName: 'not-equal',
                    logic: function (target, searchVal) {
                        if (!target) {
                            return true;
                        }
                        _this.validateInputData(target);
                        var targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                        var searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                        return targetp.year !== searchp.year ||
                            targetp.month !== searchp.month ||
                            targetp.day !== searchp.day;
                    }
                }, {
                    name: 'before',
                    isUnary: false,
                    iconName: 'is-before',
                    logic: function (target, searchVal) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        return target < searchVal;
                    }
                }, {
                    name: 'after',
                    isUnary: false,
                    iconName: 'is-after',
                    logic: function (target, searchVal) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        return target > searchVal;
                    }
                }, {
                    name: 'today',
                    isUnary: true,
                    iconName: 'today',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yMd');
                        return d.year === now.year &&
                            d.month === now.month &&
                            d.day === now.day;
                    }
                }, {
                    name: 'yesterday',
                    isUnary: true,
                    iconName: 'yesterday',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var td = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                        var y = (function (d) { return new Date(d.setDate(d.getDate() - 1)); })(new Date());
                        var yesterday = IgxDateFilteringOperand.getDateParts(y, 'yMd');
                        return td.year === yesterday.year &&
                            td.month === yesterday.month &&
                            td.day === yesterday.day;
                    }
                }, {
                    name: 'thisMonth',
                    isUnary: true,
                    iconName: 'this-month',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                        return d.year === now.year &&
                            d.month === now.month;
                    }
                }, {
                    name: 'lastMonth',
                    isUnary: true,
                    iconName: 'last-month',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                        if (!now.month) {
                            now.month = 11;
                            now.year -= 1;
                        }
                        else {
                            now.month--;
                        }
                        return d.year === now.year &&
                            d.month === now.month;
                    }
                }, {
                    name: 'nextMonth',
                    isUnary: true,
                    iconName: 'next-month',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                        if (now.month === 11) {
                            now.month = 0;
                            now.year += 1;
                        }
                        else {
                            now.month++;
                        }
                        return d.year === now.year &&
                            d.month === now.month;
                    }
                }, {
                    name: 'thisYear',
                    isUnary: true,
                    iconName: 'this-year',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'y');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                        return d.year === now.year;
                    }
                }, {
                    name: 'lastYear',
                    isUnary: true,
                    iconName: 'last-year',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'y');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                        return d.year === now.year - 1;
                    }
                }, {
                    name: 'nextYear',
                    isUnary: true,
                    iconName: 'next-year',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'y');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                        return d.year === now.year + 1;
                    }
                }, {
                    name: 'empty',
                    isUnary: true,
                    iconName: 'is-empty',
                    logic: function (target) { return target === null || target === undefined; }
                }, {
                    name: 'notEmpty',
                    isUnary: true,
                    iconName: 'not-empty',
                    logic: function (target) { return target !== null && target !== undefined; }
                }].concat(_this.operations);
            return _this;
        }
        /**
         * Splits a Date object into parts
         *
         * @memberof IgxDateFilteringOperand
         */
        IgxDateFilteringOperand.getDateParts = function (date, dateFormat) {
            var res = {
                day: null,
                hours: null,
                milliseconds: null,
                minutes: null,
                month: null,
                seconds: null,
                year: null
            };
            if (!date || !dateFormat) {
                return res;
            }
            if (dateFormat.indexOf('y') >= 0) {
                res.year = date.getFullYear();
            }
            if (dateFormat.indexOf('M') >= 0) {
                res.month = date.getMonth();
            }
            if (dateFormat.indexOf('d') >= 0) {
                res.day = date.getDate();
            }
            if (dateFormat.indexOf('h') >= 0) {
                res.hours = date.getHours();
            }
            if (dateFormat.indexOf('m') >= 0) {
                res.minutes = date.getMinutes();
            }
            if (dateFormat.indexOf('s') >= 0) {
                res.seconds = date.getSeconds();
            }
            if (dateFormat.indexOf('f') >= 0) {
                res.milliseconds = date.getMilliseconds();
            }
            return res;
        };
        IgxDateFilteringOperand.prototype.findValueInSet = function (target, searchVal) {
            if (!target) {
                return false;
            }
            return searchVal.has(target.toISOString());
        };
        IgxDateFilteringOperand.prototype.validateInputData = function (target) {
            if (!(target instanceof Date)) {
                throw new Error('Could not perform filtering on \'date\' column because the datasource object type is not \'Date\'.');
            }
        };
        return IgxDateFilteringOperand;
    }(IgxFilteringOperand));
    /**
     * Provides filtering operations for numbers
     *
     * @export
     */
    var IgxNumberFilteringOperand = /** @class */ (function (_super) {
        __extends(IgxNumberFilteringOperand, _super);
        function IgxNumberFilteringOperand() {
            var _this = _super.call(this) || this;
            _this.operations = [{
                    name: 'equals',
                    isUnary: false,
                    iconName: 'equals',
                    logic: function (target, searchVal) { return target === searchVal; }
                }, {
                    name: 'doesNotEqual',
                    isUnary: false,
                    iconName: 'not-equal',
                    logic: function (target, searchVal) { return target !== searchVal; }
                }, {
                    name: 'greaterThan',
                    isUnary: false,
                    iconName: 'greater-than',
                    logic: function (target, searchVal) { return target > searchVal; }
                }, {
                    name: 'lessThan',
                    isUnary: false,
                    iconName: 'less-than',
                    logic: function (target, searchVal) { return target < searchVal; }
                }, {
                    name: 'greaterThanOrEqualTo',
                    isUnary: false,
                    iconName: 'greater-than-or-equal',
                    logic: function (target, searchVal) { return target >= searchVal; }
                }, {
                    name: 'lessThanOrEqualTo',
                    isUnary: false,
                    iconName: 'less-than-or-equal',
                    logic: function (target, searchVal) { return target <= searchVal; }
                }, {
                    name: 'empty',
                    isUnary: true,
                    iconName: 'is-empty',
                    logic: function (target) { return target === null || target === undefined || isNaN(target); }
                }, {
                    name: 'notEmpty',
                    isUnary: true,
                    iconName: 'not-empty',
                    logic: function (target) { return target !== null && target !== undefined && !isNaN(target); }
                }].concat(_this.operations);
            return _this;
        }
        return IgxNumberFilteringOperand;
    }(IgxFilteringOperand));
    /**
     * Provides filtering operations for strings
     *
     * @export
     */
    var IgxStringFilteringOperand = /** @class */ (function (_super) {
        __extends(IgxStringFilteringOperand, _super);
        function IgxStringFilteringOperand() {
            var _this = _super.call(this) || this;
            _this.operations = [{
                    name: 'contains',
                    isUnary: false,
                    iconName: 'contains',
                    logic: function (target, searchVal, ignoreCase) {
                        var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                        return target.indexOf(search) !== -1;
                    }
                }, {
                    name: 'doesNotContain',
                    isUnary: false,
                    iconName: 'does-not-contain',
                    logic: function (target, searchVal, ignoreCase) {
                        var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                        return target.indexOf(search) === -1;
                    }
                }, {
                    name: 'startsWith',
                    isUnary: false,
                    iconName: 'starts-with',
                    logic: function (target, searchVal, ignoreCase) {
                        var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                        return target.startsWith(search);
                    }
                }, {
                    name: 'endsWith',
                    isUnary: false,
                    iconName: 'ends-with',
                    logic: function (target, searchVal, ignoreCase) {
                        var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                        return target.endsWith(search);
                    }
                }, {
                    name: 'equals',
                    isUnary: false,
                    iconName: 'equals',
                    logic: function (target, searchVal, ignoreCase) {
                        var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                        return target === search;
                    }
                }, {
                    name: 'doesNotEqual',
                    isUnary: false,
                    iconName: 'not-equal',
                    logic: function (target, searchVal, ignoreCase) {
                        var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                        return target !== search;
                    }
                }, {
                    name: 'empty',
                    isUnary: true,
                    iconName: 'is-empty',
                    logic: function (target) { return target === null || target === undefined || target.length === 0; }
                }, {
                    name: 'notEmpty',
                    isUnary: true,
                    iconName: 'not-empty',
                    logic: function (target) { return target !== null && target !== undefined && target.length > 0; }
                }].concat(_this.operations);
            return _this;
        }
        /**
         * Applies case sensitivity on strings if provided
         *
         * @memberof IgxStringFilteringOperand
         */
        IgxStringFilteringOperand.applyIgnoreCase = function (a, ignoreCase) {
            a = a !== null && a !== void 0 ? a : '';
            // bulletproof
            return ignoreCase ? ('' + a).toLowerCase() : a;
        };
        return IgxStringFilteringOperand;
    }(IgxFilteringOperand));

    var filteringStateDefaults = {
        strategy: new FilteringStrategy()
    };

    /**
     * @hidden
     */
    var GroupedRecords = /** @class */ (function (_super) {
        __extends(GroupedRecords, _super);
        function GroupedRecords() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return GroupedRecords;
    }(Array));

    var IgxGridActionButtonComponent = /** @class */ (function () {
        function IgxGridActionButtonComponent() {
            /**
             * Event emitted when action button is clicked.
             *
             * @example
             * ```html
             *  <igx-grid-action-button (actionClick)="startEdit($event)"></igx-grid-action-button>
             * ```
             */
            this.actionClick = new i0.EventEmitter();
            /**
             * Whether button action is rendered in menu and should container text label.
             */
            this.asMenuItem = false;
        }
        Object.defineProperty(IgxGridActionButtonComponent.prototype, "containerClass", {
            /** @hidden @internal */
            get: function () {
                return 'igx-action-strip__menu-button ' + (this.classNames || '');
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxGridActionButtonComponent.prototype.handleClick = function (event) {
            this.actionClick.emit(event);
        };
        /**
         * @hidden @internal
         */
        IgxGridActionButtonComponent.prototype.preventEvent = function (event) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
        };
        return IgxGridActionButtonComponent;
    }());
    IgxGridActionButtonComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-grid-action-button',
                    template: "<ng-container *ngIf=\"!asMenuItem\">\n\n    <ng-container *ngIf=\"!asMenuItem\">\n        <button igxButton=\"icon\" igxRipple (click)=\"handleClick($event)\" (mousedown)=\"preventEvent($event)\">\n            <igx-icon *ngIf=\"iconSet\" [family]=\"iconSet\" [name]=\"iconName\">{{iconName}}</igx-icon>\n            <igx-icon *ngIf=\"!iconSet\" >{{iconName}}</igx-icon>\n        </button>\n    </ng-container>\n\n    <ng-container *ngIf=\"asMenuItem\">\n        <div #container [className]='containerClass'>\n            <igx-icon *ngIf=\"iconSet\" [family]=\"iconSet\" [name]=\"iconName\">{{iconName}}</igx-icon>\n            <igx-icon *ngIf=\"!iconSet\" >{{iconName}}</igx-icon>\n            <label *ngIf='asMenuItem' igxLabel>{{labelText}}</label>\n        </div>\n    </ng-container>\n</ng-container>\n"
                },] }
    ];
    IgxGridActionButtonComponent.propDecorators = {
        container: [{ type: i0.ViewChild, args: ['container',] }],
        actionClick: [{ type: i0.Output }],
        templateRef: [{ type: i0.ViewChild, args: [i0.TemplateRef,] }],
        asMenuItem: [{ type: i0.Input }],
        iconName: [{ type: i0.Input }],
        classNames: [{ type: i0.Input }],
        iconSet: [{ type: i0.Input }],
        labelText: [{ type: i0.Input }]
    };

    var LabelPosition = mkenum({
        BEFORE: 'before',
        AFTER: 'after'
    });
    var nextId$2 = 0;
    /**
     * Allows users to make a binary choice for a certain condition.
     *
     * @igxModule IgxCheckboxModule
     *
     * @igxTheme igx-checkbox-theme
     *
     * @igxKeywords checkbox, label
     *
     * @igxGroup Data entry and display
     *
     * @remarks
     * The Ignite UI Checkbox is a selection control that allows users to make a binary choice for a certain condition.It behaves similarly
     * to the native browser checkbox.
     *
     * @example
     * ```html
     * <igx-checkbox checked="true">
     *   simple checkbox
     * </igx-checkbox>
     * ```
     */
    var IgxCheckboxComponent = /** @class */ (function () {
        function IgxCheckboxComponent() {
            /**
             * An event that is emitted after the checkbox state is changed.
             * Provides references to the `IgxCheckboxComponent` and the `checked` property as event arguments.
             */
            // eslint-disable-next-line @angular-eslint/no-output-native
            this.change = new i0.EventEmitter();
            /**
             * Sets/gets the `id` of the checkbox component.
             * If not set, the `id` of the first checkbox component will be `"igx-checkbox-0"`.
             *
             * @example
             * ```html
             * <igx-checkbox id="my-first-checkbox"></igx-checkbox>
             * ```
             * ```typescript
             * let checkboxId =  this.checkbox.id;
             * ```
             */
            this.id = "igx-checkbox-" + nextId$2++;
            /**
             * Sets/gets the id of the `label` element.
             * If not set, the id of the `label` in the first checkbox component will be `"igx-checkbox-0-label"`.
             *
             * @example
             * ```html
             * <igx-checkbox labelId = "Label1"></igx-checkbox>
             * ```
             * ```typescript
             * let labelId =  this.checkbox.labelId;
             * ```
             */
            this.labelId = this.id + "-label";
            /**
             * Sets/gets the value of the `tabindex` attribute.
             *
             * @example
             * ```html
             * <igx-checkbox [tabindex] = "1"></igx-checkbox>
             * ```
             * ```typescript
             * let tabIndex =  this.checkbox.tabindex;
             * ```
             */
            this.tabindex = null;
            /**
             *  Sets/gets the position of the `label`.
             *  If not set, the `labelPosition` will have value `"after"`.
             *
             * @example
             * ```html
             * <igx-checkbox labelPosition = "before"></igx-checkbox>
             * ```
             * ```typescript
             * let labelPosition =  this.checkbox.labelPosition;
             * ```
             */
            this.labelPosition = LabelPosition.AFTER;
            /**
             * Enables/Disables the ripple effect.
             * If not set, `disableRipple` will have value `false`.
             *
             * @example
             * ```html
             * <igx-checkbox [disableRipple] = "true"></igx-checkbox>
             * ```
             * ```typescript
             * let isRippleDisabled = this.checkbox.desableRipple;
             * ```
             */
            this.disableRipple = false;
            /**
             * Sets/gets whether the checkbox is required.
             * If not set, `required` will have value `false`.
             *
             * @example
             * ```html
             * <igx-checkbox [required] = "true"></igx-checkbox>
             * ```
             * ```typescript
             * let isRequired =  this.checkbox.required;
             * ```
             */
            this.required = false;
            /**
             * Sets/gets the `aria-labelledby` attribute.
             * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
             *
             * @example
             * ```html
             * <igx-checkbox aria-labelledby = "Checkbox1"></igx-checkbox>
             * ```
             * ```typescript
             * let ariaLabelledBy =  this.checkbox.ariaLabelledBy;
             * ```
             */
            this.ariaLabelledBy = this.labelId;
            /**
             * Sets/gets the value of the `aria-label` attribute.
             *
             * @example
             * ```html
             * <igx-checkbox aria-label = "Checkbox1"></igx-checkbox>
             * ```
             * ```typescript
             * let ariaLabel = this.checkbox.ariaLabel;
             * ```
             */
            this.ariaLabel = null;
            /**
             * Returns the class of the checkbox component.
             *
             * @example
             * ```typescript
             * let class =  this.checkbox.cssClass;
             * ```
             */
            this.cssClass = 'igx-checkbox';
            /**
             * Sets/gets whether the checkbox component is on focus.
             * Default value is `false`.
             *
             * @example
             * ```typescript
             * this.checkbox.focused =  true;
             * ```
             * ```typescript
             * let isFocused =  this.checkbox.focused;
             * ```
             */
            this.focused = false;
            /**
             * Sets/gets the checkbox indeterminate visual state.
             * Default value is `false`;
             *
             * @example
             * ```html
             * <igx-checkbox [indeterminate] = "true"></igx-checkbox>
             * ```
             * ```typescript
             * let isIndeterminate = this.checkbox.indeterminate;
             * ```
             */
            this.indeterminate = false;
            /**
             * Sets/gets whether the checkbox is checked.
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-checkbox [checked] = "true"></igx-checkbox>
             * ```
             * ```typescript
             * let isChecked =  this.checkbox.checked;
             * ```
             */
            this.checked = false;
            /**
             * Sets/gets whether the checkbox is disabled.
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-checkbox [disabled] = "true"></igx-checkbox>
             * ```
             * ```typescript
             * let isDisabled = this.checkbox.disabled;
             * ```
             */
            this.disabled = false;
            /**
             * Sets/gets whether the checkbox is readonly.
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-checkbox [readonly]="true"></igx-checkbox>
             * ```
             * ```typescript
             * let readonly = this.checkbox.readonly;
             * ```
             */
            this.readonly = false;
            /**
             * Sets/gets whether the checkbox should disable all css transitions.
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-checkbox [disableTransitions]="true"></igx-checkbox>
             * ```
             * ```typescript
             * let disableTransitions = this.checkbox.disableTransitions;
             * ```
             */
            this.disableTransitions = false;
            /** @hidden @internal */
            this.inputId = this.id + "-input";
            /**
             * @hidden
             */
            this._onTouchedCallback = rxjs.noop;
            /**
             * @hidden
             */
            this._onChangeCallback = rxjs.noop;
        }
        /**
         * @hidden
         * @internal
         */
        IgxCheckboxComponent.prototype.onKeyUp = function (event) {
            event.stopPropagation();
            this.focused = true;
        };
        /**
         * If `disabled` is `false`, switches the `checked` state.
         *
         * @example
         * ```typescript
         * this.checkbox.toggle();
         * ```
         */
        IgxCheckboxComponent.prototype.toggle = function () {
            if (this.disabled || this.readonly) {
                return;
            }
            this.nativeCheckbox.nativeElement.focus();
            this.indeterminate = false;
            this.checked = !this.checked;
            this.change.emit({ checked: this.checked, checkbox: this });
            this._onChangeCallback(this.checked);
        };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype._onCheckboxChange = function (event) {
            // We have to stop the original checkbox change event
            // from bubbling up since we emit our own change event
            event.stopPropagation();
        };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype._onCheckboxClick = function (event) {
            // Since the original checkbox is hidden and the label
            // is used for styling and to change the checked state of the checkbox,
            // we need to prevent the checkbox click event from bubbling up
            // as it gets triggered on label click
            event.stopPropagation();
            if (this.readonly) {
                // readonly prevents the component from changing state (see toggle() method).
                // However, the native checkbox can still be activated through user interaction (focus + space, label click)
                // Prevent the native change so the input remains in sync
                event.preventDefault();
            }
            this.toggle();
            if (isIE()) {
                this.nativeCheckbox.nativeElement.blur();
            }
        };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype._onLabelClick = function () {
            // We use a span element as a placeholder label
            // in place of the native label, we need to emit
            // the change event separately here alongside
            // the click event emitted on click
            this.toggle();
        };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype.onBlur = function () {
            this.focused = false;
            this._onTouchedCallback();
        };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype.writeValue = function (value) {
            this._value = value;
            this.checked = !!this._value;
        };
        Object.defineProperty(IgxCheckboxComponent.prototype, "labelClass", {
            /** @hidden @internal */
            get: function () {
                switch (this.labelPosition) {
                    case LabelPosition.BEFORE:
                        return this.cssClass + "__label--before";
                    case LabelPosition.AFTER:
                    default:
                        return this.cssClass + "__label";
                }
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden @internal */
        IgxCheckboxComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype.getEditElement = function () {
            return this.nativeCheckbox.nativeElement;
        };
        return IgxCheckboxComponent;
    }());
    IgxCheckboxComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxCheckboxComponent, multi: true }],
                    selector: 'igx-checkbox',
                    preserveWhitespaces: false,
                    template: "<input #checkbox class=\"igx-checkbox__input\"\n    type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [indeterminate]=\"indeterminate\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onCheckboxChange($event)\"\n    (click)=\"_onCheckboxClick($event)\"\n    (blur)=\"onBlur()\" />\n\n<div\n    igxRipple\n    igxRippleTarget=\".igx-checkbox__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    class=\"igx-checkbox__composite-wrapper\"\n>\n    <label #label class=\"igx-checkbox__composite\"\n        [attr.for]=\"inputId\">\n        <svg class=\"igx-checkbox__composite-mark\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n            <path d=\"M4.1,12.7 9,17.6 20.3,6.3\" />\n        </svg>\n    </label>\n\n    <div class=\"igx-checkbox__ripple\"></div>\n</div>\n\n<span #placeholderLabel\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick()\">\n    <ng-content></ng-content>\n</span>\n"
                },] }
    ];
    IgxCheckboxComponent.propDecorators = {
        change: [{ type: i0.Output }],
        nativeCheckbox: [{ type: i0.ViewChild, args: ['checkbox', { static: true },] }],
        nativeLabel: [{ type: i0.ViewChild, args: ['label', { static: true },] }],
        placeholderLabel: [{ type: i0.ViewChild, args: ['placeholderLabel', { static: true },] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        labelId: [{ type: i0.Input }],
        value: [{ type: i0.Input }],
        name: [{ type: i0.Input }],
        tabindex: [{ type: i0.Input }],
        labelPosition: [{ type: i0.Input }],
        disableRipple: [{ type: i0.Input }],
        required: [{ type: i0.Input }],
        ariaLabelledBy: [{ type: i0.Input, args: ['aria-labelledby',] }],
        ariaLabel: [{ type: i0.Input, args: ['aria-label',] }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-checkbox',] }],
        focused: [{ type: i0.HostBinding, args: ['class.igx-checkbox--focused',] }],
        indeterminate: [{ type: i0.HostBinding, args: ['class.igx-checkbox--indeterminate',] }, { type: i0.Input }],
        checked: [{ type: i0.HostBinding, args: ['class.igx-checkbox--checked',] }, { type: i0.Input }],
        disabled: [{ type: i0.HostBinding, args: ['class.igx-checkbox--disabled',] }, { type: i0.Input }],
        readonly: [{ type: i0.Input }],
        disableTransitions: [{ type: i0.HostBinding, args: ['class.igx-checkbox--plain',] }, { type: i0.Input }],
        onKeyUp: [{ type: i0.HostListener, args: ['keyup', ['$event'],] }]
    };
    var IGX_CHECKBOX_REQUIRED_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: i0.forwardRef(function () { return IgxCheckboxRequiredDirective; }),
        multi: true
    };
    /* eslint-disable  @angular-eslint/directive-selector */
    var IgxCheckboxRequiredDirective = /** @class */ (function (_super) {
        __extends(IgxCheckboxRequiredDirective, _super);
        function IgxCheckboxRequiredDirective() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return IgxCheckboxRequiredDirective;
    }(forms.CheckboxRequiredValidator));
    IgxCheckboxRequiredDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: "igx-checkbox[required][formControlName],\n    igx-checkbox[required][formControl],\n    igx-checkbox[required][ngModel]",
                    providers: [IGX_CHECKBOX_REQUIRED_VALIDATOR]
                },] }
    ];
    /**
     * @hidden
     */
    var IgxCheckboxModule = /** @class */ (function () {
        function IgxCheckboxModule() {
        }
        return IgxCheckboxModule;
    }());
    IgxCheckboxModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                    exports: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                    imports: [IgxRippleModule]
                },] }
    ];

    /**
     * @hidden
     */
    var GridBaseAPIService = /** @class */ (function () {
        function GridBaseAPIService() {
            this.destroyMap = new Map();
        }
        GridBaseAPIService.prototype.get_column_by_name = function (name) {
            return this.grid.columnList.find(function (col) { return col.field === name; });
        };
        GridBaseAPIService.prototype.get_summary_data = function () {
            var grid = this.grid;
            var data = grid.filteredData;
            if (data && grid.hasPinnedRecords) {
                data = grid._filteredUnpinnedData;
            }
            if (!data) {
                if (grid.transactions.enabled) {
                    data = DataUtil.mergeTransactions(cloneArray(grid.data), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
                    var deletedRows = grid.transactions.getTransactionLog().filter(function (t) { return t.type === exports.TransactionType.DELETE; }).map(function (t) { return t.id; });
                    deletedRows.forEach(function (rowID) {
                        var tempData = grid.primaryKey ? data.map(function (rec) { return rec[grid.primaryKey]; }) : data;
                        var index = tempData.indexOf(rowID);
                        if (index !== -1) {
                            data.splice(index, 1);
                        }
                    });
                }
                else {
                    data = grid.data;
                }
            }
            return data;
        };
        /**
         * @hidden
         * @internal
         */
        GridBaseAPIService.prototype.getRowData = function (rowID) {
            var data = this.get_all_data(this.grid.transactions.enabled);
            var index = this.get_row_index_in_data(rowID, data);
            return data[index];
        };
        GridBaseAPIService.prototype.get_row_index_in_data = function (rowID, dataCollection) {
            var grid = this.grid;
            if (!grid) {
                return -1;
            }
            var data = dataCollection !== null && dataCollection !== void 0 ? dataCollection : this.get_all_data(grid.transactions.enabled);
            return grid.primaryKey ? data.findIndex(function (record) { return record.recordRef ? record.recordRef[grid.primaryKey] === rowID
                : record[grid.primaryKey] === rowID; }) : data.indexOf(rowID);
        };
        GridBaseAPIService.prototype.get_row_by_key = function (rowSelector) {
            if (!this.grid) {
                return null;
            }
            var primaryKey = this.grid.primaryKey;
            if (primaryKey !== undefined && primaryKey !== null) {
                return this.grid.dataRowList.find(function (row) { return row.rowData[primaryKey] === rowSelector; });
            }
            else {
                return this.grid.dataRowList.find(function (row) { return row.rowData === rowSelector; });
            }
        };
        GridBaseAPIService.prototype.get_row_by_index = function (rowIndex) {
            return this.grid.rowList.find(function (row) { return row.index === rowIndex; });
        };
        GridBaseAPIService.prototype.get_cell_by_key = function (rowSelector, field) {
            var row = this.get_row_by_key(rowSelector);
            if (row && row.cells) {
                return row.cells.find(function (cell) { return cell.column.field === field; });
            }
        };
        GridBaseAPIService.prototype.get_cell_by_index = function (rowIndex, columnIndex) {
            var row = this.get_row_by_index(rowIndex);
            if (row && row.cells) {
                return row.cells.find(function (cell) { return cell.columnIndex === columnIndex; });
            }
        };
        GridBaseAPIService.prototype.get_cell_by_visible_index = function (rowIndex, columnIndex) {
            var row = this.get_row_by_index(rowIndex);
            if (row && row.cells) {
                return row.cells.find(function (cell) { return cell.visibleColumnIndex === columnIndex; });
            }
        };
        GridBaseAPIService.prototype.submit_value = function (event) {
            var cell = this.grid.crudService.cell;
            if (cell) {
                var args = this.update_cell(cell, cell.editValue, event);
                this.grid.crudService.cellEditingBlocked = args.cancel;
                if (args.cancel) {
                    return args.cancel;
                }
                this.grid.crudService.exitCellEdit(event);
            }
        };
        GridBaseAPIService.prototype.submit_add_value = function (event) {
            var cell = this.grid.crudService.cell;
            if (cell) {
                var args = this.update_add_cell(cell, cell.editValue, event);
                if (args.cancel) {
                    this.grid.endAddRow();
                    return args.cancel;
                }
                return this.grid.crudService.exitCellEdit(event);
            }
        };
        GridBaseAPIService.prototype.update_add_cell = function (cell, value, event) {
            cell.editValue = value;
            var args = cell.createEditEventArgs(true, event);
            if (isEqual(args.oldValue, args.newValue)) {
                return args;
            }
            this.grid.cellEdit.emit(args);
            this.grid.crudService.cellEditingBlocked = args.cancel;
            if (args.cancel) {
                return args;
            }
            var data = cell.rowData;
            if (cell.column.hasNestedPath) {
                mergeObjects(data, reverseMapper(cell.column.field, args.newValue));
            }
            else {
                data[cell.column.field] = args.newValue;
            }
            this.grid.crudService.row.data = data;
            var doneArgs = cell.createDoneEditEventArgs(args.newValue, event);
            doneArgs.rowData = data;
            this.grid.cellEditDone.emit(doneArgs);
            return args;
        };
        GridBaseAPIService.prototype.update_cell = function (cell, value, event) {
            cell.editValue = value;
            var args = cell.createEditEventArgs(true, event);
            if (isEqual(args.oldValue, args.newValue)) {
                return args;
            }
            this.grid.cellEdit.emit(args);
            this.grid.crudService.cellEditingBlocked = args.cancel;
            if (args.cancel) {
                return args;
            }
            this.grid.summaryService.clearSummaryCache(args);
            var data = this.getRowData(cell.id.rowID);
            this.updateData(this.grid, cell.id.rowID, data, cell.rowData, reverseMapper(cell.column.field, args.newValue));
            if (this.grid.primaryKey === cell.column.field) {
                if (this.grid.selectionService.isRowSelected(cell.id.rowID)) {
                    this.grid.selectionService.deselectRow(cell.id.rowID);
                    this.grid.selectionService.selectRowById(args.newValue);
                }
                if (this.grid.hasSummarizedColumns) {
                    this.grid.summaryService.removeSummaries(cell.id.rowID);
                }
            }
            if (!this.grid.rowEditable || !this.grid.crudService.row ||
                this.grid.crudService.row.id !== cell.id.rowID || !this.grid.transactions.enabled) {
                this.grid.summaryService.clearSummaryCache(args);
                this.grid._pipeTrigger++;
            }
            var doneArgs = cell.createDoneEditEventArgs(args.newValue, event);
            this.grid.cellEditDone.emit(doneArgs);
            return args;
        };
        GridBaseAPIService.prototype._update_row = function (row, value) {
            var grid = this.grid;
            var rowInEditMode = grid.crudService.row;
            row.newData = value !== null && value !== void 0 ? value : rowInEditMode.transactionState;
            if (rowInEditMode && row.id === rowInEditMode.id) {
                row.data = Object.assign(Object.assign({}, row.data), rowInEditMode.transactionState);
                // TODO: Workaround for updating a row in edit mode through the API
            }
            else if (this.grid.transactions.enabled) {
                var state = grid.transactions.getState(row.id);
                row.data = state ? Object.assign({}, row.data, state.value) : row.data;
            }
        };
        GridBaseAPIService.prototype.update_row = function (row, value, event) {
            var grid = this.grid;
            var selected = grid.selectionService.isRowSelected(row.id);
            var rowInEditMode = grid.crudService.row;
            var data = this.get_all_data(grid.transactions.enabled);
            var index = this.get_row_index_in_data(row.id, data);
            var hasSummarized = grid.hasSummarizedColumns;
            this._update_row(row, value);
            var args = row.createEditEventArgs(true, event);
            // If no valid row is found
            if (index === -1) {
                return args;
            }
            grid.rowEdit.emit(args);
            if (args.cancel) {
                return args;
            }
            var cachedRowData = Object.assign({}, args.oldValue);
            if (rowInEditMode) {
                var hasChanges = grid.transactions.getState(args.rowID, true);
                grid.transactions.endPending(false);
                if (!hasChanges) {
                    return args;
                }
            }
            if (!args.newValue) {
                return args;
            }
            if (hasSummarized) {
                grid.summaryService.removeSummaries(args.rowID);
            }
            this.updateData(grid, row.id, data[index], args.oldValue, args.newValue);
            var newId = grid.primaryKey ? args.newValue[grid.primaryKey] : args.newValue;
            if (selected) {
                grid.selectionService.deselectRow(row.id);
                grid.selectionService.selectRowById(newId);
            }
            // make sure selection is handled prior to updating the row.id
            row.id = newId;
            if (hasSummarized) {
                grid.summaryService.removeSummaries(newId);
            }
            grid._pipeTrigger++;
            var doneArgs = row.createDoneEditEventArgs(cachedRowData, event);
            grid.rowEditDone.emit(doneArgs);
            return args;
        };
        GridBaseAPIService.prototype.sort = function (expression) {
            if (expression.dir === exports.SortingDirection.None) {
                this.remove_grouping_expression(expression.fieldName);
            }
            var sortingState = cloneArray(this.grid.sortingExpressions);
            this.prepare_sorting_expression([sortingState], expression);
            this.grid.sortingExpressions = sortingState;
        };
        GridBaseAPIService.prototype.sort_multiple = function (expressions) {
            var e_1, _a;
            var sortingState = cloneArray(this.grid.sortingExpressions);
            try {
                for (var expressions_1 = __values(expressions), expressions_1_1 = expressions_1.next(); !expressions_1_1.done; expressions_1_1 = expressions_1.next()) {
                    var each = expressions_1_1.value;
                    if (each.dir === exports.SortingDirection.None) {
                        this.remove_grouping_expression(each.fieldName);
                    }
                    this.prepare_sorting_expression([sortingState], each);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (expressions_1_1 && !expressions_1_1.done && (_a = expressions_1.return)) _a.call(expressions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.grid.sortingExpressions = sortingState;
        };
        GridBaseAPIService.prototype.clear_sort = function (fieldName) {
            var sortingState = this.grid.sortingExpressions;
            var index = sortingState.findIndex(function (expr) { return expr.fieldName === fieldName; });
            if (index > -1) {
                sortingState.splice(index, 1);
                this.grid.sortingExpressions = sortingState;
            }
        };
        GridBaseAPIService.prototype.clear_groupby = function (name) {
        };
        GridBaseAPIService.prototype.should_apply_number_style = function (column) {
            return column.dataType === DataType.Number;
        };
        GridBaseAPIService.prototype.get_data = function () {
            var grid = this.grid;
            var data = grid.data ? grid.data : [];
            return data;
        };
        GridBaseAPIService.prototype.get_all_data = function (includeTransactions) {
            if (includeTransactions === void 0) { includeTransactions = false; }
            var grid = this.grid;
            var data = grid && grid.data ? grid.data : [];
            data = includeTransactions ? grid.dataWithAddedInTransactionRows : data;
            return data;
        };
        GridBaseAPIService.prototype.get_filtered_data = function () {
            return this.grid.filteredData;
        };
        GridBaseAPIService.prototype.addRowToData = function (rowData, parentRowID) {
            // Add row goes to transactions and if rowEditable is properly implemented, added rows will go to pending transactions
            // If there is a row in edit - > commit and close
            var grid = this.grid;
            if (grid.transactions.enabled) {
                var transactionId = grid.primaryKey ? rowData[grid.primaryKey] : rowData;
                var transaction = { id: transactionId, type: exports.TransactionType.ADD, newValue: rowData };
                grid.transactions.add(transaction);
            }
            else {
                grid.data.push(rowData);
            }
        };
        GridBaseAPIService.prototype.deleteRowFromData = function (rowID, index) {
            //  if there is a row (index !== 0) delete it
            //  if there is a row in ADD or UPDATE state change it's state to DELETE
            var grid = this.grid;
            if (index !== -1) {
                if (grid.transactions.enabled) {
                    var transaction = { id: rowID, type: exports.TransactionType.DELETE, newValue: null };
                    grid.transactions.add(transaction, grid.data[index]);
                }
                else {
                    grid.data.splice(index, 1);
                }
            }
            else {
                var state = grid.transactions.getState(rowID);
                grid.transactions.add({ id: rowID, type: exports.TransactionType.DELETE, newValue: null }, state && state.recordRef);
            }
        };
        GridBaseAPIService.prototype.deleteRowById = function (rowId) {
            var index;
            var grid = this.grid;
            var data = this.get_all_data();
            if (grid.primaryKey) {
                index = data.map(function (record) { return record[grid.primaryKey]; }).indexOf(rowId);
            }
            else {
                index = data.indexOf(rowId);
            }
            var state = grid.transactions.getState(rowId);
            var hasRowInNonDeletedState = state && state.type !== exports.TransactionType.DELETE;
            //  if there is a row (index !== -1) and the we have cell in edit mode on same row exit edit mode
            //  if there is no row (index === -1), but there is a row in ADD or UPDATE state do as above
            //  Otherwise just exit - there is nothing to delete
            if (index !== -1 || hasRowInNonDeletedState) {
                // Always exit edit when row is deleted
                grid.endEdit(true);
            }
            else {
                return;
            }
            //  TODO: should we emit this when cascadeOnDelete is true for each row?!?!
            grid.onRowDeleted.emit({ data: data[index] });
            this.deleteRowFromData(rowId, index);
            if (grid.selectionService.isRowSelected(rowId)) {
                grid.selectionService.deselectRow(rowId);
            }
            else {
                grid.selectionService.clearHeaderCBState();
            }
            grid._pipeTrigger++;
            grid.notifyChanges();
            // Data needs to be recalculated if transactions are in place
            // If no transactions, `data` will be a reference to the grid getter, otherwise it will be stale
            var dataAfterDelete = grid.transactions.enabled ? grid.dataWithAddedInTransactionRows : data;
            grid.refreshSearch();
            if (dataAfterDelete.length % grid.perPage === 0 && dataAfterDelete.length / grid.perPage - 1 < grid.page && grid.page !== 0) {
                grid.page--;
            }
        };
        GridBaseAPIService.prototype.get_row_id = function (rowData) {
            return this.grid.primaryKey ? rowData[this.grid.primaryKey] : rowData;
        };
        GridBaseAPIService.prototype.row_deleted_transaction = function (rowID) {
            var grid = this.grid;
            if (!grid) {
                return false;
            }
            if (!grid.transactions.enabled) {
                return false;
            }
            var state = grid.transactions.getState(rowID);
            if (state) {
                return state.type === exports.TransactionType.DELETE;
            }
            return false;
        };
        GridBaseAPIService.prototype.get_row_expansion_state = function (record) {
            var grid = this.grid;
            var states = grid.expansionStates;
            var rowID = grid.primaryKey ? record[grid.primaryKey] : record;
            var expanded = states.get(rowID);
            if (expanded !== undefined) {
                return expanded;
            }
            else {
                return grid.getDefaultExpandState(record);
            }
        };
        GridBaseAPIService.prototype.set_row_expansion_state = function (rowID, expanded, event) {
            var grid = this.grid;
            var expandedStates = grid.expansionStates;
            if (!this.allow_expansion_state_change(rowID, expanded)) {
                return;
            }
            var args = {
                rowID: rowID,
                expanded: expanded,
                event: event,
                cancel: false
            };
            grid.onRowToggle.emit(args);
            if (args.cancel) {
                return;
            }
            expandedStates.set(rowID, expanded);
            grid.expansionStates = expandedStates;
            if (grid.rowEditable) {
                grid.endEdit(false);
            }
        };
        GridBaseAPIService.prototype.get_rec_by_id = function (rowID) {
            return this.grid.primaryKey ? this.getRowData(rowID) : rowID;
        };
        GridBaseAPIService.prototype.allow_expansion_state_change = function (rowID, expanded) {
            return this.grid.expansionStates.get(rowID) !== expanded;
        };
        GridBaseAPIService.prototype.prepare_sorting_expression = function (stateCollections, expression) {
            if (expression.dir === exports.SortingDirection.None) {
                stateCollections.forEach(function (state) {
                    state.splice(state.findIndex(function (expr) { return expr.fieldName === expression.fieldName; }), 1);
                });
                return;
            }
            /**
             * We need to make sure the states in each collection with same fields point to the same object reference.
             * If the different state collections provided have different sizes we need to get the largest one.
             * That way we can get the state reference from the largest one that has the same fieldName as the expression to prepare.
             */
            var maxCollection = stateCollections[0];
            for (var i = 1; i < stateCollections.length; i++) {
                if (maxCollection.length < stateCollections[i].length) {
                    maxCollection = stateCollections[i];
                }
            }
            var maxExpr = maxCollection.find(function (expr) { return expr.fieldName === expression.fieldName; });
            stateCollections.forEach(function (collection) {
                var myExpr = collection.find(function (expr) { return expr.fieldName === expression.fieldName; });
                if (!myExpr && !maxExpr) {
                    // Expression with this fieldName is missing from the current and the max collection.
                    collection.push(expression);
                }
                else if (!myExpr && maxExpr) {
                    // Expression with this fieldName is missing from the current and but the max collection has.
                    collection.push(maxExpr);
                    Object.assign(maxExpr, expression);
                }
                else {
                    // The current collection has the expression so just update it.
                    Object.assign(myExpr, expression);
                }
            });
        };
        GridBaseAPIService.prototype.remove_grouping_expression = function (fieldName) {
        };
        GridBaseAPIService.prototype.filterDataByExpressions = function (expressionsTree) {
            var data = this.get_all_data();
            if (expressionsTree.filteringOperands.length) {
                var state = { expressionsTree: expressionsTree, strategy: this.grid.filterStrategy };
                data = DataUtil.filter(cloneArray(data), state, this.grid);
            }
            return data;
        };
        /**
         * Updates related row of provided grid's data source with provided new row value
         *
         * @param grid Grid to update data for
         * @param rowID ID of the row to update
         * @param rowValueInDataSource Initial value of the row as it is in data source
         * @param rowCurrentValue Current value of the row as it is with applied previous transactions
         * @param rowNewValue New value of the row
         */
        GridBaseAPIService.prototype.updateData = function (grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
            if (grid.transactions.enabled) {
                var transaction = {
                    id: rowID,
                    type: exports.TransactionType.UPDATE,
                    newValue: rowNewValue
                };
                grid.transactions.add(transaction, rowCurrentValue);
            }
            else {
                mergeObjects(rowValueInDataSource, rowNewValue);
            }
        };
        GridBaseAPIService.prototype.update_row_in_array = function (value, rowID, index) {
            var grid = this.grid;
            grid.data[index] = value;
        };
        GridBaseAPIService.prototype.getSortStrategyPerColumn = function (fieldName) {
            return this.get_column_by_name(fieldName) ?
                this.get_column_by_name(fieldName).sortStrategy : undefined;
        };
        return GridBaseAPIService;
    }());
    GridBaseAPIService.decorators = [
        { type: i0.Injectable }
    ];

    // TODO: Refactor - export in a separate file
    var IgxRow = /** @class */ (function () {
        function IgxRow(id, index, data, grid) {
            this.id = id;
            this.index = index;
            this.data = data;
            this.grid = grid;
        }
        IgxRow.prototype.createEditEventArgs = function (includeNewValue, event) {
            if (includeNewValue === void 0) { includeNewValue = true; }
            var args = {
                rowID: this.id,
                rowData: this.data,
                oldValue: this.data,
                cancel: false,
                owner: this.grid,
                isAddRow: this.isAddRow || false,
                event: event
            };
            if (includeNewValue) {
                args.newValue = this.newData;
            }
            return args;
        };
        IgxRow.prototype.createDoneEditEventArgs = function (cachedRowData, event) {
            var updatedData = this.grid.transactions.enabled ?
                this.grid.transactions.getAggregatedValue(this.id, true) : this.grid.gridAPI.getRowData(this.id);
            var rowData = updatedData === null ? this.grid.gridAPI.getRowData(this.id) : updatedData;
            var args = {
                rowID: this.id,
                rowData: rowData,
                oldValue: cachedRowData,
                newValue: updatedData,
                owner: this.grid,
                isAddRow: this.isAddRow || false,
                event: event
            };
            return args;
        };
        return IgxRow;
    }());
    var IgxCell = /** @class */ (function () {
        function IgxCell(id, rowIndex, column, value, editValue, rowData, grid) {
            this.id = id;
            this.rowIndex = rowIndex;
            this.column = column;
            this.value = value;
            this.editValue = editValue;
            this.rowData = rowData;
            this.grid = grid;
        }
        IgxCell.prototype.castToNumber = function (value) {
            if (this.column.dataType === 'number' && !this.column.inlineEditorTemplate) {
                var v = parseFloat(value);
                return !isNaN(v) && isFinite(v) ? v : 0;
            }
            return value;
        };
        IgxCell.prototype.createEditEventArgs = function (includeNewValue, event) {
            if (includeNewValue === void 0) { includeNewValue = true; }
            var args = {
                rowID: this.id.rowID,
                cellID: this.id,
                rowData: this.rowData,
                oldValue: this.value,
                cancel: false,
                column: this.column,
                owner: this.grid,
                event: event
            };
            if (includeNewValue) {
                args.newValue = this.castToNumber(this.editValue);
            }
            return args;
        };
        IgxCell.prototype.createDoneEditEventArgs = function (value, event) {
            var updatedData = this.grid.transactions.enabled ?
                this.grid.transactions.getAggregatedValue(this.id.rowID, true) : this.rowData;
            var rowData = updatedData === null ? this.grid.gridAPI.getRowData(this.id.rowID) : updatedData;
            var args = {
                rowID: this.id.rowID,
                cellID: this.id,
                // rowData - should be the updated/committed rowData - this effectively should be the newValue
                // the only case we use this.rowData directly, is when there is no rowEditing or transactions enabled
                rowData: rowData,
                oldValue: this.value,
                newValue: value,
                column: this.column,
                owner: this.grid,
                event: event
            };
            return args;
        };
        return IgxCell;
    }());
    var IgxGridCRUDService = /** @class */ (function () {
        function IgxGridCRUDService() {
            this.cell = null;
            this.row = null;
            this.isInCompositionMode = false;
            this._cellEditingBlocked = false;
            this._rowEditingBlocked = false;
        }
        IgxGridCRUDService.prototype.createCell = function (cell) {
            return new IgxCell(cell.cellID, cell.rowIndex, cell.column, cell.value, cell.value, cell.row.rowData, cell.grid);
        };
        IgxGridCRUDService.prototype.createRow = function (cell) {
            return new IgxRow(cell.id.rowID, cell.rowIndex, cell.rowData, cell.grid);
        };
        IgxGridCRUDService.prototype.sameRow = function (rowID) {
            return this.row && this.row.id === rowID;
        };
        IgxGridCRUDService.prototype.sameCell = function (cell) {
            return (this.cell.id.rowID === cell.id.rowID &&
                this.cell.id.columnID === cell.id.columnID);
        };
        Object.defineProperty(IgxGridCRUDService.prototype, "cellInEditMode", {
            get: function () {
                return !!this.cell;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCRUDService.prototype, "rowInEditMode", {
            get: function () {
                return !!this.row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCRUDService.prototype, "rowEditing", {
            get: function () {
                return this.grid.rowEditable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCRUDService.prototype, "primaryKey", {
            get: function () {
                return this.grid.primaryKey;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCRUDService.prototype, "cellEditingBlocked", {
            get: function () {
                return this._cellEditingBlocked;
            },
            set: function (val) {
                this._cellEditingBlocked = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCRUDService.prototype, "rowEditingBlocked", {
            get: function () {
                return this._rowEditingBlocked;
            },
            set: function (val) {
                this._rowEditingBlocked = val;
            },
            enumerable: false,
            configurable: true
        });
        IgxGridCRUDService.prototype.enterEditMode = function (cell, event) {
            if (this.isInCompositionMode) {
                return;
            }
            if (this.cellInEditMode) {
                // TODO: case solely for f2/enter nav that uses enterEditMode as toggle. Refactor.
                var canceled = this.grid.endEdit(true, event);
                if (!canceled || !this.cell) {
                    this.grid.tbody.nativeElement.focus();
                }
            }
            else {
                if (cell === null || cell === void 0 ? void 0 : cell.row.addRow) {
                    this.beginAddRow(cell, event);
                    return;
                }
                /** Changing the reference with the new editable cell */
                var newCell = this.createCell(cell);
                if (this.rowEditing) {
                    var canceled = this.beginRowEdit(newCell, event);
                    if (!canceled) {
                        this.beginCellEdit(newCell, event);
                    }
                }
                else {
                    this.beginCellEdit(newCell, event);
                }
            }
        };
        /** Enters row edit mode */
        IgxGridCRUDService.prototype.beginRowEdit = function (newCell, event) {
            if (this.row && !this.sameRow(newCell.id.rowID)) {
                this._rowEditingBlocked = this.grid.endEdit(true, event);
                if (this.rowEditingBlocked) {
                    return true;
                }
                this.cell = newCell;
                this._rowEditingBlocked = false;
                this.endRowEdit();
            }
            if (this.grid.rowEditable && (this.grid.primaryKey === undefined || this.grid.primaryKey === null)) {
                console.warn('The grid must have a `primaryKey` specified when using `rowEditable`!');
            }
            if (!this.row) {
                this.cell = newCell;
                this.row = this.createRow(this.cell);
                var rowArgs = this.row.createEditEventArgs(false, event);
                this.grid.rowEditEnter.emit(rowArgs);
                if (rowArgs.cancel) {
                    this.endEditMode();
                    return true;
                }
                this.row.transactionState = this.grid.transactions.getAggregatedValue(this.row.id, true);
                this.grid.transactions.startPending();
                this.grid.openRowOverlay(this.row.id);
            }
        };
        /** Exit row edit mode */
        IgxGridCRUDService.prototype.exitRowEdit = function (commit, event) {
            if (!this.grid.rowEditable ||
                this.grid.rowEditingOverlay &&
                    this.grid.rowEditingOverlay.collapsed || !this.row) {
                return false;
            }
            if (this.rowEditingBlocked && this.cellEditingBlocked) {
                return true;
            }
            var canceled = this.grid.endRowTransaction(commit, this.row, event);
            if (canceled) {
                return true;
            }
        };
        /** Enters cell edit mode */
        IgxGridCRUDService.prototype.beginAddRow = function (cell, event) {
            var newCell = this.createCell(cell);
            newCell.primaryKey = this.primaryKey;
            cell.enterAddMode = true;
            this.cell = newCell;
            if (!this.sameRow(newCell.id.rowID)) {
                this.row = this.createRow(this.cell);
                this.row.isAddRow = true;
                var rowArgs = this.row.createEditEventArgs(false, event);
                this.grid.rowEditEnter.emit(rowArgs);
                if (rowArgs.cancel) {
                    this.endEditMode();
                    this.grid.endAddRow();
                    return;
                }
                this.grid.openRowOverlay(this.row.id);
            }
            var args = newCell.createEditEventArgs(false, event);
            this.grid.cellEditEnter.emit(args);
            if (args.cancel) {
                this.endCellEdit();
                return;
            }
        };
        IgxGridCRUDService.prototype.beginCellEdit = function (newCell, event) {
            var args = newCell.createEditEventArgs(false, event);
            this.grid.cellEditEnter.emit(args);
            this._cellEditingBlocked = args.cancel;
            if (args.cancel) {
                this.endCellEdit();
            }
            else {
                this.cell = newCell;
            }
        };
        /** Exit cell edit mode */
        IgxGridCRUDService.prototype.exitCellEdit = function (event) {
            var _a;
            if (!this.cell) {
                return false;
            }
            var newValue = this.cell.castToNumber(this.cell.editValue);
            var args = (_a = this.cell) === null || _a === void 0 ? void 0 : _a.createDoneEditEventArgs(newValue, event);
            this.cell.value = newValue;
            this.grid.cellEditExit.emit(args);
            this.endCellEdit();
            return false;
        };
        /** Clears cell editing state */
        IgxGridCRUDService.prototype.endCellEdit = function () {
            this.cell = null;
            this.cellEditingBlocked = false;
        };
        /** Clears row editing state */
        IgxGridCRUDService.prototype.endRowEdit = function () {
            this.row = null;
            this.rowEditingBlocked = false;
        };
        /** Clears cell and row editing state and closes row editing template if it is open */
        IgxGridCRUDService.prototype.endEditMode = function () {
            this.endCellEdit();
            if (this.grid.rowEditable) {
                this.endRowEdit();
                this.grid.closeRowEditingOverlay();
            }
        };
        /** Returns whether the targeted cell is in edit mode */
        IgxGridCRUDService.prototype.targetInEdit = function (rowIndex, columnIndex) {
            if (!this.cell) {
                return false;
            }
            var res = this.cell.column.index === columnIndex && this.cell.rowIndex === rowIndex;
            return res;
        };
        return IgxGridCRUDService;
    }());
    IgxGridCRUDService.decorators = [
        { type: i0.Injectable }
    ];
    var IgxGridSelectionService = /** @class */ (function () {
        function IgxGridSelectionService(zone) {
            this.zone = zone;
            this.dragMode = false;
            this.keyboardState = {};
            this.pointerState = {};
            this.columnsState = {};
            this.selection = new Map();
            this.temp = new Map();
            this._ranges = new Set();
            this.rowSelection = new Set();
            this.indeterminateRows = new Set();
            this.columnSelection = new Set();
            /**
             * @hidden @internal
             */
            this.selectedRowsChange = new rxjs.Subject();
            this.initPointerState();
            this.initKeyboardState();
            this.initColumnsState();
        }
        Object.defineProperty(IgxGridSelectionService.prototype, "ranges", {
            /**
             * Returns the current selected ranges in the grid from both
             * keyboard and pointer interactions
             */
            get: function () {
                // The last action was keyboard + shift selection -> add it
                this.addKeyboardRange();
                var ranges = Array.from(this._ranges).map(function (range) { return JSON.parse(range); });
                // No ranges but we have a focused cell -> add it
                if (!ranges.length && this.activeElement && this.grid.isCellSelectable) {
                    ranges.push(this.generateRange(this.activeElement));
                }
                return ranges;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridSelectionService.prototype, "primaryButton", {
            get: function () {
                return this.pointerState.primaryButton;
            },
            set: function (value) {
                this.pointerState.primaryButton = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Resets the keyboard state
         */
        IgxGridSelectionService.prototype.initKeyboardState = function () {
            this.keyboardState.node = null;
            this.keyboardState.shift = false;
            this.keyboardState.range = null;
            this.keyboardState.active = false;
        };
        /**
         * Resets the pointer state
         */
        IgxGridSelectionService.prototype.initPointerState = function () {
            this.pointerState.node = null;
            this.pointerState.ctrl = false;
            this.pointerState.shift = false;
            this.pointerState.range = null;
            this.pointerState.primaryButton = true;
        };
        /**
         * Resets the columns state
         */
        IgxGridSelectionService.prototype.initColumnsState = function () {
            this.columnsState.field = null;
            this.columnsState.range = [];
        };
        /**
         * Adds a single node.
         * Single clicks | Ctrl + single clicks on cells is the usual case.
         */
        IgxGridSelectionService.prototype.add = function (node, addToRange) {
            if (addToRange === void 0) { addToRange = true; }
            if (this.selection.has(node.row)) {
                this.selection.get(node.row).add(node.column);
            }
            else {
                this.selection.set(node.row, new Set()).get(node.row).add(node.column);
            }
            if (addToRange) {
                this._ranges.add(JSON.stringify(this.generateRange(node)));
            }
        };
        /**
         * Adds the active keyboard range selection (if any) to the `ranges` meta.
         */
        IgxGridSelectionService.prototype.addKeyboardRange = function () {
            if (this.keyboardState.range) {
                this._ranges.add(JSON.stringify(this.keyboardState.range));
            }
        };
        IgxGridSelectionService.prototype.remove = function (node) {
            if (this.selection.has(node.row)) {
                this.selection.get(node.row).delete(node.column);
            }
            if (this.isActiveNode(node)) {
                this.activeElement = null;
            }
            this._ranges.delete(JSON.stringify(this.generateRange(node)));
        };
        IgxGridSelectionService.prototype.isInMap = function (node) {
            return (this.selection.has(node.row) && this.selection.get(node.row).has(node.column)) ||
                (this.temp.has(node.row) && this.temp.get(node.row).has(node.column));
        };
        IgxGridSelectionService.prototype.selected = function (node) {
            return (this.isActiveNode(node) && this.grid.isCellSelectable) || this.isInMap(node);
        };
        IgxGridSelectionService.prototype.isActiveNode = function (node) {
            if (this.activeElement) {
                var isActive = this.activeElement.column === node.column && this.activeElement.row === node.row;
                if (this.grid.hasColumnLayouts) {
                    var layout = this.activeElement.layout;
                    return isActive && this.isActiveLayout(layout, node.layout);
                }
                return isActive;
            }
            return false;
        };
        IgxGridSelectionService.prototype.isActiveLayout = function (current, target) {
            return current.columnVisibleIndex === target.columnVisibleIndex;
        };
        IgxGridSelectionService.prototype.addRangeMeta = function (node, state) {
            this._ranges.add(JSON.stringify(this.generateRange(node, state)));
        };
        IgxGridSelectionService.prototype.removeRangeMeta = function (node, state) {
            this._ranges.delete(JSON.stringify(this.generateRange(node, state)));
        };
        /**
         * Generates a new selection range from the given `node`.
         * If `state` is passed instead it will generate the range based on the passed `node`
         * and the start node of the `state`.
         */
        IgxGridSelectionService.prototype.generateRange = function (node, state) {
            if (!state) {
                return {
                    rowStart: node.row,
                    rowEnd: node.row,
                    columnStart: node.column,
                    columnEnd: node.column
                };
            }
            var _b = state.node, row = _b.row, column = _b.column;
            var rowStart = Math.min(node.row, row);
            var rowEnd = Math.max(node.row, row);
            var columnStart = Math.min(node.column, column);
            var columnEnd = Math.max(node.column, column);
            return { rowStart: rowStart, rowEnd: rowEnd, columnStart: columnStart, columnEnd: columnEnd };
        };
        /**
         *
         */
        IgxGridSelectionService.prototype.keyboardStateOnKeydown = function (node, shift, shiftTab) {
            this.keyboardState.active = true;
            this.initPointerState();
            this.keyboardState.shift = shift && !shiftTab;
            if (!this.grid.navigation.isDataRow(node.row)) {
                return;
            }
            // Kb navigation with shift and no previous node.
            // Clear the current selection init the start node.
            if (this.keyboardState.shift && !this.keyboardState.node) {
                this.clear();
                this.keyboardState.node = Object.assign({}, node);
            }
        };
        IgxGridSelectionService.prototype.keyboardStateOnFocus = function (node, emitter, dom) {
            var kbState = this.keyboardState;
            // Focus triggered by keyboard navigation
            if (kbState.active) {
                if (isChromium()) {
                    this._moveSelectionChrome(dom);
                }
                // Start generating a range if shift is hold
                if (kbState.shift) {
                    this.dragSelect(node, kbState);
                    kbState.range = this.generateRange(node, kbState);
                    emitter.emit(this.generateRange(node, kbState));
                    return;
                }
                this.initKeyboardState();
                this.clear();
                this.add(node);
            }
        };
        IgxGridSelectionService.prototype.pointerDown = function (node, shift, ctrl) {
            this.addKeyboardRange();
            this.initKeyboardState();
            this.pointerState.ctrl = ctrl;
            this.pointerState.shift = shift;
            // No ctrl key pressed - no multiple selection
            if (!ctrl) {
                this.clear();
            }
            if (shift) {
                // No previously 'clicked' node. Use the last active node.
                if (!this.pointerState.node) {
                    this.pointerState.node = this.activeElement || node;
                }
                this.pointerDownShiftKey(node);
                this.clearTextSelection();
                return;
            }
            this.removeRangeMeta(node);
            this.pointerState.node = node;
        };
        IgxGridSelectionService.prototype.pointerDownShiftKey = function (node) {
            this.clear();
            this.selectRange(node, this.pointerState);
        };
        IgxGridSelectionService.prototype.mergeMap = function (target, source) {
            var iterator = source.entries();
            var pair = iterator.next();
            var key;
            var value;
            var _loop_1 = function () {
                var _b;
                _b = __read(pair.value, 2), key = _b[0], value = _b[1];
                if (target.has(key)) {
                    var newValue_1 = target.get(key);
                    value.forEach(function (record) { return newValue_1.add(record); });
                    target.set(key, newValue_1);
                }
                else {
                    target.set(key, value);
                }
                pair = iterator.next();
            };
            while (!pair.done) {
                _loop_1();
            }
        };
        IgxGridSelectionService.prototype.pointerEnter = function (node, event) {
            // https://www.w3.org/TR/pointerevents/#the-button-property
            this.dragMode = event.buttons === 1 && (event.button === -1 || event.button === 0);
            if (!this.dragMode) {
                return false;
            }
            this.clearTextSelection();
            // If the users triggers a drag-like event by first clicking outside the grid cells
            // and then enters in the grid body we may not have a initial pointer starting node.
            // Assume the first pointerenter node is where we start.
            if (!this.pointerState.node) {
                this.pointerState.node = node;
            }
            if (this.pointerState.ctrl) {
                this.selectRange(node, this.pointerState, this.temp);
            }
            else {
                this.dragSelect(node, this.pointerState);
            }
            return true;
        };
        IgxGridSelectionService.prototype.pointerUp = function (node, emitter) {
            var _this = this;
            if (this.dragMode) {
                this.restoreTextSelection();
                this.addRangeMeta(node, this.pointerState);
                this.mergeMap(this.selection, this.temp);
                this.zone.runTask(function () { return emitter.emit(_this.generateRange(node, _this.pointerState)); });
                this.temp.clear();
                this.dragMode = false;
                return true;
            }
            if (this.pointerState.shift) {
                this.clearTextSelection();
                this.restoreTextSelection();
                this.addRangeMeta(node, this.pointerState);
                emitter.emit(this.generateRange(node, this.pointerState));
                return true;
            }
            this.add(node);
            return false;
        };
        IgxGridSelectionService.prototype.selectRange = function (node, state, collection) {
            if (collection === void 0) { collection = this.selection; }
            if (collection === this.temp) {
                collection.clear();
            }
            var _b = this.generateRange(node, state), rowStart = _b.rowStart, rowEnd = _b.rowEnd, columnStart = _b.columnStart, columnEnd = _b.columnEnd;
            for (var i = rowStart; i <= rowEnd; i++) {
                for (var j = columnStart; j <= columnEnd; j++) {
                    if (collection.has(i)) {
                        collection.get(i).add(j);
                    }
                    else {
                        collection.set(i, new Set()).get(i).add(j);
                    }
                }
            }
        };
        IgxGridSelectionService.prototype.dragSelect = function (node, state) {
            if (!this.pointerState.ctrl) {
                this.selection.clear();
            }
            this.selectRange(node, state);
        };
        IgxGridSelectionService.prototype.clear = function (clearAcriveEl) {
            if (clearAcriveEl === void 0) { clearAcriveEl = false; }
            if (clearAcriveEl) {
                this.activeElement = null;
            }
            this.selection.clear();
            this.temp.clear();
            this._ranges.clear();
        };
        IgxGridSelectionService.prototype.clearTextSelection = function () {
            var selection = window.getSelection();
            if (selection.rangeCount) {
                this._selectionRange = selection.getRangeAt(0);
                this._selectionRange.collapse(true);
                selection.removeAllRanges();
            }
        };
        IgxGridSelectionService.prototype.restoreTextSelection = function () {
            var selection = window.getSelection();
            if (!selection.rangeCount) {
                selection.addRange(this._selectionRange || document.createRange());
            }
        };
        /**
         * (╯°□°）╯︵ ┻━┻
         * Chrome and Chromium don't care about the active
         * range after keyboard navigation, thus this.
         */
        IgxGridSelectionService.prototype._moveSelectionChrome = function (node) {
            var selection = window.getSelection();
            selection.removeAllRanges();
            var range = new Range();
            range.selectNode(node);
            range.collapse(true);
            selection.addRange(range);
        };
        /** Returns array of the selected row id's. */
        IgxGridSelectionService.prototype.getSelectedRows = function () {
            return this.rowSelection.size ? Array.from(this.rowSelection.keys()) : [];
        };
        /** Returns array of the rows in indeterminate state. */
        IgxGridSelectionService.prototype.getIndeterminateRows = function () {
            return this.indeterminateRows.size ? Array.from(this.indeterminateRows.keys()) : [];
        };
        /** Clears row selection, if filtering is applied clears only selected rows from filtered data. */
        IgxGridSelectionService.prototype.clearRowSelection = function (event) {
            var _this = this;
            var removedRec = this.isFilteringApplied() ?
                this.getRowIDs(this.allData).filter(function (rID) { return _this.isRowSelected(rID); }) : this.getSelectedRows();
            var newSelection = this.isFilteringApplied() ? this.getSelectedRows().filter(function (x) { return !removedRec.includes(x); }) : [];
            this.emitRowSelectionEvent(newSelection, [], removedRec, event);
        };
        /** Select all rows, if filtering is applied select only from filtered data. */
        IgxGridSelectionService.prototype.selectAllRows = function (event) {
            var _this = this;
            var allRowIDs = this.getRowIDs(this.allData);
            var addedRows = allRowIDs.filter(function (rID) { return !_this.isRowSelected(rID); });
            var newSelection = this.rowSelection.size ? this.getSelectedRows().concat(addedRows) : addedRows;
            this.indeterminateRows.clear();
            this.selectedRowsChange.next();
            this.emitRowSelectionEvent(newSelection, addedRows, [], event);
        };
        /** Select the specified row and emit event. */
        IgxGridSelectionService.prototype.selectRowById = function (rowID, clearPrevSelection, event) {
            if (!this.grid.isRowSelectable || this.isRowDeleted(rowID)) {
                return;
            }
            clearPrevSelection = !this.grid.isMultiRowSelectionEnabled || clearPrevSelection;
            var newSelection = clearPrevSelection ? [rowID] : this.getSelectedRows().indexOf(rowID) !== -1 ?
                this.getSelectedRows() : __spread(this.getSelectedRows(), [rowID]);
            var removed = clearPrevSelection ? this.getSelectedRows() : [];
            this.selectedRowsChange.next();
            this.emitRowSelectionEvent(newSelection, [rowID], removed, event);
        };
        /** Deselect the specified row and emit event. */
        IgxGridSelectionService.prototype.deselectRow = function (rowID, event) {
            if (!this.isRowSelected(rowID)) {
                return;
            }
            var newSelection = this.getSelectedRows().filter(function (r) { return r !== rowID; });
            if (this.rowSelection.size && this.rowSelection.has(rowID)) {
                this.selectedRowsChange.next();
                this.emitRowSelectionEvent(newSelection, [], [rowID], event);
            }
        };
        /** Select specified rows. No event is emitted. */
        IgxGridSelectionService.prototype.selectRowsWithNoEvent = function (rowIDs, clearPrevSelection) {
            var _this = this;
            if (clearPrevSelection) {
                this.rowSelection.clear();
            }
            rowIDs.forEach(function (rowID) { return _this.rowSelection.add(rowID); });
            this.allRowsSelected = undefined;
            this.selectedRowsChange.next();
        };
        /** Deselect specified rows. No event is emitted. */
        IgxGridSelectionService.prototype.deselectRowsWithNoEvent = function (rowIDs) {
            var _this = this;
            rowIDs.forEach(function (rowID) { return _this.rowSelection.delete(rowID); });
            this.allRowsSelected = undefined;
            this.selectedRowsChange.next();
        };
        IgxGridSelectionService.prototype.isRowSelected = function (rowID) {
            return this.rowSelection.size > 0 && this.rowSelection.has(rowID);
        };
        IgxGridSelectionService.prototype.isRowInIndeterminateState = function (rowID) {
            return this.indeterminateRows.size > 0 && this.indeterminateRows.has(rowID);
        };
        /** Select range from last selected row to the current specified row. */
        IgxGridSelectionService.prototype.selectMultipleRows = function (rowID, rowData, event) {
            var _this = this;
            this.allRowsSelected = undefined;
            if (!this.rowSelection.size || this.isRowDeleted(rowID)) {
                this.selectRowById(rowID);
                return;
            }
            var gridData = this.allData;
            var lastRowID = this.getSelectedRows()[this.rowSelection.size - 1];
            var currIndex = gridData.indexOf(this.getRowDataById(lastRowID));
            var newIndex = gridData.indexOf(rowData);
            var rows = gridData.slice(Math.min(currIndex, newIndex), Math.max(currIndex, newIndex) + 1);
            var added = this.getRowIDs(rows).filter(function (rID) { return !_this.isRowSelected(rID); });
            var newSelection = this.getSelectedRows().concat(added);
            this.selectedRowsChange.next();
            this.emitRowSelectionEvent(newSelection, added, [], event);
        };
        IgxGridSelectionService.prototype.areAllRowSelected = function () {
            if (!this.grid.data) {
                return false;
            }
            if (this.allRowsSelected !== undefined) {
                return this.allRowsSelected;
            }
            var dataItemsID = this.getRowIDs(this.allData);
            return this.allRowsSelected = Math.min(this.rowSelection.size, dataItemsID.length) > 0 &&
                new Set(Array.from(this.rowSelection.values()).concat(dataItemsID)).size === this.rowSelection.size;
        };
        IgxGridSelectionService.prototype.hasSomeRowSelected = function () {
            var _this = this;
            var filteredData = this.isFilteringApplied() ?
                this.getRowIDs(this.grid.filteredData).some(function (rID) { return _this.isRowSelected(rID); }) : true;
            return this.rowSelection.size > 0 && filteredData && !this.areAllRowSelected();
        };
        Object.defineProperty(IgxGridSelectionService.prototype, "filteredSelectedRowIds", {
            get: function () {
                var _this = this;
                return this.isFilteringApplied() ?
                    this.getRowIDs(this.allData).filter(function (rowID) { return _this.isRowSelected(rowID); }) :
                    this.getSelectedRows().filter(function (rowID) { return !_this.isRowDeleted(rowID); });
            },
            enumerable: false,
            configurable: true
        });
        IgxGridSelectionService.prototype.emitRowSelectionEvent = function (newSelection, added, removed, event) {
            var currSelection = this.getSelectedRows();
            if (this.areEqualCollections(currSelection, newSelection)) {
                return;
            }
            var args = {
                oldSelection: currSelection,
                newSelection: newSelection,
                added: added, removed: removed, event: event,
                cancel: false
            };
            this.grid.onRowSelectionChange.emit(args);
            if (args.cancel) {
                return;
            }
            this.selectRowsWithNoEvent(args.newSelection, true);
        };
        IgxGridSelectionService.prototype.getRowDataById = function (rowID) {
            if (!this.grid.primaryKey) {
                return rowID;
            }
            var rowIndex = this.getRowIDs(this.grid.gridAPI.get_all_data(true)).indexOf(rowID);
            return rowIndex < 0 ? {} : this.grid.gridAPI.get_all_data(true)[rowIndex];
        };
        IgxGridSelectionService.prototype.getRowIDs = function (data) {
            var _this = this;
            return this.grid.primaryKey && data.length ? data.map(function (rec) { return rec[_this.grid.primaryKey]; }) : data;
        };
        IgxGridSelectionService.prototype.clearHeaderCBState = function () {
            this.allRowsSelected = undefined;
        };
        /** Clear rowSelection and update checkbox state */
        IgxGridSelectionService.prototype.clearAllSelectedRows = function () {
            this.rowSelection.clear();
            this.indeterminateRows.clear();
            this.clearHeaderCBState();
            this.selectedRowsChange.next();
        };
        Object.defineProperty(IgxGridSelectionService.prototype, "allData", {
            /** Returns all data in the grid, with applied filtering and sorting and without deleted rows. */
            get: function () {
                var _this = this;
                var allData;
                if (this.isFilteringApplied() || this.grid.sortingExpressions.length) {
                    allData = this.grid.pinnedRecordsCount ? this.grid._filteredSortedUnpinnedData : this.grid.filteredSortedData;
                }
                else {
                    allData = this.grid.gridAPI.get_all_data(true);
                }
                return allData.filter(function (rData) { return !_this.isRowDeleted(_this.grid.gridAPI.get_row_id(rData)); });
            },
            enumerable: false,
            configurable: true
        });
        /** Returns array of the selected columns fields. */
        IgxGridSelectionService.prototype.getSelectedColumns = function () {
            return this.columnSelection.size ? Array.from(this.columnSelection.keys()) : [];
        };
        IgxGridSelectionService.prototype.isColumnSelected = function (field) {
            return this.columnSelection.size > 0 && this.columnSelection.has(field);
        };
        /** Select the specified column and emit event. */
        IgxGridSelectionService.prototype.selectColumn = function (field, clearPrevSelection, selectColumnsRange, event) {
            var stateColumn = this.columnsState.field ? this.grid.getColumnByName(this.columnsState.field) : null;
            if (!event || !stateColumn || stateColumn.visibleIndex < 0 || !selectColumnsRange) {
                this.columnsState.field = field;
                this.columnsState.range = [];
                var newSelection = clearPrevSelection ? [field] : this.getSelectedColumns().indexOf(field) !== -1 ?
                    this.getSelectedColumns() : __spread(this.getSelectedColumns(), [field]);
                var removed = clearPrevSelection ? this.getSelectedColumns().filter(function (colField) { return colField !== field; }) : [];
                var added = this.isColumnSelected(field) ? [] : [field];
                this.emitColumnSelectionEvent(newSelection, added, removed, event);
            }
            else if (selectColumnsRange) {
                this.selectColumnsRange(field, event);
            }
        };
        /** Select specified columns. And emit event. */
        IgxGridSelectionService.prototype.selectColumns = function (fields, clearPrevSelection, selectColumnsRange, event) {
            var _this = this;
            var columns = fields.map(function (f) { return _this.grid.getColumnByName(f); }).sort(function (a, b) { return a.visibleIndex - b.visibleIndex; });
            var stateColumn = this.columnsState.field ? this.grid.getColumnByName(this.columnsState.field) : null;
            if (!stateColumn || stateColumn.visibleIndex < 0 || !selectColumnsRange) {
                this.columnsState.field = columns[0] ? columns[0].field : null;
                this.columnsState.range = [];
                var added = fields.filter(function (colField) { return !_this.isColumnSelected(colField); });
                var removed = clearPrevSelection ? this.getSelectedColumns().filter(function (colField) { return fields.indexOf(colField) === -1; }) : [];
                var newSelection = clearPrevSelection ? fields : this.getSelectedColumns().concat(added);
                this.emitColumnSelectionEvent(newSelection, added, removed, event);
            }
            else {
                var filedStart = stateColumn.visibleIndex >
                    columns[columns.length - 1].visibleIndex ? columns[0].field : columns[columns.length - 1].field;
                this.selectColumnsRange(filedStart, event);
            }
        };
        /** Select range from last clicked column to the current specified column. */
        IgxGridSelectionService.prototype.selectColumnsRange = function (field, event) {
            var _this = this;
            var currIndex = this.grid.getColumnByName(this.columnsState.field).visibleIndex;
            var newIndex = this.grid.columnToVisibleIndex(field);
            var columnsFields = this.grid.visibleColumns
                .filter(function (c) { return !c.columnGroup; })
                .sort(function (a, b) { return a.visibleIndex - b.visibleIndex; })
                .slice(Math.min(currIndex, newIndex), Math.max(currIndex, newIndex) + 1)
                .filter(function (col) { return col.selectable; }).map(function (col) { return col.field; });
            var removed = [];
            var oldAdded = [];
            var added = columnsFields.filter(function (colField) { return !_this.isColumnSelected(colField); });
            this.columnsState.range.forEach(function (f) {
                if (columnsFields.indexOf(f) === -1) {
                    removed.push(f);
                }
                else {
                    oldAdded.push(f);
                }
            });
            this.columnsState.range = columnsFields.filter(function (colField) { return !_this.isColumnSelected(colField) || oldAdded.indexOf(colField) > -1; });
            var newSelection = this.getSelectedColumns().concat(added).filter(function (c) { return removed.indexOf(c) === -1; });
            this.emitColumnSelectionEvent(newSelection, added, removed, event);
        };
        /** Select specified columns. No event is emitted. */
        IgxGridSelectionService.prototype.selectColumnsWithNoEvent = function (fields, clearPrevSelection) {
            var _this = this;
            if (clearPrevSelection) {
                this.columnSelection.clear();
            }
            fields.forEach(function (field) {
                _this.columnSelection.add(field);
            });
        };
        /** Deselect the specified column and emit event. */
        IgxGridSelectionService.prototype.deselectColumn = function (field, event) {
            this.initColumnsState();
            var newSelection = this.getSelectedColumns().filter(function (c) { return c !== field; });
            this.emitColumnSelectionEvent(newSelection, [], [field], event);
        };
        /** Deselect specified columns. No event is emitted. */
        IgxGridSelectionService.prototype.deselectColumnsWithNoEvent = function (fields) {
            var _this = this;
            fields.forEach(function (field) { return _this.columnSelection.delete(field); });
        };
        /** Deselect specified columns. And emit event. */
        IgxGridSelectionService.prototype.deselectColumns = function (fields, event) {
            var removed = this.getSelectedColumns().filter(function (colField) { return fields.indexOf(colField) > -1; });
            var newSelection = this.getSelectedColumns().filter(function (colField) { return fields.indexOf(colField) === -1; });
            this.emitColumnSelectionEvent(newSelection, [], removed, event);
        };
        IgxGridSelectionService.prototype.emitColumnSelectionEvent = function (newSelection, added, removed, event) {
            var currSelection = this.getSelectedColumns();
            if (this.areEqualCollections(currSelection, newSelection)) {
                return;
            }
            var args = {
                oldSelection: currSelection,
                newSelection: newSelection,
                added: added, removed: removed, event: event,
                cancel: false
            };
            this.grid.onColumnSelectionChange.emit(args);
            if (args.cancel) {
                return;
            }
            this.selectColumnsWithNoEvent(args.newSelection, true);
        };
        /** Clear columnSelection */
        IgxGridSelectionService.prototype.clearAllSelectedColumns = function () {
            this.columnSelection.clear();
        };
        IgxGridSelectionService.prototype.areEqualCollections = function (first, second) {
            return first.length === second.length && new Set(first.concat(second)).size === first.length;
        };
        IgxGridSelectionService.prototype.isFilteringApplied = function () {
            var grid = this.grid;
            return !FilteringExpressionsTree.empty(grid.filteringExpressionsTree) ||
                !FilteringExpressionsTree.empty(grid.advancedFilteringExpressionsTree);
        };
        IgxGridSelectionService.prototype.isRowDeleted = function (rowID) {
            return this.grid.gridAPI.row_deleted_transaction(rowID);
        };
        return IgxGridSelectionService;
    }());
    IgxGridSelectionService.decorators = [
        { type: i0.Injectable }
    ];
    IgxGridSelectionService.ctorParameters = function () { return [
        { type: i0.NgZone }
    ]; };
    var isChromium = function () { return (/Chrom|e?ium/g.test(navigator.userAgent) ||
        /Google Inc/g.test(navigator.vendor)) && !/Edge/g.test(navigator.userAgent); };

    var IgxRowDirective = /** @class */ (function () {
        function IgxRowDirective(gridAPI, crudService, selectionService, element, cdr) {
            this.gridAPI = gridAPI;
            this.crudService = crudService;
            this.selectionService = selectionService;
            this.element = element;
            this.cdr = cdr;
            /**
             * @hidden
             */
            this.onAnimationEnd = new i0.EventEmitter();
            /**
             * @hidden
             */
            this.role = 'row';
            /**
             * Sets whether this specific row has disabled functionality for editing and row selection.
             * Default value is `false`.
             * ```typescript
             * this.grid.selectedRows[0].pinned = true;
             * ```
             */
            this.disabled = false;
            /**
             * @hidden
             */
            this.focused = false;
            /**
             * @hidden
             * @internal
             */
            this.defaultCssClass = 'igx-grid__tr';
            /**
             * @hidden
             */
            this.animateAdd = false;
            this.destroy$ = new rxjs.Subject();
        }
        Object.defineProperty(IgxRowDirective.prototype, "rowData", {
            /**
             *  The data passed to the row component.
             *
             * ```typescript
             * // get the row data for the first selected row
             * let selectedRowData = this.grid.selectedRows[0].rowData;
             * ```
             */
            get: function () {
                if (this.inEditMode) {
                    return mergeWith__default['default'](cloneValue(this._rowData), this.grid.transactions.getAggregatedValue(this.rowID, false), function (objValue, srcValue) {
                        if (Array.isArray(srcValue)) {
                            return objValue = srcValue;
                        }
                    });
                }
                return this._rowData;
            },
            set: function (v) {
                this._rowData = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "pinned", {
            /**
             * Gets whether the row is pinned.
             * ```typescript
             * let isPinned = row.pinned;
             * ```
             */
            get: function () {
                return this.grid.isRecordPinned(this.rowData);
            },
            /**
             * Sets whether the row is pinned.
             * Default value is `false`.
             * ```typescript
             * this.grid.selectedRows[0].pinned = true;
             * ```
             */
            set: function (value) {
                if (value) {
                    this.grid.pinRow(this.rowID);
                }
                else {
                    this.grid.unpinRow(this.rowID);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "addRow", {
            get: function () {
                return this._addRow;
            },
            set: function (v) {
                this._addRow = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "rowHeight", {
            get: function () {
                var height = this.grid.rowHeight || 32;
                if (this.grid.hasColumnLayouts) {
                    var maxRowSpan = this.grid.multiRowLayoutRowSize;
                    height = height * maxRowSpan;
                }
                return this.addRow ? height : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "cellHeight", {
            get: function () {
                return this.addRow && !this.inEditMode ? null : this.grid.rowHeight || 32;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "virtDirRow", {
            get: function () {
                return this._virtDirRow ? this._virtDirRow.first : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "cells", {
            /**
             * Gets the rendered cells in the row component.
             *
             * ```typescript
             * // get the cells of the third selected row
             * let selectedRowCells = this.grid.selectedRows[2].cells;
             * ```
             */
            get: function () {
                var res = new i0.QueryList();
                if (!this._cells) {
                    return res;
                }
                var cList = this._cells.filter(function (item) { return item.nativeElement.parentElement !== null; })
                    .sort(function (item1, item2) { return item1.column.visibleIndex - item2.column.visibleIndex; });
                res.reset(cList);
                return res;
            },
            set: function (cells) {
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "dataRowIndex", {
            get: function () {
                return this.index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "styleClasses", {
            /**
             * @hidden
             */
            get: function () {
                return this.resolveClasses();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "selected", {
            /**
             * @hidden
             */
            get: function () {
                return this.selectionService.isRowSelected(this.rowID);
            },
            set: function (value) {
                if (value) {
                    this.selectionService.selectRowsWithNoEvent([this.rowID]);
                }
                else {
                    this.selectionService.deselectRowsWithNoEvent([this.rowID]);
                }
                this.grid.cdr.markForCheck();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "columns", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.visibleColumns;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "viewIndex", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.grid.groupingExpressions.length) {
                    return this.grid.filteredSortedData.indexOf(this.rowData);
                }
                return this.index + this.grid.page * this.grid.perPage;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "pinnedColumns", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.pinnedColumns;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "isRoot", {
            /**
             * @hidden
             */
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "hasChildren", {
            /**
             * @hidden
             */
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "unpinnedColumns", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.unpinnedColumns;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "showRowSelectors", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.showRowSelectors;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "dirty", {
            /** @hidden */
            get: function () {
                var row = this.grid.transactions.getState(this.rowID);
                if (row) {
                    return row.type === exports.TransactionType.ADD || row.type === exports.TransactionType.UPDATE;
                }
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "rowDraggable", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.rowDraggable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "added", {
            /** @hidden */
            get: function () {
                var row = this.grid.transactions.getState(this.rowID);
                if (row) {
                    return row.type === exports.TransactionType.ADD;
                }
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "deleted", {
            /** @hidden */
            get: function () {
                return this.gridAPI.row_deleted_transaction(this.rowID);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "dragging", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.dragRowID === this.rowID;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "inEditMode", {
            // TODO: Refactor
            get: function () {
                if (this.grid.rowEditable) {
                    var editRowState = this.crudService.row;
                    return (editRowState && editRowState.id === this.rowID) || false;
                }
                else {
                    return false;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "grid", {
            /**
             * Get a reference to the grid that contains the selected row.
             *
             * ```typescript
             * handleRowSelection(event) {
             *  // the grid on which the onRowSelectionChange event was triggered
             *  const grid = event.row.grid;
             * }
             * ```
             *
             * ```html
             *  <igx-grid
             *    [data]="data"
             *    (onRowSelectionChange)="handleRowSelection($event)">
             *  </igx-grid>
             * ```
             */
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "rowID", {
            /**
             * Gets the ID of the row.
             * A row in the grid is identified either by:
             * - primaryKey data value,
             * - the whole rowData, if the primaryKey is omitted.
             *
             * ```typescript
             * let rowID = this.grid.selectedRows[2].rowID;
             * ```
             */
            get: function () {
                var primaryKey = this.grid.primaryKey;
                return primaryKey ? this._rowData[primaryKey] : this._rowData;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "nativeElement", {
            /**
             * The native DOM element representing the row. Could be null in certain environments.
             *
             * ```typescript
             * // get the nativeElement of the second selected row
             * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
             * ```
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxRowDirective.prototype.onClick = function (event) {
            if (this.grid.rowSelection === 'none' || this.deleted || !this.grid.selectRowOnClick) {
                return;
            }
            if (event.shiftKey && this.grid.isMultiRowSelectionEnabled) {
                this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
                return;
            }
            this.selectionService.selectRowById(this.rowID, !event.ctrlKey, event);
        };
        /**
         * @hidden
         * @internal
         */
        IgxRowDirective.prototype.showActionStrip = function () {
            if (this.grid.actionStrip) {
                this.grid.actionStrip.show(this);
            }
        };
        IgxRowDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            // If the template of the row changes, the forOf in it is recreated and is not detected by the grid and rows can't be scrolled.
            this._virtDirRow.changes.pipe(operators.takeUntil(this.destroy$)).subscribe(function () { return _this.grid.resetHorizontalForOfs(); });
        };
        IgxRowDirective.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden
         */
        IgxRowDirective.prototype.onRowSelectorClick = function (event) {
            event.stopPropagation();
            if (event.shiftKey && this.grid.isMultiRowSelectionEnabled) {
                this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
                return;
            }
            if (this.selected) {
                this.selectionService.deselectRow(this.rowID, event);
            }
            else {
                this.selectionService.selectRowById(this.rowID, false, event);
            }
        };
        /**
         * Updates the specified row object and the data source record with the passed value.
         * This method emits `onEditDone` event.
         *
         * ```typescript
         * // update the second selected row's value
         * let newValue = "Apple";
         * this.grid.selectedRows[1].update(newValue);
         * ```
         */
        IgxRowDirective.prototype.update = function (value) {
            var crudService = this.crudService;
            if (crudService.cellInEditMode && crudService.cell.id.rowID === this.rowID) {
                this.grid.endEdit(false);
            }
            var row = new IgxRow(this.rowID, this.index, this.rowData, this.grid);
            this.gridAPI.update_row(row, value);
            this.cdr.markForCheck();
        };
        /**
         * Removes the specified row from the grid's data source.
         * This method emits `onRowDeleted` event.
         *
         * ```typescript
         * // delete the third selected row from the grid
         * this.grid.selectedRows[2].delete();
         * ```
         */
        IgxRowDirective.prototype.delete = function () {
            this.grid.deleteRowById(this.rowID);
        };
        IgxRowDirective.prototype.isCellActive = function (visibleColumnIndex) {
            var node = this.grid.navigation.activeNode;
            return node ? node.row === this.index && node.column === visibleColumnIndex : false;
        };
        /**
         * Pins the specified row.
         * This method emits `onRowPinning` event.
         *
         * ```typescript
         * // pin the selected row from the grid
         * this.grid.selectedRows[0].pin();
         * ```
         */
        IgxRowDirective.prototype.pin = function () {
            return this.grid.pinRow(this.rowID);
        };
        /**
         * Unpins the specified row.
         * This method emits `onRowPinning` event.
         *
         * ```typescript
         * // unpin the selected row from the grid
         * this.grid.selectedRows[0].unpin();
         * ```
         */
        IgxRowDirective.prototype.unpin = function () {
            return this.grid.unpinRow(this.rowID);
        };
        Object.defineProperty(IgxRowDirective.prototype, "rowCheckboxAriaLabel", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.primaryKey ?
                    this.selected ? 'Deselect row with key ' + this.rowID : 'Select row with key ' + this.rowID :
                    this.selected ? 'Deselect row' : 'Select row';
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxRowDirective.prototype.ngDoCheck = function () {
            this.cdr.markForCheck();
        };
        /**
         * @hidden
         */
        IgxRowDirective.prototype.shouldDisplayPinnedChip = function (visibleColumnIndex) {
            return this.pinned && this.disabled && visibleColumnIndex === 0;
        };
        IgxRowDirective.prototype.animationEndHandler = function () {
            this.onAnimationEnd.emit(this);
        };
        /**
         * Spawns the add row UI for the specific row.
         *
         * @example
         * ```typescript
         * const row = this.grid1.getRowByIndex(1);
         * row.beginAddRow();
         * ```
         */
        IgxRowDirective.prototype.beginAddRow = function () {
            this.grid.beginAddRowByIndex(this.rowID, this.index);
        };
        /**
         * @hidden
         */
        IgxRowDirective.prototype.resolveClasses = function () {
            var indexClass = this.index % 2 ? this.grid.evenRowCSS : this.grid.oddRowCSS;
            var selectedClass = this.selected ? 'igx-grid__tr--selected' : '';
            var editClass = this.inEditMode ? 'igx-grid__tr--edit' : '';
            var dirtyClass = this.dirty ? 'igx-grid__tr--edited' : '';
            var deletedClass = this.deleted ? 'igx-grid__tr--deleted' : '';
            var mrlClass = this.grid.hasColumnLayouts ? 'igx-grid__tr--mrl' : '';
            var dragClass = this.dragging ? 'igx-grid__tr--drag' : '';
            return (this.defaultCssClass + " " + indexClass + " " + selectedClass + " " + editClass + " " + dirtyClass + "\n         " + deletedClass + " " + mrlClass + " " + dragClass).trim();
        };
        Object.defineProperty(IgxRowDirective.prototype, "resolveDragIndicatorClasses", {
            /**
             * @hidden
             */
            get: function () {
                var defaultDragIndicatorCssClass = 'igx-grid__drag-indicator';
                var dragIndicatorOff = this.grid.rowDragging && !this.dragging ? 'igx-grid__drag-indicator--off' : '';
                return defaultDragIndicatorCssClass + " " + dragIndicatorOff;
            },
            enumerable: false,
            configurable: true
        });
        return IgxRowDirective;
    }());
    IgxRowDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxRowBaseComponent]'
                },] }
    ];
    IgxRowDirective.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: IgxGridCRUDService },
        { type: IgxGridSelectionService },
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxRowDirective.propDecorators = {
        onAnimationEnd: [{ type: i0.Output }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        rowData: [{ type: i0.Input }],
        index: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.aria-disabled',] }, { type: i0.HostBinding, args: ['class.igx-grid__tr--disabled',] }],
        addRow: [{ type: i0.Input }],
        rowHeight: [{ type: i0.HostBinding, args: ['style.min-height.px',] }],
        gridID: [{ type: i0.Input }],
        _virtDirRow: [{ type: i0.ViewChildren, args: ['igxDirRef', { read: IgxGridForOfDirective },] }],
        checkboxElement: [{ type: i0.ViewChild, args: [i0.forwardRef(function () { return IgxCheckboxComponent; }), { read: IgxCheckboxComponent },] }],
        _cells: [{ type: i0.ViewChildren, args: ['cell',] }],
        dataRowIndex: [{ type: i0.HostBinding, args: ['attr.data-rowIndex',] }],
        styleClasses: [{ type: i0.HostBinding, args: ['class',] }],
        selected: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.aria-selected',] }],
        onClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }],
        showActionStrip: [{ type: i0.HostListener, args: ['mouseenter',] }]
    };

    var IgxGridActionsBaseDirective = /** @class */ (function () {
        function IgxGridActionsBaseDirective(iconService, differs) {
            this.iconService = iconService;
            this.differs = differs;
            /**
             * Gets/Sets if the action buttons will be rendered as menu items. When in menu, items will be rendered with text label.
             *
             * @example
             * ```html
             *  <igx-grid-pinning-actions [asMenuItems]='true'></igx-grid-pinning-actions>
             *  <igx-grid-editing-actions [asMenuItems]='true'></igx-grid-editing-actions>
             * ```
             */
            this.asMenuItems = false;
        }
        Object.defineProperty(IgxGridActionsBaseDirective.prototype, "grid", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.strip.context.grid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridActionsBaseDirective.prototype, "isRowContext", {
            /**
             * Getter to be used in template
             *
             * @hidden
             * @internal
             */
            get: function () {
                return this.isRow(this.strip.context) && !this.strip.context.inEditMode;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxGridActionsBaseDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this.asMenuItems) {
                this.buttons.changes.subscribe(function () {
                    _this.strip.cdr.detectChanges();
                });
            }
        };
        /**
         * Check if the param is a row from a grid
         *
         * @hidden
         * @internal
         * @param context
         */
        IgxGridActionsBaseDirective.prototype.isRow = function (context) {
            return context && context instanceof IgxRowDirective;
        };
        return IgxGridActionsBaseDirective;
    }());
    IgxGridActionsBaseDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxGridActionsBase]'
                },] }
    ];
    IgxGridActionsBaseDirective.ctorParameters = function () { return [
        { type: IgxIconService },
        { type: i0.IterableDiffers }
    ]; };
    IgxGridActionsBaseDirective.propDecorators = {
        buttons: [{ type: i0.ViewChildren, args: [IgxGridActionButtonComponent,] }],
        asMenuItems: [{ type: i0.Input }]
    };

    var IgxGridEditingActionsComponent = /** @class */ (function (_super) {
        __extends(IgxGridEditingActionsComponent, _super);
        function IgxGridEditingActionsComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            /**
             * Host `class.igx-action-strip` binding.
             *
             * @hidden
             * @internal
             */
            _this.cssClass = 'igx-action-strip__editing-actions';
            /**
             * An input to enable/disable action strip child row adding button
             */
            _this.addChild = false;
            _this.isMessageShown = false;
            _this._addRow = false;
            _this.iconsRendered = false;
            return _this;
        }
        Object.defineProperty(IgxGridEditingActionsComponent.prototype, "addRow", {
            get: function () {
                if (!this.iconsRendered) {
                    this.registerIcons();
                    this.iconsRendered = true;
                }
                return this._addRow;
            },
            /**
             * An input to enable/disable action strip row adding button
             */
            set: function (value) {
                this._addRow = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridEditingActionsComponent.prototype, "disabled", {
            /**
             * Getter if the row is disabled
             *
             * @hidden
             * @internal
             */
            get: function () {
                if (!this.isRow(this.strip.context)) {
                    return;
                }
                return this.strip.context.disabled;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridEditingActionsComponent.prototype, "isRootRow", {
            /**
             * Getter if the row is root.
             *
             * @hidden
             * @internal
             */
            get: function () {
                if (!this.isRow(this.strip.context)) {
                    return false;
                }
                return this.strip.context.isRoot;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridEditingActionsComponent.prototype, "hasChildren", {
            get: function () {
                if (!this.isRow(this.strip.context)) {
                    return false;
                }
                return this.strip.context.hasChildren;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Enter row or cell edit mode depending the grid rowEditable option
         *
         * @example
         * ```typescript
         * this.gridEditingActions.startEdit();
         * ```
         */
        IgxGridEditingActionsComponent.prototype.startEdit = function (event) {
            if (event) {
                event.stopPropagation();
            }
            if (!this.isRow(this.strip.context)) {
                return;
            }
            var row = this.strip.context;
            var firstEditable = row.cells.filter(function (cell) { return cell.editable; })[0];
            var grid = row.grid;
            if (!grid.hasEditableColumns) {
                this.isMessageShown = showMessage('The grid should be editable in order to use IgxGridEditingActionsComponent', this.isMessageShown);
                return;
            }
            // be sure row is in view
            if (grid.rowList.filter(function (r) { return r === row; }).length !== 0) {
                grid.crudService.enterEditMode(firstEditable, event);
            }
            this.strip.hide();
        };
        /**
         * Delete a row according to the context
         *
         * @example
         * ```typescript
         * this.gridEditingActions.deleteRow();
         * ```
         */
        IgxGridEditingActionsComponent.prototype.deleteRow = function (event) {
            if (event) {
                event.stopPropagation();
            }
            if (!this.isRow(this.strip.context)) {
                return;
            }
            var context = this.strip.context;
            var grid = context.grid;
            grid.deleteRow(context.rowID);
            this.strip.hide();
        };
        IgxGridEditingActionsComponent.prototype.addRowHandler = function (event, asChild) {
            if (event) {
                event.stopPropagation();
            }
            if (!this.isRow(this.strip.context)) {
                return;
            }
            var context = this.strip.context;
            var grid = context.grid;
            if (!grid.rowEditable) {
                console.warn('The grid must use row edit mode to perform row adding! Please set rowEditable to true.');
                return;
            }
            grid.beginAddRowByIndex(context.rowID, context.index, asChild, event);
            this.strip.hide();
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridEditingActionsComponent.prototype.registerIcons = function () {
            this.iconService.addSvgIconFromText(materialIconsExtended.addRow.name, materialIconsExtended.addRow.value, 'imx-icons');
            this.iconService.addSvgIconFromText(materialIconsExtended.addChild.name, materialIconsExtended.addChild.value, 'imx-icons');
        };
        return IgxGridEditingActionsComponent;
    }(IgxGridActionsBaseDirective));
    IgxGridEditingActionsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-grid-editing-actions',
                    template: "\n<ng-container *ngIf=\"isRowContext\">\n    <igx-grid-action-button *ngIf=\"!disabled\" [asMenuItem]=\"asMenuItems\" iconName=\"edit\" [labelText]=\"grid.resourceStrings.igx_grid_actions_edit_label\" (actionClick)=\"startEdit($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"addRow && isRootRow\" [asMenuItem]=\"asMenuItems\" iconName=\"add-row\" iconSet=\"imx-icons\" [labelText]=\"grid.resourceStrings.igx_grid_actions_add_label\" (actionClick)=\"addRowHandler($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"addChild && hasChildren\" [asMenuItem]=\"asMenuItems\" iconName=\"add-child\" iconSet=\"imx-icons\" [labelText]=\"grid.resourceStrings.igx_grid_actions_add_child_label\" (actionClick)=\"addRowHandler($event, true)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"!disabled\" class=\"igx-action-strip__delete\" classNames='igx-action-strip__menu-item--danger' [asMenuItem]=\"asMenuItems\" iconName=\"delete\" [labelText]=\"grid.resourceStrings.igx_grid_actions_delete_label\" (actionClick)=\"deleteRow($event)\"></igx-grid-action-button>\n</ng-container>\n\n",
                    providers: [{ provide: IgxGridActionsBaseDirective, useExisting: IgxGridEditingActionsComponent }]
                },] }
    ];
    IgxGridEditingActionsComponent.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-action-strip__editing-actions',] }],
        addRow: [{ type: i0.Input }],
        addChild: [{ type: i0.Input }]
    };

    var IgxGridPinningActionsComponent = /** @class */ (function (_super) {
        __extends(IgxGridPinningActionsComponent, _super);
        function IgxGridPinningActionsComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            /**
             * Host `class.igx-action-strip` binding.
             *
             * @hidden
             * @internal
             */
            _this.cssClass = 'igx-action-strip__pinning-actions';
            _this.iconsRendered = false;
            return _this;
        }
        Object.defineProperty(IgxGridPinningActionsComponent.prototype, "pinned", {
            /**
             * Getter to know if the row is pinned
             *
             * @hidden
             * @internal
             */
            get: function () {
                if (!this.isRow(this.strip.context)) {
                    return;
                }
                var context = this.strip.context;
                if (context && !this.iconsRendered) {
                    this.registerSVGIcons();
                    this.iconsRendered = true;
                }
                return context && context.pinned;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridPinningActionsComponent.prototype, "inPinnedArea", {
            /**
             * Getter to know if the row is in pinned and ghost
             *
             * @hidden
             * @internal
             */
            get: function () {
                if (!this.isRow(this.strip.context)) {
                    return;
                }
                var context = this.strip.context;
                return this.pinned && !context.disabled;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridPinningActionsComponent.prototype, "pinnedTop", {
            /**
             * Getter to know if the row pinning is set to top or bottom
             *
             * @hidden
             * @internal
             */
            get: function () {
                if (!this.isRow(this.strip.context)) {
                    return;
                }
                return this.strip.context.grid.isRowPinningToTop;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Pin the row according to the context.
         *
         * @example
         * ```typescript
         * this.gridPinningActions.pin();
         * ```
         */
        IgxGridPinningActionsComponent.prototype.pin = function (event) {
            if (event) {
                event.stopPropagation();
            }
            if (!this.isRow(this.strip.context)) {
                return;
            }
            var row = this.strip.context;
            var grid = row.grid;
            grid.pinRow(row.rowID);
            this.strip.hide();
        };
        /**
         * Unpin the row according to the context.
         *
         * @example
         * ```typescript
         * this.gridPinningActions.unpin();
         * ```
         */
        IgxGridPinningActionsComponent.prototype.unpin = function (event) {
            if (event) {
                event.stopPropagation();
            }
            if (!this.isRow(this.strip.context)) {
                return;
            }
            var row = this.strip.context;
            var grid = row.grid;
            grid.unpinRow(row.rowID);
            this.strip.hide();
        };
        IgxGridPinningActionsComponent.prototype.scrollToRow = function (event) {
            if (event) {
                event.stopPropagation();
            }
            var context = this.strip.context;
            var grid = context.grid;
            grid.scrollTo(context.rowData, 0);
            this.strip.hide();
        };
        IgxGridPinningActionsComponent.prototype.registerSVGIcons = function () {
            if (!this.isRow(this.strip.context)) {
                return;
            }
            var context = this.strip.context;
            var grid = context.grid;
            if (grid) {
                this.iconService.addSvgIconFromText(materialIconsExtended.pinLeft.name, materialIconsExtended.pinLeft.value, 'imx-icons');
                this.iconService.addSvgIconFromText(materialIconsExtended.unpinLeft.name, materialIconsExtended.unpinLeft.value, 'imx-icons');
                this.iconService.addSvgIconFromText(materialIconsExtended.jumpDown.name, materialIconsExtended.jumpDown.value, 'imx-icons');
                this.iconService.addSvgIconFromText(materialIconsExtended.jumpUp.name, materialIconsExtended.jumpDown.value, 'imx-icons');
            }
        };
        return IgxGridPinningActionsComponent;
    }(IgxGridActionsBaseDirective));
    IgxGridPinningActionsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-grid-pinning-actions',
                    template: "<ng-container *ngIf=\"isRowContext\">\n    <igx-grid-action-button *ngIf=\"inPinnedArea && pinnedTop\" [asMenuItem]=\"asMenuItems\" iconSet=\"imx-icons\" iconName=\"jump-down\" [labelText]=\"grid.resourceStrings.igx_grid_actions_jumpDown_label\" (actionClick)=\"scrollToRow($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"inPinnedArea && !pinnedTop\" [asMenuItem]=\"asMenuItems\" iconSet=\"imx-icons\" iconName=\"jump-up\" [labelText]=\"grid.resourceStrings.igx_grid_actions_jumpUp_label\" (actionClick)=\"scrollToRow($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"!pinned\" [asMenuItem]=\"asMenuItems\" iconSet=\"imx-icons\" iconName=\"pin-left\" [labelText]=\"grid.resourceStrings.igx_grid_actions_pin_label\" (actionClick)=\"pin($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"pinned\" [asMenuItem]=\"asMenuItems\" iconSet=\"imx-icons\" iconName=\"unpin-left\" [labelText]=\"grid.resourceStrings.igx_grid_actions_unpin_label\" (actionClick)=\"unpin($event)\"></igx-grid-action-button>\n</ng-container>",
                    providers: [{ provide: IgxGridActionsBaseDirective, useExisting: IgxGridPinningActionsComponent }]
                },] }
    ];
    IgxGridPinningActionsComponent.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-action-strip__pinning-actions',] }]
    };

    var IgxActionStripMenuItemDirective = /** @class */ (function () {
        function IgxActionStripMenuItemDirective(templateRef) {
            this.templateRef = templateRef;
        }
        return IgxActionStripMenuItemDirective;
    }());
    IgxActionStripMenuItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxActionStripMenuItem]'
                },] }
    ];
    IgxActionStripMenuItemDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    /**
     * Action Strip provides templatable area for one or more actions.
     *
     * @igxModule IgxActionStripModule
     *
     * @igxTheme igx-action-strip-theme
     *
     * @igxKeywords action, strip, actionStrip, pinning, editing
     *
     * @igxGroup Data Entry & Display
     *
     * @remarks
     * The Ignite UI Action Strip is a container, overlaying its parent container,
     * and displaying action buttons with action applicable to the parent component the strip is instantiated or shown for.
     *
     * @example
     * ```html
     * <igx-action-strip #actionStrip>
     *     <igx-icon (click)="doSomeAction()"></igx-icon>
     * </igx-action-strip>
     */
    var IgxActionStripComponent = /** @class */ (function (_super) {
        __extends(IgxActionStripComponent, _super);
        function IgxActionStripComponent(_viewContainer, renderer, _displayDensityOptions, cdr) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this._viewContainer = _viewContainer;
            _this.renderer = renderer;
            _this._displayDensityOptions = _displayDensityOptions;
            _this.cdr = cdr;
            /**
             * Getter for menu overlay settings
             *
             * @hidden
             * @internal
             */
            _this.menuOverlaySettings = { scrollStrategy: new CloseScrollStrategy() };
            _this._hidden = false;
            return _this;
        }
        Object.defineProperty(IgxActionStripComponent.prototype, "hidden", {
            get: function () {
                return this._hidden;
            },
            /**
             * An @Input property that set the visibility of the Action Strip.
             * Could be used to set if the Action Strip will be initially hidden.
             *
             * @example
             * ```html
             *  <igx-action-strip [hidden]="false">
             * ```
             */
            set: function (value) {
                this._hidden = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxActionStripComponent.prototype, "display", {
            /**
             * Getter for the 'display' property of the current `IgxActionStrip`
             *
             * @hidden
             * @internal
             */
            get: function () {
                return this._hidden ? 'none' : 'flex';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxActionStripComponent.prototype, "hostClasses", {
            /**
             * Host `attr.class` binding.
             *
             * @hidden
             * @internal
             */
            get: function () {
                var classes = [this.getComponentDensityClass('igx-action-strip')];
                // The custom classes should be at the end.
                if (!classes.includes('igx-action-strip')) {
                    classes.push('igx-action-strip');
                }
                classes.push(this.hostClass);
                return classes.join(' ');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxActionStripComponent.prototype, "menuItems", {
            /**
             * Menu Items list.
             *
             * @hidden
             * @internal
             */
            get: function () {
                var actions = [];
                this.actionButtons.forEach(function (button) {
                    if (button.asMenuItems) {
                        var children = button.buttons;
                        if (children) {
                            children.toArray().forEach(function (x) { return actions.push(x); });
                        }
                    }
                });
                return __spread(this._menuItems.toArray(), actions);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxActionStripComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.actionButtons.forEach(function (button) {
                button.strip = _this;
            });
            this.actionButtons.changes.subscribe(function () {
                _this.actionButtons.forEach(function (button) {
                    button.strip = _this;
                });
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxActionStripComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.menu.onSelection.subscribe(function ($event) {
                var newSelection = $event.newSelection.elementRef.nativeElement;
                var allButtons = [];
                _this.actionButtons.forEach(function (actionButtons) {
                    if (actionButtons.asMenuItems) {
                        allButtons = __spread(allButtons, actionButtons.buttons.toArray());
                    }
                });
                var button = allButtons.find(function (x) { return newSelection.contains(x.container.nativeElement); });
                if (button) {
                    button.actionClick.emit();
                }
            });
        };
        /**
         * Showing the Action Strip and appending it the specified context element.
         *
         * @param context
         * @example
         * ```typescript
         * this.actionStrip.show(row);
         * ```
         */
        IgxActionStripComponent.prototype.show = function (context) {
            this.hidden = false;
            if (!context) {
                return;
            }
            // when shown for different context make sure the menu won't stay opened
            if (this.context !== context) {
                this.closeMenu();
            }
            this.context = context;
            if (this.context && this.context.element) {
                this.renderer.appendChild(context.element.nativeElement, this._viewContainer.element.nativeElement);
            }
            this.cdr.detectChanges();
        };
        /**
         * Hiding the Action Strip and removing it from its current context element.
         *
         * @example
         * ```typescript
         * this.actionStrip.hide();
         * ```
         */
        IgxActionStripComponent.prototype.hide = function () {
            this.hidden = true;
            this.closeMenu();
            if (this.context && this.context.element) {
                this.renderer.removeChild(this.context.element.nativeElement, this._viewContainer.element.nativeElement);
            }
        };
        /**
         * Close the menu if opened
         *
         * @hidden
         * @internal
         */
        IgxActionStripComponent.prototype.closeMenu = function () {
            if (this.menu && !this.menu.collapsed) {
                this.menu.close();
            }
        };
        return IgxActionStripComponent;
    }(DisplayDensityBase));
    IgxActionStripComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-action-strip',
                    template: "<div class=\"igx-action-strip__actions\">\n    <ng-content #content></ng-content>\n    <ng-container *ngIf=\"menuItems.length > 0\">\n        <button\n            igxButton=\"icon\"\n            igxRipple\n            [igxToggleAction]=\"dropdown\"\n            [overlaySettings]=\"menuOverlaySettings\"\n            (click)=\"$event.stopPropagation()\"\n            [igxDropDownItemNavigation]=\"dropdown\"\n        >\n            <igx-icon>more_vert</igx-icon>\n        </button>\n    </ng-container>\n    <igx-drop-down #dropdown [displayDensity]=\"displayDensity\">\n        <igx-drop-down-item\n            *ngFor=\"let item of menuItems\"\n            class=\"igx-action-strip__menu-item\"\n        >\n            <div class=\"igx-drop-down__item-template\">\n                <ng-container\n                    *ngTemplateOutlet=\"\n                        item.templateRef;\n                        context: { $implicit: item }\n                    \"\n                ></ng-container>\n            </div>\n        </igx-drop-down-item>\n    </igx-drop-down>\n</div>\n"
                },] }
    ];
    IgxActionStripComponent.ctorParameters = function () { return [
        { type: i0.ViewContainerRef },
        { type: i0.Renderer2 },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] },
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxActionStripComponent.propDecorators = {
        context: [{ type: i0.Input }],
        _menuItems: [{ type: i0.ContentChildren, args: [IgxActionStripMenuItemDirective,] }],
        actionButtons: [{ type: i0.ContentChildren, args: [IgxGridActionsBaseDirective,] }],
        hidden: [{ type: i0.Input }],
        hostClass: [{ type: i0.Input, args: ['class',] }],
        menu: [{ type: i0.ViewChild, args: ['dropdown',] }],
        display: [{ type: i0.HostBinding, args: ['style.display',] }],
        hostClasses: [{ type: i0.HostBinding, args: ['attr.class',] }]
    };

    /**
     * @hidden
     */
    var IgxActionStripModule = /** @class */ (function () {
        function IgxActionStripModule() {
        }
        return IgxActionStripModule;
    }());
    IgxActionStripModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxActionStripComponent,
                        IgxActionStripMenuItemDirective,
                        IgxGridPinningActionsComponent,
                        IgxGridEditingActionsComponent,
                        IgxGridActionsBaseDirective,
                        IgxGridActionButtonComponent
                    ],
                    entryComponents: [],
                    exports: [
                        IgxActionStripComponent,
                        IgxActionStripMenuItemDirective,
                        IgxGridPinningActionsComponent,
                        IgxGridEditingActionsComponent,
                        IgxGridActionsBaseDirective,
                        IgxGridActionButtonComponent
                    ],
                    imports: [i2.CommonModule, IgxDropDownModule, IgxToggleModule, IgxButtonModule, IgxIconModule, IgxRippleModule]
                },] }
    ];

    var NEXT_ID$6 = 0;
    var IgxAvatarSize = mkenum({
        SMALL: 'small',
        MEDIUM: 'medium',
        LARGE: 'large'
    });
    var IgxAvatarType = mkenum({
        INITIALS: 'initials',
        IMAGE: 'image',
        ICON: 'icon',
        CUSTOM: 'custom'
    });
    /**
     * Avatar provides a way to display an image, icon or initials to the user.
     *
     * @igxModule IgxAvatarModule
     *
     * @igxTheme igx-avatar-theme, igx-icon-theme
     *
     * @igxKeywords avatar, profile, picture, initials
     *
     * @igxGroup Layouts
     *
     * @remarks
     *
     * The Ignite UI Avatar provides an easy way to add an avatar icon to your application.  This icon can be an
     * image, someone's initials or a material icon from the Google Material icon set.
     *
     * @example
     * ```html
     * <igx-avatar initials="MS" [roundShape]="true" size="large">
     * </igx-avatar>
     * ```
     */
    var IgxAvatarComponent = /** @class */ (function () {
        function IgxAvatarComponent(elementRef) {
            this.elementRef = elementRef;
            /**
             * Returns the `aria-label` attribute of the avatar.
             *
             * @example
             * ```typescript
             * let ariaLabel = this.avatar.ariaLabel;
             * ```
             *
             */
            this.ariaLabel = 'avatar';
            /**
             * Returns the `role` attribute of the avatar.
             *
             * @example
             * ```typescript
             * let avatarRole = this.avatar.role;
             * ```
             */
            this.role = 'img';
            /**
             * Host `class.igx-avatar` binding.
             *
             * @hidden
             * @internal
             */
            this.cssClass = 'igx-avatar';
            /**
             * Sets the `id` of the avatar. If not set, the first avatar component will have `id` = `"igx-avatar-0"`.
             *
             * @example
             * ```html
             * <igx-avatar id="my-first-avatar"></igx-avatar>
             * ```
             */
            this.id = "igx-avatar-" + NEXT_ID$6++;
            /**
             * Sets a round shape to the avatar, if `[roundShape]` is set to `true`.
             * By default the shape of the avatar is a square.
             *
             * @example
             * ```html
             * <igx-avatar [roundShape]="true" ></igx-avatar>
             * ```
             */
            this.roundShape = false;
            /**
             * @hidden
             * @internal
             */
            this._size = IgxAvatarSize.SMALL;
        }
        Object.defineProperty(IgxAvatarComponent.prototype, "size", {
            /**
             * Returns the size of the avatar.
             *
             * @example
             * ```typescript
             * let avatarSize = this.avatar.size;
             * ```
             */
            get: function () {
                return this._size;
            },
            /**
             * Sets the size  of the avatar.
             * By default, the size is `"small"`. It can be set to `"medium"` or `"large"`.
             *
             * @example
             * ```html
             * <igx-avatar size="large"></igx-avatar>
             * ```
             */
            set: function (value) {
                switch (value) {
                    case 'small':
                    case 'medium':
                    case 'large':
                        this._size = value;
                        break;
                    default:
                        this._size = 'small';
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAvatarComponent.prototype, "_isSmallSize", {
            /** @hidden @internal */
            get: function () {
                return this.size === 'small';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAvatarComponent.prototype, "_isMediumSize", {
            /** @hidden @internal */
            get: function () {
                return this.size === 'medium';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAvatarComponent.prototype, "_isLargeSize", {
            /** @hidden @internal */
            get: function () {
                return this.size === 'large';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAvatarComponent.prototype, "type", {
            /**
             * Returns the type of the avatar.
             *
             * @example
             * ```typescript
             * let avatarType = this.avatar.type;
             * ```
             */
            get: function () {
                if (this.src) {
                    return IgxAvatarType.IMAGE;
                }
                if (this.icon) {
                    return IgxAvatarType.ICON;
                }
                if (this.initials) {
                    return IgxAvatarType.INITIALS;
                }
                return IgxAvatarType.CUSTOM;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAvatarComponent.prototype, "_isImageType", {
            /** @hidden @internal */
            get: function () {
                return this.type === IgxAvatarType.IMAGE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAvatarComponent.prototype, "_isIconType", {
            /** @hidden @internal */
            get: function () {
                return this.type === IgxAvatarType.ICON;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAvatarComponent.prototype, "_isInitialsType", {
            /** @hidden @internal */
            get: function () {
                return this.type === IgxAvatarType.INITIALS;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAvatarComponent.prototype, "template", {
            /**
             * Returns the template of the avatar.
             *
             * @hidden
             * @internal
             */
            get: function () {
                switch (this.type) {
                    case IgxAvatarType.IMAGE:
                        return this.imageTemplate;
                    case IgxAvatarType.INITIALS:
                        return this.initialsTemplate;
                    case IgxAvatarType.ICON:
                        return this.iconTemplate;
                    default:
                        return this.defaultTemplate;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns the css url of the image.
         *
         * @hidden
         * @internal
         */
        IgxAvatarComponent.prototype.getSrcUrl = function () {
            return "url(" + this.src + ")";
        };
        /** @hidden @internal */
        IgxAvatarComponent.prototype.ngOnInit = function () {
            this.roleDescription = this.getRole();
        };
        /** @hidden @internal */
        IgxAvatarComponent.prototype.getRole = function () {
            switch (this.type) {
                case IgxAvatarType.IMAGE:
                    return 'image avatar';
                case IgxAvatarType.ICON:
                    return 'icon avatar';
                case IgxAvatarType.INITIALS:
                    return 'initials avatar';
                default:
                    return 'custom avatar';
            }
        };
        return IgxAvatarComponent;
    }());
    IgxAvatarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-avatar',
                    template: "<ng-template #defaultTemplate>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #imageTemplate>\n    <div #image class=\"igx-avatar__image\" [style.backgroundImage]=\"getSrcUrl()\"></div>\n</ng-template>\n\n<ng-template #initialsTemplate>\n    <span>{{initials.substring(0, 2)}}</span>\n</ng-template>\n\n<ng-template #iconTemplate>\n     <igx-icon>{{icon}}</igx-icon>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
                },] }
    ];
    IgxAvatarComponent.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxAvatarComponent.propDecorators = {
        ariaLabel: [{ type: i0.HostBinding, args: ['attr.aria-label',] }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-avatar',] }],
        roleDescription: [{ type: i0.HostBinding, args: ['attr.aria-roledescription',] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        roundShape: [{ type: i0.HostBinding, args: ['class.igx-avatar--rounded',] }, { type: i0.Input }],
        color: [{ type: i0.HostBinding, args: ['style.color',] }, { type: i0.Input }],
        bgColor: [{ type: i0.HostBinding, args: ['style.background',] }, { type: i0.Input }],
        initials: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        src: [{ type: i0.Input }],
        defaultTemplate: [{ type: i0.ViewChild, args: ['defaultTemplate', { read: i0.TemplateRef, static: true },] }],
        imageTemplate: [{ type: i0.ViewChild, args: ['imageTemplate', { read: i0.TemplateRef, static: true },] }],
        initialsTemplate: [{ type: i0.ViewChild, args: ['initialsTemplate', { read: i0.TemplateRef, static: true },] }],
        iconTemplate: [{ type: i0.ViewChild, args: ['iconTemplate', { read: i0.TemplateRef, static: true },] }],
        size: [{ type: i0.Input }],
        _isSmallSize: [{ type: i0.HostBinding, args: ['class.igx-avatar--small',] }],
        _isMediumSize: [{ type: i0.HostBinding, args: ['class.igx-avatar--medium',] }],
        _isLargeSize: [{ type: i0.HostBinding, args: ['class.igx-avatar--large',] }],
        _isImageType: [{ type: i0.HostBinding, args: ['class.igx-avatar--image',] }],
        _isIconType: [{ type: i0.HostBinding, args: ['class.igx-avatar--icon',] }],
        _isInitialsType: [{ type: i0.HostBinding, args: ['class.igx-avatar--initials',] }]
    };
    /**
     * @hidden
     */
    var IgxAvatarModule = /** @class */ (function () {
        function IgxAvatarModule() {
        }
        return IgxAvatarModule;
    }());
    IgxAvatarModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxAvatarComponent],
                    exports: [IgxAvatarComponent],
                    imports: [i2.CommonModule, IgxIconModule]
                },] }
    ];

    var NEXT_ID$7 = 0;
    /**
     * Determines the igxBadge type
     */
    var IgxBadgeType = mkenum({
        PRIMARY: 'primary',
        INFO: 'info',
        SUCCESS: 'success',
        WARNING: 'warning',
        ERROR: 'error'
    });
    /**
     * Badge provides visual notifications used to decorate avatars, menus, etc.
     *
     * @igxModule IgxBadgeModule
     *
     * @igxTheme igx-badge-theme
     *
     * @igxKeywords badge, icon, notification
     *
     * @igxGroup Data Entry & Display
     *
     * @remarks
     * The Ignite UI Badge is used to decorate avatars, navigation menus, or other components in the
     * application when visual notification is needed. They are usually designed as icons with a predefined
     * style to communicate information, success, warnings, or errors.
     *
     * @example
     * ```html
     * <igx-avatar>
     *   <igx-badge icon="check" type="success"></igx-badge>
     * </igx-avatar>
     */
    var IgxBadgeComponent = /** @class */ (function () {
        function IgxBadgeComponent() {
            /**
             * Sets/gets the `id` of the badge.
             *
             * @remarks
             * If not set, the `id` will have value `"igx-badge-0"`.
             *
             * @example
             * ```html
             * <igx-badge id="igx-badge-2"></igx-badge>
             * ```
             */
            this.id = "igx-badge-" + NEXT_ID$7++;
            /**
             * Sets/gets the type of the badge.
             *
             * @remarks
             * Allowed values are `primary`, `info`, `success`, `warning`, `error`.
             * Providing an invalid value won't display a badge.
             *
             * @example
             * ```html
             * <igx-badge type="success"></igx-badge>
             * ```
             */
            this.type = IgxBadgeType.PRIMARY;
            /**
             * Sets/gets the value to be displayed inside the badge.
             *
             * @remarks
             * If an `icon` property is already set the `icon` will be displayed.
             * If neither a `value` nor an `icon` is set the content of the badge will be empty.
             *
             * @example
             * ```html
             * <igx-badge value="11"></igx-badge>
             * ```
             */
            this.value = '';
            /**
             * Sets/gets the role attribute value.
             *
             * @example
             * ```typescript
             * @ViewChild("MyBadge", { read: IgxBadgeComponent })
             * public badge: IgxBadgeComponent;
             *
             * badge.role = 'status';
             * ```
             */
            this.role = 'status';
            /**
             * Sets/gets the the css class to use on the badge.
             *
             * @example
             * ```typescript
             * @ViewChild("MyBadge", { read: IgxBadgeComponent })
             * public badge: IgxBadgeComponent;
             *
             * badge.cssClass = 'my-badge-class';
             * ```
             */
            this.cssClass = 'igx-badge';
            /**
             * Sets/gets the aria-label attribute value.
             *
             * @example
             * ```typescript
             * @ViewChild("MyBadge", { read: IgxBadgeComponent })
             * public badge: IgxBadgeComponent;
             *
             * badge.label = 'badge';
             * ```
             */
            this.label = 'badge';
        }
        Object.defineProperty(IgxBadgeComponent.prototype, "roleDescription", {
            /**
             * Defines a human-readable, accessor, author-localized description for
             * the `type` and the `icon` or `value` of the element.
             *
             * @hidden
             * @internal
             */
            get: function () {
                if (this.icon) {
                    return this.type + ' type badge with icon type ' + this.icon;
                }
                else if (this.value || this.value === 0) {
                    return this.type + ' badge type with value ' + this.value;
                }
                return this.type + ' badge type without value';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxBadgeComponent.prototype, "infoClass", {
            get: function () {
                return this.type === IgxBadgeType.INFO;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxBadgeComponent.prototype, "successClass", {
            get: function () {
                return this.type === IgxBadgeType.SUCCESS;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxBadgeComponent.prototype, "warningClass", {
            get: function () {
                return this.type === IgxBadgeType.WARNING;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxBadgeComponent.prototype, "errorClass", {
            get: function () {
                return this.type === IgxBadgeType.ERROR;
            },
            enumerable: false,
            configurable: true
        });
        return IgxBadgeComponent;
    }());
    IgxBadgeComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-badge',
                    template: "<span *ngIf=\"!icon\" class=\"igx-badge__value\">{{value}}</span>\n<igx-icon *ngIf=\"icon\">{{icon}}</igx-icon>\n"
                },] }
    ];
    IgxBadgeComponent.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        type: [{ type: i0.Input }],
        value: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-badge',] }],
        label: [{ type: i0.HostBinding, args: ['attr.aria-label',] }],
        roleDescription: [{ type: i0.HostBinding, args: ['attr.aria-roledescription',] }],
        infoClass: [{ type: i0.HostBinding, args: ['class.igx-badge--info',] }],
        successClass: [{ type: i0.HostBinding, args: ['class.igx-badge--success',] }],
        warningClass: [{ type: i0.HostBinding, args: ['class.igx-badge--warning',] }],
        errorClass: [{ type: i0.HostBinding, args: ['class.igx-badge--error',] }]
    };
    /**
     * @hidden
     */
    var IgxBadgeModule = /** @class */ (function () {
        function IgxBadgeModule() {
        }
        return IgxBadgeModule;
    }());
    IgxBadgeModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxBadgeComponent],
                    exports: [IgxBadgeComponent],
                    imports: [i2.CommonModule, IgxIconModule]
                },] }
    ];

    /** @hidden */
    var IGX_EXPANSION_PANEL_COMPONENT = new i0.InjectionToken('IgxExpansionPanelToken');

    var IgxExpansionPanelBodyComponent = /** @class */ (function () {
        function IgxExpansionPanelBodyComponent(panel, element, cdr) {
            this.panel = panel;
            this.element = element;
            this.cdr = cdr;
            /**
             * @hidden
             */
            this.cssClass = "igx-expansion-panel__body";
            /**
             * Gets/sets the `role` attribute of the panel body
             * Default is 'region';
             * Get
             * ```typescript
             *  const currentRole = this.panel.body.role;
             * ```
             * Set
             * ```typescript
             *  this.panel.body.role = 'content';
             * ```
             * ```html
             *  <igx-expansion-panel-body [role]="'custom'"></igx-expansion-panel-body>
             * ```
             */
            this.role = 'region';
            this._labelledBy = '';
            this._label = '';
        }
        Object.defineProperty(IgxExpansionPanelBodyComponent.prototype, "label", {
            /**
             * Gets the `aria-label` attribute of the panel body
             * Defaults to the panel id with '-region' in the end;
             * Get
             * ```typescript
             *  const currentLabel = this.panel.body.label;
             * ```
             */
            get: function () {
                return this._label || this.panel.id + '-region';
            },
            /**
             * Sets the `aria-label` attribute of the panel body
             * ```typescript
             *  this.panel.body.label = 'my-custom-label';
             * ```
             * ```html
             *  <igx-expansion-panel-body [label]="'my-custom-label'"></igx-expansion-panel-body>
             * ```
             */
            set: function (val) {
                this._label = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExpansionPanelBodyComponent.prototype, "labelledBy", {
            /**
             * Gets the `aria-labelledby` attribute of the panel body
             * Defaults to the panel header id;
             * Get
             * ```typescript
             *  const currentLabel = this.panel.body.labelledBy;
             * ```
             */
            get: function () {
                return this._labelledBy;
            },
            /**
             * Sets the `aria-labelledby` attribute of the panel body
             * ```typescript
             *  this.panel.body.labelledBy = 'my-custom-id';
             * ```
             * ```html
             *  <igx-expansion-panel-body [labelledBy]="'my-custom-id'"></igx-expansion-panel-body>
             * ```
             */
            set: function (val) {
                this._labelledBy = val;
            },
            enumerable: false,
            configurable: true
        });
        return IgxExpansionPanelBodyComponent;
    }());
    IgxExpansionPanelBodyComponent.decorators = [
        { type: i0.Component, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'igx-expansion-panel-body',
                    template: "<ng-content></ng-content>"
                },] }
    ];
    IgxExpansionPanelBodyComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxExpansionPanelBodyComponent.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-expansion-panel__body',] }],
        role: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.role',] }],
        label: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.aria-label',] }],
        labelledBy: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.aria-labelledby',] }]
    };

    /**
     * @hidden @internal
     */
    var IgxExpansionPanelTitleDirective = /** @class */ (function () {
        function IgxExpansionPanelTitleDirective() {
            this.cssClass = "igx-expansion-panel__header-title";
        }
        return IgxExpansionPanelTitleDirective;
    }());
    IgxExpansionPanelTitleDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'igx-expansion-panel-title'
                },] }
    ];
    IgxExpansionPanelTitleDirective.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-expansion-panel__header-title',] }]
    };
    /**
     * @hidden @internal
     */
    var IgxExpansionPanelDescriptionDirective = /** @class */ (function () {
        function IgxExpansionPanelDescriptionDirective() {
            this.cssClass = "igx-expansion-panel__header-description";
        }
        return IgxExpansionPanelDescriptionDirective;
    }());
    IgxExpansionPanelDescriptionDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'igx-expansion-panel-description'
                },] }
    ];
    IgxExpansionPanelDescriptionDirective.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-expansion-panel__header-description',] }]
    };
    /**
     * @hidden @internal
     */
    var IgxExpansionPanelIconDirective = /** @class */ (function () {
        function IgxExpansionPanelIconDirective() {
        }
        return IgxExpansionPanelIconDirective;
    }());
    IgxExpansionPanelIconDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'igx-expansion-panel-icon'
                },] }
    ];

    /**
     * @hidden
     */
    var ICON_POSITION = mkenum({
        LEFT: 'left',
        NONE: 'none',
        RIGHT: 'right'
    });
    var IgxExpansionPanelHeaderComponent = /** @class */ (function () {
        function IgxExpansionPanelHeaderComponent(panel, cdr, elementRef) {
            this.panel = panel;
            this.cdr = cdr;
            this.elementRef = elementRef;
            /**
             * Gets/sets the `aria-level` attribute of the header
             * Get
             * ```typescript
             *  const currentAriaLevel = this.panel.header.lv;
             * ```
             * Set
             * ```typescript
             *  this.panel.header.lv = '5';
             * ```
             * ```html
             *  <igx-expansion-panel-header [lv]="myCustomLevel"></igx-expansion-panel-header>
             * ```
             */
            this.lv = '3';
            /**
             * Gets/sets the `role` attribute of the header
             * Get
             * ```typescript
             *  const currentRole = this.panel.header.role;
             * ```
             * Set
             * ```typescript
             *  this.panel.header.role = '5';
             * ```
             * ```html
             *  <igx-expansion-panel-header [role]="'custom'"></igx-expansion-panel-header>
             * ```
             */
            this.role = 'heading';
            /**
             * Gets/sets the position of the expansion-panel-header expand/collapse icon
             * Accepts `left`, `right` or `none`
             * ```typescript
             *  const currentIconPosition = this.panel.header.iconPosition;
             * ```
             * Set
             * ```typescript
             *  this.panel.header.iconPosition = 'left';
             * ```
             * ```html
             *  <igx-expansion-panel-header [iconPosition]="'right'"></igx-expansion-panel-header>
             * ```
             */
            this.iconPosition = ICON_POSITION.LEFT;
            /**
             * Emitted whenever a user interacts with the header host
             * ```typescript
             *  handleInteraction(event: IExpansionPanelCancelableEventArgs) {
             *  ...
             * }
             * ```
             * ```html
             *  <igx-expansion-panel-header (onInteraction)="handleInteraction($event)">
             *      ...
             *  </igx-expansion-panel-header>
             * ```
             */
            this.onInteraction = new i0.EventEmitter();
            /**
             * @hidden
             */
            this.cssClass = 'igx-expansion-panel__header';
            /**
             * Gets/sets the whether the header is disabled
             * When disabled, the header will not handle user events and will stop their propagation
             *
             * ```typescript
             *  const isDisabled = this.panel.header.disabled;
             * ```
             * Set
             * ```typescript
             *  this.panel.header.disabled = true;
             * ```
             * ```html
             *  <igx-expansion-panel-header [disabled]="true">
             *     ...
             *  </igx-expansion-panel-header>
             * ```
             */
            this.disabled = false;
            /**
             * Sets/gets the `id` of the expansion panel header.
             * ```typescript
             * let panelHeaderId =  this.panel.header.id;
             * ```
             *
             * @memberof IgxExpansionPanelComponent
             */
            this.id = '';
            // properties section
            this._iconTemplate = false;
            this.id = this.panel.id + "-header";
        }
        Object.defineProperty(IgxExpansionPanelHeaderComponent.prototype, "iconRef", {
            /**
             * Returns a reference to the `igx-expansion-panel-icon` element;
             * If `iconPosition` is `NONE` - return null;
             */
            get: function () {
                var _a;
                var renderedTemplate = (_a = this.customIconRef) !== null && _a !== void 0 ? _a : this.defaultIconRef;
                return this.iconPosition !== ICON_POSITION.NONE ? renderedTemplate : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExpansionPanelHeaderComponent.prototype, "iconTemplate", {
            /**
             * @hidden
             */
            get: function () {
                return this._iconTemplate;
            },
            /**
             * @hidden
             */
            set: function (val) {
                this._iconTemplate = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExpansionPanelHeaderComponent.prototype, "controls", {
            /**
             * @hidden
             */
            get: function () {
                return this.panel.id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExpansionPanelHeaderComponent.prototype, "isExpanded", {
            /**
             * @hidden
             */
            get: function () {
                return !this.panel.collapsed;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxExpansionPanelHeaderComponent.prototype.onAction = function (evt) {
            if (this.disabled) {
                evt.stopPropagation();
                return;
            }
            var eventArgs = { event: evt, panel: this.panel, owner: this.panel, cancel: false };
            this.onInteraction.emit(eventArgs);
            if (eventArgs.cancel === true) {
                return;
            }
            this.panel.toggle(evt);
            evt.preventDefault();
        };
        /** @hidden @internal */
        IgxExpansionPanelHeaderComponent.prototype.openPanel = function (event) {
            if (event.altKey) {
                var eventArgs = { event: event, panel: this.panel, owner: this.panel, cancel: false };
                this.onInteraction.emit(eventArgs);
                if (eventArgs.cancel === true) {
                    return;
                }
                this.panel.expand(event);
            }
        };
        /** @hidden @internal */
        IgxExpansionPanelHeaderComponent.prototype.closePanel = function (event) {
            if (event.altKey) {
                var eventArgs = { event: event, panel: this.panel, owner: this.panel, cancel: false };
                this.onInteraction.emit(eventArgs);
                if (eventArgs.cancel === true) {
                    return;
                }
                this.panel.collapse(event);
            }
        };
        Object.defineProperty(IgxExpansionPanelHeaderComponent.prototype, "iconPositionClass", {
            /**
             * @hidden
             */
            get: function () {
                switch (this.iconPosition) {
                    case (ICON_POSITION.LEFT):
                        return "igx-expansion-panel__header-icon--start";
                    case (ICON_POSITION.RIGHT):
                        return "igx-expansion-panel__header-icon--end";
                    case (ICON_POSITION.NONE):
                        return "igx-expansion-panel__header-icon--none";
                    default:
                        return '';
                }
            },
            enumerable: false,
            configurable: true
        });
        return IgxExpansionPanelHeaderComponent;
    }());
    IgxExpansionPanelHeaderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-expansion-panel-header',
                    template: "<div class=\"igx-expansion-panel__header-inner\" tabindex=\"0\" role=\"button\" [attr.id]=\"id\"\n[attr.aria-disabled]=\"disabled\" [attr.aria-expanded]=\"isExpanded\" [attr.aria-controls]=\"controls\">\n    <div class=\"igx-expansion-panel__title-wrapper\">\n        <ng-content select=\"igx-expansion-panel-title\"></ng-content>\n        <ng-content select=\"igx-expansion-panel-description\"></ng-content>\n    </div>\n    <ng-content></ng-content>\n    <div [class]=\"iconPositionClass\">\n        <ng-content *ngIf=\"iconTemplate\" select=\"igx-expansion-panel-icon\"></ng-content>\n        <igx-icon *ngIf=\"!iconTemplate\">\n            {{panel.collapsed? 'expand_more':'expand_less'}}\n        </igx-icon>\n    </div>\n</div>\n"
                },] }
    ];
    IgxExpansionPanelHeaderComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Host }, { type: i0.Inject, args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
        { type: i0.ChangeDetectorRef },
        { type: i0.ElementRef }
    ]; };
    IgxExpansionPanelHeaderComponent.propDecorators = {
        iconTemplate: [{ type: i0.ContentChild, args: [IgxExpansionPanelIconDirective,] }],
        lv: [{ type: i0.HostBinding, args: ['attr.aria-level',] }, { type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }, { type: i0.Input }],
        iconPosition: [{ type: i0.Input }],
        onInteraction: [{ type: i0.Output }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-expansion-panel__header',] }],
        isExpanded: [{ type: i0.HostBinding, args: ['class.igx-expansion-panel__header--expanded',] }],
        disabled: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.igx-expansion-panel--disabled',] }],
        customIconRef: [{ type: i0.ContentChild, args: [IgxExpansionPanelIconDirective, { read: i0.ElementRef },] }],
        defaultIconRef: [{ type: i0.ViewChild, args: [IgxIconComponent, { read: i0.ElementRef },] }],
        onAction: [{ type: i0.HostListener, args: ['keydown.Enter', ['$event'],] }, { type: i0.HostListener, args: ['keydown.Space', ['$event'],] }, { type: i0.HostListener, args: ['keydown.Spacebar', ['$event'],] }, { type: i0.HostListener, args: ['click', ['$event'],] }],
        openPanel: [{ type: i0.HostListener, args: ['keydown.Alt.ArrowDown', ['$event'],] }],
        closePanel: [{ type: i0.HostListener, args: ['keydown.Alt.ArrowUp', ['$event'],] }]
    };

    var NEXT_ID$8 = 0;
    var IgxExpansionPanelComponent = /** @class */ (function () {
        function IgxExpansionPanelComponent(cdr, builder) {
            this.cdr = cdr;
            this.builder = builder;
            /**
             * Sets/gets the animation settings of the expansion panel component
             * Open and Close animation should be passed
             *
             * Get
             * ```typescript
             *  const currentAnimations = this.panel.animationSettings;
             * ```
             * Set
             * ```typescript
             *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
             *  ...
             *  this.panel.animationsSettings = {
             *      openAnimation: slideInLeft,
             *      closeAnimation: slideOutRight
             * };
             * ```
             * or via template
             * ```typescript
             *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
             *  ...
             *  myCustomAnimationObject = {
             *      openAnimation: slideInLeft,
             *      closeAnimation: slideOutRight
             * };
             * ```html
             *  <igx-expansion-panel [animationSettings]='myCustomAnimationObject'>
             *  ...
             *  </igx-expansion-panel>
             * ```
             */
            this.animationSettings = {
                openAnimation: growVerIn,
                closeAnimation: growVerOut
            };
            /**
             * Sets/gets the `id` of the expansion panel component.
             * If not set, `id` will have value `"igx-expansion-panel-0"`;
             * ```html
             * <igx-expansion-panel id = "my-first-expansion-panel"></igx-expansion-panel>
             * ```
             * ```typescript
             * let panelId =  this.panel.id;
             * ```
             *
             * @memberof IgxExpansionPanelComponent
             */
            this.id = "igx-expansion-panel-" + NEXT_ID$8++;
            /**
             * @hidden
             */
            this.cssClass = 'igx-expansion-panel';
            /**
             * @hidden
             */
            this.collapsedChange = new i0.EventEmitter();
            /**
             * Emitted when the expansion panel finishes collapsing
             * ```typescript
             *  handleCollapsed(event: IExpansionPanelEventArgs)
             * ```
             * ```html
             *  <igx-expansion-panel (onCollapsed)="handleCollapsed($event)">
             *      ...
             *  </igx-expansion-panel>
             * ```
             */
            this.onCollapsed = new i0.EventEmitter();
            /**
             * Emitted when the expansion panel finishes expanding
             * ```typescript
             *  handleExpanded(event: IExpansionPanelEventArgs)
             * ```
             * ```html
             *  <igx-expansion-panel (onExpanded)="handleExpanded($event)">
             *      ...
             *  </igx-expansion-panel>
             * ```
             */
            this.onExpanded = new i0.EventEmitter();
            this._collapsed = true;
        }
        Object.defineProperty(IgxExpansionPanelComponent.prototype, "collapsed", {
            /**
             * Gets/sets whether the component is collapsed (its content is hidden)
             * Get
             * ```typescript
             *  const myPanelState: boolean = this.panel.collapsed;
             * ```
             * Set
             * ```html
             *  this.panel.collapsed = true;
             * ```
             *
             * Two-way data binding:
             * ```html
             * <igx-expansion-panel [(collapsed)]="model.isCollapsed"></igx-expansion-panel>
             * ```
             */
            get: function () {
                return this._collapsed;
            },
            set: function (value) {
                this._collapsed = value;
                this.collapsedChange.emit(this._collapsed);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExpansionPanelComponent.prototype, "headerId", {
            /**
             * @hidden
             */
            get: function () {
                return this.header ? this.id + "-header" : '';
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden */
        IgxExpansionPanelComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (this.body && this.header) {
                // schedule at end of turn:
                Promise.resolve().then(function () {
                    _this.body.labelledBy = _this.body.labelledBy || _this.headerId;
                    _this.body.label = _this.body.label || _this.id + '-region';
                });
            }
        };
        /**
         * Collapses the panel
         *
         * ```html
         *  <igx-expansion-panel #myPanel>
         *      ...
         *  </igx-expansion-panel>
         *  <button (click)="myPanel.collapse($event)">Collpase Panel</button>
         * ```
         */
        IgxExpansionPanelComponent.prototype.collapse = function (evt) {
            var _this = this;
            if (this.collapsed) { // If expansion panel is already collapsed, do nothing
                return;
            }
            this.playCloseAnimation(function () {
                _this.onCollapsed.emit({ event: evt, panel: _this, owner: _this });
                _this.collapsed = true;
                _this.cdr.markForCheck();
            });
        };
        /**
         * Expands the panel
         *
         * ```html
         *  <igx-expansion-panel #myPanel>
         *      ...
         *  </igx-expansion-panel>
         *  <button (click)="myPanel.expand($event)">Expand Panel</button>
         * ```
         */
        IgxExpansionPanelComponent.prototype.expand = function (evt) {
            var _this = this;
            if (!this.collapsed) { // If the panel is already opened, do nothing
                return;
            }
            this.collapsed = false;
            this.cdr.detectChanges();
            this.playOpenAnimation(function () {
                _this.onExpanded.emit({ event: evt, panel: _this, owner: _this });
            });
        };
        /**
         * Toggles the panel
         *
         * ```html
         *  <igx-expansion-panel #myPanel>
         *      ...
         *  </igx-expansion-panel>
         *  <button (click)="myPanel.toggle($event)">Expand Panel</button>
         * ```
         */
        IgxExpansionPanelComponent.prototype.toggle = function (evt) {
            if (this.collapsed) {
                this.open(evt);
            }
            else {
                this.close(evt);
            }
        };
        IgxExpansionPanelComponent.prototype.open = function (evt) {
            this.expand(evt);
        };
        IgxExpansionPanelComponent.prototype.close = function (evt) {
            this.collapse(evt);
        };
        IgxExpansionPanelComponent.prototype.playOpenAnimation = function (cb) {
            if (!this.body) { // if not body element is passed, there is nothing to animate
                return;
            }
            var animation = i1.useAnimation(this.animationSettings.openAnimation);
            var animationBuilder = this.builder.build(animation);
            var openAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
            openAnimationPlayer.onDone(function () {
                cb();
                openAnimationPlayer.reset();
            });
            openAnimationPlayer.play();
        };
        IgxExpansionPanelComponent.prototype.playCloseAnimation = function (cb) {
            if (!this.body) { // if not body element is passed, there is nothing to animate
                return;
            }
            var animation = i1.useAnimation(this.animationSettings.closeAnimation);
            var animationBuilder = this.builder.build(animation);
            var closeAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
            closeAnimationPlayer.onDone(function () {
                cb();
                closeAnimationPlayer.reset();
            });
            closeAnimationPlayer.play();
        };
        return IgxExpansionPanelComponent;
    }());
    IgxExpansionPanelComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-expansion-panel',
                    template: "<ng-content select=\"igx-expansion-panel-header\"></ng-content>\n<ng-content *ngIf=\"!collapsed\" select=\"igx-expansion-panel-body\"></ng-content>\n",
                    providers: [{ provide: IGX_EXPANSION_PANEL_COMPONENT, useExisting: IgxExpansionPanelComponent }]
                },] }
    ];
    IgxExpansionPanelComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef },
        { type: i1.AnimationBuilder }
    ]; };
    IgxExpansionPanelComponent.propDecorators = {
        animationSettings: [{ type: i0.Input }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-expansion-panel',] }],
        collapsed: [{ type: i0.Input }],
        collapsedChange: [{ type: i0.Output }],
        onCollapsed: [{ type: i0.Output }],
        onExpanded: [{ type: i0.Output }],
        body: [{ type: i0.ContentChild, args: [IgxExpansionPanelBodyComponent, { read: IgxExpansionPanelBodyComponent },] }],
        header: [{ type: i0.ContentChild, args: [IgxExpansionPanelHeaderComponent, { read: IgxExpansionPanelHeaderComponent },] }]
    };

    /**
     * @hidden
     */
    var IgxExpansionPanelModule = /** @class */ (function () {
        function IgxExpansionPanelModule() {
        }
        return IgxExpansionPanelModule;
    }());
    IgxExpansionPanelModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxExpansionPanelComponent,
                        IgxExpansionPanelHeaderComponent,
                        IgxExpansionPanelBodyComponent,
                        IgxExpansionPanelDescriptionDirective,
                        IgxExpansionPanelTitleDirective,
                        IgxExpansionPanelIconDirective
                    ],
                    entryComponents: [],
                    exports: [
                        IgxExpansionPanelComponent,
                        IgxExpansionPanelHeaderComponent,
                        IgxExpansionPanelBodyComponent,
                        IgxExpansionPanelDescriptionDirective,
                        IgxExpansionPanelTitleDirective,
                        IgxExpansionPanelIconDirective
                    ],
                    imports: [
                        i2.CommonModule,
                        IgxRippleModule,
                        IgxIconModule,
                        IgxButtonModule,
                        IgxAvatarModule
                    ]
                },] }
    ];

    /* eslint-disable @angular-eslint/directive-selector */
    var IgxBannerActionsDirective = /** @class */ (function () {
        function IgxBannerActionsDirective() {
        }
        return IgxBannerActionsDirective;
    }());
    IgxBannerActionsDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'igx-banner-actions'
                },] }
    ];

    /**
     * **Ignite UI for Angular Banner** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/banner.html)
     *
     * The Ignite UI Banner provides a highly templateable and easy to use banner that can be shown in your application.
     *
     * Usage:
     *
     * ```html
     * <igx-banner #banner>
     *   Our privacy settings have changed.
     *  <igx-banner-actions>
     *      <button igxButton="raised">Read More</button>
     *      <button igxButton="raised">Accept and Continue</button>
     *  </igx-banner-actions>
     * </igx-banner>
     * ```
     */
    var IgxBannerComponent = /** @class */ (function () {
        function IgxBannerComponent(elementRef) {
            this.elementRef = elementRef;
            /**
             * Fires after the banner shows up
             * ```typescript
             * public handleOpened(event) {
             *  ...
             * }
             * ```
             * ```html
             * <igx-banner (onOpened)="handleOpened($event)"></igx-banner>
             * ```
             */
            this.onOpened = new i0.EventEmitter();
            /**
             * Fires before the banner shows up
             * ```typescript
             * public handleOpening(event) {
             *  ...
             * }
             * ```
             * ```html
             * <igx-banner (onOpening)="handleOpening($event)"></igx-banner>
             * ```
             */
            this.onOpening = new i0.EventEmitter();
            /**
             * Fires after the banner hides
             * ```typescript
             * public handleClosed(event) {
             *  ...
             * }
             * ```
             * ```html
             * <igx-banner (onClosed)="handleClosed($event)"></igx-banner>
             * ```
             */
            this.onClosed = new i0.EventEmitter();
            /**
             * Fires before the banner hides
             * ```typescript
             * public handleClosing(event) {
             *  ...
             * }
             * ```
             * ```html
             * <igx-banner (onClosing)="handleClosing($event)"></igx-banner>
             * ```
             */
            this.onClosing = new i0.EventEmitter();
        }
        Object.defineProperty(IgxBannerComponent.prototype, "useDefaultTemplate", {
            /** @hidden */
            get: function () {
                return !this._bannerActionTemplate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxBannerComponent.prototype, "animationSettings", {
            /**
             * Get the animation settings used by the banner open/close methods
             * ```typescript
             * let currentAnimations: AnimationSettings = banner.animationSettings
             * ```
             */
            get: function () {
                return this._animationSettings ? this._animationSettings : this._expansionPanel.animationSettings;
            },
            /**
             * Set the animation settings used by the banner open/close methods
             * ```typescript
             * import { slideInLeft, slideOutRight } from 'igniteui-angular';
             * ...
             * banner.animationSettings: AnimationSettings = { openAnimation: slideInLeft, closeAnimation: slideOutRight };
             * ```
             */
            set: function (settings) {
                this._animationSettings = settings;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxBannerComponent.prototype, "collapsed", {
            /**
             * Gets whether banner is collapsed
             *
             * ```typescript
             * const isCollapsed: boolean = banner.collapsed;
             * ```
             */
            get: function () {
                return this._expansionPanel.collapsed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxBannerComponent.prototype, "element", {
            /**
             * Returns the native element of the banner component
             * ```typescript
             *  const myBannerElement: HTMLElement = banner.element;
             * ```
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxBannerComponent.prototype, "displayStyle", {
            /**
             * @hidden
             */
            get: function () {
                return this.collapsed ? '' : 'block';
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Opens the banner
         *
         * ```typescript
         *  myBanner.open();
         * ```
         *
         * ```html
         * <igx-banner #banner>
         * ...
         * </igx-banner>
         * <button (click)="banner.open()">Open Banner</button>
         * ```
         */
        IgxBannerComponent.prototype.open = function (event) {
            this._bannerEvent = { banner: this, event: event };
            var openingArgs = {
                banner: this,
                event: event,
                cancel: false
            };
            this.onOpening.emit(openingArgs);
            if (openingArgs.cancel) {
                return;
            }
            this._expansionPanel.open(event);
        };
        /**
         * Closes the banner
         *
         * ```typescript
         *  myBanner.close();
         * ```
         *
         * ```html
         * <igx-banner #banner>
         * ...
         * </igx-banner>
         * <button (click)="banner.close()">Close Banner</button>
         * ```
         */
        IgxBannerComponent.prototype.close = function (event) {
            this._bannerEvent = { banner: this, event: event };
            var closingArgs = {
                banner: this,
                event: event,
                cancel: false
            };
            this.onClosing.emit(closingArgs);
            if (closingArgs.cancel) {
                return;
            }
            this._expansionPanel.close(event);
        };
        /**
         * Toggles the banner
         *
         * ```typescript
         *  myBanner.toggle();
         * ```
         *
         * ```html
         * <igx-banner #banner>
         * ...
         * </igx-banner>
         * <button (click)="banner.toggle()">Toggle Banner</button>
         * ```
         */
        IgxBannerComponent.prototype.toggle = function (event) {
            if (this.collapsed) {
                this.open(event);
            }
            else {
                this.close(event);
            }
        };
        /** @hidden */
        IgxBannerComponent.prototype.onExpansionPanelOpen = function () {
            this.onOpened.emit(this._bannerEvent);
        };
        /** @hidden */
        IgxBannerComponent.prototype.onExpansionPanelClose = function () {
            this.onClosed.emit(this._bannerEvent);
        };
        return IgxBannerComponent;
    }());
    IgxBannerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-banner',
                    template: "<igx-expansion-panel #expansionPanel [animationSettings]=\"animationSettings\" (onCollapsed)=\"onExpansionPanelClose()\" (onExpanded)=\"onExpansionPanelOpen()\"\n    [collapsed]=\"collapsed\" aria-live=\"polite\" [attr.aria-hidden]=\"collapsed\">\n    <igx-expansion-panel-body>\n        <div class=\"igx-banner\">\n            <div class=\"igx-banner__message\">\n                <div *ngIf=\"bannerIcon\" class=\"igx-banner__illustration\">\n                    <ng-content select=\"igx-icon\"></ng-content>\n                </div>\n                <span class=\"igx-banner__text\">\n                    <ng-content></ng-content>\n                </span>\n            </div>\n            <div class=\"igx-banner__actions\">\n                <div class=\"igx-banner__row\">\n                    <ng-container *ngIf=\"useDefaultTemplate\">\n                        <button igxButton=\"flat\" igxRipple (click)=\"close()\">\n                            Dismiss\n                        </button>\n                    </ng-container>\n                    <ng-container *ngIf=\"!useDefaultTemplate\">\n                        <ng-content select=\"igx-banner-actions\"></ng-content>\n                    </ng-container>\n                </div>\n            </div>\n        </div>\n    </igx-expansion-panel-body>\n</igx-expansion-panel>"
                },] }
    ];
    IgxBannerComponent.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxBannerComponent.propDecorators = {
        bannerIcon: [{ type: i0.ContentChild, args: [IgxIconComponent,] }],
        onOpened: [{ type: i0.Output }],
        onOpening: [{ type: i0.Output }],
        onClosed: [{ type: i0.Output }],
        onClosing: [{ type: i0.Output }],
        animationSettings: [{ type: i0.Input }],
        displayStyle: [{ type: i0.HostBinding, args: ['style.display',] }],
        _expansionPanel: [{ type: i0.ViewChild, args: ['expansionPanel', { static: true },] }],
        _bannerActionTemplate: [{ type: i0.ContentChild, args: [IgxBannerActionsDirective,] }]
    };
    /**
     * @hidden
     */
    var IgxBannerModule = /** @class */ (function () {
        function IgxBannerModule() {
        }
        return IgxBannerModule;
    }());
    IgxBannerModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxBannerComponent, IgxBannerActionsDirective],
                    exports: [IgxBannerComponent, IgxBannerActionsDirective],
                    imports: [i2.CommonModule, IgxExpansionPanelModule, IgxIconModule, IgxButtonModule, IgxRippleModule]
                },] }
    ];

    /**
     * Determines the Button Group alignment
     */
    var ButtonGroupAlignment = mkenum({
        horizontal: 'horizontal',
        vertical: 'vertical'
    });
    var NEXT_ID$9 = 0;
    /**
     * **Ignite UI for Angular Button Group** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/buttongroup.html)
     *
     * The Ignite UI Button Group displays a group of buttons either vertically or horizontally.  The group supports
     * single, multiple and toggle selection.
     *
     * Example:
     * ```html
     * <igx-buttongroup multiSelection="true" [values]="fontOptions">
     * </igx-buttongroup>
     * ```
     * The `fontOptions` value shown above is defined as:
     * ```typescript
     * this.fontOptions = [
     *   { icon: 'format_bold', selected: false },
     *   { icon: 'format_italic', selected: false },
     *   { icon: 'format_underlined', selected: false }];
     * ```
     */
    var IgxButtonGroupComponent = /** @class */ (function (_super) {
        __extends(IgxButtonGroupComponent, _super);
        function IgxButtonGroupComponent(_cdr, _renderer, _displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this._cdr = _cdr;
            _this._renderer = _renderer;
            _this._displayDensityOptions = _displayDensityOptions;
            /**
             * An @Input property that sets the value of the `id` attribute. If not set it will be automatically generated.
             * ```html
             *  <igx-buttongroup [id]="'igx-dialog-56'" [multiSelection]="!multi" [values]="alignOptions">
             * ```
             */
            _this.id = "igx-buttongroup-" + NEXT_ID$9++;
            /**
             * @hidden
             */
            _this.zIndex = 0;
            /**
             * An @Input property that enables selecting multiple buttons. By default, multi-selection is false.
             * ```html
             * <igx-buttongroup [multiSelection]="false" [alignment]="alignment"></igx-buttongroup>
             * ```
             */
            _this.multiSelection = false;
            /**
             * An @Ouput property that emits an event when a button is selected.
             * ```typescript
             * @ViewChild("toast")
             * private toast: IgxToastComponent;
             * public selectedHandler(buttongroup) {
             *     this.toast.open()
             * }
             *  //...
             * ```
             * ```html
             * <igx-buttongroup #MyChild [multiSelection]="!multi" (selected)="selectedHandler($event)"></igx-buttongroup>
             * <igx-toast #toast message="You have made a selection!"></igx-toast>
             * ```
             */
            _this.selected = new i0.EventEmitter();
            /**
             * An @Ouput property that emits an event when a button is deselected.
             * ```typescript
             *  @ViewChild("toast")
             *  private toast: IgxToastComponent;
             *  public deselectedHandler(buttongroup){
             *     this.toast.open()
             * }
             *  //...
             * ```
             * ```html
             * <igx-buttongroup> #MyChild [multiSelection]="multi" (deselected)="deselectedHandler($event)"></igx-buttongroup>
             * <igx-toast #toast message="You have deselected a button!"></igx-toast>
             * ```
             */
            _this.deselected = new i0.EventEmitter();
            /**
             * @hidden
             */
            _this.selectedIndexes = [];
            _this.buttonClickNotifier$ = new rxjs.Subject();
            _this.queryListNotifier$ = new rxjs.Subject();
            _this._disabled = false;
            return _this;
        }
        Object.defineProperty(IgxButtonGroupComponent.prototype, "buttons", {
            /**
             * A collection containing all buttons inside the button group.
             */
            get: function () {
                return __spread(this.viewButtons.toArray(), this.templateButtons.toArray());
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonGroupComponent.prototype, "itemContentCssClass", {
            /**
             * Returns the CSS class of the item content of the `IgxButtonGroup`.
             * ```typescript
             *  @ViewChild("MyChild")
             * public buttonG: IgxButtonGroupComponent;
             * ngAfterViewInit(){
             *    let buttonSelect = this.buttonG.itemContentCssClass;
             * }
             * ```
             */
            get: function () {
                return this._itemContentCssClass;
            },
            /**
             * Allows you to set a style using the `itemContentCssClass` input.
             * The value should be the CSS class name that will be applied to the button group.
             * ```typescript
             * public style1 = "styleClass";
             *  //..
             * ```
             *  ```html
             * <igx-buttongroup [itemContentCssClass]="style1" [multiSelection]="!multi" [values]="alignOptions">
             * ```
             */
            set: function (value) {
                this._itemContentCssClass = value || this._itemContentCssClass;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonGroupComponent.prototype, "disabled", {
            /**
             * An @Input property that allows you to disable the `igx-buttongroup` component. By default it's false.
             * ```html
             * <igx-buttongroup [disabled]="true" [multiSelection]="multi" [values]="fontOptions"></igx-buttongroup>
             * ```
             */
            get: function () {
                return this._disabled;
            },
            set: function (value) {
                var _this = this;
                if (this._disabled !== value) {
                    this._disabled = value;
                    if (this.viewButtons && this.templateButtons) {
                        this.buttons.forEach(function (b) { return b.disabled = _this._disabled; });
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonGroupComponent.prototype, "alignment", {
            /**
             * Returns the alignment of the `igx-buttongroup`.
             * ```typescript
             * @ViewChild("MyChild")
             * public buttonG: IgxButtonGroupComponent;
             * ngAfterViewInit(){
             *    let buttonAlignment = this.buttonG.alignment;
             * }
             * ```
             */
            get: function () {
                return this._isVertical ? ButtonGroupAlignment.vertical : ButtonGroupAlignment.horizontal;
            },
            /**
             * Allows you to set the button group alignment.
             * Available options are `ButtonGroupAlignment.horizontal` (default) and `ButtonGroupAlignment.vertical`.
             * ```typescript
             * public alignment = ButtonGroupAlignment.vertical;
             * //..
             * ```
             * ```html
             * <igx-buttongroup [multiSelection]="false" [values]="cities" [alignment]="alignment"></igx-buttongroup>
             * ```
             */
            set: function (value) {
                this._isVertical = value === ButtonGroupAlignment.vertical;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonGroupComponent.prototype, "isVertical", {
            /**
             * Returns true if the `igx-buttongroup` alignment is vertical.
             * Note that in order for the accessor to work correctly the property should be set explicitly.
             * ```html
             * <igx-buttongroup #MyChild [alignment]="alignment" [values]="alignOptions">
             * ```
             * ```typescript
             * //...
             * @ViewChild("MyChild")
             * private buttonG: IgxButtonGroupComponent;
             * ngAfterViewInit(){
             *    let orientation = this.buttonG.isVertical;
             * }
             * ```
             */
            get: function () {
                return this._isVertical;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxButtonGroupComponent.prototype, "selectedButtons", {
            /**
             * Gets the selected button/buttons.
             * ```typescript
             * @ViewChild("MyChild")
             * private buttonG: IgxButtonGroupComponent;
             * ngAfterViewInit(){
             *    let selectedButton = this.buttonG.selectedButtons;
             * }
             * ```
             */
            get: function () {
                var _this = this;
                return this.buttons.filter(function (_, i) { return _this.selectedIndexes.indexOf(i) !== -1; });
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Selects a button by its index.
         * ```typescript
         * @ViewChild("MyChild")
         * private buttonG: IgxButtonGroupComponent;
         * ngAfterViewInit(){
         *    this.buttonG.selectButton(2);
         *    this.cdr.detectChanges();
         * }
         * ```
         *
         * @memberOf {@link IgxButtonGroupComponent}
         */
        IgxButtonGroupComponent.prototype.selectButton = function (index) {
            var _this = this;
            if (index >= this.buttons.length || index < 0) {
                return;
            }
            var button = this.buttons[index];
            var buttonElement = button.nativeElement;
            this.selectedIndexes.push(index);
            button.selected = true;
            this._renderer.setAttribute(buttonElement, 'aria-pressed', 'true');
            this._renderer.addClass(buttonElement, 'igx-button-group__item--selected');
            this.selected.emit({ button: button, index: index });
            var indexInViewButtons = this.viewButtons.toArray().indexOf(button);
            if (indexInViewButtons !== -1) {
                this.values[indexInViewButtons].selected = true;
            }
            // deselect other buttons if multiSelection is not enabled
            if (!this.multiSelection && this.selectedIndexes.length > 1) {
                this.buttons.forEach(function (_, i) {
                    if (i !== index && _this.selectedIndexes.indexOf(i) !== -1) {
                        _this.deselectButton(i);
                    }
                });
            }
        };
        /**
         * Deselects a button by its index.
         * ```typescript
         * @ViewChild("MyChild")
         * private buttonG: IgxButtonGroupComponent;
         * ngAfterViewInit(){
         *    this.buttonG.deselectButton(2);
         *    this.cdr.detectChanges();
         * }
         * ```
         *
         * @memberOf {@link IgxButtonGroupComponent}
         */
        IgxButtonGroupComponent.prototype.deselectButton = function (index) {
            if (index >= this.buttons.length || index < 0) {
                return;
            }
            var button = this.buttons[index];
            var buttonElement = button.nativeElement;
            this.selectedIndexes.splice(this.selectedIndexes.indexOf(index), 1);
            button.selected = false;
            this._renderer.setAttribute(buttonElement, 'aria-pressed', 'false');
            this._renderer.removeClass(buttonElement, 'igx-button-group__item--selected');
            this.deselected.emit({ button: button, index: index });
            var indexInViewButtons = this.viewButtons.toArray().indexOf(button);
            if (indexInViewButtons !== -1) {
                this.values[indexInViewButtons].selected = false;
            }
        };
        /**
         * @hidden
         */
        IgxButtonGroupComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.templateButtons.forEach(function (button) {
                if (!button.initialDensity) {
                    button.displayDensity = _this.displayDensity;
                }
            });
        };
        /**
         * @hidden
         */
        IgxButtonGroupComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            var initButtons = function () {
                // Cancel any existing buttonClick subscriptions
                _this.buttonClickNotifier$.next();
                _this.selectedIndexes.splice(0, _this.selectedIndexes.length);
                // initial configuration
                _this.buttons.forEach(function (button, index) {
                    var buttonElement = button.nativeElement;
                    if (_this.disabled) {
                        button.disabled = true;
                    }
                    if (button.selected) {
                        _this.selectButton(index);
                    }
                    button.buttonClick.pipe(operators.takeUntil(_this.buttonClickNotifier$)).subscribe(function (ev) { return _this._clickHandler(ev, index); });
                    _this._renderer.addClass(buttonElement, 'igx-button-group__item');
                });
            };
            this.viewButtons.changes.pipe(operators.takeUntil(this.queryListNotifier$)).subscribe(function () { return initButtons(); });
            this.templateButtons.changes.pipe(operators.takeUntil(this.queryListNotifier$)).subscribe(function () { return initButtons(); });
            initButtons();
            this._cdr.detectChanges();
        };
        /**
         * @hidden
         */
        IgxButtonGroupComponent.prototype.ngOnDestroy = function () {
            this.buttonClickNotifier$.next();
            this.buttonClickNotifier$.complete();
            this.queryListNotifier$.next();
            this.queryListNotifier$.complete();
        };
        /**
         * @hidden
         */
        IgxButtonGroupComponent.prototype._clickHandler = function (_, i) {
            if (this.selectedIndexes.indexOf(i) !== -1) {
                this.deselectButton(i);
            }
            else {
                this.selectButton(i);
            }
        };
        return IgxButtonGroupComponent;
    }(DisplayDensityBase));
    IgxButtonGroupComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-buttongroup',
                    template: "<div class=\"igx-button-group\" role=\"group\" [class.igx-button-group--vertical]=\"isVertical\">\n    <button *ngFor=\"let button of values; let i = 'index'\"\n        type=\"button\"\n        igxButton=\"flat\"\n        [displayDensity]=\"displayDensity\"\n        [selected]=\"button.selected\"\n        [attr.data-togglable]=\"button.togglable\"\n        [disabled]=\"disabled || button.disabled\"\n        [igxButtonColor]=\"button.color\"\n        [igxButtonBackground]=\"button.bgcolor\"\n        [igxLabel]=\"button.label\"\n        [igxRipple]=\"button.ripple\"\n    >\n        <span class=\"igx-button-group__item-content {{ itemContentCssClass }}\">\n            <igx-icon *ngIf=\"button.icon\">{{button.icon}}</igx-icon>\n            <span class=\"igx-button-group__button-text\" *ngIf=\"button.label\">{{button.label}}</span>\n        </span>\n    </button>\n    <ng-content></ng-content>\n</div>\n"
                },] }
    ];
    IgxButtonGroupComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef },
        { type: i0.Renderer2 },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxButtonGroupComponent.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        zIndex: [{ type: i0.HostBinding, args: ['style.zIndex',] }],
        itemContentCssClass: [{ type: i0.Input }],
        multiSelection: [{ type: i0.Input }],
        values: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        alignment: [{ type: i0.Input }],
        selected: [{ type: i0.Output }],
        deselected: [{ type: i0.Output }],
        viewButtons: [{ type: i0.ViewChildren, args: [IgxButtonDirective,] }],
        templateButtons: [{ type: i0.ContentChildren, args: [IgxButtonDirective,] }]
    };
    /**
     * @hidden
     */
    var IgxButtonGroupModule = /** @class */ (function () {
        function IgxButtonGroupModule() {
        }
        return IgxButtonGroupModule;
    }());
    IgxButtonGroupModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxButtonGroupComponent],
                    exports: [IgxButtonGroupComponent],
                    imports: [IgxButtonModule, i2.CommonModule, IgxRippleModule, IgxIconModule]
                },] }
    ];

    (function (DateRangeType) {
        DateRangeType[DateRangeType["After"] = 0] = "After";
        DateRangeType[DateRangeType["Before"] = 1] = "Before";
        DateRangeType[DateRangeType["Between"] = 2] = "Between";
        DateRangeType[DateRangeType["Specific"] = 3] = "Specific";
        DateRangeType[DateRangeType["Weekdays"] = 4] = "Weekdays";
        DateRangeType[DateRangeType["Weekends"] = 5] = "Weekends";
    })(exports.DateRangeType || (exports.DateRangeType = {}));

    /**
     * @hidden
     */
    var TimeDeltaInterval;
    (function (TimeDeltaInterval) {
        TimeDeltaInterval["Month"] = "month";
        TimeDeltaInterval["Year"] = "year";
    })(TimeDeltaInterval || (TimeDeltaInterval = {}));
    var MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var FEBRUARY = 1;
    var range = function (start, stop, step) {
        if (start === void 0) { start = 0; }
        if (step === void 0) { step = 1; }
        var res = [];
        var cur = (stop === undefined) ? 0 : start;
        var max = (stop === undefined) ? start : stop;
        for (var i = cur; step < 0 ? i > max : i < max; i += step) {
            res.push(i);
        }
        return res;
    };
    /**
     * Returns true for leap years, false for non-leap years.
     *
     * @export
     * @param year
     * @returns
     */
    var isLeap = function (year) { return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0)); };
    var weekDay = function (year, month, day) { return new Date(year, month, day).getDay(); };
    /**
     * Return weekday and number of days for year, month.
     *
     * @export
     * @param year
     * @param month
     * @returns
     */
    var monthRange = function (year, month) {
        if ((month < 0) || (month > 11)) {
            throw new Error('Invalid month specified');
        }
        var day = weekDay(year, month, 1);
        var nDays = MDAYS[month];
        if ((month === FEBRUARY) && (isLeap(year))) {
            nDays++;
        }
        return [day, nDays];
    };
    var isDateInRanges = function (date, ranges) {
        var e_1, _a, e_2, _b;
        date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        var dateInMs = date.getTime();
        if (!ranges) {
            return false;
        }
        try {
            for (var ranges_1 = __values(ranges), ranges_1_1 = ranges_1.next(); !ranges_1_1.done; ranges_1_1 = ranges_1.next()) {
                var descriptor = ranges_1_1.value;
                var dRanges = descriptor.dateRange ? descriptor.dateRange.map(function (r) { return new Date(r.getFullYear(), r.getMonth(), r.getDate()); }) : undefined;
                switch (descriptor.type) {
                    case (exports.DateRangeType.After):
                        if (dateInMs > dRanges[0].getTime()) {
                            return true;
                        }
                        break;
                    case (exports.DateRangeType.Before):
                        if (dateInMs < dRanges[0].getTime()) {
                            return true;
                        }
                        break;
                    case (exports.DateRangeType.Between):
                        var dRange = dRanges.map(function (d) { return d.getTime(); });
                        var min = Math.min(dRange[0], dRange[1]);
                        var max = Math.max(dRange[0], dRange[1]);
                        if (dateInMs >= min && dateInMs <= max) {
                            return true;
                        }
                        break;
                    case (exports.DateRangeType.Specific):
                        var datesInMs = dRanges.map(function (d) { return d.getTime(); });
                        try {
                            for (var datesInMs_1 = (e_2 = void 0, __values(datesInMs)), datesInMs_1_1 = datesInMs_1.next(); !datesInMs_1_1.done; datesInMs_1_1 = datesInMs_1.next()) {
                                var specificDateInMs = datesInMs_1_1.value;
                                if (dateInMs === specificDateInMs) {
                                    return true;
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (datesInMs_1_1 && !datesInMs_1_1.done && (_b = datesInMs_1.return)) _b.call(datesInMs_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        break;
                    case (exports.DateRangeType.Weekdays):
                        var day = date.getDay();
                        if (day % 6 !== 0) {
                            return true;
                        }
                        break;
                    case (exports.DateRangeType.Weekends):
                        var weekday = date.getDay();
                        if (weekday % 6 === 0) {
                            return true;
                        }
                        break;
                    default:
                        return false;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (ranges_1_1 && !ranges_1_1.done && (_a = ranges_1.return)) _a.call(ranges_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    };
    (function (WEEKDAYS) {
        WEEKDAYS[WEEKDAYS["SUNDAY"] = 0] = "SUNDAY";
        WEEKDAYS[WEEKDAYS["MONDAY"] = 1] = "MONDAY";
        WEEKDAYS[WEEKDAYS["TUESDAY"] = 2] = "TUESDAY";
        WEEKDAYS[WEEKDAYS["WEDNESDAY"] = 3] = "WEDNESDAY";
        WEEKDAYS[WEEKDAYS["THURSDAY"] = 4] = "THURSDAY";
        WEEKDAYS[WEEKDAYS["FRIDAY"] = 5] = "FRIDAY";
        WEEKDAYS[WEEKDAYS["SATURDAY"] = 6] = "SATURDAY";
    })(exports.WEEKDAYS || (exports.WEEKDAYS = {}));
    var Calendar = /** @class */ (function () {
        function Calendar(firstWeekDay) {
            if (firstWeekDay === void 0) { firstWeekDay = exports.WEEKDAYS.SUNDAY; }
            this._firstWeekDay = firstWeekDay;
        }
        Object.defineProperty(Calendar.prototype, "firstWeekDay", {
            get: function () {
                return this._firstWeekDay % 7;
            },
            set: function (value) {
                this._firstWeekDay = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns an array of weekdays for one week starting
         * with the currently set `firstWeekDay`
         *
         * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
         * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
         *
         * @returns
         *
         * @memberof Calendar
         */
        Calendar.prototype.weekdays = function () {
            var e_3, _a;
            var res = [];
            try {
                for (var _b = __values(range(this.firstWeekDay, this.firstWeekDay + 7)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var i = _c.value;
                    res.push(i % 7);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return res;
        };
        /**
         * Returns the date values for one month. It will always iterate throught
         * complete weeks, so it will contain dates outside the specified month.
         *
         * @param year
         * @param month
         * @param boolean
         * @returns
         *
         * @memberof Calendar
         */
        Calendar.prototype.monthdates = function (year, month, extraWeek) {
            var e_4, _a;
            if (extraWeek === void 0) { extraWeek = false; }
            var date = new Date(year, month, 1);
            var days = (date.getDay() - this.firstWeekDay) % 7;
            if (days < 0) {
                days = 7 - Math.abs(days);
            }
            date = this.timedelta(date, 'day', -days);
            var res = [];
            var value;
            while (true) {
                value = this.generateICalendarDate(date, year, month);
                res.push(value);
                date = this.timedelta(date, 'day', 1);
                if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                    if (extraWeek && res.length <= 35) {
                        try {
                            for (var _b = (e_4 = void 0, __values(range(0, 7))), _c = _b.next(); !_c.done; _c = _b.next()) {
                                var _ = _c.value;
                                value = this.generateICalendarDate(date, year, month);
                                res.push(value);
                                date = this.timedelta(date, 'day', 1);
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                    }
                    break;
                }
            }
            return res;
        };
        /**
         * Returns a matrix (array of arrays) representing a month's calendar.
         * Each row represents a full week; week entries are ICalendarDate objects.
         *
         * @param year
         * @param month
         * @returns
         *
         * @memberof Calendar
         */
        Calendar.prototype.monthdatescalendar = function (year, month, extraWeek) {
            var e_5, _a;
            if (extraWeek === void 0) { extraWeek = false; }
            var dates = this.monthdates(year, month, extraWeek);
            var res = [];
            try {
                for (var _b = __values(range(0, dates.length, 7)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var i = _c.value;
                    res.push(dates.slice(i, i + 7));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_5) throw e_5.error; }
            }
            return res;
        };
        Calendar.prototype.timedelta = function (date, interval, units) {
            var ret = new Date(date);
            var checkRollover = function () {
                if (ret.getDate() !== date.getDate()) {
                    ret.setDate(0);
                }
            };
            switch (interval.toLowerCase()) {
                case 'year':
                    ret.setFullYear(ret.getFullYear() + units);
                    checkRollover();
                    break;
                case 'quarter':
                    ret.setMonth(ret.getMonth() + 3 * units);
                    checkRollover();
                    break;
                case 'month':
                    ret.setMonth(ret.getMonth() + units);
                    checkRollover();
                    break;
                case 'week':
                    ret.setDate(ret.getDate() + 7 * units);
                    break;
                case 'day':
                    ret.setDate(ret.getDate() + units);
                    break;
                case 'hour':
                    ret.setTime(ret.getTime() + units * 3600000);
                    break;
                case 'minute':
                    ret.setTime(ret.getTime() + units * 60000);
                    break;
                case 'second':
                    ret.setTime(ret.getTime() + units * 1000);
                    break;
                default:
                    throw new Error('Invalid interval specifier');
            }
            return ret;
        };
        Calendar.prototype.formatToParts = function (date, locale, options, parts) {
            var e_6, _a, e_7, _b;
            var formatter = new Intl.DateTimeFormat(locale, options);
            var result = {
                date: date,
                full: formatter.format(date)
            };
            if (formatter.formatToParts) {
                var formattedParts_1 = formatter.formatToParts(date);
                var toType = function (partType) {
                    var index = formattedParts_1.findIndex(function (_a) {
                        var type = _a.type;
                        return type === partType;
                    });
                    var o = { value: '', literal: '', combined: '' };
                    if (partType === 'era' && index > -1) {
                        o.value = formattedParts_1[index].value;
                        return o;
                    }
                    else if (partType === 'era' && index === -1) {
                        return o;
                    }
                    o.value = formattedParts_1[index].value;
                    o.literal = formattedParts_1[index + 1] ? formattedParts_1[index + 1].value : '';
                    o.combined = [o.value, o.literal].join('');
                    return o;
                };
                try {
                    for (var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
                        var each = parts_1_1.value;
                        result[each] = toType(each);
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
            else {
                try {
                    for (var parts_2 = __values(parts), parts_2_1 = parts_2.next(); !parts_2_1.done; parts_2_1 = parts_2.next()) {
                        var each = parts_2_1.value;
                        result[each] = { value: '', literal: '', combined: '' };
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (parts_2_1 && !parts_2_1.done && (_b = parts_2.return)) _b.call(parts_2);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
            }
            return result;
        };
        Calendar.prototype.getFirstViewDate = function (date, interval, activeViewIdx) {
            return this.timedelta(date, interval, -activeViewIdx);
        };
        Calendar.prototype.getDateByView = function (date, interval, activeViewIdx) {
            return this.timedelta(date, interval, activeViewIdx);
        };
        Calendar.prototype.getNextMonth = function (date) {
            return this.timedelta(date, TimeDeltaInterval.Month, 1);
        };
        Calendar.prototype.getPrevMonth = function (date) {
            return this.timedelta(date, TimeDeltaInterval.Month, -1);
        };
        Calendar.prototype.getNextYear = function (date) {
            return this.timedelta(date, TimeDeltaInterval.Year, 1);
        };
        Calendar.prototype.getPrevYear = function (date) {
            return this.timedelta(date, TimeDeltaInterval.Year, -1);
        };
        Calendar.prototype.getWeekNumber = function (date) {
            var firstJan = new Date(date.getFullYear(), 0, 1).getTime();
            var today = new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
            var dayInMilSeconds = 86400000;
            var dayOfYear = ((today - firstJan + 1) / dayInMilSeconds);
            return Math.ceil(dayOfYear / 7);
        };
        Calendar.prototype.generateICalendarDate = function (date, year, month) {
            return {
                date: date,
                isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
                isNextMonth: this.isNextMonth(date, year, month),
                isPrevMonth: this.isPreviousMonth(date, year, month)
            };
        };
        Calendar.prototype.isPreviousMonth = function (date, year, month) {
            if (date.getFullYear() === year) {
                return date.getMonth() < month;
            }
            return date.getFullYear() < year;
        };
        Calendar.prototype.isNextMonth = function (date, year, month) {
            if (date.getFullYear() === year) {
                return date.getMonth() > month;
            }
            return date.getFullYear() > year;
        };
        return Calendar;
    }());

    /**
     * Sets the selection type - single, multi or range.
     */
    var CalendarSelection = mkenum({
        SINGLE: 'single',
        MULTI: 'multi',
        RANGE: 'range'
    });
    (function (ScrollMonth) {
        ScrollMonth["PREV"] = "prev";
        ScrollMonth["NEXT"] = "next";
        ScrollMonth["NONE"] = "none";
    })(exports.ScrollMonth || (exports.ScrollMonth = {}));
    /** @hidden @internal */
    var IgxCalendarBaseDirective = /** @class */ (function () {
        /**
         * @hidden
         */
        function IgxCalendarBaseDirective() {
            /**
             * Sets/gets whether the outside dates (dates that are out of the current month) will be hidden.
             * Default value is `false`.
             * ```html
             * <igx-calendar [hideOutsideDays] = "true"></igx-calendar>
             * ```
             * ```typescript
             * let hideOutsideDays = this.calendar.hideOutsideDays;
             * ```
             */
            this.hideOutsideDays = false;
            /**
             * Emits an event when a date is selected.
             * Provides reference the `selectedDates` property.
             */
            this.selected = new i0.EventEmitter();
            /**
             * Emits an event when the month in view is changed.
             * ```html
             * <igx-calendar (viewDateChanged)="viewDateChanged($event)"></igx-calendar>
             * ```
             * ```typescript
             * public viewDateChanged(event: IViewDateChangeEventArgs) {
             *  let viewDate = event.currentValue;
             * }
             * ```
             */
            this.viewDateChanged = new i0.EventEmitter();
            /**
             * Emits an event when the active view is changed.
             * ```html
             * <igx-calendar (activeViewChanged)="activeViewChanged($event)"></igx-calendar>
             * ```
             * ```typescript
             * public activeViewChanged(event: CalendarView) {
             *  let activeView = event;
             * }
             * ```
             */
            this.activeViewChanged = new i0.EventEmitter();
            /**
             * @hidden
             */
            this.rangeStarted = false;
            /**
             * @hidden
             */
            this.monthScrollDirection = exports.ScrollMonth.NONE;
            /**
             * @hidden
             */
            this.scrollMonth$ = new rxjs.Subject();
            /**
             * @hidden
             */
            this.stopMonthScroll$ = new rxjs.Subject();
            /**
             * @hidden
             */
            this.startMonthScroll$ = new rxjs.Subject();
            /**
             * @hidden
             */
            this._onTouchedCallback = rxjs.noop;
            /**
             * @hidden
             */
            this._onChangeCallback = rxjs.noop;
            /**
             * @hidden
             */
            this._locale = 'en';
            /**
             * @hidden
             */
            this._selection = CalendarSelection.SINGLE;
            /** @hidden @internal */
            this._resourceStrings = CurrentResourceStrings.CalendarResStrings;
            /**
             * @hidden
             */
            this._formatOptions = {
                day: 'numeric',
                month: 'short',
                weekday: 'short',
                year: 'numeric'
            };
            /**
             * @hidden
             */
            this._formatViews = {
                day: false,
                month: true,
                year: false
            };
            this.calendarModel = new Calendar();
            this.viewDate = this.viewDate ? this.viewDate : new Date();
            this.calendarModel.firstWeekDay = this.weekStart;
            this.initFormatters();
        }
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "resourceStrings", {
            /**
             * An accessor that returns the resource strings.
             */
            get: function () {
                if (!this._resourceStrings) {
                    this._resourceStrings = CurrentResourceStrings.CalendarResStrings;
                }
                return this._resourceStrings;
            },
            /**
             * An accessor that sets the resource strings.
             * By default it uses EN resources.
             */
            set: function (value) {
                this._resourceStrings = Object.assign({}, this._resourceStrings, value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "weekStart", {
            /**
             * Gets the start day of the week.
             * Can return a numeric or an enum representation of the week day.
             * Defaults to `Sunday` / `0`.
             */
            get: function () {
                return this.calendarModel.firstWeekDay;
            },
            /**
             * Sets the start day of the week.
             * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
             */
            set: function (value) {
                this.calendarModel.firstWeekDay = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "locale", {
            /**
             * Gets the `locale` of the calendar.
             * Default value is `"en"`.
             */
            get: function () {
                return this._locale;
            },
            /**
             * Sets the `locale` of the calendar.
             * Expects a valid BCP 47 language tag.
             * Default value is `"en"`.
             */
            set: function (value) {
                this._locale = value;
                this.initFormatters();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "formatOptions", {
            /**
             * Gets the date format options of the days view.
             */
            get: function () {
                return this._formatOptions;
            },
            /**
             * Sets the date format options of the days view.
             * Default is { day: 'numeric', month: 'short', weekday: 'short', year: 'numeric' }
             */
            set: function (formatOptions) {
                this._formatOptions = Object.assign(this._formatOptions, formatOptions);
                this.initFormatters();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "formatViews", {
            /**
             * Gets whether the `day`, `month` and `year` should be rendered
             * according to the locale and formatOptions, if any.
             */
            get: function () {
                return this._formatViews;
            },
            /**
             * Gets whether the `day`, `month` and `year` should be rendered
             * according to the locale and formatOptions, if any.
             */
            set: function (formatViews) {
                this._formatViews = Object.assign(this._formatViews, formatViews);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "selection", {
            /**
             *
             * Gets the selection type.
             * Default value is `"single"`.
             * Changing the type of selection resets the currently
             * selected values if any.
             */
            get: function () {
                return this._selection;
            },
            /**
             * Sets the selection.
             */
            set: function (value) {
                switch (value) {
                    case CalendarSelection.SINGLE:
                        this.selectedDates = null;
                        break;
                    case CalendarSelection.MULTI:
                    case CalendarSelection.RANGE:
                        this.selectedDates = [];
                        break;
                    default:
                        throw new Error('Invalid selection value');
                }
                this._onChangeCallback(this.selectedDates);
                this.rangeStarted = false;
                this._selection = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "value", {
            /**
             * Gets the selected date(s).
             *
             * When selection is set to `single`, it returns
             * a single `Date` object.
             * Otherwise it is an array of `Date` objects.
             */
            get: function () {
                return this.selectedDates;
            },
            /**
             * Sets the selected date(s).
             *
             * When selection is set to `single`, it accepts
             * a single `Date` object.
             * Otherwise it is an array of `Date` objects.
             */
            set: function (value) {
                if (!value || !!value && value.length === 0) {
                    this.selectedDatesWithoutFocus = new Date();
                    return;
                }
                if (!this.selectedDatesWithoutFocus) {
                    var valueDate = value[0] ? Math.min.apply(null, value) : value;
                    var date = this.getDateOnly(new Date(valueDate)).setDate(1);
                    this.viewDate = new Date(date);
                }
                this.selectDate(value);
                this.selectedDatesWithoutFocus = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "viewDate", {
            /**
             * Gets the date that is presented.
             * By default it is the current date.
             */
            get: function () {
                return this._viewDate;
            },
            /**
             * Sets the date that will be presented in the default view when the component renders.
             */
            set: function (value) {
                if (Array.isArray(value)) {
                    return;
                }
                if (this._viewDate) {
                    this.selectedDatesWithoutFocus = value;
                }
                var date = this.getDateOnly(value).setDate(1);
                this._viewDate = new Date(date);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "disabledDates", {
            /**
             * Gets the disabled dates descriptors.
             */
            get: function () {
                return this._disabledDates;
            },
            /**
             * Sets the disabled dates' descriptors.
             * ```typescript
             * @ViewChild("MyCalendar")
             * public calendar: IgxCalendarComponent;
             * ngOnInit(){
             *    this.calendar.disabledDates = [
             *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
             *     {type: DateRangeType.Weekends}];
             * }
             * ```
             */
            set: function (value) {
                this._disabledDates = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "specialDates", {
            /**
             * Gets the special dates descriptors.
             */
            get: function () {
                return this._specialDates;
            },
            /**
             * Sets the special dates' descriptors.
             * ```typescript
             * @ViewChild("MyCalendar")
             * public calendar: IgxCalendarComponent;
             * ngOnInit(){
             *    this.calendar.specialDates = [
             *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
             *     {type: DateRangeType.Weekends}];
             * }
             * ```
             */
            set: function (value) {
                this._specialDates = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Performs deselection of a single value, when selection is multi
         * Usually performed by the selectMultiple method, but leads to bug when multiple months are in view
         *
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.deselectMultipleInMonth = function (value) {
            var valueDateOnly = this.getDateOnly(value);
            this.selectedDates = this.selectedDates.filter(function (date) { return date.getTime() !== valueDateOnly.getTime(); });
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.writeValue = function (value) {
            this.selectDate(value);
        };
        /**
         * Checks whether a date is disabled.
         *
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.isDateDisabled = function (date) {
            if (this.disabledDates === null) {
                return false;
            }
            return isDateInRanges(date, this.disabledDates);
        };
        /**
         * Selects date(s) (based on the selection type).
         */
        IgxCalendarBaseDirective.prototype.selectDate = function (value) {
            if (value === null || value === undefined || (Array.isArray(value) && value.length === 0)) {
                return;
            }
            switch (this.selection) {
                case CalendarSelection.SINGLE:
                    if (isDate(value) && !this.isDateDisabled(value)) {
                        this.selectSingle(value);
                    }
                    break;
                case CalendarSelection.MULTI:
                    this.selectMultiple(value);
                    break;
                case CalendarSelection.RANGE:
                    this.selectRange(value, true);
                    break;
            }
        };
        /**
         * Deselects date(s) (based on the selection type).
         */
        IgxCalendarBaseDirective.prototype.deselectDate = function (value) {
            if (!this.selectedDates || this.selectedDates.length === 0) {
                return;
            }
            if (value === null || value === undefined) {
                this.selectedDates = this.selection === CalendarSelection.SINGLE ? null : [];
                this.rangeStarted = false;
                this._onChangeCallback(this.selectedDates);
                return;
            }
            switch (this.selection) {
                case CalendarSelection.SINGLE:
                    this.deselectSingle(value);
                    break;
                case CalendarSelection.MULTI:
                    this.deselectMultiple(value);
                    break;
                case CalendarSelection.RANGE:
                    this.deselectRange(value);
                    break;
            }
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.selectDateFromClient = function (value) {
            switch (this.selection) {
                case CalendarSelection.SINGLE:
                case CalendarSelection.MULTI:
                    this.selectDate(value);
                    break;
                case CalendarSelection.RANGE:
                    this.selectRange(value, true);
                    break;
            }
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.initFormatters = function () {
            this.formatterDay = new Intl.DateTimeFormat(this._locale, { day: this._formatOptions.day });
            this.formatterWeekday = new Intl.DateTimeFormat(this._locale, { weekday: this._formatOptions.weekday });
            this.formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month });
            this.formatterYear = new Intl.DateTimeFormat(this._locale, { year: this._formatOptions.year });
            this.formatterMonthday = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month, day: this._formatOptions.day });
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.getDateOnly = function (date) {
            return new Date(date.getFullYear(), date.getMonth(), date.getDate());
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.getDateOnlyInMs = function (date) {
            return this.getDateOnly(date).getTime();
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.generateDateRange = function (start, end) {
            var result = [];
            start = this.getDateOnly(start);
            end = this.getDateOnly(end);
            while (start.getTime() < end.getTime()) {
                start = this.calendarModel.timedelta(start, 'day', 1);
                result.push(start);
            }
            return result;
        };
        /**
         * Performs a single selection.
         *
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.selectSingle = function (value) {
            this.selectedDates = this.getDateOnly(value);
            this._onChangeCallback(this.selectedDates);
        };
        /**
         * Performs a multiple selection
         *
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.selectMultiple = function (value) {
            var _this = this;
            if (Array.isArray(value)) {
                var newDates = value.map(function (v) { return _this.getDateOnly(v).getTime(); });
                var selDates = this.selectedDates.map(function (v) { return _this.getDateOnly(v).getTime(); });
                if (JSON.stringify(newDates) === JSON.stringify(selDates)) {
                    return;
                }
                this.selectedDates = Array.from(new Set(__spread(newDates, selDates))).map(function (v) { return new Date(v); });
            }
            else {
                var valueDateOnly_1 = this.getDateOnly(value);
                var newSelection = [];
                if (this.selectedDates.every(function (date) { return date.getTime() !== valueDateOnly_1.getTime(); })) {
                    newSelection.push(valueDateOnly_1);
                }
                else {
                    this.selectedDates = this.selectedDates.filter(function (date) { return date.getTime() !== valueDateOnly_1.getTime(); });
                }
                if (newSelection.length > 0) {
                    this.selectedDates = this.selectedDates.concat(newSelection);
                }
            }
            this.selectedDates = this.selectedDates.filter(function (d) { return !_this.isDateDisabled(d); });
            this.selectedDates.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
            this._onChangeCallback(this.selectedDates);
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.selectRange = function (value, excludeDisabledDates) {
            var _this = this;
            if (excludeDisabledDates === void 0) { excludeDisabledDates = false; }
            var start;
            var end;
            if (Array.isArray(value)) {
                // this.rangeStarted = false;
                value.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
                start = this.getDateOnly(value[0]);
                end = this.getDateOnly(value[value.length - 1]);
                this.selectedDates = __spread([start], this.generateDateRange(start, end));
            }
            else {
                if (!this.rangeStarted) {
                    this.rangeStarted = true;
                    this.selectedDates = [value];
                }
                else {
                    this.rangeStarted = false;
                    if (this.selectedDates[0].getTime() === value.getTime()) {
                        this.selectedDates = [];
                        this._onChangeCallback(this.selectedDates);
                        return;
                    }
                    this.selectedDates.push(value);
                    this.selectedDates.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
                    start = this.selectedDates.shift();
                    end = this.selectedDates.pop();
                    this.selectedDates = __spread([start], this.generateDateRange(start, end));
                }
            }
            if (excludeDisabledDates) {
                this.selectedDates = this.selectedDates.filter(function (d) { return !_this.isDateDisabled(d); });
            }
            this._onChangeCallback(this.selectedDates);
        };
        /**
         * Performs a single deselection.
         *
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.deselectSingle = function (value) {
            if (this.selectedDates !== null &&
                this.getDateOnlyInMs(value) === this.getDateOnlyInMs(this.selectedDates)) {
                this.selectedDates = null;
                this._onChangeCallback(this.selectedDates);
            }
        };
        /**
         * Performs a multiple deselection.
         *
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.deselectMultiple = function (value) {
            var _this = this;
            value = value.filter(function (v) { return v !== null; });
            var selectedDatesCount = this.selectedDates.length;
            var datesInMsToDeselect = new Set(value.map(function (v) { return _this.getDateOnlyInMs(v); }));
            for (var i = this.selectedDates.length - 1; i >= 0; i--) {
                if (datesInMsToDeselect.has(this.getDateOnlyInMs(this.selectedDates[i]))) {
                    this.selectedDates.splice(i, 1);
                }
            }
            if (this.selectedDates.length !== selectedDatesCount) {
                this._onChangeCallback(this.selectedDates);
            }
        };
        /**
         * Performs a range deselection.
         *
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.deselectRange = function (value) {
            value = value.filter(function (v) { return v !== null; });
            if (value.length < 1) {
                return;
            }
            value.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
            var valueStart = this.getDateOnlyInMs(value[0]);
            var valueEnd = this.getDateOnlyInMs(value[value.length - 1]);
            this.selectedDates.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
            var selectedDatesStart = this.getDateOnlyInMs(this.selectedDates[0]);
            var selectedDatesEnd = this.getDateOnlyInMs(this.selectedDates[this.selectedDates.length - 1]);
            if (!(valueEnd < selectedDatesStart) && !(valueStart > selectedDatesEnd)) {
                this.selectedDates = [];
                this.rangeStarted = false;
                this._onChangeCallback(this.selectedDates);
            }
        };
        return IgxCalendarBaseDirective;
    }());
    IgxCalendarBaseDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCalendarBase]',
                },] }
    ];
    IgxCalendarBaseDirective.ctorParameters = function () { return []; };
    IgxCalendarBaseDirective.propDecorators = {
        hideOutsideDays: [{ type: i0.Input }],
        selected: [{ type: i0.Output }],
        viewDateChanged: [{ type: i0.Output }],
        activeViewChanged: [{ type: i0.Output }],
        resourceStrings: [{ type: i0.Input }],
        weekStart: [{ type: i0.Input }],
        locale: [{ type: i0.Input }],
        formatOptions: [{ type: i0.Input }],
        formatViews: [{ type: i0.Input }],
        selection: [{ type: i0.Input }],
        value: [{ type: i0.Input }],
        viewDate: [{ type: i0.Input }],
        disabledDates: [{ type: i0.Input }],
        specialDates: [{ type: i0.Input }]
    };

    /**
     * This file contains all the directives used by the @link IgxCalendarComponent.
     * Except for the directives which are used for templating the calendar itself
     * you should generally not use them directly.
     *
     * @preferred
     */
    /**
     * @hidden
     */
    var IgxCalendarYearDirective = /** @class */ (function () {
        function IgxCalendarYearDirective(elementRef) {
            this.elementRef = elementRef;
            this.yearSelection = new i0.EventEmitter();
        }
        Object.defineProperty(IgxCalendarYearDirective.prototype, "defaultCSS", {
            get: function () {
                return !this.isCurrentYear;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarYearDirective.prototype, "currentCSS", {
            get: function () {
                return this.isCurrentYear;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarYearDirective.prototype, "role", {
            get: function () {
                return this.isCurrentYear ? 'spinbutton' : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarYearDirective.prototype, "valuenow", {
            get: function () {
                return this.isCurrentYear ? this.date.getFullYear() : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarYearDirective.prototype, "tabIndex", {
            get: function () {
                return this.isCurrentYear ? 0 : -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarYearDirective.prototype, "isCurrentYear", {
            get: function () {
                return this.date.getFullYear() === this.value.getFullYear();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarYearDirective.prototype, "nativeElement", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        IgxCalendarYearDirective.prototype.onClick = function () {
            this.yearSelection.emit(this.value);
        };
        return IgxCalendarYearDirective;
    }());
    IgxCalendarYearDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCalendarYear]'
                },] }
    ];
    IgxCalendarYearDirective.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxCalendarYearDirective.propDecorators = {
        value: [{ type: i0.Input, args: ['igxCalendarYear',] }],
        date: [{ type: i0.Input }],
        yearSelection: [{ type: i0.Output }],
        defaultCSS: [{ type: i0.HostBinding, args: ['class.igx-calendar__year',] }],
        currentCSS: [{ type: i0.HostBinding, args: ['class.igx-calendar__year--current',] }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        valuenow: [{ type: i0.HostBinding, args: ['attr.aria-valuenow',] }],
        tabIndex: [{ type: i0.HostBinding, args: ['attr.tabindex',] }],
        onClick: [{ type: i0.HostListener, args: ['click',] }]
    };
    var IgxCalendarMonthDirective = /** @class */ (function () {
        function IgxCalendarMonthDirective(elementRef) {
            this.elementRef = elementRef;
            this.monthSelection = new i0.EventEmitter();
        }
        Object.defineProperty(IgxCalendarMonthDirective.prototype, "defaultCSS", {
            get: function () {
                return !this.isCurrentMonth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarMonthDirective.prototype, "currentCSS", {
            get: function () {
                return this.isCurrentMonth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarMonthDirective.prototype, "isCurrentMonth", {
            get: function () {
                return this.date.getMonth() === this.value.getMonth();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarMonthDirective.prototype, "nativeElement", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        IgxCalendarMonthDirective.prototype.onClick = function () {
            var date = new Date(this.value.getFullYear(), this.value.getMonth(), this.date.getDate());
            this.monthSelection.emit(date);
        };
        return IgxCalendarMonthDirective;
    }());
    IgxCalendarMonthDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCalendarMonth]'
                },] }
    ];
    IgxCalendarMonthDirective.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxCalendarMonthDirective.propDecorators = {
        value: [{ type: i0.Input, args: ['igxCalendarMonth',] }],
        date: [{ type: i0.Input }],
        index: [{ type: i0.Input }],
        monthSelection: [{ type: i0.Output }],
        defaultCSS: [{ type: i0.HostBinding, args: ['class.igx-calendar__month',] }],
        currentCSS: [{ type: i0.HostBinding, args: ['class.igx-calendar__month--current',] }],
        onClick: [{ type: i0.HostListener, args: ['click',] }]
    };
    /**
     * @hidden
     */
    var IgxCalendarHeaderTemplateDirective = /** @class */ (function () {
        function IgxCalendarHeaderTemplateDirective(template) {
            this.template = template;
        }
        return IgxCalendarHeaderTemplateDirective;
    }());
    IgxCalendarHeaderTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCalendarHeader]'
                },] }
    ];
    IgxCalendarHeaderTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    /**
     * @hidden
     */
    var IgxCalendarSubheaderTemplateDirective = /** @class */ (function () {
        function IgxCalendarSubheaderTemplateDirective(template) {
            this.template = template;
        }
        return IgxCalendarSubheaderTemplateDirective;
    }());
    IgxCalendarSubheaderTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCalendarSubheader]'
                },] }
    ];
    IgxCalendarSubheaderTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    /**
     * @hidden
     */
    var IgxCalendarScrollMonthDirective = /** @class */ (function () {
        function IgxCalendarScrollMonthDirective(element, zone) {
            this.element = element;
            this.zone = zone;
            /**
             * @hidden
             */
            this.destroy$ = new rxjs.Subject();
        }
        /**
         * @hidden
         */
        IgxCalendarScrollMonthDirective.prototype.onMouseDown = function () {
            this.startScroll();
        };
        /**
         * @hidden
         */
        IgxCalendarScrollMonthDirective.prototype.onMouseUp = function (event) {
            this.stopScroll(event);
        };
        /**
         * @hidden
         */
        IgxCalendarScrollMonthDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            rxjs.fromEvent(this.element.nativeElement, 'keyup').pipe(operators.debounce(function () { return rxjs.interval(100); }), operators.takeUntil(this.destroy$)).subscribe(function (event) {
                _this.stopScroll(event);
            });
            this.zone.runOutsideAngular(function () {
                rxjs.fromEvent(_this.element.nativeElement, 'keydown').pipe(operators.tap(function (event) {
                    if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }), operators.debounce(function () { return rxjs.interval(100); }), operators.takeUntil(_this.destroy$)).subscribe(function (event) {
                    if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                        _this.zone.run(function () { return _this.startScroll(true); });
                    }
                });
            });
        };
        /**
         * @hidden
         */
        IgxCalendarScrollMonthDirective.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        return IgxCalendarScrollMonthDirective;
    }());
    IgxCalendarScrollMonthDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCalendarScrollMonth]'
                },] }
    ];
    IgxCalendarScrollMonthDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.NgZone }
    ]; };
    IgxCalendarScrollMonthDirective.propDecorators = {
        startScroll: [{ type: i0.Input }],
        stopScroll: [{ type: i0.Input }],
        onMouseDown: [{ type: i0.HostListener, args: ['mousedown',] }],
        onMouseUp: [{ type: i0.HostListener, args: ['mouseup', ['$event'],] }]
    };

    var IgxCalendarView = mkenum({
        Month: 'month',
        Year: 'year',
        Decade: 'decade'
    });
    (function (CalendarView) {
        CalendarView[CalendarView["DEFAULT"] = 0] = "DEFAULT";
        CalendarView[CalendarView["YEAR"] = 1] = "YEAR";
        CalendarView[CalendarView["DECADE"] = 2] = "DECADE";
    })(exports.CalendarView || (exports.CalendarView = {}));
    var IgxMonthPickerBaseDirective = /** @class */ (function (_super) {
        __extends(IgxMonthPickerBaseDirective, _super);
        function IgxMonthPickerBaseDirective() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            /**
             * Holds month view index we are operating on.
             */
            _this.activeViewIdx = 0;
            /**
             * @hidden
             */
            _this._activeView = IgxCalendarView.Month;
            return _this;
        }
        Object.defineProperty(IgxMonthPickerBaseDirective.prototype, "activeView", {
            /**
             * Gets the current active view.
             * ```typescript
             * this.activeView = calendar.activeView;
             * ```
             */
            get: function () {
                return this._activeView;
            },
            /**
             * Sets the current active view.
             * ```html
             * <igx-calendar [activeView]="year" #calendar></igx-calendar>
             * ```
             * ```typescript
             * calendar.activeView = IgxCalendarView.YEAR;
             * ```
             */
            set: function (val) {
                this._activeView = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMonthPickerBaseDirective.prototype, "isDefaultView", {
            /**
             * @hidden
             */
            get: function () {
                return this._activeView === exports.CalendarView.DEFAULT || this._activeView === IgxCalendarView.Month;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMonthPickerBaseDirective.prototype, "isDecadeView", {
            /**
             * @hidden
             */
            get: function () {
                return this._activeView === exports.CalendarView.DECADE || this._activeView === IgxCalendarView.Decade;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxMonthPickerBaseDirective.prototype.changeYear = function (event) {
            var _this = this;
            this.previousViewDate = this.viewDate;
            this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
            this.activeView = IgxCalendarView.Month;
            requestAnimationFrame(function () {
                if (_this.yearsBtns && _this.yearsBtns.length) {
                    _this.yearsBtns.find(function (e, idx) { return idx === _this.activeViewIdx; }).nativeElement.focus();
                }
            });
        };
        /**
         * @hidden
         */
        IgxMonthPickerBaseDirective.prototype.activeViewDecade = function (activeViewIdx) {
            if (activeViewIdx === void 0) { activeViewIdx = 0; }
            this.activeView = IgxCalendarView.Decade;
            this.activeViewIdx = activeViewIdx;
        };
        /**
         * @hidden
         */
        IgxMonthPickerBaseDirective.prototype.activeViewDecadeKB = function (event, activeViewIdx) {
            if (activeViewIdx === void 0) { activeViewIdx = 0; }
            if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                event.preventDefault();
                this.activeViewDecade(activeViewIdx);
            }
        };
        /**
         * Returns the locale representation of the year in the year view if enabled,
         * otherwise returns the default `Date.getFullYear()` value.
         *
         * @hidden
         */
        IgxMonthPickerBaseDirective.prototype.formattedYear = function (value) {
            if (this.formatViews.year) {
                return this.formatterYear.format(value);
            }
            return "" + value.getFullYear();
        };
        return IgxMonthPickerBaseDirective;
    }(IgxCalendarBaseDirective));
    IgxMonthPickerBaseDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxMonthPickerBase]'
                },] }
    ];
    IgxMonthPickerBaseDirective.propDecorators = {
        yearsBtns: [{ type: i0.ViewChildren, args: ['yearsBtn',] }],
        activeView: [{ type: i0.Input }]
    };

    var NEXT_ID$a = 0;
    var IgxMonthsViewComponent = /** @class */ (function () {
        function IgxMonthsViewComponent(el) {
            this.el = el;
            /**
             * Sets/gets the `id` of the months view.
             * If not set, the `id` will have value `"igx-months-view-0"`.
             * ```html
             * <igx-months-view id="my-months-view"></igx-months-view>
             * ```
             * ```typescript
             * let monthsViewId =  this.monthsView.id;
             * ```
             *
             * @memberof IgxMonthsViewComponent
             */
            this.id = "igx-months-view-" + NEXT_ID$a++;
            /**
             * Gets/sets whether the view should be rendered
             * according to the locale and monthFormat, if any.
             */
            this.formatView = true;
            /**
             * Emits an event when a selection is made in the months view.
             * Provides reference the `date` property in the `IgxMonthsViewComponent`.
             * ```html
             * <igx-months-view (selected)="onSelection($event)"></igx-months-view>
             * ```
             *
             * @memberof IgxMonthsViewComponent
             */
            this.selected = new i0.EventEmitter();
            /**
             * The default css class applied to the component.
             *
             * @hidden
             */
            this.styleClass = true;
            this._date = new Date();
            /**
             * @hidden
             */
            this._locale = 'en';
            /**
             * @hidden
             */
            this._monthFormat = 'short';
            /**
             * @hidden
             */
            this._onTouchedCallback = rxjs.noop;
            /**
             * @hidden
             */
            this._onChangeCallback = rxjs.noop;
            this.initMonthFormatter();
            this._calendarModel = new Calendar();
        }
        Object.defineProperty(IgxMonthsViewComponent.prototype, "date", {
            get: function () {
                return this._date;
            },
            /**
             * Gets/sets the selected date of the months view.
             * By default it is the current date.
             * ```html
             * <igx-months-view [date]="myDate"></igx-months-view>
             * ```
             * ```typescript
             * let date =  this.monthsView.date;
             * ```
             *
             * @memberof IgxMonthsViewComponent
             */
            set: function (value) {
                if (!(value instanceof Date)) {
                    return;
                }
                this._date = value;
                this.activeMonth = this.date.getMonth();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMonthsViewComponent.prototype, "monthFormat", {
            /**
             * Gets the month format option of the months view.
             * ```typescript
             * let monthFormat = this.monthsView.monthFormat.
             * ```
             */
            get: function () {
                return this._monthFormat;
            },
            /**
             * Sets the month format option of the months view.
             * ```html
             * <igx-months-view> [monthFormat] = "short'"</igx-months-view>
             * ```
             *
             * @memberof IgxMonthsViewComponent
             */
            set: function (value) {
                this._monthFormat = value;
                this.initMonthFormatter();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMonthsViewComponent.prototype, "locale", {
            /**
             * Gets the `locale` of the months view.
             * Default value is `"en"`.
             * ```typescript
             * let locale =  this.monthsView.locale;
             * ```
             *
             * @memberof IgxMonthsViewComponent
             */
            get: function () {
                return this._locale;
            },
            /**
             * Sets the `locale` of the months view.
             * Expects a valid BCP 47 language tag.
             * Default value is `"en"`.
             * ```html
             * <igx-months-view [locale]="de"></igx-months-view>
             * ```
             *
             * @memberof IgxMonthsViewComponent
             */
            set: function (value) {
                this._locale = value;
                this.initMonthFormatter();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMonthsViewComponent.prototype, "months", {
            /**
             * Returns an array of date objects which are then used to
             * properly render the month names.
             *
             * Used in the template of the component
             *
             * @hidden
             */
            get: function () {
                var start = new Date(this.date.getFullYear(), 0, 1);
                var result = [];
                for (var i = 0; i < 12; i++) {
                    result.push(start);
                    start = this._calendarModel.timedelta(start, 'month', 1);
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownArrowUp = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var node = this.monthsRef.find(function (date) { return date.nativeElement === event.target; });
            if (!node) {
                return;
            }
            var months = this.monthsRef.toArray();
            var nodeRect = node.nativeElement.getBoundingClientRect();
            for (var index = months.indexOf(node) - 1; index >= 0; index--) {
                var nextNodeRect = months[index].nativeElement.getBoundingClientRect();
                var tolerance = 6;
                if (nodeRect.top !== nextNodeRect.top && (nextNodeRect.left - nodeRect.left) < tolerance) {
                    var month = months[index];
                    month.nativeElement.focus();
                    this.activeMonth = month.value.getMonth();
                    break;
                }
            }
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownArrowDown = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var node = this.monthsRef.find(function (date) { return date.nativeElement === event.target; });
            if (!node) {
                return;
            }
            var months = this.monthsRef.toArray();
            var nodeRect = node.nativeElement.getBoundingClientRect();
            for (var index = months.indexOf(node) + 1; index < months.length; index++) {
                var nextNodeRect = months[index].nativeElement.getBoundingClientRect();
                var tolerance = 6;
                if (nextNodeRect.top !== nodeRect.top && (nodeRect.left - nextNodeRect.left) < tolerance) {
                    var month = months[index];
                    month.nativeElement.focus();
                    this.activeMonth = month.value.getMonth();
                    break;
                }
            }
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownArrowRight = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var node = this.monthsRef.find(function (date) { return date.nativeElement === event.target; });
            if (!node) {
                return;
            }
            var months = this.monthsRef.toArray();
            if (months.indexOf(node) + 1 < months.length) {
                var month = months[months.indexOf(node) + 1];
                this.activeMonth = month.value.getMonth();
                month.nativeElement.focus();
            }
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownArrowLeft = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var node = this.monthsRef.find(function (date) { return date.nativeElement === event.target; });
            if (!node) {
                return;
            }
            var months = this.monthsRef.toArray();
            if (months.indexOf(node) - 1 >= 0) {
                var month = months[months.indexOf(node) - 1];
                this.activeMonth = month.value.getMonth();
                month.nativeElement.focus();
            }
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownHome = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var month = this.monthsRef.toArray()[0];
            this.activeMonth = month.value.getMonth();
            month.nativeElement.focus();
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownEnd = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var months = this.monthsRef.toArray();
            var month = months[months.length - 1];
            this.activeMonth = month.value.getMonth();
            month.nativeElement.focus();
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownEnter = function (event) {
            var value = this.monthsRef.find(function (date) { return date.nativeElement === event.target; }).value;
            this.date = new Date(value.getFullYear(), value.getMonth(), this.date.getDate());
            this.activeMonth = this.date.getMonth();
            this.selected.emit(this.date);
            this._onChangeCallback(this.date);
        };
        IgxMonthsViewComponent.prototype.resetActiveMonth = function () {
            this.activeMonth = this.date.getMonth();
        };
        /**
         * Returns the locale representation of the month in the months view.
         *
         * @hidden
         */
        IgxMonthsViewComponent.prototype.formattedMonth = function (value) {
            if (this.formatView) {
                return this._formatterMonth.format(value);
            }
            return "" + value.getMonth();
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.selectMonth = function (event) {
            this.selected.emit(event);
            this.date = event;
            this.activeMonth = this.date.getMonth();
            this._onChangeCallback(this.date);
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.writeValue = function (value) {
            if (value) {
                this.date = value;
            }
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.monthTracker = function (index, item) {
            return item.getMonth() + "}";
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.initMonthFormatter = function () {
            this._formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this.monthFormat });
        };
        return IgxMonthsViewComponent;
    }());
    IgxMonthsViewComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxMonthsViewComponent, multi: true }],
                    selector: 'igx-months-view',
                    template: "<div class=\"igx-calendar__body\">\n    <div  class=\"igx-calendar__body-row--wrap\">\n        <span\n            role=\"button\"\n            [attr.aria-label]=\"month | date: 'LLLL'\"\n            [igxCalendarMonth]=\"month\"\n            [date]=\"date\"\n            [attr.tabindex]=\"activeMonth === month.getMonth() ? 0 : -1\"\n            (monthSelection)=\"selectMonth($event)\" [index]=\"i\"\n            *ngFor=\"let month of months; index as i; trackBy: monthTracker\">\n            {{ formattedMonth(month) | titlecase }}\n        </span>\n    </div>\n</div>\n\n"
                },] }
    ];
    IgxMonthsViewComponent.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxMonthsViewComponent.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        date: [{ type: i0.Input }],
        monthFormat: [{ type: i0.Input }],
        locale: [{ type: i0.Input }],
        formatView: [{ type: i0.Input }],
        selected: [{ type: i0.Output }],
        styleClass: [{ type: i0.HostBinding, args: ['class.igx-calendar',] }],
        monthsRef: [{ type: i0.ViewChildren, args: [IgxCalendarMonthDirective, { read: IgxCalendarMonthDirective },] }],
        onKeydownArrowUp: [{ type: i0.HostListener, args: ['keydown.arrowup', ['$event'],] }],
        onKeydownArrowDown: [{ type: i0.HostListener, args: ['keydown.arrowdown', ['$event'],] }],
        onKeydownArrowRight: [{ type: i0.HostListener, args: ['keydown.arrowright', ['$event'],] }],
        onKeydownArrowLeft: [{ type: i0.HostListener, args: ['keydown.arrowleft', ['$event'],] }],
        onKeydownHome: [{ type: i0.HostListener, args: ['keydown.home', ['$event'],] }],
        onKeydownEnd: [{ type: i0.HostListener, args: ['keydown.end', ['$event'],] }],
        onKeydownEnter: [{ type: i0.HostListener, args: ['keydown.enter', ['$event'],] }],
        resetActiveMonth: [{ type: i0.HostListener, args: ['focusout',] }]
    };

    var CalendarHammerConfig = /** @class */ (function (_super) {
        __extends(CalendarHammerConfig, _super);
        function CalendarHammerConfig() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.overrides = {
                pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
            };
            return _this;
        }
        return CalendarHammerConfig;
    }(i1$1.HammerGestureConfig));
    CalendarHammerConfig.decorators = [
        { type: i0.Injectable }
    ];
    var IgxYearsViewComponent = /** @class */ (function () {
        function IgxYearsViewComponent(el) {
            this.el = el;
            /**
             * Emits an event when a selection is made in the years view.
             * Provides reference the `date` property in the `IgxYearsViewComponent`.
             * ```html
             * <igx-years-view (selected)="onSelection($event)"></igx-years-view>
             * ```
             *
             * @memberof IgxYearsViewComponent
             */
            this.selected = new i0.EventEmitter();
            /**
             * The default css class applied to the component.
             *
             * @hidden
             */
            this.styleClass = true;
            /**
             * @hidden
             */
            this._locale = 'en';
            /**
             * @hidden
             */
            this._yearFormat = 'numeric';
            /**
             * @hidden
             */
            this._date = new Date();
            /**
             * @hidden
             */
            this._onTouchedCallback = rxjs.noop;
            /**
             * @hidden
             */
            this._onChangeCallback = rxjs.noop;
            this.initYearFormatter();
            this._calendarModel = new Calendar();
        }
        Object.defineProperty(IgxYearsViewComponent.prototype, "date", {
            /**
             * Gets/sets the selected date of the years view.
             * By default it is the current date.
             * ```html
             * <igx-years-view [date]="myDate"></igx-years-view>
             * ```
             * ```typescript
             * let date =  this.yearsView.date;
             * ```
             *
             * @memberof IgxYearsViewComponent
             */
            get: function () {
                return this._date;
            },
            set: function (value) {
                if (!(value instanceof Date)) {
                    return;
                }
                this._date = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxYearsViewComponent.prototype, "yearFormat", {
            /**
             * Gets the year format option of the years view.
             * ```typescript
             * let yearFormat = this.yearsView.yearFormat.
             * ```
             */
            get: function () {
                return this._yearFormat;
            },
            /**
             * Sets the year format option of the years view.
             * ```html
             * <igx-years-view [yearFormat]="numeric"></igx-years-view>
             * ```
             *
             * @memberof IgxYearsViewComponent
             */
            set: function (value) {
                this._yearFormat = value;
                this.initYearFormatter();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxYearsViewComponent.prototype, "locale", {
            /**
             * Gets the `locale` of the years view.
             * Default value is `"en"`.
             * ```typescript
             * let locale =  this.yearsView.locale;
             * ```
             *
             * @memberof IgxYearsViewComponent
             */
            get: function () {
                return this._locale;
            },
            /**
             * Sets the `locale` of the years view.
             * Expects a valid BCP 47 language tag.
             * Default value is `"en"`.
             * ```html
             * <igx-years-view [locale]="de"></igx-years-view>
             * ```
             *
             * @memberof IgxYearsViewComponent
             */
            set: function (value) {
                this._locale = value;
                this.initYearFormatter();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxYearsViewComponent.prototype, "decade", {
            /**
             * Returns an array of date objects which are then used to properly
             * render the years.
             *
             * Used in the template of the component.
             *
             * @hidden
             */
            get: function () {
                var e_1, _a;
                var result = [];
                var start = this.date.getFullYear() - 3;
                var end = this.date.getFullYear() + 4;
                try {
                    for (var _b = __values(range(start, end)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var year = _c.value;
                        result.push(new Date(year, this.date.getMonth(), this.date.getDate()));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.onKeydownArrowDown = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.generateYearRange(1);
            this.calendarDir.find(function (date) { return date.isCurrentYear; }).nativeElement.nextElementSibling.focus();
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.onKeydownArrowUp = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.generateYearRange(-1);
            this.calendarDir.find(function (date) { return date.isCurrentYear; }).nativeElement.previousElementSibling.focus();
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.onKeydownEnter = function () {
            this.selected.emit(this.date);
            this._onChangeCallback(this.date);
        };
        /**
         * Returns the locale representation of the year in the years view.
         *
         * @hidden
         */
        IgxYearsViewComponent.prototype.formattedYear = function (value) {
            if (this.formatView) {
                return this._formatterYear.format(value);
            }
            return "" + value.getFullYear();
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.selectYear = function (event) {
            this.date = event;
            this.selected.emit(this.date);
            this._onChangeCallback(this.date);
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.scroll = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var delta = event.deltaY < 0 ? -1 : 1;
            this.generateYearRange(delta);
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.pan = function (event) {
            var delta = event.deltaY < 0 ? 1 : -1;
            this.generateYearRange(delta);
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.yearTracker = function (index, item) {
            return item.getFullYear() + "}";
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.writeValue = function (value) {
            if (value) {
                this.date = value;
            }
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.initYearFormatter = function () {
            this._formatterYear = new Intl.DateTimeFormat(this._locale, { year: this.yearFormat });
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.generateYearRange = function (delta) {
            var currentYear = new Date().getFullYear();
            if ((delta > 0 && this.date.getFullYear() - currentYear >= 95) ||
                (delta < 0 && currentYear - this.date.getFullYear() >= 95)) {
                return;
            }
            this.date = this._calendarModel.timedelta(this.date, 'year', delta);
        };
        return IgxYearsViewComponent;
    }());
    IgxYearsViewComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: IgxYearsViewComponent,
                            multi: true
                        },
                        {
                            provide: i1$1.HAMMER_GESTURE_CONFIG,
                            useClass: CalendarHammerConfig
                        }
                    ],
                    selector: 'igx-years-view',
                    template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-column\" (wheel)=\"scroll($event)\" (pan)=\"pan($event)\">\n        <span\n            [igxCalendarYear]=\"year\"\n            [date]=\"date\"\n            (yearSelection)=\"selectYear($event)\"\n            *ngFor=\"let year of decade; trackBy: yearTracker\">\n\n            {{ formattedYear(year) }}\n        </span>\n    </div>\n</div>\n"
                },] }
    ];
    IgxYearsViewComponent.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxYearsViewComponent.propDecorators = {
        formatView: [{ type: i0.Input }],
        selected: [{ type: i0.Output }],
        styleClass: [{ type: i0.HostBinding, args: ['class.igx-calendar',] }],
        calendarDir: [{ type: i0.ViewChildren, args: [IgxCalendarYearDirective, { read: IgxCalendarYearDirective },] }],
        date: [{ type: i0.Input }],
        yearFormat: [{ type: i0.Input }],
        locale: [{ type: i0.Input }],
        onKeydownArrowDown: [{ type: i0.HostListener, args: ['keydown.arrowdown', ['$event'],] }],
        onKeydownArrowUp: [{ type: i0.HostListener, args: ['keydown.arrowup', ['$event'],] }],
        onKeydownEnter: [{ type: i0.HostListener, args: ['keydown.enter',] }]
    };

    /**
     * @hidden
     */
    var IgxDayItemComponent = /** @class */ (function () {
        function IgxDayItemComponent(elementRef) {
            this.elementRef = elementRef;
            this.hideOutsideDays = false;
            this.isLastInRange = false;
            this.isFirstInRange = false;
            this.isWithinRange = false;
            this.dateSelection = new i0.EventEmitter();
            this._selected = false;
        }
        Object.defineProperty(IgxDayItemComponent.prototype, "selected", {
            /**
             * Returns boolean indicating if the day is selected
             *
             */
            get: function () {
                return this._selected;
            },
            /**
             * Selects the day
             */
            set: function (value) {
                this._selected = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isCurrentMonth", {
            get: function () {
                return this.date.isCurrentMonth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isPreviousMonth", {
            get: function () {
                return this.date.isPrevMonth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isNextMonth", {
            get: function () {
                return this.date.isNextMonth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "nativeElement", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isSelectedCSS", {
            get: function () {
                return (!this.isDisabled && this.selected);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isInactive", {
            get: function () {
                return this.date.isNextMonth || this.date.isPrevMonth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isHidden", {
            get: function () {
                return this.hideOutsideDays && this.isInactive;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isToday", {
            get: function () {
                var today = new Date(Date.now());
                var date = this.date.date;
                if (date.getDate() === today.getDate()) {
                    this.nativeElement.setAttribute('aria-current', 'date');
                }
                return (date.getFullYear() === today.getFullYear() &&
                    date.getMonth() === today.getMonth() &&
                    date.getDate() === today.getDate());
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isWeekend", {
            get: function () {
                var day = this.date.date.getDay();
                return day === 0 || day === 6;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isDisabled", {
            get: function () {
                if (this.disabledDates === null) {
                    return false;
                }
                return isDateInRanges(this.date.date, this.disabledDates);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isOutOfRange", {
            get: function () {
                if (!this.outOfRangeDates) {
                    return false;
                }
                return isDateInRanges(this.date.date, this.outOfRangeDates);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isFocusable", {
            get: function () {
                return this.isCurrentMonth && !this.isHidden && !this.isDisabled && !this.isOutOfRange;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isWithinRangeCSS", {
            get: function () {
                return !this.isSingleSelection && this.isWithinRange;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isSpecial", {
            get: function () {
                if (this.specialDates === null) {
                    return false;
                }
                return isDateInRanges(this.date.date, this.specialDates);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "defaultCSS", {
            get: function () {
                return this.date.isCurrentMonth && !(this.isWeekend && this.selected);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isDisabledCSS", {
            get: function () {
                return this.isHidden || this.isDisabled || this.isOutOfRange;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isSingleSelection", {
            get: function () {
                return this.selection !== CalendarSelection.RANGE;
            },
            enumerable: false,
            configurable: true
        });
        IgxDayItemComponent.prototype.onSelect = function (event) {
            event.stopPropagation();
            this.dateSelection.emit(this.date);
        };
        return IgxDayItemComponent;
    }());
    IgxDayItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-day-item',
                    template: "<span aria-hidden=\"true\" class=\"igx-calendar__date-content\">\n    <ng-content></ng-content>\n</span>\n"
                },] }
    ];
    IgxDayItemComponent.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxDayItemComponent.propDecorators = {
        date: [{ type: i0.Input }],
        selection: [{ type: i0.Input }],
        selected: [{ type: i0.Input }],
        disabledDates: [{ type: i0.Input }],
        outOfRangeDates: [{ type: i0.Input }],
        specialDates: [{ type: i0.Input }],
        hideOutsideDays: [{ type: i0.Input }],
        isLastInRange: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.igx-calendar__date--last',] }],
        isFirstInRange: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.igx-calendar__date--first',] }],
        isWithinRange: [{ type: i0.Input }],
        dateSelection: [{ type: i0.Output }],
        isSelectedCSS: [{ type: i0.HostBinding, args: ['class.igx-calendar__date--selected',] }],
        isInactive: [{ type: i0.HostBinding, args: ['class.igx-calendar__date--inactive',] }],
        isHidden: [{ type: i0.HostBinding, args: ['class.igx-calendar__date--hidden',] }],
        isToday: [{ type: i0.HostBinding, args: ['class.igx-calendar__date--current',] }],
        isWeekend: [{ type: i0.HostBinding, args: ['class.igx-calendar__date--weekend',] }],
        isWithinRangeCSS: [{ type: i0.HostBinding, args: ['class.igx-calendar__date--range',] }],
        isSpecial: [{ type: i0.HostBinding, args: ['class.igx-calendar__date--special',] }],
        defaultCSS: [{ type: i0.HostBinding, args: ['class.igx-calendar__date',] }],
        isDisabledCSS: [{ type: i0.HostBinding, args: ['class.igx-calendar__date--disabled',] }],
        isSingleSelection: [{ type: i0.HostBinding, args: ['class.igx-calendar__date--single',] }],
        onSelect: [{ type: i0.HostListener, args: ['click', ['$event'],] }, { type: i0.HostListener, args: ['keydown.enter', ['$event'],] }]
    };

    var Direction;
    (function (Direction) {
        Direction["Up"] = "ArrowUp";
        Direction["Down"] = "ArrowDown";
        Direction["Left"] = "ArrowLeft";
        Direction["Right"] = "ArrowRight";
    })(Direction || (Direction = {}));
    var ARROW = 'Arrow';
    /** @hidden */
    var IgxDaysViewNavigationService = /** @class */ (function () {
        function IgxDaysViewNavigationService() {
        }
        /**
         * Implements kb navigation in all MoveDirections. nextDate and nextMonthView naming convention is used for both previous/next
         *
         * @hidden
         */
        IgxDaysViewNavigationService.prototype.focusNextDate = function (target, key, nextView) {
            if (nextView === void 0) { nextView = false; }
            if (target.childElementCount === 0) {
                target = target.parentElement;
            }
            if (key.indexOf('Arrow') === -1) {
                key = ARROW.concat(key);
            }
            var monthView = this.monthView;
            var node = monthView.dates.find(function (date) { return date.nativeElement === target; });
            var dates = monthView.dates.toArray();
            var day;
            var step;
            var i;
            var nextDate;
            var index = dates.indexOf(node);
            if (!node) {
                return;
            }
            // focus item in current month
            switch (key) {
                case Direction.Left: {
                    step = -1;
                    nextDate = this.timedelta(node.date.date, step);
                    for (i = index; i > 0; i--) {
                        day = nextView ? dates[i] : dates[i - 1];
                        nextDate = day.date.date;
                        if (day.date.isPrevMonth) {
                            break;
                        }
                        if (day && day.isFocusable) {
                            day.nativeElement.focus();
                            return;
                        }
                    }
                    break;
                }
                case Direction.Right: {
                    step = 1;
                    nextDate = this.timedelta(node.date.date, step);
                    for (i = index; i < dates.length - 1; i++) {
                        day = nextView ? dates[i] : dates[i + 1];
                        nextDate = day.date.date;
                        if (day.date.isNextMonth) {
                            break;
                        }
                        if (day && day.isFocusable) {
                            day.nativeElement.focus();
                            return;
                        }
                    }
                    break;
                }
                case Direction.Up: {
                    step = -7;
                    nextDate = this.timedelta(node.date.date, step);
                    for (i = index; i - 7 > -1; i -= 7) {
                        day = nextView ? dates[i] : dates[i - 7];
                        nextDate = day.date.date;
                        if (day.date.isPrevMonth) {
                            break;
                        }
                        if (day && day.isFocusable) {
                            day.nativeElement.focus();
                            return;
                        }
                    }
                    break;
                }
                case Direction.Down: {
                    step = 7;
                    nextDate = this.timedelta(node.date.date, step);
                    for (i = index; i + 7 < 42; i += 7) {
                        day = nextView ? dates[i] : dates[i + 7];
                        nextDate = day.date.date;
                        if (day.date.isNextMonth) {
                            break;
                        }
                        if (day && day.isFocusable) {
                            day.nativeElement.focus();
                            return;
                        }
                    }
                    break;
                }
            }
            // focus item in prev/next visible month
            var nextMonthView = step > 0 ? monthView.nextMonthView : monthView.prevMonthView;
            if (nextMonthView) {
                dates = nextMonthView.dates.toArray();
                day = dates.find(function (item) { return item.date.date.getTime() === nextDate.getTime(); });
                if (day && day.isFocusable) {
                    day.nativeElement.focus();
                    return;
                }
                nextMonthView.daysNavService.focusNextDate(day.nativeElement, key);
            }
            // if iterating in the visible prev/next moths above found a day that is not focusable, ie is disabled, hidden, etc
            // then it is needed to recalculate the next day, which is going to be part of the prev/next months
            if (day && !day.isFocusable) {
                day = dates[i + step];
                if (!day) {
                    nextDate = this.timedelta(node.date.date, step + i - index);
                }
            }
            // focus item in prev/next month, which is currently out of view
            var dayIsNextMonth; // determine what we need to check for next date - if it belongs to prev or next month
            if (day) {
                dayIsNextMonth = step > 0 ? day.date.isNextMonth : day.date.isPrevMonth;
            }
            if (monthView.changeDaysView && !nextMonthView && ((day && dayIsNextMonth) || !day)) {
                var monthAction = step > 0 ? exports.ScrollMonth.NEXT : exports.ScrollMonth.PREV;
                monthView.viewChanging.emit({ monthAction: monthAction, key: key, nextDate: nextDate });
            }
        };
        /**
         * Focuses first focusable day in the month. Will go to next visible month, if no day in the first month is focusable
         *
         * @hidden
         */
        IgxDaysViewNavigationService.prototype.focusHomeDate = function () {
            var monthView = this.monthView;
            while (!this.focusFirstDay(monthView) && monthView.nextMonthView) {
                monthView = monthView.nextMonthView;
            }
        };
        /**
         * Focuses last focusable day in the month. Will go to previous visible month, if no day in the first month is focusable
         *
         * @hidden
         */
        IgxDaysViewNavigationService.prototype.focusEndDate = function () {
            var monthView = this.monthView;
            while (!this.focusLastDay(monthView) && monthView.prevMonthView) {
                monthView = monthView.prevMonthView;
            }
        };
        IgxDaysViewNavigationService.prototype.timedelta = function (date, units) {
            var ret = new Date(date);
            ret.setDate(ret.getDate() + units);
            return ret;
        };
        IgxDaysViewNavigationService.prototype.focusFirstDay = function (monthView) {
            var e_1, _a;
            var dates = monthView.dates.filter(function (d) { return d.isCurrentMonth; });
            try {
                for (var dates_1 = __values(dates), dates_1_1 = dates_1.next(); !dates_1_1.done; dates_1_1 = dates_1.next()) {
                    var date = dates_1_1.value;
                    if (date.isFocusable) {
                        date.nativeElement.focus();
                        return true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (dates_1_1 && !dates_1_1.done && (_a = dates_1.return)) _a.call(dates_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return false;
        };
        IgxDaysViewNavigationService.prototype.focusLastDay = function (monthView) {
            var dates = monthView.dates.filter(function (d) { return d.isCurrentMonth; });
            for (var i = dates.length - 1; i >= 0; i--) {
                if (dates[i].isFocusable) {
                    dates[i].nativeElement.focus();
                    return true;
                }
            }
            return false;
        };
        return IgxDaysViewNavigationService;
    }());
    IgxDaysViewNavigationService.decorators = [
        { type: i0.Injectable }
    ];

    var NEXT_ID$b = 0;
    var IgxDaysViewComponent = /** @class */ (function (_super) {
        __extends(IgxDaysViewComponent, _super);
        /**
         * @hidden
         */
        function IgxDaysViewComponent(daysNavService) {
            var _this = _super.call(this) || this;
            _this.daysNavService = daysNavService;
            /**
             * Sets/gets the `id` of the days view.
             * If not set, the `id` will have value `"igx-days-view-0"`.
             * ```html
             * <igx-days-view id="my-days-view"></igx-days-view>
             * ```
             * ```typescript
             * let daysViewId =  this.daysView.id;
             * ```
             */
            _this.id = "igx-days-view-" + NEXT_ID$b++;
            /**
             * @hidden
             */
            _this.changeDaysView = false;
            /**
             * @hidden
             */
            _this.dateSelection = new i0.EventEmitter();
            /**
             * @hidden
             */
            _this.viewChanging = new i0.EventEmitter();
            /**
             * @hidden
             */
            _this.activeDateChange = new i0.EventEmitter();
            /**
             * @hidden
             */
            _this.monthsViewBlur = new i0.EventEmitter();
            /**
             * The default css class applied to the component.
             *
             * @hidden
             */
            _this.styleClass = true;
            /** @hidden */
            _this.shouldResetDate = true;
            return _this;
        }
        Object.defineProperty(IgxDaysViewComponent.prototype, "activeDate", {
            get: function () {
                return this._activeDate ? this._activeDate : this.viewDate.toLocaleDateString();
            },
            /**
             * @hidden
             * @internal
             */
            set: function (value) {
                this._activeDate = value;
                this.activeDateChange.emit(this._activeDate);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxDaysViewComponent.prototype.resetActiveMonth = function () {
            if (this.shouldResetDate) {
                var date = this.dates.find(function (day) { return day.selected && day.isCurrentMonth; }) ||
                    this.dates.find(function (day) { return day.isToday && day.isCurrentMonth; }) ||
                    this.dates.find(function (d) { return d.isFocusable; });
                if (date) {
                    this.activeDate = date.date.date.toLocaleDateString();
                }
                this.monthsViewBlur.emit();
            }
            this.shouldResetDate = true;
        };
        /**
         * @hidden
         * @internal
         */
        IgxDaysViewComponent.prototype.pointerDown = function () {
            this.shouldResetDate = false;
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.onKeydownArrow = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.shouldResetDate = false;
            this.daysNavService.focusNextDate(event.target, event.key);
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.onKeydownHome = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.shouldResetDate = false;
            this.getFirstMonthView().daysNavService.focusHomeDate();
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.onKeydownEnd = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.shouldResetDate = false;
            this.getLastMonthView().daysNavService.focusEndDate();
        };
        Object.defineProperty(IgxDaysViewComponent.prototype, "getCalendarMonth", {
            /**
             * @hidden
             */
            get: function () {
                return this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth(), true);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.ngOnInit = function () {
            this.daysNavService.monthView = this;
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.ngDoCheck = function () {
            if (!this.changeDaysView && this.dates) {
                this.disableOutOfRangeDates();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxDaysViewComponent.prototype.tabIndex = function (day) {
            return this.activeDate && this.activeDate === day.date.toLocaleDateString() && day.isCurrentMonth ? 0 : -1;
        };
        /**
         * Returns the week number by date
         *
         * @hidden
         */
        IgxDaysViewComponent.prototype.getWeekNumber = function (date) {
            return this.calendarModel.getWeekNumber(date);
        };
        /**
         * Returns the locale representation of the date in the days view.
         *
         * @hidden
         */
        IgxDaysViewComponent.prototype.formattedDate = function (value) {
            if (this.formatViews.day) {
                return this.formatterDay.format(value);
            }
            return "" + value.getDate();
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.generateWeekHeader = function () {
            var e_1, _a;
            var dayNames = [];
            var rv = this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth())[0];
            try {
                for (var rv_1 = __values(rv), rv_1_1 = rv_1.next(); !rv_1_1.done; rv_1_1 = rv_1.next()) {
                    var day = rv_1_1.value;
                    dayNames.push(this.formatterWeekday.format(day.date));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (rv_1_1 && !rv_1_1.done && (_a = rv_1.return)) _a.call(rv_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return dayNames;
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.rowTracker = function (index, item) {
            return "" + item[index].date.getMonth() + item[index].date.getDate();
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.dateTracker = function (index, item) {
            return item.date.getMonth() + "--" + item.date.getDate();
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.isCurrentMonth = function (value) {
            return this.viewDate.getMonth() === value.getMonth();
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.isCurrentYear = function (value) {
            return this.viewDate.getFullYear() === value.getFullYear();
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.isSelected = function (date) {
            var selectedDates;
            if (this.isDateDisabled(date.date) || !this.value ||
                (Array.isArray(this.value) && this.value.length === 0)) {
                return false;
            }
            if (this.selection === CalendarSelection.SINGLE) {
                selectedDates = this.value;
                return this.getDateOnly(selectedDates).getTime() === date.date.getTime();
            }
            selectedDates = this.value;
            if (this.selection === CalendarSelection.RANGE && selectedDates.length === 1) {
                return this.getDateOnly(selectedDates[0]).getTime() === date.date.getTime();
            }
            if (this.selection === CalendarSelection.MULTI) {
                var start = this.getDateOnly(selectedDates[0]);
                var end = this.getDateOnly(selectedDates[selectedDates.length - 1]);
                if (this.isWithinRange(date.date, false, start, end)) {
                    var currentDate = selectedDates.find(function (element) { return element.getTime() === date.date.getTime(); });
                    return !!currentDate;
                }
                else {
                    return false;
                }
            }
            else {
                return this.isWithinRange(date.date, true);
            }
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.isLastInRange = function (date) {
            if (this.isSingleSelection || !this.value) {
                return false;
            }
            var dates = this.value;
            var lastDate = dates[dates.length - 1];
            return isEqual(lastDate, date.date);
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.isFirstInRange = function (date) {
            if (this.isSingleSelection || !this.value) {
                return false;
            }
            return isEqual(this.value[0], date.date);
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.isWithinRange = function (date, checkForRange, min, max) {
            if (checkForRange && !(Array.isArray(this.value) && this.value.length > 1)) {
                return false;
            }
            min = min ? min : this.value[0];
            max = max ? max : this.value[this.value.length - 1];
            return isDateInRanges(date, [
                {
                    type: exports.DateRangeType.Between,
                    dateRange: [min, max]
                }
            ]);
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.focusActiveDate = function () {
            var date = this.dates.find(function (d) { return d.selected; });
            if (!date) {
                date = this.dates.find(function (d) { return d.isToday; });
            }
            if (date.isFocusable) {
                date.nativeElement.focus();
            }
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.selectDay = function (event) {
            this.selectDateFromClient(event.date);
            this.dateSelection.emit(event);
            this.selected.emit(this.selectedDates);
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.getFirstMonthView = function () {
            var monthView = this;
            while (monthView.prevMonthView) {
                monthView = monthView.prevMonthView;
            }
            return monthView;
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.disableOutOfRangeDates = function () {
            var dateRange = [];
            this.dates.toArray().forEach(function (date) {
                if (!date.isCurrentMonth) {
                    dateRange.push(date.date.date);
                }
            });
            this.outOfRangeDates = [{
                    type: exports.DateRangeType.Specific,
                    dateRange: dateRange
                }];
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.getLastMonthView = function () {
            var monthView = this;
            while (monthView.nextMonthView) {
                monthView = monthView.nextMonthView;
            }
            return monthView;
        };
        Object.defineProperty(IgxDaysViewComponent.prototype, "isSingleSelection", {
            /**
             * @hidden
             */
            get: function () {
                return this.selection !== CalendarSelection.RANGE;
            },
            enumerable: false,
            configurable: true
        });
        return IgxDaysViewComponent;
    }(IgxCalendarBaseDirective));
    IgxDaysViewComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [
                        {
                            multi: true,
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: IgxDaysViewComponent
                        },
                        { provide: IgxDaysViewNavigationService, useClass: IgxDaysViewNavigationService }
                    ],
                    selector: 'igx-days-view',
                    template: "<div role=\"row\" class=\"igx-calendar__body-row\">\n    <div role=\"columnheader\" *ngIf=\"showWeekNumbers\" class=\"igx-calendar__label igx-calendar__label--week-number\">\n        <span>Wk</span>\n    </div>\n    <span role=\"columnheader\" [attr.aria-label]=\"dayName\" *ngFor=\"let dayName of generateWeekHeader()\" class=\"igx-calendar__label\">\n        {{ dayName | titlecase }}\n    </span>\n</div>\n\n<div *ngFor=\"let week of getCalendarMonth; last as isLast; index as i; trackBy: rowTracker\"\n     class=\"igx-calendar__body-row\" role=\"row\">\n\n    <div *ngIf=\"showWeekNumbers\" class=\"igx-calendar__date igx-calendar__date--week-number\">\n\n        <span role=\"rowheader\" class=\"igx-calendar__date-content igx-calendar__date-content--week-number\">\n            {{getWeekNumber(week[0].date)}}\n        </span>\n\n    </div>\n\n    <!-- <igx-week-number-item *ngIf=\"showWeekNumbers\">{{getWeekNumber(week[0].date)}}</igx-week-number-item> -->\n    <igx-day-item\n        *ngFor=\"let day of week; trackBy: dateTracker\"\n        [attr.aria-selected]=\"isSelected(day)\"\n        role=\"gridcell\"\n        [attr.aria-disabled]=\"isDateDisabled(day.date)\"\n        [attr.aria-label]=\"isFirstInRange(day) ? day.date.toDateString() + ', ' + resourceStrings.igx_calendar_range_start : isLastInRange(day) ? day.date.toDateString() + ', ' +  resourceStrings.igx_calendar_range_end  : day.date.toDateString()\"\n        [date]=\"day\"\n        [selection]=\"selection\"\n        [selected]=\"isSelected(day)\"\n        [isLastInRange]=\"isLastInRange(day)\"\n        [isFirstInRange]=\"isFirstInRange(day)\"\n        [isWithinRange]=\"isWithinRange(day.date, true)\"\n        [disabledDates]=\"disabledDates\"\n        [specialDates]=\"specialDates\"\n        [outOfRangeDates]=\"outOfRangeDates\"\n        [hideOutsideDays]=\"hideOutsideDays\"\n        [attr.tabindex]=\"tabIndex(day)\"\n        (focus)=\"activeDate = day.date.toLocaleDateString()\"\n        (dateSelection)=\"selectDay($event)\">\n        {{ formattedDate(day.date) }}\n    </igx-day-item>\n</div>\n\n"
                },] }
    ];
    IgxDaysViewComponent.ctorParameters = function () { return [
        { type: IgxDaysViewNavigationService }
    ]; };
    IgxDaysViewComponent.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        changeDaysView: [{ type: i0.Input }],
        showWeekNumbers: [{ type: i0.Input }],
        activeDate: [{ type: i0.Input }],
        dateSelection: [{ type: i0.Output }],
        viewChanging: [{ type: i0.Output }],
        activeDateChange: [{ type: i0.Output }],
        monthsViewBlur: [{ type: i0.Output }],
        dates: [{ type: i0.ViewChildren, args: [IgxDayItemComponent, { read: IgxDayItemComponent },] }],
        styleClass: [{ type: i0.HostBinding, args: ['class.igx-calendar',] }],
        resetActiveMonth: [{ type: i0.HostListener, args: ['focusout',] }],
        pointerDown: [{ type: i0.HostListener, args: ['keydown.pagedown',] }, { type: i0.HostListener, args: ['keydown.pageup',] }, { type: i0.HostListener, args: ['keydown.shift.pagedown',] }, { type: i0.HostListener, args: ['keydown.shift.pageup',] }, { type: i0.HostListener, args: ['pointerdown',] }],
        onKeydownArrow: [{ type: i0.HostListener, args: ['keydown.arrowleft', ['$event'],] }, { type: i0.HostListener, args: ['keydown.arrowright', ['$event'],] }, { type: i0.HostListener, args: ['keydown.arrowup', ['$event'],] }, { type: i0.HostListener, args: ['keydown.arrowdown', ['$event'],] }],
        onKeydownHome: [{ type: i0.HostListener, args: ['keydown.home', ['$event'],] }],
        onKeydownEnd: [{ type: i0.HostListener, args: ['keydown.end', ['$event'],] }]
    };

    var NEXT_ID$c = 0;
    /**
     * Calendar provides a way to display date information.
     *
     * @igxModule IgxCalendarModule
     *
     * @igxTheme igx-calendar-theme, igx-icon-theme
     *
     * @igxKeywords calendar, datepicker, schedule, date
     *
     * @igxGroup Scheduling
     *
     * @remarks
     * The Ignite UI Calendar provides an easy way to display a calendar and allow users to select dates using single, multiple
     * or range selection.
     *
     * @example:
     * ```html
     * <igx-calendar selection="range"></igx-calendar>
     * ```
     */
    var IgxCalendarComponent = /** @class */ (function (_super) {
        __extends(IgxCalendarComponent, _super);
        function IgxCalendarComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            /**
             * Sets/gets the `id` of the calendar.
             *
             * @remarks
             * If not set, the `id` will have value `"igx-calendar-0"`.
             *
             * @example
             * ```html
             * <igx-calendar id="my-first-calendar"></igx-calendar>
             * ```
             * @memberof IgxCalendarComponent
             */
            _this.id = "igx-calendar-" + NEXT_ID$c++;
            /**
             * Sets/gets whether the calendar has header.
             * Default value is `true`.
             *
             * @example
             * ```html
             * <igx-calendar [hasHeader]="false"></igx-calendar>
             * ```
             */
            _this.hasHeader = true;
            /**
             * Sets/gets whether the calendar header will be in vertical position.
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-calendar [vertical] = "true"></igx-calendar>
             * ```
             */
            _this.vertical = false;
            /**
             * Show/hide week numbers
             *
             * @example
             * ```html
             * <igx-calendar [showWeekNumbers]="true"></igx-calendar>
             * ``
             */
            _this.showWeekNumbers = false;
            /**
             * Apply the different states for the transitions of animateChange
             *
             * @hidden
             * @internal
             */
            _this.animationAction = '';
            /**
             * The default css class applied to the component.
             *
             * @hidden
             * @internal
             */
            _this.styleClass = true;
            /**
             * @hidden
             * @internal
             */
            _this.activeDate = new Date().toLocaleDateString();
            /**
             * Denote if the calendar view was changed with the keyboard
             *
             * @hidden
             * @internal
             */
            _this.isKeydownTrigger = false;
            /**
             * @hidden
             * @internal
             */
            _this._monthsViewNumber = 1;
            /**
             * Continious navigation through the previous months
             *
             * @hidden
             * @internal
             */
            _this.startPrevMonthScroll = function (isKeydownTrigger) {
                if (isKeydownTrigger === void 0) { isKeydownTrigger = false; }
                _this.startMonthScroll$.next();
                _this.monthScrollDirection = exports.ScrollMonth.PREV;
                _this.animationAction = exports.ScrollMonth.PREV;
                _this.previousMonth(isKeydownTrigger);
            };
            /**
             * Continious navigation through the next months
             *
             * @hidden
             * @internal
             */
            _this.startNextMonthScroll = function (isKeydownTrigger) {
                if (isKeydownTrigger === void 0) { isKeydownTrigger = false; }
                _this.startMonthScroll$.next();
                _this.monthScrollDirection = exports.ScrollMonth.NEXT;
                _this.animationAction = exports.ScrollMonth.NEXT;
                _this.nextMonth(isKeydownTrigger);
            };
            /**
             * Stop continuous navigation
             *
             * @hidden
             * @internal
             */
            _this.stopMonthScroll = function (event) {
                event.stopPropagation();
                // generally the scrolling is built on the calendar component
                // and all start/stop scrolling methods are called on the calendar
                // if we change below lines to call stopMonthScroll$ on the calendar instead of on the views,
                // strange bug is introduced --> after changing number of months, continuous scrolling on mouse click does not happen
                _this.daysView.stopMonthScroll$.next(true);
                _this.daysView.stopMonthScroll$.complete();
                if (_this.monthScrollDirection === exports.ScrollMonth.PREV) {
                    _this.prevMonthBtn.nativeElement.focus();
                }
                else if (_this.monthScrollDirection === exports.ScrollMonth.NEXT) {
                    _this.nextMonthBtn.nativeElement.focus();
                }
                if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                    _this.resetActiveDate();
                }
                _this.monthScrollDirection = exports.ScrollMonth.NONE;
            };
            return _this;
        }
        Object.defineProperty(IgxCalendarComponent.prototype, "monthsViewNumber", {
            /**
             * Sets/gets the number of month views displayed.
             * Default value is `1`.
             *
             * @example
             * ```html
             * <igx-calendar [monthsViewNumber]="2"></igx-calendar>
             * ```
             */
            get: function () {
                return this._monthsViewNumber;
            },
            set: function (val) {
                if (val < 1) {
                    return;
                }
                this._monthsViewNumber = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "styleVerticalClass", {
            /**
             * The default css class applied to the component.
             *
             * @hidden
             * @internal
             */
            get: function () {
                return this.vertical;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "isYearView", {
            /**
             * Denote if the year view is active.
             *
             * @hidden
             * @internal
             */
            get: function () {
                return this.activeView === exports.CalendarView.YEAR || this.activeView === IgxCalendarView.Year;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "headerTemplate", {
            /**
             * Gets the header template.
             *
             * @example
             * ```typescript
             * let headerTemplate =  this.calendar.headerTeamplate;
             * ```
             * @memberof IgxCalendarComponent
             */
            get: function () {
                if (this.headerTemplateDirective) {
                    return this.headerTemplateDirective.template;
                }
                return null;
            },
            /**
             * Sets the header template.
             *
             * @example
             * ```html
             * <igx-calendar headerTemplateDirective = "igxCalendarHeader"></igx-calendar>
             * ```
             * @memberof IgxCalendarComponent
             */
            set: function (directive) {
                this.headerTemplateDirective = directive;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "subheaderTemplate", {
            /**
             * Gets the subheader template.
             *
             * @example
             * ```typescript
             * let subheaderTemplate = this.calendar.subheaderTemplate;
             * ```
             */
            get: function () {
                if (this.subheaderTemplateDirective) {
                    return this.subheaderTemplateDirective.template;
                }
                return null;
            },
            /**
             * Sets the subheader template.
             *
             * @example
             * ```html
             * <igx-calendar subheaderTemplate = "igxCalendarSubheader"></igx-calendar>
             * ```
             * @memberof IgxCalendarComponent
             */
            set: function (directive) {
                this.subheaderTemplateDirective = directive;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "headerContext", {
            /**
             * Gets the context for the template marked with the `igxCalendarHeader` directive.
             *
             * @example
             * ```typescript
             * let headerContext =  this.calendar.headerContext;
             * ```
             */
            get: function () {
                var date = this.headerDate;
                return this.generateContext(date);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "context", {
            /**
             * Gets the context for the template marked with either `igxCalendarSubHeaderMonth`
             * or `igxCalendarSubHeaderYear` directive.
             *
             * @example
             * ```typescript
             * let context =  this.calendar.context;
             * ```
             */
            get: function () {
                var date = this.viewDate;
                return this.generateContext(date);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "headerDate", {
            /**
             * Date displayed in header
             *
             * @hidden
             * @internal
             */
            get: function () {
                return this.selectedDates ? this.selectedDates : new Date();
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Keyboard navigation of the calendar
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onKeydownPageDown = function (event) {
            var _this = this;
            event.preventDefault();
            if (!this.isDefaultView) {
                return;
            }
            var isPageDown = event.key === 'PageDown';
            var step = isPageDown ? 1 : -1;
            var monthView = this.daysView;
            var activeDate;
            while (!activeDate && monthView) {
                activeDate = monthView.dates.find(function (date) { return date.nativeElement === document.activeElement; });
                monthView = monthView.nextMonthView;
            }
            if (activeDate) {
                this.nextDate = new Date(activeDate.date.date);
                var year = this.nextDate.getFullYear();
                var month = this.nextDate.getMonth() + step;
                if (isPageDown) {
                    if (month > 11) {
                        month = 0;
                        year += step;
                    }
                }
                else {
                    if (month < 0) {
                        month = 11;
                        year += step;
                    }
                }
                var range = monthRange(this.nextDate.getFullYear(), month);
                var day = this.nextDate.getDate();
                if (day > range[1]) {
                    day = range[1];
                }
                this.nextDate.setDate(day);
                this.nextDate.setMonth(month);
                this.nextDate.setFullYear(year);
                this.callback = function (next) {
                    monthView = _this.daysView;
                    var dayItem;
                    while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                        dayItem = monthView.dates.find(function (d) { return d.date.date.getTime() === next.getTime(); });
                        monthView = monthView.nextMonthView;
                    }
                    if (dayItem && dayItem.isFocusable) {
                        dayItem.nativeElement.focus();
                    }
                };
            }
            if (isPageDown) {
                if (event.repeat) {
                    requestAnimationFrame(function () { return _this.nextMonth(true); });
                }
                else {
                    this.nextMonth(true);
                }
            }
            else {
                if (event.repeat) {
                    requestAnimationFrame(function () { return _this.previousMonth(true); });
                }
                else {
                    this.previousMonth(true);
                }
            }
        };
        /**
         * Keyboard navigation of the calendar
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onKeydownShiftPageUp = function (event) {
            var _this = this;
            event.preventDefault();
            if (!this.isDefaultView) {
                return;
            }
            var isPageDown = event.key === 'PageDown';
            var step = isPageDown ? 1 : -1;
            this.previousViewDate = this.viewDate;
            this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', step);
            this.animationAction = isPageDown ? exports.ScrollMonth.NEXT : exports.ScrollMonth.PREV;
            this.isKeydownTrigger = true;
            var monthView = this.daysView;
            var activeDate;
            while (!activeDate && monthView) {
                activeDate = monthView.dates.find(function (date) { return date.nativeElement === document.activeElement; });
                monthView = monthView.nextMonthView;
            }
            if (activeDate) {
                this.nextDate = new Date(activeDate.date.date);
                var year = this.nextDate.getFullYear() + step;
                var range = monthRange(year, this.nextDate.getMonth());
                var day = this.nextDate.getDate();
                if (day > range[1]) {
                    day = range[1];
                }
                this.nextDate.setDate(day);
                this.nextDate.setFullYear(year);
                this.callback = function (next) {
                    monthView = _this.daysView;
                    var dayItem;
                    while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                        dayItem = monthView.dates.find(function (d) { return d.date.date.getTime() === next.getTime(); });
                        monthView = monthView.nextMonthView;
                    }
                    if (dayItem && dayItem.isFocusable) {
                        dayItem.nativeElement.focus();
                    }
                };
            }
        };
        /**
         * Keyboard navigation of the calendar
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onKeydownHome = function (event) {
            if (this.daysView) {
                this.daysView.onKeydownHome(event);
            }
        };
        /**
         * Keyboard navigation of the calendar
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onKeydownEnd = function (event) {
            if (this.daysView) {
                this.daysView.onKeydownEnd(event);
            }
        };
        /**
         * Stop continuous navigation on mouseup event
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onMouseUp = function (event) {
            if (this.monthScrollDirection !== exports.ScrollMonth.NONE) {
                this.stopMonthScroll(event);
            }
        };
        IgxCalendarComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.setSiblingMonths(this.monthViews);
            this._monthViewsChanges$ = this.monthViews.changes.subscribe(function (c) {
                _this.setSiblingMonths(c);
            });
            this.startMonthScroll$.pipe(operators.takeUntil(this.stopMonthScroll$), operators.switchMap(function () { return _this.scrollMonth$.pipe(operators.skipLast(1), operators.debounce(function () { return rxjs.interval(300); }), operators.takeUntil(_this.stopMonthScroll$)); })).subscribe(function () {
                switch (_this.monthScrollDirection) {
                    case exports.ScrollMonth.PREV:
                        _this.previousMonth();
                        break;
                    case exports.ScrollMonth.NEXT:
                        _this.nextMonth();
                        break;
                    case exports.ScrollMonth.NONE:
                    default:
                        break;
                }
            });
        };
        /**
         * Returns the locale representation of the month in the month view if enabled,
         * otherwise returns the default `Date.getMonth()` value.
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.formattedMonth = function (value) {
            if (this.formatViews.month) {
                return this.formatterMonth.format(value);
            }
            return "" + value.getMonth();
        };
        /**
         * Change to previous month
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.previousMonth = function (isKeydownTrigger) {
            if (isKeydownTrigger === void 0) { isKeydownTrigger = false; }
            if (isKeydownTrigger && this.animationAction === exports.ScrollMonth.NEXT) {
                return;
            }
            this.previousViewDate = this.viewDate;
            this.viewDate = this.calendarModel.getPrevMonth(this.viewDate);
            this.animationAction = exports.ScrollMonth.PREV;
            this.isKeydownTrigger = isKeydownTrigger;
        };
        IgxCalendarComponent.prototype.suppressBlur = function () {
            var _a;
            (_a = this.monthViews) === null || _a === void 0 ? void 0 : _a.forEach(function (d) { return d.shouldResetDate = false; });
            if (this.daysView) {
                this.daysView.shouldResetDate = false;
            }
        };
        /**
         * Change to next month
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.nextMonth = function (isKeydownTrigger) {
            if (isKeydownTrigger === void 0) { isKeydownTrigger = false; }
            if (isKeydownTrigger && this.animationAction === 'prev') {
                return;
            }
            this.isKeydownTrigger = isKeydownTrigger;
            this.previousViewDate = this.viewDate;
            this.viewDate = this.calendarModel.getNextMonth(this.viewDate);
            this.animationAction = exports.ScrollMonth.NEXT;
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onActiveViewDecade = function (args, activeViewIdx) {
            var _this = this;
            _super.prototype.activeViewDecade.call(this, activeViewIdx);
            requestAnimationFrame(function () {
                if (_this.dacadeView) {
                    _this.dacadeView.date = args;
                    _this.dacadeView.calendarDir.find(function (date) { return date.isCurrentYear; }).nativeElement.focus();
                }
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onActiveViewDecadeKB = function (event, args, activeViewIdx) {
            var _this = this;
            _super.prototype.activeViewDecadeKB.call(this, event, activeViewIdx);
            requestAnimationFrame(function () {
                if (_this.dacadeView) {
                    _this.dacadeView.date = args;
                    _this.dacadeView.calendarDir.find(function (date) { return date.isCurrentYear; }).nativeElement.focus();
                }
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.getFormattedDate = function () {
            var date = this.headerDate;
            return {
                monthday: this.formatterMonthday.format(date),
                weekday: this.formatterWeekday.format(date),
            };
        };
        /**
         * Handles invoked on date selection
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.childClicked = function (instance) {
            if (instance.isPrevMonth) {
                this.previousMonth();
            }
            if (instance.isNextMonth) {
                this.nextMonth();
            }
            this.selectDateFromClient(instance.date);
            if (this.selection === 'multi') {
                this.deselectDateInMonthViews(instance.date);
            }
            this.selected.emit(this.selectedDates);
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.viewChanging = function (args) {
            var _this = this;
            this.animationAction = args.monthAction;
            this.isKeydownTrigger = true;
            this.nextDate = args.nextDate;
            this.callback = function (next) {
                var day = _this.daysView.dates.find(function (item) { return item.date.date.getTime() === next.getTime(); });
                if (day) {
                    _this.daysView.daysNavService.focusNextDate(day.nativeElement, args.key, true);
                }
            };
            this.previousViewDate = this.viewDate;
            this.viewDate = this.nextDate;
        };
        /**
         * @hidden
         * @intenal
         */
        IgxCalendarComponent.prototype.changeMonth = function (event) {
            var _this = this;
            this.previousViewDate = this.viewDate;
            this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
            this.activeView = IgxCalendarView.Month;
            requestAnimationFrame(function () {
                var elem = _this.monthsBtns.find(function (e, idx) { return idx === _this.activeViewIdx; });
                if (elem) {
                    elem.nativeElement.focus();
                }
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onActiveViewYear = function (args, activeViewIdx) {
            var _this = this;
            this.activeView = IgxCalendarView.Year;
            this.activeViewIdx = activeViewIdx;
            requestAnimationFrame(function () {
                _this.monthsView.date = args;
                _this.focusMonth();
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onActiveViewYearKB = function (args, event, activeViewIdx) {
            if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                event.preventDefault();
                this.onActiveViewYear(args, activeViewIdx);
            }
        };
        /**
         * Deselects date(s) (based on the selection type).
         *
         * @example
         * ```typescript
         *  this.calendar.deselectDate(new Date(`2018-06-12`));
         * ````
         */
        IgxCalendarComponent.prototype.deselectDate = function (value) {
            var _this = this;
            _super.prototype.deselectDate.call(this, value);
            this.monthViews.forEach(function (view) {
                view.selectedDates = _this.selectedDates;
                view.rangeStarted = false;
            });
            this._onChangeCallback(this.selectedDates);
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.getViewDate = function (i) {
            var date = this.calendarModel.timedelta(this.viewDate, 'month', i);
            return date;
        };
        /**
         * Getter for the context object inside the calendar templates.
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.getContext = function (i) {
            var date = this.getViewDate(i);
            return this.generateContext(date, i);
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.animationDone = function (event) {
            if ((event.fromState === exports.ScrollMonth.NONE && (event.toState === exports.ScrollMonth.PREV || event.toState === exports.ScrollMonth.NEXT)) ||
                (event.fromState === 'void' && event.toState === exports.ScrollMonth.NONE)) {
                this.viewDateChanged.emit({ previousValue: this.previousViewDate, currentValue: this.viewDate });
            }
            if (!this.isKeydownTrigger) {
                this.resetActiveDate();
            }
            if (this.monthScrollDirection !== exports.ScrollMonth.NONE) {
                this.scrollMonth$.next();
            }
            if (!this.isDefaultView) {
                return;
            }
            var monthView = this.daysView;
            var date = monthView.dates.find(function (d) { return d.selected; });
            while (!date && monthView.nextMonthView) {
                monthView = monthView.nextMonthView;
                date = monthView.dates.find(function (d) { return d.selected; });
            }
            if (date && date.isFocusable && !this.isKeydownTrigger) {
                setTimeout(function () {
                    date.nativeElement.focus();
                }, parseInt(slideInRight.options.params.duration, 10));
            }
            else if (this.callback && (event.toState === exports.ScrollMonth.NEXT || event.toState === exports.ScrollMonth.PREV)) {
                this.callback(this.nextDate);
            }
            this.animationAction = exports.ScrollMonth.NONE;
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.viewRendered = function (event) {
            if (event.fromState !== 'void') {
                this.activeViewChanged.emit(this.activeView);
                if (this.isDefaultView) {
                    this.resetActiveDate();
                }
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.resetActiveDate = function () {
            if (!this.monthViews) {
                return;
            }
            var dates = [];
            this.monthViews.map(function (mv) { return mv.dates; }).forEach(function (days) {
                dates = dates.concat(days.toArray());
            });
            var date = dates.find(function (day) { return day.selected && day.isCurrentMonth; }) || dates.find(function (day) { return day.isToday && day.isCurrentMonth; })
                || dates.find(function (d) { return d.isFocusable; });
            if (date) {
                this.activeDate = date.date.date.toLocaleDateString();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.ngOnDestroy = function () {
            if (this._monthViewsChanges$) {
                this._monthViewsChanges$.unsubscribe();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.getPrevMonth = function (date) {
            return this.calendarModel.getPrevMonth(date);
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.getNextMonth = function (date, viewIndex) {
            return this.calendarModel.getDateByView(date, 'Month', viewIndex);
        };
        /**
         * Helper method building and returning the context object inside
         * the calendar templates.
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.generateContext = function (value, i) {
            var _this = this;
            var formatObject = Object.assign({ index: i, monthView: function () { return _this.onActiveViewYear(value, i); }, yearView: function () { return _this.onActiveViewDecade(value, i); } }, this.calendarModel.formatToParts(value, this.locale, this.formatOptions, ['era', 'year', 'month', 'day', 'weekday']));
            return { $implicit: formatObject };
        };
        /**
         * Helper method that sets references for prev/next months for each month in the view
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.setSiblingMonths = function (monthViews) {
            var _this = this;
            monthViews.forEach(function (item, index) {
                var prevMonthView = _this.getMonthView(index - 1);
                var nextMonthView = _this.getMonthView(index + 1);
                item.nextMonthView = nextMonthView;
                item.prevMonthView = prevMonthView;
            });
        };
        /**
         * Helper method returning previous/next day views
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.getMonthView = function (index) {
            if (index === -1 || index === this.monthViews.length) {
                return null;
            }
            else {
                return this.monthViews.toArray()[index];
            }
        };
        /**
         * Helper method that does deselection for all month views when selection is "multi"
         * If not called, selection in other month views stays
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.deselectDateInMonthViews = function (value) {
            this.monthViews.forEach(function (m) {
                m.deselectMultipleInMonth(value);
            });
        };
        IgxCalendarComponent.prototype.focusMonth = function () {
            var _this = this;
            var month = this.monthsView.monthsRef.find(function (e) { return e.index === _this.monthsView.date.getMonth(); });
            if (month) {
                month.nativeElement.focus();
            }
        };
        return IgxCalendarComponent;
    }(IgxMonthPickerBaseDirective));
    IgxCalendarComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [
                        {
                            multi: true,
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: IgxCalendarComponent
                        }
                    ],
                    animations: [
                        i1.trigger('animateView', [
                            i1.transition('void => 0', i1.useAnimation(fadeIn)),
                            i1.transition('void => *', i1.useAnimation(scaleInCenter, {
                                params: {
                                    duration: '.2s',
                                    fromScale: .9
                                }
                            }))
                        ]),
                        i1.trigger('animateChange', [
                            i1.transition('* => prev', i1.useAnimation(slideInLeft, {
                                params: {
                                    fromPosition: 'translateX(-30%)'
                                }
                            })),
                            i1.transition('* => next', i1.useAnimation(slideInRight, {
                                params: {
                                    fromPosition: 'translateX(30%)'
                                }
                            }))
                        ])
                    ],
                    selector: 'igx-calendar',
                    template: "<ng-template let-result #defaultHeader>\n    <span>{{ getFormattedDate().weekday }},&nbsp;</span>\n    <span>{{ getFormattedDate().monthday }}</span>\n</ng-template>\n\n<ng-template let-result #defaultMonth let-obj>\n        <span *ngIf=\"monthsViewNumber < 2 || obj.index < 1\" class=\"igx-calendar__aria-off-screen\" aria-live=\"polite\">\n            {{ monthsViewNumber > 1 ? (resourceStrings.igx_calendar_first_picker_of.replace('{0}', monthsViewNumber.toString())  + ' ' + (getViewDate(obj.index) | date: 'LLLL yyyy')) : resourceStrings.igx_calendar_selected_month_is + (getViewDate(obj.index) | date: 'LLLL yyyy')}}\n        </span>\n        <span\n            tabindex=\"0\"\n            role=\"button\"\n            [attr.aria-label]=\"(getViewDate(obj.index) | date: 'LLLL') + ' ' + resourceStrings.igx_calendar_select_month\"\n            #monthsBtn\n            (keydown)=\"onActiveViewYearKB(getViewDate(obj.index), $event, obj.index)\"\n            (click)=\"onActiveViewYear(getViewDate(obj.index), obj.index)\"\n            class=\"igx-calendar-picker__date\">\n            {{ formattedMonth(getViewDate(obj.index)) }}\n        </span>\n\n        <span\n            tabindex=\"0\"\n            role=\"button\"\n            [attr.aria-label]=\"(getViewDate(obj.index) | date: 'yyyy') + ' ' + resourceStrings.igx_calendar_select_year\"\n            #yearsBtn\n            (keydown)=\"onActiveViewDecadeKB($event, getViewDate(obj.index), obj.index)\"\n            (click)=\"onActiveViewDecade(getViewDate(obj.index), obj.index)\"\n            class=\"igx-calendar-picker__date\">\n            {{ formattedYear(getViewDate(obj.index)) }}\n        </span>\n</ng-template>\n\n<header\n    aria-labelledby=\"igx-aria-calendar-title-month igx-aria-calendar-title-year\"\n    class=\"igx-calendar__header\"\n    *ngIf=\"selection === 'single' && hasHeader\">\n\n    <h5 id=\"igx-aria-calendar-title-year\" class=\"igx-calendar__header-year\">\n        {{ formattedYear(headerDate) }}\n    </h5>\n\n    <h2 id=\"igx-aria-calendar-title-month\" class=\"igx-calendar__header-date\">\n        <ng-container *ngTemplateOutlet=\"headerTemplate ? headerTemplate : defaultHeader; context: headerContext\">\n        </ng-container>\n    </h2>\n</header>\n\n<div *ngIf=\"isDefaultView\"  class=\"igx-calendar__body\" [@animateView]=\"activeView\" (@animateView.done)=\"viewRendered($event)\" (swiperight)=\"previousMonth()\"\n    (swipeleft)=\"nextMonth()\" (pointerdown)=\"suppressBlur()\">\n    <section class=\"igx-calendar-picker\">\n        <span tabindex=\"0\" class=\"igx-calendar__aria-off-screen\">\n            <ng-container *ngIf=\"selection === 'multi'\">\n                {{ monthsViewNumber && monthsViewNumber > 1 ?  resourceStrings.igx_calendar_multi_selection.replace('{0}', monthsViewNumber.toString()) : resourceStrings.igx_calendar_singular_multi_selection}}\n            </ng-container>\n            <ng-container *ngIf=\"selection === 'range'\">\n                {{ monthsViewNumber && monthsViewNumber > 1 ?  resourceStrings.igx_calendar_range_selection.replace('{0}', monthsViewNumber.toString()) : resourceStrings.igx_calendar_singular_range_selection}}\n            </ng-container>\n            <ng-container *ngIf=\"selection === 'single'\">\n                {{ monthsViewNumber && monthsViewNumber > 1 ?  resourceStrings.igx_calendar_single_selection.replace('{0}', monthsViewNumber.toString()) : resourceStrings.igx_calendar_singular_single_selection}}\n            </ng-container>\n        </span>\n        <div\n            tabindex=\"0\"\n            class=\"igx-calendar-picker__prev\"\n            role=\"button\"\n            [attr.aria-label]=\"resourceStrings.igx_calendar_previous_month + ', ' + (getPrevMonth(viewDate) | date: 'LLLL')\"\n            data-action=\"prev\"\n            #prevMonthBtn\n            igxCalendarScrollMonth\n            [startScroll]=\"startPrevMonthScroll\"\n            [stopScroll]=\"stopMonthScroll\"\n            [ngStyle]=\"{ 'min-width.%': 100/(monthsViewNumber*7)}\">\n            <igx-icon aria-hidden=\"true\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div class=\"igx-calendar-picker__dates\"\n             *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\"\n             [style.width.%]=\"100/monthsViewNumber\"\n             [attr.data-month]=\"i | IgxGetViewDate:viewDate:false\">\n            <ng-container *ngTemplateOutlet=\"subheaderTemplate ? subheaderTemplate : defaultMonth; context: getContext(i)\">\n            </ng-container>\n        </div>\n        <div\n            tabindex=\"0\"\n            class=\"igx-calendar-picker__next\"\n            role=\"button\"\n            [attr.aria-label]=\"resourceStrings.igx_calendar_next_month + ', ' +  (getNextMonth(viewDate, monthsViewNumber) | date: 'LLLL')\"\n            data-action=\"next\"\n            #nextMonthBtn\n            igxCalendarScrollMonth\n            [startScroll]=\"startNextMonthScroll\"\n            [stopScroll]=\"stopMonthScroll\"\n            [ngStyle]=\"{'min-width.%': 100/(monthsViewNumber*7)}\">\n            <igx-icon aria-hidden=\"true\">keyboard_arrow_right</igx-icon>\n        </div>\n    </section>\n\n    <section style=\"display: flex\"\n        [@animateChange]=\"animationAction\"\n        (@animateChange.done)=\"animationDone($event)\">\n        <igx-days-view role=\"grid\" *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [changeDaysView]=\"true\" #days\n                [selection]=\"selection\"\n                [locale]=\"locale\"\n                [value]=\"value\"\n                [(activeDate)]=\"activeDate\"\n                [viewDate]=\"i | IgxGetViewDate:viewDate\"\n                [weekStart]=\"weekStart\"\n                [formatOptions]=\"formatOptions\"\n                [formatViews]=\"formatViews\"\n                [disabledDates]=\"disabledDates\"\n                [specialDates]=\"specialDates\"\n                [hideOutsideDays]=\"hideOutsideDays\"\n                [showWeekNumbers]=\"showWeekNumbers\"\n                (viewChanging)=\"viewChanging($event)\"\n                (dateSelection)=\"childClicked($event)\"\n                (monthsViewBlur)=\"resetActiveDate()\">\n        </igx-days-view>\n    </section>\n</div>\n\n<igx-months-view *ngIf=\"isYearView\"\n                 [@animateView]=\"activeView\"\n                 #months\n                 (@animateView.done)=\"viewRendered($event)\"\n                 [date]=\"viewDate\"\n                 [locale]=\"locale\"\n                 [formatView]=\"formatViews.month\"\n                 [monthFormat]=\"formatOptions.month\"\n                 (selected)=\"changeMonth($event)\">\n</igx-months-view>\n\n<igx-years-view *ngIf=\"isDecadeView\"\n                [@animateView]=\"activeView\"\n                #decade\n                (@animateView.done)=\"viewRendered($event)\"\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (selected)=\"changeYear($event)\">\n</igx-years-view>\n"
                },] }
    ];
    IgxCalendarComponent.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        hasHeader: [{ type: i0.Input }],
        vertical: [{ type: i0.Input }],
        monthsViewNumber: [{ type: i0.Input }],
        showWeekNumbers: [{ type: i0.Input }],
        animationAction: [{ type: i0.Input }],
        styleVerticalClass: [{ type: i0.HostBinding, args: ['class.igx-calendar--vertical',] }],
        styleClass: [{ type: i0.HostBinding, args: ['class.igx-calendar',] }],
        monthsView: [{ type: i0.ViewChild, args: ['months', { read: IgxMonthsViewComponent },] }],
        monthsBtns: [{ type: i0.ViewChildren, args: ['monthsBtn',] }],
        dacadeView: [{ type: i0.ViewChild, args: ['decade', { read: IgxYearsViewComponent },] }],
        daysView: [{ type: i0.ViewChild, args: ['days', { read: IgxDaysViewComponent },] }],
        monthViews: [{ type: i0.ViewChildren, args: ['days', { read: IgxDaysViewComponent },] }],
        prevMonthBtn: [{ type: i0.ViewChild, args: ['prevMonthBtn',] }],
        nextMonthBtn: [{ type: i0.ViewChild, args: ['nextMonthBtn',] }],
        headerTemplateDirective: [{ type: i0.ContentChild, args: [i0.forwardRef(function () { return IgxCalendarHeaderTemplateDirective; }), { read: IgxCalendarHeaderTemplateDirective, static: true },] }],
        subheaderTemplateDirective: [{ type: i0.ContentChild, args: [i0.forwardRef(function () { return IgxCalendarSubheaderTemplateDirective; }), { read: IgxCalendarSubheaderTemplateDirective, static: true },] }],
        onKeydownPageDown: [{ type: i0.HostListener, args: ['keydown.pagedown', ['$event'],] }, { type: i0.HostListener, args: ['keydown.pageup', ['$event'],] }],
        onKeydownShiftPageUp: [{ type: i0.HostListener, args: ['keydown.shift.pageup', ['$event'],] }, { type: i0.HostListener, args: ['keydown.shift.pagedown', ['$event'],] }],
        onKeydownHome: [{ type: i0.HostListener, args: ['keydown.home', ['$event'],] }],
        onKeydownEnd: [{ type: i0.HostListener, args: ['keydown.end', ['$event'],] }],
        onMouseUp: [{ type: i0.HostListener, args: ['document:mouseup', ['$event'],] }]
    };

    var NEXT_ID$d = 0;
    var IgxMonthPickerComponent = /** @class */ (function (_super) {
        __extends(IgxMonthPickerComponent, _super);
        function IgxMonthPickerComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            /**
             * Sets/gets the `id` of the month picker.
             * If not set, the `id` will have value `"igx-month-picker-0"`.
             */
            _this.id = "igx-month-picker-" + NEXT_ID$d++;
            /**
             * The default css class applied to the component.
             *
             * @hidden
             */
            _this.styleClass = true;
            /**
             * @hidden
             */
            _this.yearAction = '';
            return _this;
        }
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.previousYear = function (event) {
            event === null || event === void 0 ? void 0 : event.preventDefault();
            if (event && this.yearAction === 'next') {
                return;
            }
            this.yearAction = 'prev';
            this.previousViewDate = this.viewDate;
            this.viewDate = this.calendarModel.getPrevYear(this.viewDate);
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.nextYear = function (event) {
            event === null || event === void 0 ? void 0 : event.preventDefault();
            if (event && this.yearAction === 'prev') {
                return;
            }
            this.yearAction = 'next';
            this.previousViewDate = this.viewDate;
            this.viewDate = this.calendarModel.getNextYear(this.viewDate);
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.onKeydownHome = function (event) {
            if (this.monthsView) {
                this.monthsView.el.nativeElement.focus();
                this.monthsView.onKeydownHome(event);
            }
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.onKeydownEnd = function (event) {
            if (this.monthsView) {
                this.monthsView.el.nativeElement.focus();
                this.monthsView.onKeydownEnd(event);
            }
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.animationDone = function (event) {
            if ((event.fromState === 'void' && event.toState === '') ||
                (event.fromState === '' && (event.toState === exports.ScrollMonth.PREV || event.toState === exports.ScrollMonth.NEXT))) {
                this.viewDateChanged.emit({ previousValue: this.previousViewDate, currentValue: this.viewDate });
            }
            this.yearAction = '';
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.viewRendered = function (event) {
            if (event.fromState !== 'void') {
                this.activeViewChanged.emit(this.activeView);
            }
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.activeViewDecadeKB = function (event) {
            var _this = this;
            _super.prototype.activeViewDecadeKB.call(this, event);
            if (event.key === "ArrowRight" /* RIGHT_ARROW */ || event.key === "Right" /* RIGHT_ARROW_IE */) {
                this.nextYear(event);
            }
            if (event.key === "ArrowLeft" /* LEFT_ARROW */ || event.key === "Left" /* LEFT_ARROW_IE */) {
                this.previousYear(event);
            }
            requestAnimationFrame(function () {
                if (_this.dacadeView) {
                    _this.dacadeView.el.nativeElement.focus();
                }
            });
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.activeViewDecade = function () {
            var _this = this;
            _super.prototype.activeViewDecade.call(this);
            requestAnimationFrame(function () {
                _this.dacadeView.el.nativeElement.focus();
            });
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.changeYearKB = function (event, next) {
            if (next === void 0) { next = true; }
            if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                event.stopPropagation();
                if (next) {
                    this.nextYear();
                }
                else {
                    this.previousYear();
                }
            }
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.selectYear = function (event) {
            var _this = this;
            this.previousViewDate = this.viewDate;
            this.viewDate = new Date(event.getFullYear(), event.getMonth(), event.getDate());
            this.activeView = IgxCalendarView.Month;
            requestAnimationFrame(function () {
                if (_this.yearsBtn) {
                    _this.yearsBtn.nativeElement.focus();
                }
            });
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.selectMonth = function (event) {
            this.selectDate(event);
            this.selected.emit(this.selectedDates);
        };
        /**
         * Selects a date.
         * ```typescript
         *  this.monthPicker.selectDate(new Date(`2018-06-12`));
         * ```
         */
        IgxMonthPickerComponent.prototype.selectDate = function (value) {
            if (!value) {
                return new Date();
            }
            _super.prototype.selectDate.call(this, value);
            this.viewDate = value;
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.writeValue = function (value) {
            if (value) {
                this.viewDate = this.selectedDates = value;
            }
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.getNextYear = function () {
            return this.calendarModel.getNextYear(this.viewDate).getFullYear();
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.getPreviousYear = function () {
            return this.calendarModel.getPrevYear(this.viewDate).getFullYear();
        };
        return IgxMonthPickerComponent;
    }(IgxMonthPickerBaseDirective));
    IgxMonthPickerComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [
                        {
                            multi: true,
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: IgxMonthPickerComponent
                        }
                    ],
                    animations: [
                        i1.trigger('animateView', [
                            i1.transition('void => 0', i1.useAnimation(fadeIn)),
                            i1.transition('void => *', i1.useAnimation(scaleInCenter, {
                                params: {
                                    duration: '.2s',
                                    fromScale: .9
                                }
                            }))
                        ]),
                        i1.trigger('animateChange', [
                            i1.transition('* => prev', i1.useAnimation(slideInLeft, {
                                params: {
                                    fromPosition: 'translateX(-30%)'
                                }
                            })),
                            i1.transition('* => next', i1.useAnimation(slideInRight, {
                                params: {
                                    fromPosition: 'translateX(30%)'
                                }
                            }))
                        ])
                    ],
                    selector: 'igx-month-picker',
                    template: "<div\n    *ngIf=\"isDefaultView\"\n    [@animateView]=\"activeView\"\n    (@animateView.done)=\"viewRendered($event)\"\n    class=\"igx-calendar__body\"\n    (swiperight)=\"previousYear()\"\n    (swipeleft)=\"nextYear()\">\n\n    <div role=\"rowheader\" class=\"igx-calendar-picker\">\n        <div\n            tabindex=\"0\"\n            class=\"igx-calendar-picker__prev\"\n            (click)=\"previousYear()\"\n            (keydown)=\"changeYearKB($event, false)\"\n            [ngStyle]=\"{'min-width.%': 25, 'left': 0}\"\n            role=\"button\"\n            [attr.aria-label]=\"'Previous Year ' + getPreviousYear()\"\n            data-action=\"prev\">\n            <igx-icon>keyboard_arrow_left</igx-icon>\n        </div>\n        <div [style.width.%]=\"100\">\n            <span\n                tabindex=\"0\"\n                aria-live=\"polite\"\n                #yearsBtn\n                (keydown)=\"activeViewDecadeKB($event)\"\n                (click)=\"activeViewDecade()\"\n                class=\"igx-calendar-picker__date\">\n                {{ formattedYear(viewDate) }}\n            </span>\n        </div>\n        <div\n            tabindex=\"0\"\n            class=\"igx-calendar-picker__next\"\n            (click)=\"nextYear()\"\n            (keydown)=\"changeYearKB($event)\"\n            [ngStyle]=\"{'min-width.%': 25,'right': 0}\"\n            role=\"button\"\n            [attr.aria-label]=\"'Next Year ' + getNextYear()\"\n            data-action=\"next\">\n\n            <igx-icon>keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <igx-months-view [@animateChange]=\"yearAction\" #months\n                     (@animateChange.done)=\"animationDone($event)\"\n                     (@animateView.done)=\"viewRendered($event)\"\n                     [date]=\"viewDate\"\n                     [locale]=\"locale\"\n                     [formatView]=\"formatViews.month\"\n                     [monthFormat]=\"formatOptions.month\"\n                     (selected)=\"selectMonth($event)\">\n    </igx-months-view>\n</div>\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade (@animateView.done)=\"viewRendered($event)\"\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (selected)=\"selectYear($event)\">\n</igx-years-view>\n"
                },] }
    ];
    IgxMonthPickerComponent.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        styleClass: [{ type: i0.HostBinding, args: ['class.igx-calendar',] }],
        monthsView: [{ type: i0.ViewChild, args: ['months', { read: IgxMonthsViewComponent },] }],
        dacadeView: [{ type: i0.ViewChild, args: ['decade', { read: IgxYearsViewComponent },] }],
        daysView: [{ type: i0.ViewChild, args: ['days', { read: IgxDaysViewComponent },] }],
        yearsBtn: [{ type: i0.ViewChild, args: ['yearsBtn',] }],
        previousYear: [{ type: i0.HostListener, args: ['keydown.pageup', ['$event'],] }],
        nextYear: [{ type: i0.HostListener, args: ['keydown.pagedown', ['$event'],] }],
        onKeydownHome: [{ type: i0.HostListener, args: ['keydown.home', ['$event'],] }],
        onKeydownEnd: [{ type: i0.HostListener, args: ['keydown.end', ['$event'],] }]
    };

    var IgxMonthViewSlotsCalendar = /** @class */ (function () {
        function IgxMonthViewSlotsCalendar() {
        }
        IgxMonthViewSlotsCalendar.prototype.transform = function (monthViews) {
            return new Array(monthViews);
        };
        return IgxMonthViewSlotsCalendar;
    }());
    IgxMonthViewSlotsCalendar.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'IgxMonthViewSlots'
                },] }
    ];
    var IgxGetViewDateCalendar = /** @class */ (function () {
        function IgxGetViewDateCalendar() {
            this.calendar = new Calendar();
        }
        IgxGetViewDateCalendar.prototype.transform = function (index, viewDate, wholeDate) {
            if (wholeDate === void 0) { wholeDate = true; }
            var date = this.calendar.timedelta(viewDate, 'month', index);
            return wholeDate ? date : date.getMonth();
        };
        return IgxGetViewDateCalendar;
    }());
    IgxGetViewDateCalendar.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'IgxGetViewDate'
                },] }
    ];
    IgxGetViewDateCalendar.ctorParameters = function () { return []; };

    /**
     * @hidden
     */
    var IgxCalendarModule = /** @class */ (function () {
        function IgxCalendarModule() {
        }
        return IgxCalendarModule;
    }());
    IgxCalendarModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxCalendarBaseDirective,
                        IgxMonthPickerBaseDirective,
                        IgxDayItemComponent,
                        IgxDaysViewComponent,
                        IgxCalendarComponent,
                        IgxCalendarHeaderTemplateDirective,
                        IgxCalendarMonthDirective,
                        IgxCalendarYearDirective,
                        IgxCalendarSubheaderTemplateDirective,
                        IgxCalendarScrollMonthDirective,
                        IgxMonthsViewComponent,
                        IgxYearsViewComponent,
                        IgxMonthPickerComponent,
                        IgxMonthViewSlotsCalendar,
                        IgxGetViewDateCalendar
                    ],
                    exports: [
                        IgxCalendarComponent,
                        IgxDaysViewComponent,
                        IgxMonthsViewComponent,
                        IgxYearsViewComponent,
                        IgxMonthPickerComponent,
                        IgxCalendarHeaderTemplateDirective,
                        IgxCalendarMonthDirective,
                        IgxCalendarYearDirective,
                        IgxCalendarSubheaderTemplateDirective
                    ],
                    imports: [i2.CommonModule, forms.FormsModule, IgxIconModule]
                },] }
    ];

    var NEXT_ID$e = 0;
    /**
     * IgxCardMedia is container for the card media section.
     * Use it to wrap images and videos.
     */
    var IgxCardMediaDirective = /** @class */ (function () {
        function IgxCardMediaDirective() {
            /** @hidden @internal */
            this.cssClass = 'igx-card__media';
            /**
             * An @Input property that sets the `width` and `min-width` style property
             * of the media container. If not provided it will be set to `auto`.
             *
             * @example
             * ```html
             * <igx-card-media width="300px"></igx-card-media>
             * ```
             */
            this.width = 'auto';
            /**
             * An @Input property that sets the `height` style property of the media container.
             * If not provided it will be set to `auto`.
             *
             * @example
             * ```html
             * <igx-card-media height="50%"></igx-card-media>
             * ```
             */
            this.height = 'auto';
            /**
             * An @Input property that sets the `role` attribute of the media container.
             */
            this.role = 'img';
        }
        return IgxCardMediaDirective;
    }());
    IgxCardMediaDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'igx-card-media'
                },] }
    ];
    IgxCardMediaDirective.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-card__media',] }],
        width: [{ type: i0.HostBinding, args: ['style.width',] }, { type: i0.HostBinding, args: ['style.min-width',] }, { type: i0.Input }],
        height: [{ type: i0.HostBinding, args: ['style.height',] }, { type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }, { type: i0.Input }]
    };
    /**
     * IgxCardHeader is container for the card header
     */
    var IgxCardHeaderComponent = /** @class */ (function () {
        function IgxCardHeaderComponent() {
            /** @hidden @internal */
            this.cssClass = 'igx-card-header';
            /**
             * An @Input property that sets the layout style of the header.
             * By default the header elements(thumbnail and title/subtitle) are aligned horizontally.
             *
             * @example
             * ```html
             * <igx-card-header [vertical]="true"></igx-card-header>
             * ```
             */
            this.vertical = false;
            /**
             * An @Input property that sets the value of the `role` attribute of the card header.
             * By default the value is set to `header`.
             *
             * @example
             * ```html
             * <igx-card-header role="header"></igx-card-header>
             * ```
             */
            this.role = 'header';
        }
        return IgxCardHeaderComponent;
    }());
    IgxCardHeaderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-card-header',
                    template: "<div class=\"igx-card-header__thumbnail\">\n    <ng-content select=\"igx-avatar, igx-card-media, [igxCardThumbnail]\"></ng-content>\n</div>\n\n<div class=\"igx-card-header__titles\">\n    <ng-content select=\"\n        [igxCardHeaderTitle],\n        [igxCardHeaderSubtitle],\n        .igx-card-header__title,\n        .igx-card-header__subtitle\">\n    </ng-content>\n</div>\n\n<ng-content></ng-content>\n"
                },] }
    ];
    IgxCardHeaderComponent.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-card-header',] }],
        vertical: [{ type: i0.HostBinding, args: ['class.igx-card-header--vertical',] }, { type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }]
    };
    /**
     * IgxCardThumbnail is container for the card thumbnail section.
     * Use it to wrap anything you want to be used as a thumbnail.
     */
    var IgxCardThumbnailDirective = /** @class */ (function () {
        function IgxCardThumbnailDirective() {
        }
        return IgxCardThumbnailDirective;
    }());
    IgxCardThumbnailDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCardThumbnail]'
                },] }
    ];
    /**
     * igxCardHeaderTitle is used to denote the header title in a card.
     * Use it to tag text nodes.
     */
    var IgxCardHeaderTitleDirective = /** @class */ (function () {
        function IgxCardHeaderTitleDirective() {
            /** @hidden @internal */
            this.cssClass = 'igx-card__header__title';
        }
        return IgxCardHeaderTitleDirective;
    }());
    IgxCardHeaderTitleDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCardHeaderTitle]'
                },] }
    ];
    IgxCardHeaderTitleDirective.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-card-header__title',] }]
    };
    /**
     * igxCardHeaderSubtitle is used to denote the header subtitle in a card.
     * Use it to tag text nodes.
     */
    var IgxCardHeaderSubtitleDirective = /** @class */ (function () {
        function IgxCardHeaderSubtitleDirective() {
            /** @hidden @internal */
            this.cssClass = 'igx-card-header__subtitle';
        }
        return IgxCardHeaderSubtitleDirective;
    }());
    IgxCardHeaderSubtitleDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCardHeaderSubtitle]'
                },] }
    ];
    IgxCardHeaderSubtitleDirective.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-card-header__subtitle',] }]
    };
    /**
     * IgxCardContent is container for the card content.
     */
    var IgxCardContentDirective = /** @class */ (function () {
        function IgxCardContentDirective() {
            /** @hidden @internal */
            this.cssClass = 'igx-card-content';
        }
        return IgxCardContentDirective;
    }());
    IgxCardContentDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'igx-card-content'
                },] }
    ];
    IgxCardContentDirective.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-card-content',] }]
    };
    /**
     * IgxCardFooter is container for the card footer
     */
    var IgxCardFooterDirective = /** @class */ (function () {
        function IgxCardFooterDirective() {
            /**
             * An @Input property that sets the value of the `role` attribute of the card footer.
             * By default the value is set to `footer`.
             *
             * @example
             * ```html
             * <igx-card-footer role="footer"></igx-card-footer>
             * ```
             */
            this.role = 'footer';
        }
        return IgxCardFooterDirective;
    }());
    IgxCardFooterDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'igx-card-footer'
                },] }
    ];
    IgxCardFooterDirective.propDecorators = {
        role: [{ type: i0.HostBinding, args: ['attr.role',] }, { type: i0.Input }]
    };
    /**
     * Card provides a way to display organized content in appealing way.
     *
     * @igxModule IgxCardModule
     *
     * @igxTheme igx-card-theme, igx-icon-theme, igx-button-theme
     *
     * @igxKeywords card, button, avatar, icon
     *
     * @igxGroup Layouts
     *
     * @remarks
     * The Ignite UI Card serves as a container that allows custom content to be organized in an appealing way. There are
     * five sections in a card that you can use to organize your content. These are header, media, content, actions, and footer.
     *
     * @example
     * ```html
     * <igx-card>
     *   <igx-card-header>
     *     <h3 igxCardHeaderTitle>{{title}}</h3>
     *     <h5 igxCardHeaderSubtitle>{{subtitle}}</h5>
     *   </igx-card-header>
     *   <igx-card-actions>
     *       <button igxButton igxRipple>Share</button>
     *       <button igxButton igxRipple>Play Album</button>
     *   </igx-card-actions>
     * </igx-card>
     * ```
     */
    var IgxCardType = mkenum({
        ELEVATED: 'elevated',
        OUTLINED: 'outlined'
    });
    var IgxCardComponent = /** @class */ (function () {
        function IgxCardComponent() {
            /**
             * Sets/gets the `id` of the card.
             * If not set, `id` will have value `"igx-card-0"`;
             *
             * @example
             * ```html
             * <igx-card id = "my-first-card"></igx-card>
             * ```
             * ```typescript
             * let cardId =  this.card.id;
             * ```
             */
            this.id = "igx-card-" + NEXT_ID$e++;
            /**
             * An @Input property that sets the value of the `role` attribute of the card.
             * By default the value is set to `group`.
             *
             * @example
             * ```html
             * <igx-card role="group"></igx-card>
             * ```
             */
            this.role = 'group';
            /**
             * An @Input property that sets the value of the `type` attribute of the card.
             * By default the value is set to `elevated`. You can make the card use the
             * outlined style by setting the value to `outlined`.
             *
             * @example
             * ```html
             * <igx-card type="outlined"></igx-card>
             * ```
             */
            this.type = IgxCardType.ELEVATED;
            /**
             * An @Input property that sets the value of the `horizontal` attribute of the card.
             * Setting this to `true` will make the different card sections align horizontally,
             * essentially flipping the card to the side.
             *
             * @example
             * ```html
             * <igx-card [horizontal]="true"></igx-card>
             * ```
             */
            this.horizontal = false;
        }
        Object.defineProperty(IgxCardComponent.prototype, "isOutlinedCard", {
            /**
             * A getter which will return true if the card type is `outlined`.
             */
            get: function () {
                return this.type === IgxCardType.OUTLINED;
            },
            enumerable: false,
            configurable: true
        });
        return IgxCardComponent;
    }());
    IgxCardComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-card',
                    template: "<ng-content></ng-content>\n"
                },] }
    ];
    IgxCardComponent.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }, { type: i0.Input }],
        type: [{ type: i0.HostBinding, args: ['class.igx-card',] }, { type: i0.Input }],
        isOutlinedCard: [{ type: i0.HostBinding, args: ['class.igx-card--outlined',] }],
        horizontal: [{ type: i0.HostBinding, args: ['class.igx-card--horizontal',] }, { type: i0.Input }]
    };
    var IgxCardActionsLayout = mkenum({
        START: 'start',
        JUSTIFY: 'justify'
    });
    /**
     * IgxCardActions is container for the card actions.
     */
    var IgxCardActionsComponent = /** @class */ (function () {
        function IgxCardActionsComponent(card) {
            this.card = card;
            /**
             * An @Input property that sets the layout style of the actions.
             * By default icons and icon buttons, as well as regular buttons
             * are split into two containers, which are then positioned on both ends
             * of the card-actions area.
             * You can justify the elements in those groups so they are positioned equally
             * from one another taking up all the space available along the card actions axis.
             *
             * @example
             * ```html
             * <igx-card-actions layout="justify"></igx-card-actions>
             * ```
             */
            this.layout = IgxCardActionsLayout.START;
            /**
             * An @Input property that sets order of the buttons the actions area.
             * By default all icons/icon buttons are placed at the end of the action
             * area. Any regular buttons(flat, raised) will appear before the icons/icon buttons
             * placed in the actions area.
             * If you want to reverse their positions so that icons appear first, use the `reverse`
             * attribute.
             *
             * @example
             * ```html
             * <igx-card-actions [reverse]="true"></igx-card-actions>
             * ```
             */
            this.reverse = false;
            this.isVerticalSet = false;
        }
        Object.defineProperty(IgxCardActionsComponent.prototype, "isJustifyLayout", {
            /**
             * A getter that returns `true` when the layout has been
             * set to `justify`.
             */
            get: function () {
                return this.layout === IgxCardActionsLayout.JUSTIFY;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxCardActionsComponent.prototype.ngOnChanges = function (changes) {
            for (var prop in changes) {
                if (prop === 'vertical') {
                    this.isVerticalSet = true;
                }
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxCardActionsComponent.prototype.ngOnInit = function () {
            this.vertical = !this.isVerticalSet && this.card.horizontal;
        };
        return IgxCardActionsComponent;
    }());
    IgxCardActionsComponent.decorators = [
        { type: i0.Component, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'igx-card-actions',
                    template: "<div class=\"igx-card-actions__icons\">\n    <ng-content select=\"igx-icon, [igxButton='icon']\"></ng-content>\n</div>\n\n<div #buttons class=\"igx-card-actions__buttons\">\n    <ng-content select=\"[igxButton]\"></ng-content>\n</div>\n\n\n<ng-content></ng-content>\n"
                },] }
    ];
    IgxCardActionsComponent.ctorParameters = function () { return [
        { type: IgxCardComponent, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [IgxCardComponent,] }] }
    ]; };
    IgxCardActionsComponent.propDecorators = {
        layout: [{ type: i0.HostBinding, args: ['class.igx-card-actions',] }, { type: i0.Input }],
        vertical: [{ type: i0.HostBinding, args: ['class.igx-card-actions--vertical',] }, { type: i0.Input }],
        isJustifyLayout: [{ type: i0.HostBinding, args: ['class.igx-card-actions--justify',] }],
        reverse: [{ type: i0.HostBinding, args: ['class.igx-card-actions--reverse',] }, { type: i0.Input }]
    };
    /**
     * @hidden
     */
    var IgxCardModule = /** @class */ (function () {
        function IgxCardModule() {
        }
        return IgxCardModule;
    }());
    IgxCardModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxCardComponent,
                        IgxCardHeaderComponent,
                        IgxCardMediaDirective,
                        IgxCardContentDirective,
                        IgxCardActionsComponent,
                        IgxCardFooterDirective,
                        IgxCardHeaderTitleDirective,
                        IgxCardHeaderSubtitleDirective,
                        IgxCardThumbnailDirective,
                    ],
                    exports: [
                        IgxCardComponent,
                        IgxCardHeaderComponent,
                        IgxCardMediaDirective,
                        IgxCardContentDirective,
                        IgxCardActionsComponent,
                        IgxCardFooterDirective,
                        IgxCardHeaderTitleDirective,
                        IgxCardHeaderSubtitleDirective,
                        IgxCardThumbnailDirective,
                    ],
                    imports: [i2.CommonModule, IgxButtonModule]
                },] }
    ];

    var IgxCarouselIndicatorDirective = /** @class */ (function () {
        function IgxCarouselIndicatorDirective() {
        }
        return IgxCarouselIndicatorDirective;
    }());
    IgxCarouselIndicatorDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCarouselIndicator]'
                },] }
    ];
    var IgxCarouselNextButtonDirective = /** @class */ (function () {
        function IgxCarouselNextButtonDirective() {
        }
        return IgxCarouselNextButtonDirective;
    }());
    IgxCarouselNextButtonDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCarouselNextButton]'
                },] }
    ];
    var IgxCarouselPrevButtonDirective = /** @class */ (function () {
        function IgxCarouselPrevButtonDirective() {
        }
        return IgxCarouselPrevButtonDirective;
    }());
    IgxCarouselPrevButtonDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCarouselPrevButton]'
                },] }
    ];

    var Direction$1;
    (function (Direction) {
        Direction[Direction["NONE"] = 0] = "NONE";
        Direction[Direction["NEXT"] = 1] = "NEXT";
        Direction[Direction["PREV"] = 2] = "PREV";
    })(Direction$1 || (Direction$1 = {}));
    /**
     * A slide component that usually holds an image and/or a caption text.
     * IgxSlideComponent is usually a child component of an IgxCarouselComponent.
     *
     * ```
     * <igx-slide [input bindings] >
     *    <ng-content></ng-content>
     * </igx-slide>
     * ```
     *
     * @export
     */
    var IgxSlideComponent = /** @class */ (function () {
        function IgxSlideComponent(elementRef) {
            this.elementRef = elementRef;
            /**
             * Returns the `role` of the slide component.
             * By default is set to `tabpanel`
             *
             * @memberof IgxSlideComponent
             */
            this.tab = 'tabpanel';
            /**
             * Returns the class of the slide component.
             * ```typescript
             * let class =  this.slide.cssClass;
             * ```
             *
             * @memberof IgxSlideComponent
             */
            this.cssClass = 'igx-slide';
            this.previous = false;
            /**
             * @hidden
             */
            this.activeChange = new i0.EventEmitter();
            this._active = false;
            this._destroy$ = new rxjs.Subject();
        }
        Object.defineProperty(IgxSlideComponent.prototype, "tabIndex", {
            /**
             * Returns the `tabIndex` of the slide component.
             * ```typescript
             * let tabIndex =  this.carousel.tabIndex;
             * ```
             *
             * @memberof IgxSlideComponent
             */
            get: function () {
                return this.active ? 0 : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSlideComponent.prototype, "active", {
            /**
             * Gets/sets the `active` state of the slide.
             * ```html
             * <igx-carousel>
             *  <igx-slide [active] ="false"></igx-slide>
             * <igx-carousel>
             * ```
             *
             * Two-way data binding.
             * ```html
             * <igx-carousel>
             *  <igx-slide [(active)] ="model.isActive"></igx-slide>
             * <igx-carousel>
             * ```
             *
             * @memberof IgxSlideComponent
             */
            get: function () {
                return this._active;
            },
            set: function (value) {
                this._active = !!value;
                this.activeChange.emit(this._active);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSlideComponent.prototype, "nativeElement", {
            /**
             * Returns a reference to the carousel element in the DOM.
             * ```typescript
             * let nativeElement =  this.slide.nativeElement;
             * ```
             *
             * @memberof IgxSlideComponent
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSlideComponent.prototype, "isDestroyed", {
            /**
             * @hidden
             */
            get: function () {
                return this._destroy$;
            },
            enumerable: false,
            configurable: true
        });
        IgxSlideComponent.prototype.ngAfterContentChecked = function () {
            this.id = "panel-" + this.index;
            this.ariaLabelledBy = "tab-" + this.index + "-" + this.total;
        };
        /**
         * @hidden
         */
        IgxSlideComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next(true);
            this._destroy$.complete();
        };
        return IgxSlideComponent;
    }());
    IgxSlideComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-slide',
                    template: "<ng-content></ng-content>\n"
                },] }
    ];
    IgxSlideComponent.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxSlideComponent.propDecorators = {
        index: [{ type: i0.Input }],
        direction: [{ type: i0.Input }],
        total: [{ type: i0.Input }],
        tabIndex: [{ type: i0.HostBinding, args: ['attr.tabindex',] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }],
        tab: [{ type: i0.HostBinding, args: ['attr.role',] }],
        ariaLabelledBy: [{ type: i0.HostBinding, args: ['attr.aria-labelledby',] }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-slide',] }],
        active: [{ type: i0.HostBinding, args: ['class.igx-slide--current',] }, { type: i0.Input }],
        previous: [{ type: i0.HostBinding, args: ['class.igx-slide--previous',] }, { type: i0.Input }],
        activeChange: [{ type: i0.Output }]
    };

    var NEXT_ID$f = 0;
    var CarouselIndicatorsOrientation = mkenum({
        bottom: 'bottom',
        top: 'top'
    });
    var CarouselAnimationType = mkenum({
        none: 'none',
        slide: 'slide',
        fade: 'fade'
    });
    var CarouselHammerConfig = /** @class */ (function (_super) {
        __extends(CarouselHammerConfig, _super);
        function CarouselHammerConfig() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.overrides = {
                pan: { direction: Hammer.DIRECTION_HORIZONTAL }
            };
            return _this;
        }
        return CarouselHammerConfig;
    }(i1$1.HammerGestureConfig));
    CarouselHammerConfig.decorators = [
        { type: i0.Injectable }
    ];
    /**
     * **Ignite UI for Angular Carousel** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/carousel.html)
     *
     * The Ignite UI Carousel is used to browse or navigate through a collection of slides. Slides can contain custom
     * content such as images or cards and be used for things such as on-boarding tutorials or page-based interfaces.
     * It can be used as a separate fullscreen element or inside another component.
     *
     * Example:
     * ```html
     * <igx-carousel>
     *   <igx-slide>
     *     <h3>First Slide Header</h3>
     *     <p>First slide Content</p>
     *   <igx-slide>
     *   <igx-slide>
     *     <h3>Second Slide Header</h3>
     *     <p>Second Slide Content</p>
     * </igx-carousel>
     * ```
     */
    var IgxCarouselComponent = /** @class */ (function () {
        function IgxCarouselComponent(element, iterableDiffers, builder, platformUtil) {
            this.element = element;
            this.iterableDiffers = iterableDiffers;
            this.builder = builder;
            this.platformUtil = platformUtil;
            /**
             * Sets the `id` of the carousel.
             * If not set, the `id` of the first carousel component will be `"igx-carousel-0"`.
             * ```html
             * <igx-carousel id="my-first-carousel"></igx-carousel>
             * ```
             *
             * @memberof IgxCarouselComponent
             */
            this.id = "igx-carousel-" + NEXT_ID$f++;
            /**
             * Returns the `role` attribute of the carousel.
             * ```typescript
             * let carouselRole =  this.carousel.role;
             * ```
             *
             * @memberof IgxCarouselComponent
             */
            this.role = 'region';
            /** @hidden */
            this.roleDescription = 'carousel';
            /**
             * Returns the class of the carousel component.
             * ```typescript
             * let class =  this.carousel.cssClass;
             * ```
             *
             * @memberof IgxCarouselComponent
             */
            this.cssClass = 'igx-carousel';
            /**
             * Sets whether the carousel should `loop` back to the first slide after reaching the last slide.
             * Default value is `true`.
             * ```html
             * <igx-carousel [loop]="false"></igx-carousel>
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            this.loop = true;
            /**
             * Sets whether the carousel will `pause` the slide transitions on user interactions.
             * Default value is `true`.
             * ```html
             *  <igx-carousel [pause]="false"></igx-carousel>
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            this.pause = true;
            /**
             * Controls whether the carousel should render the left/right `navigation` buttons.
             * Default value is `true`.
             * ```html
             * <igx-carousel [navigation] = "false"></igx-carousel>
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            this.navigation = true;
            /**
             * Controls whether the carousel should support keyboard navigation.
             * Default value is `true`.
             * ```html
             * <igx-carousel [keyboardSupport] = "false"></igx-carousel>
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            this.keyboardSupport = true;
            /**
             * Controls whether the carousel should support gestures.
             * Default value is `true`.
             * ```html
             * <igx-carousel [gesturesSupport] = "false"></igx-carousel>
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            this.gesturesSupport = true;
            /**
             * Controls the maximum indexes that can be shown.
             * Default value is `5`.
             * ```html
             * <igx-carousel [maximumIndicatorsCount] = "10"></igx-carousel>
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            this.maximumIndicatorsCount = 5;
            /**
             * Gets/sets the display mode of carousel indicators. It can be top or bottom.
             * Default value is `bottom`.
             * ```html
             * <igx-carousel indicatorsOrientation='top'>
             * <igx-carousel>
             * ```
             *
             * @memberOf IgxSlideComponent
             */
            this.indicatorsOrientation = CarouselIndicatorsOrientation.bottom;
            /**
             * Gets/sets the animation type of carousel.
             * Default value is `slide`.
             * ```html
             * <igx-carousel animationType='none'>
             * <igx-carousel>
             * ```
             *
             * @memberOf IgxSlideComponent
             */
            this.animationType = CarouselAnimationType.slide;
            /**
             * The custom template, if any, that should be used when rendering carousel indicators
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.carousel.indicatorTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-carousel #carousel>
             *      ...
             *      <ng-template igxCarouselIndicator let-slide>
             *         <igx-icon *ngIf="slide.active">brightness_7</igx-icon>
             *         <igx-icon *ngIf="!slide.active">brightness_5</igx-icon>
             *      </ng-template>
             *  </igx-carousel>
             * ```
             */
            this.indicatorTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering carousel next button
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.carousel.nextButtonTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-carousel #carousel>
             *      ...
             *      <ng-template igxCarouselNextButton let-disabled>
             *            <button igxButton="fab" igxRipple="white" [disabled]="disabled">
             *                <igx-icon>add</igx-icon>
             *           </button>
             *      </ng-template>
             *  </igx-carousel>
             * ```
             */
            this.nextButtonTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering carousel previous button
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.carousel.nextButtonTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-carousel #carousel>
             *      ...
             *      <ng-template igxCarouselPrevButton let-disabled>
             *            <button igxButton="fab" igxRipple="white" [disabled]="disabled">
             *                <igx-icon>remove</igx-icon>
             *           </button>
             *      </ng-template>
             *  </igx-carousel>
             * ```
             */
            this.prevButtonTemplate = null;
            /**
             * An event that is emitted after a slide transition has happened.
             * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
             * ```html
             * <igx-carousel (onSlideChanged)="onSlideChanged($event)"></igx-carousel>
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            this.onSlideChanged = new i0.EventEmitter();
            /**
             * An event that is emitted after a slide has been added to the carousel.
             * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
             * ```html
             * <igx-carousel (onSlideAdded)="onSlideAdded($event)"></igx-carousel>
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            this.onSlideAdded = new i0.EventEmitter();
            /**
             * An event that is emitted after a slide has been removed from the carousel.
             * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
             * ```html
             * <igx-carousel (onSlideRemoved)="onSlideRemoved($event)"></igx-carousel>
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            this.onSlideRemoved = new i0.EventEmitter();
            /**
             * An event that is emitted after the carousel has been paused.
             * Provides a reference to the `IgxCarouselComponent` as an event argument.
             * ```html
             * <igx-carousel (onCarouselPaused)="onCarouselPaused($event)"></igx-carousel>
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            this.onCarouselPaused = new i0.EventEmitter();
            /**
             * An event that is emitted after the carousel has resumed transitioning between `slides`.
             * Provides a reference to the `IgxCarouselComponent` as an event argument.
             * ```html
             * <igx-carousel (onCarouselPlaying)="onCarouselPlaying($event)"></igx-carousel>
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            this.onCarouselPlaying = new i0.EventEmitter();
            this._resourceStrings = CurrentResourceStrings.CarouselResStrings;
            this.destroy$ = new rxjs.Subject();
            this.differ = null;
            this.animationDuration = 320;
            this.animationPosition = 0;
            this.newDuration = 0;
            this.differ = this.iterableDiffers.find([]).create(null);
        }
        Object.defineProperty(IgxCarouselComponent.prototype, "labelId", {
            /** @hidden */
            get: function () {
                return this.showIndicatorsLabel ? this.id + "-label" : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "touchAction", {
            /**
             * Gets the `touch-action` style of the `list item`.
             * ```typescript
             * let touchAction = this.listItem.touchAction;
             * ```
             */
            get: function () {
                return this.gesturesSupport ? 'pan-y' : 'auto';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "resourceStrings", {
            /**
             * An accessor that returns the resource strings.
             */
            get: function () {
                return this._resourceStrings;
            },
            /**
             * An accessor that sets the resource strings.
             * By default it uses EN resources.
             */
            set: function (value) {
                this._resourceStrings = Object.assign({}, this._resourceStrings, value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "getIndicatorTemplate", {
            /** @hidden */
            get: function () {
                if (this.indicatorTemplate) {
                    return this.indicatorTemplate;
                }
                return this.defaultIndicator;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "getNextButtonTemplate", {
            /** @hidden */
            get: function () {
                if (this.nextButtonTemplate) {
                    return this.nextButtonTemplate;
                }
                return this.defaultNextButton;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "getPrevButtonTemplate", {
            /** @hidden */
            get: function () {
                if (this.prevButtonTemplate) {
                    return this.prevButtonTemplate;
                }
                return this.defaultPrevButton;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "indicatorsOrientationClass", {
            /** @hidden */
            get: function () {
                return "igx-carousel-indicators--" + this.indicatorsOrientation;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "showIndicators", {
            /** @hidden */
            get: function () {
                return this.total <= this.maximumIndicatorsCount && this.total > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "showIndicatorsLabel", {
            /** @hidden */
            get: function () {
                return this.total > this.maximumIndicatorsCount;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "getCarouselLabel", {
            /** @hidden */
            get: function () {
                return this.current + 1 + " " + this.resourceStrings.igx_carousel_of + " " + this.total;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "total", {
            /**
             * Returns the total number of `slides` in the carousel.
             * ```typescript
             * let slideCount =  this.carousel.total;
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            get: function () {
                var _a;
                return (_a = this.slides) === null || _a === void 0 ? void 0 : _a.length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "current", {
            /**
             * The index of the slide being currently shown.
             * ```typescript
             * let currentSlideNumber =  this.carousel.current;
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            get: function () {
                return !this.currentSlide ? 0 : this.currentSlide.index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "isPlaying", {
            /**
             * Returns a boolean indicating if the carousel is playing.
             * ```typescript
             * let isPlaying =  this.carousel.isPlaying;
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            get: function () {
                return this.playing;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "isDestroyed", {
            /**
             * Returns а boolean indicating if the carousel is destroyed.
             * ```typescript
             * let isDestroyed =  this.carousel.isDestroyed;
             * ```
             *
             * @memberOf IgxCarouselComponent
             */
            get: function () {
                return this.destroyed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "nativeElement", {
            /**
             * Returns a reference to the carousel element in the DOM.
             * ```typescript
             * let nativeElement =  this.carousel.nativeElement;
             * ```
             *
             * @memberof IgxCarouselComponent
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "interval", {
            /**
             * Returns the time `interval` in milliseconds before the slide changes.
             * ```typescript
             * let timeInterval = this.carousel.interval;
             * ```
             *
             * @memberof IgxCarouselComponent
             */
            get: function () {
                return this._interval;
            },
            /**
             * Sets the time `interval` in milliseconds before the slide changes.
             * If not set, the carousel will not change `slides` automatically.
             * ```html
             * <igx-carousel [interval] = "1000"></igx-carousel>
             * ```
             *
             * @memberof IgxCarouselComponent
             */
            set: function (value) {
                this._interval = +value;
                this.restartInterval();
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden */
        IgxCarouselComponent.prototype.onKeydownArrowRight = function (event) {
            var _this = this;
            if (this.keyboardSupport) {
                event.preventDefault();
                this.next();
                requestAnimationFrame(function () { return _this.slides.find(function (s) { return s.active; }).nativeElement.focus(); });
            }
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onKeydownArrowLeft = function (event) {
            var _this = this;
            if (this.keyboardSupport) {
                event.preventDefault();
                this.prev();
                requestAnimationFrame(function () { return _this.slides.find(function (s) { return s.active; }).nativeElement.focus(); });
            }
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onTap = function (event) {
            // play pause only when tap on slide
            if (event.target && event.target.classList.contains('igx-slide')) {
                if (this.isPlaying) {
                    if (this.pause) {
                        this.stoppedByInteraction = true;
                    }
                    this.stop();
                }
                else if (this.stoppedByInteraction) {
                    this.play();
                }
            }
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onKeydownHome = function (event) {
            var _this = this;
            if (this.keyboardSupport && this.slides.length > 0) {
                event.preventDefault();
                this.slides.first.active = true;
                requestAnimationFrame(function () { return _this.slides.find(function (s) { return s.active; }).nativeElement.focus(); });
            }
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onKeydownEnd = function (event) {
            var _this = this;
            if (this.keyboardSupport && this.slides.length > 0) {
                event.preventDefault();
                this.slides.last.active = true;
                requestAnimationFrame(function () { return _this.slides.find(function (s) { return s.active; }).nativeElement.focus(); });
            }
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onMouseEnter = function () {
            if (this.pause && this.isPlaying) {
                this.stoppedByInteraction = true;
            }
            this.stop();
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onMouseLeave = function () {
            if (this.stoppedByInteraction) {
                this.play();
            }
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onPanLeft = function (event) {
            this.pan(event);
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onPanRight = function (event) {
            this.pan(event);
        };
        /**
         * @hidden
         */
        IgxCarouselComponent.prototype.onPanEnd = function (event) {
            if (!this.gesturesSupport) {
                return;
            }
            event.preventDefault();
            var slideWidth = this.currentSlide.nativeElement.offsetWidth;
            var panOffset = (slideWidth / 1000);
            var deltaX = Math.abs(event.deltaX) + panOffset < slideWidth ? Math.abs(event.deltaX) : slideWidth - panOffset;
            var velocity = Math.abs(event.velocity);
            this.resetSlideStyles(this.currentSlide);
            if (this.incomingSlide) {
                this.resetSlideStyles(this.incomingSlide);
                if (slideWidth / 2 < deltaX || velocity > 1) {
                    this.incomingSlide.direction = event.deltaX < 0 ? Direction$1.NEXT : Direction$1.PREV;
                    this.incomingSlide.previous = false;
                    this.animationPosition = this.animationType === CarouselAnimationType.fade ?
                        deltaX / slideWidth : (slideWidth - deltaX) / slideWidth;
                    if (velocity > 1) {
                        this.newDuration = this.animationDuration / velocity;
                    }
                    this.incomingSlide.active = true;
                }
                else {
                    this.currentSlide.direction = event.deltaX > 0 ? Direction$1.NEXT : Direction$1.PREV;
                    this.previousSlide = this.incomingSlide;
                    this.previousSlide.previous = true;
                    this.animationPosition = this.animationType === CarouselAnimationType.fade ?
                        Math.abs((slideWidth - deltaX) / slideWidth) : deltaX / slideWidth;
                    this.playAnimations();
                }
            }
            if (this.stoppedByInteraction) {
                this.play();
            }
        };
        /** @hidden */
        IgxCarouselComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.slides.changes
                .pipe(operators.takeUntil(this.destroy$))
                .subscribe(function (change) { return _this.initSlides(change); });
            this.initSlides(this.slides);
        };
        /** @hidden */
        IgxCarouselComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
            this.destroyed = true;
            if (this.lastInterval) {
                clearInterval(this.lastInterval);
            }
        };
        /**
         * Returns the slide corresponding to the provided `index` or null.
         * ```typescript
         * let slide1 =  this.carousel.get(1);
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.get = function (index) {
            return this.slides.find(function (slide) { return slide.index === index; });
        };
        /**
         * Adds a new slide to the carousel.
         * ```typescript
         * this.carousel.add(newSlide);
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.add = function (slide) {
            var newSlides = this.slides.toArray();
            newSlides.push(slide);
            this.slides.reset(newSlides);
            this.slides.notifyOnChanges();
        };
        /**
         * Removes a slide from the carousel.
         * ```typescript
         * this.carousel.remove(slide);
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.remove = function (slide) {
            if (slide && slide === this.get(slide.index)) { // check if the requested slide for delete is present in the carousel
                var newSlides = this.slides.toArray();
                newSlides.splice(slide.index, 1);
                this.slides.reset(newSlides);
                this.slides.notifyOnChanges();
            }
        };
        /**
         * Kicks in a transition for a given slide with a given `direction`.
         * ```typescript
         * this.carousel.select(this.carousel.get(2), Direction.NEXT);
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.select = function (slide, direction) {
            if (direction === void 0) { direction = Direction$1.NONE; }
            if (slide && slide !== this.currentSlide) {
                slide.direction = direction;
                slide.active = true;
            }
        };
        /**
         * Transitions to the next slide in the carousel.
         * ```typescript
         * this.carousel.next();
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.next = function () {
            var index = this.getNextIndex();
            if (index === 0 && !this.loop) {
                this.stop();
                return;
            }
            return this.select(this.get(index), Direction$1.NEXT);
        };
        /**
         * Transitions to the previous slide in the carousel.
         * ```typescript
         * this.carousel.prev();
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.prev = function () {
            var index = this.getPrevIndex();
            if (!this.loop && index === this.total - 1) {
                this.stop();
                return;
            }
            return this.select(this.get(index), Direction$1.PREV);
        };
        /**
         * Resumes playing of the carousel if in paused state.
         * No operation otherwise.
         * ```typescript
         * this.carousel.play();
         * }
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.play = function () {
            if (!this.playing) {
                this.playing = true;
                this.onCarouselPlaying.emit(this);
                this.restartInterval();
                this.stoppedByInteraction = false;
            }
        };
        /**
         * Stops slide transitions if the `pause` option is set to `true`.
         * No operation otherwise.
         * ```typescript
         *  this.carousel.stop();
         * }
         * ```
         *
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.stop = function () {
            if (this.pause) {
                this.playing = false;
                this.onCarouselPaused.emit(this);
                this.resetInterval();
            }
        };
        IgxCarouselComponent.prototype.resetInterval = function () {
            if (this.lastInterval) {
                clearInterval(this.lastInterval);
                this.lastInterval = null;
            }
        };
        IgxCarouselComponent.prototype.restartInterval = function () {
            var _this = this;
            this.resetInterval();
            if (!isNaN(this.interval) && this.interval > 0 && this.platformUtil.isBrowser) {
                this.lastInterval = setInterval(function () {
                    var tick = +_this.interval;
                    if (_this.playing && _this.total && !isNaN(tick) && tick > 0) {
                        _this.next();
                    }
                    else {
                        _this.stop();
                    }
                }, this.interval);
            }
        };
        Object.defineProperty(IgxCarouselComponent.prototype, "nextButtonDisabled", {
            /** @hidden */
            get: function () {
                return !this.loop && this.current === (this.total - 1);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "prevButtonDisabled", {
            /** @hidden */
            get: function () {
                return !this.loop && this.current === 0;
            },
            enumerable: false,
            configurable: true
        });
        IgxCarouselComponent.prototype.getNextIndex = function () {
            return (this.current + 1) % this.total;
        };
        IgxCarouselComponent.prototype.getPrevIndex = function () {
            return this.current - 1 < 0 ? this.total - 1 : this.current - 1;
        };
        IgxCarouselComponent.prototype.resetSlideStyles = function (slide) {
            slide.nativeElement.style.transform = '';
            slide.nativeElement.style.opacity = '';
        };
        IgxCarouselComponent.prototype.pan = function (event) {
            var slideWidth = this.currentSlide.nativeElement.offsetWidth;
            var panOffset = (slideWidth / 1000);
            var deltaX = event.deltaX;
            var index = deltaX < 0 ? this.getNextIndex() : this.getPrevIndex();
            var offset = deltaX < 0 ? slideWidth + deltaX : -slideWidth + deltaX;
            if (!this.gesturesSupport || event.isFinal || Math.abs(deltaX) + panOffset >= slideWidth) {
                return;
            }
            if (!this.loop && ((this.current === 0 && deltaX > 0) || (this.current === this.total - 1 && deltaX < 0))) {
                this.incomingSlide = null;
                return;
            }
            event.preventDefault();
            if (this.isPlaying) {
                this.stoppedByInteraction = true;
                this.stop();
            }
            if (this.previousSlide && this.previousSlide.previous) {
                this.previousSlide.previous = false;
            }
            this.finishAnimations();
            if (this.incomingSlide) {
                if (index !== this.incomingSlide.index) {
                    this.resetSlideStyles(this.incomingSlide);
                    this.incomingSlide.previous = false;
                    this.incomingSlide = this.get(index);
                }
            }
            else {
                this.incomingSlide = this.get(index);
            }
            this.incomingSlide.previous = true;
            if (this.animationType === CarouselAnimationType.fade) {
                this.currentSlide.nativeElement.style.opacity = "" + Math.abs(offset) / slideWidth;
            }
            else {
                this.currentSlide.nativeElement.style.transform = "translateX(" + deltaX + "px)";
                this.incomingSlide.nativeElement.style.transform = "translateX(" + offset + "px)";
            }
        };
        IgxCarouselComponent.prototype.unsubscriber = function (slide) {
            return rxjs.merge(this.destroy$, slide.isDestroyed);
        };
        IgxCarouselComponent.prototype.onSlideActivated = function (slide) {
            var _this = this;
            if (slide.active && slide !== this.currentSlide) {
                if (slide.direction === Direction$1.NONE) {
                    var newIndex = slide.index;
                    slide.direction = newIndex > this.current ? Direction$1.NEXT : Direction$1.PREV;
                }
                if (this.currentSlide) {
                    if (this.previousSlide && this.previousSlide.previous) {
                        this.previousSlide.previous = false;
                    }
                    this.currentSlide.direction = slide.direction;
                    this.currentSlide.active = false;
                    this.previousSlide = this.currentSlide;
                    this.currentSlide = slide;
                    if (this.animationType !== CarouselAnimationType.none) {
                        if (this.animationStarted(this.leaveAnimationPlayer) || this.animationStarted(this.enterAnimationPlayer)) {
                            requestAnimationFrame(function () {
                                _this.resetAnimations();
                                _this.playAnimations();
                            });
                        }
                        else {
                            this.playAnimations();
                        }
                    }
                }
                else {
                    this.currentSlide = slide;
                }
                this.onSlideChanged.emit({ carousel: this, slide: slide });
                this.restartInterval();
            }
        };
        IgxCarouselComponent.prototype.playAnimations = function () {
            this.playLeaveAnimation();
            this.playEnterAnimation();
        };
        IgxCarouselComponent.prototype.finishAnimations = function () {
            if (this.animationStarted(this.leaveAnimationPlayer)) {
                this.leaveAnimationPlayer.finish();
            }
            if (this.animationStarted(this.enterAnimationPlayer)) {
                this.enterAnimationPlayer.finish();
            }
        };
        IgxCarouselComponent.prototype.resetAnimations = function () {
            if (this.animationStarted(this.leaveAnimationPlayer)) {
                this.leaveAnimationPlayer.reset();
            }
            if (this.animationStarted(this.enterAnimationPlayer)) {
                this.enterAnimationPlayer.reset();
            }
        };
        IgxCarouselComponent.prototype.animationStarted = function (animation) {
            return animation && animation.hasStarted();
        };
        IgxCarouselComponent.prototype.getAnimation = function () {
            var duration;
            if (this.newDuration) {
                duration = this.animationPosition ? this.animationPosition * this.newDuration : this.newDuration;
            }
            else {
                duration = this.animationPosition ? this.animationPosition * this.animationDuration : this.animationDuration;
            }
            switch (this.animationType) {
                case CarouselAnimationType.slide:
                    var trans = this.animationPosition ? this.animationPosition * 100 : 100;
                    return {
                        enterAnimation: i1.useAnimation(slideInLeft, {
                            params: {
                                delay: '0s',
                                duration: duration + "ms",
                                endOpacity: 1,
                                startOpacity: 1,
                                fromPosition: "translateX(" + (this.currentSlide.direction === 1 ? trans : -trans) + "%)",
                                toPosition: 'translateX(0%)'
                            }
                        }),
                        leaveAnimation: i1.useAnimation(slideInLeft, {
                            params: {
                                delay: '0s',
                                duration: duration + "ms",
                                endOpacity: 1,
                                startOpacity: 1,
                                fromPosition: "translateX(0%)",
                                toPosition: "translateX(" + (this.currentSlide.direction === 1 ? -trans : trans) + "%)",
                            }
                        })
                    };
                case CarouselAnimationType.fade:
                    return {
                        enterAnimation: i1.useAnimation(fadeIn, { params: { duration: duration + "ms", startOpacity: "" + this.animationPosition } }),
                        leaveAnimation: null
                    };
            }
            return {
                enterAnimation: null,
                leaveAnimation: null
            };
        };
        IgxCarouselComponent.prototype.playEnterAnimation = function () {
            var _this = this;
            var animation = this.getAnimation().enterAnimation;
            if (!animation) {
                return;
            }
            var animationBuilder = this.builder.build(animation);
            this.enterAnimationPlayer = animationBuilder.create(this.currentSlide.nativeElement);
            this.enterAnimationPlayer.onDone(function () {
                if (_this.enterAnimationPlayer) {
                    _this.enterAnimationPlayer.reset();
                    _this.enterAnimationPlayer = null;
                }
                _this.animationPosition = 0;
                _this.newDuration = 0;
                _this.previousSlide.previous = false;
            });
            this.previousSlide.previous = true;
            this.enterAnimationPlayer.play();
        };
        IgxCarouselComponent.prototype.playLeaveAnimation = function () {
            var _this = this;
            var animation = this.getAnimation().leaveAnimation;
            if (!animation) {
                return;
            }
            var animationBuilder = this.builder.build(animation);
            this.leaveAnimationPlayer = animationBuilder.create(this.previousSlide.nativeElement);
            this.leaveAnimationPlayer.onDone(function () {
                if (_this.leaveAnimationPlayer) {
                    _this.leaveAnimationPlayer.reset();
                    _this.leaveAnimationPlayer = null;
                }
                _this.animationPosition = 0;
                _this.newDuration = 0;
            });
            this.leaveAnimationPlayer.play();
        };
        IgxCarouselComponent.prototype.initSlides = function (change) {
            var _this = this;
            var diff = this.differ.diff(change.toArray());
            if (diff) {
                this.slides.reduce(function (any, c, ind) { return c.index = ind; }, 0); // reset slides indexes
                diff.forEachAddedItem(function (record) {
                    var slide = record.item;
                    slide.total = _this.total;
                    _this.onSlideAdded.emit({ carousel: _this, slide: slide });
                    if (slide.active) {
                        _this.currentSlide = slide;
                    }
                    slide.activeChange.pipe(operators.takeUntil(_this.unsubscriber(slide))).subscribe(function () { return _this.onSlideActivated(slide); });
                });
                diff.forEachRemovedItem(function (record) {
                    var slide = record.item;
                    _this.onSlideRemoved.emit({ carousel: _this, slide: slide });
                    if (slide.active) {
                        slide.active = false;
                        _this.currentSlide = _this.get(slide.index < _this.total ? slide.index : _this.total - 1);
                    }
                });
                this.updateSlidesSelection();
            }
        };
        IgxCarouselComponent.prototype.updateSlidesSelection = function () {
            var _this = this;
            if (this.platformUtil.isBrowser) {
                requestAnimationFrame(function () {
                    if (_this.currentSlide) {
                        _this.currentSlide.active = true;
                        var activeSlides = _this.slides.filter(function (slide) { return slide.active && slide.index !== _this.currentSlide.index; });
                        activeSlides.forEach(function (slide) { return slide.active = false; });
                    }
                    else if (_this.total) {
                        _this.slides.first.active = true;
                    }
                    _this.play();
                });
            }
        };
        return IgxCarouselComponent;
    }());
    IgxCarouselComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [
                        {
                            provide: i1$1.HAMMER_GESTURE_CONFIG,
                            useClass: CarouselHammerConfig
                        }
                    ],
                    selector: 'igx-carousel',
                    template: "<ng-template #defaultIndicator let-slide>\n    <div class=\"igx-nav-dot\"\n        [class.igx-nav-dot--active]=\"slide.active\">\n    </div>\n</ng-template>\n\n<ng-template #defaultNextButton let-disabled>\n    <span class=\"igx-nav-arrow\"\n          [class.igx-nav-arrow--disabled]=\"disabled\">\n        <igx-icon>arrow_forward</igx-icon>\n    </span>\n</ng-template>\n\n<ng-template #defaultPrevButton let-disabled>\n    <span class=\"igx-nav-arrow\"\n          [class.igx-nav-arrow--disabled]=\"disabled\">\n        <igx-icon>arrow_back</igx-icon>\n    </span>\n</ng-template>\n\n<div *ngIf=\"showIndicators\" [ngClass]=\"indicatorsOrientationClass\" [attr.role]=\"'tablist'\">\n    <div *ngFor=\"let slide of slides\"\n        class=\"igx-carousel-indicators__indicator\"\n        (click)=\"select(slide)\"\n        [id]=\"'tab-'+ slide.index + '-' + total\"\n        [attr.role]=\"'tab'\"\n        [attr.aria-label]=\"resourceStrings.igx_carousel_slide + ' ' + (slide.index + 1) + ' ' + resourceStrings.igx_carousel_of + ' ' + this.total\"\n        [attr.aria-controls]=\"'panel-' + slide.index\"\n        [attr.aria-selected]=\"slide.active\">\n        <ng-container *ngTemplateOutlet=\"getIndicatorTemplate; context: {$implicit: slide};\"></ng-container>\n    </div>\n</div>\n\n<div *ngIf=\"showIndicatorsLabel\" [ngClass]=\"indicatorsOrientationClass\">\n    <span [id]=\"labelId\" class=\"igx-carousel__label\">{{getCarouselLabel}}</span>\n</div>\n\n<div class=\"igx-carousel__inner\" [attr.aria-live]=\"!interval || stoppedByInteraction ? 'polite' : 'off'\">\n    <ng-content></ng-content>\n</div>\n\n<div *ngIf=\"navigation && slides.length\" role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--prev\" [attr.aria-label]=\"resourceStrings.igx_carousel_previous_slide\" (keydown.enter)=\"prev()\" (click)=\"prev()\">\n    <ng-container *ngTemplateOutlet=\"getPrevButtonTemplate; context: {$implicit: prevButtonDisabled};\"></ng-container>\n</div>\n\n<div *ngIf=\"navigation && slides.length\" role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--next\" [attr.aria-label]=\"resourceStrings.igx_carousel_next_slide\" (keydown.enter)=\"next()\" (click)=\"next()\">\n    <ng-container *ngTemplateOutlet=\"getNextButtonTemplate; context: {$implicit: nextButtonDisabled};\"></ng-container>\n</div>\n\n\n\n",
                    styles: ["\n    :host {\n        display: block;\n        outline-style: none;\n    }"]
                },] }
    ];
    IgxCarouselComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.IterableDiffers },
        { type: i1.AnimationBuilder },
        { type: PlatformUtil }
    ]; };
    IgxCarouselComponent.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        roleDescription: [{ type: i0.HostBinding, args: ['attr.aria-roledescription',] }],
        labelId: [{ type: i0.HostBinding, args: ['attr.aria-labelledby',] }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-carousel',] }],
        touchAction: [{ type: i0.HostBinding, args: ['style.touch-action',] }],
        loop: [{ type: i0.Input }],
        pause: [{ type: i0.Input }],
        navigation: [{ type: i0.Input }],
        keyboardSupport: [{ type: i0.Input }],
        gesturesSupport: [{ type: i0.Input }],
        maximumIndicatorsCount: [{ type: i0.Input }],
        indicatorsOrientation: [{ type: i0.Input }],
        animationType: [{ type: i0.Input }],
        indicatorTemplate: [{ type: i0.ContentChild, args: [IgxCarouselIndicatorDirective, { read: i0.TemplateRef, static: false },] }],
        nextButtonTemplate: [{ type: i0.ContentChild, args: [IgxCarouselNextButtonDirective, { read: i0.TemplateRef, static: false },] }],
        prevButtonTemplate: [{ type: i0.ContentChild, args: [IgxCarouselPrevButtonDirective, { read: i0.TemplateRef, static: false },] }],
        slides: [{ type: i0.ContentChildren, args: [IgxSlideComponent,] }],
        onSlideChanged: [{ type: i0.Output }],
        onSlideAdded: [{ type: i0.Output }],
        onSlideRemoved: [{ type: i0.Output }],
        onCarouselPaused: [{ type: i0.Output }],
        onCarouselPlaying: [{ type: i0.Output }],
        defaultIndicator: [{ type: i0.ViewChild, args: ['defaultIndicator', { read: i0.TemplateRef, static: true },] }],
        defaultNextButton: [{ type: i0.ViewChild, args: ['defaultNextButton', { read: i0.TemplateRef, static: true },] }],
        defaultPrevButton: [{ type: i0.ViewChild, args: ['defaultPrevButton', { read: i0.TemplateRef, static: true },] }],
        resourceStrings: [{ type: i0.Input }],
        interval: [{ type: i0.Input }],
        onKeydownArrowRight: [{ type: i0.HostListener, args: ['keydown.arrowright', ['$event'],] }],
        onKeydownArrowLeft: [{ type: i0.HostListener, args: ['keydown.arrowleft', ['$event'],] }],
        onTap: [{ type: i0.HostListener, args: ['tap', ['$event'],] }],
        onKeydownHome: [{ type: i0.HostListener, args: ['keydown.home', ['$event'],] }],
        onKeydownEnd: [{ type: i0.HostListener, args: ['keydown.end', ['$event'],] }],
        onMouseEnter: [{ type: i0.HostListener, args: ['mouseenter',] }],
        onMouseLeave: [{ type: i0.HostListener, args: ['mouseleave',] }],
        onPanLeft: [{ type: i0.HostListener, args: ['panleft', ['$event'],] }],
        onPanRight: [{ type: i0.HostListener, args: ['panright', ['$event'],] }],
        onPanEnd: [{ type: i0.HostListener, args: ['panend', ['$event'],] }]
    };
    /**
     * @hidden
     */
    var IgxCarouselModule = /** @class */ (function () {
        function IgxCarouselModule() {
        }
        return IgxCarouselModule;
    }());
    IgxCarouselModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxCarouselComponent,
                        IgxSlideComponent,
                        IgxCarouselIndicatorDirective,
                        IgxCarouselNextButtonDirective,
                        IgxCarouselPrevButtonDirective
                    ],
                    exports: [
                        IgxCarouselComponent,
                        IgxSlideComponent,
                        IgxCarouselIndicatorDirective,
                        IgxCarouselNextButtonDirective,
                        IgxCarouselPrevButtonDirective
                    ],
                    imports: [i2.CommonModule, IgxIconModule]
                },] }
    ];

    var CHIP_ID = 0;
    /**
     * Chip is compact visual component that displays information in an obround.
     *
     * @igxModule IgxChipsModule
     *
     * @igxTheme igx-chip-theme
     *
     * @igxKeywords chip
     *
     * @igxGroup display
     *
     * @remarks
     * The Ignite UI Chip can be templated, deleted, and selected.
     * Multiple chips can be reordered and visually connected to each other.
     * Chips reside in a container called chips area which is responsible for managing the interactions between the chips.
     *
     * @example
     * ```html
     * <igx-chip class="chipStyle" [id]="901" [draggable]="true" [removable]="true" (remove)="chipRemoved($event)">
     *    <igx-avatar class="chip-avatar-resized" igxPrefix roundShape="true"></igx-avatar>
     * </igx-chip>
     * ```
     */
    var IgxChipComponent = /** @class */ (function (_super) {
        __extends(IgxChipComponent, _super);
        function IgxChipComponent(cdr, elementRef, renderer, _displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.cdr = cdr;
            _this.elementRef = elementRef;
            _this.renderer = renderer;
            _this._displayDensityOptions = _displayDensityOptions;
            /**
             * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
             *
             * @example
             * ```html
             * <igx-chip [id]="'igx-chip-1'"></igx-chip>
             * ```
             */
            _this.id = "igx-chip-" + CHIP_ID++;
            /**
             * An @Input property that defines if the `IgxChipComponent` can be dragged in order to change it's position.
             * By default it is set to false.
             *
             * @example
             * ```html
             * <igx-chip [id]="'igx-chip-1'" [draggable]="true"></igx-chip>
             * ```
             */
            _this.draggable = false;
            /**
             * An @Input property that enables/disables the draggable element animation when the element is released.
             * By default it's set to true.
             *
             * @example
             * ```html
             * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [animateOnRelease]="false"></igx-chip>
             * ```
             */
            _this.animateOnRelease = true;
            /**
             * An @Input property that enables/disables the hiding of the base element that has been dragged.
             * By default it's set to true.
             *
             * @example
             * ```html
             * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [hideBaseOnDrag]="false"></igx-chip>
             * ```
             */
            _this.hideBaseOnDrag = true;
            /**
             * An @Input property that defines if the `IgxChipComponent` should render remove button and throw remove events.
             * By default it is set to false.
             *
             * @example
             * ```html
             * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [removable]="true"></igx-chip>
             * ```
             */
            _this.removable = false;
            /**
             * An @Input property that defines if the `IgxChipComponent` can be selected on click or through navigation,
             * By default it is set to false.
             *
             * @example
             * ```html
             * <igx-chip [id]="chip.id" [draggable]="true" [removable]="true" [selectable]="true"></igx-chip>
             * ```
             */
            _this.selectable = false;
            /**
             * @hidden
             * @internal
             */
            _this.class = '';
            /**
             * An @Input property that defines if the `IgxChipComponent` is disabled. When disabled it restricts user interactions
             * like focusing on click or tab, selection on click or Space, dragging.
             * By default it is set to false.
             *
             * @example
             * ```html
             * <igx-chip [id]="chip.id" [disabled]="true"></igx-chip>
             * ```
             */
            _this.disabled = false;
            /**
             * @hidden
             * @internal
             */
            _this.selectedChange = new i0.EventEmitter();
            /**
             * Emits an event when the `IgxChipComponent` moving starts.
             * Returns the moving `IgxChipComponent`.
             *
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (moveStart)="moveStarted($event)">
             * ```
             */
            _this.moveStart = new i0.EventEmitter();
            /**
             * Emits an event when the `IgxChipComponent` moving ends.
             * Returns the moved `IgxChipComponent`.
             *
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (moveEnd)="moveEnded($event)">
             * ```
             */
            _this.moveEnd = new i0.EventEmitter();
            /**
             * Emits an event when the `IgxChipComponent` is removed.
             * Returns the removed `IgxChipComponent`.
             *
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (remove)="remove($event)">
             * ```
             */
            _this.remove = new i0.EventEmitter();
            /**
             * Emits an event when the `IgxChipComponent` is clicked.
             * Returns the clicked `IgxChipComponent`, whether the event should be canceled.
             *
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (click)="chipClick($event)">
             * ```
             */
            _this.chipClick = new i0.EventEmitter();
            /**
             * Emits event when the `IgxChipComponent` is selected/deselected.
             * Returns the selected chip reference, whether the event should be canceled, what is the next selection state and
             * when the event is triggered by interaction `originalEvent` is provided, otherwise `originalEvent` is `null`.
             *
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (selectedChanging)="chipSelect($event)">
             * ```
             */
            _this.selectedChanging = new i0.EventEmitter();
            /**
             * Emits event when the `IgxChipComponent` is selected/deselected and any related animations and transitions also end.
             *
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (selectedChanged)="chipSelectEnd($event)">
             * ```
             */
            _this.selectedChanged = new i0.EventEmitter();
            /**
             * Emits an event when the `IgxChipComponent` keyboard navigation is being used.
             * Returns the focused/selected `IgxChipComponent`, whether the event should be canceled,
             * if the `alt`, `shift` or `control` key is pressed and the pressed key name.
             *
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (keyDown)="chipKeyDown($event)">
             * ```
             */
            _this.keyDown = new i0.EventEmitter();
            /**
             * Emits an event when the `IgxChipComponent` has entered the `IgxChipsAreaComponent`.
             * Returns the target `IgxChipComponent`, the drag `IgxChipComponent`, as  well as
             * the original drop event arguments.
             *
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onDragEnter)="chipEnter($event)">
             * ```
             */
            _this.dragEnter = new i0.EventEmitter();
            /**
             * @hidden
             * @internal
             */
            _this.hideBaseElement = false;
            _this._tabIndex = null;
            _this._selected = false;
            _this._selectedItemClass = 'igx-chip__item--selected';
            _this._movedWhileRemoving = false;
            return _this;
        }
        Object.defineProperty(IgxChipComponent.prototype, "tabIndex", {
            get: function () {
                if (this._tabIndex !== null) {
                    return this._tabIndex;
                }
                return !this.disabled ? 0 : null;
            },
            /**
             * An @Input property that sets the value of `tabindex` attribute. If not provided it will use the element's tabindex if set.
             *
             * @example
             * ```html
             * <igx-chip [id]="'igx-chip-1'" [tabIndex]="1"></igx-chip>
             * ```
             */
            set: function (value) {
                this._tabIndex = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxChipComponent.prototype, "selected", {
            /**
             * Returns if the `IgxChipComponent` is selected.
             *
             * @example
             * ```typescript
             * @ViewChild('myChip')
             * public chip: IgxChipComponent;
             * selectedChip(){
             *     let selectedChip = this.chip.selected;
             * }
             * ```
             */
            get: function () {
                return this._selected;
            },
            /**
             * Sets the `IgxChipComponent` selected state.
             *
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [selected]="true">
             * ```
             *
             * Two-way data binding:
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [(selected)]="model.isSelected">
             * ```
             */
            set: function (newValue) {
                this.changeSelection(newValue);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxChipComponent.prototype, "color", {
            /**
             * Returns the background color of the `IgxChipComponent`.
             *
             * @example
             * ```typescript
             * @ViewChild('myChip')
             * public chip: IgxChipComponent;
             * ngAfterViewInit(){
             *     let chipColor = this.chip.color;
             * }
             * ```
             */
            get: function () {
                return this.chipArea.nativeElement.style.backgroundColor;
            },
            /**
             * An @Input property that sets the `IgxChipComponent` background color.
             * The `color` property supports string, rgb, hex.
             *
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [color]="'#ff0000'"></igx-chip>
             * ```
             */
            set: function (newColor) {
                this.chipArea.nativeElement.style.backgroundColor = newColor;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxChipComponent.prototype, "hostClass", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                var classes = [this.getComponentDensityClass('igx-chip')];
                classes.push(this.disabled ? 'igx-chip--disabled' : '');
                // The custom classes should be at the end.
                classes.push(this.class);
                return classes.join(' ');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxChipComponent.prototype, "removeButtonTemplate", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.removeIcon || this.defaultRemoveIcon;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxChipComponent.prototype, "selectIconTemplate", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.selectIcon || this.defaultSelectIcon;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxChipComponent.prototype, "ghostClass", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.getComponentDensityClass('igx-chip__ghost');
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.keyEvent = function (event) {
            this.onChipKeyDown(event);
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.selectClass = function (condition) {
            var _a;
            var SELECT_CLASS = 'igx-chip__select';
            return _a = {},
                _a[SELECT_CLASS] = condition,
                _a[SELECT_CLASS + "--hidden"] = !condition,
                _a;
        };
        IgxChipComponent.prototype.onSelectTransitionDone = function (event) {
            if (!!event.target.tagName) {
                // Trigger onSelectionDone on when `width` property is changed and the target is valid element(not comment).
                this.selectedChanged.emit({
                    owner: this,
                    originalEvent: event
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onChipKeyDown = function (event) {
            var keyDownArgs = {
                originalEvent: event,
                owner: this,
                cancel: false
            };
            this.keyDown.emit(keyDownArgs);
            if (keyDownArgs.cancel) {
                return;
            }
            if ((event.key === 'Delete' || event.key === 'Del') && this.removable) {
                this.remove.emit({
                    originalEvent: event,
                    owner: this
                });
            }
            if ((event.key === ' ' || event.key === 'Spacebar') && this.selectable && !this.disabled) {
                this.changeSelection(!this.selected, event);
            }
            if (event.key !== 'Tab') {
                event.preventDefault();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onRemoveBtnKeyDown = function (event) {
            if (event.key === ' ' || event.key === 'Spacebar' || event.key === 'Enter') {
                this.remove.emit({
                    originalEvent: event,
                    owner: this
                });
                event.preventDefault();
                event.stopPropagation();
            }
        };
        IgxChipComponent.prototype.onRemoveMouseDown = function (event) {
            event.stopPropagation();
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onRemoveClick = function (event) {
            this.remove.emit({
                originalEvent: event,
                owner: this
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onRemoveTouchMove = function () {
            // We don't remove chip if user starting touch interacting on the remove button moves the chip
            this._movedWhileRemoving = true;
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onRemoveTouchEnd = function (event) {
            if (!this._movedWhileRemoving) {
                this.onRemoveClick(event);
            }
            this._movedWhileRemoving = false;
        };
        /**
         * @hidden
         * @internal
         */
        // -----------------------------
        // Start chip igxDrag behavior
        IgxChipComponent.prototype.onChipDragStart = function (event) {
            this.moveStart.emit({
                originalEvent: event,
                owner: this
            });
            event.cancel = !this.draggable || this.disabled;
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onChipDragEnd = function () {
            if (this.animateOnRelease) {
                this.dragDirective.transitionToOrigin();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onChipMoveEnd = function (event) {
            // moveEnd is triggered after return animation has finished. This happen when we drag and release the chip.
            this.moveEnd.emit({
                originalEvent: event,
                owner: this
            });
            if (this.selected) {
                this.chipArea.nativeElement.focus();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onChipGhostCreate = function () {
            this.hideBaseElement = this.hideBaseOnDrag;
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onChipGhostDestroy = function () {
            this.hideBaseElement = false;
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onChipDragClicked = function (event) {
            var clickEventArgs = {
                originalEvent: event,
                owner: this,
                cancel: false
            };
            this.chipClick.emit(clickEventArgs);
            if (!clickEventArgs.cancel && this.selectable && !this.disabled) {
                this.changeSelection(!this.selected, event);
            }
        };
        // End chip igxDrag behavior
        /**
         * @hidden
         * @internal
         */
        // -----------------------------
        // Start chip igxDrop behavior
        IgxChipComponent.prototype.onChipDragEnterHandler = function (event) {
            if (this.dragDirective === event.drag || !event.drag.data || !event.drag.data.chip) {
                return;
            }
            var eventArgs = {
                owner: this,
                dragChip: event.drag.data.chip,
                originalEvent: event
            };
            this.dragEnter.emit(eventArgs);
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onChipDrop = function (event) {
            // Cancel the default drop logic
            event.cancel = true;
        };
        // End chip igxDrop behavior
        IgxChipComponent.prototype.changeSelection = function (newValue, srcEvent) {
            var _this = this;
            if (srcEvent === void 0) { srcEvent = null; }
            var onSelectArgs = {
                originalEvent: srcEvent,
                owner: this,
                selected: false,
                cancel: false
            };
            rxjs.fromEvent(this.selectContainer.nativeElement, 'transitionend')
                .pipe(operators.filter(function (event) { return event.propertyName === 'width'; }), operators.take(1))
                .subscribe(function (event) { return _this.onSelectTransitionDone(event); });
            if (newValue && !this._selected) {
                onSelectArgs.selected = true;
                this.selectedChanging.emit(onSelectArgs);
                if (!onSelectArgs.cancel) {
                    this.renderer.addClass(this.chipArea.nativeElement, this._selectedItemClass);
                    this._selected = newValue;
                    this.selectedChange.emit(this._selected);
                }
            }
            else if (!newValue && this._selected) {
                this.selectedChanging.emit(onSelectArgs);
                if (!onSelectArgs.cancel) {
                    this.renderer.removeClass(this.chipArea.nativeElement, this._selectedItemClass);
                    this._selected = newValue;
                    this.selectedChange.emit(this._selected);
                }
            }
        };
        return IgxChipComponent;
    }(DisplayDensityBase));
    IgxChipComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-chip',
                    template: "<div #chipArea class=\"igx-chip__item\"\n    [igxDrag]=\"{chip: this}\"\n    [style.visibility]='hideBaseElement ? \"hidden\" : \"visible\"'\n    [ghostClass]=\"ghostClass\"\n    (dragStart)=\"onChipDragStart($event)\"\n    (ghostCreate)=\"onChipGhostCreate()\"\n    (ghostDestroy)=\"onChipGhostDestroy()\"\n    (dragEnd)=\"onChipDragEnd()\"\n    (transitioned)=\"onChipMoveEnd($event)\"\n    (dragClick)=\"onChipDragClicked($event)\"\n    igxDrop\n    (enter)=\"onChipDragEnterHandler($event)\"\n    (dropped)=\"onChipDrop($event)\">\n\n    <div #selectContainer [ngClass]=\"selectClass(selected)\">\n        <ng-container *ngTemplateOutlet=\"selectIconTemplate\"></ng-container>\n    </div>\n\n    <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n\n    <div class=\"igx-chip__content\">\n        <ng-content></ng-content>\n    </div>\n\n    <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n\n    <div class=\"igx-chip__remove\" *ngIf=\"removable\"\n        [attr.tabIndex]=\"tabIndex\"\n        (keydown)=\"onRemoveBtnKeyDown($event)\"\n        (pointerdown)=\"onRemoveMouseDown($event)\"\n        (mousedown)=\"onRemoveMouseDown($event)\"\n        (click)=\"onRemoveClick($event)\"\n        (touchmove)=\"onRemoveTouchMove()\"\n        (touchend)=\"onRemoveTouchEnd($event)\">\n        <ng-container *ngTemplateOutlet=\"removeButtonTemplate\"></ng-container>\n    </div>\n</div>\n\n<ng-template #defaultSelectIcon>\n    <igx-icon>done</igx-icon>\n</ng-template>\n\n<ng-template #defaultRemoveIcon>\n    <igx-icon>cancel</igx-icon>\n</ng-template>\n"
                },] }
    ];
    IgxChipComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef },
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxChipComponent.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        tabIndex: [{ type: i0.HostBinding, args: ['attr.tabIndex',] }, { type: i0.Input }],
        data: [{ type: i0.Input }],
        draggable: [{ type: i0.Input }],
        animateOnRelease: [{ type: i0.Input }],
        hideBaseOnDrag: [{ type: i0.Input }],
        removable: [{ type: i0.Input }],
        removeIcon: [{ type: i0.Input }],
        selectable: [{ type: i0.Input }],
        selectIcon: [{ type: i0.Input }],
        class: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        selected: [{ type: i0.Input }],
        selectedChange: [{ type: i0.Output }],
        color: [{ type: i0.Input }],
        moveStart: [{ type: i0.Output }],
        moveEnd: [{ type: i0.Output }],
        remove: [{ type: i0.Output }],
        chipClick: [{ type: i0.Output }],
        selectedChanging: [{ type: i0.Output }],
        selectedChanged: [{ type: i0.Output }],
        keyDown: [{ type: i0.Output }],
        dragEnter: [{ type: i0.Output }],
        hostClass: [{ type: i0.HostBinding, args: ['attr.class',] }],
        dragDirective: [{ type: i0.ViewChild, args: ['chipArea', { read: IgxDragDirective, static: true },] }],
        chipArea: [{ type: i0.ViewChild, args: ['chipArea', { read: i0.ElementRef, static: true },] }],
        selectContainer: [{ type: i0.ViewChild, args: ['selectContainer', { read: i0.ElementRef, static: true },] }],
        defaultRemoveIcon: [{ type: i0.ViewChild, args: ['defaultRemoveIcon', { read: i0.TemplateRef, static: true },] }],
        defaultSelectIcon: [{ type: i0.ViewChild, args: ['defaultSelectIcon', { read: i0.TemplateRef, static: true },] }],
        keyEvent: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
    };

    /**
     * The chip area allows you to perform more complex scenarios with chips that require interaction,
     * like dragging, selection, navigation, etc.
     *
     * @igxModule IgxChipsModule
     *
     * @igxTheme igx-chip-theme
     *
     * @igxKeywords chip area, chip
     *
     * @igxGroup display
     *
     * @example
     * ```html
     * <igx-chips-area>
     *    <igx-chip *ngFor="let chip of chipList" [id]="chip.id">
     *        <span>{{chip.text}}</span>
     *    </igx-chip>
     * </igx-chips-area>
     * ```
     */
    var IgxChipsAreaComponent = /** @class */ (function () {
        function IgxChipsAreaComponent(cdr, element, _iterableDiffers) {
            this.cdr = cdr;
            this.element = element;
            this._iterableDiffers = _iterableDiffers;
            /**
             * @hidden
             * @internal
             */
            this.class = '';
            /**
             * Emits an event when `IgxChipComponent`s in the `IgxChipsAreaComponent` should be reordered.
             * Returns an array of `IgxChipComponent`s.
             *
             * @example
             * ```html
             * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onReorder)="changedOrder($event)"></igx-chips-area>
             * ```
             */
            this.reorder = new i0.EventEmitter();
            /**
             * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is selected/deselected.
             * Fired after the chips area is initialized if there are initially selected chips as well.
             * Returns an array of selected `IgxChipComponent`s and the `IgxChipAreaComponent`.
             *
             * @example
             * ```html
             * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (selectionChange)="selection($event)"></igx-chips-area>
             * ```
             */
            this.selectionChange = new i0.EventEmitter();
            /**
             * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
             *
             * @example
             * ```html
             * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (moveStart)="moveStart($event)"></igx-chips-area>
             * ```
             */
            this.moveStart = new i0.EventEmitter();
            /**
             * Emits an event after an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
             *
             * @example
             * ```html
             * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (moveEnd)="moveEnd($event)"></igx-chips-area>
             * ```
             */
            this.moveEnd = new i0.EventEmitter();
            this.destroy$ = new rxjs.Subject();
            this._differ = null;
            this._differ = this._iterableDiffers.find([]).create(null);
        }
        Object.defineProperty(IgxChipsAreaComponent.prototype, "hostClass", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                var classes = ['igx-chip-area'];
                classes.push(this.class);
                return classes.join(' ');
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.ngAfterViewInit = function () {
            // If we have initially selected chips through their inputs, we need to get them, because we cannot listen to their events yet.
            if (this.chipsList.length) {
                var selectedChips = this.chipsList.filter(function (item) { return item.selected; });
                if (selectedChips.length) {
                    this.selectionChange.emit({
                        originalEvent: null,
                        newSelection: selectedChips,
                        owner: this
                    });
                }
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.ngDoCheck = function () {
            var _this = this;
            if (this.chipsList) {
                var changes = this._differ.diff(this.chipsList.toArray());
                if (changes) {
                    changes.forEachAddedItem(function (addedChip) {
                        addedChip.item.moveStart.pipe(operators.takeUntil(_this.destroy$)).subscribe(function (args) {
                            _this.onChipMoveStart(args);
                        });
                        addedChip.item.moveEnd.pipe(operators.takeUntil(_this.destroy$)).subscribe(function (args) {
                            _this.onChipMoveEnd(args);
                        });
                        addedChip.item.dragEnter.pipe(operators.takeUntil(_this.destroy$)).subscribe(function (args) {
                            _this.onChipDragEnter(args);
                        });
                        addedChip.item.keyDown.pipe(operators.takeUntil(_this.destroy$)).subscribe(function (args) {
                            _this.onChipKeyDown(args);
                        });
                        if (addedChip.item.selectable) {
                            addedChip.item.selectedChanging.pipe(operators.takeUntil(_this.destroy$)).subscribe(function (args) {
                                _this.onChipSelectionChange(args);
                            });
                        }
                    });
                    this.modifiedChipsArray = this.chipsList.toArray();
                }
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.onChipKeyDown = function (event) {
            var _this = this;
            var orderChanged = false;
            var chipsArray = this.chipsList.toArray();
            var dragChipIndex = chipsArray.findIndex(function (el) { return el === event.owner; });
            if (event.originalEvent.shiftKey === true) {
                if (event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') {
                    orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex - 1, false, event.originalEvent);
                    if (orderChanged) {
                        setTimeout(function () {
                            _this.chipsList.toArray()[dragChipIndex - 1].elementRef.nativeElement.focus();
                        });
                    }
                }
                else if (event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') {
                    orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex + 1, true, event.originalEvent);
                }
            }
            else {
                if ((event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') && dragChipIndex > 0) {
                    chipsArray[dragChipIndex - 1].elementRef.nativeElement.focus();
                }
                else if ((event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') &&
                    dragChipIndex < chipsArray.length - 1) {
                    chipsArray[dragChipIndex + 1].elementRef.nativeElement.focus();
                }
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.onChipMoveStart = function (event) {
            this.moveStart.emit({
                originalEvent: event.originalEvent,
                owner: this
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.onChipMoveEnd = function (event) {
            this.moveEnd.emit({
                originalEvent: event.originalEvent,
                owner: this
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.onChipDragEnter = function (event) {
            var dropChipIndex = this.chipsList.toArray().findIndex(function (el) { return el === event.owner; });
            var dragChipIndex = this.chipsList.toArray().findIndex(function (el) { return el === event.dragChip; });
            if (dragChipIndex < dropChipIndex) {
                // from the left to right
                this.positionChipAtIndex(dragChipIndex, dropChipIndex, true, event.originalEvent);
            }
            else {
                // from the right to left
                this.positionChipAtIndex(dragChipIndex, dropChipIndex, false, event.originalEvent);
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.positionChipAtIndex = function (chipIndex, targetIndex, shiftRestLeft, originalEvent) {
            if (chipIndex < 0 || this.chipsList.length <= chipIndex ||
                targetIndex < 0 || this.chipsList.length <= targetIndex) {
                return false;
            }
            var chipsArray = this.chipsList.toArray();
            var result = [];
            for (var i = 0; i < chipsArray.length; i++) {
                if (shiftRestLeft) {
                    if (chipIndex <= i && i < targetIndex) {
                        result.push(chipsArray[i + 1]);
                    }
                    else if (i === targetIndex) {
                        result.push(chipsArray[chipIndex]);
                    }
                    else {
                        result.push(chipsArray[i]);
                    }
                }
                else {
                    if (targetIndex < i && i <= chipIndex) {
                        result.push(chipsArray[i - 1]);
                    }
                    else if (i === targetIndex) {
                        result.push(chipsArray[chipIndex]);
                    }
                    else {
                        result.push(chipsArray[i]);
                    }
                }
            }
            this.modifiedChipsArray = result;
            var eventData = {
                chipsArray: this.modifiedChipsArray,
                originalEvent: originalEvent,
                owner: this
            };
            this.reorder.emit(eventData);
            return true;
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.onChipSelectionChange = function (event) {
            var selectedChips = this.chipsList.filter(function (chip) { return chip.selected; });
            if (event.selected && !selectedChips.includes(event.owner)) {
                selectedChips.push(event.owner);
            }
            else if (!event.selected && selectedChips.includes(event.owner)) {
                selectedChips = selectedChips.filter(function (chip) { return chip.id !== event.owner.id; });
            }
            this.selectionChange.emit({
                originalEvent: event.originalEvent,
                newSelection: selectedChips,
                owner: this
            });
        };
        return IgxChipsAreaComponent;
    }());
    IgxChipsAreaComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-chips-area',
                    template: "<ng-content></ng-content>\n"
                },] }
    ];
    IgxChipsAreaComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef },
        { type: i0.ElementRef },
        { type: i0.IterableDiffers }
    ]; };
    IgxChipsAreaComponent.propDecorators = {
        class: [{ type: i0.Input }],
        hostClass: [{ type: i0.HostBinding, args: ['attr.class',] }],
        width: [{ type: i0.HostBinding, args: ['style.width.px',] }, { type: i0.Input }],
        height: [{ type: i0.HostBinding, args: ['style.height.px',] }, { type: i0.Input }],
        reorder: [{ type: i0.Output }],
        selectionChange: [{ type: i0.Output }],
        moveStart: [{ type: i0.Output }],
        moveEnd: [{ type: i0.Output }],
        chipsList: [{ type: i0.ContentChildren, args: [IgxChipComponent, { descendants: true },] }]
    };

    /**
     * @hidden
     */
    var IgxChipsModule = /** @class */ (function () {
        function IgxChipsModule() {
        }
        return IgxChipsModule;
    }());
    IgxChipsModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxChipsAreaComponent,
                        IgxChipComponent
                    ],
                    exports: [
                        IgxChipsAreaComponent,
                        IgxChipComponent,
                        IgxPrefixDirective,
                        IgxSuffixDirective
                    ],
                    imports: [
                        i2.CommonModule,
                        IgxRippleModule,
                        IgxIconModule,
                        IgxButtonModule,
                        IgxAvatarModule,
                        IgxDragDropModule,
                        IgxPrefixModule,
                        IgxSuffixModule
                    ]
                },] }
    ];

    /**
     * @hidden
     */
    var IgxComboHeaderDirective = /** @class */ (function () {
        function IgxComboHeaderDirective() {
        }
        return IgxComboHeaderDirective;
    }());
    IgxComboHeaderDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxComboHeader]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxComboFooterDirective = /** @class */ (function () {
        function IgxComboFooterDirective() {
        }
        return IgxComboFooterDirective;
    }());
    IgxComboFooterDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxComboFooter]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxComboItemDirective = /** @class */ (function () {
        function IgxComboItemDirective() {
        }
        return IgxComboItemDirective;
    }());
    IgxComboItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxComboItem]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxComboEmptyDirective = /** @class */ (function () {
        function IgxComboEmptyDirective() {
        }
        return IgxComboEmptyDirective;
    }());
    IgxComboEmptyDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxComboEmpty]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxComboHeaderItemDirective = /** @class */ (function () {
        function IgxComboHeaderItemDirective() {
        }
        return IgxComboHeaderItemDirective;
    }());
    IgxComboHeaderItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxComboHeaderItem]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxComboAddItemDirective = /** @class */ (function () {
        function IgxComboAddItemDirective() {
        }
        return IgxComboAddItemDirective;
    }());
    IgxComboAddItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxComboAddItem]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxComboToggleIconDirective = /** @class */ (function () {
        function IgxComboToggleIconDirective() {
        }
        return IgxComboToggleIconDirective;
    }());
    IgxComboToggleIconDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxComboToggleIcon]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxComboClearIconDirective = /** @class */ (function () {
        function IgxComboClearIconDirective() {
        }
        return IgxComboClearIconDirective;
    }());
    IgxComboClearIconDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxComboClearIcon]'
                },] }
    ];

    /**
     * @hidden
     */
    var IgxComboAPIService = /** @class */ (function () {
        function IgxComboAPIService() {
            this.disableTransitions = false;
        }
        Object.defineProperty(IgxComboAPIService.prototype, "valueKey", {
            get: function () {
                return this.combo.valueKey !== null && this.combo.valueKey !== undefined ? this.combo.valueKey : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboAPIService.prototype, "item_focusable", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboAPIService.prototype, "isRemote", {
            get: function () {
                return this.combo.isRemote;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboAPIService.prototype, "comboID", {
            get: function () {
                return this.combo.id;
            },
            enumerable: false,
            configurable: true
        });
        IgxComboAPIService.prototype.register = function (combo) {
            this.combo = combo;
        };
        IgxComboAPIService.prototype.clear = function () {
            this.combo = null;
        };
        IgxComboAPIService.prototype.add_custom_item = function () {
            if (!this.combo) {
                return;
            }
            this.combo.addItemToCollection();
        };
        IgxComboAPIService.prototype.set_selected_item = function (itemID, event) {
            var selected = this.combo.isItemSelected(itemID);
            if (itemID === null || itemID === undefined) {
                return;
            }
            if (!selected) {
                this.combo.selectItems([itemID], false, event);
            }
            else {
                this.combo.deselectItems([itemID], event);
            }
        };
        IgxComboAPIService.prototype.is_item_selected = function (itemID) {
            return this.combo.isItemSelected(itemID);
        };
        return IgxComboAPIService;
    }());
    IgxComboAPIService.decorators = [
        { type: i0.Injectable }
    ];

    /** @hidden */
    var IgxComboItemComponent = /** @class */ (function (_super) {
        __extends(IgxComboItemComponent, _super);
        function IgxComboItemComponent(comboAPI, dropDown, elementRef, selection) {
            var _this = _super.call(this, dropDown, elementRef, null, selection) || this;
            _this.comboAPI = comboAPI;
            _this.dropDown = dropDown;
            _this.elementRef = elementRef;
            _this.selection = selection;
            /**
             * Gets the height of a list item
             *
             * @hidden
             */
            _this.itemHeight = '';
            return _this;
        }
        Object.defineProperty(IgxComboItemComponent.prototype, "itemID", {
            /**
             * @hidden
             */
            get: function () {
                var valueKey = this.comboAPI.valueKey;
                return valueKey !== null ? this.value[valueKey] : this.value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboItemComponent.prototype, "comboID", {
            /**
             * @hidden
             */
            get: function () {
                return this.comboAPI.comboID;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboItemComponent.prototype, "disableTransitions", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.comboAPI.disableTransitions;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboItemComponent.prototype, "selected", {
            /**
             * @hidden
             */
            get: function () {
                return this.comboAPI.is_item_selected(this.itemID);
            },
            set: function (value) {
                if (this.isHeader) {
                    return;
                }
                this._selected = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxComboItemComponent.prototype.isVisible = function (direction) {
            var rect = this.element.nativeElement.getBoundingClientRect();
            var parentDiv = this.element.nativeElement.parentElement.parentElement.getBoundingClientRect();
            if (direction === Navigate.Down) {
                return rect.y + rect.height <= parentDiv.y + parentDiv.height;
            }
            return rect.y >= parentDiv.y;
        };
        /**
         * @inheritdoc
         */
        IgxComboItemComponent.prototype.clicked = function (event) {
            this.comboAPI.disableTransitions = false;
            if (!this.isSelectable) {
                return;
            }
            this.dropDown.navigateItem(this.index);
            this.comboAPI.set_selected_item(this.itemID, event);
        };
        /**
         * @hidden
         * @internal
         * The event that is prevented is the click on the checkbox label element.
         * That is the only visible element that a user can interact with.
         * The click propagates to the host and the preventDefault is to stop it from
         * switching focus to the input it's base on.
         * The toggle happens in an internal handler in the drop-down on the next task queue cycle.
         */
        IgxComboItemComponent.prototype.disableCheck = function (event) {
            event.preventDefault();
        };
        IgxComboItemComponent.prototype.ngDoCheck = function () {
        };
        return IgxComboItemComponent;
    }(IgxDropDownItemComponent));
    IgxComboItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-combo-item',
                    template: "<ng-container *ngIf=\"!isHeader\">\n    <igx-checkbox [checked]=\"selected\" disableRipple=\"true\" [disableTransitions]=\"disableTransitions\" [tabindex]=\"-1\" (click)=\"disableCheck($event)\" class=\"igx-combo__checkbox\"></igx-checkbox>\n</ng-container>\n<span class=\"igx-drop-down__inner\"><ng-content></ng-content></span>\n"
                },] }
    ];
    IgxComboItemComponent.ctorParameters = function () { return [
        { type: IgxComboAPIService },
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_DROPDOWN_BASE,] }] },
        { type: i0.ElementRef },
        { type: IgxSelectionAPIService, decorators: [{ type: i0.Inject, args: [IgxSelectionAPIService,] }] }
    ]; };
    IgxComboItemComponent.propDecorators = {
        itemHeight: [{ type: i0.Input }, { type: i0.HostBinding, args: ['style.height.px',] }]
    };

    var IGX_COMBO_COMPONENT = new i0.InjectionToken('IgxComboComponentToken');

    /**
     * @hidden
     */
    var IgxComboAddItemComponent = /** @class */ (function (_super) {
        __extends(IgxComboAddItemComponent, _super);
        function IgxComboAddItemComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IgxComboAddItemComponent.prototype, "selected", {
            get: function () {
                return false;
            },
            set: function (value) {
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @inheritdoc
         */
        IgxComboAddItemComponent.prototype.clicked = function (event) {
            this.comboAPI.disableTransitions = false;
            this.comboAPI.add_custom_item();
        };
        return IgxComboAddItemComponent;
    }(IgxComboItemComponent));
    IgxComboAddItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-combo-add-item',
                    template: '<ng-content></ng-content>',
                    providers: [{ provide: IgxComboItemComponent, useExisting: IgxComboAddItemComponent }]
                },] }
    ];

    /** @hidden */
    var IgxComboDropDownComponent = /** @class */ (function (_super) {
        __extends(IgxComboDropDownComponent, _super);
        function IgxComboDropDownComponent(elementRef, cdr, selection, combo, comboAPI, _displayDensityOptions) {
            var _this = _super.call(this, elementRef, cdr, selection, _displayDensityOptions) || this;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            _this.selection = selection;
            _this.combo = combo;
            _this.comboAPI = comboAPI;
            _this._displayDensityOptions = _displayDensityOptions;
            /**
             * @hidden
             * @internal
             */
            _this.children = null;
            _this.scrollHandler = function () {
                _this.comboAPI.disableTransitions = true;
            };
            return _this;
        }
        Object.defineProperty(IgxComboDropDownComponent.prototype, "scrollContainer", {
            /** @hidden @internal */
            get: function () {
                return this.virtDir.dc.location.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboDropDownComponent.prototype, "isScrolledToLast", {
            get: function () {
                var scrollTop = this.virtDir.scrollPosition;
                var scrollHeight = this.virtDir.getScroll().scrollHeight;
                return Math.floor(scrollTop + this.virtDir.igxForContainerSize) === scrollHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboDropDownComponent.prototype, "lastVisibleIndex", {
            get: function () {
                return this.combo.totalItemCount ?
                    Math.floor(this.combo.itemsMaxHeight / this.combo.itemHeight) :
                    this.items.length - 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboDropDownComponent.prototype, "sortedChildren", {
            get: function () {
                if (this.children !== undefined) {
                    return this.children.toArray()
                        .sort(function (a, b) { return a.index - b.index; });
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboDropDownComponent.prototype, "items", {
            /**
             * Get all non-header items
             *
             * ```typescript
             * let myDropDownItems = this.dropdown.items;
             * ```
             */
            get: function () {
                var e_1, _a;
                var items = [];
                if (this.children !== undefined) {
                    var sortedChildren = this.sortedChildren;
                    try {
                        for (var sortedChildren_1 = __values(sortedChildren), sortedChildren_1_1 = sortedChildren_1.next(); !sortedChildren_1_1.done; sortedChildren_1_1 = sortedChildren_1.next()) {
                            var child = sortedChildren_1_1.value;
                            if (!child.isHeader) {
                                items.push(child);
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (sortedChildren_1_1 && !sortedChildren_1_1.done && (_a = sortedChildren_1.return)) _a.call(sortedChildren_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                return items;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxComboDropDownComponent.prototype.onFocus = function () {
            this.focusedItem = this._focusedItem || this.items[0];
        };
        /**
         * @hidden @internal
         */
        IgxComboDropDownComponent.prototype.onBlur = function (evt) {
            this.focusedItem = null;
        };
        /**
         * @hidden @internal
         */
        IgxComboDropDownComponent.prototype.onToggleOpened = function () {
            this.onOpened.emit();
        };
        /**
         * @hidden
         */
        IgxComboDropDownComponent.prototype.navigateFirst = function () {
            this.navigateItem(this.virtDir.igxForOf.findIndex(function (e) { return !e.isHeader; }));
        };
        /**
         * @hidden
         */
        IgxComboDropDownComponent.prototype.navigatePrev = function () {
            if (this._focusedItem && this._focusedItem.index === 0 && this.virtDir.state.startIndex === 0) {
                this.combo.focusSearchInput(false);
            }
            else {
                _super.prototype.navigatePrev.call(this);
            }
        };
        /**
         * @hidden
         */
        IgxComboDropDownComponent.prototype.navigateNext = function () {
            var lastIndex = this.combo.totalItemCount ? this.combo.totalItemCount - 1 : this.virtDir.igxForOf.length - 1;
            if (this._focusedItem && this._focusedItem.index === lastIndex) {
                this.focusAddItemButton();
            }
            else {
                _super.prototype.navigateNext.call(this);
            }
        };
        /**
         * @hidden @internal
         */
        IgxComboDropDownComponent.prototype.selectItem = function (item) {
            if (item === null || item === undefined) {
                return;
            }
            this.comboAPI.set_selected_item(item.itemID);
            this._focusedItem = item;
        };
        /**
         * @hidden @internal
         */
        IgxComboDropDownComponent.prototype.updateScrollPosition = function () {
            this.virtDir.getScroll().scrollTop = this._scrollPosition;
        };
        /**
         * @hidden @internal
         */
        IgxComboDropDownComponent.prototype.onItemActionKey = function (key) {
            switch (key) {
                case DropDownActionKey.ENTER:
                    this.handleEnter();
                    break;
                case DropDownActionKey.SPACE:
                    this.handleSpace();
                    break;
                case DropDownActionKey.ESCAPE:
                    this.close();
            }
        };
        IgxComboDropDownComponent.prototype.ngAfterViewInit = function () {
            this.virtDir.getScroll().addEventListener('scroll', this.scrollHandler);
        };
        /**
         * @hidden @internal
         */
        IgxComboDropDownComponent.prototype.ngOnDestroy = function () {
            this.virtDir.getScroll().removeEventListener('scroll', this.scrollHandler);
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        IgxComboDropDownComponent.prototype.scrollToHiddenItem = function (newItem) { };
        IgxComboDropDownComponent.prototype.handleEnter = function () {
            if (this.isAddItemFocused()) {
                this.combo.addItemToCollection();
            }
            else {
                this.close();
            }
        };
        IgxComboDropDownComponent.prototype.handleSpace = function () {
            if (this.isAddItemFocused()) {
                return;
            }
            else {
                this.selectItem(this.focusedItem);
            }
        };
        IgxComboDropDownComponent.prototype.isAddItemFocused = function () {
            return this.focusedItem instanceof IgxComboAddItemComponent;
        };
        IgxComboDropDownComponent.prototype.focusAddItemButton = function () {
            if (this.combo.isAddButtonVisible()) {
                this.focusedItem = this.items[this.items.length - 1];
            }
        };
        return IgxComboDropDownComponent;
    }(IgxDropDownComponent));
    IgxComboDropDownComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-combo-drop-down',
                    template: "<div class=\"igx-drop-down__list\" [style.width]=\"width\"\nigxToggle\n(onAppended)=\"onToggleContentAppended()\"\n(onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n(onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <div class=\"igx-drop-down__list-scroll\" #scrollContainer [attr.id]=\"this.listId\" role=\"listbox\"\n    [style.height]=\"height\"\n    [style.maxHeight]=\"maxHeight\">\n        <ng-container *ngIf=\"!collapsed\">\n            <ng-content></ng-content>\n        </ng-container>\n    </div>\n</div>\n",
                    providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxComboDropDownComponent }]
                },] }
    ];
    IgxComboDropDownComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: IgxSelectionAPIService },
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_COMBO_COMPONENT,] }] },
        { type: IgxComboAPIService },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxComboDropDownComponent.propDecorators = {
        children: [{ type: i0.ContentChildren, args: [IgxComboItemComponent, { descendants: true },] }]
    };

    /**
     * @hidden
     */
    var IgxComboFilteringPipe = /** @class */ (function () {
        function IgxComboFilteringPipe() {
        }
        IgxComboFilteringPipe.prototype.transform = function (collection, searchValue, displayKey, shouldFilter, filteringOptions) {
            if (!collection) {
                return [];
            }
            if (!searchValue || !shouldFilter) {
                return collection;
            }
            else {
                var searchTerm_1 = filteringOptions.caseSensitive ? searchValue.trim() : searchValue.toLowerCase().trim();
                if (displayKey != null) {
                    return collection.filter(function (e) { return filteringOptions.caseSensitive ? e[displayKey].includes(searchTerm_1) :
                        e[displayKey].toString().toLowerCase().includes(searchTerm_1); });
                }
                else {
                    return collection.filter(function (e) { return filteringOptions.caseSensitive ? e.includes(searchTerm_1) :
                        e.toLowerCase().includes(searchTerm_1); });
                }
            }
        };
        return IgxComboFilteringPipe;
    }());
    IgxComboFilteringPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'comboFiltering'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxComboGroupingPipe = /** @class */ (function () {
        function IgxComboGroupingPipe(combo) {
            this.combo = combo;
        }
        IgxComboGroupingPipe.prototype.transform = function (collection, groupKey, valueKey) {
            var _a;
            this.combo.filteredData = collection;
            if ((!groupKey && groupKey !== 0) || !collection.length) {
                return collection;
            }
            var sorted = DataUtil.sort(cloneArray(collection), [{
                    fieldName: groupKey,
                    dir: exports.SortingDirection.Asc,
                    ignoreCase: true,
                    strategy: DefaultSortingStrategy.instance()
                }]);
            var data = cloneArray(sorted);
            var inserts = 0;
            var currentHeader = null;
            for (var i = 0; i < sorted.length; i++) {
                var insertFlag = 0;
                if (currentHeader !== sorted[i][groupKey]) {
                    currentHeader = sorted[i][groupKey];
                    insertFlag = 1;
                }
                if (insertFlag) {
                    data.splice(i + inserts, 0, (_a = {},
                        _a[valueKey] = currentHeader,
                        _a[groupKey] = currentHeader,
                        _a.isHeader = true,
                        _a));
                    inserts++;
                }
            }
            return data;
        };
        return IgxComboGroupingPipe;
    }());
    IgxComboGroupingPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'comboGrouping'
                },] }
    ];
    IgxComboGroupingPipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_COMBO_COMPONENT,] }] }
    ]; };

    /**
     * @hidden
     */
    var DataTypes;
    (function (DataTypes) {
        DataTypes["EMPTY"] = "empty";
        DataTypes["PRIMITIVE"] = "primitive";
        DataTypes["COMPLEX"] = "complex";
        DataTypes["PRIMARYKEY"] = "valueKey";
    })(DataTypes || (DataTypes = {}));
    /**
     * @hidden
     */
    var ItemHeights = {
        comfortable: 40,
        cosy: 32,
        compact: 28,
    };
    /**
     * @hidden
     * The default number of items that should be in the combo's
     * drop-down list if no `[itemsMaxHeight]` is specified
     */
    var itemsInContainer = 10;
    (function (IgxComboState) {
        /**
         * Combo with initial state.
         */
        IgxComboState[IgxComboState["INITIAL"] = 0] = "INITIAL";
        /**
         * Combo with valid state.
         */
        IgxComboState[IgxComboState["VALID"] = 1] = "VALID";
        /**
         * Combo with invalid state.
         */
        IgxComboState[IgxComboState["INVALID"] = 2] = "INVALID";
    })(exports.IgxComboState || (exports.IgxComboState = {}));
    /**
     * When called with sets A & B, returns A - B (as array);
     *
     * @hidden
     */
    var diffInSets = function (set1, set2) {
        var results = [];
        set1.forEach(function (entry) {
            if (!set2.has(entry)) {
                results.push(entry);
            }
        });
        return results;
    };
    var ɵ0$3 = diffInSets;
    var NEXT_ID$g = 0;
    var IgxComboComponent = /** @class */ (function (_super) {
        __extends(IgxComboComponent, _super);
        function IgxComboComponent(elementRef, cdr, selection, comboAPI, _iconService, _displayDensityOptions, _inputGroupType, _injector) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            _this.selection = selection;
            _this.comboAPI = comboAPI;
            _this._iconService = _iconService;
            _this._displayDensityOptions = _displayDensityOptions;
            _this._inputGroupType = _inputGroupType;
            _this._injector = _injector;
            /**
             * Set custom overlay settings that control how the combo's list of items is displayed.
             * Set:
             * ```html
             * <igx-combo [overlaySettings] = "customOverlaySettings"></igx-combo>
             * ```
             *
             * ```typescript
             *  const customSettings = { positionStrategy: { settings: { target: myTarget } } };
             *  combo.overlaySettings = customSettings;
             * ```
             * Get any custom overlay settings used by the combo:
             * ```typescript
             *  const comboOverlaySettings: OverlaySettings = myCombo.overlaySettings;
             * ```
             */
            _this.overlaySettings = null;
            /**
             * @hidden @internal
             */
            _this.searchInput = null;
            /**
             * The custom template, if any, that should be used when rendering ITEMS in the combo list
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.itemTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboItem>
             *          <div class="custom-item" let-item let-key="valueKey">
             *              <div class="custom-item__name">{{ item[key] }}</div>
             *              <div class="custom-item__cost">{{ item.cost }}</div>
             *          </div>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.itemTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the HEADER for the combo items list
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.headerTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboHeader>
             *          <div class="combo__header">
             *              This is a custom header
             *          </div>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.headerTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the FOOTER for the combo items list
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.footerTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboFooter>
             *          <div class="combo__footer">
             *              This is a custom footer
             *          </div>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.footerTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering HEADER ITEMS for groups in the combo list
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.headerItemTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboHeaderItem let-item let-key="groupKey">
             *          <div class="custom-item--group">Group header for {{ item[key] }}</div>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.headerItemTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.addItemTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboAddItem>
             *          <button class="combo__add-button">
             *              Click to add item
             *          </button>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.addItemTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.emptyTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboEmpty>
             *          <div class="combo--empty">
             *              There are no items to display
             *          </div>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.emptyTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the combo TOGGLE(open/close) button
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.toggleIconTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboToggleIcon let-collapsed>
             *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.toggleIconTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the combo CLEAR button
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.clearIconTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboClearIcon>
             *          <igx-icon>clear</igx-icon>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.clearIconTemplate = null;
            /**
             * Emitted when item selection is changing, before the selection completes
             *
             * ```html
             * <igx-combo (onSelectionChange)='handleSelection()'></igx-combo>
             * ```
             */
            _this.onSelectionChange = new i0.EventEmitter();
            /**
             * Emitted before the dropdown is opened
             *
             * ```html
             * <igx-combo onOpening='handleOpening($event)'></igx-combo>
             * ```
             */
            _this.onOpening = new i0.EventEmitter();
            /**
             * Emitted after the dropdown is opened
             *
             * ```html
             * <igx-combo (onOpened)='handleOpened()'></igx-combo>
             * ```
             */
            _this.onOpened = new i0.EventEmitter();
            /**
             * Emitted before the dropdown is closed
             *
             * ```html
             * <igx-combo (onClosing)='handleClosing($event)'></igx-combo>
             * ```
             */
            _this.onClosing = new i0.EventEmitter();
            /**
             * Emitted after the dropdown is closed
             *
             * ```html
             * <igx-combo (onClosed)='handleClosed()'></igx-combo>
             * ```
             */
            _this.onClosed = new i0.EventEmitter();
            /**
             * Emitted when an item is being added to the data collection
             *
             * ```html
             * <igx-combo (onAddition)='handleAdditionEvent()'></igx-combo>
             * ```
             */
            _this.onAddition = new i0.EventEmitter();
            /**
             * Emitted when the value of the search input changes (e.g. typing, pasting, clear, etc.)
             *
             * ```html
             * <igx-combo (onSearchInput)='handleSearchInputEvent()'></igx-combo>
             * ```
             */
            _this.onSearchInput = new i0.EventEmitter();
            /**
             * Emitted when new chunk of data is loaded from the virtualization
             *
             * ```html
             * <igx-combo (onDataPreLoad)='handleDataPreloadEvent()'></igx-combo>
             * ```
             */
            _this.onDataPreLoad = new i0.EventEmitter();
            /**
             * Gets/gets combo id.
             *
             * ```typescript
             * // get
             * let id = this.combo.id;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [id]='combo1'></igx-combo>
             * ```
             */
            _this.id = "igx-combo-" + NEXT_ID$g++;
            /**
             * @hidden @internal
             */
            _this.cssClass = 'igx-combo'; // Independent of display density, at the time being
            /**
             * @hidden @internal
             */
            _this.role = 'combobox';
            /**
             * Controls whether custom values can be added to the collection
             *
             * ```typescript
             * // get
             * let comboAllowsCustomValues = this.combo.allowCustomValues;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [allowCustomValues]='true'></igx-combo>
             * ```
             */
            _this.allowCustomValues = false;
            /**
             * Defines the placeholder value for the combo dropdown search field
             *
             * ```typescript
             * // get
             * let myComboSearchPlaceholder = this.combo.searchPlaceholder;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [searchPlaceholder]='newPlaceHolder'></igx-combo>
             * ```
             */
            _this.searchPlaceholder = 'Enter a Search Term';
            /**
             * Defines whether the caseSensitive icon should be shown in the search input
             *
             * ```typescript
             * // get
             * let myComboShowSearchCaseIcon = this.combo.showSearchCaseIcon;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [showSearchCaseIcon]='true'></igx-combo>
             * ```
             */
            _this.showSearchCaseIcon = false;
            /**
             * Combo value data source property.
             *
             * ```typescript
             * // get
             * let myComboValueKey = this.combo.valueKey;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [valueKey]='myKey'></igx-combo>
             * ```
             */
            _this.valueKey = null;
            /**
             * An @Input property that enabled/disables filtering in the list. The default is `true`.
             * ```html
             * <igx-combo [filterable]="false">
             * ```
             */
            _this.filterable = true;
            /**
             * An @Input property that enabled/disables combo. The default is `false`.
             * ```html
             * <igx-combo [disabled]="'true'">
             * ```
             */
            _this.disabled = false;
            /**
             * An @Input property that controls whether the combo's search box
             * should be focused after the `onOpened` event is called
             * When `false`, the combo's list item container will be focused instead
             */
            _this.autoFocusSearch = true;
            _this.dropdownContainer = null;
            /**
             * @hidden @internal
             */
            _this.customValueFlag = true;
            /**
             * @hidden @internal
             */
            _this.defaultFallbackGroup = 'Other';
            /**
             * @hidden @internal
             */
            _this.filteringOptions = {
                caseSensitive: false
            };
            /**
             * @hidden @internal
             */
            _this.filteringLogic = exports.FilteringLogic.Or;
            /** @hidden @internal */
            _this.filterValue = '';
            _this.stringFilters = IgxStringFilteringOperand;
            _this.booleanFilters = IgxBooleanFilteringOperand;
            _this._groupKey = '';
            _this._prevInputValue = '';
            _this._dataType = '';
            _this._searchValue = '';
            _this._type = null;
            _this.ngControl = null;
            _this.destroy$ = new rxjs.Subject();
            _this._data = [];
            _this._filteredData = [];
            _this._itemHeight = null;
            _this._itemsMaxHeight = null;
            _this._remoteSelection = {};
            _this._onChangeCallback = rxjs.noop;
            _this._onTouchedCallback = rxjs.noop;
            _this._value = '';
            _this._valid = exports.IgxComboState.INITIAL;
            _this.onStatusChanged = function () {
                if ((_this.ngControl.control.touched || _this.ngControl.control.dirty) &&
                    (_this.ngControl.control.validator || _this.ngControl.control.asyncValidator)) {
                    if (!_this.collapsed || _this.inputGroup.isFocused) {
                        _this.valid = _this.ngControl.invalid ? exports.IgxComboState.INVALID : exports.IgxComboState.VALID;
                    }
                    else {
                        _this.valid = _this.ngControl.invalid ? exports.IgxComboState.INVALID : exports.IgxComboState.INITIAL;
                    }
                }
                _this.manageRequiredAsterisk();
            };
            _this.comboAPI.register(_this);
            return _this;
        }
        Object.defineProperty(IgxComboComponent.prototype, "displaySearchInput", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.filterable || this.allowCustomValues;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "ariaExpanded", {
            /**
             * @hidden @internal
             */
            get: function () {
                return !this.dropdown.collapsed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "hasPopUp", {
            /**
             * @hidden @internal
             */
            get: function () {
                return 'listbox';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "ariaOwns", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.dropdown.id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "itemsMaxHeight", {
            /**
             * Configures the drop down list height
             *
             * ```typescript
             * // get
             * let myComboItemsMaxHeight = this.combo.itemsMaxHeight;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [itemsMaxHeight]='320'></igx-combo>
             * ```
             */
            get: function () {
                if (this._itemsMaxHeight === null || this._itemsMaxHeight === undefined) {
                    return this.itemHeight * itemsInContainer;
                }
                return this._itemsMaxHeight;
            },
            set: function (val) {
                this._itemsMaxHeight = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "itemHeight", {
            /**
             * Configures the drop down list item height
             *
             * ```typescript
             * // get
             * let myComboItemHeight = this.combo.itemHeight;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [itemHeight]='32'></igx-combo>
             * ```
             */
            get: function () {
                if (this._itemHeight === null || this._itemHeight === undefined) {
                    return ItemHeights[this.displayDensity];
                }
                return this._itemHeight;
            },
            set: function (val) {
                this._itemHeight = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "inputEmpty", {
            /**
             * @hidden @internal
             */
            get: function () {
                return !this.value && !this.placeholder;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "data", {
            /**
             * Combo data source.
             *
             * ```html
             * <!--set-->
             * <igx-combo [data]='items'></igx-combo>
             * ```
             */
            get: function () {
                return this._data;
            },
            set: function (val) {
                this._data = (val) ? val : [];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "displayKey", {
            /**
             * Combo text data source property.
             *
             * ```typescript
             * // get
             * let myComboDisplayKey = this.combo.displayKey;
             *
             * // set
             * this.combo.displayKey = 'val';
             *
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [displayKey]='myDisplayKey'></igx-combo>
             * ```
             */
            get: function () {
                return this._displayKey ? this._displayKey : this.valueKey;
            },
            set: function (val) {
                this._displayKey = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "groupKey", {
            /**
             * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
             *
             * ```typescript
             * // get
             * let currentGroupKey = this.combo.groupKey;
             * ```
             */
            get: function () {
                return this._groupKey;
            },
            /**
             * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
             *
             * ```html
             * <!--set-->
             * <igx-combo [groupKey]='newGroupKey'></igx-combo>
             * ```
             */
            set: function (val) {
                this._groupKey = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "type", {
            /**
             * An @Input property that sets how the combo will be styled.
             * The allowed values are `line`, `box`, `border` and `search`. The default is `box`.
             * ```html
             * <igx-combo [type]="'line'">
             * ```
             */
            get: function () {
                return this._type || this._inputGroupType || 'box';
            },
            set: function (val) {
                this._type = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "valid", {
            /**
             * Gets if control is valid, when used in a form
             *
             * ```typescript
             * // get
             * let valid = this.combo.valid;
             * ```
             */
            get: function () {
                return this._valid;
            },
            /**
             * Sets if control is valid, when used in a form
             *
             * ```typescript
             * // set
             * this.combo.valid = IgxComboState.INVALID;
             * ```
             */
            set: function (valid) {
                this._valid = valid;
                this.comboInput.valid = exports.IgxInputState[exports.IgxComboState[valid]];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "searchValue", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._searchValue;
            },
            set: function (val) {
                this.filterValue = val;
                this._searchValue = val;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.onArrowDown = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.open();
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.onInputClick = function (event) {
            event.stopPropagation();
            event.preventDefault();
            if (!this.disabled) {
                this.toggle();
            }
        };
        Object.defineProperty(IgxComboComponent.prototype, "virtualizationState", {
            /**
             * Defines the current state of the virtualized data. It contains `startIndex` and `chunkSize`
             *
             * ```typescript
             * // get
             * let state = this.combo.virtualizationState;
             * ```
             */
            get: function () {
                return this.virtDir.state;
            },
            /**
             * Sets the current state of the virtualized data.
             *
             * ```typescript
             * // set
             * this.combo.virtualizationState(state);
             * ```
             */
            set: function (state) {
                this.virtDir.state = state;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "totalItemCount", {
            /**
             * Gets total count of the virtual data items, when using remote service.
             *
             * ```typescript
             * // get
             * let count = this.combo.totalItemCount;
             * ```
             */
            get: function () {
                return this.virtDir.totalItemCount;
            },
            /**
             * Sets total count of the virtual data items, when using remote service.
             *
             * ```typescript
             * // set
             * this.combo.totalItemCount(remoteService.count);
             * ```
             */
            set: function (count) {
                this.virtDir.totalItemCount = count;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "value", {
            /**
             * The text displayed in the combo input
             *
             * ```typescript
             * // get
             * let comboValue = this.combo.value;
             * ```
             */
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "filteredData", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.filterable ? this._filteredData : this.data;
            },
            /**
             * @hidden @internal
             */
            set: function (val) {
                this._filteredData = this.groupKey ? (val || []).filter(function (e) { return e.isHeader !== true; }) : val;
                this.checkMatch();
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleKeyUp = function (event) {
            if (event.key === 'ArrowDown' || event.key === 'Down') {
                this.dropdown.focusedItem = this.dropdown.items[0];
                this.dropdownContainer.nativeElement.focus();
            }
            else if (event.key === 'Escape' || event.key === 'Esc') {
                this.toggle();
            }
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleKeyDown = function (event) {
            if (event.key === 'ArrowUp' || event.key === 'Up') {
                event.preventDefault();
                event.stopPropagation();
                this.close();
            }
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleInputChange = function (event) {
            if (event !== undefined) {
                var args = {
                    searchText: event,
                    owner: this,
                    cancel: false
                };
                this.onSearchInput.emit(args);
                if (args.cancel) {
                    this.filterValue = null;
                }
            }
            this.checkMatch();
        };
        Object.defineProperty(IgxComboComponent.prototype, "dataType", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this.displayKey) {
                    return DataTypes.COMPLEX;
                }
                return DataTypes.PRIMITIVE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "isRemote", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.totalItemCount > 0 &&
                    this.valueKey &&
                    this.dataType === DataTypes.COMPLEX;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns if the specified itemID is selected
         *
         * @hidden
         * @internal
         */
        IgxComboComponent.prototype.isItemSelected = function (item) {
            return this.selection.is_item_selected(this.id, item);
        };
        /**
         * Triggers change detection on the combo view
         */
        IgxComboComponent.prototype.triggerCheck = function () {
            this.cdr.detectChanges();
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.isAddButtonVisible = function () {
            // This should always return a boolean value. If this.searchValue was '', it returns '' instead of false;
            return this.searchValue !== '' && this.customValueFlag;
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleSelectAll = function (evt) {
            if (evt.checked) {
                this.selectAllItems();
            }
            else {
                this.deselectAllItems();
            }
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.addItemToCollection = function () {
            var _a, _b;
            if (!this.searchValue) {
                return;
            }
            var newValue = this.searchValue.trim();
            var addedItem = this.displayKey ? (_a = {},
                _a[this.valueKey] = newValue,
                _a[this.displayKey] = newValue,
                _a) : newValue;
            if (this.groupKey) {
                Object.assign(addedItem, (_b = {}, _b[this.groupKey] = this.defaultFallbackGroup, _b));
            }
            var oldCollection = this.data;
            var newCollection = __spread(this.data);
            newCollection.push(addedItem);
            var args = {
                oldCollection: oldCollection, addedItem: addedItem, newCollection: newCollection,
                owner: this
            };
            this.onAddition.emit(args);
            this.data.push(addedItem);
            // If you mutate the array, no pipe is invoked and the display isn't updated;
            // if you replace the array, the pipe executes and the display is updated.
            this.data = cloneArray(this.data);
            this.selectItems(this.comboAPI.valueKey !== null ? [addedItem[this.valueKey]] : [addedItem], false);
            this.customValueFlag = false;
            this.searchInput.nativeElement.focus();
            this.dropdown.focusedItem = null;
            this.virtDir.scrollTo(0);
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.focusSearchInput = function (opening) {
            if (this.displaySearchInput && this.searchInput) {
                this.searchInput.nativeElement.focus();
            }
            else {
                if (opening) {
                    this.dropdownContainer.nativeElement.focus();
                }
                else {
                    this.comboInput.nativeElement.focus();
                    this.toggle();
                }
            }
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.onBlur = function () {
            if (this.collapsed) {
                this._onTouchedCallback();
                if (this.ngControl && this.ngControl.invalid) {
                    this.valid = exports.IgxComboState.INVALID;
                }
                else {
                    this.valid = exports.IgxComboState.INITIAL;
                }
            }
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.ngOnInit = function () {
            this.ngControl = this._injector.get(forms.NgControl, null);
            var targetElement = this.elementRef.nativeElement;
            this._overlaySettings = {
                target: targetElement,
                scrollStrategy: new AbsoluteScrollStrategy(),
                positionStrategy: new AutoPositionStrategy(),
                modal: false,
                closeOnOutsideClick: true,
                excludeFromOutsideClick: [targetElement]
            };
            this.selection.set(this.id, new Set());
            this._iconService.addSvgIconFromText(materialIconsExtended.caseSensitive.name, materialIconsExtended.caseSensitive.value, 'imx-icons');
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.filteredData = __spread(this.data);
            if (this.ngControl) {
                this.ngControl.statusChanges.pipe(operators.takeUntil(this.destroy$)).subscribe(this.onStatusChanged);
                this.manageRequiredAsterisk();
                this.cdr.detectChanges();
            }
            this.virtDir.onChunkPreload.pipe(operators.takeUntil(this.destroy$)).subscribe(function (e) {
                var eventArgs = Object.assign({}, e, { owner: _this });
                _this.onDataPreLoad.emit(eventArgs);
            });
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next();
            this.destroy$.complete();
            this.comboAPI.clear();
            this.selection.clear(this.id);
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.writeValue = function (value) {
            var selection = Array.isArray(value) ? value : [];
            var oldSelection = this.selectedItems();
            this.selection.select_items(this.id, selection, true);
            this._value = this.createDisplayText(this.selectedItems(), oldSelection);
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        /**
         * @hidden
         */
        IgxComboComponent.prototype.getEditElement = function () {
            return this.comboInput.nativeElement;
        };
        Object.defineProperty(IgxComboComponent.prototype, "template", {
            /**
             * @hidden @internal
             */
            get: function () {
                this._dataType = this.dataType;
                if (this.itemTemplate) {
                    return this.itemTemplate;
                }
                if (this._dataType === DataTypes.COMPLEX) {
                    return this.complexTemplate;
                }
                return this.primitiveTemplate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "context", {
            /**
             * @hidden @internal
             */
            get: function () {
                return {
                    $implicit: this
                };
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleClearItems = function (event) {
            if (this.disabled) {
                return;
            }
            this.deselectAllItems(true, event);
            if (this.collapsed) {
                this.getEditElement().focus();
            }
            else {
                this.focusSearchInput(true);
            }
            event.stopPropagation();
        };
        /**
         * A method that opens/closes the combo.
         *
         * ```html
         * <button (click)="combo.toggle()">Toggle Combo</button>
         * <igx-combo #combo></igx-combo>
         * ```
         */
        IgxComboComponent.prototype.toggle = function () {
            var overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
            this.dropdown.toggle(overlaySettings);
        };
        /**
         * A method that opens the combo.
         *
         * ```html
         * <button (click)="combo.open()">Open Combo</button>
         * <igx-combo #combo></igx-combo>
         * ```
         */
        IgxComboComponent.prototype.open = function () {
            var overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
            this.dropdown.open(overlaySettings);
        };
        /**
         * A method that closes the combo.
         *
         * ```html
         * <button (click)="combo.close()">Close Combo</button>
         * <igx-combo #combo></igx-combo>
         * ```
         */
        IgxComboComponent.prototype.close = function () {
            this.dropdown.close();
        };
        Object.defineProperty(IgxComboComponent.prototype, "collapsed", {
            /**
             * Gets drop down state.
             *
             * ```typescript
             * let state = this.combo.collapsed;
             * ```
             */
            get: function () {
                return this.dropdown.collapsed;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Get current selection state
         *
         * @returns Array of selected items
         * ```typescript
         * let selectedItems = this.combo.selectedItems();
         * ```
         */
        IgxComboComponent.prototype.selectedItems = function () {
            var items = Array.from(this.selection.get(this.id));
            return items;
        };
        /**
         * Select defined items
         *
         * @param newItems new items to be selected
         * @param clearCurrentSelection if true clear previous selected items
         * ```typescript
         * this.combo.selectItems(["New York", "New Jersey"]);
         * ```
         */
        IgxComboComponent.prototype.selectItems = function (newItems, clearCurrentSelection, event) {
            if (newItems) {
                var newSelection = this.selection.add_items(this.id, newItems, clearCurrentSelection);
                this.setSelection(newSelection, event);
            }
        };
        /**
         * Deselect defined items
         *
         * @param items items to deselected
         * ```typescript
         * this.combo.deselectItems(["New York", "New Jersey"]);
         * ```
         */
        IgxComboComponent.prototype.deselectItems = function (items, event) {
            if (items) {
                var newSelection = this.selection.delete_items(this.id, items);
                this.setSelection(newSelection, event);
            }
        };
        /**
         * Select all (filtered) items
         *
         * @param ignoreFilter if set to true, selects all items, otherwise selects only the filtered ones.
         * ```typescript
         * this.combo.selectAllItems();
         * ```
         */
        IgxComboComponent.prototype.selectAllItems = function (ignoreFilter, event) {
            var allVisible = this.selection.get_all_ids(ignoreFilter ? this.data : this.filteredData, this.valueKey);
            var newSelection = this.selection.add_items(this.id, allVisible);
            this.setSelection(newSelection, event);
        };
        /**
         * Deselect all (filtered) items
         *
         * @param ignoreFilter if set to true, deselects all items, otherwise deselects only the filtered ones.
         * ```typescript
         * this.combo.deselectAllItems();
         * ```
         */
        IgxComboComponent.prototype.deselectAllItems = function (ignoreFilter, event) {
            var newSelection = this.selection.get_empty();
            if (this.filteredData.length !== this.data.length && !ignoreFilter) {
                newSelection = this.selection.delete_items(this.id, this.selection.get_all_ids(this.filteredData, this.valueKey));
            }
            this.setSelection(newSelection, event);
        };
        /**
         * Selects/Deselects a single item
         *
         * @param itemID the itemID of the specific item
         * @param select If the item should be selected (true) or deselected (false)
         *
         * Without specified valueKey;
         * ```typescript
         * this.combo.valueKey = null;
         * const items: { field: string, region: string}[] = data;
         * this.combo.setSelectedItem(items[0], true);
         * ```
         * With specified valueKey;
         * ```typescript
         * this.combo.valueKey = 'field';
         * const items: { field: string, region: string}[] = data;
         * this.combo.setSelectedItem('Connecticut', true);
         * ```
         */
        IgxComboComponent.prototype.setSelectedItem = function (itemID, select, event) {
            if (select === void 0) { select = true; }
            if (itemID === null || itemID === undefined) {
                return;
            }
            if (select) {
                this.selectItems([itemID], false, event);
            }
            else {
                this.deselectItems([itemID], event);
            }
        };
        /**
         * Event handlers
         *
         * @hidden
         * @internal
         */
        IgxComboComponent.prototype.handleOpening = function (event) {
            var eventArgs = Object.assign({}, event, { owner: this });
            this.onOpening.emit(eventArgs);
            event.cancel = eventArgs.cancel;
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleOpened = function () {
            this.triggerCheck();
            // Disabling focus of the search input should happen only when drop down opens.
            // During keyboard navigation input should receive focus, even the autoFocusSearch is disabled.
            // That is why in such cases focusing of the dropdownContainer happens outside focusSearchInput method.
            if (this.autoFocusSearch) {
                this.focusSearchInput(true);
            }
            else {
                this.dropdownContainer.nativeElement.focus();
            }
            this.onOpened.emit();
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleClosing = function (event) {
            var eventArgs = Object.assign({}, event, { owner: this });
            this.onClosing.emit(eventArgs);
            event.cancel = eventArgs.cancel;
            if (event.cancel) {
                return;
            }
            this.searchValue = '';
            this.comboInput.nativeElement.focus();
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleClosed = function () {
            this.onClosed.emit();
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.toggleCaseSensitive = function () {
            this.filteringOptions = { caseSensitive: !this.filteringOptions.caseSensitive };
        };
        IgxComboComponent.prototype.setSelection = function (newSelection, event) {
            var removed = diffInSets(this.selection.get(this.id), newSelection);
            var added = diffInSets(newSelection, this.selection.get(this.id));
            var newSelectionAsArray = Array.from(newSelection);
            var oldSelectionAsArray = Array.from(this.selection.get(this.id) || []);
            var displayText = this.createDisplayText(newSelectionAsArray, oldSelectionAsArray);
            var args = {
                newSelection: newSelectionAsArray,
                oldSelection: oldSelectionAsArray,
                added: added,
                removed: removed,
                event: event,
                owner: this,
                displayText: displayText,
                cancel: false
            };
            this.onSelectionChange.emit(args);
            if (!args.cancel) {
                this.selection.select_items(this.id, args.newSelection, true);
                if (displayText !== args.displayText) {
                    this._value = args.displayText;
                }
                else {
                    this._value = this.createDisplayText(args.newSelection, args.oldSelection);
                }
                this._onChangeCallback(args.newSelection);
            }
        };
        IgxComboComponent.prototype.manageRequiredAsterisk = function () {
            if (this.ngControl && this.ngControl.control.validator) {
                // Run the validation with empty object to check if required is enabled.
                var error = this.ngControl.control.validator({});
                this.inputGroup.isRequired = error && error.required;
            }
        };
        /** Contains key-value pairs of the selected valueKeys and their resp. displayKeys */
        IgxComboComponent.prototype.registerRemoteEntries = function (ids, add) {
            var e_1, _a, e_2, _b;
            if (add === void 0) { add = true; }
            if (add) {
                var selection = this.getValueDisplayPairs(ids);
                try {
                    for (var selection_1 = __values(selection), selection_1_1 = selection_1.next(); !selection_1_1.done; selection_1_1 = selection_1.next()) {
                        var entry = selection_1_1.value;
                        this._remoteSelection[entry[this.valueKey]] = entry[this.displayKey];
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (selection_1_1 && !selection_1_1.done && (_a = selection_1.return)) _a.call(selection_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else {
                try {
                    for (var ids_1 = __values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
                        var entry = ids_1_1.value;
                        delete this._remoteSelection[entry];
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (ids_1_1 && !ids_1_1.done && (_b = ids_1.return)) _b.call(ids_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        };
        /**
         * For `id: any[]` returns a mapped `{ [combo.valueKey]: any, [combo.displayKey]: any }[]`
         */
        IgxComboComponent.prototype.getValueDisplayPairs = function (ids) {
            var _this = this;
            return this.data.filter(function (entry) { return ids.indexOf(entry[_this.valueKey]) > -1; }).map(function (e) {
                var _a;
                return (_a = {},
                    _a[_this.valueKey] = e[_this.valueKey],
                    _a[_this.displayKey] = e[_this.displayKey],
                    _a);
            });
        };
        IgxComboComponent.prototype.checkMatch = function () {
            var _this = this;
            var displayKey = this.displayKey;
            var matchFn = function (e) {
                var value = displayKey ? e[displayKey] : e;
                return value.toString().toLowerCase() === _this.searchValue.trim().toLowerCase();
            };
            var itemMatch = this.filteredData.some(matchFn);
            this.customValueFlag = this.allowCustomValues && !itemMatch;
        };
        /** Returns a string that should be populated in the combo's text box */
        IgxComboComponent.prototype.concatDisplayText = function (selection) {
            var _this = this;
            var value = this.displayKey !== null && this.displayKey !== undefined ?
                this.convertKeysToItems(selection).map(function (entry) { return entry[_this.displayKey]; }).join(', ') :
                selection.join(', ');
            return value;
        };
        /**
         * Constructs the combo display value
         * If remote, caches the key displayText
         * If not, just combine the object.displayKeys
         */
        IgxComboComponent.prototype.createDisplayText = function (newSelection, oldSelection) {
            var _this = this;
            var value = '';
            if (this.isRemote) {
                if (newSelection.length) {
                    var removedItems = oldSelection.filter(function (e) { return newSelection.indexOf(e) < 0; });
                    var addedItems = newSelection.filter(function (e) { return oldSelection.indexOf(e) < 0; });
                    this.registerRemoteEntries(addedItems);
                    this.registerRemoteEntries(removedItems, false);
                    value = Object.keys(this._remoteSelection).map(function (e) { return _this._remoteSelection[e]; }).join(', ');
                }
                else {
                    // If new selection is empty, clear all items
                    this.registerRemoteEntries(oldSelection, false);
                }
            }
            else {
                value = this.concatDisplayText(newSelection);
            }
            return value;
        };
        /** if there is a valueKey - map the keys to data items, else - just return the keys */
        IgxComboComponent.prototype.convertKeysToItems = function (keys) {
            var _this = this;
            if (this.comboAPI.valueKey === null) {
                return keys;
            }
            // map keys vs. filter data to retain the order of the selected items
            return keys.map(function (key) { return _this.data.find(function (entry) { return entry[_this.valueKey] === key; }); }).filter(function (e) { return e !== undefined; });
        };
        return IgxComboComponent;
    }(DisplayDensityBase));
    IgxComboComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-combo',
                    template: "<igx-input-group #inputGroup [displayDensity]=\"displayDensity\" [type]=\"type\" (click)=\"onInputClick($event)\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-hint, [igxHint]\">\n        <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n    </ng-container>\n    <input igxInput #comboInput name=\"comboInput\" type=\"text\" [value]=\"value\" readonly [attr.placeholder]=\"placeholder\"\n        [disabled]=\"disabled\" (blur)=\"onBlur()\" />\n    <ng-container ngProjectAs=\"igx-suffix\">\n        <ng-content select=\"igx-suffix\"></ng-content>\n    </ng-container>\n    <igx-suffix *ngIf=\"value.length\" aria-label=\"Clear Selection\" class=\"igx-combo__clear-button\"\n        (click)=\"handleClearItems($event)\">\n        <ng-container *ngIf=\"clearIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"clearIconTemplate\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!clearIconTemplate\">\n            clear\n        </igx-icon>\n    </igx-suffix>\n    <igx-suffix class=\"igx-combo__toggle-button\">\n        <ng-container *ngIf=\"toggleIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!toggleIconTemplate\">\n            {{ dropdown.collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}\n        </igx-icon>\n    </igx-suffix>\n</igx-input-group>\n<igx-combo-drop-down #igxComboDropDown class=\"igx-combo__drop-down\" [displayDensity]=\"displayDensity\"\n    [width]=\"itemsWidth || '100%'\" (onOpening)=\"handleOpening($event)\" (onClosing)=\"handleClosing($event)\"\n    (onOpened)=\"handleOpened()\" (onClosed)=\"handleClosed()\">\n    <igx-input-group *ngIf=\"displaySearchInput\" [displayDensity]=\"displayDensity\" class=\"igx-combo__search\">\n        <input class=\"igx-combo-input\" igxInput #searchInput name=\"searchInput\" autocomplete=\"off\" type=\"text\"\n            [(ngModel)]=\"searchValue\" (ngModelChange)=\"handleInputChange($event)\" (keyup)=\"handleKeyUp($event)\"\n            (keydown)=\"handleKeyDown($event)\" (focus)=\"dropdown.onBlur($event)\" [attr.placeholder]=\"searchPlaceholder\"\n            aria-autocomplete=\"both\" [attr.aria-owns]=\"dropdown.id\" [attr.aria-labelledby]=\"ariaLabelledBy\" />\n        <igx-suffix *ngIf=\"showSearchCaseIcon\">\n            <igx-icon family=\"imx-icons\" name=\"case-sensitive\" [active]=\"filteringOptions.caseSensitive\"\n                (click)=\"toggleCaseSensitive()\">\n            </igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n    <ng-container *ngTemplateOutlet=\"headerTemplate\">\n    </ng-container>\n    <div #dropdownItemContainer class=\"igx-combo__content\" [style.overflow]=\"'hidden'\"\n        [style.maxHeight.px]=\"itemsMaxHeight\" [igxDropDownItemNavigation]=\"dropdown\" (focus)=\"dropdown.onFocus()\"\n        [tabindex]=\"dropdown.collapsed ? -1 : 0\" role=\"listbox\" [attr.id]=\"dropdown.id\">\n        <igx-combo-item role=\"option\" [itemHeight]='itemHeight' *igxFor=\"let item of data\n            | comboFiltering:filterValue:displayKey:filterable:filteringOptions\n            | comboGrouping:groupKey:valueKey;\n            index as rowIndex; containerSize: itemsMaxHeight; scrollOrientation: 'vertical'; itemSize: itemHeight\"\n            [value]=\"item\" [isHeader]=\"item.isHeader\" [index]=\"rowIndex\">\n            <ng-container *ngIf=\"item.isHeader\">\n                <ng-container\n                    *ngTemplateOutlet=\"headerItemTemplate ? headerItemTemplate : headerItemBase;\n                    context: {$implicit: item, data: data, valueKey: valueKey, groupKey: groupKey, displayKey: displayKey}\">\n                </ng-container>\n            </ng-container>\n            <ng-container *ngIf=\"!item.isHeader\">\n                <ng-container #listItem\n                    *ngTemplateOutlet=\"template; context: {$implicit: item, data: data, valueKey: valueKey, displayKey: displayKey};\">\n                </ng-container>\n            </ng-container>\n        </igx-combo-item>\n    </div>\n    <div class=\"igx-combo__add\" *ngIf=\"filteredData.length === 0 || isAddButtonVisible()\">\n        <div class=\"igx-combo__empty\" *ngIf=\"filteredData.length === 0\">\n            <ng-container *ngTemplateOutlet=\"emptyTemplate ? emptyTemplate : empty\">\n            </ng-container>\n        </div>\n        <igx-combo-add-item [itemHeight]='itemHeight' *ngIf=\"isAddButtonVisible()\"\n            [tabindex]=\"dropdown.collapsed ? -1 : customValueFlag ? 1 : -1\" class=\"igx-combo__add-item\" role=\"button\"\n            aria-label=\"Add Item\" [index]=\"virtualScrollContainer.igxForOf.length\">\n            <ng-container *ngTemplateOutlet=\"addItemTemplate ? addItemTemplate : addItemDefault\">\n            </ng-container>\n        </igx-combo-add-item>\n    </div>\n    <ng-container *ngTemplateOutlet=\"footerTemplate\">\n    </ng-container>\n</igx-combo-drop-down>\n<ng-template #complex let-display let-data=\"data\" let-key=\"displayKey\">\n    {{display[key]}}\n</ng-template>\n<ng-template #primitive let-display>\n    {{display}}\n</ng-template>\n<ng-template #empty>\n    <span>The list is empty</span>\n</ng-template>\n<ng-template #addItemDefault let-control>\n    <button igxButton=\"flat\" igxRipple>Add item</button>\n</ng-template>\n<ng-template #headerItemBase let-item let-key=\"valueKey\" let-groupKey=\"groupKey\">\n    {{ item[key] }}\n</ng-template>\n",
                    providers: [
                        IgxComboAPIService,
                        { provide: IGX_COMBO_COMPONENT, useExisting: IgxComboComponent },
                        { provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxComboComponent, multi: true }
                    ]
                },] }
    ];
    IgxComboComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: IgxSelectionAPIService },
        { type: IgxComboAPIService },
        { type: IgxIconService },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [IGX_INPUT_GROUP_TYPE,] }] },
        { type: i0.Injector, decorators: [{ type: i0.Optional }] }
    ]; };
    IgxComboComponent.propDecorators = {
        overlaySettings: [{ type: i0.Input }],
        inputGroup: [{ type: i0.ViewChild, args: ['inputGroup', { read: IgxInputGroupComponent, static: true },] }],
        comboInput: [{ type: i0.ViewChild, args: ['comboInput', { read: IgxInputDirective, static: true },] }],
        dropdown: [{ type: i0.ViewChild, args: [IgxComboDropDownComponent, { read: IgxComboDropDownComponent, static: true },] }],
        searchInput: [{ type: i0.ViewChild, args: ['searchInput',] }],
        itemTemplate: [{ type: i0.ContentChild, args: [IgxComboItemDirective, { read: i0.TemplateRef },] }],
        headerTemplate: [{ type: i0.ContentChild, args: [IgxComboHeaderDirective, { read: i0.TemplateRef },] }],
        footerTemplate: [{ type: i0.ContentChild, args: [IgxComboFooterDirective, { read: i0.TemplateRef },] }],
        headerItemTemplate: [{ type: i0.ContentChild, args: [IgxComboHeaderItemDirective, { read: i0.TemplateRef },] }],
        addItemTemplate: [{ type: i0.ContentChild, args: [IgxComboAddItemDirective, { read: i0.TemplateRef },] }],
        emptyTemplate: [{ type: i0.ContentChild, args: [IgxComboEmptyDirective, { read: i0.TemplateRef },] }],
        toggleIconTemplate: [{ type: i0.ContentChild, args: [IgxComboToggleIconDirective, { read: i0.TemplateRef },] }],
        clearIconTemplate: [{ type: i0.ContentChild, args: [IgxComboClearIconDirective, { read: i0.TemplateRef },] }],
        virtualScrollContainer: [{ type: i0.ViewChild, args: [IgxForOfDirective, { static: true },] }],
        onSelectionChange: [{ type: i0.Output }],
        onOpening: [{ type: i0.Output }],
        onOpened: [{ type: i0.Output }],
        onClosing: [{ type: i0.Output }],
        onClosed: [{ type: i0.Output }],
        onAddition: [{ type: i0.Output }],
        onSearchInput: [{ type: i0.Output }],
        onDataPreLoad: [{ type: i0.Output }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        width: [{ type: i0.HostBinding, args: ['style.width',] }, { type: i0.Input }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-combo',] }],
        role: [{ type: i0.HostBinding, args: ["attr.role",] }],
        ariaExpanded: [{ type: i0.HostBinding, args: ['attr.aria-expanded',] }],
        hasPopUp: [{ type: i0.HostBinding, args: ['attr.aria-haspopup',] }],
        ariaOwns: [{ type: i0.HostBinding, args: ['attr.aria-owns',] }],
        allowCustomValues: [{ type: i0.Input }],
        itemsMaxHeight: [{ type: i0.Input }],
        itemsWidth: [{ type: i0.Input }],
        itemHeight: [{ type: i0.Input }],
        placeholder: [{ type: i0.Input }],
        searchPlaceholder: [{ type: i0.Input }],
        showSearchCaseIcon: [{ type: i0.Input }],
        data: [{ type: i0.Input }],
        valueKey: [{ type: i0.Input }],
        displayKey: [{ type: i0.Input }],
        groupKey: [{ type: i0.Input }],
        filterable: [{ type: i0.Input }],
        ariaLabelledBy: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.aria-labelledby',] }],
        disabled: [{ type: i0.Input }],
        type: [{ type: i0.Input }],
        autoFocusSearch: [{ type: i0.Input }],
        dropdownContainer: [{ type: i0.ViewChild, args: ['dropdownItemContainer', { static: true },] }],
        primitiveTemplate: [{ type: i0.ViewChild, args: ['primitive', { read: i0.TemplateRef, static: true },] }],
        complexTemplate: [{ type: i0.ViewChild, args: ['complex', { read: i0.TemplateRef, static: true },] }],
        virtDir: [{ type: i0.ViewChild, args: [IgxForOfDirective, { read: IgxForOfDirective, static: true },] }],
        onArrowDown: [{ type: i0.HostListener, args: ['keydown.ArrowDown', ['$event'],] }, { type: i0.HostListener, args: ['keydown.Alt.ArrowDown', ['$event'],] }]
    };
    /**
     * @hidden
     */
    var IgxComboModule = /** @class */ (function () {
        function IgxComboModule() {
        }
        return IgxComboModule;
    }());
    IgxComboModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxComboComponent, IgxComboItemComponent, IgxComboGroupingPipe,
                        IgxComboFilteringPipe, IgxComboDropDownComponent, IgxComboAddItemComponent,
                        IgxComboItemDirective,
                        IgxComboEmptyDirective,
                        IgxComboHeaderItemDirective,
                        IgxComboHeaderDirective,
                        IgxComboFooterDirective,
                        IgxComboAddItemDirective,
                        IgxComboToggleIconDirective,
                        IgxComboClearIconDirective],
                    exports: [IgxComboComponent, IgxComboItemComponent, IgxComboDropDownComponent, IgxComboAddItemComponent,
                        IgxComboItemDirective,
                        IgxComboEmptyDirective,
                        IgxComboHeaderItemDirective,
                        IgxComboHeaderDirective,
                        IgxComboFooterDirective,
                        IgxComboAddItemDirective,
                        IgxComboToggleIconDirective,
                        IgxComboClearIconDirective,
                        IgxInputGroupModule],
                    imports: [IgxRippleModule, i2.CommonModule, IgxInputGroupModule, forms.FormsModule, forms.ReactiveFormsModule,
                        IgxForOfModule, IgxToggleModule, IgxCheckboxModule, IgxDropDownModule, IgxButtonModule, IgxIconModule]
                },] }
    ];

    /** @hidden */
    var IGX_DATE_PICKER_COMPONENT = 'IgxDatePickerComponentToken';

    /**
     * @hidden
     */
    var DatePickerDisplayValuePipe = /** @class */ (function () {
        function DatePickerDisplayValuePipe(_datePicker) {
            this._datePicker = _datePicker;
        }
        DatePickerDisplayValuePipe.prototype.transform = function (value, args) {
            if (value !== '') {
                if (value === DatePickerUtil.maskToPromptChars(this._datePicker.inputMask)) {
                    return '';
                }
                this._datePicker.rawDateString = value;
                return DatePickerUtil.trimEmptyPlaceholders(value);
            }
            return '';
        };
        return DatePickerDisplayValuePipe;
    }());
    DatePickerDisplayValuePipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'displayValue'
                },] }
    ];
    DatePickerDisplayValuePipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
    ]; };
    /**
     * @hidden
     */
    var DatePickerInputValuePipe = /** @class */ (function () {
        function DatePickerInputValuePipe(_datePicker) {
            this._datePicker = _datePicker;
        }
        DatePickerInputValuePipe.prototype.transform = function (value, args) {
            /**
             * TODO(D.P.): This plugs into the mask, but constantly received display strings it can't handle at all
             * Those are almost immediately overridden by the pickers onFocus handling anyway; Refactor ASAP
             */
            if (this._datePicker.invalidDate !== '') {
                return this._datePicker.invalidDate;
            }
            else {
                if (this._datePicker.value === null || this._datePicker.value === undefined) {
                    return DatePickerUtil.maskToPromptChars(this._datePicker.inputMask);
                }
                else {
                    return this._datePicker._getEditorDate(this._datePicker.value);
                    // return DatePickerUtil.addPromptCharsEditMode(this._datePicker.dateFormatParts, this._datePicker.value, value);
                }
            }
        };
        return DatePickerInputValuePipe;
    }());
    DatePickerInputValuePipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'inputValue'
                },] }
    ];
    DatePickerInputValuePipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
    ]; };

    /**
     * IgxDatePickerTemplateDirective can be used to re-template the date-picker input-group.
     *
     * @hidden
     */
    var IgxDatePickerTemplateDirective = /** @class */ (function () {
        function IgxDatePickerTemplateDirective(template) {
            this.template = template;
        }
        return IgxDatePickerTemplateDirective;
    }());
    IgxDatePickerTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDatePickerTemplate]'
                },] }
    ];
    IgxDatePickerTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    /**
     * IgxDatePickerActionsDirective can be used to re-template the dropdown/dialog action buttons.
     */
    var IgxDatePickerActionsDirective = /** @class */ (function () {
        function IgxDatePickerActionsDirective(template) {
            this.template = template;
        }
        return IgxDatePickerActionsDirective;
    }());
    IgxDatePickerActionsDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDatePickerActions]'
                },] }
    ];
    IgxDatePickerActionsDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };

    /**
     * This enumeration is used to configure whether the date/time picker has an editable input with drop down
     * or is readonly - the date/time is selected only through a dialog.
     */
    var InteractionMode = mkenum({
        DropDown: 'dropdown',
        Dialog: 'dialog'
    });

    /**
     * @hidden
     */
    var IgxCalendarContainerComponent = /** @class */ (function () {
        function IgxCalendarContainerComponent() {
            this.mode = InteractionMode.Dialog;
            this.vertical = false;
            this.onClose = new i0.EventEmitter();
            this.onTodaySelection = new i0.EventEmitter();
            this.styleClass = 'igx-date-picker';
        }
        Object.defineProperty(IgxCalendarContainerComponent.prototype, "dropdownCSS", {
            get: function () {
                return this.mode === InteractionMode.DropDown;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCalendarContainerComponent.prototype, "verticalCSS", {
            get: function () {
                return this.vertical && this.mode === InteractionMode.Dialog;
            },
            enumerable: false,
            configurable: true
        });
        IgxCalendarContainerComponent.prototype.onEscape = function (event) {
            event.preventDefault();
            this.onClose.emit();
        };
        Object.defineProperty(IgxCalendarContainerComponent.prototype, "isReadonly", {
            /**
             * Returns whether the date-picker is in readonly dialog mode.
             *
             * @hidden
             */
            get: function () {
                return this.mode === InteractionMode.Dialog;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Emits close event for the calendar.
         */
        IgxCalendarContainerComponent.prototype.closeCalendar = function () {
            this.onClose.emit();
        };
        /**
         * Emits today selection event for the calendar.
         */
        IgxCalendarContainerComponent.prototype.triggerTodaySelection = function () {
            this.onTodaySelection.emit();
        };
        return IgxCalendarContainerComponent;
    }());
    IgxCalendarContainerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-calendar-container',
                    template: "<ng-template #defaultDatePickerActions>\n    <div *ngIf=\"cancelButtonLabel || todayButtonLabel\" class=\"igx-date-picker__buttons\">\n        <button #closeButton *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"closeCalendar()\">\n            {{ cancelButtonLabel }}\n        </button>\n        <button #todayButton *ngIf=\"todayButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"triggerTodaySelection()\">\n            {{ todayButtonLabel }}\n        </button>\n    </div>\n</ng-template>\n<igx-calendar #calendar></igx-calendar>\n<ng-container *ngTemplateOutlet=\"datePickerActions ? datePickerActions.template : defaultDatePickerActions\"></ng-container>\n",
                    styles: [':host {display: block;}']
                },] }
    ];
    IgxCalendarContainerComponent.propDecorators = {
        calendar: [{ type: i0.ViewChild, args: ['calendar', { static: true },] }],
        mode: [{ type: i0.Input }],
        vertical: [{ type: i0.Input }],
        cancelButtonLabel: [{ type: i0.Input }],
        todayButtonLabel: [{ type: i0.Input }],
        datePickerActions: [{ type: i0.Input }],
        onClose: [{ type: i0.Output }],
        onTodaySelection: [{ type: i0.Output }],
        styleClass: [{ type: i0.HostBinding, args: ['class.igx-date-picker',] }],
        dropdownCSS: [{ type: i0.HostBinding, args: ['class.igx-date-picker--dropdown',] }],
        verticalCSS: [{ type: i0.HostBinding, args: ['class.igx-date-picker--vertical',] }],
        onEscape: [{ type: i0.HostListener, args: ['keydown.esc', ['$event'],] }, { type: i0.HostListener, args: ['keydown.alt.arrowup', ['$event'],] }]
    };

    var NEXT_ID$h = 0;
    /**
     * This enumeration is used to configure the date picker to operate with pre-defined format option used in Angular DatePipe.
     * 'https://angular.io/api/common/DatePipe'
     * 'shortDate': equivalent to 'M/d/yy' (6/15/15).
     * 'mediumDate': equivalent to 'MMM d, y' (Jun 15, 2015).
     * 'longDate': equivalent to 'MMMM d, y' (June 15, 2015).
     * 'fullDate': equivalent to 'EEEE, MMMM d, y' (Monday, June 15, 2015).
     */
    var PredefinedFormatOptions = mkenum({
        ShortDate: 'shortDate',
        MediumDate: 'mediumDate',
        LongDate: 'longDate',
        FullDate: 'fullDate'
    });
    /**
     * Date Picker displays a popup calendar that lets users select a single date.
     *
     * @igxModule IgxDatePickerModule
     * @igxTheme igx-calendar-theme, igx-icon-theme
     * @igxGroup Scheduling
     * @igxKeywords  datepicker, calendar, schedule, date
     * @example
     * ```html
     * <igx-date-picker [(ngModel)]="selectedDate"></igx-date-picker>
     * ```
     */
    var IgxDatePickerComponent = /** @class */ (function () {
        function IgxDatePickerComponent(_overlayService, element, _cdr, _moduleRef, _injector, _renderer) {
            this._overlayService = _overlayService;
            this.element = element;
            this._cdr = _cdr;
            this._moduleRef = _moduleRef;
            this._injector = _injector;
            this._renderer = _renderer;
            /**
             * Gets/Sets the `IgxDatePickerComponent` label visibility.
             *
             * @remarks
             * By default the visibility is set to true.
             * @example
             * <igx-date-picker [labelVisibility]="false"></igx-date-picker>
             */
            this.labelVisibility = true;
            /**
             * Gets/Sets on which day the week starts.
             *
             * @example
             * ```html
             * <igx-date-picker [weekStart]="WEEKDAYS.FRIDAY" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
             * ```
             */
            this.weekStart = exports.WEEKDAYS.SUNDAY;
            /**
             * Gets/Sets the number of month views displayed.
             *
             * @remarks
             * Default value is `1`.
             * @example
             * ```html
             * <igx-date-picker [monthsViewNumber]="2"></igx-date-picker>
             * ```
             * @example
             * ```typescript
             * let monthViewsDisplayed = this.datePicker.monthsViewNumber;
             * ```
             */
            this.monthsViewNumber = 1;
            /**
             * Gets/Sets the value of `id` attribute.
             *
             * @remarks If not provided it will be automatically generated.
             * @example
             * ```html
             * <igx-date-picker [id]="'igx-date-picker-3'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
             * ```
             */
            this.id = "igx-date-picker-" + NEXT_ID$h++;
            /**
             * Gets/Sets the orientation of the `IgxDatePickerComponent` header.
             *
             *  @example
             * ```html
             * <igx-date-picker [vertical]="'true'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
             * ```
             */
            this.vertical = false;
            /**
             * Gets/Sets the interaction mode - dialog or drop down.
             *
             *  @example
             * ```html
             * <igx-date-picker mode="dropdown"></igx-date-picker>
             * ```
             */
            this.mode = InteractionMode.Dialog;
            /**
             * Gets/Sets whether date should spin continuously or stop when min/max is reached.
             *
             *  @example
             * ```html
             * <igx-date-picker [isSpinLoop]="false"></igx-date-picker>
             * ```
             */
            this.isSpinLoop = true;
            /**
             * Emitted when the `IgxDatePickerComponent` calendar is opened.
             */
            this.onOpened = new i0.EventEmitter();
            /**
             * Emitted after the `IgxDatePickerComponent` is closed.
             */
            this.onClosed = new i0.EventEmitter();
            /**
             * Emitted when the `IgxDatePickerComponent` is being closed.
             */
            this.onClosing = new i0.EventEmitter();
            /**
             * Emitted when selection is made in the calendar.
             *
             *  @example
             * ```html
             * <igx-date-picker (onSelection)="selection($event)"></igx-date-picker>
             * ```
             */
            this.onSelection = new i0.EventEmitter();
            /**
             * Emitted when date picker value is changed.
             *
             * @example
             * ```html
             * <igx-date-picker (valueChange)="valueChanged($event)" mode="dropdown"></igx-date-picker>
             * ```
             */
            this.valueChange = new i0.EventEmitter();
            /**
             * Emitted when the user types/spins to a disabled date in the date-picker editor.
             *
             *  @example
             * ```html
             * <igx-date-picker (onDisabledDate)="onDisabledDate($event)"></igx-date-picker>
             * ```
             */
            this.onDisabledDate = new i0.EventEmitter();
            /**
             * Emitted when the user types/spins invalid date in the date-picker editor.
             *
             *  @example
             * ```html
             * <igx-date-picker (onValidationFailed)="onValidationFailed($event)"></igx-date-picker>
             * ```
             */
            this.onValidationFailed = new i0.EventEmitter();
            /** @hidden @internal */
            this.hasHeader = true;
            /** @hidden @internal */
            this.collapsed = true;
            /** @hidden @internal */
            this.displayValuePipe = new DatePickerDisplayValuePipe(this);
            /** @hidden @internal */
            this.inputValuePipe = new DatePickerInputValuePipe(this);
            /** @hidden @internal */
            this.dateFormatParts = [];
            /** @hidden @internal */
            this.isEmpty = true;
            /** @hidden @internal */
            this.invalidDate = '';
            this.spinDelta = 1;
            this.defaultLocale = 'en';
            this._formatOptions = {
                day: 'numeric',
                month: 'short',
                weekday: 'short',
                year: 'numeric'
            };
            this._formatViews = {
                day: false,
                month: true,
                year: false
            };
            this._destroy$ = new rxjs.Subject();
            this._disabledDates = null;
            this._specialDates = null;
            this._onOpen = new i0.EventEmitter();
            this._onClose = new i0.EventEmitter();
            this._ngControl = null;
            this._label = 'Date';
            //#region ControlValueAccessor
            this._onChangeCallback = rxjs.noop;
            this._onTouchedCallback = rxjs.noop;
            this._onValidatorChange = rxjs.noop;
        }
        Object.defineProperty(IgxDatePickerComponent.prototype, "label", {
            /**
             * Gets/Sets the `IgxDatePickerComponent` label.
             *
             * @remarks
             * The default label is 'Date'.
             * @example
             * ```html
             * <igx-date-picker [label]="Calendar"></igx-date-picker>
             * ```
             * @deprecated Use igxLabel inside the date picker to change the label:
             * ````html
             * <igx-date-picker>
             *      <label igxLabel>Custom label</label>
             * </igx-date-picker>
             * ````
             * to set a custom label.
             */
            get: function () {
                return this._label;
            },
            set: function (v) {
                this._label = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "labelInternal", {
            get: function () {
                return this._label;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "labelTemplate", {
            /** @hidden @internal */
            get: function () {
                return this._labelDirectiveUserTemplate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "formatOptions", {
            /**
             * Gets the format options of the `IgxDatePickerComponent`.
             *
             * @example
             * ```typescript
             * let formatOptions = this.datePicker.formatOptions;
             * ```
             */
            get: function () {
                return this._formatOptions;
            },
            /**
             * Sets the format options of the `IgxDatePickerComponent`.
             *
             * @example
             * ```typescript
             * this.datePicker.formatOptions = {  day: "numeric",  month: "long", weekday: "long", year: "numeric"};
             * ```
             */
            set: function (formatOptions) {
                this._formatOptions = Object.assign(this._formatOptions, formatOptions);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "format", {
            /**
             * Gets/Sets the date display format of the `IgxDatePickerComponent` in dropdown mode.
             *
             * @example
             * ```typescript
             * let format = this.datePicker.format;
             * this.datePicker.format = 'yyyy-M-d';
             * ```
             */
            get: function () {
                return (this._format === undefined) ? PredefinedFormatOptions.ShortDate : this._format;
            },
            set: function (format) {
                this._format = format;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "formatViews", {
            /**
             * Gets/Sets the format views of the `IgxDatePickerComponent`.
             *
             * @example
             * ```typescript
             * let formatViews = this.datePicker.formatViews;
             *  this.datePicker.formatViews = {day:false, month: false, year:false};
             * ```
             */
            get: function () {
                return this._formatViews;
            },
            set: function (formatViews) {
                this._formatViews = Object.assign(this._formatViews, formatViews);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "disabledDates", {
            /**
             * Gets/Sets the disabled dates descriptors.
             *
             * @example
             * ```typescript
             * let disabledDates = this.datepicker.disabledDates;
             * this.datePicker.disabledDates = [ {type: DateRangeType.Weekends}, ...];
             * ```
             */
            get: function () {
                return this._disabledDates;
            },
            set: function (value) {
                this._disabledDates = value;
                this._onValidatorChange();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "specialDates", {
            /**
             * Gets/Sets the special dates descriptors.
             *
             * @example
             * ```typescript
             * let specialDates = this.datepicker.specialDates;
             * this.datePicker.specialDates = [ {type: DateRangeType.Weekends}, ... ];
             * ```
             */
            get: function () {
                return this._specialDates;
            },
            set: function (value) {
                this._specialDates = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "modalOverlaySettings", {
            /**
             * Gets/Sets the modal overlay settings.
             */
            get: function () {
                return this._modalOverlay;
            },
            set: function (value) {
                this._modalOverlay = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "dropDownOverlaySettings", {
            /**
             * Gets/Sets the drop-down overlay settings.
             */
            get: function () {
                return this._dropDownOverlaySettings || this._defaultDropDownOverlaySettings;
            },
            set: function (value) {
                this._dropDownOverlaySettings = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "displayData", {
            /**
             * Gets the formatted date when `IgxDatePickerComponent` is in dialog mode.
             *
             *  @example
             * ```typescript
             * let selectedDate = this.datePicker.displayData;
             * ```
             */
            get: function () {
                if (this.value) {
                    return this._customFormatChecker(this.formatter, this.value);
                }
                return '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "transformedDate", {
            /** @hidden @internal */
            get: function () {
                if (this._value) {
                    this._transformedDate = (this._isInEditMode) ? this._getEditorDate(this._value) : this._getDisplayDate(this._value);
                    this.isEmpty = false;
                }
                else {
                    this._transformedDate = (this._isInEditMode) ? DatePickerUtil.maskToPromptChars(this.inputMask) : '';
                }
                return this._transformedDate;
            },
            /** @hidden @internal */
            set: function (value) {
                this._transformedDate = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "template", {
            /**
             * Gets the input group template.
             *
             * @example
             * ```typescript
             * let template = this.template();
             * ```
             */
            get: function () {
                if (this.datePickerTemplateDirective) {
                    return this.datePickerTemplateDirective.template;
                }
                return (this.mode === InteractionMode.Dialog) ? this.readOnlyDatePickerTemplate : this.editableDatePickerTemplate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "context", {
            /**
             * Gets the context passed to the input group template.
             */
            get: function () {
                var _this = this;
                return {
                    disabled: this.disabled,
                    disabledDates: this.disabledDates,
                    displayData: this.displayData,
                    format: this.format,
                    isSpinLoop: this.isSpinLoop,
                    labelVisibility: this.labelVisibility,
                    locale: this.locale,
                    mask: this.mask,
                    mode: this.mode,
                    specialDates: this.specialDates,
                    value: this.value,
                    openDialog: function () { return _this.openDialog(); }
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "required", {
            get: function () {
                if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
                    // Run the validation with empty object to check if required is enabled.
                    var error = this._ngControl.control.validator({});
                    return error && error.required;
                }
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "value", {
            /**
             * Gets/Sets the selected date.
             *
             *  @example
             * ```html
             * <igx-date-picker [value]="date"></igx-date-picker>
             * ```
             */
            get: function () {
                return this._value;
            },
            set: function (date) {
                this._value = date;
                this._onChangeCallback(date);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxDatePickerComponent.prototype.onSpaceClick = function (event) {
            this.openDialog();
            event.preventDefault();
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.writeValue = function (value) {
            this._value = value;
            // TODO: do we need next call
            this._cdr.markForCheck();
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.registerOnValidatorChange = function (fn) {
            this._onValidatorChange = fn;
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.validate = function () {
            if (!!this.value && this.disabledDates && isDateInRanges(this.value, this.disabledDates)) {
                return { dateIsDisabled: true };
            }
            return null;
        };
        //#endregion
        /** @hidden */
        IgxDatePickerComponent.prototype.getEditElement = function () {
            var inputDirectiveElementRef = this._inputElementRef || this._inputUserTemplateElementRef;
            return (inputDirectiveElementRef) ? inputDirectiveElementRef.nativeElement : null;
        };
        Object.defineProperty(IgxDatePickerComponent.prototype, "inputGroupElement", {
            /** @hidden @internal */
            get: function () {
                var _a;
                return (_a = this.inputGroup) === null || _a === void 0 ? void 0 : _a.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "inputGroup", {
            /** @hidden @internal */
            get: function () {
                return this._inputGroup || this._inputGroupUserTemplate || null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "inputDirective", {
            /** @hidden @internal */
            get: function () {
                return this._inputDirective || this._inputDirectiveUserTemplates.first || null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "labelDirective", {
            /** @hidden @internal */
            get: function () {
                return this._labelDirective || this._labelDirectiveUserTemplate || null;
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.ngOnInit = function () {
            var _this = this;
            this._positionSettings = {
                openAnimation: fadeIn,
                closeAnimation: fadeOut
            };
            this._defaultDropDownOverlaySettings = {
                target: this.inputGroupElement,
                closeOnOutsideClick: true,
                modal: false,
                scrollStrategy: new AbsoluteScrollStrategy(),
                positionStrategy: new AutoPositionStrategy(this._positionSettings),
                outlet: this.outlet
            };
            this._modalOverlaySettings = {
                closeOnOutsideClick: true,
                modal: true,
                closeOnEscape: true,
                outlet: this.outlet
            };
            this._overlayService.onOpening.pipe(operators.filter(function (overlay) { return overlay.id === _this._componentID; }), operators.takeUntil(this._destroy$)).subscribe(function (eventArgs) {
                _this._onOpening(eventArgs);
            });
            this._overlayService.onOpened.pipe(operators.filter(function (overlay) { return overlay.id === _this._componentID; }), operators.takeUntil(this._destroy$)).subscribe(function () {
                _this._onOpened();
            });
            this._overlayService.onClosed.pipe(operators.filter(function (overlay) { return overlay.id === _this._componentID; }), operators.takeUntil(this._destroy$)).subscribe(function () {
                _this._onClosed();
            });
            this._overlayService.onClosing.pipe(operators.filter(function (overlay) { return overlay.id === _this._componentID; }), operators.takeUntil(this._destroy$)).subscribe(function (event) {
                _this.onClosing.emit(event);
                // If canceled in a user onClosing handler
                if (event.cancel) {
                    return;
                }
                // Do not focus the input if clicking outside in dropdown mode
                var input = _this.getEditElement();
                if (input && !(event.event && _this.mode === InteractionMode.DropDown)) {
                    input.focus();
                }
                else {
                    // outside click
                    _this._updateValidityOnBlur();
                }
            });
            if (this.mode === InteractionMode.DropDown) {
                this.dateFormatParts = DatePickerUtil.parseDateFormat(this.mask, this.locale);
                if (this.mask === undefined) {
                    this.mask = DatePickerUtil.getMask(this.dateFormatParts);
                }
                this.inputMask = DatePickerUtil.getInputMask(this.dateFormatParts);
            }
            this._ngControl = this._injector.get(forms.NgControl, null);
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this.mode === InteractionMode.DropDown && this._inputElementRef) {
                rxjs.fromEvent(this._inputElementRef.nativeElement, 'keydown').pipe(operators.throttle(function () { return rxjs.interval(0, rxjs.animationFrameScheduler); }), operators.takeUntil(this._destroy$)).subscribe(function (res) { return _this.onKeyDown(res); });
            }
            if (this._ngControl) {
                this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
            }
            this._inputDirectiveUserTemplates.changes.subscribe(function () {
                _this.attachTemplateBlur();
            });
            this.attachTemplateBlur();
        };
        IgxDatePickerComponent.prototype.ngAfterViewChecked = function () {
            // If one sets mode at run time this forces initialization of new igxInputGroup
            // As a result a new igxInputDirective is initialized too. In ngAfterViewInit of
            // the new directive isRequired of the igxInputGroup is set again. However
            // ngAfterViewInit of date picker is not called again and we may finish with wrong
            // isRequired in igxInputGroup. This is why we should set it her, only when needed
            if (this.inputGroup && this.inputGroup.isRequired !== this.required) {
                this.inputGroup.isRequired = this.required;
                this._cdr.detectChanges();
            }
            // TODO: persist validation state when dynamically changing 'dropdown' to 'dialog' ot vice versa.
            // For reference -> it is currently persisted if a user template is passed (as template is not recreated)
            if (this.labelDirective) {
                this._renderer.setAttribute(this.inputDirective.nativeElement, 'aria-labelledby', this.labelDirective.id);
            }
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.ngOnDestroy = function () {
            if (this._componentID) {
                this._overlayService.hide(this._componentID);
            }
            if (this._statusChanges$) {
                this._statusChanges$.unsubscribe();
            }
            this._destroy$.next(true);
            this._destroy$.complete();
        };
        /**
         * Selects today's date from calendar.
         *
         *  @remarks
         * Changes the input field value, @calendar.viewDate and @calendar.value.
         *  @example
         * ```typescript
         * this.datePicker.triggerTodaySelection();
         * ```
         */
        IgxDatePickerComponent.prototype.triggerTodaySelection = function () {
            var today = new Date(Date.now());
            this.handleSelection(today);
        };
        /**
         * Change the calendar selection.
         *
         * @remarks
         * Calling this method will emit the @calendar.onSelection event,
         * which will fire @handleSelection method.
         * @example
         * ```typescript
         * this.datePicker.selectDate(this.date);
         * ```
         * @param date passed date that has to be set to the calendar.
         */
        IgxDatePickerComponent.prototype.selectDate = function (date) {
            var oldValue = this.value;
            this.value = date;
            this.emitValueChangeEvent(oldValue, this.value);
            this.onSelection.emit(date);
        };
        /**
         * Deselects the calendar date.
         *
         * @example
         * ```typescript
         * this.datePicker.deselectDate();
         * ```
         */
        IgxDatePickerComponent.prototype.deselectDate = function () {
            var oldValue = this.value;
            this.value = null;
            this.emitValueChangeEvent(oldValue, this.value);
            if (this.calendar) {
                this.calendar.deselectDate();
            }
        };
        /**
         * Opens the date picker drop down or dialog.
         *
         * @param target HTMLElement - the target element to use for positioning the drop down container according to
         * @example
         * ```typescript
         * this.datePicker.openDialog(target);
         * ```
         */
        IgxDatePickerComponent.prototype.openDialog = function () {
            if (!this.collapsed || this.disabled) {
                return;
            }
            switch (this.mode) {
                case InteractionMode.Dialog: {
                    this.hasHeader = true;
                    var modalOverlay = (this.modalOverlaySettings !== undefined) ? this._modalOverlay : this._modalOverlaySettings;
                    this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, modalOverlay, this._moduleRef);
                    this._overlayService.show(this._componentID);
                    break;
                }
                case InteractionMode.DropDown: {
                    this.hasHeader = false;
                    var target = this.inputGroupElement;
                    if (target) {
                        this.dropDownOverlaySettings.target = target;
                    }
                    this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, this.dropDownOverlaySettings, this._moduleRef);
                    this._overlayService.show(this._componentID);
                    break;
                }
            }
        };
        /**
         * Close the calendar.
         *
         * @hidden @internal
         */
        IgxDatePickerComponent.prototype.closeCalendar = function () {
            this._overlayService.hide(this._componentID);
        };
        /**
         * Clear the input field, date picker value and calendar selection.
         *
         * @hidden @internal
         */
        IgxDatePickerComponent.prototype.clear = function () {
            if (!this.disabled) {
                this.isEmpty = true;
                this.invalidDate = '';
                this.deselectDate();
                this._setCursorPosition(0);
            }
        };
        /**
         * Evaluates when @calendar.onSelection event was fired
         * and update the input value.
         *
         * @param event selected value from calendar.
         *
         * @hidden @internal
         */
        IgxDatePickerComponent.prototype.handleSelection = function (date) {
            if (this.value) {
                date.setHours(this.value.getHours());
                date.setMinutes(this.value.getMinutes());
                date.setSeconds(this.value.getSeconds());
                date.setMilliseconds(this.value.getMilliseconds());
            }
            var oldValue = this.value;
            this.value = date;
            this.emitValueChangeEvent(oldValue, this.value);
            this.calendar.viewDate = date;
            this.closeCalendar();
            this.onSelection.emit(date);
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.onOpenClick = function (event) {
            event.stopPropagation();
            this.openDialog();
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.onBlur = function (event, calcDate) {
            if (calcDate === void 0) { calcDate = true; }
            this._isInEditMode = false;
            if (this.mode === InteractionMode.DropDown && calcDate) {
                this.calculateDate(event.target.value, event.type);
            }
            if (this.collapsed) {
                this._updateValidityOnBlur();
            }
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.onFocus = function () {
            this._isInEditMode = true;
            if (this.value && this.invalidDate === '') {
                this._transformedDate = this._getEditorDate(this.value);
            }
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.onKeyDown = function (event) {
            switch (event.key) {
                case "ArrowUp" /* UP_ARROW */:
                case "Up" /* UP_ARROW_IE */:
                    event.preventDefault();
                    event.stopPropagation();
                    this.spinValue(event.target.value, 1, event.type);
                    break;
                case "ArrowDown" /* DOWN_ARROW */:
                case "Down" /* DOWN_ARROW_IE */:
                    if (event.altKey) {
                        this.openDialog();
                    }
                    else {
                        event.preventDefault();
                        event.stopPropagation();
                        this.spinValue(event.target.value, -1, event.type);
                    }
                    break;
                default:
                    break;
            }
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.onWheel = function (event) {
            if (this._isInEditMode) {
                event.preventDefault();
                event.stopPropagation();
                var sign = (event.deltaY > 0) ? -1 : 1;
                this.spinValue(event.target.value, sign, event.type);
            }
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.onInput = function (event) {
            var _this = this;
            /**
             * Fix for #8165 until refactoring (#6483).
             * The IgxDateTimeEditor will be used to handle all inputs, i.e. this handler will be removed.
             * It extends the IgxMaskDirective which contains logic that handles this issue.
             */
            if (isIE() && !this._isInEditMode && !this.inputGroup.isFocused) {
                return;
            }
            var targetValue = event.target.value;
            var cursorPosition = this._getCursorPosition();
            var checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, targetValue);
            this._isInEditMode = true;
            if (targetValue !== DatePickerUtil.maskToPromptChars(this.inputMask)) {
                this.isEmpty = false;
            }
            // If all date parts are completed, change the date-picker value, stay in edit mode
            if (checkInput === 'complete' && event.inputType !== 'deleteContentBackward') {
                this._transformedDate = targetValue;
                this.calculateDate(targetValue, event.type);
                this._setCursorPosition(cursorPosition);
            }
            else if (checkInput === 'partial') {
                // While editing, if one date part is deleted, date-picker value is set to null, the remaining input stays intact.
                this.deselectDate();
                requestAnimationFrame(function () {
                    _this.getEditElement().value = targetValue;
                    _this._setCursorPosition(cursorPosition);
                });
            }
            else if (checkInput === 'empty') {
                // Total clean-up as input is deleted.
                this.isEmpty = true;
                this.deselectDate();
            }
        };
        IgxDatePickerComponent.prototype._updateValidityOnBlur = function () {
            this._onTouchedCallback();
            var input = this.inputDirective;
            if (input && this._ngControl && !this._ngControl.valid) {
                input.valid = exports.IgxInputState.INVALID;
            }
            else {
                input.valid = exports.IgxInputState.INITIAL;
            }
        };
        IgxDatePickerComponent.prototype.onStatusChanged = function () {
            if ((this._ngControl.control.touched || this._ngControl.control.dirty) &&
                (this.inputDirective && this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {
                if (this.inputGroup.isFocused) {
                    this.inputDirective.valid = this._ngControl.valid ? exports.IgxInputState.VALID : exports.IgxInputState.INVALID;
                }
                else {
                    this.inputDirective.valid = this._ngControl.valid ? exports.IgxInputState.INITIAL : exports.IgxInputState.INVALID;
                }
            }
            if (this.inputGroup && this.inputGroup.isRequired !== this.required) {
                this.inputGroup.isRequired = this.required;
            }
        };
        IgxDatePickerComponent.prototype.attachTemplateBlur = function () {
            var _this = this;
            if (this._templateInputBlur$) {
                this._templateInputBlur$.unsubscribe();
            }
            if (this._inputDirectiveUserTemplates.first) {
                var directive = this._inputDirectiveUserTemplates.first;
                this._templateInputBlur$ = rxjs.fromEvent(directive.nativeElement, 'blur').pipe(operators.takeUntil(this._destroy$)).subscribe(function (res) {
                    _this.rawDateString = res.target.value;
                    _this.onBlur(res, false);
                });
                // TODO: Refactor custom template handling.
                // Revise blur handling when custom template is passed
            }
        };
        IgxDatePickerComponent.prototype.emitValueChangeEvent = function (oldValue, newValue) {
            if (!isEqual(oldValue, newValue)) {
                this.valueChange.emit(newValue);
            }
        };
        IgxDatePickerComponent.prototype.calculateDate = function (dateString, invokedByEvent) {
            if (dateString !== '') {
                var prevDateValue = this.value;
                var inputValue = (invokedByEvent === 'blur') ? this.rawDateString : dateString;
                var newDateArray = DatePickerUtil.parseDateArray(this.dateFormatParts, prevDateValue, inputValue);
                if (newDateArray.state === "valid" /* Valid */) {
                    var newValue = newDateArray.date;
                    // Restore the time part if any
                    if (prevDateValue) {
                        newValue.setHours(prevDateValue.getHours());
                        newValue.setMinutes(prevDateValue.getMinutes());
                        newValue.setSeconds(prevDateValue.getSeconds());
                        newValue.setMilliseconds(prevDateValue.getMilliseconds());
                    }
                    if (this.disabledDates === null
                        || (this.disabledDates !== null && !isDateInRanges(newValue, this.disabledDates))) {
                        var oldValue = this.value;
                        this.value = newValue;
                        this.emitValueChangeEvent(oldValue, this.value);
                        this.invalidDate = '';
                    }
                    else {
                        var args = {
                            datePicker: this,
                            currentValue: newValue,
                        };
                        this.onDisabledDate.emit(args);
                    }
                }
                else {
                    var args = {
                        datePicker: this,
                        prevValue: prevDateValue
                    };
                    this.invalidDate = dateString;
                    this.onValidationFailed.emit(args);
                }
            }
        };
        IgxDatePickerComponent.prototype.spinValue = function (inputValue, sign, eventType) {
            this._isInEditMode = true;
            this.isEmpty = false;
            var cursorPosition = this._getCursorPosition();
            var modifiedInputValue = DatePickerUtil.getModifiedDateInput(this.dateFormatParts, inputValue, cursorPosition, this.spinDelta * sign, this.isSpinLoop);
            this.getEditElement().value = modifiedInputValue;
            this._setCursorPosition(cursorPosition);
            var checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, modifiedInputValue);
            if (checkInput === 'complete') {
                this._isInEditMode = true;
                this.calculateDate(modifiedInputValue, eventType);
                this._setCursorPosition(cursorPosition);
            }
        };
        IgxDatePickerComponent.prototype._onOpening = function (event) {
            this._initializeCalendarContainer(event.componentRef.instance);
            this.collapsed = false;
        };
        IgxDatePickerComponent.prototype._onOpened = function () {
            this.onOpened.emit(this);
            if (this.calendar) {
                this._focusCalendarDate();
            }
        };
        IgxDatePickerComponent.prototype._onClosed = function () {
            this.collapsed = true;
            this._componentID = null;
            this.onClosed.emit(this);
        };
        IgxDatePickerComponent.prototype._initializeCalendarContainer = function (componentInstance) {
            var _this = this;
            this.calendar = componentInstance.calendar;
            var isVertical = (this.vertical && this.mode === InteractionMode.Dialog);
            this.calendar.hasHeader = this.hasHeader;
            this.calendar.formatOptions = this.formatOptions;
            this.calendar.formatViews = this.formatViews;
            this.calendar.locale = this.locale;
            this.calendar.vertical = isVertical;
            this.calendar.weekStart = this.weekStart;
            this.calendar.specialDates = this.specialDates;
            this.calendar.disabledDates = this.disabledDates;
            this.calendar.headerTemplate = this.headerTemplate;
            this.calendar.subheaderTemplate = this.subheaderTemplate;
            this.calendar.hideOutsideDays = this.hideOutsideDays;
            this.calendar.monthsViewNumber = this.monthsViewNumber;
            this.calendar.showWeekNumbers = this.showWeekNumbers;
            this.calendar.selected.pipe(operators.takeUntil(this._destroy$)).subscribe(function (ev) { return _this.handleSelection(ev); });
            if (this.value) {
                this.calendar.value = this.value;
                this.calendar.viewDate = this.value;
            }
            componentInstance.mode = this.mode;
            componentInstance.vertical = isVertical;
            componentInstance.cancelButtonLabel = this.cancelButtonLabel;
            componentInstance.todayButtonLabel = this.todayButtonLabel;
            componentInstance.datePickerActions = this.datePickerActionsDirective;
            componentInstance.onClose.pipe(operators.takeUntil(this._destroy$)).subscribe(function () { return _this.closeCalendar(); });
            componentInstance.onTodaySelection.pipe(operators.takeUntil(this._destroy$)).subscribe(function () { return _this.triggerTodaySelection(); });
        };
        // Focus a date, after the calendar appearance into DOM.
        IgxDatePickerComponent.prototype._focusCalendarDate = function () {
            var _this = this;
            requestAnimationFrame(function () {
                _this.calendar.daysView.focusActiveDate();
            });
        };
        IgxDatePickerComponent.prototype._setLocaleToDate = function (value) {
            if (isIE()) {
                // this is a workaround fixing the following IE11 issue:
                // IE11 has added character code 8206 (mark for RTL) to the output of toLocaleDateString() that
                // precedes each portion that comprises the total date... For more information read this article:
                // eslint-disable-next-line max-len
                // https://www.csgpro.com/blog/2016/08/a-bad-date-with-internet-explorer-11-trouble-with-new-unicode-characters-in-javascript-date-strings/
                var localeDateStrIE = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
                return localeDateStrIE.toLocaleDateString(this.locale);
            }
            return value.toLocaleDateString(this.locale);
        };
        IgxDatePickerComponent.prototype._getCursorPosition = function () {
            return this.getEditElement().selectionStart;
        };
        IgxDatePickerComponent.prototype._setCursorPosition = function (start, end) {
            var _this = this;
            if (end === void 0) { end = start; }
            requestAnimationFrame(function () {
                _this.getEditElement().setSelectionRange(start, end);
            });
        };
        /**
         * Apply custom user formatter upon date.
         *
         * @param formatter custom formatter function.
         * @param date passed date
         */
        IgxDatePickerComponent.prototype._customFormatChecker = function (formatter, date) {
            return this.formatter ? this.formatter(date) : this._setLocaleToDate(date);
        };
        /*
        * Transforms the date according to the specified format when `IgxDatePickerComponent` is in edit mode
        * using @angular/common formatDate method: https://angular.io/api/common/formatDate
        * @param  value: string | number | Date
        * @returns formatted string
        */
        IgxDatePickerComponent.prototype._getDisplayDate = function (value) {
            if (this.format && !this.formatter) {
                var locale = this.locale || this.defaultLocale;
                return i2.formatDate(value, this.format, locale);
            }
            else {
                return this._customFormatChecker(this.formatter, value);
            }
        };
        IgxDatePickerComponent.prototype._getEditorDate = function (value) {
            var locale = this.locale || this.defaultLocale;
            var changedValue = (value) ? i2.formatDate(value, this.mask, locale) : '';
            return DatePickerUtil.addPromptCharsEditMode(this.dateFormatParts, this.value, changedValue);
        };
        return IgxDatePickerComponent;
    }());
    IgxDatePickerComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: IgxDatePickerComponent,
                            multi: true
                        },
                        {
                            provide: forms.NG_VALIDATORS,
                            useExisting: IgxDatePickerComponent,
                            multi: true
                        }],
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'igx-date-picker',
                    template: "<ng-template #labelTemplate>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #readOnlyDatePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\">\n        <ng-container ngProjectAs=\"[igxLabel]\" *ngTemplateOutlet=\"labelTemplate\"></ng-container>\n        <igx-prefix>\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility&&!_labelDirectiveUserTemplate\" igxLabel>{{labelInternal}}</label>\n        <input\n            class=\"igx-date-picker__input-date\"\n            igxInput\n            [value]=\"displayData || ''\"\n            [disabled]=\"disabled\"\n            (blur)=\"onBlur($event)\"\n            [tabindex]='editorTabIndex'\n            readonly\n        />\n    </igx-input-group>\n</ng-template>\n\n<ng-template #editableDatePickerTemplate>\n    <igx-input-group #editableInputGroup>\n        <ng-container ngProjectAs=\"[igxLabel]\" *ngTemplateOutlet=\"labelTemplate\"></ng-container>\n        <igx-prefix (click)=\"onOpenClick($event)\">\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility&&!_labelDirectiveUserTemplate\" igxLabel>{{labelInternal}}</label>\n        <input\n            class=\"igx-date-picker__input-date\"\n            igxInput\n            type=\"text\"\n            [value]=\"transformedDate\"\n            [igxMask]=\"inputMask\"\n            [placeholder]=\"mask\"\n            [igxTextSelection]=\"true\"\n            [disabled]=\"disabled\"\n            [displayValuePipe]=\"displayValuePipe\"\n            [focusedValuePipe]=\"inputValuePipe\"\n            (blur)=\"onBlur($event)\"\n            (wheel)=\"onWheel($event)\"\n            (input)=\"onInput($event)\"\n            (focus)=\"onFocus()\"\n            [tabindex]='editorTabIndex'\n        />\n        <igx-suffix *ngIf=\"!isEmpty\" (click)=\"clear()\">\n            <igx-icon>clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n",
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                },] }
    ];
    IgxDatePickerComponent.ctorParameters = function () { return [
        { type: IgxOverlayService, decorators: [{ type: i0.Inject, args: [IgxOverlayService,] }] },
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: i0.NgModuleRef },
        { type: i0.Injector },
        { type: i0.Renderer2 }
    ]; };
    IgxDatePickerComponent.propDecorators = {
        label: [{ type: i0.Input }],
        labelVisibility: [{ type: i0.Input }],
        locale: [{ type: i0.Input }],
        editorTabIndex: [{ type: i0.Input }],
        weekStart: [{ type: i0.Input }],
        formatOptions: [{ type: i0.Input }],
        hideOutsideDays: [{ type: i0.Input }],
        monthsViewNumber: [{ type: i0.Input }],
        showWeekNumbers: [{ type: i0.Input }],
        format: [{ type: i0.Input }],
        mask: [{ type: i0.Input }],
        formatViews: [{ type: i0.Input }],
        disabledDates: [{ type: i0.Input }],
        specialDates: [{ type: i0.Input }],
        modalOverlaySettings: [{ type: i0.Input }],
        dropDownOverlaySettings: [{ type: i0.Input }],
        value: [{ type: i0.Input }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        formatter: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        vertical: [{ type: i0.Input }],
        todayButtonLabel: [{ type: i0.Input }],
        cancelButtonLabel: [{ type: i0.Input }],
        mode: [{ type: i0.Input }],
        isSpinLoop: [{ type: i0.Input }],
        outlet: [{ type: i0.Input }],
        onOpened: [{ type: i0.Output }],
        onClosed: [{ type: i0.Output }],
        onClosing: [{ type: i0.Output }],
        onSelection: [{ type: i0.Output }],
        valueChange: [{ type: i0.Output }],
        onDisabledDate: [{ type: i0.Output }],
        onValidationFailed: [{ type: i0.Output }],
        _labelDirectiveUserTemplate: [{ type: i0.ContentChild, args: [IgxLabelDirective,] }],
        headerTemplate: [{ type: i0.ContentChild, args: [IgxCalendarHeaderTemplateDirective, { read: IgxCalendarHeaderTemplateDirective },] }],
        subheaderTemplate: [{ type: i0.ContentChild, args: [IgxCalendarSubheaderTemplateDirective, { read: IgxCalendarSubheaderTemplateDirective },] }],
        datePickerActionsDirective: [{ type: i0.ContentChild, args: [IgxDatePickerActionsDirective, { read: IgxDatePickerActionsDirective },] }],
        readOnlyDatePickerTemplate: [{ type: i0.ViewChild, args: ['readOnlyDatePickerTemplate', { read: i0.TemplateRef, static: true },] }],
        editableDatePickerTemplate: [{ type: i0.ViewChild, args: ['editableDatePickerTemplate', { read: i0.TemplateRef, static: true },] }],
        _inputGroup: [{ type: i0.ViewChild, args: [IgxInputGroupComponent,] }],
        _inputGroupUserTemplate: [{ type: i0.ContentChild, args: [IgxInputGroupComponent,] }],
        _inputUserTemplateElementRef: [{ type: i0.ContentChild, args: [IgxInputDirective, { read: i0.ElementRef },] }],
        _labelDirective: [{ type: i0.ViewChild, args: [IgxLabelDirective,] }],
        datePickerTemplateDirective: [{ type: i0.ContentChild, args: [IgxDatePickerTemplateDirective, { read: IgxDatePickerTemplateDirective },] }],
        _inputElementRef: [{ type: i0.ViewChild, args: [IgxInputDirective, { read: i0.ElementRef },] }],
        _inputDirective: [{ type: i0.ViewChild, args: [IgxInputDirective,] }],
        _inputDirectiveUserTemplates: [{ type: i0.ContentChildren, args: [IgxInputDirective, { descendants: true },] }],
        onSpaceClick: [{ type: i0.HostListener, args: ['keydown.spacebar', ['$event'],] }, { type: i0.HostListener, args: ['keydown.space', ['$event'],] }]
    };
    __decorate([
        DeprecateProperty("Use igxLabel inside the date picker to change the label:\n    <igx-date-picker>\n        <label igxLabel>Custom label</label>\n    </igx-date-picker> ")
    ], IgxDatePickerComponent.prototype, "label", null);
    /**
     * @hidden
     */
    var IgxDatePickerModule = /** @class */ (function () {
        function IgxDatePickerModule() {
        }
        return IgxDatePickerModule;
    }());
    IgxDatePickerModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxDatePickerComponent,
                        IgxCalendarContainerComponent,
                        IgxDatePickerActionsDirective,
                        IgxDatePickerTemplateDirective,
                        DatePickerDisplayValuePipe,
                        DatePickerInputValuePipe
                    ],
                    entryComponents: [
                        IgxCalendarContainerComponent
                    ],
                    exports: [
                        IgxDatePickerComponent,
                        IgxDatePickerTemplateDirective,
                        IgxDatePickerActionsDirective,
                        DatePickerDisplayValuePipe,
                        DatePickerInputValuePipe,
                        IgxInputGroupModule
                    ],
                    imports: [
                        i2.CommonModule,
                        IgxIconModule,
                        IgxInputGroupModule,
                        IgxCalendarModule,
                        IgxButtonModule,
                        IgxRippleModule,
                        IgxMaskModule,
                        IgxTextSelectionModule
                    ]
                },] }
    ];

    /**
     * @hidden
     */
    var IgxDialogTitleDirective = /** @class */ (function () {
        function IgxDialogTitleDirective() {
            this.defaultStyle = true;
        }
        return IgxDialogTitleDirective;
    }());
    IgxDialogTitleDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'igx-dialog-title,[igxDialogTitle]'
                },] }
    ];
    IgxDialogTitleDirective.propDecorators = {
        defaultStyle: [{ type: i0.HostBinding, args: ['class.igx-dialog__window-title',] }]
    };
    /**
     * @hidden
     */
    var IgxDialogActionsDirective = /** @class */ (function () {
        function IgxDialogActionsDirective() {
            this.defaultClass = true;
        }
        return IgxDialogActionsDirective;
    }());
    IgxDialogActionsDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'igx-dialog-actions,[igxDialogActions]'
                },] }
    ];
    IgxDialogActionsDirective.propDecorators = {
        defaultClass: [{ type: i0.HostBinding, args: ['class.igx-dialog__window-actions',] }]
    };

    var DIALOG_ID = 0;
    /**
     * **Ignite UI for Angular Dialog Window** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/dialog.html)
     *
     * The Ignite UI Dialog Window presents a dialog window to the user which can simply display messages or display
     * more complicated visuals such as a user sign-in form.  It also provides a right and left button
     * which can be used for custom actions.
     *
     * Example:
     * ```html
     * <button (click)="form.open()">Show Dialog</button>
     * <igx-dialog #form title="Sign In" rightButtonLabel="OK">
     *   <div>
     *     <input type="text" igxInput/>
     *     <label igxLabel>Username</label>
     *   </div>
     *   <div>
     *     <input type="password" igxInput/>
     *     <label igxLabel>Password</label>
     *   </div>
     * </igx-dialog>
     * ```
     */
    var IgxDialogComponent = /** @class */ (function () {
        function IgxDialogComponent(elementRef, navService) {
            this.elementRef = elementRef;
            this.navService = navService;
            /**
             * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
             * ```html
             * <igx-dialog [id]="'igx-dialog-56'" #alert title="Notification"
             *  leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()">
             * </igx-dialog>
             * ```
             */
            this.id = "igx-dialog-" + DIALOG_ID++;
            /**
             * An @Input property controlling the `title` of the dialog.
             * ```html
             * <igx-dialog title="Notification" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
             * ```
             */
            this.title = '';
            /**
             *  An @Input property controlling the `message` of the dialog.
             * ```html
             * <igx-dialog message="Your email was sent!" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
             * ```
             */
            this.message = '';
            /**
             * An @Input property to set the `label` of the left button of the dialog.
             * ```html
             * <igx-dialog leftButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
             * ```
             */
            this.leftButtonLabel = '';
            /**
             * An @Input property to set the left button `type`. The types are `flat`, `raised` and `fab`.
             * The `flat` type button is a rectangle and doesn't have a shadow. <br>
             * The `raised` type button is also a rectangle but has a shadow. <br>
             * The `fab` type button is a circle with a shadow. <br>
             * The default value is `flat`.
             * ```html
             * <igx-dialog leftButtonType="raised" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             * ```
             */
            this.leftButtonType = 'flat';
            /**
             * An @Input property to set the left button color. The property accepts all valid CSS color property values.
             * ```html
             * <igx-dialog leftButtonColor="yellow" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             * ```
             */
            this.leftButtonColor = '';
            /**
             * An @Input property to set the left button `background-color`. The property accepts all valid CSS color property values.
             * ```html
             * <igx-dialog leftButtonBackgroundColor="black" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             * ```
             */
            this.leftButtonBackgroundColor = '';
            /**
             * An @Input property to set the left button `ripple`. The `ripple` animates a click/tap to a component as a series of fading waves.
             * The property accepts all valid CSS color property values.
             * ```html
             * <igx-dialog leftButtonRipple="green" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             * ```
             */
            this.leftButtonRipple = '';
            /**
             * An @Input property to set the `label` of the right button of the dialog.
             * ```html
             * <igx-dialog rightButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
             * ```
             */
            this.rightButtonLabel = '';
            /**
             * An @Input property to set the right button `type`. The types are `flat`, `raised` and `fab`.
             * The `flat` type button is a rectangle and doesn't have a shadow. <br>
             * The `raised` type button is also a rectangle but has a shadow. <br>
             * The `fab` type button is a circle with a shadow. <br>
             * The default value is `flat`.
             * ```html
             * <igx-dialog rightButtonType="fab" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             * ```
             */
            this.rightButtonType = 'flat';
            /**
             * An @Input property to set the right button `color`. The property accepts all valid CSS color property values.
             * ```html
             * <igx-dialog rightButtonColor="yellow" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             * ```
             */
            this.rightButtonColor = '';
            /**
             * An @Input property to set the right button `background-color`. The property accepts all valid CSS color property values.
             * ```html
             * <igx-dialog rightButtonBackgroundColor="black" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             * ```
             */
            this.rightButtonBackgroundColor = '';
            /**
             * An @Input property to set the right button `ripple`.
             * ```html
             * <igx-dialog rightButtonRipple="green" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             * ```
             */
            this.rightButtonRipple = '';
            /**
             * The default `tabindex` attribute for the component
             *
             * @hidden
             */
            this.tabindex = -1;
            /**
             * An event that is emitted before the dialog is opened.
             * ```html
             * <igx-dialog (onOpen)="onDialogOpenHandler($event)" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK">
             * </igx-dialog>
             * ```
             */
            this.onOpen = new i0.EventEmitter();
            /**
             * An event that is emitted after the dialog is opened.
             * ```html
             * <igx-dialog (onOpened)="onDialogOpenedHandler($event)" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK">
             * </igx-dialog>
             * ```
             */
            this.onOpened = new i0.EventEmitter();
            /**
             * An event that is emitted before the dialog is closed.
             * ```html
             * <igx-dialog (onClose)="onDialogCloseHandler($event)" title="Confirmation" leftButtonLabel="Cancel" rightButtonLabel="OK">
             * </igx-dialog>
             * ```
             */
            this.onClose = new i0.EventEmitter();
            /**
             * An event that is emitted after the dialog is closed.
             * ```html
             * <igx-dialog (onClosed)="onDialogClosedHandler($event)" title="Confirmation" leftButtonLabel="Cancel" rightButtonLabel="OK">
             * </igx-dialog>
             * ```
             */
            this.onClosed = new i0.EventEmitter();
            /**
             * An event that is emitted when the left button is clicked.
             * ```html
             * <igx-dialog (onLeftButtonSelect)="onDialogOKSelected($event)" #dialog leftButtonLabel="OK" rightButtonLabel="Cancel">
             * </igx-dialog>
             * ```
             */
            this.onLeftButtonSelect = new i0.EventEmitter();
            /**
             * An event that is emitted when the right button is clicked.
             * ```html
             * <igx-dialog (onRightButtonSelect)="onDialogOKSelected($event)"
             * #dialog title="Confirmation" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK"
             * rightButtonRipple="#4CAF50" closeOnOutsideSelect="true">
             * </igx-dialog>
             * ```
             */
            this.onRightButtonSelect = new i0.EventEmitter();
            /**
             * @hidden
             */
            this.isOpenChange = new i0.EventEmitter();
            this.destroy$ = new rxjs.Subject();
            this._positionSettings = {
                openAnimation: i1.useAnimation(slideInBottom, { params: { fromPosition: 'translateY(100%)' } }),
                closeAnimation: i1.useAnimation(slideOutTop, { params: { toPosition: 'translateY(-100%)' } })
            };
            this._closeOnOutsideSelect = false;
            this._closeOnEscape = true;
            this._isModal = true;
            this._titleId = IgxDialogComponent.NEXT_ID++ + '_title';
            this._overlayDefaultSettings = {
                positionStrategy: new GlobalPositionStrategy(this._positionSettings),
                scrollStrategy: new NoOpScrollStrategy(),
                modal: this.isModal,
                closeOnEscape: this._closeOnEscape,
                closeOnOutsideClick: this.closeOnOutsideSelect
            };
        }
        Object.defineProperty(IgxDialogComponent.prototype, "isModal", {
            /**
             * Controls whether the dialog should be shown as modal. Defaults to `true`
             * ```html
             * <igx-dialog [isModal]="false" ></igx-dialog>
             * ```
             */
            get: function () {
                return this._isModal;
            },
            set: function (val) {
                this._overlayDefaultSettings.modal = val;
                this._isModal = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "closeOnEscape", {
            /**
             * Controls whether the dialog should close when `Esc` key is pressed. Defaults to `true`
             * ```html
             * <igx-dialog [closeOnEscape]="false" ></igx-dialog>
             * ```
             */
            get: function () {
                return this._closeOnEscape;
            },
            set: function (val) {
                this._overlayDefaultSettings.closeOnEscape = val;
                this._closeOnEscape = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "closeOnOutsideSelect", {
            /**
             * An @Input property that allows you to enable the "close on click outside the dialog". By default it's disabled.
             * ```html
             * <igx-dialog closeOnOutsideSelect="true" leftButtonLabel="Cancel" (onLeftButtonSelect)="dialog.close()"
             * rightButtonLabel="OK" rightButtonRipple="#4CAF50" (onRightButtonSelect)="onDialogOKSelected($event)">
             * </igx-dialog>
             * ```
             */
            get: function () {
                return this._closeOnOutsideSelect;
            },
            set: function (val) {
                this._overlayDefaultSettings.closeOnOutsideClick = val;
                this._closeOnOutsideSelect = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "positionSettings", {
            /**
             * Get the position and animation settings used by the dialog.
             * ```typescript
             * @ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
             * let currentPosition: PositionSettings = this.alert.positionSettings
             * ```
             */
            get: function () {
                return this._positionSettings;
            },
            /**
             * Set the position and animation settings used by the dialog.
             * ```typescript
             * import { slideInLeft, slideOutRight } from 'igniteui-angular';
             * ...
             * @ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
             *  public newPositionSettings: PositionSettings = {
             *      openAnimation: useAnimation(slideInTop, { params: { duration: '2000ms' } }),
             *      closeAnimation: useAnimation(slideOutBottom, { params: { duration: '2000ms'} }),
             *      horizontalDirection: HorizontalAlignment.Left,
             *      verticalDirection: VerticalAlignment.Middle,
             *      horizontalStartPoint: HorizontalAlignment.Left,
             *      verticalStartPoint: VerticalAlignment.Middle,
             *      minSize: { height: 100, width: 100 }
             *  };
             * this.alert.positionSettings = this.newPositionSettings;
             * ```
             */
            set: function (settings) {
                this._positionSettings = settings;
                this._overlayDefaultSettings.positionStrategy = new GlobalPositionStrategy(this._positionSettings);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "element", {
            /**
             * @hidden
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "state", {
            /**
             * Returns the value of state. Possible state values are "open" or "close".
             * ```typescript
             * @ViewChild("MyDialog")
             * public dialog: IgxDialogComponent;
             * ngAfterViewInit() {
             *     let dialogState = this.dialog.state;
             * }
             * ```
             */
            get: function () {
                return this.isOpen ? 'open' : 'close';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "isOpen", {
            /**
             * State of the dialog.
             *
             * ```typescript
             * // get
             * let dialogIsOpen = this.dialog.isOpen;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-dialog [isOpen]='false'></igx-dialog>
             * ```
             *
             * Two-way data binding.
             * ```html
             * <!--set-->
             * <igx-dialog [(isOpen)]='model.isOpen'></igx-dialog>
             * ```
             */
            get: function () {
                return !this.toggleRef.collapsed;
            },
            set: function (value) {
                var _this = this;
                if (value !== this.isOpen) {
                    this.isOpenChange.emit(value);
                    if (value) {
                        requestAnimationFrame(function () {
                            _this.open();
                        });
                    }
                    else {
                        this.close();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "isCollapsed", {
            get: function () {
                return this.toggleRef.collapsed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "role", {
            /**
             * Returns the value of the role of the dialog. The valid values are `dialog`, `alertdialog`, `alert`.
             * ```typescript
             * @ViewChild("MyDialog")
             * public dialog: IgxDialogComponent;
             * ngAfterViewInit() {
             *     let dialogRole = this.dialog.role;
             * }
             *  ```
             */
            get: function () {
                if (this.leftButtonLabel !== '' && this.rightButtonLabel !== '') {
                    return 'dialog';
                }
                else if (this.leftButtonLabel !== '' ||
                    this.rightButtonLabel !== '') {
                    return 'alertdialog';
                }
                else {
                    return 'alert';
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "titleId", {
            /**
             * Returns the value of the title id.
             * ```typescript
             *  @ViewChild("MyDialog")
             * public dialog: IgxDialogComponent;
             * ngAfterViewInit() {
             *     let dialogTitle = this.dialog.titleId;
             * }
             * ```
             */
            get: function () {
                return this._titleId;
            },
            enumerable: false,
            configurable: true
        });
        IgxDialogComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.toggleRef.onClosing.pipe(operators.takeUntil(this.destroy$)).subscribe(function (eventArgs) { return _this.emitCloseFromDialog(eventArgs); });
            this.toggleRef.onClosed.pipe(operators.takeUntil(this.destroy$)).subscribe(function (eventArgs) { return _this.emitClosedFromDialog(eventArgs); });
            this.toggleRef.onOpened.pipe(operators.takeUntil(this.destroy$)).subscribe(function (eventArgs) { return _this.emitOpenedFromDialog(eventArgs); });
        };
        /**
         * A method that opens the dialog.
         *
         * @memberOf {@link IgxDialogComponent}
         * ```html
         * <button (click)="dialog.open() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
         * <igx-dialog #dialog></igx-dialog>
         * ```
         */
        IgxDialogComponent.prototype.open = function (overlaySettings) {
            if (overlaySettings === void 0) { overlaySettings = this._overlayDefaultSettings; }
            var eventArgs = { dialog: this, event: null, cancel: false };
            this.onOpen.emit(eventArgs);
            if (!eventArgs.cancel) {
                this.toggleRef.open(overlaySettings);
                this.isOpenChange.emit(true);
                if (!this.leftButtonLabel && !this.rightButtonLabel) {
                    this.toggleRef.element.focus();
                }
            }
        };
        /**
         * A method that that closes the dialog.
         *
         *  @memberOf {@link IgxDialogComponent}
         * ```html
         * <button (click)="dialog.close() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
         * <igx-dialog #dialog></igx-dialog>
         * ```
         */
        IgxDialogComponent.prototype.close = function () {
            // `onClose` will emit from `toggleRef.onClosing` subscription
            this.toggleRef.close();
        };
        /**
         * A method that opens/closes the dialog.
         *
         * @memberOf {@link IgxDialogComponent}
         * ```html
         * <button (click)="dialog.toggle() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
         * <igx-dialog #dialog></igx-dialog>
         * ```
         */
        IgxDialogComponent.prototype.toggle = function () {
            if (this.isOpen) {
                this.close();
            }
            else {
                this.open();
            }
        };
        /**
         * @hidden
         */
        IgxDialogComponent.prototype.onDialogSelected = function (event) {
            event.stopPropagation();
            if (this.isOpen &&
                this.closeOnOutsideSelect &&
                event.target.classList.contains(IgxDialogComponent.DIALOG_CLASS)) {
                this.close();
            }
        };
        /**
         * @hidden
         */
        IgxDialogComponent.prototype.onInternalLeftButtonSelect = function (event) {
            this.onLeftButtonSelect.emit({ dialog: this, event: event });
        };
        /**
         * @hidden
         */
        IgxDialogComponent.prototype.onInternalRightButtonSelect = function (event) {
            this.onRightButtonSelect.emit({ dialog: this, event: event });
        };
        /**
         * @hidden
         */
        IgxDialogComponent.prototype.ngOnInit = function () {
            if (this.navService && this.id) {
                this.navService.add(this.id, this);
            }
        };
        /**
         * @hidden
         */
        IgxDialogComponent.prototype.ngOnDestroy = function () {
            if (this.navService && this.id) {
                this.navService.remove(this.id);
            }
        };
        IgxDialogComponent.prototype.emitCloseFromDialog = function (eventArgs) {
            var dialogEventsArgs = { dialog: this, event: eventArgs.event, cancel: eventArgs.cancel };
            this.onClose.emit(dialogEventsArgs);
            eventArgs.cancel = dialogEventsArgs.cancel;
            if (!eventArgs.cancel) {
                this.isOpenChange.emit(false);
            }
        };
        IgxDialogComponent.prototype.emitClosedFromDialog = function (eventArgs) {
            this.onClosed.emit({ dialog: this, event: eventArgs.event });
        };
        IgxDialogComponent.prototype.emitOpenedFromDialog = function (eventArgs) {
            this.onOpened.emit({ dialog: this, event: eventArgs.event });
        };
        return IgxDialogComponent;
    }());
    IgxDialogComponent.NEXT_ID = 1;
    IgxDialogComponent.DIALOG_CLASS = 'igx-dialog';
    IgxDialogComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-dialog',
                    template: "<div tabindex=\"0\" #dialog class=\"igx-dialog\" igxToggle (click)=\"onDialogSelected($event)\">\n    <div #dialogWindow class=\"igx-dialog__window\"  [attr.role]=\"role\" [attr.aria-labelledby]=\"titleId\">\n\n        <div *ngIf=\"title\" [attr.id]=\"titleId\" class=\"igx-dialog__window-title\">\n            {{ title }}\n        </div>\n        <ng-content *ngIf=\"!title\" select=\"igx-dialog-title,[igxDialogTitle]\"></ng-content>\n\n        <div class=\"igx-dialog__window-content\">\n            <span *ngIf=\"message\" class=\"igx-dialog__window-message\">{{ message }}</span>\n            <ng-content *ngIf=\"!message\"></ng-content>\n        </div>\n\n        <div *ngIf=\"leftButtonLabel || rightButtonLabel\" class=\"igx-dialog__window-actions\">\n            <button *ngIf=\"leftButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ leftButtonType }}\" igxButtonColor=\"{{ leftButtonColor }}\" igxButtonBackground=\"{{ leftButtonBackgroundColor }}\"\n                igxRipple=\"{{ leftButtonRipple }}\" (click)=\"onInternalLeftButtonSelect($event)\">\n                {{ leftButtonLabel }}\n            </button>\n            <button *ngIf=\"rightButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ rightButtonType }}\" igxButtonColor=\"{{ rightButtonColor }}\" igxButtonBackground=\"{{ rightButtonBackgroundColor }}\"\n                igxRipple=\"{{ rightButtonRipple }}\" (click)=\"onInternalRightButtonSelect($event)\">\n                {{ rightButtonLabel }}\n            </button>\n        </div>\n        <ng-content *ngIf=\"!leftButtonLabel && !rightButtonLabel\" select=\"igx-dialog-actions,[igxDialogActions]\"></ng-content>\n\n    </div>\n</div>\n"
                },] }
    ];
    IgxDialogComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: IgxNavigationService, decorators: [{ type: i0.Optional }] }
    ]; };
    IgxDialogComponent.propDecorators = {
        toggleRef: [{ type: i0.ViewChild, args: [IgxToggleDirective, { static: true },] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        isModal: [{ type: i0.Input }],
        closeOnEscape: [{ type: i0.Input }],
        title: [{ type: i0.Input }],
        message: [{ type: i0.Input }],
        leftButtonLabel: [{ type: i0.Input }],
        leftButtonType: [{ type: i0.Input }],
        leftButtonColor: [{ type: i0.Input }],
        leftButtonBackgroundColor: [{ type: i0.Input }],
        leftButtonRipple: [{ type: i0.Input }],
        rightButtonLabel: [{ type: i0.Input }],
        rightButtonType: [{ type: i0.Input }],
        rightButtonColor: [{ type: i0.Input }],
        rightButtonBackgroundColor: [{ type: i0.Input }],
        rightButtonRipple: [{ type: i0.Input }],
        closeOnOutsideSelect: [{ type: i0.Input }],
        positionSettings: [{ type: i0.Input }],
        tabindex: [{ type: i0.HostBinding, args: ['attr.tabindex',] }],
        onOpen: [{ type: i0.Output }],
        onOpened: [{ type: i0.Output }],
        onClose: [{ type: i0.Output }],
        onClosed: [{ type: i0.Output }],
        onLeftButtonSelect: [{ type: i0.Output }],
        onRightButtonSelect: [{ type: i0.Output }],
        isOpenChange: [{ type: i0.Output }],
        isOpen: [{ type: i0.Input }],
        isCollapsed: [{ type: i0.HostBinding, args: ['class.igx-dialog--hidden',] }],
        role: [{ type: i0.Input }],
        titleId: [{ type: i0.Input }]
    };
    /**
     * @hidden
     */
    var IgxDialogModule = /** @class */ (function () {
        function IgxDialogModule() {
        }
        return IgxDialogModule;
    }());
    IgxDialogModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                    exports: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                    imports: [i2.CommonModule, IgxToggleModule, IgxButtonModule, IgxRippleModule, IgxFocusModule]
                },] }
    ];

    var FilterMode = mkenum({
        quickFilter: 'quickFilter',
        excelStyleFilter: 'excelStyleFilter'
    });
    var GridSummaryPosition = mkenum({
        top: 'top',
        bottom: 'bottom'
    });
    var GridSummaryCalculationMode = mkenum({
        rootLevelOnly: 'rootLevelOnly',
        childLevelsOnly: 'childLevelsOnly',
        rootAndChildLevels: 'rootAndChildLevels'
    });
    var GridSelectionMode = mkenum({
        none: 'none',
        single: 'single',
        multiple: 'multiple',
        multipleCascade: 'multipleCascade'
    });
    var ColumnDisplayOrder = mkenum({
        Alphabetical: 'Alphabetical',
        DisplayOrder: 'DisplayOrder'
    });
    (function (ColumnPinningPosition) {
        ColumnPinningPosition[ColumnPinningPosition["Start"] = 0] = "Start";
        ColumnPinningPosition[ColumnPinningPosition["End"] = 1] = "End";
    })(exports.ColumnPinningPosition || (exports.ColumnPinningPosition = {}));
    (function (RowPinningPosition) {
        RowPinningPosition[RowPinningPosition["Top"] = 0] = "Top";
        RowPinningPosition[RowPinningPosition["Bottom"] = 1] = "Bottom";
    })(exports.RowPinningPosition || (exports.RowPinningPosition = {}));
    (function (GridPagingMode) {
        GridPagingMode[GridPagingMode["Local"] = 0] = "Local";
        GridPagingMode[GridPagingMode["Remote"] = 1] = "Remote";
    })(exports.GridPagingMode || (exports.GridPagingMode = {}));

    /**
     * @hidden
     */
    var FilterListItem = /** @class */ (function () {
        function FilterListItem() {
            this.isSpecial = false;
            this.isBlanks = false;
        }
        return FilterListItem;
    }());
    var IgxExcelStyleColumnOperationsTemplateDirective = /** @class */ (function () {
        function IgxExcelStyleColumnOperationsTemplateDirective() {
        }
        return IgxExcelStyleColumnOperationsTemplateDirective;
    }());
    IgxExcelStyleColumnOperationsTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'igx-excel-style-column-operations,[igxExcelStyleColumnOperations]'
                },] }
    ];
    IgxExcelStyleColumnOperationsTemplateDirective.ctorParameters = function () { return []; };
    var IgxExcelStyleFilterOperationsTemplateDirective = /** @class */ (function () {
        function IgxExcelStyleFilterOperationsTemplateDirective() {
        }
        return IgxExcelStyleFilterOperationsTemplateDirective;
    }());
    IgxExcelStyleFilterOperationsTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'igx-excel-style-filter-operations,[igxExcelStyleFilterOperations]'
                },] }
    ];
    IgxExcelStyleFilterOperationsTemplateDirective.ctorParameters = function () { return []; };
    /**
     * A component used for presenting Excel style filtering UI for a specific column.
     * It is used internally in the Grid, but could also be hosted in a container outside of it.
     *
     * Example:
     * ```html
     * <igx-grid-excel-style-filtering
     *     [column]="grid1.columns[0]">
     * </igx-grid-excel-style-filtering>
     * ```
     */
    var IgxGridExcelStyleFilteringComponent = /** @class */ (function () {
        function IgxGridExcelStyleFilteringComponent(cdr, element, gridAPI) {
            this.cdr = cdr;
            this.element = element;
            this.gridAPI = gridAPI;
            /**
             * @hidden @internal
             */
            this.defaultClass = true;
            /**
             * @hidden @internal
             */
            this.inline = true;
            /**
             * @hidden @internal
             */
            this.loadingStart = new i0.EventEmitter();
            /**
             * @hidden @internal
             */
            this.loadingEnd = new i0.EventEmitter();
            /**
             * @hidden @internal
             */
            this.initialized = new i0.EventEmitter();
            /**
             * @hidden @internal
             */
            this.sortingChanged = new i0.EventEmitter();
            /**
             * @hidden @internal
             */
            this.columnChange = new i0.EventEmitter();
            /**
             * @hidden @internal
             */
            this.listDataLoaded = new i0.EventEmitter();
            /**
             * @hidden @internal
             */
            this.expressionsList = new Array();
            /**
             * @hidden @internal
             */
            this.listData = new Array();
            /**
             * @hidden @internal
             */
            this.uniqueValues = [];
            this.destroy$ = new rxjs.Subject();
            this.containsNullOrEmpty = false;
            this.selectAllSelected = true;
            this.selectAllIndeterminate = false;
            this.filterValues = new Set();
        }
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "column", {
            /**
             * Returns the current column.
             */
            get: function () {
                return this._column;
            },
            /**
             * An @Input property that sets the column.
             */
            set: function (value) {
                var _this = this;
                this._column = value;
                this.listData = new Array();
                this.columnChange.emit(this._column);
                if (this._columnPinning) {
                    this._columnPinning.unsubscribe();
                }
                if (this._columnVisibilityChanged) {
                    this._columnVisibilityChanged.unsubscribe();
                }
                if (this._sortingChanged) {
                    this._sortingChanged.unsubscribe();
                }
                if (this._filteringChanged) {
                    this._filteringChanged.unsubscribe();
                }
                if (this._densityChanged) {
                    this._densityChanged.unsubscribe();
                }
                if (this._columnMoved) {
                    this._columnMoved.unsubscribe();
                }
                if (this._column) {
                    this._column.grid.filteringService.registerSVGIcons();
                    this.init();
                    this.sortingChanged.emit();
                    this._columnPinning = this.grid.onColumnPinning.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                        requestAnimationFrame(function () {
                            if (!_this.cdr.destroyed) {
                                _this.cdr.detectChanges();
                            }
                        });
                    });
                    this._columnVisibilityChanged = this.grid.onColumnVisibilityChanged.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                        _this.cdr.detectChanges();
                    });
                    this._sortingChanged = this.grid.sortingExpressionsChange.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                        _this.sortingChanged.emit();
                    });
                    this._filteringChanged = this.grid.filteringExpressionsTreeChange.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                        _this.init();
                    });
                    this._densityChanged = this.grid.onDensityChanged.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                        _this.cdr.detectChanges();
                    });
                    this._columnMoved = this.grid.onColumnMovingEnd.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                        _this.cdr.detectChanges();
                    });
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "filteringService", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.grid.filteringService;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "minHeight", {
            /**
             * Gets the minimum height.
             */
            get: function () {
                if (this._minHeight || this._minHeight === 0) {
                    return this._minHeight;
                }
                if (!this.inline) {
                    var minHeight = 645;
                    switch (this.displayDensity) {
                        case DisplayDensity.cosy:
                            minHeight = 465;
                            break;
                        case DisplayDensity.compact:
                            minHeight = 330;
                            break;
                        default: break;
                    }
                    return minHeight + "px";
                }
            },
            /**
             * Sets the minimum height.
             */
            set: function (value) {
                this._minHeight = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "maxHeight", {
            /**
             * Gets the maximum height.
             */
            get: function () {
                if (this._maxHeight) {
                    return this._maxHeight;
                }
                if (!this.inline) {
                    var maxHeight = 775;
                    switch (this.displayDensity) {
                        case DisplayDensity.cosy:
                            maxHeight = 565;
                            break;
                        case DisplayDensity.compact:
                            maxHeight = 405;
                            break;
                        default: break;
                    }
                    return maxHeight + "px";
                }
            },
            /**
             * Sets the maximum height.
             */
            set: function (value) {
                this._maxHeight = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "grid", {
            /**
             * @hidden @internal
             */
            get: function () {
                var _a, _b, _c;
                return (_b = (_a = this.column) === null || _a === void 0 ? void 0 : _a.grid) !== null && _b !== void 0 ? _b : (_c = this.gridAPI) === null || _c === void 0 ? void 0 : _c.grid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "displayDensity", {
            /**
             * @hidden @internal
             */
            get: function () {
                var _a;
                return (_a = this.grid) === null || _a === void 0 ? void 0 : _a.displayDensity;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.selectedClass = function () {
            return this.column.selected ? 'igx-excel-filter__actions-selected' : 'igx-excel-filter__actions-select';
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.initialize = function (column, overlayService, overlayComponentId) {
            var _this = this;
            this.inline = false;
            this.column = column;
            this.overlayService = overlayService;
            this.overlayComponentId = overlayComponentId;
            if (this._originalDisplay) {
                this.element.nativeElement.style.display = this._originalDisplay;
            }
            this.initialized.emit();
            this.grid.onColumnMoving.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                _this.closeDropdown();
            });
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.onPin = function () {
            this.column.pinned = !this.column.pinned;
            this.closeDropdown();
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.onSelect = function () {
            if (!this.column.selected) {
                this.grid.selectionService.selectColumn(this.column.field, this.grid.columnSelection === GridSelectionMode.single);
            }
            else {
                this.grid.selectionService.deselectColumn(this.column.field);
            }
            this.grid.notifyChanges();
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.columnSelectable = function () {
            var _a, _b;
            return ((_a = this.grid) === null || _a === void 0 ? void 0 : _a.columnSelection) !== GridSelectionMode.none && ((_b = this.column) === null || _b === void 0 ? void 0 : _b.selectable);
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.onHideToggle = function () {
            this.column.toggleVisibility();
            this.closeDropdown();
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.cancel = function () {
            if (!this.overlayComponentId) {
                this.init();
            }
            this.closeDropdown();
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.closeDropdown = function () {
            if (this.overlayComponentId) {
                this.overlayService.hide(this.overlayComponentId);
                this.overlayComponentId = null;
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.onKeyDown = function (eventArgs) {
            if (eventArgs.key === "Escape" /* ESCAPE */ || eventArgs.key === "Esc" /* ESCAPE_IE */ ||
                eventArgs.ctrlKey && eventArgs.shiftKey && eventArgs.key.toLowerCase() === 'l') {
                this.closeDropdown();
            }
            eventArgs.stopPropagation();
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.hide = function () {
            this._originalDisplay = document.defaultView.getComputedStyle(this.element.nativeElement).display;
            this.element.nativeElement.style.display = 'none';
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.detectChanges = function () {
            this.cdr.detectChanges();
        };
        IgxGridExcelStyleFilteringComponent.prototype.init = function () {
            this.expressionsList = new Array();
            this.filteringService.generateExpressionsList(this.column.filteringExpressionsTree, this.grid.filteringLogic, this.expressionsList);
            this.populateColumnData();
        };
        IgxGridExcelStyleFilteringComponent.prototype.areExpressionsSelectable = function () {
            if (this.expressionsList.length === 1 &&
                (this.expressionsList[0].expression.condition.name === 'equals' ||
                    this.expressionsList[0].expression.condition.name === 'true' ||
                    this.expressionsList[0].expression.condition.name === 'false' ||
                    this.expressionsList[0].expression.condition.name === 'empty' ||
                    this.expressionsList[0].expression.condition.name === 'in')) {
                return true;
            }
            var selectableExpressionsCount = this.expressionsList.filter(function (exp) { return (exp.beforeOperator === 1 || exp.afterOperator === 1) &&
                (exp.expression.condition.name === 'equals' ||
                    exp.expression.condition.name === 'true' ||
                    exp.expression.condition.name === 'false' ||
                    exp.expression.condition.name === 'empty' ||
                    exp.expression.condition.name === 'in'); }).length;
            return selectableExpressionsCount === this.expressionsList.length;
        };
        IgxGridExcelStyleFilteringComponent.prototype.areExpressionsValuesInTheList = function () {
            var e_1, _d;
            if (this.column.dataType === DataType.Boolean) {
                return true;
            }
            if (this.filterValues.size === 1) {
                var firstValue = this.filterValues.values().next().value;
                if (!firstValue && firstValue !== 0) {
                    return true;
                }
            }
            try {
                for (var _e = __values(this.uniqueValues), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var expression = _f.value;
                    var value = this.getExpressionValue(expression);
                    if (this.filterValues.has(value)) {
                        return true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_d = _e.return)) _d.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return false;
        };
        IgxGridExcelStyleFilteringComponent.prototype.populateColumnData = function () {
            if (this.grid.uniqueColumnValuesStrategy) {
                this.cdr.detectChanges();
                this.renderColumnValuesRemotely();
            }
            else {
                this.renderColumnValuesFromData();
            }
        };
        IgxGridExcelStyleFilteringComponent.prototype.renderColumnValuesRemotely = function () {
            var _this = this;
            this.loadingStart.emit();
            var expressionsTree = this.getColumnFilterExpressionsTree();
            var prevColumn = this.column;
            this.grid.uniqueColumnValuesStrategy(this.column, expressionsTree, function (colVals) {
                if (!_this.column || _this.column !== prevColumn) {
                    return;
                }
                var columnValues = (_this.column.dataType === DataType.Date) ?
                    colVals.map(function (value) {
                        var label = _this.getFilterItemLabel(value);
                        return { label: label, value: value };
                    }) : colVals;
                _this.renderValues(columnValues);
                _this.loadingEnd.emit();
            });
        };
        IgxGridExcelStyleFilteringComponent.prototype.shouldFormatValues = function () {
            return this.column.formatter &&
                (this.grid.filterStrategy instanceof FormattedValuesFilteringStrategy ||
                    this.grid.filterStrategy instanceof TreeGridFormattedValuesFilteringStrategy) &&
                this.grid.filterStrategy.shouldApplyFormatter(this.column.field);
        };
        IgxGridExcelStyleFilteringComponent.prototype.renderColumnValuesFromData = function () {
            var _this = this;
            var expressionsTree = this.getColumnFilterExpressionsTree();
            var data = this.column.gridAPI.filterDataByExpressions(expressionsTree);
            var shouldFormatValues = this.shouldFormatValues();
            var columnField = this.column.field;
            var columnValues = (this.column.dataType === DataType.Date) ?
                data.map(function (record) {
                    var value = (resolveNestedPath(record, columnField));
                    var label = _this.getFilterItemLabel(value);
                    return { label: label, value: value };
                }) : data.map(function (record) {
                var value = resolveNestedPath(record, columnField);
                return shouldFormatValues ? _this.column.formatter(value) : value;
            });
            this.renderValues(columnValues);
        };
        IgxGridExcelStyleFilteringComponent.prototype.renderValues = function (columnValues) {
            this.generateUniqueValues(columnValues);
            this.generateFilterValues(this.column.dataType === DataType.Date);
            this.generateListData();
        };
        IgxGridExcelStyleFilteringComponent.prototype.generateUniqueValues = function (columnValues) {
            if (this.column.dataType === DataType.String && this.column.filteringIgnoreCase) {
                var filteredUniqueValues = columnValues.map(function (s) { return s === null || s === void 0 ? void 0 : s.toString().toLowerCase(); })
                    .reduce(function (map, val, i) { return map.get(val) ? map : map.set(val, columnValues[i]); }, new Map());
                this.uniqueValues = Array.from(filteredUniqueValues.values());
            }
            else {
                this.uniqueValues = this.column.dataType === DataType.Date ? uniqueDates(columnValues) : Array.from(new Set(columnValues));
            }
        };
        IgxGridExcelStyleFilteringComponent.prototype.generateFilterValues = function (isDateColumn) {
            if (isDateColumn === void 0) { isDateColumn = false; }
            if (isDateColumn) {
                this.filterValues = new Set(this.expressionsList.reduce(function (arr, e) {
                    if (e.expression.condition.name === 'in') {
                        return __spread(arr, Array.from(e.expression.searchVal.values()).map(function (v) { return new Date(v).toISOString(); }));
                    }
                    return __spread(arr, [e.expression.searchVal ? e.expression.searchVal.toISOString() : e.expression.searchVal]);
                }, []));
            }
            else {
                this.filterValues = new Set(this.expressionsList.reduce(function (arr, e) {
                    if (e.expression.condition.name === 'in') {
                        return __spread(arr, Array.from(e.expression.searchVal.values()));
                    }
                    return __spread(arr, [e.expression.searchVal]);
                }, []));
            }
        };
        IgxGridExcelStyleFilteringComponent.prototype.generateListData = function () {
            var _this = this;
            this.listData = new Array();
            var shouldUpdateSelection = this.areExpressionsSelectable() && this.areExpressionsValuesInTheList();
            if (this.column.dataType === DataType.Boolean) {
                this.addBooleanItems();
            }
            else {
                this.addItems(shouldUpdateSelection);
            }
            this.listData.sort(function (a, b) { return _this.sortData(a, b); });
            if (this.containsNullOrEmpty) {
                this.addBlanksItem(shouldUpdateSelection);
            }
            if (this.listData.length > 0) {
                this.addSelectAllItem();
            }
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
            this.listDataLoaded.emit();
        };
        IgxGridExcelStyleFilteringComponent.prototype.getColumnFilterExpressionsTree = function () {
            var e_2, _d;
            var gridExpressionsTree = this.grid.filteringExpressionsTree;
            var expressionsTree = new FilteringExpressionsTree(gridExpressionsTree.operator, gridExpressionsTree.fieldName);
            try {
                for (var _e = __values(gridExpressionsTree.filteringOperands), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var operand = _f.value;
                    if (operand instanceof FilteringExpressionsTree) {
                        var columnExprTree = operand;
                        if (columnExprTree.fieldName === this.column.field) {
                            break;
                        }
                    }
                    expressionsTree.filteringOperands.push(operand);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_d = _e.return)) _d.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return expressionsTree;
        };
        IgxGridExcelStyleFilteringComponent.prototype.addBooleanItems = function () {
            var _this = this;
            this.selectAllSelected = true;
            this.selectAllIndeterminate = false;
            this.uniqueValues.forEach(function (element) {
                var filterListItem = new FilterListItem();
                if (element !== undefined && element !== null && element !== '') {
                    if (_this.column.filteringExpressionsTree) {
                        if (element === true && _this.expressionsList.find(function (exp) { return exp.expression.condition.name === 'true'; })) {
                            filterListItem.isSelected = true;
                            filterListItem.isFiltered = true;
                            _this.selectAllIndeterminate = true;
                        }
                        else if (element === false && _this.expressionsList.find(function (exp) { return exp.expression.condition.name === 'false'; })) {
                            filterListItem.isSelected = true;
                            filterListItem.isFiltered = true;
                            _this.selectAllIndeterminate = true;
                        }
                        else {
                            filterListItem.isSelected = false;
                            filterListItem.isFiltered = false;
                        }
                    }
                    else {
                        filterListItem.isSelected = true;
                        filterListItem.isFiltered = true;
                    }
                    filterListItem.value = element;
                    filterListItem.label = element ?
                        _this.grid.resourceStrings.igx_grid_filter_true :
                        _this.grid.resourceStrings.igx_grid_filter_false;
                    filterListItem.indeterminate = false;
                    _this.listData.push(filterListItem);
                }
                else {
                    _this.containsNullOrEmpty = true;
                }
            });
        };
        IgxGridExcelStyleFilteringComponent.prototype.addItems = function (shouldUpdateSelection) {
            var _this = this;
            this.selectAllSelected = true;
            this.containsNullOrEmpty = false;
            this.selectAllIndeterminate = false;
            var applyFormatter = !this.shouldFormatValues();
            this.uniqueValues.forEach(function (element) {
                var hasValue = (element !== undefined && element !== null && element !== '' && _this.column.dataType !== DataType.Date)
                    || !!(element && element.label);
                if (hasValue) {
                    var filterListItem = new FilterListItem();
                    filterListItem.isSelected = true;
                    filterListItem.isFiltered = true;
                    if (_this.column.filteringExpressionsTree) {
                        filterListItem.isSelected = false;
                        filterListItem.isFiltered = false;
                        if (shouldUpdateSelection) {
                            var value = _this.getExpressionValue(element);
                            if (_this.filterValues.has(value)) {
                                filterListItem.isSelected = true;
                                filterListItem.isFiltered = true;
                            }
                            _this.selectAllIndeterminate = true;
                        }
                        else {
                            _this.selectAllSelected = false;
                        }
                    }
                    filterListItem.value = _this.getFilterItemValue(element);
                    filterListItem.label = _this.getFilterItemLabel(element, applyFormatter);
                    filterListItem.indeterminate = false;
                    _this.listData.push(filterListItem);
                }
            });
            this.containsNullOrEmpty = this.uniqueValues.length > this.listData.length;
        };
        IgxGridExcelStyleFilteringComponent.prototype.addSelectAllItem = function () {
            var selectAll = new FilterListItem();
            selectAll.isSelected = this.selectAllSelected;
            selectAll.value = this.grid.resourceStrings.igx_grid_excel_select_all;
            selectAll.label = this.grid.resourceStrings.igx_grid_excel_select_all;
            selectAll.indeterminate = this.selectAllIndeterminate;
            selectAll.isSpecial = true;
            selectAll.isFiltered = this.selectAllSelected;
            this.listData.unshift(selectAll);
        };
        IgxGridExcelStyleFilteringComponent.prototype.addBlanksItem = function (shouldUpdateSelection) {
            var blanks = new FilterListItem();
            if (this.column.filteringExpressionsTree) {
                if (shouldUpdateSelection) {
                    if (this.filterValues.has(null)) {
                        blanks.isSelected = true;
                        blanks.isFiltered = true;
                    }
                    else {
                        blanks.isSelected = false;
                        blanks.isFiltered = false;
                    }
                }
            }
            else {
                blanks.isSelected = true;
                blanks.isFiltered = true;
            }
            blanks.value = null;
            blanks.label = this.grid.resourceStrings.igx_grid_excel_blanks;
            blanks.indeterminate = false;
            blanks.isSpecial = true;
            blanks.isBlanks = true;
            this.listData.unshift(blanks);
        };
        IgxGridExcelStyleFilteringComponent.prototype.sortData = function (a, b) {
            var valueA = a.value;
            var valueB = b.value;
            if (typeof (a) === DataType.String) {
                valueA = a.value.toUpperCase();
                valueB = b.value.toUpperCase();
            }
            if (valueA < valueB) {
                return -1;
            }
            else if (valueA > valueB) {
                return 1;
            }
            else {
                return 0;
            }
        };
        IgxGridExcelStyleFilteringComponent.prototype.getFilterItemLabel = function (element, applyFormatter) {
            if (applyFormatter === void 0) { applyFormatter = true; }
            if (this.column.dataType === DataType.Date) {
                return element && element.label ? element.label : this.column.formatter ?
                    applyFormatter ? this.column.formatter(element) : element :
                    this.grid.datePipe.transform(element, this.column.pipeArgs.format, this.column.pipeArgs.timezone, this.grid.locale);
            }
            if (this.column.dataType === DataType.Number) {
                return this.column.formatter ?
                    applyFormatter ? this.column.formatter(element) : element :
                    this.grid.decimalPipe.transform(element, this.column.pipeArgs.digitsInfo, this.grid.locale);
            }
            if (this.column.dataType === DataType.Currency) {
                return this.column.formatter ?
                    applyFormatter ? this.column.formatter(element) : element :
                    this.grid.currencyPipe.transform(element, this.column.pipeArgs.currencyCode ?
                        this.column.pipeArgs.currencyCode : i2.getLocaleCurrencyCode(this.grid.locale), this.column.pipeArgs.display, this.column.pipeArgs.digitsInfo, this.grid.locale);
            }
            if (this.column.dataType === DataType.Percent) {
                return this.column.formatter ?
                    applyFormatter ? this.column.formatter(element) : element :
                    this.grid.percentPipe.transform(element, this.column.pipeArgs.digitsInfo, this.grid.locale);
            }
            return this.column.formatter && applyFormatter ?
                this.column.formatter(element) :
                element;
        };
        IgxGridExcelStyleFilteringComponent.prototype.getFilterItemValue = function (element) {
            if (this.column.dataType === DataType.Date) {
                element = parseDate(element.value);
            }
            return element;
        };
        IgxGridExcelStyleFilteringComponent.prototype.getExpressionValue = function (element) {
            var value;
            if (this.column.dataType === DataType.Date) {
                value = element && element.value ? new Date(element.value).toISOString() : element.value;
            }
            else {
                value = element;
            }
            return value;
        };
        return IgxGridExcelStyleFilteringComponent;
    }());
    IgxGridExcelStyleFilteringComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-excel-style-filtering',
                    template: "<ng-template #defaultExcelColumnOperations>\n    <igx-excel-style-header\n        [showHiding]=\"displayDensity !== 'comfortable' && !column?.disableHiding\"\n        [showPinning]=\"displayDensity !== 'comfortable' && !column?.disablePinning\"\n        [showSelecting]=\"displayDensity !== 'comfortable' && columnSelectable()\"\n    >\n    </igx-excel-style-header>\n\n    <igx-excel-style-sorting *ngIf=\"column?.sortable\">\n    </igx-excel-style-sorting>\n\n    <igx-excel-style-moving *ngIf=\"column?.movable\">\n    </igx-excel-style-moving>\n\n    <igx-excel-style-pinning *ngIf=\"!column?.disablePinning && displayDensity==='comfortable'\">\n    </igx-excel-style-pinning>\n\n    <igx-excel-style-hiding *ngIf=\"!column?.disableHiding && displayDensity==='comfortable'\">\n    </igx-excel-style-hiding>\n\n    <igx-excel-style-selecting *ngIf=\"columnSelectable() && displayDensity==='comfortable'\">\n    </igx-excel-style-selecting>\n</ng-template>\n\n<ng-template #defaultExcelFilterOperations>\n    <igx-excel-style-clear-filters>\n    </igx-excel-style-clear-filters>\n\n    <igx-excel-style-conditional-filter>\n    </igx-excel-style-conditional-filter>\n\n    <igx-excel-style-search>\n    </igx-excel-style-search>\n</ng-template>\n\n<article #mainDropdown\n    class=\"igx-excel-filter__menu\"\n    [ngClass]=\"{\n        'igx-excel-filter__menu--cosy': displayDensity === 'cosy',\n        'igx-excel-filter__menu--compact': displayDensity === 'compact'\n    }\"\n    [id]=\"overlayComponentId\"\n    (keydown)=\"onKeyDown($event)\"\n    [style.min-height]=\"minHeight\"\n    [style.max-height]=\"maxHeight\">\n\n    <ng-container *ngIf=\"this.excelColumnOperationsDirective; else defaultExcelColumnOperations\">\n        <ng-content select=\"igx-excel-style-column-operations,[igxExcelStyleColumnOperations]\">\n        </ng-content>\n    </ng-container>\n\n    <ng-container *ngIf=\"this.excelFilterOperationsDirective; else defaultExcelFilterOperations\">\n        <ng-content select=\"igx-excel-style-filter-operations,[igxExcelStyleFilterOperations]\">\n        </ng-content>\n    </ng-container>\n</article>\n"
                },] }
    ];
    IgxGridExcelStyleFilteringComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef },
        { type: i0.ElementRef },
        { type: GridBaseAPIService, decorators: [{ type: i0.Host }, { type: i0.Optional }] }
    ]; };
    IgxGridExcelStyleFilteringComponent.propDecorators = {
        defaultClass: [{ type: i0.HostBinding, args: ['class.igx-excel-filter',] }],
        inline: [{ type: i0.HostBinding, args: ['class.igx-excel-filter--inline',] }],
        loadingStart: [{ type: i0.Output }],
        loadingEnd: [{ type: i0.Output }],
        initialized: [{ type: i0.Output }],
        sortingChanged: [{ type: i0.Output }],
        columnChange: [{ type: i0.Output }],
        listDataLoaded: [{ type: i0.Output }],
        mainDropdown: [{ type: i0.ViewChild, args: ['mainDropdown', { read: i0.ElementRef },] }],
        excelColumnOperationsDirective: [{ type: i0.ContentChild, args: [IgxExcelStyleColumnOperationsTemplateDirective, { read: IgxExcelStyleColumnOperationsTemplateDirective },] }],
        excelFilterOperationsDirective: [{ type: i0.ContentChild, args: [IgxExcelStyleFilterOperationsTemplateDirective, { read: IgxExcelStyleFilterOperationsTemplateDirective },] }],
        defaultExcelColumnOperations: [{ type: i0.ViewChild, args: ['defaultExcelColumnOperations', { read: i0.TemplateRef, static: true },] }],
        defaultExcelFilterOperations: [{ type: i0.ViewChild, args: ['defaultExcelFilterOperations', { read: i0.TemplateRef, static: true },] }],
        column: [{ type: i0.Input }],
        minHeight: [{ type: i0.Input }],
        maxHeight: [{ type: i0.Input }, { type: i0.HostBinding, args: ['style.max-height',] }]
    };

    /**
     * A component used for presenting Excel style clear filters UI.
     */
    var IgxExcelStyleClearFiltersComponent = /** @class */ (function () {
        function IgxExcelStyleClearFiltersComponent(esf) {
            this.esf = esf;
        }
        /**
         * @hidden @internal
         */
        IgxExcelStyleClearFiltersComponent.prototype.clearFilterClass = function () {
            if (this.esf.column.filteringExpressionsTree) {
                return 'igx-excel-filter__actions-clear';
            }
            return 'igx-excel-filter__actions-clear--disabled';
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleClearFiltersComponent.prototype.clearFilter = function () {
            this.esf.grid.filteringService.clearFilter(this.esf.column.field);
            this.selectAllFilterItems();
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleClearFiltersComponent.prototype.onClearFilterKeyDown = function (eventArgs) {
            if (eventArgs.key === "Enter" /* ENTER */) {
                this.clearFilter();
            }
        };
        IgxExcelStyleClearFiltersComponent.prototype.selectAllFilterItems = function () {
            this.esf.listData.forEach(function (filterListItem) {
                filterListItem.isSelected = true;
                filterListItem.indeterminate = false;
            });
            this.esf.detectChanges();
        };
        return IgxExcelStyleClearFiltersComponent;
    }());
    IgxExcelStyleClearFiltersComponent.decorators = [
        { type: i0.Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-clear-filters',
                    template: "<div *ngIf=\"esf.column\"\n    tabindex=\"0\"\n    [ngClass]=\"clearFilterClass()\"\n    (keydown)=\"onClearFilterKeyDown($event)\"\n    (click)=\"clearFilter()\">\n    <span>{{ esf.grid.resourceStrings.igx_grid_excel_filter_clear }}</span>\n    <igx-icon>clear</igx-icon>\n</div>\n"
                },] }
    ];
    IgxExcelStyleClearFiltersComponent.ctorParameters = function () { return [
        { type: IgxGridExcelStyleFilteringComponent }
    ]; };

    /** @hidden */
    var ExcelStylePositionStrategy = /** @class */ (function (_super) {
        __extends(ExcelStylePositionStrategy, _super);
        function ExcelStylePositionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ExcelStylePositionStrategy.prototype.shouldFitInViewPort = function () {
            return true;
        };
        ExcelStylePositionStrategy.prototype.fitInViewport = function (element, connectedFit) {
            var heightOverflow = connectedFit.contentElementRect.height - connectedFit.viewPortRect.height;
            if (heightOverflow > 0) {
                element.style.width = 'auto';
                element.style.height = connectedFit.viewPortRect.height + "px";
            }
            else {
                element.style.height = Math.max(connectedFit.viewPortRect.height - connectedFit.targetRect.bottom - 1, connectedFit.contentElementRect.height) + "px";
            }
            _super.prototype.fitInViewport.call(this, element, connectedFit);
        };
        return ExcelStylePositionStrategy;
    }(AutoPositionStrategy));

    /**
     * @hidden
     */
    var ExpressionUI = /** @class */ (function () {
        function ExpressionUI() {
            this.isSelected = false;
            this.isVisible = true;
        }
        return ExpressionUI;
    }());
    /**
     * @hidden
     */
    var IgxFilteringService = /** @class */ (function () {
        function IgxFilteringService(_moduleRef, iconService, _overlayService) {
            this._moduleRef = _moduleRef;
            this.iconService = iconService;
            this._overlayService = _overlayService;
            this.isFilterRowVisible = false;
            this.filteredColumn = null;
            this.selectedExpression = null;
            this.columnToMoreIconHidden = new Map();
            this.activeFilterCell = 0;
            this.columnsWithComplexFilter = new Set();
            this.areEventsSubscribed = false;
            this.destroy$ = new rxjs.Subject();
            this.isFiltering = false;
            this.columnToExpressionsMap = new Map();
            this.columnStartIndex = -1;
        }
        IgxFilteringService.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        IgxFilteringService.prototype.toggleFilterDropdown = function (element, column, classRef) {
            if (!this._componentOverlayId || (this.column && this.column.field !== column.field)) {
                this.initFilteringSettings();
                this.column = column;
                var filterIcon = this.column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';
                var filterIconTarget = element.querySelector('.' + filterIcon);
                this._filterMenuOverlaySettings.target = filterIconTarget;
                this._filterMenuOverlaySettings.outlet = this.grid.outlet;
                if (this.grid.excelStyleFilteringComponent) {
                    this._componentOverlayId =
                        this._overlayService.attach(this.grid.excelStyleFilteringComponent.element, this._filterMenuOverlaySettings);
                }
                else {
                    this._componentOverlayId =
                        this._overlayService.attach(classRef, this._filterMenuOverlaySettings, this._moduleRef);
                }
                this._overlayService.show(this._componentOverlayId, this._filterMenuOverlaySettings);
            }
        };
        IgxFilteringService.prototype.initFilteringSettings = function () {
            var _this = this;
            this._filterMenuPositionSettings = {
                verticalStartPoint: exports.VerticalAlignment.Bottom,
                openAnimation: i1.useAnimation(fadeIn, { params: { duration: '250ms' } }),
                closeAnimation: null
            };
            this._filterMenuOverlaySettings = {
                closeOnOutsideClick: true,
                modal: false,
                positionStrategy: new ExcelStylePositionStrategy(this._filterMenuPositionSettings),
                scrollStrategy: new AbsoluteScrollStrategy()
            };
            this._overlayService.onOpening.pipe(operators.first(function (overlay) { return overlay.id === _this._componentOverlayId; }), operators.takeUntil(this.destroy$)).subscribe(function (eventArgs) {
                var instance = _this.grid.excelStyleFilteringComponent ?
                    _this.grid.excelStyleFilteringComponent :
                    eventArgs.componentRef.instance;
                if (instance) {
                    _this.lastActiveNode = _this.grid.navigation.activeNode;
                    instance.initialize(_this.column, _this._overlayService, eventArgs.id);
                }
            });
            this._overlayService.onClosed.pipe(operators.first(function (overlay) { return overlay.id === _this._componentOverlayId; }), operators.takeUntil(this.destroy$)).subscribe(function (eventArgs) {
                var instance = _this.grid.excelStyleFilteringComponent ?
                    _this.grid.excelStyleFilteringComponent :
                    eventArgs.componentRef.instance;
                if (instance) {
                    instance.column = null;
                }
                _this._componentOverlayId = null;
                _this.grid.navigation.activeNode = _this.lastActiveNode;
                _this.grid.theadRow.nativeElement.focus();
            });
        };
        IgxFilteringService.prototype.hideExcelFiltering = function () {
            if (this._componentOverlayId) {
                this._overlayService.hide(this._componentOverlayId);
            }
        };
        /**
         * Subscribe to grid's events.
         */
        IgxFilteringService.prototype.subscribeToEvents = function () {
            var _this = this;
            if (!this.areEventsSubscribed) {
                this.areEventsSubscribed = true;
                this.grid.onColumnResized.pipe(operators.takeUntil(this.destroy$)).subscribe(function (eventArgs) {
                    _this.updateFilteringCell(eventArgs.column);
                });
                this.grid.parentVirtDir.onChunkLoad.pipe(operators.takeUntil(this.destroy$)).subscribe(function (eventArgs) {
                    if (eventArgs.startIndex !== _this.columnStartIndex) {
                        _this.columnStartIndex = eventArgs.startIndex;
                        _this.grid.filterCellList.forEach(function (filterCell) {
                            filterCell.updateFilterCellArea();
                        });
                    }
                });
                this.grid.onColumnMovingEnd.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                    _this.grid.filterCellList.forEach(function (filterCell) {
                        filterCell.updateFilterCellArea();
                    });
                });
            }
        };
        /**
         * Close filtering row if a column is hidden.
         */
        IgxFilteringService.prototype.hideFilteringRowOnColumnVisibilityChange = function (col) {
            var filteringRow = this.grid.filteringRow;
            if (filteringRow && filteringRow.column && filteringRow.column === col) {
                filteringRow.close();
            }
        };
        /**
         * Internal method to create expressionsTree and filter grid used in both filter modes.
         */
        IgxFilteringService.prototype.filterInternal = function (field, expressions) {
            if (expressions === void 0) { expressions = null; }
            this.isFiltering = true;
            var expressionsTree;
            if (expressions instanceof FilteringExpressionsTree) {
                expressionsTree = expressions;
            }
            else {
                expressionsTree = this.createSimpleFilteringTree(field, expressions);
            }
            if (expressionsTree.filteringOperands.length === 0) {
                this.clearFilter(field);
            }
            else {
                this.filter(field, null, expressionsTree);
            }
            this.isFiltering = false;
        };
        /**
         * Execute filtering on the grid.
         */
        IgxFilteringService.prototype.filter = function (field, value, conditionOrExpressionTree, ignoreCase) {
            var _this = this;
            var grid = this.grid;
            var col = grid.getColumnByName(field);
            var filteringIgnoreCase = ignoreCase || (col ? col.filteringIgnoreCase : false);
            var filteringTree = grid.filteringExpressionsTree;
            var columnFilteringExpressionsTree = grid.filteringExpressionsTree.find(field);
            conditionOrExpressionTree = conditionOrExpressionTree !== null && conditionOrExpressionTree !== void 0 ? conditionOrExpressionTree : columnFilteringExpressionsTree;
            var fieldFilterIndex = filteringTree.findIndex(field);
            if (fieldFilterIndex > -1) {
                filteringTree.filteringOperands.splice(fieldFilterIndex, 1);
            }
            var newFilteringTree = this.prepare_filtering_expression(filteringTree, field, value, conditionOrExpressionTree, filteringIgnoreCase, fieldFilterIndex, true);
            var eventArgs = { owner: grid, filteringExpressions: newFilteringTree.find(field), cancel: false };
            this.grid.filtering.emit(eventArgs);
            if (eventArgs.cancel) {
                return;
            }
            if (conditionOrExpressionTree) {
                this.filter_internal(field, value, conditionOrExpressionTree, filteringIgnoreCase);
            }
            else {
                var expressionsTreeForColumn = this.grid.filteringExpressionsTree.find(field);
                if (!expressionsTreeForColumn) {
                    throw new Error('Invalid condition or Expression Tree!');
                }
                else if (expressionsTreeForColumn instanceof FilteringExpressionsTree) {
                    this.filter_internal(field, value, expressionsTreeForColumn, filteringIgnoreCase);
                }
                else {
                    var expressionForColumn = expressionsTreeForColumn;
                    this.filter_internal(field, value, expressionForColumn.condition, filteringIgnoreCase);
                }
            }
            var doneEventArgs = this.grid.filteringExpressionsTree.find(field);
            // Wait for the change detection to update filtered data through the pipes and then emit the event.
            requestAnimationFrame(function () { return _this.grid.onFilteringDone.emit(doneEventArgs); });
        };
        IgxFilteringService.prototype.filter_global = function (term, condition, ignoreCase) {
            var e_1, _a;
            if (!condition) {
                return;
            }
            var grid = this.grid;
            var filteringTree = grid.filteringExpressionsTree;
            grid.endEdit(false);
            if (grid.paging) {
                grid.page = 0;
            }
            filteringTree.filteringOperands = [];
            try {
                for (var _b = __values(grid.columns), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var column = _c.value;
                    this.prepare_filtering_expression(filteringTree, column.field, term, condition, ignoreCase || column.filteringIgnoreCase);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            grid.filteringExpressionsTree = filteringTree;
        };
        /**
         * Clears the filter of a given column if name is provided. Otherwise clears the filters of all columns.
         */
        IgxFilteringService.prototype.clearFilter = function (field) {
            var _this = this;
            if (field) {
                var column = this.grid.getColumnByName(field);
                if (!column) {
                    return;
                }
            }
            var onFilteringEventArgs = {
                owner: this.grid,
                filteringExpressions: null,
                cancel: false
            };
            this.grid.filtering.emit(onFilteringEventArgs);
            if (onFilteringEventArgs.cancel) {
                return;
            }
            this.isFiltering = true;
            this.clear_filter(field);
            // Wait for the change detection to update filtered data through the pipes and then emit the event.
            requestAnimationFrame(function () { return _this.grid.onFilteringDone.emit(null); });
            if (field) {
                var expressions = this.getExpressions(field);
                expressions.length = 0;
            }
            else {
                this.grid.columns.forEach(function (c) {
                    var expressions = _this.getExpressions(c.field);
                    expressions.length = 0;
                });
            }
            this.isFiltering = false;
        };
        IgxFilteringService.prototype.clear_filter = function (fieldName) {
            var grid = this.grid;
            grid.endEdit(false);
            var filteringState = grid.filteringExpressionsTree;
            var index = filteringState.findIndex(fieldName);
            if (index > -1) {
                filteringState.filteringOperands.splice(index, 1);
            }
            else if (!fieldName) {
                filteringState.filteringOperands = [];
            }
            grid.filteringExpressionsTree = filteringState;
        };
        /**
         * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
         */
        IgxFilteringService.prototype.filterGlobal = function (value, condition, ignoreCase) {
            var e_2, _a;
            var _this = this;
            if (!condition) {
                return;
            }
            var grid = this.grid;
            var filteringTree = grid.filteringExpressionsTree;
            var newFilteringTree = new FilteringExpressionsTree(filteringTree.operator, filteringTree.fieldName);
            try {
                for (var _b = __values(grid.columns), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var column = _c.value;
                    this.prepare_filtering_expression(newFilteringTree, column.field, value, condition, ignoreCase || column.filteringIgnoreCase);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var eventArgs = { owner: grid, filteringExpressions: newFilteringTree, cancel: false };
            grid.filtering.emit(eventArgs);
            if (eventArgs.cancel) {
                return;
            }
            grid.endEdit(false);
            if (grid.paging) {
                grid.page = 0;
            }
            grid.filteringExpressionsTree = newFilteringTree;
            // Wait for the change detection to update filtered data through the pipes and then emit the event.
            requestAnimationFrame(function () { return _this.grid.onFilteringDone.emit(_this.grid.filteringExpressionsTree); });
        };
        /**
         * Register filtering SVG icons in the icon service.
         */
        IgxFilteringService.prototype.registerSVGIcons = function () {
            var _this = this;
            var editorIcons = materialIconsExtended.editor;
            editorIcons.forEach(function (icon) { return _this.iconService.addSvgIconFromText(icon.name, icon.value, 'imx-icons'); });
            this.iconService.addSvgIconFromText(materialIconsExtended.pinLeft.name, materialIconsExtended.pinLeft.value, 'imx-icons');
            this.iconService.addSvgIconFromText(materialIconsExtended.unpinLeft.name, materialIconsExtended.unpinLeft.value, 'imx-icons');
        };
        /**
         * Returns the ExpressionUI array for a given column.
         */
        IgxFilteringService.prototype.getExpressions = function (columnId) {
            if (!this.columnToExpressionsMap.has(columnId)) {
                var column = this.grid.columns.find(function (col) { return col.field === columnId; });
                var expressionUIs = new Array();
                if (column) {
                    this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, expressionUIs);
                    this.columnToExpressionsMap.set(columnId, expressionUIs);
                }
                return expressionUIs;
            }
            return this.columnToExpressionsMap.get(columnId);
        };
        /**
         * Recreates all ExpressionUIs for all columns. Executed after filtering to refresh the cache.
         */
        IgxFilteringService.prototype.refreshExpressions = function () {
            var _this = this;
            if (!this.isFiltering) {
                this.columnsWithComplexFilter.clear();
                this.columnToExpressionsMap.forEach(function (value, key) {
                    var column = _this.grid.columns.find(function (col) { return col.field === key; });
                    if (column) {
                        value.length = 0;
                        _this.generateExpressionsList(column.filteringExpressionsTree, _this.grid.filteringExpressionsTree.operator, value);
                        var isComplex = _this.isFilteringTreeComplex(column.filteringExpressionsTree);
                        if (isComplex) {
                            _this.columnsWithComplexFilter.add(key);
                        }
                        _this.updateFilteringCell(column);
                    }
                    else {
                        _this.columnToExpressionsMap.delete(key);
                    }
                });
            }
        };
        /**
         * Remove an ExpressionUI for a given column.
         */
        IgxFilteringService.prototype.removeExpression = function (columnId, indexToRemove) {
            var expressionsList = this.getExpressions(columnId);
            if (indexToRemove === 0 && expressionsList.length > 1) {
                expressionsList[1].beforeOperator = null;
            }
            else if (indexToRemove === expressionsList.length - 1) {
                expressionsList[indexToRemove - 1].afterOperator = null;
            }
            else {
                expressionsList[indexToRemove - 1].afterOperator = expressionsList[indexToRemove + 1].beforeOperator;
                expressionsList[0].beforeOperator = null;
                expressionsList[expressionsList.length - 1].afterOperator = null;
            }
            expressionsList.splice(indexToRemove, 1);
        };
        /**
         * Generate filtering tree for a given column from existing ExpressionUIs.
         */
        IgxFilteringService.prototype.createSimpleFilteringTree = function (columnId, expressionUIList) {
            var e_3, _a;
            if (expressionUIList === void 0) { expressionUIList = null; }
            var expressionsList = expressionUIList ? expressionUIList : this.getExpressions(columnId);
            var expressionsTree = new FilteringExpressionsTree(exports.FilteringLogic.Or, columnId);
            var currAndBranch;
            try {
                for (var expressionsList_1 = __values(expressionsList), expressionsList_1_1 = expressionsList_1.next(); !expressionsList_1_1.done; expressionsList_1_1 = expressionsList_1.next()) {
                    var currExpressionUI = expressionsList_1_1.value;
                    if (!currExpressionUI.expression.condition.isUnary && currExpressionUI.expression.searchVal === null) {
                        if (currExpressionUI.afterOperator === exports.FilteringLogic.And && !currAndBranch) {
                            currAndBranch = new FilteringExpressionsTree(exports.FilteringLogic.And, columnId);
                            expressionsTree.filteringOperands.push(currAndBranch);
                        }
                        continue;
                    }
                    if ((currExpressionUI.beforeOperator === undefined || currExpressionUI.beforeOperator === null ||
                        currExpressionUI.beforeOperator === exports.FilteringLogic.Or) &&
                        currExpressionUI.afterOperator === exports.FilteringLogic.And) {
                        currAndBranch = new FilteringExpressionsTree(exports.FilteringLogic.And, columnId);
                        expressionsTree.filteringOperands.push(currAndBranch);
                        currAndBranch.filteringOperands.push(currExpressionUI.expression);
                    }
                    else if (currExpressionUI.beforeOperator === exports.FilteringLogic.And) {
                        currAndBranch.filteringOperands.push(currExpressionUI.expression);
                    }
                    else {
                        expressionsTree.filteringOperands.push(currExpressionUI.expression);
                        currAndBranch = null;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (expressionsList_1_1 && !expressionsList_1_1.done && (_a = expressionsList_1.return)) _a.call(expressionsList_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return expressionsTree;
        };
        /**
         * Returns whether a complex filter is applied to a given column.
         */
        IgxFilteringService.prototype.isFilterComplex = function (columnId) {
            if (this.columnsWithComplexFilter.has(columnId)) {
                return true;
            }
            var column = this.grid.columns.find(function (col) { return col.field === columnId; });
            var isComplex = column && this.isFilteringTreeComplex(column.filteringExpressionsTree);
            if (isComplex) {
                this.columnsWithComplexFilter.add(columnId);
            }
            return isComplex;
        };
        /**
         * Returns the string representation of the FilteringLogic operator.
         */
        IgxFilteringService.prototype.getOperatorAsString = function (operator) {
            if (operator === 0) {
                return this.grid.resourceStrings.igx_grid_filter_operator_and;
            }
            else {
                return this.grid.resourceStrings.igx_grid_filter_operator_or;
            }
        };
        /**
         * Generate the label of a chip from a given filtering expression.
         */
        IgxFilteringService.prototype.getChipLabel = function (expression) {
            if (expression.condition.isUnary) {
                return this.grid.resourceStrings["igx_grid_filter_" + expression.condition.name] || expression.condition.name;
            }
            else if (expression.searchVal instanceof Date) {
                var column = this.grid.getColumnByName(expression.fieldName);
                var formatter = column.formatter;
                if (formatter) {
                    return formatter(expression.searchVal);
                }
                var pipeArgs = column.pipeArgs;
                return this.grid.datePipe.transform(expression.searchVal, pipeArgs.format, undefined, this.grid.locale);
            }
            else {
                return expression.searchVal;
            }
        };
        /**
         * Updates the content of a filterCell.
         */
        IgxFilteringService.prototype.updateFilteringCell = function (column) {
            var filterCell = column.filterCell;
            if (filterCell) {
                filterCell.updateFilterCellArea();
            }
        };
        Object.defineProperty(IgxFilteringService.prototype, "filteredData", {
            get: function () {
                return this.grid.filteredData;
            },
            enumerable: false,
            configurable: true
        });
        IgxFilteringService.prototype.generateExpressionsList = function (expressions, operator, expressionsUIs) {
            this.generateExpressionsListRecursive(expressions, operator, expressionsUIs);
            // The beforeOperator of the first expression and the afterOperator of the last expression should be null
            if (expressionsUIs.length) {
                expressionsUIs[expressionsUIs.length - 1].afterOperator = null;
            }
        };
        IgxFilteringService.prototype.isFilteringExpressionsTreeEmpty = function (expressionTree) {
            var e_4, _a;
            if (FilteringExpressionsTree.empty(expressionTree)) {
                return true;
            }
            try {
                for (var _b = __values(expressionTree.filteringOperands), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var expr = _c.value;
                    if ((expr instanceof FilteringExpressionsTree)) {
                        var exprTree = expr;
                        if (exprTree.filteringOperands && exprTree.filteringOperands.length) {
                            return false;
                        }
                    }
                    else {
                        return false;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
            return true;
        };
        IgxFilteringService.prototype.filter_internal = function (fieldName, term, conditionOrExpressionsTree, ignoreCase) {
            var grid = this.grid;
            var filteringTree = grid.filteringExpressionsTree;
            this.grid.endEdit(false);
            if (grid.paging) {
                grid.page = 0;
            }
            var fieldFilterIndex = filteringTree.findIndex(fieldName);
            if (fieldFilterIndex > -1) {
                filteringTree.filteringOperands.splice(fieldFilterIndex, 1);
            }
            this.prepare_filtering_expression(filteringTree, fieldName, term, conditionOrExpressionsTree, ignoreCase, fieldFilterIndex);
            grid.filteringExpressionsTree = filteringTree;
        };
        /** Modifies the filteringState object to contain the newly added fitering conditions/expressions.
         * If createNewTree is true, filteringState will not be modified (because it directly affects the grid.filteringExpressionsTree),
         * but a new object is created and returned.
         */
        IgxFilteringService.prototype.prepare_filtering_expression = function (filteringState, fieldName, searchVal, conditionOrExpressionsTree, ignoreCase, insertAtIndex, createNewTree) {
            if (insertAtIndex === void 0) { insertAtIndex = -1; }
            if (createNewTree === void 0) { createNewTree = false; }
            var oldExpressionsTreeIndex = filteringState.findIndex(fieldName);
            var expressionsTree = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
                conditionOrExpressionsTree : null;
            var condition = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
                null : conditionOrExpressionsTree;
            var newExpression = { fieldName: fieldName, searchVal: searchVal, condition: condition, ignoreCase: ignoreCase };
            var newExpressionsTree = createNewTree ?
                new FilteringExpressionsTree(filteringState.operator, filteringState.fieldName) : filteringState;
            if (oldExpressionsTreeIndex === -1) {
                // no expressions tree found for this field
                if (expressionsTree) {
                    if (insertAtIndex > -1) {
                        newExpressionsTree.filteringOperands.splice(insertAtIndex, 0, expressionsTree);
                    }
                    else {
                        newExpressionsTree.filteringOperands.push(expressionsTree);
                    }
                }
                else if (condition) {
                    // create expressions tree for this field and add the new expression to it
                    var newExprTree = new FilteringExpressionsTree(filteringState.operator, fieldName);
                    newExprTree.filteringOperands.push(newExpression);
                    newExpressionsTree.filteringOperands.push(newExprTree);
                }
            }
            return newExpressionsTree;
        };
        IgxFilteringService.prototype.isFilteringTreeComplex = function (expressions) {
            var e_5, _a;
            if (!expressions) {
                return false;
            }
            if (expressions instanceof FilteringExpressionsTree) {
                var expressionsTree = expressions;
                if (expressionsTree.operator === exports.FilteringLogic.Or) {
                    var andOperatorsCount = this.getChildAndOperatorsCount(expressionsTree);
                    // having more that 'And' and operator in the sub-tree means that the filter could not be represented without parentheses.
                    return andOperatorsCount > 1;
                }
                var isComplex = false;
                try {
                    for (var _b = __values(expressionsTree.filteringOperands), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var operand = _c.value;
                        isComplex = isComplex || this.isFilteringTreeComplex(operand);
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                return isComplex;
            }
            return false;
        };
        IgxFilteringService.prototype.getChildAndOperatorsCount = function (expressions) {
            var count = 0;
            var operand;
            for (var i = 0; i < expressions.filteringOperands.length; i++) {
                operand = expressions[i];
                if (operand instanceof FilteringExpressionsTree) {
                    if (operand.operator === exports.FilteringLogic.And) {
                        count++;
                    }
                    count = count + this.getChildAndOperatorsCount(operand);
                }
            }
            return count;
        };
        IgxFilteringService.prototype.generateExpressionsListRecursive = function (expressions, operator, expressionsUIs) {
            var e_6, _a;
            if (!expressions) {
                return;
            }
            if (expressions instanceof FilteringExpressionsTree) {
                var expressionsTree = expressions;
                try {
                    for (var _b = __values(expressionsTree.filteringOperands), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var operand = _c.value;
                        this.generateExpressionsListRecursive(operand, expressionsTree.operator, expressionsUIs);
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
                if (expressionsUIs.length) {
                    expressionsUIs[expressionsUIs.length - 1].afterOperator = operator;
                }
            }
            else {
                var exprUI = new ExpressionUI();
                exprUI.expression = expressions;
                exprUI.afterOperator = operator;
                var prevExprUI = expressionsUIs[expressionsUIs.length - 1];
                if (prevExprUI) {
                    exprUI.beforeOperator = prevExprUI.afterOperator;
                }
                expressionsUIs.push(exprUI);
            }
        };
        return IgxFilteringService;
    }());
    IgxFilteringService.decorators = [
        { type: i0.Injectable }
    ];
    IgxFilteringService.ctorParameters = function () { return [
        { type: i0.NgModuleRef },
        { type: IgxIconService },
        { type: IgxOverlayService }
    ]; };

    var IgxSelectItemComponent = /** @class */ (function (_super) {
        __extends(IgxSelectItemComponent, _super);
        function IgxSelectItemComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IgxSelectItemComponent.prototype, "text", {
            /**
             * An @Input property that gets/sets the item's text to be displayed in the select component's input when the item is selected.
             *
             * ```typescript
             *  //get
             *  let mySelectedItem = this.dropDown.selectedItem;
             *  let selectedItemText = mySelectedItem.text;
             * ```
             *
             * ```html
             * // set
             * <igx-select-item [text]="'London'"></igx-select-item>
             * ```
             */
            get: function () {
                return this._text;
            },
            set: function (text) {
                this._text = text;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSelectItemComponent.prototype, "itemText", {
            /** @hidden @internal */
            get: function () {
                if (this._text !== undefined) {
                    return this._text;
                }
                // If text @Input is undefined, try extract a meaningful item text out of the item template
                return this.elementRef.nativeElement.textContent.trim();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSelectItemComponent.prototype, "selected", {
            /**
             * Sets/Gets if the item is the currently selected one in the select
             *
             * ```typescript
             *  let mySelectedItem = this.select.selectedItem;
             *  let isMyItemSelected = mySelectedItem.selected; // true
             * ```
             */
            get: function () {
                return !this.isHeader && !this.disabled && this.selection.is_item_selected(this.dropDown.id, this);
            },
            set: function (value) {
                if (value && !this.isHeader && !this.disabled) {
                    this.dropDown.selectItem(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        IgxSelectItemComponent.prototype.ngDoCheck = function () {
        };
        return IgxSelectItemComponent;
    }(IgxDropDownItemComponent));
    IgxSelectItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-select-item',
                    template: '<span class="igx-drop-down__inner"><ng-content></ng-content></span>'
                },] }
    ];
    IgxSelectItemComponent.propDecorators = {
        text: [{ type: i0.Input }]
    };

    /** @hidden @internal */
    var SelectPositioningStrategy = /** @class */ (function (_super) {
        __extends(SelectPositioningStrategy, _super);
        function SelectPositioningStrategy(select, settings) {
            var _this = _super.call(this) || this;
            _this.select = select;
            _this._selectDefaultSettings = {
                horizontalDirection: exports.HorizontalAlignment.Right,
                verticalDirection: exports.VerticalAlignment.Bottom,
                horizontalStartPoint: exports.HorizontalAlignment.Left,
                verticalStartPoint: exports.VerticalAlignment.Top,
                openAnimation: fadeIn,
                closeAnimation: fadeOut
            };
            // Global variables required for cases of !initialCall (page scroll/overlay repositionAll)
            _this.global_yOffset = 0;
            _this.global_xOffset = 0;
            _this.global_styles = {};
            _this.settings = Object.assign({}, _this._selectDefaultSettings, settings);
            return _this;
        }
        /** @inheritdoc */
        SelectPositioningStrategy.prototype.position = function (contentElement, size, document, initialCall, target) {
            this.select.scrollContainer.scrollTop = 0;
            var targetElement = target || this.settings.target;
            var rects = _super.prototype.calculateElementRectangles.call(this, contentElement, targetElement);
            // selectFit obj, to be used for both cases of initialCall and !initialCall(page scroll/overlay repositionAll)
            var selectFit = {
                verticalOffset: this.global_yOffset,
                horizontalOffset: this.global_xOffset,
                targetRect: rects.targetRect,
                contentElementRect: rects.elementRect,
                styles: this.global_styles,
                scrollContainer: this.select.scrollContainer,
                scrollContainerRect: this.select.scrollContainer.getBoundingClientRect()
            };
            if (initialCall) {
                // Fill in the required selectFit object properties.
                selectFit.viewPortRect = Util.getViewportRect(document);
                selectFit.itemElement = this.getInteractionItemElement();
                selectFit.itemRect = selectFit.itemElement.getBoundingClientRect();
                // Calculate input and selected item elements style related variables
                selectFit.styles = this.calculateStyles(selectFit, targetElement);
                selectFit.scrollAmount = this.calculateScrollAmount(selectFit);
                // Calculate how much to offset the overlay container.
                this.calculateYoffset(selectFit);
                this.calculateXoffset(selectFit);
                _super.prototype.updateViewPortFit.call(this, selectFit);
                // container does not fit in viewPort and is out on Top or Bottom
                if (selectFit.fitVertical.back < 0 || selectFit.fitVertical.forward < 0) {
                    this.fitInViewport(contentElement, selectFit);
                }
                this.select.scrollContainer.scrollTop = selectFit.scrollAmount;
            }
            this.setStyles(contentElement, selectFit);
        };
        /**
         * Obtain the selected item if there is such one or otherwise use the first one
         */
        SelectPositioningStrategy.prototype.getInteractionItemElement = function () {
            var itemElement;
            if (this.select.selectedItem) {
                itemElement = this.select.selectedItem.element.nativeElement;
                // D.P. Feb 22 2019, #3921 Force item scroll before measuring in IE11, due to base scrollToItem delay
                if (isIE()) {
                    this.select.scrollContainer.scrollTop = this.select.calculateScrollPosition(this.select.selectedItem);
                }
            }
            else {
                itemElement = this.select.getFirstItemElement();
            }
            return itemElement;
        };
        /**
         * Position the items outer container so selected item text is positioned over input text and if header
         * And/OR footer - both header/footer are visible
         *
         * @param selectFit selectFit to use for computation.
         */
        SelectPositioningStrategy.prototype.fitInViewport = function (contentElement, selectFit) {
            var footer = selectFit.scrollContainerRect.bottom - selectFit.contentElementRect.bottom;
            var header = selectFit.scrollContainerRect.top - selectFit.contentElementRect.top;
            var lastItemFitSize = selectFit.targetRect.bottom + selectFit.styles.itemTextToInputTextDiff - footer;
            var firstItemFitSize = selectFit.targetRect.top - selectFit.styles.itemTextToInputTextDiff - header;
            // out of viewPort on Top
            if (selectFit.fitVertical.back < 0) {
                var possibleScrollAmount = selectFit.scrollContainer.scrollHeight -
                    selectFit.scrollContainerRect.height - selectFit.scrollAmount;
                if (possibleScrollAmount + selectFit.fitVertical.back > 0 && firstItemFitSize > selectFit.viewPortRect.top) {
                    selectFit.scrollAmount -= selectFit.fitVertical.back;
                    selectFit.verticalOffset -= selectFit.fitVertical.back;
                    this.global_yOffset = selectFit.verticalOffset;
                }
                else {
                    selectFit.verticalOffset = 0;
                    this.global_yOffset = 0;
                }
                // out of viewPort on Bottom
            }
            else if (selectFit.fitVertical.forward < 0) {
                if (selectFit.scrollAmount + selectFit.fitVertical.forward > 0 && lastItemFitSize < selectFit.viewPortRect.bottom) {
                    selectFit.scrollAmount += selectFit.fitVertical.forward;
                    selectFit.verticalOffset += selectFit.fitVertical.forward;
                    this.global_yOffset = selectFit.verticalOffset;
                }
                else {
                    selectFit.verticalOffset = -selectFit.contentElementRect.height + selectFit.targetRect.height;
                    this.global_yOffset = selectFit.verticalOffset;
                }
            }
        };
        /**
         * Sets element's style which effectively positions the provided element
         *
         * @param element Element to position
         * @param selectFit selectFit to use for computation.
         * @param initialCall should be true if this is the initial call to the position method calling setStyles
         */
        SelectPositioningStrategy.prototype.setStyles = function (contentElement, selectFit) {
            _super.prototype.setStyle.call(this, contentElement, selectFit.targetRect, selectFit.contentElementRect, selectFit);
            contentElement.style.width = selectFit.styles.contentElementNewWidth + "px"; // manage container based on paddings?
            this.global_styles.contentElementNewWidth = selectFit.styles.contentElementNewWidth;
        };
        /**
         * Calculate selected item scroll position.
         */
        SelectPositioningStrategy.prototype.calculateScrollAmount = function (selectFit) {
            var itemElementRect = selectFit.itemRect;
            var scrollContainer = selectFit.scrollContainer;
            var scrollContainerRect = selectFit.scrollContainerRect;
            var scrollDelta = scrollContainerRect.top - itemElementRect.top;
            var scrollPosition = scrollContainer.scrollTop - scrollDelta;
            var dropDownHeight = scrollContainer.clientHeight;
            scrollPosition -= dropDownHeight / 2;
            scrollPosition += itemElementRect.height / 2;
            return Math.round(Math.min(Math.max(0, scrollPosition), scrollContainer.scrollHeight - scrollContainerRect.height));
        };
        /**
         * Calculate the necessary input and selected item styles to be used for positioning item text over input text.
         * Calculate & Set default items container width.
         *
         * @param selectFit selectFit to use for computation.
         */
        SelectPositioningStrategy.prototype.calculateStyles = function (selectFit, target) {
            var styles = {};
            var inputElementStyles = window.getComputedStyle(target);
            var itemElementStyles = window.getComputedStyle(selectFit.itemElement);
            var numericInputFontSize = parseFloat(inputElementStyles.fontSize);
            var numericItemFontSize = parseFloat(itemElementStyles.fontSize);
            var inputTextToInputTop = (selectFit.targetRect.bottom - selectFit.targetRect.top - numericInputFontSize) / 2;
            var itemTextToItemTop = (selectFit.itemRect.height - numericItemFontSize) / 2;
            // Adjust for input top padding
            var negateInputPaddings = (parseFloat(inputElementStyles.paddingTop) -
                parseFloat(inputElementStyles.paddingBottom)) / 2;
            styles.itemTextToInputTextDiff = Math.round(itemTextToItemTop - inputTextToInputTop + negateInputPaddings);
            var numericLeftPadding = parseFloat(itemElementStyles.paddingLeft);
            var numericTextIndent = parseFloat(itemElementStyles.textIndent);
            styles.itemTextPadding = numericLeftPadding;
            styles.itemTextIndent = numericTextIndent;
            // 24 is the input's toggle ddl icon width
            styles.contentElementNewWidth = selectFit.targetRect.width + 24 + numericLeftPadding * 2;
            return styles;
        };
        /**
         * Calculate how much to offset the overlay container for Y-axis.
         */
        SelectPositioningStrategy.prototype.calculateYoffset = function (selectFit) {
            selectFit.verticalOffset = -(selectFit.itemRect.top - selectFit.contentElementRect.top +
                selectFit.styles.itemTextToInputTextDiff - selectFit.scrollAmount);
            this.global_yOffset = selectFit.verticalOffset;
        };
        /**
         * Calculate how much to offset the overlay container for X-axis.
         */
        SelectPositioningStrategy.prototype.calculateXoffset = function (selectFit) {
            selectFit.horizontalOffset = selectFit.styles.itemTextIndent - selectFit.styles.itemTextPadding;
            this.global_xOffset = selectFit.horizontalOffset;
        };
        return SelectPositioningStrategy;
    }(BaseFitPositionStrategy));

    /** @hidden @internal */
    var IgxSelectToggleIconDirective = /** @class */ (function () {
        function IgxSelectToggleIconDirective() {
        }
        return IgxSelectToggleIconDirective;
    }());
    IgxSelectToggleIconDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxSelectToggleIcon]'
                },] }
    ];
    /** @hidden @internal */
    var IgxSelectHeaderDirective = /** @class */ (function () {
        function IgxSelectHeaderDirective() {
        }
        return IgxSelectHeaderDirective;
    }());
    IgxSelectHeaderDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxSelectHeader]'
                },] }
    ];
    /** @hidden @internal */
    var IgxSelectFooterDirective = /** @class */ (function () {
        function IgxSelectFooterDirective() {
        }
        return IgxSelectFooterDirective;
    }());
    IgxSelectFooterDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxSelectFooter]'
                },] }
    ];
    /**
     * **Ignite UI for Angular Select** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/select)
     *
     * The `igxSelect` provides an input with dropdown list allowing selection of a single item.
     *
     * Example:
     * ```html
     * <igx-select #select1 [placeholder]="'Pick One'">
     *   <label igxLabel>Select Label</label>
     *   <igx-select-item *ngFor="let item of items" [value]="item.field">
     *     {{ item.field }}
     *   </igx-select-item>
     * </igx-select>
     * ```
     */
    var IgxSelectComponent = /** @class */ (function (_super) {
        __extends(IgxSelectComponent, _super);
        function IgxSelectComponent(elementRef, cdr, selection, _displayDensityOptions, _inputGroupType, _injector) {
            var _this = _super.call(this, elementRef, cdr, selection, _displayDensityOptions) || this;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            _this.selection = selection;
            _this._displayDensityOptions = _displayDensityOptions;
            _this._inputGroupType = _inputGroupType;
            _this._injector = _injector;
            /**
             * An @Input property that disables the `IgxSelectComponent`.
             * ```html
             * <igx-select [disabled]="'true'"></igx-select>
             * ```
             */
            _this.disabled = false;
            /** @hidden @internal */
            _this.maxHeight = '256px';
            /**
             * Emitted before the dropdown is opened
             *
             * ```html
             * <igx-select onOpening='handleOpening($event)'></igx-select>
             * ```
             */
            _this.onOpening = new i0.EventEmitter();
            /**
             * Emitted after the dropdown is opened
             *
             * ```html
             * <igx-select (onOpened)='handleOpened()'></igx-select>
             * ```
             */
            _this.onOpened = new i0.EventEmitter();
            /**
             * Emitted before the dropdown is closed
             *
             * ```html
             * <igx-select (onClosing)='handleClosing($event)'></igx-select>
             * ```
             */
            _this.onClosing = new i0.EventEmitter();
            /**
             * Emitted after the dropdown is closed
             *
             * ```html
             * <igx-select (onClosed)='handleClosed()'></igx-select>
             * ```
             */
            _this.onClosed = new i0.EventEmitter();
            /**
             * The custom template, if any, that should be used when rendering the select TOGGLE(open/close) button
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.select.toggleIconTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-select #select>
             *      ...
             *      <ng-template igxSelectToggleIcon let-collapsed>
             *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
             *      </ng-template>
             *  </igx-select>
             * ```
             */
            _this.toggleIconTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the HEADER for the select items list
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.select.headerTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-select #select>
             *      ...
             *      <ng-template igxSelectHeader>
             *          <div class="select__header">
             *              This is a custom header
             *          </div>
             *      </ng-template>
             *  </igx-select>
             * ```
             */
            _this.headerTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the FOOTER for the select items list
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.select.footerTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-select #select>
             *      ...
             *      <ng-template igxSelectFooter>
             *          <div class="select__footer">
             *              This is a custom footer
             *          </div>
             *      </ng-template>
             *  </igx-select>
             * ```
             */
            _this.footerTemplate = null;
            /** @hidden @internal do not use the drop-down container class */
            _this.cssClass = false;
            /** @hidden @internal */
            _this.allowItemsFocus = false;
            _this.destroy$ = new rxjs.Subject();
            _this.ngControl = null;
            _this._type = null;
            _this._onChangeCallback = rxjs.noop;
            _this._onTouchedCallback = rxjs.noop;
            //#region ControlValueAccessor
            /** @hidden @internal */
            _this.writeValue = function (value) {
                _this.value = value;
            };
            return _this;
        }
        Object.defineProperty(IgxSelectComponent.prototype, "value", {
            /**
             * An @Input property that gets/sets the component value.
             *
             * ```typescript
             * // get
             * let selectValue = this.select.value;
             * ```
             *
             * ```typescript
             * // set
             * this.select.value = 'London';
             * ```
             * ```html
             * <igx-select [value]="value"></igx-select>
             * ```
             */
            get: function () {
                return this._value;
            },
            set: function (v) {
                var _this = this;
                if (this._value === v) {
                    return;
                }
                this._value = v;
                this.setSelection(this.items.find(function (x) { return x.value === _this.value; }));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSelectComponent.prototype, "type", {
            /**
             * An @Input property that sets how the select will be styled.
             * The allowed values are `line`, `box` and `border`. The input-group default is `line`.
             * ```html
             * <igx-select [type]="'box'"></igx-select>
             * ```
             */
            get: function () {
                return this._type || this._inputGroupType || 'line';
            },
            set: function (val) {
                this._type = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSelectComponent.prototype, "selectionValue", {
            /** @hidden @internal */
            get: function () {
                var selectedItem = this.selectedItem;
                return selectedItem ? selectedItem.itemText : '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSelectComponent.prototype, "selectedItem", {
            /** @hidden @internal */
            get: function () {
                return this.selection.first_item(this.id);
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden @internal */
        IgxSelectComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        //#endregion
        /** @hidden @internal */
        IgxSelectComponent.prototype.getEditElement = function () {
            return this.input.nativeElement;
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.selectItem = function (newSelection, event) {
            var oldSelection = this.selectedItem;
            if (event) {
                this.toggleDirective.close();
            }
            if (newSelection === null || newSelection === oldSelection || newSelection.disabled || newSelection.isHeader) {
                return;
            }
            var args = { oldSelection: oldSelection, newSelection: newSelection, cancel: false };
            this.onSelection.emit(args);
            if (args.cancel) {
                return;
            }
            this.setSelection(newSelection);
            this._value = newSelection.value;
            this.cdr.detectChanges();
            this._onChangeCallback(this.value);
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.getFirstItemElement = function () {
            return this.children.first.element.nativeElement;
        };
        /**
         * Opens the select
         *
         * ```typescript
         * this.select.open();
         * ```
         */
        IgxSelectComponent.prototype.open = function (overlaySettings) {
            if (this.disabled || this.items.length === 0) {
                return;
            }
            if (!this.selectedItem) {
                this.navigateFirst();
            }
            _super.prototype.open.call(this, Object.assign({}, this._overlayDefaults, this.overlaySettings, overlaySettings));
        };
        IgxSelectComponent.prototype.inputGroupClick = function (event, overlaySettings) {
            var targetElement = event.target;
            if (this.hintElement && targetElement.contains(this.hintElement.nativeElement)) {
                return;
            }
            this.toggle(Object.assign({}, this._overlayDefaults, this.overlaySettings, overlaySettings));
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this._overlayDefaults = {
                target: this.getEditElement(),
                modal: false,
                positionStrategy: new SelectPositioningStrategy(this),
                scrollStrategy: new AbsoluteScrollStrategy(),
                excludeFromOutsideClick: [this.inputGroup.element.nativeElement]
            };
            var changes$ = this.children.changes.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                _this.setSelection(_this.items.find(function (x) { return x.value === _this.value; }));
                _this.cdr.detectChanges();
            });
            Promise.resolve().then(function () {
                if (!changes$.closed) {
                    _this.children.notifyOnChanges();
                }
            });
        };
        /**
         * Event handlers
         *
         * @hidden @internal
         */
        IgxSelectComponent.prototype.handleOpening = function (event) {
            var args = { cancel: event.cancel };
            this.onOpening.emit(args);
            event.cancel = args.cancel;
            if (args.cancel) {
                return;
            }
            this.scrollToItem(this.selectedItem);
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.handleOpened = function () {
            this.updateItemFocus();
            this.onOpened.emit();
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.handleClosing = function (event) {
            var args = { cancel: event.cancel };
            this.onClosing.emit(args);
            event.cancel = args.cancel;
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.handleClosed = function () {
            this.focusItem(false);
            this.onClosed.emit();
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.onBlur = function () {
            this._onTouchedCallback();
            if (this.ngControl && this.ngControl.invalid) {
                this.input.valid = exports.IgxInputState.INVALID;
            }
            else {
                this.input.valid = exports.IgxInputState.INITIAL;
            }
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.onFocus = function () {
            this._onTouchedCallback();
        };
        /**
         * @hidden @internal
         */
        IgxSelectComponent.prototype.ngOnInit = function () {
            this.ngControl = this._injector.get(forms.NgControl, null);
        };
        /**
         * @hidden @internal
         */
        IgxSelectComponent.prototype.ngAfterViewInit = function () {
            if (this.ngControl) {
                this.ngControl.statusChanges.pipe(operators.takeUntil(this.destroy$)).subscribe(this.onStatusChanged.bind(this));
                this.manageRequiredAsterisk();
            }
            this.cdr.detectChanges();
        };
        /**
         * @hidden @internal
         */
        IgxSelectComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
            this.selection.clear(this.id);
        };
        /**
         * @hidden @internal
         * Prevent input blur - closing the items container on Header/Footer Template click.
         */
        IgxSelectComponent.prototype.mousedownHandler = function (event) {
            event.preventDefault();
        };
        IgxSelectComponent.prototype.onStatusChanged = function () {
            if ((this.ngControl.control.touched || this.ngControl.control.dirty) &&
                (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {
                if (this.inputGroup.isFocused) {
                    this.input.valid = this.ngControl.invalid ? exports.IgxInputState.INVALID : exports.IgxInputState.VALID;
                }
                else {
                    this.input.valid = this.ngControl.invalid ? exports.IgxInputState.INVALID : exports.IgxInputState.INITIAL;
                }
            }
            this.manageRequiredAsterisk();
        };
        IgxSelectComponent.prototype.navigate = function (direction, currentIndex) {
            if (this.collapsed && this.selectedItem) {
                this.navigateItem(this.selectedItem.itemIndex);
            }
            _super.prototype.navigate.call(this, direction, currentIndex);
        };
        IgxSelectComponent.prototype.manageRequiredAsterisk = function () {
            var hasRequiredHTMLAttribute = this.elementRef.nativeElement.hasAttribute('required');
            if (this.ngControl && this.ngControl.control.validator) {
                // Run the validation with empty object to check if required is enabled.
                var error = this.ngControl.control.validator({});
                this.inputGroup.isRequired = error && error.required;
                this.cdr.markForCheck();
                // If validator is dynamically cleared and no required HTML attribute is set,
                // reset label's required class(asterisk) and IgxInputState #6896
            }
            else if (this.inputGroup.isRequired && this.ngControl && !this.ngControl.control.validator && !hasRequiredHTMLAttribute) {
                this.input.valid = exports.IgxInputState.INITIAL;
                this.inputGroup.isRequired = false;
                this.cdr.markForCheck();
            }
        };
        IgxSelectComponent.prototype.setSelection = function (item) {
            if (item && item.value !== undefined && item.value !== null) {
                this.selection.set(this.id, new Set([item]));
            }
            else {
                this.selection.clear(this.id);
            }
        };
        return IgxSelectComponent;
    }(IgxDropDownComponent));
    IgxSelectComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-select',
                    template: "<igx-input-group #inputGroup class=\"input-group\" (click)=\"inputGroupClick($event)\" [type]=\"type\" [displayDensity]=\"displayDensity\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n    </ng-container>\n    <input #input class=\"input\" type=\"text\" igxInput [igxSelectItemNavigation]=\"this\"\n        [disabled]=\"disabled\"\n        readonly=\"true\"\n        [attr.placeholder]=\"this.placeholder\"\n        [value]=\"this.selectionValue\"\n        role=\"combobox\"\n        aria-haspopup=\"listbox\"\n        [attr.aria-labelledby]=\"this.label?.id\"\n        [attr.aria-expanded]=\"!this.collapsed\"\n        [attr.aria-owns]=\"this.listId\"\n        [attr.aria-activedescendant]=\"!this.collapsed ? this.focusedItem?.id : null\"\n        (blur)=\"onBlur()\"\n        (focus)=\"onFocus()\"\n    />\n    <ng-container ngProjectAs=\"igx-suffix\">\n            <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n    </ng-container>\n    <igx-suffix>\n        <ng-container *ngIf=\"toggleIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n            </ng-container>\n        <igx-icon *ngIf=\"!toggleIconTemplate\">{{ collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}</igx-icon>\n    </igx-suffix>\n    <ng-container ngProjectAs=\"igx-hint, [igxHint]\" >\n        <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n    </ng-container>\n</igx-input-group>\n<div igxToggle class=\"igx-drop-down__list\" (mousedown)=\"mousedownHandler($event);\" (onOpening)=\"handleOpening($event)\"\n    (onOpened)=\"handleOpened()\" (onClosing)=\"handleClosing($event)\" (onClosed)=\"handleClosed()\">\n\n    <div *ngIf=\"headerTemplate\" class=\"igx-drop-down__select-header\">\n        <ng-content *ngTemplateOutlet=\"headerTemplate\"></ng-content>\n    </div>\n\n    <!-- #7436 LMB scrolling closes items container - unselectable attribute is IE specific  -->\n    <div #scrollContainer class=\"igx-drop-down__list-scroll\" unselectable=\"on\" [style.maxHeight]=\"maxHeight\"\n        [attr.id]=\"this.listId\" role=\"listbox\" [attr.aria-labelledby]=\"this.label?.id\">\n        <ng-content select=\"igx-select-item, igx-select-item-group\"></ng-content>\n    </div>\n\n    <div *ngIf=\"footerTemplate\" class=\"igx-drop-down__select-footer\">\n        <ng-container *ngTemplateOutlet=\"footerTemplate\"></ng-container>\n    </div>\n</div>\n",
                    providers: [
                        { provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxSelectComponent, multi: true },
                        { provide: IGX_DROPDOWN_BASE, useExisting: IgxSelectComponent }
                    ],
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                },] }
    ];
    IgxSelectComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: IgxSelectionAPIService },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [IGX_INPUT_GROUP_TYPE,] }] },
        { type: i0.Injector }
    ]; };
    IgxSelectComponent.propDecorators = {
        inputGroup: [{ type: i0.ViewChild, args: ['inputGroup', { read: IgxInputGroupComponent, static: true },] }],
        input: [{ type: i0.ViewChild, args: ['input', { read: IgxInputDirective, static: true },] }],
        children: [{ type: i0.ContentChildren, args: [i0.forwardRef(function () { return IgxSelectItemComponent; }), { descendants: true },] }],
        label: [{ type: i0.ContentChild, args: [i0.forwardRef(function () { return IgxLabelDirective; }), { static: true },] }],
        placeholder: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        overlaySettings: [{ type: i0.Input }],
        maxHeight: [{ type: i0.HostBinding, args: ['style.maxHeight',] }],
        onOpening: [{ type: i0.Output }],
        onOpened: [{ type: i0.Output }],
        onClosing: [{ type: i0.Output }],
        onClosed: [{ type: i0.Output }],
        toggleIconTemplate: [{ type: i0.ContentChild, args: [IgxSelectToggleIconDirective, { read: i0.TemplateRef },] }],
        headerTemplate: [{ type: i0.ContentChild, args: [IgxSelectHeaderDirective, { read: i0.TemplateRef, static: false },] }],
        footerTemplate: [{ type: i0.ContentChild, args: [IgxSelectFooterDirective, { read: i0.TemplateRef, static: false },] }],
        hintElement: [{ type: i0.ContentChild, args: [IgxHintDirective, { read: i0.ElementRef },] }],
        value: [{ type: i0.Input }],
        type: [{ type: i0.Input }]
    };

    /**
     * @hidden
     */
    var IgxExcelStyleDefaultExpressionComponent = /** @class */ (function () {
        function IgxExcelStyleDefaultExpressionComponent(cdr) {
            this.cdr = cdr;
            this.expressionRemoved = new i0.EventEmitter();
            this.logicOperatorChanged = new i0.EventEmitter();
            this.dropDownOverlaySettings = {
                scrollStrategy: new AbsoluteScrollStrategy(),
                modal: false,
                closeOnOutsideClick: true
            };
        }
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "isLast", {
            get: function () {
                return this.expressionsList[this.expressionsList.length - 1] === this.expressionUI;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "isSingle", {
            get: function () {
                return this.expressionsList.length === 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "conditionsPlaceholder", {
            get: function () {
                return this.grid.resourceStrings['igx_grid_filter_condition_placeholder'];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "inputValuePlaceholder", {
            get: function () {
                return this.grid.resourceStrings['igx_grid_filter_row_placeholder'];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "type", {
            get: function () {
                switch (this.column.dataType) {
                    case DataType.Number:
                    case DataType.Currency:
                    case DataType.Percent:
                        return 'number';
                    default:
                        return 'text';
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "conditions", {
            get: function () {
                return this.column.filters.conditionList();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "inputValuesElement", {
            get: function () {
                return this.inputValuesDirective;
            },
            enumerable: false,
            configurable: true
        });
        IgxExcelStyleDefaultExpressionComponent.prototype.ngAfterViewInit = function () {
            this.dropDownOverlaySettings.outlet = this.overlayOutlet;
            this.dropDownOverlaySettings.target = this.dropdownConditions.inputGroup.element.nativeElement;
            this.dropDownOverlaySettings.excludeFromOutsideClick = [this.dropdownConditions.inputGroup.element.nativeElement];
            this.dropDownOverlaySettings.positionStrategy = new ConnectedPositioningStrategy();
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.focus = function () {
            var _this = this;
            // use requestAnimationFrame to focus the values input because when initializing the component
            // datepicker's input group is not yet fully initialized
            requestAnimationFrame(function () { return _this.inputValuesElement.focus(); });
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.translateCondition = function (value) {
            return this.grid.resourceStrings["igx_grid_filter_" + this.getCondition(value).name] || value;
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.getIconName = function () {
            if (this.column.dataType === DataType.Boolean && this.expressionUI.expression.condition === null) {
                return this.getCondition(this.conditions[0]).iconName;
            }
            else if (!this.expressionUI.expression.condition) {
                return 'filter_list';
            }
            else {
                return this.expressionUI.expression.condition.iconName;
            }
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.isConditionSelected = function (conditionName) {
            return this.expressionUI.expression.condition && this.expressionUI.expression.condition.name === conditionName;
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.onConditionsChanged = function (eventArgs) {
            var value = eventArgs.newSelection.value;
            this.expressionUI.expression.condition = this.getCondition(value);
            this.focus();
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.getCondition = function (value) {
            return this.column.filters.condition(value);
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.onValuesInput = function (eventArgs) {
            this.expressionUI.expression.searchVal = DataUtil.parseValue(this.column.dataType, eventArgs.target.value);
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.onLogicOperatorButtonClicked = function (eventArgs, buttonIndex) {
            if (this.logicOperatorButtonGroup.selectedButtons.length === 0) {
                eventArgs.stopPropagation();
                this.logicOperatorButtonGroup.selectButton(buttonIndex);
            }
            else {
                this.logicOperatorChanged.emit({
                    target: this.expressionUI,
                    newValue: buttonIndex
                });
            }
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.onLogicOperatorKeyDown = function (eventArgs, buttonIndex) {
            if (eventArgs.key === "Enter" /* ENTER */) {
                this.logicOperatorButtonGroup.selectButton(buttonIndex);
                this.logicOperatorChanged.emit({
                    target: this.expressionUI,
                    newValue: buttonIndex
                });
            }
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.onRemoveButtonClick = function () {
            this.expressionRemoved.emit(this.expressionUI);
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.onOutletPointerDown = function (event) {
            event.preventDefault();
        };
        return IgxExcelStyleDefaultExpressionComponent;
    }());
    IgxExcelStyleDefaultExpressionComponent.decorators = [
        { type: i0.Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-default-expression',
                    template: "<igx-select #dropdownConditions\n        type=\"box\"\n        [displayDensity]=\"displayDensity\"\n        [placeholder]=\"conditionsPlaceholder\"\n        (onSelection)=\"onConditionsChanged($event)\"\n        [overlaySettings]=\"dropDownOverlaySettings\">\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" family=\"imx-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n    <igx-select-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <div class=\"igx-grid__filtering-dropdown-items\">\n            <igx-icon family=\"imx-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n            <span class=\"igx-grid__filtering-dropdown-text\">{{translateCondition(condition)}}</span>\n        </div>\n    </igx-select-item>\n</igx-select>\n\n<igx-input-group #inputGroupValues type=\"box\" [displayDensity]=\"displayDensity\">\n    <input\n        #inputValues\n        igxInput\n        [type]=\"type\"\n        tabindex=\"0\"\n        [placeholder]=\"inputValuePlaceholder\"\n        [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"\n        autocomplete=\"off\"\n        [value]=\"expressionUI.expression.searchVal\"\n        (input)=\"onValuesInput($event)\"\n    />\n</igx-input-group>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\">\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #orButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n\n<div #overlayOutlet\n     igxOverlayOutlet\n     (pointerdown)=\"onOutletPointerDown($event)\">\n</div>\n"
                },] }
    ];
    IgxExcelStyleDefaultExpressionComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxExcelStyleDefaultExpressionComponent.propDecorators = {
        column: [{ type: i0.Input }],
        expressionUI: [{ type: i0.Input }],
        expressionsList: [{ type: i0.Input }],
        grid: [{ type: i0.Input }],
        displayDensity: [{ type: i0.Input }],
        expressionRemoved: [{ type: i0.Output }],
        logicOperatorChanged: [{ type: i0.Output }],
        overlayOutlet: [{ type: i0.ViewChild, args: ['overlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
        dropdownConditions: [{ type: i0.ViewChild, args: ['dropdownConditions', { read: IgxSelectComponent, static: true },] }],
        logicOperatorButtonGroup: [{ type: i0.ViewChild, args: ['logicOperatorButtonGroup', { read: IgxButtonGroupComponent },] }],
        inputValuesDirective: [{ type: i0.ViewChild, args: ['inputValues', { read: IgxInputDirective, static: true },] }]
    };

    /**
     * @hidden
     */
    var IgxExcelStyleDateExpressionComponent = /** @class */ (function (_super) {
        __extends(IgxExcelStyleDateExpressionComponent, _super);
        function IgxExcelStyleDateExpressionComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IgxExcelStyleDateExpressionComponent.prototype, "inputValuesElement", {
            get: function () {
                return this.datePicker.getEditElement();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleDateExpressionComponent.prototype, "inputDatePlaceholder", {
            get: function () {
                return this.grid.resourceStrings['igx_grid_filter_row_date_placeholder'];
            },
            enumerable: false,
            configurable: true
        });
        return IgxExcelStyleDateExpressionComponent;
    }(IgxExcelStyleDefaultExpressionComponent));
    IgxExcelStyleDateExpressionComponent.decorators = [
        { type: i0.Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-date-expression',
                    template: "<igx-select #dropdownConditions\n        type=\"box\"\n        [displayDensity]=\"displayDensity\"\n        [placeholder]=\"conditionsPlaceholder\"\n        (onSelection)=\"onConditionsChanged($event)\"\n        [overlaySettings]=\"dropDownOverlaySettings\">\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" family=\"imx-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n    <igx-select-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <igx-icon family=\"imx-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span>{{translateCondition(condition)}}</span>\n    </igx-select-item>\n</igx-select>\n\n<igx-date-picker #datePicker mode=\"dropdown\" [(ngModel)]=\"expressionUI.expression.searchVal\" [locale]=\"grid.locale\" [outlet]=\"grid.outlet\">\n    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"displayDensity\">\n            <input #input\n                    igxInput\n                    tabindex=\"0\"\n                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                    [placeholder]=\"inputDatePlaceholder\"\n                    autocomplete=\"off\"\n                    [value]=\"\n                        column.formatter\n                        ? (value | columnFormatter:column.formatter)\n                        : (value | date:column.pipeArgs.format:undefined:grid.locale)\n                    \"\n                    [readonly]=\"true\"\n                    [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"/>\n        </igx-input-group>\n    </ng-template>\n</igx-date-picker>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\" >\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        tabindex=\"0\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #orButton\n        tabindex=\"0\"\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n\n<div #overlayOutlet\n     igxOverlayOutlet\n     (pointerdown)=\"onOutletPointerDown($event)\">\n</div>\n"
                },] }
    ];
    IgxExcelStyleDateExpressionComponent.propDecorators = {
        displayDensity: [{ type: i0.Input }],
        datePicker: [{ type: i0.ViewChild, args: ['datePicker', { read: IgxDatePickerComponent, static: true },] }]
    };

    /**
     * @hidden
     */
    var IgxExcelStyleCustomDialogComponent = /** @class */ (function () {
        function IgxExcelStyleCustomDialogComponent(cdr) {
            this.cdr = cdr;
            this.expressionsList = new Array();
            this._customDialogPositionSettings = {
                verticalDirection: exports.VerticalAlignment.Middle,
                horizontalDirection: exports.HorizontalAlignment.Center,
                horizontalStartPoint: exports.HorizontalAlignment.Center,
                verticalStartPoint: exports.VerticalAlignment.Middle
            };
            this._customDialogOverlaySettings = {
                closeOnOutsideClick: true,
                modal: false,
                positionStrategy: new AutoPositionStrategy(this._customDialogPositionSettings),
                scrollStrategy: new AbsoluteScrollStrategy()
            };
        }
        IgxExcelStyleCustomDialogComponent.prototype.ngAfterViewInit = function () {
            this._customDialogOverlaySettings.outlet = this.grid.outlet;
        };
        Object.defineProperty(IgxExcelStyleCustomDialogComponent.prototype, "template", {
            get: function () {
                if (this.column.dataType === DataType.Date) {
                    return this.dateExpressionTemplate;
                }
                return this.defaultExpressionTemplate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleCustomDialogComponent.prototype, "grid", {
            get: function () {
                return this.filteringService.grid;
            },
            enumerable: false,
            configurable: true
        });
        IgxExcelStyleCustomDialogComponent.prototype.onCustomDialogOpening = function () {
            if (this.selectedOperator) {
                this.createInitialExpressionUIElement();
            }
        };
        IgxExcelStyleCustomDialogComponent.prototype.onCustomDialogOpened = function () {
            if (this.expressionComponents.first) {
                this.expressionComponents.first.focus();
            }
        };
        IgxExcelStyleCustomDialogComponent.prototype.open = function (esf) {
            this._customDialogOverlaySettings.target =
                this.overlayComponentId ?
                    this.grid.rootGrid ? this.grid.rootGrid.nativeElement : this.grid.nativeElement :
                    esf;
            this.toggle.open(this._customDialogOverlaySettings);
        };
        IgxExcelStyleCustomDialogComponent.prototype.onClearButtonClick = function () {
            this.filteringService.clearFilter(this.column.field);
            this.createInitialExpressionUIElement();
            this.cdr.detectChanges();
        };
        IgxExcelStyleCustomDialogComponent.prototype.closeDialog = function () {
            if (this.overlayComponentId) {
                this.overlayService.hide(this.overlayComponentId);
            }
            else {
                this.toggle.close();
            }
        };
        IgxExcelStyleCustomDialogComponent.prototype.onApplyButtonClick = function () {
            this.expressionsList = this.expressionsList.filter(function (element) { return element.expression.condition &&
                (element.expression.searchVal || element.expression.searchVal === 0 || element.expression.condition.isUnary); });
            if (this.expressionsList.length > 0) {
                this.expressionsList[0].beforeOperator = null;
                this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
            }
            this.filteringService.filterInternal(this.column.field, this.expressionsList);
            this.closeDialog();
        };
        IgxExcelStyleCustomDialogComponent.prototype.onAddButtonClick = function () {
            var exprUI = new ExpressionUI();
            exprUI.expression = {
                condition: null,
                fieldName: this.column.field,
                ignoreCase: this.column.filteringIgnoreCase,
                searchVal: null
            };
            this.expressionsList[this.expressionsList.length - 1].afterOperator = exports.FilteringLogic.And;
            exprUI.beforeOperator = this.expressionsList[this.expressionsList.length - 1].afterOperator;
            this.expressionsList.push(exprUI);
            this.markChildrenForCheck();
            this.scrollToBottom();
        };
        IgxExcelStyleCustomDialogComponent.prototype.onExpressionRemoved = function (event) {
            var indexToRemove = this.expressionsList.indexOf(event);
            if (indexToRemove === 0 && this.expressionsList.length > 1) {
                this.expressionsList[1].beforeOperator = null;
            }
            else if (indexToRemove === this.expressionsList.length - 1) {
                this.expressionsList[indexToRemove - 1].afterOperator = null;
            }
            else {
                this.expressionsList[indexToRemove - 1].afterOperator = this.expressionsList[indexToRemove + 1].beforeOperator;
                this.expressionsList[0].beforeOperator = null;
                this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
            }
            this.expressionsList.splice(indexToRemove, 1);
            this.cdr.detectChanges();
            this.markChildrenForCheck();
        };
        IgxExcelStyleCustomDialogComponent.prototype.onLogicOperatorChanged = function (event) {
            var index = this.expressionsList.indexOf(event.target);
            event.target.afterOperator = event.newValue;
            if (index + 1 < this.expressionsList.length) {
                this.expressionsList[index + 1].beforeOperator = event.newValue;
            }
        };
        IgxExcelStyleCustomDialogComponent.prototype.onKeyDown = function (eventArgs) {
            eventArgs.stopPropagation();
        };
        IgxExcelStyleCustomDialogComponent.prototype.onApplyButtonKeyDown = function (eventArgs) {
            if (eventArgs.key === "Tab" /* TAB */ && !eventArgs.shiftKey) {
                eventArgs.stopPropagation();
                eventArgs.preventDefault();
            }
        };
        IgxExcelStyleCustomDialogComponent.prototype.createCondition = function (conditionName) {
            switch (this.column.dataType) {
                case DataType.Boolean:
                    return IgxBooleanFilteringOperand.instance().condition(conditionName);
                case DataType.Number:
                case DataType.Currency:
                case DataType.Percent:
                    return IgxNumberFilteringOperand.instance().condition(conditionName);
                case DataType.Date:
                    return IgxDateFilteringOperand.instance().condition(conditionName);
                default:
                    return IgxStringFilteringOperand.instance().condition(conditionName);
            }
        };
        IgxExcelStyleCustomDialogComponent.prototype.markChildrenForCheck = function () {
            this.expressionComponents.forEach(function (x) { return x.cdr.markForCheck(); });
            this.expressionDateComponents.forEach(function (x) { return x.cdr.markForCheck(); });
        };
        IgxExcelStyleCustomDialogComponent.prototype.createInitialExpressionUIElement = function () {
            this.expressionsList = [];
            var firstExprUI = new ExpressionUI();
            firstExprUI.expression = {
                condition: this.createCondition(this.selectedOperator),
                fieldName: this.column.field,
                ignoreCase: this.column.filteringIgnoreCase,
                searchVal: null
            };
            firstExprUI.afterOperator = exports.FilteringLogic.And;
            this.expressionsList.push(firstExprUI);
            var secondExprUI = new ExpressionUI();
            secondExprUI.expression = {
                condition: null,
                fieldName: this.column.field,
                ignoreCase: this.column.filteringIgnoreCase,
                searchVal: null
            };
            secondExprUI.beforeOperator = exports.FilteringLogic.And;
            this.expressionsList.push(secondExprUI);
        };
        IgxExcelStyleCustomDialogComponent.prototype.scrollToBottom = function () {
            var _this = this;
            requestAnimationFrame(function () {
                _this.expressionsContainer.nativeElement.scrollTop = _this.expressionsContainer.nativeElement.scrollHeight;
            });
        };
        return IgxExcelStyleCustomDialogComponent;
    }());
    IgxExcelStyleCustomDialogComponent.decorators = [
        { type: i0.Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-custom-dialog',
                    template: "<article #toggle igxToggle\n    class=\"igx-excel-filter__secondary\"\n    [ngClass]=\"{\n        'igx-excel-filter__secondary--cosy': grid.displayDensity === 'cosy',\n        'igx-excel-filter__secondary--compact': grid.displayDensity === 'compact'\n    }\"\n    (keydown)=\"onKeyDown($event)\"\n    (onOpening)=\"onCustomDialogOpening()\"\n    (onOpened)=\"onCustomDialogOpened()\">\n    <header class=\"igx-excel-filter__secondary-header\">\n        <h4 class=\"igx-typography__h6\">\n            {{ grid.resourceStrings.igx_grid_excel_custom_dialog_header }}{{ column.header || column.field }}\n        </h4>\n    </header>\n\n    <article #expressionsContainer class=\"igx-excel-filter__secondary-main\">\n        <ng-container *ngIf=\"column.dataType === 'date'\">\n            <igx-excel-style-date-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (expressionRemoved)=\"onExpressionRemoved($event)\"\n                (logicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-date-expression>\n        </ng-container>\n\n        <ng-container *ngIf=\"column.dataType !== 'date'\">\n            <igx-excel-style-default-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (expressionRemoved)=\"onExpressionRemoved($event)\"\n                (logicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-default-expression>\n        </ng-container>\n\n        <button igxButton [displayDensity]=\"displayDensity\"\n            class=\"igx-excel-filter__add-filter\"\n            (click)=\"onAddButtonClick()\">\n            <igx-icon>add</igx-icon>\n            <span>{{ grid.resourceStrings.igx_grid_excel_custom_dialog_add }}</span>\n        </button>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick()\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"closeDialog()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick()\" (keydown)=\"onApplyButtonKeyDown($event)\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n"
                },] }
    ];
    IgxExcelStyleCustomDialogComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxExcelStyleCustomDialogComponent.propDecorators = {
        expressionsList: [{ type: i0.Input }],
        column: [{ type: i0.Input }],
        selectedOperator: [{ type: i0.Input }],
        filteringService: [{ type: i0.Input }],
        overlayComponentId: [{ type: i0.Input }],
        overlayService: [{ type: i0.Input }],
        displayDensity: [{ type: i0.Input }],
        toggle: [{ type: i0.ViewChild, args: ['toggle', { read: IgxToggleDirective, static: true },] }],
        defaultExpressionTemplate: [{ type: i0.ViewChild, args: ['defaultExpressionTemplate', { read: i0.TemplateRef },] }],
        dateExpressionTemplate: [{ type: i0.ViewChild, args: ['dateExpressionTemplate', { read: i0.TemplateRef },] }],
        expressionsContainer: [{ type: i0.ViewChild, args: ['expressionsContainer', { static: true },] }],
        expressionComponents: [{ type: i0.ViewChildren, args: [IgxExcelStyleDefaultExpressionComponent,] }],
        expressionDateComponents: [{ type: i0.ViewChildren, args: [IgxExcelStyleDateExpressionComponent,] }]
    };

    /**
     * A component used for presenting Excel style conditional filter UI.
     */
    var IgxExcelStyleConditionalFilterComponent = /** @class */ (function () {
        function IgxExcelStyleConditionalFilterComponent(esf) {
            var _this = this;
            this.esf = esf;
            this.shouldOpenSubMenu = true;
            this.destroy$ = new rxjs.Subject();
            this._subMenuPositionSettings = {
                verticalStartPoint: exports.VerticalAlignment.Top
            };
            this._subMenuOverlaySettings = {
                closeOnOutsideClick: true,
                modal: false,
                positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),
                scrollStrategy: new AbsoluteScrollStrategy()
            };
            this.esf.columnChange.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                if (_this.esf.grid) {
                    _this.shouldOpenSubMenu = true;
                    _this._subMenuOverlaySettings.outlet = _this.esf.grid.outlet;
                }
            });
            if (this.esf.grid) {
                this._subMenuOverlaySettings.outlet = this.esf.grid.outlet;
            }
        }
        IgxExcelStyleConditionalFilterComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleConditionalFilterComponent.prototype.onTextFilterKeyDown = function (eventArgs) {
            if (eventArgs.key === "Enter" /* ENTER */) {
                this.onTextFilterClick(eventArgs);
            }
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleConditionalFilterComponent.prototype.onTextFilterClick = function (eventArgs) {
            if (this.shouldOpenSubMenu) {
                this._subMenuOverlaySettings.target = eventArgs.currentTarget;
                var gridRect = this.esf.grid.nativeElement.getBoundingClientRect();
                var dropdownRect = this.esf.mainDropdown.nativeElement.getBoundingClientRect();
                var x = dropdownRect.left + dropdownRect.width;
                var x1 = gridRect.left + gridRect.width;
                x += window.pageXOffset;
                x1 += window.pageXOffset;
                if (Math.abs(x - x1) < 200) {
                    this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = exports.HorizontalAlignment.Left;
                    this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = exports.HorizontalAlignment.Left;
                }
                else {
                    this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = exports.HorizontalAlignment.Right;
                    this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = exports.HorizontalAlignment.Right;
                }
                this.subMenu.open(this._subMenuOverlaySettings);
                this.shouldOpenSubMenu = false;
            }
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleConditionalFilterComponent.prototype.getCondition = function (value) {
            return this.esf.column.filters.condition(value);
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleConditionalFilterComponent.prototype.translateCondition = function (value) {
            return this.esf.grid.resourceStrings["igx_grid_filter_" + this.getCondition(value).name] || value;
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleConditionalFilterComponent.prototype.onSubMenuSelection = function (eventArgs) {
            if (this.esf.expressionsList && this.esf.expressionsList.length &&
                this.esf.expressionsList[0].expression.condition.name !== 'in') {
                this.customDialog.expressionsList = this.esf.expressionsList;
            }
            this.customDialog.selectedOperator = eventArgs.newSelection.value;
            eventArgs.cancel = true;
            if (this.esf.overlayComponentId) {
                this.esf.hide();
            }
            this.subMenu.close();
            this.customDialog.open(this.esf.mainDropdown.nativeElement);
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleConditionalFilterComponent.prototype.onSubMenuClosed = function () {
            var _this = this;
            requestAnimationFrame(function () {
                _this.shouldOpenSubMenu = true;
            });
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleConditionalFilterComponent.prototype.showCustomFilterItem = function () {
            var exprTree = this.esf.column.filteringExpressionsTree;
            return exprTree && exprTree.filteringOperands && exprTree.filteringOperands.length &&
                !(exprTree.filteringOperands[0].condition &&
                    exprTree.filteringOperands[0].condition.name === 'in');
        };
        Object.defineProperty(IgxExcelStyleConditionalFilterComponent.prototype, "subMenuText", {
            /**
             * @hidden @internal
             */
            get: function () {
                switch (this.esf.column.dataType) {
                    case DataType.Boolean:
                        return this.esf.grid.resourceStrings.igx_grid_excel_boolean_filter;
                    case DataType.Number:
                    case DataType.Percent:
                        return this.esf.grid.resourceStrings.igx_grid_excel_number_filter;
                    case DataType.Date:
                        return this.esf.grid.resourceStrings.igx_grid_excel_date_filter;
                    case DataType.Currency:
                        return this.esf.grid.resourceStrings.igx_grid_excel_currency_filter;
                    default:
                        return this.esf.grid.resourceStrings.igx_grid_excel_text_filter;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleConditionalFilterComponent.prototype, "conditions", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.esf.column.filters.conditionList();
            },
            enumerable: false,
            configurable: true
        });
        return IgxExcelStyleConditionalFilterComponent;
    }());
    IgxExcelStyleConditionalFilterComponent.decorators = [
        { type: i0.Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-conditional-filter',
                    template: "<ng-container *ngIf=\"esf.column\">\n    <div tabindex=\"0\"\n        class=\"igx-excel-filter__actions-filter\"\n        (keydown)=\"onTextFilterKeyDown($event)\"\n        (click)=\"onTextFilterClick($event)\"\n        [igxDropDownItemNavigation]=\"subMenu\">\n        <span>{{ subMenuText }}</span>\n        <igx-icon>keyboard_arrow_right</igx-icon>\n    </div>\n\n    <igx-drop-down\n        #subMenu\n        [maxHeight]=\"'397px'\"\n        [displayDensity]=\"esf.grid.displayDensity\"\n        (onSelection)=\"onSubMenuSelection($event)\"\n        (onClosed)=\"onSubMenuClosed()\">\n        <div>\n            <igx-drop-down-item\n            *ngFor=\"let condition of conditions\"\n            [value]=\"condition\">\n                <div class=\"igx-grid__filtering-dropdown-items\">\n                    <igx-icon family=\"imx-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n                    <span class=\"igx-grid__filtering-dropdown-text\">{{ translateCondition(condition) }}</span>\n                </div>\n            </igx-drop-down-item>\n            <igx-drop-down-item *ngIf=\"showCustomFilterItem()\">\n                <div class=\"igx-grid__filtering-dropdown-items\">\n                    <igx-icon>filter_list</igx-icon>\n                    <span class=\"igx-grid__filtering-dropdown-text\">{{ esf.grid.resourceStrings.igx_grid_excel_custom_filter }}</span>\n                </div>\n            </igx-drop-down-item>\n        </div>\n    </igx-drop-down>\n\n    <igx-excel-style-custom-dialog\n        #customDialog\n        [column]=\"esf.column\"\n        [filteringService]=\"esf.grid.filteringService\"\n        [overlayComponentId]=\"esf.overlayComponentId\"\n        [overlayService]=\"esf.overlayService\"\n        [displayDensity]=\"esf.grid.displayDensity\">\n    </igx-excel-style-custom-dialog>\n</ng-container>\n"
                },] }
    ];
    IgxExcelStyleConditionalFilterComponent.ctorParameters = function () { return [
        { type: IgxGridExcelStyleFilteringComponent }
    ]; };
    IgxExcelStyleConditionalFilterComponent.propDecorators = {
        customDialog: [{ type: i0.ViewChild, args: ['customDialog', { read: IgxExcelStyleCustomDialogComponent },] }],
        subMenu: [{ type: i0.ViewChild, args: ['subMenu', { read: IgxDropDownComponent },] }]
    };

    /**
     * A component used for presenting Excel style header UI.
     */
    var IgxExcelStyleHeaderComponent = /** @class */ (function () {
        function IgxExcelStyleHeaderComponent(esf) {
            this.esf = esf;
        }
        return IgxExcelStyleHeaderComponent;
    }());
    IgxExcelStyleHeaderComponent.decorators = [
        { type: i0.Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-header',
                    template: "<header *ngIf=\"esf.column\"\r\n        class=\"igx-excel-filter__menu-header\">\r\n    <h4>{{ esf.column.header || esf.column.field }}</h4>\r\n    <div class=\"igx-excel-filter__menu-header-actions\">\r\n        <button *ngIf=\"showSelecting\"\r\n            igxButton=\"icon\"\r\n            (click)=\"esf.onSelect()\"\r\n            [ngClass]=\"esf.selectedClass()\"\r\n        >\r\n            <igx-icon>done</igx-icon>\r\n        </button>\r\n        <button *ngIf=\"showPinning\"\r\n            igxButton=\"icon\"\r\n            (click)=\"esf.onPin()\"\r\n        >\r\n            <igx-icon family=\"imx-icons\" [name]=\"esf.column.pinned ? 'unpin-left' : 'pin-left'\"></igx-icon>\r\n        </button>\r\n        <button *ngIf=\"showHiding\"\r\n            igxButton=\"icon\"\r\n            (click)=\"esf.onHideToggle()\"\r\n        >\r\n            <igx-icon>{{ esf.column.hidden ? 'visibility' : 'visibility_off' }}</igx-icon>\r\n        </button>\r\n    </div>\r\n</header>\r\n"
                },] }
    ];
    IgxExcelStyleHeaderComponent.ctorParameters = function () { return [
        { type: IgxGridExcelStyleFilteringComponent }
    ]; };
    IgxExcelStyleHeaderComponent.propDecorators = {
        showPinning: [{ type: i0.Input }],
        showSelecting: [{ type: i0.Input }],
        showHiding: [{ type: i0.Input }]
    };

    /**
     * A component used for presenting Excel style column hiding UI.
     */
    var IgxExcelStyleHidingComponent = /** @class */ (function () {
        function IgxExcelStyleHidingComponent(esf) {
            this.esf = esf;
        }
        return IgxExcelStyleHidingComponent;
    }());
    IgxExcelStyleHidingComponent.decorators = [
        { type: i0.Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-hiding',
                    template: "<div *ngIf=\"esf.column\"\n    class=\"igx-excel-filter__actions-hide\"\n    tabindex=\"0\"\n    (click)=\"esf.onHideToggle()\">\n    <span>{{ esf.column.hidden ? esf.grid.resourceStrings.igx_grid_excel_show : esf.grid.resourceStrings.igx_grid_excel_hide }}</span>\n    <igx-icon>{{ esf.column.hidden ? 'visibility' : 'visibility_off' }}</igx-icon>\n</div>\n"
                },] }
    ];
    IgxExcelStyleHidingComponent.ctorParameters = function () { return [
        { type: IgxGridExcelStyleFilteringComponent }
    ]; };

    /**
     * @hidden
     */
    function WatchChanges() {
        return function (target, key, propDesc) {
            var privateKey = '_' + key.toString();
            propDesc = propDesc || {
                configurable: true,
                enumerable: true,
            };
            propDesc.get = propDesc.get || (function () {
                return this[privateKey];
            });
            var originalSetter = propDesc.set || (function (val) {
                this[privateKey] = val;
            });
            propDesc.set = function (val) {
                var _a;
                var init = this._init;
                var oldValue = this[key];
                if (val !== oldValue || (typeof val === 'object' && val === oldValue)) {
                    originalSetter.call(this, val);
                    if (this.ngOnChanges && !init) {
                        // in case wacthed prop changes trigger ngOnChanges manually
                        var changes = (_a = {},
                            _a[key] = new i0.SimpleChange(oldValue, val, false),
                            _a);
                        this.ngOnChanges(changes);
                    }
                }
            };
            return propDesc;
        };
    }
    function WatchColumnChanges() {
        return function (target, key, propDesc) {
            var privateKey = '_' + key.toString();
            propDesc = propDesc || {
                configurable: true,
                enumerable: true,
            };
            propDesc.get = propDesc.get || (function () {
                return this[privateKey];
            });
            var originalSetter = propDesc.set || (function (val) {
                this[privateKey] = val;
            });
            propDesc.set = function (val) {
                var oldValue = this[key];
                originalSetter.call(this, val);
                if (val !== oldValue || (typeof val === 'object' && val === oldValue)) {
                    if (this.onColumnChange) {
                        this.onColumnChange.emit();
                    }
                }
            };
            return propDesc;
        };
    }
    function notifyChanges(repaint) {
        if (repaint === void 0) { repaint = false; }
        return function (_, key, propDesc) {
            var privateKey = "__" + key;
            propDesc = propDesc || {
                enumerable: true,
                configurable: true
            };
            var originalSetter = propDesc ? propDesc.set : null;
            propDesc.get = propDesc.get || (function () {
                return this[privateKey];
            });
            propDesc.set = function (newValue) {
                if (originalSetter) {
                    originalSetter.call(this, newValue);
                    if (this.grid) {
                        this.grid.notifyChanges(repaint);
                    }
                }
                else {
                    if (newValue === this[key]) {
                        return;
                    }
                    this[privateKey] = newValue;
                    if (this.grid) {
                        this.grid.notifyChanges(repaint);
                    }
                }
            };
            return propDesc;
        };
    }

    var clear = function (el) { return el === 0 || Boolean(el); };
    var ɵ0$4 = clear;
    var first = function (arr) { return arr[0]; };
    var ɵ1$1 = first;
    var last = function (arr) { return arr[arr.length - 1]; };
    var ɵ2 = last;
    var IgxSummaryOperand = /** @class */ (function () {
        function IgxSummaryOperand() {
        }
        /**
         * Counts all the records in the data source.
         * If filtering is applied, counts only the filtered records.
         * ```typescript
         * IgxSummaryOperand.count(dataSource);
         * ```
         *
         * @memberof IgxSummaryOperand
         */
        IgxSummaryOperand.count = function (data) {
            return data.length;
        };
        /**
         * Executes the static `count` method and returns `IgxSummaryResult[]`.
         * ```typescript
         * interface IgxSummaryResult {
         *   key: string;
         *   label: string;
         *   summaryResult: any;
         * }
         * ```
         * Can be overridden in the inherited classes to provide customization for the `summary`.
         * ```typescript
         * class CustomSummary extends IgxSummaryOperand {
         *   constructor() {
         *     super();
         *   }
         *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
         *     const result = [];
         *     result.push({
         *       key: "test",
         *       label: "Test",
         *       summaryResult: IgxSummaryOperand.count(data)
         *     });
         *     return result;
         *   }
         * }
         * this.grid.getColumnByName('ColumnName').summaries = CustomSummary;
         * ```
         *
         * @memberof IgxSummaryOperand
         */
        IgxSummaryOperand.prototype.operate = function (data, allData, fieldName, locale) {
            if (data === void 0) { data = []; }
            if (allData === void 0) { allData = []; }
            if (locale === void 0) { locale = 'en-US'; }
            var pipe = new i2.DecimalPipe(locale);
            return [{
                    key: 'count',
                    label: 'Count',
                    summaryResult: pipe.transform(IgxSummaryOperand.count(data))
                }];
        };
        return IgxSummaryOperand;
    }());
    // @dynamic
    var IgxNumberSummaryOperand = /** @class */ (function (_super) {
        __extends(IgxNumberSummaryOperand, _super);
        function IgxNumberSummaryOperand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Returns the minimum numeric value in the provided data records.
         * If filtering is applied, returns the minimum value in the filtered data records.
         * ```typescript
         * IgxNumberSummaryOperand.min(data);
         * ```
         *
         * @memberof IgxNumberSummaryOperand
         */
        IgxNumberSummaryOperand.min = function (data) {
            return data.length && data.filter(clear).length ? data.filter(clear).reduce(function (a, b) { return Math.min(a, b); }) : 0;
        };
        /**
         * Returns the maximum numeric value in the provided data records.
         * If filtering is applied, returns the maximum value in the filtered data records.
         * ```typescript
         * IgxNumberSummaryOperand.max(data);
         * ```
         *
         * @memberof IgxNumberSummaryOperand
         */
        IgxNumberSummaryOperand.max = function (data) {
            return data.length && data.filter(clear).length ? data.filter(clear).reduce(function (a, b) { return Math.max(a, b); }) : 0;
        };
        /**
         * Returns the sum of the numeric values in the provided data records.
         * If filtering is applied, returns the sum of the numeric values in the data records.
         * ```typescript
         * IgxNumberSummaryOperand.sum(data);
         * ```
         *
         * @memberof IgxNumberSummaryOperand
         */
        IgxNumberSummaryOperand.sum = function (data) {
            return data.length && data.filter(clear).length ? data.filter(clear).reduce(function (a, b) { return +a + +b; }) : 0;
        };
        /**
         * Returns the average numeric value in the data provided data records.
         * If filtering is applied, returns the average numeric value in the filtered data records.
         * ```typescript
         * IgxSummaryOperand.average(data);
         * ```
         *
         * @memberof IgxNumberSummaryOperand
         */
        IgxNumberSummaryOperand.average = function (data) {
            return data.length && data.filter(clear).length ? this.sum(data) / this.count(data) : 0;
        };
        /**
         * Executes the static methods and returns `IgxSummaryResult[]`.
         * ```typescript
         * interface IgxSummaryResult {
         *   key: string;
         *   label: string;
         *   summaryResult: any;
         * }
         * ```
         * Can be overridden in the inherited classes to provide customization for the `summary`.
         * ```typescript
         * class CustomNumberSummary extends IgxNumberSummaryOperand {
         *   constructor() {
         *     super();
         *   }
         *   public operate(data: any[], allData: any[], fieldName: string, locale: string, pipeArgs: IColumnPipeArgs): IgxSummaryResult[] {
         *     pipeArgs.digitsInfo = '1.1-2';
         *     const result = super.operate(data, allData, fieldName, locale, pipeArgs);
         *     result.push({
         *       key: "avg",
         *       label: "Avg",
         *       summaryResult: IgxNumberSummaryOperand.average(data)
         *     });
         *     result.push({
         *       key: 'mdn',
         *       label: 'Median',
         *       summaryResult: this.findMedian(data)
         *     });
         *     return result;
         *   }
         * }
         * this.grid.getColumnByName('ColumnName').summaries = CustomNumberSummary;
         * ```
         *
         * @memberof IgxNumberSummaryOperand
         */
        IgxNumberSummaryOperand.prototype.operate = function (data, allData, fieldName, locale, pipeArgs) {
            if (data === void 0) { data = []; }
            if (allData === void 0) { allData = []; }
            if (locale === void 0) { locale = 'en-US'; }
            if (pipeArgs === void 0) { pipeArgs = {}; }
            var result = _super.prototype.operate.call(this, data, allData, fieldName, locale);
            var pipe = new i2.DecimalPipe(locale);
            result.push({
                key: 'min',
                label: 'Min',
                summaryResult: pipe.transform(IgxNumberSummaryOperand.min(data), pipeArgs.digitsInfo)
            });
            result.push({
                key: 'max',
                label: 'Max',
                summaryResult: pipe.transform(IgxNumberSummaryOperand.max(data), pipeArgs.digitsInfo)
            });
            result.push({
                key: 'sum',
                label: 'Sum',
                summaryResult: pipe.transform(IgxNumberSummaryOperand.sum(data), pipeArgs.digitsInfo)
            });
            result.push({
                key: 'average',
                label: 'Avg',
                summaryResult: pipe.transform(IgxNumberSummaryOperand.average(data), pipeArgs.digitsInfo)
            });
            return result;
        };
        return IgxNumberSummaryOperand;
    }(IgxSummaryOperand));
    // @dynamic
    var IgxDateSummaryOperand = /** @class */ (function (_super) {
        __extends(IgxDateSummaryOperand, _super);
        function IgxDateSummaryOperand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Returns the latest date value in the data records.
         * If filtering is applied, returns the latest date value in the filtered data records.
         * ```typescript
         * IgxDateSummaryOperand.latest(data);
         * ```
         *
         * @memberof IgxDateSummaryOperand
         */
        IgxDateSummaryOperand.latest = function (data) {
            return data.length && data.filter(clear).length ?
                first(data.filter(clear).sort(function (a, b) { return new Date(b).valueOf() - new Date(a).valueOf(); })) : undefined;
        };
        /**
         * Returns the earliest date value in the data records.
         * If filtering is applied, returns the latest date value in the filtered data records.
         * ```typescript
         * IgxDateSummaryOperand.earliest(data);
         * ```
         *
         * @memberof IgxDateSummaryOperand
         */
        IgxDateSummaryOperand.earliest = function (data) {
            return data.length && data.filter(clear).length ?
                last(data.filter(clear).sort(function (a, b) { return new Date(b).valueOf() - new Date(a).valueOf(); })) : undefined;
        };
        /**
         * Executes the static methods and returns `IgxSummaryResult[]`.
         * ```typescript
         * interface IgxSummaryResult {
         *   key: string;
         *   label: string;
         *   summaryResult: any;
         * }
         * ```
         * Can be overridden in the inherited classes to provide customization for the `summary`.
         * ```typescript
         * class CustomDateSummary extends IgxDateSummaryOperand {
         *   constructor() {
         *     super();
         *   }
         *   public operate(data: any[], allData: any[], fieldName: string, locale: string, pipeArgs: IColumnPipeArgs): IgxSummaryResult[] {
         *     pipeArgs = {
         *        format: 'longDate',
         *        timezone: 'UTC'
         *     };
         *     const result = super.operate(data, allData, fieldName, locale, pipeArgs);
         *     result.push({
         *       key: "deadline",
         *       label: "Deadline Date",
         *       summaryResult: this.calculateDeadline(data);
         *     });
         *     return result;
         *   }
         * }
         * this.grid.getColumnByName('ColumnName').summaries = CustomDateSummary;
         * ```
         *
         * @memberof IgxDateSummaryOperand
         */
        IgxDateSummaryOperand.prototype.operate = function (data, allData, fieldName, locale, pipeArgs) {
            if (data === void 0) { data = []; }
            if (allData === void 0) { allData = []; }
            if (locale === void 0) { locale = 'en-US'; }
            if (pipeArgs === void 0) { pipeArgs = {}; }
            var result = _super.prototype.operate.call(this, data, allData, fieldName, locale);
            var pipe = new i2.DatePipe(locale);
            result.push({
                key: 'earliest',
                label: 'Earliest',
                summaryResult: pipe.transform(IgxDateSummaryOperand.earliest(data), pipeArgs.format, pipeArgs.timezone)
            });
            result.push({
                key: 'latest',
                label: 'Latest',
                summaryResult: pipe.transform(IgxDateSummaryOperand.latest(data), pipeArgs.format, pipeArgs.timezone)
            });
            return result;
        };
        return IgxDateSummaryOperand;
    }(IgxSummaryOperand));
    var IgxCurrencySummaryOperand = /** @class */ (function (_super) {
        __extends(IgxCurrencySummaryOperand, _super);
        function IgxCurrencySummaryOperand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxCurrencySummaryOperand.prototype.operate = function (data, allData, fieldName, locale, pipeArgs) {
            if (data === void 0) { data = []; }
            if (allData === void 0) { allData = []; }
            if (locale === void 0) { locale = 'en-US'; }
            if (pipeArgs === void 0) { pipeArgs = {}; }
            var result = _super.prototype.operate.call(this, data, allData, fieldName, locale);
            var currencyCode = pipeArgs.currencyCode ? pipeArgs.currencyCode : i2.getLocaleCurrencyCode(locale);
            var pipe = new i2.CurrencyPipe(locale, currencyCode);
            result.push({
                key: 'min',
                label: 'Min',
                summaryResult: pipe.transform(IgxNumberSummaryOperand.min(data), currencyCode, pipeArgs.display, pipeArgs.digitsInfo)
            });
            result.push({
                key: 'max',
                label: 'Max',
                summaryResult: pipe.transform(IgxNumberSummaryOperand.max(data), currencyCode, pipeArgs.display, pipeArgs.digitsInfo)
            });
            result.push({
                key: 'sum',
                label: 'Sum',
                summaryResult: pipe.transform(IgxNumberSummaryOperand.sum(data), currencyCode, pipeArgs.display, pipeArgs.digitsInfo)
            });
            result.push({
                key: 'average',
                label: 'Avg',
                summaryResult: pipe.transform(IgxNumberSummaryOperand.average(data), currencyCode, pipeArgs.display, pipeArgs.digitsInfo)
            });
            return result;
        };
        return IgxCurrencySummaryOperand;
    }(IgxSummaryOperand));
    var IgxPercentSummaryOperand = /** @class */ (function (_super) {
        __extends(IgxPercentSummaryOperand, _super);
        function IgxPercentSummaryOperand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxPercentSummaryOperand.prototype.operate = function (data, allData, fieldName, locale, pipeArgs) {
            if (data === void 0) { data = []; }
            if (allData === void 0) { allData = []; }
            if (locale === void 0) { locale = 'en-US'; }
            if (pipeArgs === void 0) { pipeArgs = {}; }
            var result = _super.prototype.operate.call(this, data, allData, fieldName, locale);
            var pipe = new i2.PercentPipe(locale);
            result.push({
                key: 'min',
                label: 'Min',
                summaryResult: pipe.transform(IgxNumberSummaryOperand.min(data), pipeArgs.digitsInfo)
            });
            result.push({
                key: 'max',
                label: 'Max',
                summaryResult: pipe.transform(IgxNumberSummaryOperand.max(data), pipeArgs.digitsInfo)
            });
            result.push({
                key: 'sum',
                label: 'Sum',
                summaryResult: pipe.transform(IgxNumberSummaryOperand.sum(data), pipeArgs.digitsInfo)
            });
            result.push({
                key: 'average',
                label: 'Avg',
                summaryResult: pipe.transform(IgxNumberSummaryOperand.average(data), pipeArgs.digitsInfo)
            });
            return result;
        };
        return IgxPercentSummaryOperand;
    }(IgxSummaryOperand));

    var IgxFilterCellTemplateDirective = /** @class */ (function () {
        function IgxFilterCellTemplateDirective(template) {
            this.template = template;
        }
        return IgxFilterCellTemplateDirective;
    }());
    IgxFilterCellTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxFilterCellTemplate]'
                },] }
    ];
    IgxFilterCellTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    var IgxCellTemplateDirective = /** @class */ (function () {
        function IgxCellTemplateDirective(template) {
            this.template = template;
        }
        return IgxCellTemplateDirective;
    }());
    IgxCellTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCell]'
                },] }
    ];
    IgxCellTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    var IgxCellHeaderTemplateDirective = /** @class */ (function () {
        function IgxCellHeaderTemplateDirective(template) {
            this.template = template;
        }
        return IgxCellHeaderTemplateDirective;
    }());
    IgxCellHeaderTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxHeader]'
                },] }
    ];
    IgxCellHeaderTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    /**
     * @hidden
     */
    var IgxCellFooterTemplateDirective = /** @class */ (function () {
        function IgxCellFooterTemplateDirective(template) {
            this.template = template;
        }
        return IgxCellFooterTemplateDirective;
    }());
    IgxCellFooterTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxFooter]'
                },] }
    ];
    IgxCellFooterTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    var IgxCellEditorTemplateDirective = /** @class */ (function () {
        function IgxCellEditorTemplateDirective(template) {
            this.template = template;
        }
        return IgxCellEditorTemplateDirective;
    }());
    IgxCellEditorTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCellEditor]'
                },] }
    ];
    IgxCellEditorTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    var IgxCollapsibleIndicatorTemplateDirective = /** @class */ (function () {
        function IgxCollapsibleIndicatorTemplateDirective(template) {
            this.template = template;
        }
        return IgxCollapsibleIndicatorTemplateDirective;
    }());
    IgxCollapsibleIndicatorTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxCollapsibleIndicator]'
                },] }
    ];
    IgxCollapsibleIndicatorTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };

    /**
     * This enumeration is used to configure whether the drop position is set before or after
     * the target.
     */
    var DropPosition;
    (function (DropPosition) {
        DropPosition[DropPosition["BeforeDropTarget"] = 0] = "BeforeDropTarget";
        DropPosition[DropPosition["AfterDropTarget"] = 1] = "AfterDropTarget";
    })(DropPosition || (DropPosition = {}));
    /**
     * @hidden
     * @internal
     */
    var IgxColumnMovingService = /** @class */ (function () {
        function IgxColumnMovingService() {
        }
        Object.defineProperty(IgxColumnMovingService.prototype, "column", {
            get: function () {
                return this._column;
            },
            set: function (val) {
                if (val) {
                    this._column = val;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnMovingService.prototype, "icon", {
            get: function () {
                return this._icon;
            },
            set: function (val) {
                if (val) {
                    this._icon = val;
                }
            },
            enumerable: false,
            configurable: true
        });
        return IgxColumnMovingService;
    }());
    IgxColumnMovingService.ɵprov = i0.ɵɵdefineInjectable({ factory: function IgxColumnMovingService_Factory() { return new IgxColumnMovingService(); }, token: IgxColumnMovingService, providedIn: "root" });
    IgxColumnMovingService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    var DEFAULT_DATE_FORMAT = 'mediumDate';
    var DEFAULT_DIGITS_INFO = '1.0-3';
    /**
     * **Ignite UI for Angular Column** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid#columns-configuration)
     *
     * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
     * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
     * the column using `ng-template` which will be used for all cells within the column.
     */
    var IgxColumnComponent = /** @class */ (function () {
        function IgxColumnComponent(gridAPI, cdr) {
            this.gridAPI = gridAPI;
            this.cdr = cdr;
            /**
             * Sets/gets the `header` value.
             * ```typescript
             * let columnHeader = this.column.header;
             * ```
             * ```html
             * <igx-column [header] = "'ID'"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.header = '';
            /**
             * Sets/gets the `title` value.
             * ```typescript
             * let title = this.column.title;
             * ```
             * ```html
             * <igx-column [title] = "'Some column tooltip'"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.title = '';
            /**
             * Sets/gets whether the column is sortable.
             * Default value is `false`.
             * ```typescript
             * let isSortable = this.column.sortable;
             * ```
             * ```html
             * <igx-column [sortable] = "true"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.sortable = false;
            /**
             * Sets/gets whether the column is groupable.
             * Default value is `false`.
             * ```typescript
             * let isGroupable = this.column.groupable;
             * ```
             * ```html
             * <igx-column [groupable] = "true"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.groupable = false;
            /**
             * Sets/gets whether the column is filterable.
             * Default value is `true`.
             * ```typescript
             * let isFilterable = this.column.filterable;
             * ```
             * ```html
             * <igx-column [filterable] = "false"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.filterable = true;
            /**
             * Sets/gets whether the column is resizable.
             * Default value is `false`.
             * ```typescript
             * let isResizable = this.column.resizable;
             * ```
             * ```html
             * <igx-column [resizable] = "true"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.resizable = false;
            /**
             * @hidden
             */
            this.hiddenChange = new i0.EventEmitter();
            /** @hidden */
            this.expandedChange = new i0.EventEmitter();
            /** @hidden */
            this.collapsibleChange = new i0.EventEmitter();
            /** @hidden */
            this.visibleWhenCollapsedChange = new i0.EventEmitter();
            /** @hidden */
            this.onColumnChange = new i0.EventEmitter();
            /**
             * Gets whether the hiding is disabled.
             * ```typescript
             * let isHidingDisabled =  this.column.disableHiding;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.disableHiding = false;
            /**
             * Gets whether the pinning is disabled.
             * ```typescript
             * let isPinningDisabled =  this.column.disablePinning;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.disablePinning = false;
            /**
             * Sets/gets whether the column is movable.
             * Default value is `false`.
             * ```typescript
             * let isMovable = this.column.movable;
             * ```
             * ```html
             * <igx-column [movable] = "true"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.movable = false;
            /**
             * Sets/gets the class selector of the column header.
             * ```typescript
             * let columnHeaderClass = this.column.headerClasses;
             * ```
             * ```html
             * <igx-column [headerClasses] = "'column-header'"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.headerClasses = '';
            /**
             * Sets/gets the class selector of the column group header.
             * ```typescript
             * let columnHeaderClass = this.column.headerGroupClasses;
             * ```
             * ```html
             * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.headerGroupClasses = '';
            /**
             * Sets conditional style properties on the column cells.
             * Similar to `ngStyle` it accepts an object literal where the keys are
             * the style properties and the value is the expression to be evaluated.
             * As with `cellClasses` it accepts a callback function.
             * ```typescript
             * styles = {
             *  background: 'royalblue',
             *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') : 'red': 'inherit'
             * }
             * ```
             * ```html
             * <igx-column [cellStyles]="styles"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.cellStyles = null;
            /**
             * Sets/gets whether the column filtering should be case sensitive.
             * Default value is `true`.
             * ```typescript
             * let filteringIgnoreCase = this.column.filteringIgnoreCase;
             * ```
             * ```html
             * <igx-column [filteringIgnoreCase] = "false"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.filteringIgnoreCase = true;
            /**
             * Sets/gets whether the column sorting should be case sensitive.
             * Default value is `true`.
             * ```typescript
             * let sortingIgnoreCase = this.column.sortingIgnoreCase;
             * ```
             * ```html
             * <igx-column [sortingIgnoreCase] = "false"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.sortingIgnoreCase = true;
            /**
             * Sets/gets whether the column is `searchable`.
             * Default value is `true`.
             * ```typescript
             * let isSearchable =  this.column.searchable';
             * ```
             * ```html
             *  <igx-column [searchable] = "false"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.searchable = true;
            /**
             * Sets/gets the data type of the column values.
             * Default value is `string`.
             * ```typescript
             * let columnDataType = this.column.dataType;
             * ```
             * ```html
             * <igx-column [dataType] = "'number'"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.dataType = DataType.String;
            /**
             * @hidden
             */
            this.widthChange = new i0.EventEmitter();
            /**
             * @hidden
             */
            this.pinnedChange = new i0.EventEmitter();
            /**
             * Sets/gets the parent column.
             * ```typescript
             * let parentColumn = this.column.parent;
             * ```
             * ```typescript
             * this.column.parent = higherLevelColumn;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.parent = null;
            /**
             * @hidden
             */
            this.destroy$ = new rxjs.Subject();
            /**
             * @hidden
             */
            this._applySelectableClass = false;
            this._vIndex = NaN;
            /**
             * @hidden
             */
            this._pinned = false;
            /**
             * @hidden
             */
            this._summaries = null;
            /**
             * @hidden
             */
            this._filters = null;
            /**
             * @hidden
             */
            this._sortStrategy = DefaultSortingStrategy.instance();
            /**
             * @hidden
             */
            this._hidden = false;
            /**
             * @hidden
             */
            this._disablePinning = false;
            /**
             * @hidden
             */
            this._defaultMinWidth = '';
            /**
             * @hidden
             */
            this._hasSummary = false;
            /**
             * @hidden
             */
            this._collapsible = false;
            /**
             * @hidden
             */
            this._expanded = true;
            /**
             * @hidden
             */
            this._selectable = true;
            this._calcWidth = null;
            this._columnPipeArgs = { format: DEFAULT_DATE_FORMAT, digitsInfo: DEFAULT_DIGITS_INFO };
        }
        Object.defineProperty(IgxColumnComponent.prototype, "field", {
            get: function () {
                return this._field;
            },
            /**
             * Sets/gets the `field` value.
             * ```typescript
             * let columnField = this.column.field;
             * ```
             * ```html
             * <igx-column [field] = "'ID'"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                this._field = value;
                this.hasNestedPath = value === null || value === void 0 ? void 0 : value.includes('.');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "selectable", {
            /**
             * Returns if the column is selectable.
             * ```typescript
             * let columnSelectable = this.column.selectable;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._selectable;
            },
            /**
             * Sets if the column is selectable.
             * Default value is `true`.
             * ```html
             * <igx-column [selectable] = "false"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                this._selectable = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "editable", {
            /**
             * Gets whether the column is editable.
             * Default value is `false`.
             * ```typescript
             * let isEditable = this.column.editable;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                // Updating the primary key when grid has transactions (incl. row edit)
                // should not be allowed, as that can corrupt transaction state.
                var rowEditable = this.grid && this.grid.rowEditable;
                var hasTransactions = this.grid && this.grid.transactions.enabled;
                if (this.isPrimaryColumn && (rowEditable || hasTransactions)) {
                    return false;
                }
                if (this._editable !== undefined) {
                    return this._editable;
                }
                else {
                    return rowEditable;
                }
            },
            /**
             * Sets whether the column is editable.
             * ```typescript
             * this.column.editable = true;
             * ```
             * ```html
             * <igx-column [editable] = "true"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (editable) {
                this._editable = editable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "hasSummary", {
            /**
             * Gets a value indicating whether the summary for the column is enabled.
             * ```typescript
             * let hasSummary = this.column.hasSummary;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._hasSummary;
            },
            /**
             * Sets a value indicating whether the summary for the column is enabled.
             * Default value is `false`.
             * ```html
             * <igx-column [hasSummary] = "true"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                this._hasSummary = value;
                if (this.grid) {
                    this.grid.summaryService.resetSummaryHeight();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "hidden", {
            /**
             * Gets whether the column is hidden.
             * ```typescript
             * let isHidden = this.column.hidden;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._hidden;
            },
            /**
             * Sets the column hidden property.
             * Default value is `false`.
             * ```html
             * <igx-column [hidden] = "true"></igx-column>
             * ```
             *
             * Two-way data binding.
             * ```html
             * <igx-column [(hidden)] = "model.isHidden"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                if (this._hidden !== value) {
                    this._hidden = value;
                    this.hiddenChange.emit(this._hidden);
                    if (this.columnLayoutChild && this.parent.hidden !== value) {
                        this.parent.hidden = value;
                        return;
                    }
                    if (this.grid) {
                        this.grid.endEdit(false);
                        this.grid.summaryService.resetSummaryHeight();
                        this.grid.filteringService.refreshExpressions();
                        this.grid.filteringService.hideFilteringRowOnColumnVisibilityChange(this);
                        this.grid.notifyChanges();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "selected", {
            /**
             * Returns if the column is selected.
             * ```typescript
             * let isSelected = this.column.selected;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this.grid.selectionService.isColumnSelected(this.field);
            },
            /**
             * Select/deselect a column.
             * Default value is `false`.
             * ```typescript
             * this.column.selected = true;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                if (this.selectable && value !== this.selected) {
                    if (value) {
                        this.grid.selectionService.selectColumnsWithNoEvent([this.field]);
                    }
                    else {
                        this.grid.selectionService.deselectColumnsWithNoEvent([this.field]);
                    }
                    this.grid.notifyChanges();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "width", {
            /**
             * Gets the `width` of the column.
             * ```typescript
             * let columnWidth = this.column.width;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this.widthSetByUser ? this._width : this.defaultWidth;
            },
            /**
             * Sets the `width` of the column.
             * ```html
             * <igx-column [width] = "'25%'"></igx-column>
             * ```
             *
             * Two-way data binding.
             * ```html
             * <igx-column [(width)]="model.columns[0].width"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                if (value) {
                    this._calcWidth = null;
                    this.calcPixelWidth = NaN;
                    this.widthSetByUser = true;
                    // width could be passed as number from the template
                    // host bindings are not px affixed so we need to ensure we affix simple number strings
                    if (typeof (value) === 'number' || value.match(/^[0-9]*$/)) {
                        value = value + 'px';
                    }
                    this._width = value;
                    if (this.grid) {
                        this.cacheCalcWidth();
                    }
                    this.widthChange.emit(this._width);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "calcWidth", {
            /**
             * @hidden
             */
            get: function () {
                return this.getCalcWidth();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "maxWidthPx", {
            /**
             * @hidden
             */
            get: function () {
                var gridAvailableSize = this.grid.calcWidth;
                var isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
                return isPercentageWidth ? parseFloat(this.maxWidth) / 100 * gridAvailableSize : parseFloat(this.maxWidth);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "maxWidthPercent", {
            /**
             * @hidden
             */
            get: function () {
                var gridAvailableSize = this.grid.calcWidth;
                var isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
                return isPercentageWidth ? parseFloat(this.maxWidth) : parseFloat(this.maxWidth) / gridAvailableSize * 100;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "minWidthPx", {
            /**
             * @hidden
             */
            get: function () {
                var gridAvailableSize = this.grid.calcWidth;
                var isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
                return isPercentageWidth ? parseFloat(this.minWidth) / 100 * gridAvailableSize : parseFloat(this.minWidth);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "minWidthPercent", {
            /**
             * @hidden
             */
            get: function () {
                var gridAvailableSize = this.grid.calcWidth;
                var isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
                return isPercentageWidth ? parseFloat(this.minWidth) : parseFloat(this.minWidth) / gridAvailableSize * 100;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "minWidth", {
            get: function () {
                return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;
            },
            /**
             * Sets/gets the minimum `width` of the column.
             * Default value is `88`;
             * ```typescript
             * let columnMinWidth = this.column.minWidth;
             * ```
             * ```html
             * <igx-column [minWidth] = "'100px'"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                var minVal = parseFloat(value);
                if (Number.isNaN(minVal)) {
                    return;
                }
                this._defaultMinWidth = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "index", {
            /**
             * Gets the column index.
             * ```typescript
             * let columnIndex = this.column.index;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this.grid.columns.indexOf(this);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "pinned", {
            /**
             * Gets whether the column is `pinned`.
             * ```typescript
             * let isPinned = this.column.pinned;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._pinned;
            },
            /**
             * Sets whether the column is pinned.
             * Default value is `false`.
             * ```html
             * <igx-column [pinned] = "true"></igx-column>
             * ```
             *
             * Two-way data binding.
             * ```html
             * <igx-column [(pinned)] = "model.columns[0].isPinned"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                if (this._pinned !== value) {
                    if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {
                        if (value) {
                            this.pin();
                        }
                        else {
                            this.unpin();
                        }
                        return;
                    }
                    /* No grid/width available at initialization. `initPinning` in the grid
                       will re-init the group (if present)
                    */
                    this._pinned = value;
                    this.pinnedChange.emit(this._pinned);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "summaries", {
            /**
             * Gets the column `summaries`.
             * ```typescript
             * let columnSummaries = this.column.summaries;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._summaries;
            },
            /**
             * Sets the column `summaries`.
             * ```typescript
             * this.column.summaries = IgxNumberSummaryOperand;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (classRef) {
                this._summaries = new classRef();
                if (this.grid) {
                    this.grid.summaryService.removeSummariesCachePerColumn(this.field);
                    this.grid._summaryPipeTrigger++;
                    this.grid.summaryService.resetSummaryHeight();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "filters", {
            /**
             * Gets the column `filters`.
             * ```typescript
             * let columnFilters = this.column.filters'
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._filters;
            },
            /**
             * Sets the column `filters`.
             * ```typescript
             * this.column.filters = IgxBooleanFilteringOperand.instance().
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (instance) {
                this._filters = instance;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "sortStrategy", {
            /**
             * Gets the column `sortStrategy`.
             * ```typescript
             * let sortStrategy = this.column.sortStrategy
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._sortStrategy;
            },
            /**
             * Sets the column `sortStrategy`.
             * ```typescript
             * this.column.sortStrategy = new CustomSortingStrategy().
             * class CustomSortingStrategy extends SortingStrategy {...}
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (classRef) {
                this._sortStrategy = classRef;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "groupingComparer", {
            /**
             * Gets the function that compares values for grouping.
             * ```typescript
             * let groupingComparer = this.column.groupingComparer'
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._groupingComparer;
            },
            /**
             * Sets a custom function to compare values for grouping.
             * Subsequent values in the sorted data that the function returns 0 for are grouped.
             * ```typescript
             * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (funcRef) {
                this._groupingComparer = funcRef;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "defaultMinWidth", {
            /**
             * Gets the default minimum `width` of the column.
             * ```typescript
             * let defaultMinWidth =  this.column.defaultMinWidth;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                if (!this.grid) {
                    return '80';
                }
                switch (this.grid.displayDensity) {
                    case DisplayDensity.cosy:
                        return '64';
                    case DisplayDensity.compact:
                        return '56';
                    default:
                        return '80';
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "grid", {
            /**
             * The reference to the `igx-grid` owner.
             * ```typescript
             * let gridComponent = this.column.grid;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "bodyTemplate", {
            /**
             * Returns a reference to the `bodyTemplate`.
             * ```typescript
             * let bodyTemplate = this.column.bodyTemplate;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._bodyTemplate;
            },
            /**
             * Sets the body template.
             * ```html
             * <ng-template #bodyTemplate igxCell let-val>
             *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
             *       <span> {{val}} </span>
             *    </div>
             * </ng-template>
             * ```
             * ```typescript
             * @ViewChild("'bodyTemplate'", {read: TemplateRef })
             * public bodyTemplate: TemplateRef<any>;
             * this.column.bodyTemplate = this.bodyTemplate;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (template) {
                this._bodyTemplate = template;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "headerTemplate", {
            /**
             * Returns a reference to the header template.
             * ```typescript
             * let headerTemplate = this.column.headerTemplate;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._headerTemplate;
            },
            /**
             * Sets the header template.
             * Note that the column header height is fixed and any content bigger than it will be cut off.
             * ```html
             * <ng-template #headerTemplate>
             *   <div style = "background-color:black" (click) = "changeColor(val)">
             *       <span style="color:red" >{{column.field}}</span>
             *   </div>
             * </ng-template>
             * ```
             * ```typescript
             * @ViewChild("'headerTemplate'", {read: TemplateRef })
             * public headerTemplate: TemplateRef<any>;
             * this.column.headerTemplate = this.headerTemplate;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (template) {
                this._headerTemplate = template;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "inlineEditorTemplate", {
            /**
             * Returns a reference to the inline editor template.
             * ```typescript
             * let inlineEditorTemplate = this.column.inlineEditorTemplate;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._inlineEditorTemplate;
            },
            /**
             * Sets the inline editor template.
             * ```html
             * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
             *     <input type="string" [(ngModel)]="cell.value"/>
             * </ng-template>
             * ```
             * ```typescript
             * @ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
             * public inlineEditorTemplate: TemplateRef<any>;
             * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (template) {
                this._inlineEditorTemplate = template;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "filterCellTemplate", {
            /**
             * Returns a reference to the `filterCellTemplate`.
             * ```typescript
             * let filterCellTemplate = this.column.filterCellTemplate;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._filterCellTemplate;
            },
            /**
             * Sets the quick filter template.
             * ```html
             * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
             *    <input (input)="onInput()">
             * </ng-template>
             * ```
             * ```typescript
             * @ViewChild("'filterCellTemplate'", {read: TemplateRef })
             * public filterCellTemplate: TemplateRef<any>;
             * this.column.filterCellTemplate = this.filterCellTemplate;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (template) {
                this._filterCellTemplate = template;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "cells", {
            /**
             * Gets the cells of the column.
             * ```typescript
             * let columnCells =  this.column.cells;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                var _this = this;
                return this.grid.rowList.filter(function (row) { return row instanceof IgxRowDirective; })
                    .map(function (row) {
                    if (row.cells) {
                        return row.cells.filter(function (cell) { return cell.columnIndex === _this.index; });
                    }
                }).reduce(function (a, b) { return a.concat(b); }, []);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "visibleIndex", {
            /**
             * Gets the column visible index.
             * If the column is not visible, returns `-1`.
             * ```typescript
             * let visibleColumnIndex =  this.column.visibleIndex;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                var _this = this;
                if (!isNaN(this._vIndex)) {
                    return this._vIndex;
                }
                var unpinnedColumns = this.grid.unpinnedColumns.filter(function (c) { return !c.columnGroup; });
                var pinnedColumns = this.grid.pinnedColumns.filter(function (c) { return !c.columnGroup; });
                var col = this;
                var vIndex = -1;
                if (this.columnGroup) {
                    col = this.allChildren.filter(function (c) { return !c.columnGroup && !c.hidden; })[0];
                }
                if (this.columnLayoutChild) {
                    return this.parent.childrenVisibleIndexes.find(function (x) { return x.column === _this; }).index;
                }
                if (!this.pinned) {
                    var indexInCollection = unpinnedColumns.indexOf(col);
                    vIndex = indexInCollection === -1 ?
                        -1 :
                        (this.grid.isPinningToStart ?
                            pinnedColumns.length + indexInCollection :
                            indexInCollection);
                }
                else {
                    var indexInCollection = pinnedColumns.indexOf(col);
                    vIndex = this.grid.isPinningToStart ?
                        indexInCollection :
                        unpinnedColumns.length + indexInCollection;
                }
                this._vIndex = vIndex;
                return vIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "columnGroup", {
            /**
             * Returns a boolean indicating if the column is a `ColumnGroup`.
             * ```typescript
             * let columnGroup =  this.column.columnGroup;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "columnLayout", {
            /**
             * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
             * ```typescript
             * let columnGroup =  this.column.columnGroup;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "columnLayoutChild", {
            /**
             * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
             * ```typescript
             * let columnLayoutChild =  this.column.columnLayoutChild;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this.parent && this.parent.columnLayout;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "allChildren", {
            /**
             * Returns the children columns collection.
             * Returns an empty array if the column does not contain children columns.
             * ```typescript
             * let childrenColumns =  this.column.allChildren;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return [];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "level", {
            /**
             * Returns the level of the column in a column group.
             * Returns `0` if the column doesn't have a `parent`.
             * ```typescript
             * let columnLevel =  this.column.level;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                var ptr = this.parent;
                var lvl = 0;
                while (ptr) {
                    lvl++;
                    ptr = ptr.parent;
                }
                return lvl;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "isLastPinned", {
            get: function () {
                return this.grid.isPinningToStart &&
                    this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "isFirstPinned", {
            get: function () {
                var pinnedCols = this.grid.pinnedColumns.filter(function (x) { return !x.columnGroup; });
                return !this.grid.isPinningToStart && pinnedCols[0] === this;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "rightPinnedOffset", {
            get: function () {
                return this.pinned && !this.grid.isPinningToStart ?
                    -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' :
                    null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "gridRowSpan", {
            get: function () {
                return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "gridColumnSpan", {
            get: function () {
                return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "visibleWhenCollapsed", {
            get: function () {
                return this._visibleWhenCollapsed;
            },
            /**
             * Indicates whether the column will be visible when its parent is collapsed.
             * ```html
             * <igx-column-group>
             *   <igx-column [visibleWhenCollapsed]="true"></igx-column>
             * </igx-column-group>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                this._visibleWhenCollapsed = value;
                this.visibleWhenCollapsedChange.emit(this._visibleWhenCollapsed);
                if (this.parent) {
                    this.parent.setExpandCollapseState();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "pipeArgs", {
            get: function () {
                return this._columnPipeArgs;
            },
            /**
             * @remarks
             * Pass optional parameters for DatePipe and/or DecimalPipe to format the display value for date and numeric columns.
             * Accepts an `IColumnPipeArgs` object with any of the `format`, `timezone` and `digitsInfo` properties.
             * For more details see https://angular.io/api/common/DatePipe and https://angular.io/api/common/DecimalPipe
             * @example
             * ```typescript
             * const pipeArgs: IColumnPipeArgs = {
             *      format: 'longDate',
             *      timezone: 'UTC',
             *      digitsInfo: '1.1-2'
             * }
             * ```
             * ```html
             * <igx-column dataType="date" [pipeArgs]="pipeArgs"></igx-column>
             * <igx-column dataType="number" [pipeArgs]="pipeArgs"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                this._columnPipeArgs = Object.assign(this._columnPipeArgs, value);
                this.grid.summaryService.clearSummaryCache();
                this.grid._pipeTrigger++;
                this.grid.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "collapsible", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return false;
            },
            set: function (_value) { },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "expanded", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return true;
            },
            set: function (_value) { },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "filteringExpressionsTree", {
            /**
             * Returns the filteringExpressionsTree of the column.
             * ```typescript
             * let tree =  this.column.filteringExpressionsTree;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this.grid.filteringExpressionsTree.find(this.field);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "isPrimaryColumn", {
            /**
             * @hidden
             */
            get: function () {
                return this.field !== undefined && this.grid !== undefined && this.field === this.grid.primaryKey;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxColumnComponent.prototype.resetCaches = function () {
            this._vIndex = NaN;
            if (this.grid) {
                this.cacheCalcWidth();
            }
        };
        /**
         * @hidden
         */
        IgxColumnComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden
         */
        IgxColumnComponent.prototype.ngAfterContentInit = function () {
            if (this.cellTemplate) {
                this._bodyTemplate = this.cellTemplate.template;
            }
            if (this.headTemplate && this.headTemplate.length) {
                this._headerTemplate = this.headTemplate.toArray()[0].template;
            }
            if (this.editorTemplate) {
                this._inlineEditorTemplate = this.editorTemplate.template;
            }
            if (this.filterCellTemplateDirective) {
                this._filterCellTemplate = this.filterCellTemplateDirective.template;
            }
            if (!this.summaries) {
                switch (this.dataType) {
                    case DataType.String:
                    case DataType.Boolean:
                        this.summaries = IgxSummaryOperand;
                        break;
                    case DataType.Number:
                        this.summaries = IgxNumberSummaryOperand;
                        break;
                    case DataType.Date:
                        this.summaries = IgxDateSummaryOperand;
                        break;
                    case DataType.Currency:
                        this.summaries = IgxCurrencySummaryOperand;
                        break;
                    case DataType.Percent:
                        this.summaries = IgxPercentSummaryOperand;
                        break;
                    default:
                        this.summaries = IgxSummaryOperand;
                        break;
                }
            }
            if (!this.filters) {
                switch (this.dataType) {
                    case DataType.Boolean:
                        this.filters = IgxBooleanFilteringOperand.instance();
                        break;
                    case DataType.Number:
                    case DataType.Currency:
                    case DataType.Percent:
                        this.filters = IgxNumberFilteringOperand.instance();
                        break;
                    case DataType.Date:
                        this.filters = IgxDateFilteringOperand.instance();
                        break;
                    case DataType.String:
                    default:
                        this.filters = IgxStringFilteringOperand.instance();
                        break;
                }
            }
        };
        /**
         * @hidden
         */
        IgxColumnComponent.prototype.getGridTemplate = function (isRow, isIE) {
            if (isRow) {
                var rowsCount = this.grid.multiRowLayoutRowSize;
                return isIE ?
                    "(1fr)[" + rowsCount + "]" :
                    "repeat(" + rowsCount + ",1fr)";
            }
            else {
                return this.getColumnSizesString(this.children);
            }
        };
        IgxColumnComponent.prototype.getInitialChildColumnSizes = function (children) {
            var _this = this;
            var columnSizes = [];
            // find the smallest col spans
            children.forEach(function (col) {
                if (!col.colStart) {
                    return;
                }
                var newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
                var newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
                var bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
                var bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
                if (columnSizes[col.colStart - 1] === undefined) {
                    // If nothing is defined yet take any column at first
                    // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
                    columnSizes[col.colStart - 1] = {
                        ref: col,
                        width: col.widthSetByUser || _this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                        colSpan: col.gridColumnSpan,
                        colEnd: col.colStart + col.gridColumnSpan,
                        widthSetByUser: col.widthSetByUser
                    };
                }
                else if (newWidthSet || (newSpanSmaller && ((bothWidthsSet) || (bothWidthsNotSet)))) {
                    // If a column is set already it should either not have width defined or have width with bigger span than the new one.
                    /**
                     *  If replaced column has bigger span, we want to fill the remaining columns
                     *  that the replacing column does not fill with the old one.
                     */
                    if (bothWidthsSet && newSpanSmaller) {
                        // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                        // We have not yet replaced it so we can use it directly from the columnSizes collection.
                        // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                        for (var i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                            if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                                columnSizes[i] = columnSizes[col.colStart - 1];
                            }
                            else {
                                break;
                            }
                        }
                    }
                    // Replace the old column with the new one.
                    columnSizes[col.colStart - 1] = {
                        ref: col,
                        width: col.widthSetByUser || _this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                        colSpan: col.gridColumnSpan,
                        colEnd: col.colStart + col.gridColumnSpan,
                        widthSetByUser: col.widthSetByUser
                    };
                }
                else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
                    // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
                    // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
                    // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
                    for (var i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {
                        if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                            columnSizes[i] = {
                                ref: col,
                                width: col.widthSetByUser || _this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                                colSpan: col.gridColumnSpan,
                                colEnd: col.colStart + col.gridColumnSpan,
                                widthSetByUser: col.widthSetByUser
                            };
                        }
                        else {
                            break;
                        }
                    }
                }
            });
            // Flatten columnSizes so there are not columns with colSpan > 1
            for (var i = 0; i < columnSizes.length; i++) {
                if (columnSizes[i] && columnSizes[i].colSpan > 1) {
                    var j = 1;
                    // Replace all empty places depending on how much the current column spans starting from next col.
                    for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                        if (columnSizes[i + j] &&
                            ((!columnSizes[i].width && columnSizes[i + j].width) ||
                                (!columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan) ||
                                (!!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan))) {
                            // If we reach an already defined column that has width and the current doesn't have or
                            // if the reached column has bigger colSpan we stop.
                            break;
                        }
                        else {
                            var width = columnSizes[i].widthSetByUser ?
                                columnSizes[i].width / columnSizes[i].colSpan :
                                columnSizes[i].width;
                            columnSizes[i + j] = {
                                ref: columnSizes[i].ref,
                                width: width,
                                colSpan: 1,
                                colEnd: columnSizes[i].colEnd,
                                widthSetByUser: columnSizes[i].widthSetByUser
                            };
                        }
                    }
                    // Update the current column width so it is divided between all columns it spans and set it to 1.
                    columnSizes[i].width = columnSizes[i].widthSetByUser ?
                        columnSizes[i].width / columnSizes[i].colSpan :
                        columnSizes[i].width;
                    columnSizes[i].colSpan = 1;
                    // Update the index based on how much we have replaced. Subtract 1 because we started from 1.
                    i += j - 1;
                }
            }
            return columnSizes;
        };
        IgxColumnComponent.prototype.getFilledChildColumnSizes = function (children) {
            var e_1, _a;
            var columnSizes = this.getInitialChildColumnSizes(children);
            // fill the gaps if there are any
            var result = [];
            try {
                for (var columnSizes_1 = __values(columnSizes), columnSizes_1_1 = columnSizes_1.next(); !columnSizes_1_1.done; columnSizes_1_1 = columnSizes_1.next()) {
                    var size = columnSizes_1_1.value;
                    if (size && !!size.width) {
                        result.push(size.width + 'px');
                    }
                    else {
                        result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (columnSizes_1_1 && !columnSizes_1_1.done && (_a = columnSizes_1.return)) _a.call(columnSizes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        };
        IgxColumnComponent.prototype.getResizableColUnderEnd = function () {
            var e_2, _a;
            if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {
                return [{ target: this, spanUsed: 1 }];
            }
            var columnSized = this.getInitialChildColumnSizes(this.parent.children);
            var targets = [];
            var colEnd = this.colEnd ? this.colEnd : this.colStart + 1;
            for (var i = 0; i < columnSized.length; i++) {
                if (this.colStart <= i + 1 && i + 1 < colEnd) {
                    targets.push({ target: columnSized[i].ref, spanUsed: 1 });
                }
            }
            var targetsSquashed = [];
            try {
                for (var targets_1 = __values(targets), targets_1_1 = targets_1.next(); !targets_1_1.done; targets_1_1 = targets_1.next()) {
                    var target = targets_1_1.value;
                    if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === target.target.field) {
                        targetsSquashed[targetsSquashed.length - 1].spanUsed++;
                    }
                    else {
                        targetsSquashed.push(target);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (targets_1_1 && !targets_1_1.done && (_a = targets_1.return)) _a.call(targets_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return targetsSquashed;
        };
        /**
         * Pins the column at the provided index in the pinned area.
         * Defaults to index `0` if not provided, or to the initial index in the pinned area.
         * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
         * Column cannot be pinned if:
         * - Is already pinned
         * - index argument is out of range
         * - The pinned area exceeds 80% of the grid width
         * ```typescript
         * let success = this.column.pin();
         * ```
         *
         * @memberof IgxColumnComponent
         */
        IgxColumnComponent.prototype.pin = function (index) {
            // TODO: Probably should the return type of the old functions
            // should be moved as a event parameter.
            var grid = this.grid;
            if (this._pinned) {
                return false;
            }
            if (this.parent && !this.parent.pinned) {
                return this.topLevelParent.pin(index);
            }
            var hasIndex = index !== undefined;
            if (hasIndex && (index < 0 || index > grid.pinnedColumns.length)) {
                return false;
            }
            if (!this.parent && !this.pinnable) {
                return false;
            }
            var rootPinnedCols = grid._pinnedColumns.filter(function (c) { return c.level === 0; });
            index = hasIndex ? index : rootPinnedCols.length;
            var args = { column: this, insertAtIndex: index, isPinned: false, cancel: false };
            this.grid.onColumnPinning.emit(args);
            if (args.cancel) {
                return;
            }
            grid.endEdit(false);
            this._pinned = true;
            this.pinnedChange.emit(this._pinned);
            // it is possible that index is the last position, so will need to find target column by [index-1]
            var targetColumn = args.insertAtIndex === grid._pinnedColumns.length ?
                grid._pinnedColumns[args.insertAtIndex - 1] : grid._pinnedColumns[args.insertAtIndex];
            if (grid._pinnedColumns.indexOf(this) === -1) {
                if (!grid.hasColumnGroups) {
                    grid._pinnedColumns.splice(args.insertAtIndex, 0, this);
                }
                else {
                    // insert based only on root collection
                    rootPinnedCols.splice(args.insertAtIndex, 0, this);
                    var allPinned_1 = [];
                    // re-create hierarchy
                    rootPinnedCols.forEach(function (group) {
                        allPinned_1.push(group);
                        allPinned_1 = allPinned_1.concat(group.allChildren);
                    });
                    grid._pinnedColumns = allPinned_1;
                }
                if (grid._unpinnedColumns.indexOf(this) !== -1) {
                    var childrenCount = this.allChildren.length;
                    grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1 + childrenCount);
                }
            }
            if (hasIndex) {
                grid._moveColumns(this, targetColumn);
            }
            if (this.columnGroup) {
                this.allChildren.forEach(function (child) { return child.pin(); });
                grid.reinitPinStates();
            }
            grid.resetCaches();
            grid.notifyChanges();
            if (this.columnLayoutChild) {
                this.grid.columns.filter(function (x) { return x.columnLayout; }).forEach(function (x) { return x.populateVisibleIndexes(); });
            }
            this.grid.filteringService.refreshExpressions();
            var eventArgs = { column: this, insertAtIndex: index, isPinned: true };
            this.grid.columnPinned.emit(eventArgs);
            return true;
        };
        /**
         * Unpins the column and place it at the provided index in the unpinned area.
         * Defaults to index `0` if not provided, or to the initial index in the unpinned area.
         * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
         * Column cannot be unpinned if:
         * - Is already unpinned
         * - index argument is out of range
         * ```typescript
         * let success = this.column.unpin();
         * ```
         *
         * @memberof IgxColumnComponent
         */
        IgxColumnComponent.prototype.unpin = function (index) {
            var grid = this.grid;
            if (!this._pinned) {
                return false;
            }
            if (this.parent && this.parent.pinned) {
                return this.topLevelParent.unpin(index);
            }
            var hasIndex = index !== undefined;
            if (hasIndex && (index < 0 || index > grid._unpinnedColumns.length)) {
                return false;
            }
            // estimate the exact index at which column will be inserted
            // takes into account initial unpinned index of the column
            if (!hasIndex) {
                var indices = grid.unpinnedColumns.map(function (col) { return col.index; });
                indices.push(this.index);
                indices.sort(function (a, b) { return a - b; });
                index = indices.indexOf(this.index);
            }
            var args = { column: this, insertAtIndex: index, isPinned: true, cancel: false };
            this.grid.onColumnPinning.emit(args);
            if (args.cancel) {
                return;
            }
            this.grid.endEdit(false);
            this._pinned = false;
            this.pinnedChange.emit(this._pinned);
            // it is possible that index is the last position, so will need to find target column by [index-1]
            var targetColumn = args.insertAtIndex === grid._unpinnedColumns.length ?
                grid._unpinnedColumns[args.insertAtIndex - 1] : grid._unpinnedColumns[args.insertAtIndex];
            if (!hasIndex) {
                grid._unpinnedColumns.splice(index, 0, this);
                if (grid._pinnedColumns.indexOf(this) !== -1) {
                    grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
                }
            }
            if (hasIndex) {
                grid.moveColumn(this, targetColumn);
            }
            if (this.columnGroup) {
                this.allChildren.forEach(function (child) { return child.unpin(); });
            }
            grid.reinitPinStates();
            grid.resetCaches();
            grid.notifyChanges();
            if (this.columnLayoutChild) {
                this.grid.columns.filter(function (x) { return x.columnLayout; }).forEach(function (x) { return x.populateVisibleIndexes(); });
            }
            this.grid.filteringService.refreshExpressions();
            this.grid.columnPinned.emit({ column: this, insertAtIndex: index, isPinned: false });
            return true;
        };
        /**
         * Moves a column to the specified visible index.
         * If passed index is invalid, or if column would receive a different visible index after moving, moving is not performed.
         * If passed index would move the column to a different column group. moving is not performed.
         *
         * @example
         * ```typescript
         * column.move(index);
         * ```
         * @memberof IgxColumnComponent
         */
        IgxColumnComponent.prototype.move = function (index) {
            var _this = this;
            var target;
            var grid = this.grid;
            var columns = grid.columnList.filter(function (c) { return c.visibleIndex > -1; });
            // grid last visible index
            var li = columns.map(function (c) { return c.visibleIndex; }).reduce(function (a, b) { return Math.max(a, b); });
            var parent = this.parent;
            var isPreceding = this.visibleIndex < index;
            if (index === this.visibleIndex || index < 0 || index > li) {
                return;
            }
            if (parent) {
                columns = columns.filter(function (c) { return c.level >= _this.level && c !== _this && c.parent !== _this &&
                    c.topLevelParent === _this.topLevelParent; });
            }
            /* eslint-disable max-len */
            // If isPreceding, find a target such that when the current column is placed after it, current colummn will receive a visibleIndex === index. This takes into account visible children of the columns.
            // If !isPreceding, finds a column of the same level and visible index that equals the passed index agument (c.visibleIndex === index). No need to consider the children here.
            /* eslint-enable max-len */
            if (isPreceding) {
                columns = columns.filter(function (c) { return c.visibleIndex > _this.visibleIndex; });
                target = columns.find(function (c) { return c.level === _this.level && c.visibleIndex + c.calcChildren() - _this.calcChildren() === index; });
            }
            else {
                columns = columns.filter(function (c) { return c.visibleIndex < _this.visibleIndex; });
                target = columns.find(function (c) { return c.level === _this.level && c.visibleIndex === index; });
            }
            if (!target || (target.pinned && this.disablePinning)) {
                return;
            }
            var pos = isPreceding ? DropPosition.AfterDropTarget : DropPosition.BeforeDropTarget;
            grid.moveColumn(this, target, pos);
        };
        /**
         * No children for the column, so will returns 1 or 0, if the column is hidden.
         *
         * @hidden
         */
        IgxColumnComponent.prototype.calcChildren = function () {
            var children = this.hidden ? 0 : 1;
            return children;
        };
        /**
         * Toggles column vibisility and emits the respective event.
         *
         * @hidden
         */
        IgxColumnComponent.prototype.toggleVisibility = function (value) {
            var newValue = value !== null && value !== void 0 ? value : !this.hidden;
            var eventArgs = { column: this, newValue: newValue, cancel: false };
            this.grid.columnVisibilityChanging.emit(eventArgs);
            if (eventArgs.cancel) {
                return;
            }
            this.hidden = newValue;
            this.grid.onColumnVisibilityChanged.emit({ column: this, newValue: newValue });
        };
        Object.defineProperty(IgxColumnComponent.prototype, "topLevelParent", {
            /**
             * Returns a reference to the top level parent column.
             * ```typescript
             * let topLevelParent =  this.column.topLevelParent;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                var parent = this.parent;
                while (parent && parent.parent) {
                    parent = parent.parent;
                }
                return parent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "headerCell", {
            /**
             * Returns a reference to the header of the column.
             * ```typescript
             * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
             * let headerCell = column.headerCell;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                var _this = this;
                return this.grid.headerCellList.find(function (header) { return header.column === _this; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "filterCell", {
            /**
             * Returns a reference to the filter cell of the column.
             * ```typescript
             * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
             * let filterell = column.filterell;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                var _this = this;
                return this.grid.filterCellList.find(function (filterCell) { return filterCell.column === _this; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "headerGroup", {
            /**
             * Returns a reference to the header group of the column.
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                var _this = this;
                return this.grid.headerGroupsList.find(function (headerGroup) { return headerGroup.column === _this; });
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Autosize the column to the longest currently visible cell value, including the header cell.
         * ```typescript
         * @ViewChild('grid') grid: IgxGridComponent;
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * column.autosize();
         * ```
         *
         * @memberof IgxColumnComponent
         * @param byHeader Set if column should be autized based only on the header content
         */
        IgxColumnComponent.prototype.autosize = function (byHeader) {
            if (byHeader === void 0) { byHeader = false; }
            if (!this.columnGroup) {
                var size = this.getAutoSize(byHeader);
                this.width = size;
                this.grid.reflow();
            }
        };
        /**
         * @hidden
         */
        IgxColumnComponent.prototype.getAutoSize = function (byHeader) {
            if (byHeader === void 0) { byHeader = false; }
            var size = !byHeader ? this.getLargestCellWidth() :
                (Object.values(this.getHeaderCellWidths()).reduce(function (a, b) { return a + b; }) + 'px');
            var gridAvailableSize = this.grid.calcWidth;
            var newWidth;
            var isPercentageWidth = this.width && typeof this.width === 'string' && this.width.indexOf('%') !== -1;
            if (isPercentageWidth) {
                var percentageSize = parseFloat(size) / gridAvailableSize * 100;
                newWidth = percentageSize + '%';
            }
            else {
                newWidth = size;
            }
            return newWidth;
        };
        /**
         * @hidden
         */
        IgxColumnComponent.prototype.getCalcWidth = function () {
            if (this._calcWidth && !isNaN(this.calcPixelWidth)) {
                return this._calcWidth;
            }
            this.cacheCalcWidth();
            return this._calcWidth;
        };
        /**
         * @hidden
         * Returns the width and padding of a header cell.
         */
        IgxColumnComponent.prototype.getHeaderCellWidths = function () {
            var range = this.grid.document.createRange();
            var headerWidth;
            if (this.headerTemplate && this.headerCell.elementRef.nativeElement.children[0].children.length > 0) {
                headerWidth = Math.max.apply(Math, __spread(Array.from(this.headerCell.elementRef.nativeElement.children[0].children)
                    .map(function (child) { return getNodeSizeViaRange(range, child); })));
            }
            else {
                headerWidth = getNodeSizeViaRange(range, this.headerCell.elementRef.nativeElement.children[0]);
            }
            if (this.sortable || this.filterable) {
                headerWidth += this.headerCell.elementRef.nativeElement.children[1].getBoundingClientRect().width;
            }
            var headerStyle = this.grid.document.defaultView.getComputedStyle(this.headerCell.elementRef.nativeElement);
            var headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) +
                parseFloat(headerStyle.borderRightWidth);
            // Take into consideration the header group element, since column pinning applies borders to it if its not a columnGroup.
            var headerGroupStyle = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement);
            var borderSize = !this.parent ? parseFloat(headerGroupStyle.borderRightWidth) + parseFloat(headerGroupStyle.borderLeftWidth) : 0;
            return { width: Math.ceil(headerWidth), padding: Math.ceil(headerPadding + borderSize) };
        };
        /**
         * @hidden
         * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
         * ```typescript
         * @ViewChild('grid') grid: IgxGridComponent;
         *
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * let size = column.getLargestCellWidth();
         * ```
         * @memberof IgxColumnComponent
         */
        IgxColumnComponent.prototype.getLargestCellWidth = function () {
            var range = this.grid.document.createRange();
            var largest = new Map();
            if (this.cells.length > 0) {
                var cellsContentWidths_1 = [];
                if (this.cells[0].nativeElement.children.length > 0) {
                    this.cells.forEach(function (cell) { return cellsContentWidths_1.push(cell.calculateSizeToFit(range)); });
                }
                else {
                    cellsContentWidths_1 = this.cells.map(function (cell) { return getNodeSizeViaRange(range, cell.nativeElement); });
                }
                var index = cellsContentWidths_1.indexOf(Math.max.apply(Math, __spread(cellsContentWidths_1)));
                var cellStyle = this.grid.document.defaultView.getComputedStyle(this.cells[index].nativeElement);
                var cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) +
                    parseFloat(cellStyle.borderLeftWidth) + parseFloat(cellStyle.borderRightWidth);
                largest.set(Math.max.apply(Math, __spread(cellsContentWidths_1)), cellPadding);
            }
            if (this.headerCell) {
                var headerCellWidths = this.getHeaderCellWidths();
                largest.set(headerCellWidths.width, headerCellWidths.padding);
            }
            var largestCell = Math.max.apply(Math, __spread(Array.from(largest.keys())));
            var width = Math.ceil(largestCell + largest.get(largestCell));
            if (Number.isNaN(width)) {
                return this.width;
            }
            else {
                return width + 'px';
            }
        };
        /**
         * @hidden
         */
        IgxColumnComponent.prototype.getCellWidth = function () {
            var colWidth = this.width;
            var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
            if (this.columnLayoutChild) {
                return '';
            }
            if (colWidth && !isPercentageWidth) {
                var cellWidth = colWidth;
                if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
                    cellWidth += 'px';
                }
                return cellWidth;
            }
            else {
                return colWidth;
            }
        };
        /**
         * @hidden
         */
        IgxColumnComponent.prototype.populateVisibleIndexes = function () { };
        IgxColumnComponent.prototype.getColumnSizesString = function (children) {
            var res = this.getFilledChildColumnSizes(children);
            return res.join(' ');
        };
        /**
         * @hidden
         * @internal
         */
        IgxColumnComponent.prototype.cacheCalcWidth = function () {
            var grid = this.gridAPI.grid;
            var colWidth = this.width;
            var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
            if (isPercentageWidth) {
                this._calcWidth = parseFloat(colWidth) / 100 * grid.calcWidth;
            }
            else if (!colWidth) {
                // no width
                this._calcWidth = this.defaultWidth || grid.getPossibleColumnWidth();
            }
            else {
                this._calcWidth = this.width;
            }
            this.calcPixelWidth = parseFloat(this._calcWidth);
        };
        /**
         * @hidden
         * @internal
         */
        IgxColumnComponent.prototype.setExpandCollapseState = function () {
            var _this = this;
            this.children.filter(function (col) { return (col.visibleWhenCollapsed !== undefined); }).forEach(function (c) {
                if (!_this.collapsible) {
                    c.hidden = _this.hidden;
                    return;
                }
                c.hidden = _this._expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxColumnComponent.prototype.checkCollapsibleState = function () {
            if (!this.children) {
                return false;
            }
            var cols = this.children.map(function (child) { return child.visibleWhenCollapsed; });
            return (cols.some(function (c) { return c === true; }) && cols.some(function (c) { return c === false; }));
        };
        Object.defineProperty(IgxColumnComponent.prototype, "pinnable", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid._init || !this.pinned;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "applySelectableClass", {
            /**
             * @hidden
             */
            get: function () {
                return this._applySelectableClass;
            },
            /**
             * @hidden
             */
            set: function (value) {
                if (this.selectable) {
                    this._applySelectableClass = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        return IgxColumnComponent;
    }());
    IgxColumnComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-column',
                    template: ""
                },] }
    ];
    IgxColumnComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxColumnComponent.propDecorators = {
        field: [{ type: i0.Input }],
        header: [{ type: i0.Input }],
        title: [{ type: i0.Input }],
        sortable: [{ type: i0.Input }],
        selectable: [{ type: i0.Input }],
        groupable: [{ type: i0.Input }],
        editable: [{ type: i0.Input }],
        filterable: [{ type: i0.Input }],
        resizable: [{ type: i0.Input }],
        hasSummary: [{ type: i0.Input }],
        hidden: [{ type: i0.Input }],
        hiddenChange: [{ type: i0.Output }],
        expandedChange: [{ type: i0.Output }],
        collapsibleChange: [{ type: i0.Output }],
        visibleWhenCollapsedChange: [{ type: i0.Output }],
        onColumnChange: [{ type: i0.Output }],
        disableHiding: [{ type: i0.Input }],
        disablePinning: [{ type: i0.Input }],
        movable: [{ type: i0.Input }],
        width: [{ type: i0.Input }],
        maxWidth: [{ type: i0.Input }],
        headerClasses: [{ type: i0.Input }],
        headerGroupClasses: [{ type: i0.Input }],
        cellClasses: [{ type: i0.Input }],
        cellStyles: [{ type: i0.Input }],
        formatter: [{ type: i0.Input }],
        filteringIgnoreCase: [{ type: i0.Input }],
        sortingIgnoreCase: [{ type: i0.Input }],
        searchable: [{ type: i0.Input }],
        dataType: [{ type: i0.Input }],
        collapsibleIndicatorTemplate: [{ type: i0.Input }],
        rowEnd: [{ type: i0.Input }],
        colEnd: [{ type: i0.Input }],
        rowStart: [{ type: i0.Input }],
        colStart: [{ type: i0.Input }],
        widthChange: [{ type: i0.Output }],
        pinnedChange: [{ type: i0.Output }],
        filterCellTemplateDirective: [{ type: i0.ContentChild, args: [IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective },] }],
        cellTemplate: [{ type: i0.ContentChild, args: [IgxCellTemplateDirective, { read: IgxCellTemplateDirective },] }],
        headTemplate: [{ type: i0.ContentChildren, args: [IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective, descendants: false },] }],
        editorTemplate: [{ type: i0.ContentChild, args: [IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective },] }],
        collapseIndicatorTemplate: [{ type: i0.ContentChild, args: [IgxCollapsibleIndicatorTemplateDirective, { read: IgxCollapsibleIndicatorTemplateDirective, static: false },] }],
        minWidth: [{ type: i0.Input }],
        pinned: [{ type: i0.Input }],
        summaries: [{ type: i0.Input }],
        filters: [{ type: i0.Input }],
        sortStrategy: [{ type: i0.Input }],
        groupingComparer: [{ type: i0.Input }],
        bodyTemplate: [{ type: i0.Input, args: ['cellTemplate',] }],
        headerTemplate: [{ type: i0.Input }],
        inlineEditorTemplate: [{ type: i0.Input, args: ['cellEditorTemplate',] }],
        filterCellTemplate: [{ type: i0.Input, args: ['filterCellTemplate',] }],
        visibleWhenCollapsed: [{ type: i0.Input }],
        pipeArgs: [{ type: i0.Input }]
    };
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "header", void 0);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "title", void 0);
    __decorate([
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "sortable", void 0);
    __decorate([
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "selectable", null);
    __decorate([
        notifyChanges(true),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "groupable", void 0);
    __decorate([
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "editable", null);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "filterable", void 0);
    __decorate([
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "resizable", void 0);
    __decorate([
        notifyChanges(true),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "hasSummary", null);
    __decorate([
        notifyChanges(true),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "hidden", null);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "disableHiding", void 0);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "disablePinning", void 0);
    __decorate([
        WatchColumnChanges(),
        notifyChanges()
    ], IgxColumnComponent.prototype, "movable", void 0);
    __decorate([
        notifyChanges(true),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "width", null);
    __decorate([
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "maxWidth", void 0);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "headerClasses", void 0);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "headerGroupClasses", void 0);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "cellClasses", void 0);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "cellStyles", void 0);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "formatter", void 0);
    __decorate([
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "filteringIgnoreCase", void 0);
    __decorate([
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "sortingIgnoreCase", void 0);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "searchable", void 0);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "minWidth", null);
    __decorate([
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "pinned", null);
    __decorate([
        notifyChanges(true),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "summaries", null);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "bodyTemplate", null);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "headerTemplate", null);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "inlineEditorTemplate", null);
    __decorate([
        notifyChanges(),
        WatchColumnChanges()
    ], IgxColumnComponent.prototype, "filterCellTemplate", null);
    __decorate([
        notifyChanges(true)
    ], IgxColumnComponent.prototype, "visibleWhenCollapsed", null);

    var IgxColumnGroupComponent = /** @class */ (function (_super) {
        __extends(IgxColumnGroupComponent, _super);
        function IgxColumnGroupComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.children = new i0.QueryList();
            /**
             * Sets/gets whether the column group is `searchable`.
             * Default value is `true`.
             * ```typescript
             * let isSearchable =  this.columnGroup.searchable;
             * ```
             * ```html
             *  <igx-column-group [searchable] = "false"></igx-column-group>
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            _this.searchable = true;
            /**
             * @hidden
             */
            _this.hiddenChange = new i0.EventEmitter();
            return _this;
        }
        Object.defineProperty(IgxColumnGroupComponent.prototype, "collapsible", {
            get: function () {
                return this._collapsible && this.checkCollapsibleState();
            },
            /**
             * Set if the column group is collapsible.
             * Default value is `false`
             * ```html
             *  <igx-column-group [collapsible] = "true"></igx-column-group>
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            set: function (value) {
                this._collapsible = value;
                this.collapsibleChange.emit(this._collapsible);
                if (this.children && !this.hidden) {
                    if (this._collapsible) {
                        this.setExpandCollapseState();
                    }
                    else {
                        this.children.forEach(function (child) { return child.hidden = false; });
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "expanded", {
            get: function () {
                return this._expanded;
            },
            /**
             * Set whether the group is expanded or collapsed initially.
             * Applied only if the collapsible property is set to `true`
             * Default value is `true`
             * ```html
             *  const state = false
             *  <igx-column-group [(expand)] = "state"></igx-column-group>
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            set: function (value) {
                this._expanded = value;
                this.expandedChange.emit(this._expanded);
                if (!this.collapsible) {
                    return;
                }
                if (!this.hidden && this.children) {
                    this.setExpandCollapseState();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "summaries", {
            /**
             * Gets the column group `summaries`.
             * ```typescript
             * let columnGroupSummaries = this.columnGroup.summaries;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this._summaries;
            },
            /**
             * Sets the column group `summaries`.
             * ```typescript
             * this.columnGroup.summaries = IgxNumberSummaryOperand;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            set: function (classRef) { },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "filters", {
            /**
             * Gets the column group `filters`.
             * ```typescript
             * let columnGroupFilters = this.columnGroup.filters;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this._filters;
            },
            /**
             * Sets the column group `filters`.
             * ```typescript
             * this.columnGroup.filters = IgxStringFilteringOperand;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            set: function (classRef) { },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "selectable", {
            /**
             * Returns if the column group is selectable
             * ```typescript
             * let columnGroupSelectable = this.columnGroup.selectable;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this.children && this.children.some(function (child) { return child.selectable; });
            },
            set: function (value) { },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "bodyTemplate", {
            /**
             * Returns a reference to the body template.
             * ```typescript
             * let bodyTemplate = this.columnGroup.bodyTemplate;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this._bodyTemplate;
            },
            /**
             * @hidden
             */
            set: function (template) { },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "inlineEditorTemplate", {
            /**
             * Returns a reference to the inline editor template.
             * ```typescript
             * let inlineEditorTemplate = this.columnGroup.inlineEditorTemplate;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this._inlineEditorTemplate;
            },
            /**
             * @hidden
             */
            set: function (template) { },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "cells", {
            /**
             * Gets the column group cells.
             * ```typescript
             * let columnCells = this.columnGroup.cells;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return [];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "hidden", {
            /**
             * Gets whether the column group is hidden.
             * ```typescript
             * let isHidden = this.columnGroup.hidden;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this.allChildren.every(function (c) { return c.hidden; });
            },
            /**
             * Sets the column group hidden property.
             * ```html
             * <igx-column [hidden] = "true"></igx-column>
             * ```
             *
             * Two-way data binding
             * ```html
             * <igx-column [(hidden)] = "model.columns[0].isHidden"></igx-column>
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            set: function (value) {
                var _this = this;
                this._hidden = value;
                this.hiddenChange.emit(this._hidden);
                if (this._hidden || !this.collapsible) {
                    this.children.forEach(function (child) { return child.hidden = _this._hidden; });
                }
                else {
                    this.children.forEach(function (c) {
                        if (c.visibleWhenCollapsed === undefined) {
                            c.hidden = false;
                            return;
                        }
                        c.hidden = _this.expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
                    });
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "selected", {
            /**
             * Returns if the column group is selected.
             * ```typescript
             * let isSelected = this.columnGroup.selected;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                var selectableChildren = this.allChildren.filter(function (c) { return !c.columnGroup && c.selectable && !c.hidden; });
                return selectableChildren.length > 0 && selectableChildren.every(function (c) { return c.selected; });
            },
            /**
             * Select/deselect the column group.
             * ```typescript
             * this.columnGroup.selected = true;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            set: function (value) {
                if (this.selectable) {
                    this.children.forEach(function (c) {
                        c.selected = value;
                    });
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxColumnGroupComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            /*
                @ContentChildren with descendants still returns the `parent`
                component in the query list.
            */
            if (this.headTemplate && this.headTemplate.length) {
                this._headerTemplate = this.headTemplate.toArray()[0].template;
            }
            if (this.collapseIndicatorTemplate) {
                this.collapsibleIndicatorTemplate = this.collapseIndicatorTemplate.template;
            }
            // currently only ivy fixes the issue, we have to slice only if the first child is group
            if (this.children.first === this) {
                this.children.reset(this.children.toArray().slice(1));
            }
            this.children.forEach(function (child) {
                child.parent = _this;
            });
            if (this.collapsible) {
                this.setExpandCollapseState();
            }
        };
        Object.defineProperty(IgxColumnGroupComponent.prototype, "allChildren", {
            /**
             * Returns the children columns collection.
             * ```typescript
             * let columns =  this.columnGroup.allChildren;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return flatten(this.children.toArray());
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "columnGroup", {
            /**
             * Returns a boolean indicating if the column is a `ColumnGroup`.
             * ```typescript
             * let isColumnGroup =  this.columnGroup.columnGroup
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "columnLayout", {
            /**
             * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
             * ```typescript
             * let columnGroup =  this.column.columnGroup;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "width", {
            /**
             * Gets the width of the column group.
             * ```typescript
             * let columnGroupWidth = this.columnGroup.width;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                var width = "" + this.children.reduce(function (acc, val) {
                    if (val.hidden) {
                        return acc;
                    }
                    return acc + parseInt(val.calcWidth, 10);
                }, 0);
                return width + 'px';
            },
            set: function (val) { },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "applySelectableClass", {
            /**
             * @hidden
             */
            get: function () {
                return this._applySelectableClass;
            },
            /**
             * @hidden
             */
            set: function (value) {
                if (this.selectable) {
                    this._applySelectableClass = value;
                    this.children.forEach(function (c) {
                        c.applySelectableClass = value;
                    });
                }
            },
            enumerable: false,
            configurable: true
        });
        // constructor(public gridAPI: GridBaseAPIService<IgxGridBaseDirective & IGridDataBindable>, public cdr: ChangeDetectorRef) {
        //     // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        //     super(gridAPI, cdr);
        // }
        /**
         * @hidden
         * Calculates the number of visible columns, based on indexes of first and last visible columns.
         */
        IgxColumnGroupComponent.prototype.calcChildren = function () {
            var visibleChildren = this.allChildren.filter(function (c) { return c.visibleIndex > -1; });
            var fi = visibleChildren[0].visibleIndex;
            var li = visibleChildren[visibleChildren.length - 1].visibleIndex;
            return li - fi + 1;
        };
        return IgxColumnGroupComponent;
    }(IgxColumnComponent));
    IgxColumnGroupComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: IgxColumnComponent, useExisting: i0.forwardRef(function () { return IgxColumnGroupComponent; }) }],
                    selector: 'igx-column-group',
                    template: ""
                },] }
    ];
    IgxColumnGroupComponent.propDecorators = {
        children: [{ type: i0.ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent },] }],
        collapsible: [{ type: i0.Input }],
        expanded: [{ type: i0.Input }],
        summaries: [{ type: i0.Input }],
        searchable: [{ type: i0.Input }],
        filters: [{ type: i0.Input }],
        collapsibleIndicatorTemplate: [{ type: i0.Input }],
        hidden: [{ type: i0.Input }],
        hiddenChange: [{ type: i0.Output }]
    };

    /**
     * A component used for presenting Excel style column moving UI.
     */
    var IgxExcelStyleMovingComponent = /** @class */ (function () {
        function IgxExcelStyleMovingComponent(esf) {
            this.esf = esf;
            /**
             * @hidden @internal
             */
            this.defaultClass = true;
        }
        Object.defineProperty(IgxExcelStyleMovingComponent.prototype, "visibleColumns", {
            get: function () {
                return this.esf.grid.visibleColumns.filter(function (col) { return !(col instanceof IgxColumnGroupComponent); });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleMovingComponent.prototype, "canNotMoveLeft", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.esf.column.visibleIndex === 0 ||
                    (this.esf.grid.unpinnedColumns.indexOf(this.esf.column) === 0 && this.esf.column.disablePinning) ||
                    (this.esf.column.level !== 0 && !this.findColumn(0, this.visibleColumns));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleMovingComponent.prototype, "canNotMoveRight", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.esf.column.visibleIndex === this.visibleColumns.length - 1 ||
                    (this.esf.column.level !== 0 && !this.findColumn(1, this.visibleColumns));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxExcelStyleMovingComponent.prototype.onMoveButtonClicked = function (moveDirection) {
            var targetColumn;
            if (this.esf.column.pinned) {
                if (this.esf.column.isLastPinned && moveDirection === 1 && this.esf.grid.isPinningToStart) {
                    targetColumn = this.esf.grid.unpinnedColumns[0];
                    moveDirection = 0;
                }
                else if (this.esf.column.isFirstPinned && moveDirection === 0 && !this.esf.grid.isPinningToStart) {
                    targetColumn = this.esf.grid.unpinnedColumns[this.esf.grid.unpinnedColumns.length - 1];
                    moveDirection = 1;
                }
                else {
                    targetColumn = this.findColumn(moveDirection, this.esf.grid.pinnedColumns);
                }
            }
            else if (this.esf.grid.unpinnedColumns.indexOf(this.esf.column) === 0 && moveDirection === 0 &&
                this.esf.grid.isPinningToStart) {
                targetColumn = this.esf.grid.pinnedColumns[this.esf.grid.pinnedColumns.length - 1];
                if (targetColumn.parent) {
                    targetColumn = targetColumn.topLevelParent;
                }
                moveDirection = 1;
            }
            else if (this.esf.grid.unpinnedColumns.indexOf(this.esf.column) === this.esf.grid.unpinnedColumns.length - 1 &&
                moveDirection === 1 && !this.esf.grid.isPinningToStart) {
                targetColumn = this.esf.grid.pinnedColumns[0];
                moveDirection = 0;
            }
            else {
                targetColumn = this.findColumn(moveDirection, this.esf.grid.unpinnedColumns);
            }
            this.esf.grid.moveColumn(this.esf.column, targetColumn, moveDirection);
        };
        IgxExcelStyleMovingComponent.prototype.findColumn = function (moveDirection, columns) {
            var index = columns.indexOf(this.esf.column);
            if (moveDirection === 0) {
                while (index > 0) {
                    index--;
                    if (columns[index].level === this.esf.column.level && columns[index].parent === this.esf.column.parent) {
                        return columns[index];
                    }
                }
            }
            else {
                while (index < columns.length - 1) {
                    index++;
                    if (columns[index].level === this.esf.column.level && columns[index].parent === this.esf.column.parent) {
                        return columns[index];
                    }
                }
            }
        };
        return IgxExcelStyleMovingComponent;
    }());
    IgxExcelStyleMovingComponent.decorators = [
        { type: i0.Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-moving',
                    template: "<ng-container *ngIf=\"esf.column\">\n<header>\n    {{ esf.grid.resourceStrings.igx_grid_excel_filter_moving_header }}\n</header>\n<section class=\"igx-excel-filter__move-buttons\">\n    <button [displayDensity]=\"esf.grid.displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveLeft\"\n        (click)=\"onMoveButtonClicked(0)\">\n        <igx-icon>arrow_back</igx-icon>\n        <span>\n            {{ esf.grid.displayDensity==='compact'?\n            esf.grid.resourceStrings.igx_grid_excel_filter_moving_left_short:\n            esf.grid.resourceStrings.igx_grid_excel_filter_moving_left }}\n        </span>\n    </button>\n    <button [displayDensity]=\"esf.grid.displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveRight\"\n        (click)=\"onMoveButtonClicked(1)\">\n        <span>\n            {{ esf.grid.displayDensity==='compact'?\n            esf.grid.resourceStrings.igx_grid_excel_filter_moving_right_short:\n            esf.grid.resourceStrings.igx_grid_excel_filter_moving_right }}\n        </span>\n        <igx-icon>arrow_forwards</igx-icon>\n    </button>\n</section>\n</ng-container>\n"
                },] }
    ];
    IgxExcelStyleMovingComponent.ctorParameters = function () { return [
        { type: IgxGridExcelStyleFilteringComponent }
    ]; };
    IgxExcelStyleMovingComponent.propDecorators = {
        defaultClass: [{ type: i0.HostBinding, args: ['class.igx-excel-filter__move',] }]
    };

    /**
     * A component used for presenting Excel style column pinning UI.
     */
    var IgxExcelStylePinningComponent = /** @class */ (function () {
        function IgxExcelStylePinningComponent(esf) {
            this.esf = esf;
        }
        return IgxExcelStylePinningComponent;
    }());
    IgxExcelStylePinningComponent.decorators = [
        { type: i0.Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-pinning',
                    template: "<div *ngIf=\"esf.column\"\n    [ngClass]=\"esf.column.pinned ? 'igx-excel-filter__actions-unpin' : 'igx-excel-filter__actions-pin'\"\n    (click)=\"esf.onPin()\"\n    tabindex=\"0\">\n    <span>{{ esf.column.pinned ? esf.grid.resourceStrings.igx_grid_excel_unpin : esf.grid.resourceStrings.igx_grid_excel_pin }}</span>\n    <igx-icon family=\"imx-icons\" name=\"{{ esf.column.pinned ? 'unpin-left' : 'pin-left' }}\"></igx-icon>\n</div>\n"
                },] }
    ];
    IgxExcelStylePinningComponent.ctorParameters = function () { return [
        { type: IgxGridExcelStyleFilteringComponent }
    ]; };

    /** @hidden */
    var IgxListBaseDirective = /** @class */ (function (_super) {
        __extends(IgxListBaseDirective, _super);
        function IgxListBaseDirective(_displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this._displayDensityOptions = _displayDensityOptions;
            return _this;
        }
        return IgxListBaseDirective;
    }(DisplayDensityBase));
    IgxListBaseDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxListBase]'
                },] }
    ];
    IgxListBaseDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] }
    ]; };
    (function (IgxListPanState) {
        IgxListPanState[IgxListPanState["NONE"] = 0] = "NONE";
        IgxListPanState[IgxListPanState["LEFT"] = 1] = "LEFT";
        IgxListPanState[IgxListPanState["RIGHT"] = 2] = "RIGHT";
    })(exports.IgxListPanState || (exports.IgxListPanState = {}));
    var IgxEmptyListTemplateDirective = /** @class */ (function () {
        function IgxEmptyListTemplateDirective(template) {
            this.template = template;
        }
        return IgxEmptyListTemplateDirective;
    }());
    IgxEmptyListTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxEmptyList]'
                },] }
    ];
    IgxEmptyListTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    var IgxDataLoadingTemplateDirective = /** @class */ (function () {
        function IgxDataLoadingTemplateDirective(template) {
            this.template = template;
        }
        return IgxDataLoadingTemplateDirective;
    }());
    IgxDataLoadingTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDataLoading]'
                },] }
    ];
    IgxDataLoadingTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    var IgxListItemLeftPanningTemplateDirective = /** @class */ (function () {
        function IgxListItemLeftPanningTemplateDirective(template) {
            this.template = template;
        }
        return IgxListItemLeftPanningTemplateDirective;
    }());
    IgxListItemLeftPanningTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxListItemLeftPanning]'
                },] }
    ];
    IgxListItemLeftPanningTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    var IgxListItemRightPanningTemplateDirective = /** @class */ (function () {
        function IgxListItemRightPanningTemplateDirective(template) {
            this.template = template;
        }
        return IgxListItemRightPanningTemplateDirective;
    }());
    IgxListItemRightPanningTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxListItemRightPanning]'
                },] }
    ];
    IgxListItemRightPanningTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };

    var EVENT_SUFFIX = 'precise';
    /**
     * Touch gestures manager based on Hammer.js
     * Use with caution, this will track references for single manager per element. Very TBD. Much TODO.
     *
     * @hidden
     */
    var HammerGesturesManager = /** @class */ (function () {
        function HammerGesturesManager(_zone, doc, platformUtil) {
            this._zone = _zone;
            this.doc = doc;
            this.platformUtil = platformUtil;
            /**
             * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.
             */
            this.hammerOptions = {};
            this._hammerManagers = [];
            this.platformBrowser = this.platformUtil.isBrowser;
            if (this.platformBrowser) {
                this.hammerOptions = {
                    // D.P. #447 Force TouchInput due to PointerEventInput bug (https://github.com/hammerjs/hammer.js/issues/1065)
                    // see https://github.com/IgniteUI/igniteui-angular/issues/447#issuecomment-324601803
                    inputClass: Hammer.TouchInput,
                    recognizers: [
                        [Hammer.Pan, { threshold: 0 }],
                        [Hammer.Swipe, { direction: Hammer.DIRECTION_HORIZONTAL }],
                        [Hammer.Tap],
                        [Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']]
                    ]
                };
            }
        }
        HammerGesturesManager.prototype.supports = function (eventName) {
            return eventName.toLowerCase().endsWith('.' + EVENT_SUFFIX);
        };
        /**
         * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
         * Modeling after other event plugins for easy future modifications.
         */
        HammerGesturesManager.prototype.addEventListener = function (element, eventName, eventHandler, options) {
            var _this = this;
            if (options === void 0) { options = null; }
            if (!this.platformBrowser) {
                return;
            }
            // Creating the manager bind events, must be done outside of angular
            return this._zone.runOutsideAngular(function () {
                var mc = _this.getManagerForElement(element);
                if (mc === null) {
                    // new Hammer is a shortcut for Manager with defaults
                    mc = new Hammer(element, Object.assign(_this.hammerOptions, options));
                    _this.addManagerForElement(element, mc);
                }
                var handler = function (eventObj) { return _this._zone.run(function () { return eventHandler(eventObj); }); };
                mc.on(eventName, handler);
                return function () { return mc.off(eventName, handler); };
            });
        };
        /**
         * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
         * Modeling after other event plugins for easy future modifications.
         *
         * @param target Can be one of either window, body or document(fallback default).
         */
        HammerGesturesManager.prototype.addGlobalEventListener = function (target, eventName, eventHandler) {
            if (!this.platformBrowser) {
                return;
            }
            var element = this.getGlobalEventTarget(target);
            // Creating the manager bind events, must be done outside of angular
            return this.addEventListener(element, eventName, eventHandler);
        };
        /**
         * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.
         * Supported: window, document, body. Defaults to document for invalid args.
         *
         * @param target Target name
         */
        HammerGesturesManager.prototype.getGlobalEventTarget = function (target) {
            return i1$1.ɵgetDOM().getGlobalEventTarget(this.doc, target);
        };
        /**
         * Set HammerManager options.
         *
         * @param element The DOM element used to create the manager on.
         *
         * ### Example
         *
         * ```ts
         * manager.setManagerOption(myElem, "pan", { pointers: 1 });
         * ```
         */
        HammerGesturesManager.prototype.setManagerOption = function (element, event, options) {
            var manager = this.getManagerForElement(element);
            manager.get(event).set(options);
        };
        /**
         * Add an element and manager map to the internal collection.
         *
         * @param element The DOM element used to create the manager on.
         */
        HammerGesturesManager.prototype.addManagerForElement = function (element, manager) {
            this._hammerManagers.push({ element: element, manager: manager });
        };
        /**
         * Get HammerManager for the element or null
         *
         * @param element The DOM element used to create the manager on.
         */
        HammerGesturesManager.prototype.getManagerForElement = function (element) {
            var result = this._hammerManagers.filter(function (value, index, array) { return value.element === element; });
            return result.length ? result[0].manager : null;
        };
        /**
         * Destroys the HammerManager for the element, removing event listeners in the process.
         *
         * @param element The DOM element used to create the manager on.
         */
        HammerGesturesManager.prototype.removeManagerForElement = function (element) {
            var index = null;
            for (var i = 0; i < this._hammerManagers.length; i++) {
                if (element === this._hammerManagers[i].element) {
                    index = i;
                    break;
                }
            }
            if (index !== null) {
                var item = this._hammerManagers.splice(index, 1)[0];
                // destroy also
                item.manager.destroy();
            }
        };
        /** Destroys all internally tracked HammerManagers, removing event listeners in the process. */
        HammerGesturesManager.prototype.destroy = function () {
            var e_1, _a;
            try {
                for (var _b = __values(this._hammerManagers), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var item = _c.value;
                    item.manager.destroy();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this._hammerManagers = [];
        };
        return HammerGesturesManager;
    }());
    HammerGesturesManager.decorators = [
        { type: i0.Injectable }
    ];
    HammerGesturesManager.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: PlatformUtil }
    ]; };

    /**
     * The Ignite UI List Item component is a container intended for row items in the Ignite UI for Angular List component.
     *
     * Example:
     * ```html
     * <igx-list>
     *   <igx-list-item isHeader="true">Contacts</igx-list-item>
     *   <igx-list-item *ngFor="let contact of contacts">
     *     <span class="name">{{ contact.name }}</span>
     *     <span class="phone">{{ contact.phone }}</span>
     *   </igx-list-item>
     * </igx-list>
     * ```
     */
    var IgxListItemComponent = /** @class */ (function () {
        function IgxListItemComponent(list, elementRef, _renderer) {
            this.list = list;
            this.elementRef = elementRef;
            this._renderer = _renderer;
            /**
             * Sets/gets whether the `list item` is hidden.
             * By default the `hidden` value is `false`.
             * ```html
             * <igx-list-item [hidden] = "true">Hidden Item</igx-list-item>
             * ```
             * ```typescript
             * let isHidden =  this.listItem.hidden;
             * ```
             *
             * @memberof IgxListItemComponent
             */
            this.hidden = false;
            /**
             * Gets the `touch-action` style of the `list item`.
             * ```typescript
             * let touchAction = this.listItem.touchAction;
             * ```
             */
            this.touchAction = 'pan-y';
            /**
             * @hidden
             */
            this._panState = exports.IgxListPanState.NONE;
            /**
             * @hidden
             */
            this.panOffset = 0;
            /**
             * @hidden
             */
            this._index = null;
            /**
             * @hidden
             */
            this.lastPanDir = exports.IgxListPanState.NONE;
        }
        Object.defineProperty(IgxListItemComponent.prototype, "panState", {
            /**
             * Gets the `panState` of a `list item`.
             * ```typescript
             * let itemPanState =  this.listItem.panState;
             * ```
             *
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this._panState;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "index", {
            /**
             * Gets the `index` of a `list item`.
             * ```typescript
             * let itemIndex =  this.listItem.index;
             * ```
             *
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this._index !== null ? this._index : this.list.children.toArray().indexOf(this);
            },
            /**
             * Sets the `index` of the `list item`.
             * ```typescript
             * this.listItem.index = index;
             * ```
             *
             * @memberof IgxListItemComponent
             */
            set: function (value) {
                this._index = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "element", {
            /**
             * Returns an element reference to the list item.
             * ```typescript
             * let listItemElement =  this.listItem.element.
             * ```
             *
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "contentElement", {
            /**
             * Returns a reference container which contains the list item's content.
             * ```typescript
             * let listItemContainer =  this.listItem.contentElement.
             * ```
             *
             * @memberof IgxListItemComponent
             */
            get: function () {
                var candidates = this.element.getElementsByClassName('igx-list__item-content');
                return (candidates && candidates.length > 0) ? candidates[0] : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "context", {
            /**
             * Returns the `context` object which represents the `template context` binding into the `list item container`
             * by providing the `$implicit` declaration which is the `IgxListItemComponent` itself.
             * ```typescript
             * let listItemComponent = this.listItem.context;
             * ```
             */
            get: function () {
                return {
                    $implicit: this
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "width", {
            /**
             * Gets the width of a `list item`.
             * ```typescript
             * let itemWidth = this.listItem.width;
             * ```
             *
             * @memberof IgxListItemComponent
             */
            get: function () {
                if (this.element) {
                    return this.element.offsetWidth;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "maxLeft", {
            /**
             * Gets the maximum left position of the `list item`.
             * ```typescript
             * let maxLeft = this.listItem.maxLeft;
             * ```
             *
             * @memberof IgxListItemComponent
             */
            get: function () {
                return -this.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "maxRight", {
            /**
             * Gets the maximum right position of the `list item`.
             * ```typescript
             * let maxRight = this.listItem.maxRight;
             * ```
             *
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "role", {
            /**
             * Gets the `role` attribute of the `list item`.
             * ```typescript
             * let itemRole =  this.listItem.role;
             * ```
             *
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this.isHeader ? 'separator' : 'listitem';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "headerStyle", {
            /**
             * Indicates whether `list item` should have header style.
             * ```typescript
             * let headerStyle =  this.listItem.headerStyle;
             * ```
             *
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this.isHeader;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "innerStyle", {
            /**
             * Applies the inner style of the `list item` if the item is not counted as header.
             * ```typescript
             * let innerStyle =  this.listItem.innerStyle;
             * ```
             *
             * @memberof IgxListItemComponent
             */
            get: function () {
                return !this.isHeader;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "display", {
            /**
             * Returns string value which describes the display mode of the `list item`.
             * ```typescript
             * let isHidden = this.listItem.display;
             * ```
             *
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this.hidden ? 'none' : '';
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxListItemComponent.prototype.clicked = function (evt) {
            this.list.itemClicked.emit({ item: this, event: evt, direction: this.lastPanDir });
            this.lastPanDir = exports.IgxListPanState.NONE;
        };
        /**
         * @hidden
         */
        IgxListItemComponent.prototype.panStart = function () {
            if (this.isTrue(this.isHeader)) {
                return;
            }
            if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
                return;
            }
        };
        /**
         * @hidden
         */
        IgxListItemComponent.prototype.panMove = function (ev) {
            if (this.isTrue(this.isHeader)) {
                return;
            }
            if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
                return;
            }
            var isPanningToLeft = ev.deltaX < 0;
            if (isPanningToLeft && this.isTrue(this.list.allowLeftPanning)) {
                this.showLeftPanTemplate();
                this.setContentElementLeft(Math.max(this.maxLeft, ev.deltaX));
            }
            else if (!isPanningToLeft && this.isTrue(this.list.allowRightPanning)) {
                this.showRightPanTemplate();
                this.setContentElementLeft(Math.min(this.maxRight, ev.deltaX));
            }
        };
        /**
         * @hidden
         */
        IgxListItemComponent.prototype.panEnd = function () {
            if (this.isTrue(this.isHeader)) {
                return;
            }
            if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
                return;
            }
            // the translation offset of the current list item content
            var relativeOffset = this.panOffset;
            var widthTriggeringGrip = this.width * this.list.panEndTriggeringThreshold;
            if (relativeOffset === 0) {
                return; // no panning has occured
            }
            var dir = relativeOffset > 0 ? exports.IgxListPanState.RIGHT : exports.IgxListPanState.LEFT;
            this.lastPanDir = dir;
            var oldPanState = this._panState;
            if (Math.abs(relativeOffset) < widthTriggeringGrip) {
                this.setContentElementLeft(0);
                this._panState = exports.IgxListPanState.NONE;
                this.hideLeftAndRightPanTemplates();
                return;
            }
            var args = { item: this, direction: dir, keepItem: false };
            if (dir === exports.IgxListPanState.LEFT) {
                this.list.leftPan.emit(args);
            }
            else {
                this.list.rightPan.emit(args);
            }
            if (args.keepItem === true) {
                this.setContentElementLeft(0);
                this._panState = exports.IgxListPanState.NONE;
            }
            else {
                if (dir === exports.IgxListPanState.LEFT) {
                    this.setContentElementLeft(this.maxLeft);
                    this._panState = exports.IgxListPanState.LEFT;
                }
                else {
                    this.setContentElementLeft(this.maxRight);
                    this._panState = exports.IgxListPanState.RIGHT;
                }
            }
            if (oldPanState !== this._panState) {
                var args2 = { oldState: oldPanState, newState: this._panState, item: this };
                this.list.panStateChange.emit(args2);
            }
            this.hideLeftAndRightPanTemplates();
        };
        /**
         * @hidden
         */
        IgxListItemComponent.prototype.showLeftPanTemplate = function () {
            this.setLeftAndRightTemplatesVisibility('visible', 'hidden');
        };
        /**
         * @hidden
         */
        IgxListItemComponent.prototype.showRightPanTemplate = function () {
            this.setLeftAndRightTemplatesVisibility('hidden', 'visible');
        };
        /**
         * @hidden
         */
        IgxListItemComponent.prototype.hideLeftAndRightPanTemplates = function () {
            var _this = this;
            setTimeout(function () {
                _this.setLeftAndRightTemplatesVisibility('hidden', 'hidden');
            }, 500);
        };
        /**
         * @hidden
         */
        IgxListItemComponent.prototype.setLeftAndRightTemplatesVisibility = function (leftVisibility, rightVisibility) {
            if (this.leftPanningTemplateElement && this.leftPanningTemplateElement.nativeElement) {
                this.leftPanningTemplateElement.nativeElement.style.visibility = leftVisibility;
            }
            if (this.rightPanningTemplateElement && this.rightPanningTemplateElement.nativeElement) {
                this.rightPanningTemplateElement.nativeElement.style.visibility = rightVisibility;
            }
        };
        /**
         * @hidden
         */
        IgxListItemComponent.prototype.setContentElementLeft = function (value) {
            this.panOffset = value;
            this.contentElement.style.transform = 'translateX(' + value + 'px)';
        };
        /**
         * @hidden
         */
        IgxListItemComponent.prototype.isTrue = function (value) {
            if (typeof (value) === 'boolean') {
                return value;
            }
            else {
                return value === 'true';
            }
        };
        return IgxListItemComponent;
    }());
    IgxListItemComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [HammerGesturesManager],
                    selector: 'igx-list-item',
                    template: "   \n<div *ngIf=\"!isHeader && list.listItemLeftPanningTemplate != null\" #leftPanningTmpl class=\"igx-list__item-right\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemLeftPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<div *ngIf=\"!isHeader && list.listItemRightPanningTemplate != null\" #rightPanningTmpl class=\"igx-list__item-left\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemRightPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<ng-template #itemsContent>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #itemThumbnails>\n    <div class=\"igx-list__item-thumbnail\">\n        <ng-content select=\"[igxListThumbnail], igx-list__item-thumbnail, igx-avatar\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemLines>\n    <div class=\"igx-list__item-lines\">\n        <ng-content select=\"[igxListLine], .igx-list__item-lines, [igxListLineTitle], [igxListLineSubTitle], .igx-list__item-line-title, .igx-list__item-line-subtitle\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemActions>\n    <div class=\"igx-list__item-actions\">\n        <ng-content select=\"[igxListAction], .igx-list__item-actions\"></ng-content>\n    </div>\n</ng-template>\n\n    \n<ng-container *ngIf=\"isHeader\">\n    <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n</ng-container>\n\n<ng-container *ngIf=\"!isHeader\">\n    <div class=\"igx-list__item-content\">\n        <ng-container *ngTemplateOutlet=\"itemThumbnails\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemLines\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemActions\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n    </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    IgxListItemComponent.ctorParameters = function () { return [
        { type: IgxListBaseDirective },
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    IgxListItemComponent.propDecorators = {
        leftPanningTemplateElement: [{ type: i0.ViewChild, args: ['leftPanningTmpl',] }],
        rightPanningTemplateElement: [{ type: i0.ViewChild, args: ['rightPanningTmpl',] }],
        isHeader: [{ type: i0.Input }],
        hidden: [{ type: i0.Input }],
        ariaLabel: [{ type: i0.HostBinding, args: ['attr.aria-label',] }],
        touchAction: [{ type: i0.HostBinding, args: ['style.touch-action',] }],
        index: [{ type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        headerStyle: [{ type: i0.HostBinding, args: ['class.igx-list__header',] }],
        innerStyle: [{ type: i0.HostBinding, args: ['class.igx-list__item-base',] }],
        display: [{ type: i0.HostBinding, args: ['style.display',] }],
        clicked: [{ type: i0.HostListener, args: ['click', ['$event'],] }],
        panStart: [{ type: i0.HostListener, args: ['panstart',] }],
        panMove: [{ type: i0.HostListener, args: ['panmove', ['$event'],] }],
        panEnd: [{ type: i0.HostListener, args: ['panend',] }]
    };

    var NEXT_ID$i = 0;
    /**
     * igxListThumbnail is container for the List media
     * Use it to wrap anything you want to be used as a thumbnail.
     */
    var IgxListThumbnailDirective = /** @class */ (function () {
        function IgxListThumbnailDirective() {
        }
        return IgxListThumbnailDirective;
    }());
    IgxListThumbnailDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[igxListThumbnail]'
                },] }
    ];
    /**
     * igxListAction is container for the List action
     * Use it to wrap anything you want to be used as a list action: icon, checkbox...
     */
    var IgxListActionDirective = /** @class */ (function () {
        function IgxListActionDirective() {
        }
        return IgxListActionDirective;
    }());
    IgxListActionDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[igxListAction]'
                },] }
    ];
    /**
     * igxListLine is container for the List text content
     * Use it to wrap anything you want to be used as a plane text.
     */
    var IgxListLineDirective = /** @class */ (function () {
        function IgxListLineDirective() {
        }
        return IgxListLineDirective;
    }());
    IgxListLineDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[igxListLine]'
                },] }
    ];
    /**
     * igxListLineTitle is a directive that add class to the target element
     * Use it to make anything to look like list Title.
     */
    var IgxListLineTitleDirective = /** @class */ (function () {
        function IgxListLineTitleDirective() {
            this.cssClass = 'igx-list__item-line-title';
        }
        return IgxListLineTitleDirective;
    }());
    IgxListLineTitleDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[igxListLineTitle]'
                },] }
    ];
    IgxListLineTitleDirective.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-list__item-line-title',] }]
    };
    /**
     * igxListLineSubTitle is a directive that add class to the target element
     * Use it to make anything to look like list Subtitle.
     */
    var IgxListLineSubTitleDirective = /** @class */ (function () {
        function IgxListLineSubTitleDirective() {
            this.cssClass = 'igx-list__item-line-subtitle';
        }
        return IgxListLineSubTitleDirective;
    }());
    IgxListLineSubTitleDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[igxListLineSubTitle]'
                },] }
    ];
    IgxListLineSubTitleDirective.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-list__item-line-subtitle',] }]
    };
    /**
     * Displays a collection of data items in a templatable list format
     *
     * @igxModule IgxListModule
     *
     * @igxTheme igx-list-theme
     *
     * @igxKeywords list, data
     *
     * @igxGroup Grids & Lists
     *
     * @remarks
     * The Ignite UI List displays rows of items and supports one or more header items as well as search and filtering
     * of list items. Each list item is completely templatable and will support any valid HTML or Angular component.
     *
     * @example
     * ```html
     * <igx-list>
     *   <igx-list-item isHeader="true">Contacts</igx-list-item>
     *   <igx-list-item *ngFor="let contact of contacts">
     *     <span class="name">{{ contact.name }}</span>
     *     <span class="phone">{{ contact.phone }}</span>
     *   </igx-list-item>
     * </igx-list>
     * ```
     */
    var IgxListComponent = /** @class */ (function (_super) {
        __extends(IgxListComponent, _super);
        function IgxListComponent(element, _displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.element = element;
            _this._displayDensityOptions = _displayDensityOptions;
            /**
             * Provides a threshold after which the item's panning will be completed automatically.
             *
             * @remarks
             * By default this property is set to 0.5 which is 50% of the list item's width.
             *
             * @example
             * ```html
             * <igx-list [panEndTriggeringThreshold]="0.8"></igx-list>
             * ```
             */
            _this.panEndTriggeringThreshold = 0.5;
            /**
             * Sets/gets the `id` of the list.
             *
             * @remarks
             * If not set, the `id` of the first list component will be `"igx-list-0"`.
             *
             * @example
             * ```html
             * <igx-list id="my-first-list"></igx-list>
             * ```
             * ```typescript
             * let listId = this.list.id;
             * ```
             */
            _this.id = "igx-list-" + NEXT_ID$i++;
            /**
             * Sets/gets whether the left panning of an item is allowed.
             *
             * @remarks
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-list [allowLeftPanning]="true"></igx-list>
             * ```
             * ```typescript
             * let isLeftPanningAllowed = this.list.allowLeftPanning;
             * ```
             */
            _this.allowLeftPanning = false;
            /**
             * Sets/gets whether the right panning of an item is allowed.
             *
             * @remarks
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-list [allowRightPanning]="true"></igx-list>
             * ```
             * ```typescript
             * let isRightPanningAllowed = this.list.allowRightPanning;
             * ```
             */
            _this.allowRightPanning = false;
            /**
             * Sets/gets whether the list is currently loading data.
             *
             * @remarks
             * Set it to display the dataLoadingTemplate while data is being retrieved.
             * Default value is `false`.
             *
             * @example
             * ```html
             *  <igx-list [isLoading]="true"></igx-list>
             * ```
             * ```typescript
             * let isLoading = this.list.isLoading;
             * ```
             */
            _this.isLoading = false;
            /**
             * Event emitted when a left pan gesture is executed on a list item.
             *
             * @remarks
             * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
             *
             * @example
             * ```html
             * <igx-list [allowLeftPanning]="true" (leftPan)="leftPan($event)"></igx-list>
             * ```
             */
            _this.leftPan = new i0.EventEmitter();
            /**
             * Event emitted when a right pan gesture is executed on a list item.
             *
             * @remarks
             * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
             *
             * @example
             * ```html
             * <igx-list [allowRightPanning]="true" (rightPan)="rightPan($event)"></igx-list>
             * ```
             */
            _this.rightPan = new i0.EventEmitter();
            /**
             *
             * Event emitted when a pan gesture is executed on a list item.
             *
             * @remarks
             * Provides references to the `IgxListItemComponent` and `IgxListPanState` as event arguments.
             *
             * @example
             * ```html
             * <igx-list (panStateChange)="panStateChange($event)"></igx-list>
             * ```
             */
            _this.panStateChange = new i0.EventEmitter();
            /**
             * Event emitted when a list item is clicked.
             *
             * @remarks
             * Provides references to the `IgxListItemComponent` and `Event` as event arguments.
             *
             * @example
             * ```html
             * <igx-list (itemClicked)="onItemClicked($event)"></igx-list>
             * ```
             */
            _this.itemClicked = new i0.EventEmitter();
            _this._resourceStrings = CurrentResourceStrings.ListResStrings;
            return _this;
        }
        Object.defineProperty(IgxListComponent.prototype, "resourceStrings", {
            /**
             * Returns the resource strings.
             */
            get: function () {
                return this._resourceStrings;
            },
            /**
             * Sets the resource strings.
             * By default it uses EN resources.
             */
            set: function (value) {
                this._resourceStrings = Object.assign({}, this._resourceStrings, value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "sortedChildren", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.children !== undefined) {
                    return this.children.toArray()
                        .sort(function (a, b) { return a.index - b.index; });
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "role", {
            /**
             * Gets the `role` attribute value.
             *
             * @example
             * ```typescript
             * let listRole =  this.list.role;
             * ```
             */
            get: function () {
                return 'list';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "isListEmpty", {
            /**
             * Gets a boolean indicating if the list is empty.
             *
             * @example
             * ```typescript
             * let isEmpty =  this.list.isListEmpty;
             * ```
             */
            get: function () {
                return !this.children || this.children.length === 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "cssClass", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return !this.isListEmpty && this.displayDensity === DisplayDensity.comfortable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "cssClassCompact", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return !this.isListEmpty && this.displayDensity === DisplayDensity.compact;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "cssClassCosy", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return !this.isListEmpty && this.displayDensity === DisplayDensity.cosy;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "items", {
            /**
             * Gets the list `items` excluding the header ones.
             *
             * @example
             * ```typescript
             * let listItems: IgxListItemComponent[] = this.list.items;
             * ```
             */
            get: function () {
                var e_1, _a;
                var items = [];
                if (this.children !== undefined) {
                    try {
                        for (var _b = __values(this.sortedChildren), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var child = _c.value;
                            if (!child.isHeader) {
                                items.push(child);
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                return items;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "headers", {
            /**
             * Gets the header list `items`.
             *
             * @example
             * ```typescript
             * let listHeaders: IgxListItemComponent[] =  this.list.headers;
             * ```
             */
            get: function () {
                var e_2, _a;
                var headers = [];
                if (this.children !== undefined) {
                    try {
                        for (var _b = __values(this.children.toArray()), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var child = _c.value;
                            if (child.isHeader) {
                                headers.push(child);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                return headers;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "context", {
            /**
             * Gets the `context` object of the template binding.
             *
             * @remark
             * Gets the `context` object which represents the `template context` binding into the `list container`
             * by providing the `$implicit` declaration which is the `IgxListComponent` itself.
             *
             * @example
             * ```typescript
             * let listComponent =  this.list.context;
             * ```
             */
            get: function () {
                return {
                    $implicit: this
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "template", {
            /**
             * Gets a `TemplateRef` to the currently used template.
             *
             * @example
             * ```typescript
             * let listTemplate = this.list.template;
             * ```
             */
            get: function () {
                if (this.isLoading) {
                    return this.dataLoadingTemplate ? this.dataLoadingTemplate.template : this.defaultDataLoadingTemplate;
                }
                else {
                    return this.emptyListTemplate ? this.emptyListTemplate.template : this.defaultEmptyListTemplate;
                }
            },
            enumerable: false,
            configurable: true
        });
        return IgxListComponent;
    }(IgxListBaseDirective));
    IgxListComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-list',
                    template: "<ng-content></ng-content>\n\n<ng-template #defaultEmptyList>\n    <article class=\"igx-list__message\">\n        {{resourceStrings.igx_list_no_items}}\n    </article>\n</ng-template>\n\n<ng-template #defaultDataLoading>\n    <article class=\"igx-list__message\">\n        {{resourceStrings.igx_list_loading}}\n    </article>\n</ng-template>\n\n<ng-container *ngIf=\"!children || children.length === 0 || isLoading\">\n    <ng-container *ngTemplateOutlet=\"template; context: context\">\n    </ng-container>\n</ng-container>\n",
                    providers: [{ provide: IgxListBaseDirective, useExisting: IgxListComponent }]
                },] }
    ];
    IgxListComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxListComponent.propDecorators = {
        children: [{ type: i0.ContentChildren, args: [i0.forwardRef(function () { return IgxListItemComponent; }), { descendants: true },] }],
        emptyListTemplate: [{ type: i0.ContentChild, args: [IgxEmptyListTemplateDirective, { read: IgxEmptyListTemplateDirective },] }],
        dataLoadingTemplate: [{ type: i0.ContentChild, args: [IgxDataLoadingTemplateDirective, { read: IgxDataLoadingTemplateDirective },] }],
        listItemLeftPanningTemplate: [{ type: i0.ContentChild, args: [IgxListItemLeftPanningTemplateDirective, { read: IgxListItemLeftPanningTemplateDirective },] }],
        listItemRightPanningTemplate: [{ type: i0.ContentChild, args: [IgxListItemRightPanningTemplateDirective, { read: IgxListItemRightPanningTemplateDirective },] }],
        panEndTriggeringThreshold: [{ type: i0.Input }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        allowLeftPanning: [{ type: i0.Input }],
        allowRightPanning: [{ type: i0.Input }],
        isLoading: [{ type: i0.Input }],
        leftPan: [{ type: i0.Output }],
        rightPan: [{ type: i0.Output }],
        panStateChange: [{ type: i0.Output }],
        itemClicked: [{ type: i0.Output }],
        defaultEmptyListTemplate: [{ type: i0.ViewChild, args: ['defaultEmptyList', { read: i0.TemplateRef, static: true },] }],
        defaultDataLoadingTemplate: [{ type: i0.ViewChild, args: ['defaultDataLoading', { read: i0.TemplateRef, static: true },] }],
        resourceStrings: [{ type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        isListEmpty: [{ type: i0.HostBinding, args: ['class.igx-list--empty',] }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-list',] }],
        cssClassCompact: [{ type: i0.HostBinding, args: ['class.igx-list--compact',] }],
        cssClassCosy: [{ type: i0.HostBinding, args: ['class.igx-list--cosy',] }]
    };
    /**
     * @hidden
     */
    var IgxListModule = /** @class */ (function () {
        function IgxListModule() {
        }
        return IgxListModule;
    }());
    IgxListModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxListBaseDirective,
                        IgxListComponent,
                        IgxListItemComponent,
                        IgxListThumbnailDirective,
                        IgxListActionDirective,
                        IgxListLineDirective,
                        IgxListLineTitleDirective,
                        IgxListLineSubTitleDirective,
                        IgxDataLoadingTemplateDirective,
                        IgxEmptyListTemplateDirective,
                        IgxListItemLeftPanningTemplateDirective,
                        IgxListItemRightPanningTemplateDirective
                    ],
                    exports: [
                        IgxListComponent,
                        IgxListItemComponent,
                        IgxListThumbnailDirective,
                        IgxListActionDirective,
                        IgxListLineDirective,
                        IgxListLineTitleDirective,
                        IgxListLineSubTitleDirective,
                        IgxDataLoadingTemplateDirective,
                        IgxEmptyListTemplateDirective,
                        IgxListItemLeftPanningTemplateDirective,
                        IgxListItemRightPanningTemplateDirective
                    ],
                    imports: [
                        i2.CommonModule,
                        IgxRippleModule
                    ]
                },] }
    ];

    var IgxExcelStyleLoadingValuesTemplateDirective = /** @class */ (function () {
        function IgxExcelStyleLoadingValuesTemplateDirective(template) {
            this.template = template;
        }
        return IgxExcelStyleLoadingValuesTemplateDirective;
    }());
    IgxExcelStyleLoadingValuesTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxExcelStyleLoading]'
                },] }
    ];
    IgxExcelStyleLoadingValuesTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    /**
     * A component used for presenting Excel style search UI.
     */
    var IgxExcelStyleSearchComponent = /** @class */ (function () {
        function IgxExcelStyleSearchComponent(cdr, esf) {
            var _this = this;
            this.cdr = cdr;
            this.esf = esf;
            /**
             * @hidden @internal
             */
            this.defaultClass = true;
            this.destroy$ = new rxjs.Subject();
            esf.loadingStart.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                _this.displayedListData = [];
                _this.isLoading = true;
            });
            esf.loadingEnd.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                _this.isLoading = false;
                _this.refreshSize();
            });
            esf.initialized.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                requestAnimationFrame(function () {
                    _this.searchInput.nativeElement.focus();
                });
            });
            esf.columnChange.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                _this.virtDir.resetScrollPosition();
            });
            esf.listDataLoaded.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                if (_this.searchValue) {
                    _this.clearInput();
                }
                else {
                    _this.filterListData();
                }
                _this.cdr.detectChanges();
            });
        }
        Object.defineProperty(IgxExcelStyleSearchComponent.prototype, "addToCurrentFilter", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (!this._addToCurrentFilter) {
                    var addToCurrentFilterItem = {
                        isSelected: false,
                        isFiltered: false,
                        indeterminate: false,
                        isSpecial: true,
                        isBlanks: false,
                        value: this.esf.grid.resourceStrings.igx_grid_excel_add_to_filter,
                        label: this.esf.grid.resourceStrings.igx_grid_excel_add_to_filter
                    };
                    this._addToCurrentFilter = addToCurrentFilterItem;
                }
                return this._addToCurrentFilter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleSearchComponent.prototype, "isLoading", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._isLoading;
            },
            /**
             * @hidden @internal
             */
            set: function (value) {
                this._isLoading = value;
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleSearchComponent.prototype, "valuesLoadingTemplate", {
            /**
             * @hidden @internal
             */
            get: function () {
                var _a;
                if ((_a = this.esf.grid) === null || _a === void 0 ? void 0 : _a.excelStyleLoadingValuesTemplateDirective) {
                    return this.esf.grid.excelStyleLoadingValuesTemplateDirective.template;
                }
                else {
                    return this.defaultExcelStyleLoadingValuesTemplate;
                }
            },
            enumerable: false,
            configurable: true
        });
        IgxExcelStyleSearchComponent.prototype.ngAfterViewInit = function () {
            this.refreshSize();
        };
        IgxExcelStyleSearchComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleSearchComponent.prototype.refreshSize = function () {
            var _this = this;
            requestAnimationFrame(function () {
                var _a;
                (_a = _this.virtDir) === null || _a === void 0 ? void 0 : _a.recalcUpdateSizes();
            });
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleSearchComponent.prototype.clearInput = function () {
            this.searchValue = null;
            this.filterListData();
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleSearchComponent.prototype.onCheckboxChange = function (eventArgs) {
            var _this = this;
            var selectedIndex = this.displayedListData.indexOf(eventArgs.checkbox.value);
            var selectAllBtn = this.displayedListData[0];
            if (selectedIndex === 0) {
                this.displayedListData.forEach(function (element) {
                    if (element === _this.addToCurrentFilter) {
                        return;
                    }
                    element.isSelected = eventArgs.checked;
                });
                selectAllBtn.indeterminate = false;
            }
            else {
                eventArgs.checkbox.value.isSelected = eventArgs.checked;
                var indexToStartSlicing = this.displayedListData.indexOf(this.addToCurrentFilter) > -1 ? 2 : 1;
                var slicedArray = this.displayedListData.slice(indexToStartSlicing, this.displayedListData.length);
                if (!slicedArray.find(function (el) { return el.isSelected === false; })) {
                    selectAllBtn.indeterminate = false;
                    selectAllBtn.isSelected = true;
                }
                else if (!slicedArray.find(function (el) { return el.isSelected === true; })) {
                    selectAllBtn.indeterminate = false;
                    selectAllBtn.isSelected = false;
                }
                else {
                    selectAllBtn.indeterminate = true;
                }
            }
            eventArgs.checkbox.nativeCheckbox.nativeElement.blur();
        };
        Object.defineProperty(IgxExcelStyleSearchComponent.prototype, "itemSize", {
            /**
             * @hidden @internal
             */
            get: function () {
                var itemSize = '40px';
                switch (this.esf.displayDensity) {
                    case DisplayDensity.cosy:
                        itemSize = '32px';
                        break;
                    case DisplayDensity.compact:
                        itemSize = '24px';
                        break;
                    default: break;
                }
                return itemSize;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleSearchComponent.prototype, "type", {
            /**
             * @hidden @internal
             */
            get: function () {
                var _a;
                switch ((_a = this.esf.column) === null || _a === void 0 ? void 0 : _a.dataType) {
                    case DataType.Number:
                    case DataType.Currency:
                    case DataType.Percent:
                        return 'number';
                    default:
                        return 'text';
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleSearchComponent.prototype, "containerSize", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this.list) {
                    return this.list.element.nativeElement.offsetHeight;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleSearchComponent.prototype, "applyButtonDisabled", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.esf.listData[0] && !this.esf.listData[0].isSelected && !this.esf.listData[0].indeterminate ||
                    this.displayedListData && this.displayedListData.length === 0;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxExcelStyleSearchComponent.prototype.onInputKeyDown = function (event) {
            switch (event.key) {
                case "Enter" /* ENTER */:
                    event.preventDefault();
                    this.applyFilter();
                    return;
                case "Escape" /* ESCAPE */ || "Esc" /* ESCAPE_IE */:
                    if (this.searchValue) {
                        event.stopPropagation();
                        this.clearInput();
                    }
                    return;
            }
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleSearchComponent.prototype.filterListData = function () {
            if (!this.esf.listData || !this.esf.listData.length) {
                this.displayedListData = [];
                return;
            }
            var searchAllBtn = this.esf.listData[0];
            if (!this.searchValue) {
                var anyFiltered = this.esf.listData.some(function (i) { return i.isFiltered; });
                var anyUnfiltered = this.esf.listData.some(function (i) { return !i.isFiltered; });
                if (anyFiltered && anyUnfiltered) {
                    searchAllBtn.indeterminate = true;
                }
                this.esf.listData.forEach(function (i) { return i.isSelected = i.isFiltered; });
                this.displayedListData = this.esf.listData;
                searchAllBtn.label = this.esf.grid.resourceStrings.igx_grid_excel_select_all;
                return;
            }
            var searchVal = this.searchValue.toLowerCase();
            this.displayedListData = this.esf.listData.filter(function (it, i) { return (i === 0 && it.isSpecial) ||
                (it.label !== null && it.label !== undefined) &&
                    !it.isBlanks &&
                    it.label.toString().toLowerCase().indexOf(searchVal) > -1; });
            this.esf.listData.forEach(function (i) { return i.isSelected = false; });
            this.displayedListData.forEach(function (i) { return i.isSelected = true; });
            this.displayedListData.splice(1, 0, this.addToCurrentFilter);
            searchAllBtn.indeterminate = false;
            searchAllBtn.label = this.esf.grid.resourceStrings.igx_grid_excel_select_all_search_results;
            if (this.displayedListData.length === 2) {
                this.displayedListData = [];
            }
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleSearchComponent.prototype.applyFilter = function () {
            var _this = this;
            var filterTree = new FilteringExpressionsTree(exports.FilteringLogic.Or, this.esf.column.field);
            var item = this.displayedListData[1];
            var addToCurrentFilterOptionVisible = item === this.addToCurrentFilter;
            var selectedItems = addToCurrentFilterOptionVisible && item.isSelected ?
                this.esf.listData.slice(1, this.esf.listData.length).filter(function (el) { return el.isSelected || el.isFiltered; }) :
                this.esf.listData.slice(1, this.esf.listData.length).filter(function (el) { return el.isSelected; });
            var unselectedItem = this.esf.listData.slice(1, this.esf.listData.length).find(function (el) { return el.isSelected === false; });
            if (unselectedItem) {
                if (selectedItems.length <= IgxExcelStyleSearchComponent.filterOptimizationThreshold) {
                    selectedItems.forEach(function (element) {
                        var condition = null;
                        if (element.value !== null && element.value !== undefined) {
                            if (_this.esf.column.dataType === DataType.Boolean) {
                                condition = _this.createCondition(element.value.toString());
                            }
                            else {
                                condition = _this.createCondition('equals');
                            }
                        }
                        else {
                            condition = _this.createCondition('empty');
                        }
                        filterTree.filteringOperands.push({
                            condition: condition,
                            fieldName: _this.esf.column.field,
                            ignoreCase: _this.esf.column.filteringIgnoreCase,
                            searchVal: element.value
                        });
                    });
                }
                else {
                    var blanksItemIndex = selectedItems.findIndex(function (e) { return e.value === null || e.value === undefined; });
                    var blanksItem = void 0;
                    if (blanksItemIndex >= 0) {
                        blanksItem = selectedItems[blanksItemIndex];
                        selectedItems.splice(blanksItemIndex, 1);
                    }
                    filterTree.filteringOperands.push({
                        condition: this.createCondition('in'),
                        fieldName: this.esf.column.field,
                        ignoreCase: this.esf.column.filteringIgnoreCase,
                        searchVal: new Set(this.esf.column.dataType === DataType.Date ?
                            selectedItems.map(function (d) { return d.value.toISOString(); }) :
                            selectedItems.map(function (e) { return e.value; }))
                    });
                    if (blanksItem) {
                        filterTree.filteringOperands.push({
                            condition: this.createCondition('empty'),
                            fieldName: this.esf.column.field,
                            ignoreCase: this.esf.column.filteringIgnoreCase,
                            searchVal: blanksItem.value
                        });
                    }
                }
                this.esf.grid.filteringService.filterInternal(this.esf.column.field, filterTree);
                this.esf.expressionsList = new Array();
                this.esf.grid.filteringService.generateExpressionsList(this.esf.column.filteringExpressionsTree, this.esf.grid.filteringLogic, this.esf.expressionsList);
            }
            else {
                this.esf.grid.filteringService.clearFilter(this.esf.column.field);
            }
            this.esf.closeDropdown();
        };
        IgxExcelStyleSearchComponent.prototype.createCondition = function (conditionName) {
            switch (this.esf.column.dataType) {
                case DataType.Boolean:
                    return IgxBooleanFilteringOperand.instance().condition(conditionName);
                case DataType.Number:
                case DataType.Currency:
                case DataType.Percent:
                    return IgxNumberFilteringOperand.instance().condition(conditionName);
                case DataType.Date:
                    return IgxDateFilteringOperand.instance().condition(conditionName);
                default:
                    return IgxStringFilteringOperand.instance().condition(conditionName);
            }
        };
        return IgxExcelStyleSearchComponent;
    }());
    IgxExcelStyleSearchComponent.filterOptimizationThreshold = 2;
    IgxExcelStyleSearchComponent.decorators = [
        { type: i0.Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-search',
                    template: "<igx-input-group\n            type=\"box\"\n            [displayDensity]=\"esf.displayDensity\">\n    <igx-icon igxPrefix>search</igx-icon>\n    <input\n        #input\n        igxInput\n        tabindex=\"0\"\n        [(ngModel)]=\"searchValue\"\n        (ngModelChange)=\"filterListData()\"\n        (keydown)=\"onInputKeyDown($event)\"\n        [placeholder]=\"esf.column?.grid.resourceStrings.igx_grid_excel_search_placeholder\"\n        [type]=\"type\"\n        autocomplete=\"off\"/>\n    <igx-icon\n        igxSuffix\n        *ngIf=\"searchValue || searchValue === 0\"\n        (click)=\"clearInput()\"\n        tabindex=\"0\">\n        clear\n    </igx-icon>\n</igx-input-group>\n\n<igx-list #list [displayDensity]=\"esf.displayDensity\" [isLoading]=\"isLoading\">\n    <div [style.overflow]=\"'hidden'\" [style.position]=\"'relative'\">\n        <igx-list-item\n        *igxFor=\"let item of displayedListData scrollOrientation : 'vertical'; containerSize: containerSize; itemSize: itemSize\">\n            <igx-checkbox\n            [value]=\"item\"\n            tabindex=\"-1\"\n            [checked]=\"item.isSelected\"\n            [disableRipple]=\"true\"\n            [indeterminate]=\"item.indeterminate\"\n            [disableTransitions]=\"true\"\n            (change)=\"onCheckboxChange($event)\">\n                {{ item.label }}\n            </igx-checkbox>\n        </igx-list-item>\n    </div>\n\n    <ng-template igxDataLoading>\n        <div class=\"igx-excel-filter__loading\">\n            <ng-container *ngTemplateOutlet=\"valuesLoadingTemplate\">\n            </ng-container>\n        </div>\n    </ng-template>\n</igx-list>\n\n<ng-template #defaultExcelStyleLoadingValuesTemplate>\n    <igx-circular-bar [indeterminate]=\"true\">\n    </igx-circular-bar>\n</ng-template>\n\n<footer class=\"igx-excel-filter__menu-footer\">\n    <button igxButton [displayDensity]=\"esf.displayDensity\" (click)=\"esf.cancel()\">{{ esf.grid?.resourceStrings.igx_grid_excel_cancel }}</button>\n    <button igxButton=\"raised\" [displayDensity]=\"esf.displayDensity\" [disabled]=\"applyButtonDisabled\" (click)=\"applyFilter()\">{{ esf.grid?.resourceStrings.igx_grid_excel_apply }}</button>\n</footer>\n"
                },] }
    ];
    IgxExcelStyleSearchComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef },
        { type: IgxGridExcelStyleFilteringComponent }
    ]; };
    IgxExcelStyleSearchComponent.propDecorators = {
        defaultClass: [{ type: i0.HostBinding, args: ['class.igx-excel-filter__menu-main',] }],
        searchInput: [{ type: i0.ViewChild, args: ['input', { read: IgxInputDirective, static: true },] }],
        list: [{ type: i0.ViewChild, args: ['list', { read: IgxListComponent, static: true },] }],
        virtDir: [{ type: i0.ViewChild, args: [IgxForOfDirective, { static: true },] }],
        defaultExcelStyleLoadingValuesTemplate: [{ type: i0.ViewChild, args: ['defaultExcelStyleLoadingValuesTemplate', { read: i0.TemplateRef },] }]
    };

    /**
     * A component used for presenting Excel style conditional filter UI.
     */
    var IgxExcelStyleSelectingComponent = /** @class */ (function () {
        function IgxExcelStyleSelectingComponent(esf) {
            this.esf = esf;
        }
        return IgxExcelStyleSelectingComponent;
    }());
    IgxExcelStyleSelectingComponent.decorators = [
        { type: i0.Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-selecting',
                    template: "<div *ngIf=\"esf.column\"\n    [ngClass]=\"esf.selectedClass()\"\n    tabindex=\"0\"\n    (click)=\"esf.onSelect()\">\n    <span>{{esf.grid.resourceStrings.igx_grid_excel_select }}</span>\n    <igx-icon>done</igx-icon>\n</div>\n"
                },] }
    ];
    IgxExcelStyleSelectingComponent.ctorParameters = function () { return [
        { type: IgxGridExcelStyleFilteringComponent }
    ]; };

    /**
     * A component used for presenting Excel style column sorting UI.
     */
    var IgxExcelStyleSortingComponent = /** @class */ (function () {
        function IgxExcelStyleSortingComponent(esf, cdr) {
            var _this = this;
            this.esf = esf;
            this.cdr = cdr;
            /**
             * @hidden @internal
             */
            this.defaultClass = true;
            this.destroy$ = new rxjs.Subject();
            this.esf.sortingChanged.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                _this.updateSelectedButtons(_this.esf.column.field);
            });
        }
        IgxExcelStyleSortingComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden @internal
         */
        IgxExcelStyleSortingComponent.prototype.onSortButtonClicked = function (sortDirection) {
            if (this.sortButtonGroup.selectedIndexes.length === 0) {
                if (this.esf.grid.isColumnGrouped(this.esf.column.field)) {
                    this.sortButtonGroup.selectButton(sortDirection - 1);
                }
                else {
                    this.esf.grid.clearSort(this.esf.column.field);
                }
            }
            else {
                this.esf.grid.sort({ fieldName: this.esf.column.field, dir: sortDirection, ignoreCase: true });
            }
        };
        IgxExcelStyleSortingComponent.prototype.updateSelectedButtons = function (fieldName) {
            var _this = this;
            var sortIndex = this.esf.grid.sortingExpressions.findIndex(function (s) { return s.fieldName === fieldName; });
            this.cdr.detectChanges();
            this.sortButtonGroup.buttons.forEach(function (b, i) {
                _this.sortButtonGroup.deselectButton(i);
            });
            if (sortIndex !== -1) {
                var sortDirection = this.esf.grid.sortingExpressions[sortIndex].dir;
                this.sortButtonGroup.selectButton(sortDirection - 1);
            }
        };
        return IgxExcelStyleSortingComponent;
    }());
    IgxExcelStyleSortingComponent.decorators = [
        { type: i0.Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-sorting',
                    template: "<ng-container *ngIf=\"esf.column\">\n<header>\n    {{ esf.grid.resourceStrings.igx_grid_excel_filter_sorting_header }}\n</header>\n<igx-buttongroup #sortButtonGroup [multiSelection]=\"false\">\n    <button igxButton\n        [displayDensity]=\"esf.grid.displayDensity\"\n        [attr.data-togglable]=\"true\"\n        (click)=\"onSortButtonClicked(1)\"\n        >\n        <igx-icon>arrow_upwards</igx-icon>\n        <span>\n            {{ esf.grid.displayDensity==='compact'?\n            esf.grid.resourceStrings.igx_grid_excel_filter_sorting_asc_short:\n            esf.grid.resourceStrings.igx_grid_excel_filter_sorting_asc  }}\n        </span>\n    </button>\n\n    <button igxButton\n        [displayDensity]=\"esf.grid.displayDensity\"\n        [attr.data-togglable]=\"true\"\n        (click)=\"onSortButtonClicked(2)\"\n        >\n        <igx-icon>arrow_downwards</igx-icon>\n        <span>\n            {{ esf.grid.displayDensity==='compact'?\n            esf.grid.resourceStrings.igx_grid_excel_filter_sorting_desc_short:\n            esf.grid.resourceStrings.igx_grid_excel_filter_sorting_desc\n        }}\n        </span>\n    </button>\n</igx-buttongroup>\n</ng-container>\n"
                },] }
    ];
    IgxExcelStyleSortingComponent.ctorParameters = function () { return [
        { type: IgxGridExcelStyleFilteringComponent },
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxExcelStyleSortingComponent.propDecorators = {
        defaultClass: [{ type: i0.HostBinding, args: ['class.igx-excel-filter__sort',] }],
        sortButtonGroup: [{ type: i0.ViewChild, args: ['sortButtonGroup', { read: IgxButtonGroupComponent },] }]
    };

    /**
     * Providing reference to `IgxGridCellComponent`:
     * ```typescript
     * @ViewChild('grid', { read: IgxGridComponent })
     *  public grid: IgxGridComponent;
     * ```
     * ```typescript
     *  let column = this.grid.columnList.first;
     * ```
     * ```typescript
     *  let cell = column.cells[0];
     * ```
     */
    var IgxGridCellComponent = /** @class */ (function () {
        function IgxGridCellComponent(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil) {
            var _this = this;
            this.selectionService = selectionService;
            this.crudService = crudService;
            this.gridAPI = gridAPI;
            this.cdr = cdr;
            this.element = element;
            this.zone = zone;
            this.touchManager = touchManager;
            this.platformUtil = platformUtil;
            /**
             * @hidden
             * @internal
             */
            this.lastPinned = false;
            /**
             * @hidden
             * @internal
             */
            this.firstPinned = false;
            /**
             * Returns whether the cell is in edit mode.
             */
            this.editMode = false;
            /**
             * Sets/get the `role` property of the cell.
             * Default value is `"gridcell"`.
             * ```typescript
             * this.cell.role = 'grid-cell';
             * ```
             * ```typescript
             * let cellRole = this.cell.role;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            this.role = 'gridcell';
            /**
             * Gets the width of the cell.
             * ```typescript
             * let cellWidth = this.cell.width;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            this.width = '';
            /**
             * @hidden
             */
            this.active = false;
            /**
             * @hidden
             */
            this.displayPinnedChip = false;
            /**
             * Sets/gets the highlight class of the cell.
             * Default value is `"igx-highlight"`.
             * ```typescript
             * let highlightClass = this.cell.highlightClass;
             * ```
             * ```typescript
             * this.cell.highlightClass = 'igx-cell-highlight';
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            this.highlightClass = 'igx-highlight';
            /**
             * Sets/gets the active highlight class class of the cell.
             * Default value is `"igx-highlight__active"`.
             * ```typescript
             * let activeHighlightClass = this.cell.activeHighlightClass;
             * ```
             * ```typescript
             * this.cell.activeHighlightClass = 'igx-cell-highlight_active';
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            this.activeHighlightClass = 'igx-highlight__active';
            /** @hidden @internal @deprecated */
            this.focused = this.active;
            this._cellSelection = GridSelectionMode.multiple;
            this._vIndex = -1;
            /**
             * @hidden
             * @internal
             */
            this.onDoubleClick = function (event) {
                if (event.type === 'doubletap') {
                    // prevent double-tap to zoom on iOS
                    event.preventDefault();
                }
                if (_this.grid.rowEditable && _this.row.addRow) {
                    _this.crudService.enterEditMode(_this, event);
                }
                if (_this.editable && !_this.editMode && !_this.row.deleted && !_this.crudService.rowEditingBlocked) {
                    _this.crudService.enterEditMode(_this, event);
                }
                _this.grid.onDoubleClick.emit({
                    cell: _this,
                    event: event
                });
            };
            /**
             *
             * @hidden
             * @internal
             */
            this.pointerdown = function (event) {
                if (_this.cellSelectionMode !== GridSelectionMode.multiple) {
                    _this.activate(event);
                    return;
                }
                if (!isLeftClick(event)) {
                    event.preventDefault();
                    _this.grid.navigation.setActiveNode({ rowIndex: _this.rowIndex, colIndex: _this.visibleColumnIndex });
                    _this.selectionService.addKeyboardRange();
                    _this.selectionService.initKeyboardState();
                    _this.selectionService.primaryButton = false;
                    // Ensure RMB Click on edited cell does not end cell editing
                    if (!_this.selected) {
                        _this.gridAPI.submit_value(event);
                    }
                    return;
                }
                _this.selectionService.pointerDown(_this.selectionNode, event.shiftKey, event.ctrlKey);
                _this.activate(event);
            };
            /**
             *
             * @hidden
             * @internal
             */
            this.pointerenter = function (event) {
                var isHierarchicalGrid = _this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
                if (isHierarchicalGrid && (!_this.grid.navigation.activeNode.gridID || _this.grid.navigation.activeNode.gridID !== _this.gridID)) {
                    return;
                }
                var dragMode = _this.selectionService.pointerEnter(_this.selectionNode, event);
                if (dragMode) {
                    _this.grid.cdr.detectChanges();
                    if (isIE()) {
                        _this.grid.tbody.nativeElement.focus({ preventScroll: true });
                    }
                }
            };
            /**
             * @hidden
             * @internal
             */
            this.pointerup = function (event) {
                var isHierarchicalGrid = _this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
                if (!isLeftClick(event) || (isHierarchicalGrid && (!_this.grid.navigation.activeNode.gridID ||
                    _this.grid.navigation.activeNode.gridID !== _this.gridID))) {
                    return;
                }
                if (_this.selectionService.pointerUp(_this.selectionNode, _this.grid.onRangeSelection)) {
                    _this.grid.cdr.detectChanges();
                    if (isIE()) {
                        _this.grid.tbody.nativeElement.focus({ preventScroll: true });
                    }
                }
            };
        }
        Object.defineProperty(IgxGridCellComponent.prototype, "isEmptyAddRowCell", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.row.addRow && (this.value === undefined || this.value === null);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "context", {
            /**
             * Gets the cell template context object.
             * ```typescript
             *  let context = this.cell.context();
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return {
                    $implicit: this.value,
                    cell: this
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "template", {
            /**
             * Gets the cell template.
             * ```typescript
             * let template = this.cell.template;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                if (this.editMode) {
                    var inlineEditorTemplate = this.column.inlineEditorTemplate;
                    return inlineEditorTemplate ? inlineEditorTemplate : this.inlineEditorTemplate;
                }
                if (this.cellTemplate) {
                    return this.cellTemplate;
                }
                if (this.grid.rowEditable && this.row.addRow) {
                    return this.addRowCellTemplate;
                }
                return this.defaultCellTemplate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "pinnedIndicatorTemplate", {
            /**
             * Gets the cell template.
             * ```typescript
             * let template = this.cell.template;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                if (this.pinnedIndicator) {
                    return this.pinnedIndicator;
                }
                return this.defaultPinnedIndicator;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "gridID", {
            /**
             * Gets the `id` of the grid in which the cell is stored.
             * ```typescript
             * let gridId = this.cell.gridID;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.row.gridID;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "grid", {
            /**
             * Gets the grid of the cell.
             * ```typescript
             * let grid = this.cell.grid;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "rowIndex", {
            /**
             * Gets the `index` of the row where the cell is stored.
             * ```typescript
             * let rowIndex = this.cell.rowIndex;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.row.index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "columnIndex", {
            /**
             * Gets the `index` of the cell column.
             * ```typescript
             * let columnIndex = this.cell.columnIndex;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.column.index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "visibleColumnIndex", {
            /**
             * Gets the visible `index` of the in which the cell is stored.
             * ```typescript
             * let visibleColumnIndex = this.cell.visibleColumnIndex;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.column.columnLayoutChild ? this.column.visibleIndex : this._vIndex;
            },
            set: function (val) {
                this._vIndex = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "cellID", {
            /**
             * Gets the ID of the cell.
             * ```typescript
             * let cellID = this.cell.cellID;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                var primaryKey = this.grid.primaryKey;
                var rowID = primaryKey ? this.rowData[primaryKey] : this.rowData;
                return { rowID: rowID, columnID: this.columnIndex, rowIndex: this.rowIndex };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "attrCellID", {
            get: function () {
                return this.row.gridID + "_" + this.rowIndex + "_" + this.visibleColumnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "title", {
            get: function () {
                return this.editMode || this.cellTemplate ? '' : this.column.dataType === DataType.Percent ?
                    this.grid.percentPipe.transform(this.value, this.column.pipeArgs.digitsInfo, this.grid.locale) :
                    this.column.dataType === DataType.Currency ?
                        this.grid.currencyPipe.transform(this.value, this.currencyCode, this.column.pipeArgs.display, this.column.pipeArgs.digitsInfo, this.grid.locale) :
                        this.value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "booleanClass", {
            get: function () {
                return this.column.dataType === 'boolean' && this.value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "nativeElement", {
            /**
             * Returns a reference to the nativeElement of the cell.
             * ```typescript
             * let cellNativeElement = this.cell.nativeElement;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "cellSelectionMode", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this._cellSelection;
            },
            set: function (value) {
                var _this = this;
                if (this._cellSelection === value) {
                    return;
                }
                this.zone.runOutsideAngular(function () {
                    if (value === GridSelectionMode.multiple) {
                        _this.addPointerListeners(value);
                    }
                    else {
                        _this.removePointerListeners(_this._cellSelection);
                    }
                });
                this._cellSelection = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "lastSearchInfo", {
            /**
             * @hidden
             * @internal
             */
            set: function (value) {
                this._lastSearchInfo = value;
                this.highlightText(this._lastSearchInfo.searchText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "readonly", {
            /**
             * Gets whether the cell is editable.
             * ```typescript
             * let isCellReadonly = this.cell.readonly;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return !this.editable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "gridRowSpan", {
            get: function () {
                return this.column.gridRowSpan;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "gridColumnSpan", {
            get: function () {
                return this.column.gridColumnSpan;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "rowEnd", {
            get: function () {
                return this.column.rowEnd;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "colEnd", {
            get: function () {
                return this.column.colEnd;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "rowStart", {
            get: function () {
                return this.column.rowStart;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "colStart", {
            get: function () {
                return this.column.colStart;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "ariaSelected", {
            get: function () {
                return this.selected || this.column.selected || this.row.selected;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "selected", {
            /**
             * Gets whether the cell is selected.
             * ```typescript
             * let isSelected = this.cell.selected;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.selectionService.selected(this.selectionNode);
            },
            /**
             * Selects/deselects the cell.
             * ```typescript
             * this.cell.selected = true.
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            set: function (val) {
                var node = this.selectionNode;
                if (val) {
                    this.selectionService.add(node);
                }
                else {
                    this.selectionService.remove(node);
                }
                this.grid.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "columnSelected", {
            /**
             * Gets whether the cell column is selected.
             * ```typescript
             * let isCellColumnSelected = this.cell.columnSelected;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.selectionService.isColumnSelected(this.column.field);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "editValue", {
            /**
             * Gets the current edit value while a cell is in edit mode.
             * Only for cell editing mode.
             * ```typescript
             * let editValue = this.cell.editValue;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            get: function () {
                if (this.crudService.cellInEditMode) {
                    return this.crudService.cell.editValue;
                }
            },
            /**
             * Sets the current edit value while a cell is in edit mode.
             * Only for cell editing mode.
             * ```typescript
             * this.cell.editValue = value;
             * ```
             *
             * @memberof IgxGridCellComponent
             */
            set: function (value) {
                if (this.crudService.cellInEditMode) {
                    this.crudService.cell.editValue = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "editable", {
            /**
             * Returns whether the cell is editable.
             */
            get: function () {
                return this.column.editable && !this.row.disabled;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "highlight", {
            get: function () {
                return this._highlight;
            },
            set: function (value) {
                this._highlight = value;
                if (this._highlight && this.grid.lastSearchInfo.searchText) {
                    this._highlight.highlight(this.grid.lastSearchInfo.searchText, this.grid.lastSearchInfo.caseSensitive, this.grid.lastSearchInfo.exactMatch);
                    this._highlight.activateIfNecessary();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "selectionNode", {
            get: function () {
                return {
                    row: this.rowIndex,
                    column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
                    layout: this.column.columnLayoutChild ? {
                        rowStart: this.column.rowStart,
                        colStart: this.column.colStart,
                        rowEnd: this.column.rowEnd,
                        colEnd: this.column.colEnd,
                        columnVisibleIndex: this.visibleColumnIndex
                    } : null
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "step", {
            /** @hidden @internal */
            get: function () {
                var digitsInfo = this.column.pipeArgs.digitsInfo;
                if (!digitsInfo) {
                    return 1;
                }
                var step = +digitsInfo.substr(digitsInfo.indexOf('.') + 1, 1);
                return 1 / (Math.pow(10, step));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "currencyCode", {
            /** @hidden @internal */
            get: function () {
                return this.column.pipeArgs.currencyCode ?
                    this.column.pipeArgs.currencyCode : i2.getLocaleCurrencyCode(this.grid.locale);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "currencyCodeSymbol", {
            /** @hidden @internal */
            get: function () {
                return i2.getCurrencySymbol(this.currencyCode, 'wide', this.grid.locale);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @deprecated
         * Gets whether the cell is selected.
         * ```typescript
         * let isCellSelected = thid.cell.isCellSelected();
         * ```
         * @memberof IgxGridCellComponent
         */
        IgxGridCellComponent.prototype.isCellSelected = function () {
            return this.selectionService.selected(this.selectionNode);
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.onClick = function (event) {
            this.grid.onCellClick.emit({
                cell: this,
                event: event
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.onContextMenu = function (event) {
            this.grid.onContextMenu.emit({
                cell: this,
                event: event
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                _this.nativeElement.addEventListener('pointerdown', _this.pointerdown);
                _this.addPointerListeners(_this.cellSelectionMode);
                // IE 11 workarounds
                if (_this.platformUtil.isBrowser && isIE()) { // TODO: Move isIE to platformUtil
                    _this.compositionStartHandler = function () { return _this.crudService.isInCompositionMode = true; };
                    _this.compositionEndHandler = function () { return _this.crudService.isInCompositionMode = false; };
                    // Hitting Enter with IME submits and exits from edit mode instead of first closing the IME dialog
                    _this.nativeElement.addEventListener('compositionstart', _this.compositionStartHandler);
                    _this.nativeElement.addEventListener('compositionend', _this.compositionEndHandler);
                }
            });
            if (this.platformUtil.isIOS) {
                this.touchManager.addEventListener(this.nativeElement, 'doubletap', this.onDoubleClick, {
                    cssProps: {} /* don't disable user-select, etc */
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.ngOnDestroy = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                _this.nativeElement.removeEventListener('pointerdown', _this.pointerdown);
                _this.removePointerListeners(_this.cellSelectionMode);
                if (_this.platformUtil.isBrowser && isIE()) {
                    _this.nativeElement.removeEventListener('compositionstart', _this.compositionStartHandler);
                    _this.nativeElement.removeEventListener('compositionend', _this.compositionEndHandler);
                }
            });
            this.touchManager.destroy();
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype._updateCRUDStatus = function (event) {
            if (this.editMode) {
                return;
            }
            var crud = this.crudService;
            var editableCell = this.crudService.cell;
            var editMode = !!(crud.row || crud.cell);
            if (this.editable && editMode && !this.row.deleted) {
                if (editableCell) {
                    if (this.row.addRow) {
                        this.gridAPI.update_add_cell(editableCell, editableCell.editValue, event);
                        this.row.rowData = editableCell.rowData;
                    }
                    else {
                        this.gridAPI.update_cell(editableCell, editableCell.editValue, event);
                    }
                    /* This check is related with the following issue #6517:
                     * when edit cell that belongs to a column which is sorted and press tab,
                     * the next cell in edit mode is with wrong value /its context is not updated/;
                     * So we reapply sorting before the next cell enters edit mode.
                     * Also we need to keep the notifyChanges below, because of the current
                     * change detection cycle when we have editing with enabled transactions
                     */
                    if (this.grid.sortingExpressions.length && this.grid.sortingExpressions.indexOf(editableCell.column.field)) {
                        this.grid.cdr.detectChanges();
                    }
                    if (this.crudService.cellEditingBlocked) {
                        return true;
                    }
                    crud.exitCellEdit(event);
                }
                this.grid.tbody.nativeElement.focus({ preventScroll: true });
                this.grid.notifyChanges();
                crud.enterEditMode(this, event);
                return false;
            }
            if (editableCell && crud.sameRow(this.cellID.rowID)) {
                if (this.row.addRow) {
                    this.gridAPI.submit_add_value(event);
                    this.row.rowData = editableCell.rowData;
                }
                else {
                    this.gridAPI.submit_value(event);
                }
            }
            else if (editMode && !crud.sameRow(this.cellID.rowID)) {
                this.grid.endEdit(true, event);
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.ngOnChanges = function (changes) {
            if (changes.value && !changes.value.firstChange) {
                if (this.highlight) {
                    this.highlight.lastSearchInfo.searchedText = this.grid.lastSearchInfo.searchText;
                    this.highlight.lastSearchInfo.caseSensitive = this.grid.lastSearchInfo.caseSensitive;
                    this.highlight.lastSearchInfo.exactMatch = this.grid.lastSearchInfo.exactMatch;
                }
            }
        };
        /**
         * Starts/ends edit mode for the cell.
         *
         * ```typescript
         * cell.setEditMode(true);
         * ```
         */
        IgxGridCellComponent.prototype.setEditMode = function (value) {
            if (this.row.deleted) {
                return;
            }
            if (this.editable && value) {
                this.gridAPI.submit_value();
                this.crudService.enterEditMode(this);
            }
            else {
                this.grid.crudService.exitCellEdit();
            }
            this.grid.notifyChanges();
        };
        /**
         * Sets new value to the cell.
         * ```typescript
         * this.cell.update('New Value');
         * ```
         *
         * @memberof IgxGridCellComponent
         */
        // TODO: Refactor
        IgxGridCellComponent.prototype.update = function (val) {
            if (this.row.deleted) {
                return;
            }
            var cell = this.crudService.createCell(this);
            var args = this.gridAPI.update_cell(cell, val);
            if (this.crudService.cell && this.crudService.sameCell(cell)) {
                if (args.cancel) {
                    return;
                }
                this.grid.crudService.exitCellEdit();
            }
            this.cdr.markForCheck();
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.activate = function (event) {
            var node = this.selectionNode;
            var shouldEmitSelection = !this.selectionService.isActiveNode(node);
            if (this.selectionService.primaryButton) {
                this._updateCRUDStatus(event);
                var activeElement = this.selectionService.activeElement;
                var row = activeElement ? this.gridAPI.get_row_by_index(activeElement.row) : null;
                if ((this.crudService.rowEditingBlocked && row && this.row.rowID !== row.rowID) ||
                    (this.crudService.cell && this.crudService.cellEditingBlocked)) {
                    return;
                }
                this.selectionService.activeElement = node;
            }
            else {
                this.selectionService.activeElement = null;
                if (this.crudService.cellInEditMode && !this.editMode) {
                    this.gridAPI.submit_value(event);
                }
            }
            this.grid.navigation.setActiveNode({ row: this.rowIndex, column: this.visibleColumnIndex });
            this.selectionService.primaryButton = true;
            if (this.cellSelectionMode === GridSelectionMode.multiple && this.selectionService.activeElement) {
                this.selectionService.add(this.selectionService.activeElement, false); // pointer events handle range generation
                this.selectionService.keyboardStateOnFocus(node, this.grid.onRangeSelection, this.nativeElement);
            }
            if (this.grid.isCellSelectable && shouldEmitSelection) {
                this.grid.onSelection.emit({ cell: this, event: event });
            }
        };
        /**
         * If the provided string matches the text in the cell, the text gets highlighted.
         * ```typescript
         * this.cell.highlightText('Cell Value', true);
         * ```
         *
         * @memberof IgxGridCellComponent
         */
        IgxGridCellComponent.prototype.highlightText = function (text, caseSensitive, exactMatch) {
            return this.highlight && this.column.searchable ? this.highlight.highlight(text, caseSensitive, exactMatch) : 0;
        };
        /**
         * Clears the highlight of the text in the cell.
         * ```typescript
         * this.cell.clearHighLight();
         * ```
         *
         * @memberof IgxGridCellComponent
         */
        IgxGridCellComponent.prototype.clearHighlight = function () {
            if (this.highlight && this.column.searchable) {
                this.highlight.clearHighlight();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.calculateSizeToFit = function (range) {
            return Math.max.apply(Math, __spread(Array.from(this.nativeElement.children)
                .map(function (child) { return getNodeSizeViaRange(range, child); })));
        };
        Object.defineProperty(IgxGridCellComponent.prototype, "searchMetadata", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                var meta = new Map();
                meta.set('pinned', this.grid.isRecordPinnedByViewIndex(this.row.index));
                return meta;
            },
            enumerable: false,
            configurable: true
        });
        IgxGridCellComponent.prototype.addPointerListeners = function (selection) {
            if (selection !== GridSelectionMode.multiple) {
                return;
            }
            this.nativeElement.addEventListener('pointerenter', this.pointerenter);
            this.nativeElement.addEventListener('pointerup', this.pointerup);
        };
        IgxGridCellComponent.prototype.removePointerListeners = function (selection) {
            if (selection !== GridSelectionMode.multiple) {
                return;
            }
            this.nativeElement.removeEventListener('pointerenter', this.pointerenter);
            this.nativeElement.removeEventListener('pointerup', this.pointerup);
        };
        return IgxGridCellComponent;
    }());
    IgxGridCellComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    selector: 'igx-grid-cell',
                    template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip\n        *ngIf=\"displayPinnedChip\"\n        class=\"igx-grid__td--pinned-chip\"\n        [disabled]=\"true\"\n        [displayDensity]=\"'compact'\"\n        >{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip\n    >\n</ng-template>\n<ng-template #defaultCell>\n    <div *ngIf=\"column.dataType !== 'boolean'\"\n        igxTextHighlight\n        class=\"igx-grid__td-text\"\n        style=\"pointer-events: none;\"\n        [cssClass]=\"highlightClass\"\n        [activeCssClass]=\"activeHighlightClass\"\n        [groupName]=\"gridID\"\n        [value]=\"\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === 'number'\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'date'\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : column.dataType === 'currency'\n                ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'percent'\n                ? (value | percent:column.pipeArgs.digitsInfo:grid.locale)\n                : value\n        \"\n        [row]=\"rowData\"\n        [column]=\"this.column.field\"\n        [containerClass]=\"'igx-grid__td-text'\"\n        [metadata]=\"searchMetadata\"\n    >{{\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === \"number\"\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === \"date\"\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : column.dataType === 'currency'\n                ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'percent'\n                ? (value | percent:column.pipeArgs.digitsInfo:grid.locale)\n                : value\n        }}</div>\n    <igx-icon\n        *ngIf=\"column.dataType === 'boolean'\"\n        [ngClass]=\"{ 'igx-icon--success': value, 'igx-icon--error': !value }\"\n        >{{ value ? \"check\" : \"close\" }}</igx-icon\n    >\n</ng-template>\n<ng-template #addRowCell let-cell=\"cell\">\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n    [cssClass]=\"highlightClass\"\n    [activeCssClass]=\"activeHighlightClass\"\n    [groupName]=\"gridID\"\n    [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ?\n        (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ?\n        (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : column.dataType === 'currency' ?\n        (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'percent' ?\n        (value | percent:column.pipeArgs.digitsInfo:grid.locale) : value\"\n    [row]=\"rowData\"\n    [column]=\"this.column.field\"\n    [containerClass]=\"'igx-grid__td-text'\"\n    [metadata]=\"searchMetadata\">{{\n        !isEmptyAddRowCell ? value : (column.header || column.field)\n    }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox\n            (change)=\"editValue = $event.checked\"\n            [value]=\"editValue\"\n            [checked]=\"editValue\"\n            [igxFocus]=\"true\"\n            [disableRipple]=\"true\"\n        ></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker\n            [style.width.%]=\"100\"\n            [outlet]=\"grid.outlet\"\n            mode=\"dropdown\"\n            [locale]=\"grid.locale\"\n            [(value)]=\"editValue\"\n            [igxFocus]=\"true\"\n            [labelVisibility]=\"false\"\n        >\n        </igx-date-picker>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'currency'\">\n        <igx-input-group displayDensity=\"compact\">\n            <igx-prefix *ngIf=\"grid.currencyPositionLeft\">{{ currencyCodeSymbol }}</igx-prefix>\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n            <igx-suffix *ngIf=\"!grid.currencyPositionLeft\" >{{ currencyCodeSymbol }}</igx-suffix>\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'percent'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n            <igx-suffix> {{ editValue | percent:column.pipeArgs.digitsInfo:grid.locale }} </igx-suffix>\n        </igx-input-group>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n",
                    providers: [HammerGesturesManager]
                },] }
    ];
    IgxGridCellComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: GridBaseAPIService },
        { type: i0.ChangeDetectorRef },
        { type: i0.ElementRef },
        { type: i0.NgZone },
        { type: HammerGesturesManager },
        { type: PlatformUtil }
    ]; };
    IgxGridCellComponent.propDecorators = {
        isEmptyAddRowCell: [{ type: i0.HostBinding, args: ['class.igx-grid__td--new',] }],
        column: [{ type: i0.Input }],
        row: [{ type: i0.Input }],
        rowData: [{ type: i0.Input }],
        cellTemplate: [{ type: i0.Input }],
        pinnedIndicator: [{ type: i0.Input }],
        value: [{ type: i0.Input }],
        formatter: [{ type: i0.Input }],
        rowIndex: [{ type: i0.HostBinding, args: ['attr.data-rowIndex',] }],
        visibleColumnIndex: [{ type: i0.HostBinding, args: ['attr.data-visibleIndex',] }, { type: i0.Input }],
        attrCellID: [{ type: i0.HostBinding, args: ['attr.id',] }],
        title: [{ type: i0.HostBinding, args: ['attr.title',] }],
        booleanClass: [{ type: i0.HostBinding, args: ['class.igx-grid__td--bool-true',] }],
        cellSelectionMode: [{ type: i0.Input }],
        lastSearchInfo: [{ type: i0.Input }],
        lastPinned: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.igx-grid__td--pinned-last',] }],
        firstPinned: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.igx-grid__td--pinned-first',] }],
        editMode: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.igx-grid__td--editing',] }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        readonly: [{ type: i0.HostBinding, args: ['attr.aria-readonly',] }],
        width: [{ type: i0.Input }],
        active: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.igx-grid__td--active',] }],
        ariaSelected: [{ type: i0.HostBinding, args: ['attr.aria-selected',] }],
        selected: [{ type: i0.HostBinding, args: ['class.igx-grid__td--selected',] }],
        columnSelected: [{ type: i0.HostBinding, args: ['class.igx-grid__td--column-selected',] }],
        displayPinnedChip: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.igx-grid__td--row-pinned-first',] }],
        defaultCellTemplate: [{ type: i0.ViewChild, args: ['defaultCell', { read: i0.TemplateRef, static: true },] }],
        defaultPinnedIndicator: [{ type: i0.ViewChild, args: ['defaultPinnedIndicator', { read: i0.TemplateRef, static: true },] }],
        inlineEditorTemplate: [{ type: i0.ViewChild, args: ['inlineEditor', { read: i0.TemplateRef, static: true },] }],
        addRowCellTemplate: [{ type: i0.ViewChild, args: ['addRowCell', { read: i0.TemplateRef, static: true },] }],
        highlight: [{ type: i0.ViewChild, args: [IgxTextHighlightDirective, { read: IgxTextHighlightDirective },] }],
        onDoubleClick: [{ type: i0.HostListener, args: ['dblclick', ['$event'],] }],
        onClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }],
        onContextMenu: [{ type: i0.HostListener, args: ['contextmenu', ['$event'],] }]
    };
    __decorate([
        DeprecateMethod("'isCellSelected' is deprecated. Use 'selected' property instead.")
    ], IgxGridCellComponent.prototype, "isCellSelected", null);

    var IgxGridBodyDirective = /** @class */ (function () {
        function IgxGridBodyDirective() {
        }
        return IgxGridBodyDirective;
    }());
    IgxGridBodyDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxGridBody]',
                    providers: [IgxForOfSyncService]
                },] }
    ];
    /**
     * @hidden
     */
    var RowEditPositionStrategy = /** @class */ (function (_super) {
        __extends(RowEditPositionStrategy, _super);
        function RowEditPositionStrategy() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.isTop = false;
            _this.isTopInitialPosition = null;
            return _this;
        }
        RowEditPositionStrategy.prototype.position = function (contentElement, size, document, initialCall, target) {
            var container = this.settings.container; // grid.tbody
            var targetElement = target || this.settings.target; // current grid.row
            // Position of the overlay depends on the available space in the grid.
            // If the bottom space is not enough then the the row overlay will show at the top of the row.
            // Once shown, either top or bottom, then this position stays until the overlay is closed (isTopInitialPosition property),
            // which means that when scrolling then overlay may hide, while the row is still visible (UX requirement).
            this.isTop = this.isTopInitialPosition !== null ?
                this.isTopInitialPosition :
                container.getBoundingClientRect().bottom <
                    targetElement.getBoundingClientRect().bottom + contentElement.getBoundingClientRect().height;
            // Set width of the row editing overlay to equal row width, otherwise it fits 100% of the grid.
            contentElement.style.width = targetElement.clientWidth + 'px';
            this.settings.verticalStartPoint = this.settings.verticalDirection = this.isTop ? exports.VerticalAlignment.Top : exports.VerticalAlignment.Bottom;
            this.settings.openAnimation = this.isTop ? scaleInVerBottom : scaleInVerTop;
            _super.prototype.position.call(this, contentElement, { width: targetElement.clientWidth, height: targetElement.clientHeight }, document, initialCall, targetElement);
        };
        return RowEditPositionStrategy;
    }(ConnectedPositioningStrategy));

    // eslint-disable-next-line @angular-eslint/directive-selector
    var IgxExcelTextDirective = /** @class */ (function () {
        function IgxExcelTextDirective() {
        }
        return IgxExcelTextDirective;
    }());
    IgxExcelTextDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[excelText],excel-text' },] }
    ];
    // eslint-disable-next-line @angular-eslint/directive-selector
    var IgxCSVTextDirective = /** @class */ (function () {
        function IgxCSVTextDirective() {
        }
        return IgxCSVTextDirective;
    }());
    IgxCSVTextDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[csvText],csv-text' },] }
    ];
    /**
     * Provides a way to template the title portion of the toolbar in the grid.
     *
     * @igxModule IgxGridToolbarModule
     * @igxParent IgxGridToolbarComponent
     *
     * @example
     * ```html
     * <igx-grid-toolbar-title>My custom title</igx-grid-toolbar-title>
     * ```
     */
    var IgxGridToolbarTitleDirective = /** @class */ (function () {
        function IgxGridToolbarTitleDirective() {
            /**
             * Host `class.igx-grid-toolbar__title` binding.
             *
             * @hidden
             * @internal
             */
            this.cssClass = 'igx-grid-toolbar__title';
        }
        return IgxGridToolbarTitleDirective;
    }());
    IgxGridToolbarTitleDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[igxGridToolbarTitle],igx-grid-toolbar-title' },] }
    ];
    IgxGridToolbarTitleDirective.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-grid-toolbar__title',] }]
    };
    /**
     * Provides a way to template the action portion of the toolbar in the grid.
     *
     * @igxModule IgxGridToolbarModule
     * @igxParent IgxGridToolbarComponent
     *
     * @example
     * ```html
     * <igx-grid-toolbar-actions>
     *  <some-toolbar-action-here />
     * </igx-grid-toolbar-actions>
     * ```
     */
    var IgxGridToolbarActionsDirective = /** @class */ (function () {
        function IgxGridToolbarActionsDirective() {
            /**
             * Host `class.igx-grid-toolbar__actions` binding.
             *
             * @hidden
             * @internal
             */
            this.cssClass = 'igx-grid-toolbar__actions';
        }
        return IgxGridToolbarActionsDirective;
    }());
    IgxGridToolbarActionsDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[igxGridToolbarActions],igx-grid-toolbar-actions' },] }
    ];
    IgxGridToolbarActionsDirective.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-grid-toolbar__actions',] }]
    };
    var IgxGridToolbarDirective = /** @class */ (function () {
        function IgxGridToolbarDirective(template) {
            this.template = template;
        }
        return IgxGridToolbarDirective;
    }());
    IgxGridToolbarDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[igxGridToolbar]' },] }
    ];
    IgxGridToolbarDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };

    /**
     * Provides a context-aware container component for UI operations for the grid components.
     *
     * @igxModule IgxGridToolbarModule
     *
     */
    var IgxGridToolbarComponent = /** @class */ (function (_super) {
        __extends(IgxGridToolbarComponent, _super);
        function IgxGridToolbarComponent(_displayDensityOptions, api, iconService, element) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this._displayDensityOptions = _displayDensityOptions;
            _this.api = api;
            _this.iconService = iconService;
            _this.element = element;
            /**
             * When enabled, shows the indeterminate progress bar.
             *
             * @remarks
             * By default this will be toggled, when the default exporter component is present
             * and an exporting is in progress.
             */
            _this.showProgress = false;
            /**
             * @hidden
             * @internal
             */
            _this.defaultStyle = true;
            /** @hidden @internal */
            _this.width = null;
            _this.iconService.addSvgIconFromText(materialIconsExtended.pinLeft.name, materialIconsExtended.pinLeft.value, 'imx-icons');
            _this.iconService.addSvgIconFromText(materialIconsExtended.unpinLeft.name, materialIconsExtended.unpinLeft.value, 'imx-icons');
            return _this;
        }
        Object.defineProperty(IgxGridToolbarComponent.prototype, "grid", {
            /**
             * Gets/sets the grid component for the toolbar component.
             *
             * @remarks
             * Usually you should not set this property in the context of the default grid/tree grid.
             * The only grids that demands this to be set are the hierarchical child grids. For additional
             * information check the toolbar topic.
             */
            get: function () {
                if (this._grid) {
                    return this._grid;
                }
                return this.api.grid;
            },
            set: function (value) {
                this._grid = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridToolbarComponent.prototype, "nativeElement", {
            /** Returns the native DOM element of the toolbar component */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridToolbarComponent.prototype, "cosyStyle", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.displayDensity === 'cosy';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridToolbarComponent.prototype, "compactStyle", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.displayDensity === 'compact';
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden @internal */
        IgxGridToolbarComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.grid.rendered$.pipe(operators.first()).subscribe(function () { return _this.width = _this.grid.outerWidth; });
            this.sub = this.grid.resizeNotify.subscribe(function () { return _this.width = _this.grid.outerWidth; });
        };
        /** @hidden @internal */
        IgxGridToolbarComponent.prototype.ngOnDestroy = function () {
            var _a;
            (_a = this.sub) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        };
        return IgxGridToolbarComponent;
    }(DisplayDensityBase));
    IgxGridToolbarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-grid-toolbar',
                    template: "<ng-template #title>\n    <ng-content select=\"[igxGridToolbarTitle],igx-grid-toolbar-title\"></ng-content>\n</ng-template>\n<igx-grid-toolbar-title *ngIf=\"!hasTitle\">{{ grid.toolbarTitle }}</igx-grid-toolbar-title>\n<ng-container *ngTemplateOutlet=\"title\"></ng-container>\n\n<div class=\"igx-grid-toolbar__custom-content\">\n    <ng-content></ng-content>\n</div>\n\n<ng-template #actions>\n    <ng-content select=\"[igxGridToolbarActions],igx-grid-toolbar-actions\"></ng-content>\n</ng-template>\n<igx-grid-toolbar-actions *ngIf=\"!hasActions\">\n    <igx-grid-toolbar-advanced-filtering *ngIf=\"grid.allowAdvancedFiltering\"></igx-grid-toolbar-advanced-filtering>\n    <igx-grid-toolbar-hiding *ngIf=\"grid.columnHiding\"></igx-grid-toolbar-hiding>\n    <igx-grid-toolbar-pinning *ngIf=\"grid.columnPinning\"></igx-grid-toolbar-pinning>\n    <igx-grid-toolbar-exporter *ngIf=\"grid.exportExcel || grid.exportCsv\" (exportStarted)=\"showProgress = true\" (exportEnded)=\"showProgress = false\">\n    </igx-grid-toolbar-exporter>\n</igx-grid-toolbar-actions>\n<ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n\n<div class=\"igx-grid-toolbar__progress-bar\" *ngIf=\"showProgress\">\n    <igx-linear-bar [indeterminate]=\"true\"></igx-linear-bar>\n</div>\n"
                },] }
    ];
    IgxGridToolbarComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] },
        { type: GridBaseAPIService },
        { type: IgxIconService },
        { type: i0.ElementRef }
    ]; };
    IgxGridToolbarComponent.propDecorators = {
        showProgress: [{ type: i0.Input }],
        grid: [{ type: i0.Input }],
        hasTitle: [{ type: i0.ContentChild, args: [IgxGridToolbarTitleDirective,] }],
        hasActions: [{ type: i0.ContentChild, args: [IgxGridToolbarActionsDirective,] }],
        defaultStyle: [{ type: i0.HostBinding, args: ['class.igx-grid-toolbar',] }],
        cosyStyle: [{ type: i0.HostBinding, args: ['class.igx-grid-toolbar--cosy',] }],
        compactStyle: [{ type: i0.HostBinding, args: ['class.igx-grid-toolbar--compact',] }],
        width: [{ type: i0.HostBinding, args: ['style.max-width.px',] }, { type: i0.HostBinding, args: ['style.flex-basis.px',] }]
    };

    /** @hidden @internal */
    var IgxRowEditTemplateDirective = /** @class */ (function () {
        function IgxRowEditTemplateDirective() {
        }
        return IgxRowEditTemplateDirective;
    }());
    IgxRowEditTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxRowEdit]'
                },] }
    ];
    /** @hidden @internal */
    var IgxRowEditTextDirective = /** @class */ (function () {
        function IgxRowEditTextDirective() {
        }
        return IgxRowEditTextDirective;
    }());
    IgxRowEditTextDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxRowEditText]'
                },] }
    ];
    /** @hidden @internal */
    var IgxRowEditActionsDirective = /** @class */ (function () {
        function IgxRowEditActionsDirective() {
        }
        return IgxRowEditActionsDirective;
    }());
    IgxRowEditActionsDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxRowEditActions]'
                },] }
    ];
    // TODO: Refactor circular ref, deps and logic
    /** @hidden @internal */
    var IgxRowEditTabStopDirective = /** @class */ (function () {
        function IgxRowEditTabStopDirective(api, element) {
            this.api = api;
            this.element = element;
        }
        Object.defineProperty(IgxRowEditTabStopDirective.prototype, "grid", {
            get: function () {
                return this.api.grid;
            },
            enumerable: false,
            configurable: true
        });
        IgxRowEditTabStopDirective.prototype.handleTab = function (event) {
            event.stopPropagation();
            if ((this.grid.rowEditTabs.last === this && !event.shiftKey) ||
                (this.grid.rowEditTabs.first === this && event.shiftKey)) {
                this.move(event);
            }
        };
        IgxRowEditTabStopDirective.prototype.handleEscape = function (event) {
            this.grid.endEdit(false, event);
            this.grid.tbody.nativeElement.focus();
        };
        IgxRowEditTabStopDirective.prototype.handleEnter = function (event) {
            event.stopPropagation();
        };
        /**
         * Moves focus to first/last editable cell in the editable row and put the cell in edit mode.
         * If cell is out of view first scrolls to the cell
         *
         * @param event keyboard event containing information about whether SHIFT key was pressed
         */
        IgxRowEditTabStopDirective.prototype.move = function (event) {
            var _this = this;
            event.preventDefault();
            this.currentCellIndex = event.shiftKey ? this.grid.lastEditableColumnIndex : this.grid.firstEditableColumnIndex;
            this.grid.navigation.activeNode.row = this.grid.rowInEditMode.index;
            this.grid.navigation.activeNode.column = this.currentCellIndex;
            this.grid.navigateTo(this.grid.rowInEditMode.index, this.currentCellIndex, function (obj) {
                obj.target.activate(event);
                _this.grid.cdr.detectChanges();
            });
        };
        return IgxRowEditTabStopDirective;
    }());
    IgxRowEditTabStopDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: "[igxRowEditTabStop]"
                },] }
    ];
    IgxRowEditTabStopDirective.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: i0.ElementRef }
    ]; };
    IgxRowEditTabStopDirective.propDecorators = {
        handleTab: [{ type: i0.HostListener, args: ['keydown.Tab', ["$event"],] }, { type: i0.HostListener, args: ['keydown.Shift.Tab', ["$event"],] }],
        handleEscape: [{ type: i0.HostListener, args: ['keydown.Escape', ["$event"],] }],
        handleEnter: [{ type: i0.HostListener, args: ['keydown.Enter', ['$event'],] }]
    };

    /** @hidden */
    var IgxGridNavigationService = /** @class */ (function () {
        function IgxGridNavigationService() {
            this._activeNode = {};
            this.lastActiveNode = {};
            this.pendingNavigation = false;
        }
        Object.defineProperty(IgxGridNavigationService.prototype, "activeNode", {
            get: function () {
                return this._activeNode;
            },
            set: function (value) {
                this._activeNode = value;
            },
            enumerable: false,
            configurable: true
        });
        IgxGridNavigationService.prototype.handleNavigation = function (event) {
            var _this = this;
            var key = event.key.toLowerCase();
            if (this.grid.crudService.cell && NAVIGATION_KEYS.has(key)) {
                return;
            }
            if (event.repeat && SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) {
                event.preventDefault();
            }
            if (event.repeat) {
                setTimeout(function () { return _this.dispatchEvent(event); }, 1);
            }
            else {
                this.dispatchEvent(event);
            }
        };
        IgxGridNavigationService.prototype.dispatchEvent = function (event) {
            var _this = this;
            var key = event.key.toLowerCase();
            if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) &&
                !this.grid.crudService.rowEditingBlocked && !this.grid.rowInEditMode) {
                return;
            }
            var shift = event.shiftKey;
            var ctrl = event.ctrlKey;
            if (NAVIGATION_KEYS.has(key) && this.pendingNavigation) {
                event.preventDefault();
                return;
            }
            var type = this.isDataRow(this.activeNode.row) ? 'dataCell' :
                this.isDataRow(this.activeNode.row, true) ? 'summaryCell' : 'groupRow';
            if (this.emitKeyDown(type, this.activeNode.row, event)) {
                return;
            }
            if (event.altKey) {
                this.handleAlt(key, event);
                return;
            }
            if ([' ', 'spacebar', 'space'].indexOf(key) === -1) {
                this.grid.selectionService.keyboardStateOnKeydown(this.activeNode, shift, shift && key === 'tab');
            }
            var position = this.getNextPosition(this.activeNode.row, this.activeNode.column, key, shift, ctrl, event);
            if (NAVIGATION_KEYS.has(key)) {
                event.preventDefault();
                this.navigateInBody(position.rowIndex, position.colIndex, function (obj) {
                    obj.target.activate(event);
                    _this.grid.cdr.detectChanges();
                });
            }
            this.grid.cdr.detectChanges();
        };
        IgxGridNavigationService.prototype.summaryNav = function (event) {
            if (this.grid.hasSummarizedColumns) {
                this.horizontalNav(event, event.key.toLowerCase(), this.grid.dataView.length, 'summaryCell');
            }
        };
        IgxGridNavigationService.prototype.headerNavigation = function (event) {
            var key = event.key.toLowerCase();
            if (!HEADER_KEYS.has(key)) {
                return;
            }
            event.preventDefault();
            var ctrl = event.ctrlKey;
            var shift = event.shiftKey;
            var alt = event.altKey;
            this.performHeaderKeyCombination(this.currentActiveColumn, key, shift, ctrl, alt, event);
            if (shift || alt || (ctrl && (key.includes('down') || key.includes('down')))) {
                return;
            }
            if (this.grid.hasColumnGroups) {
                this.handleMCHeaderNav(key, ctrl);
            }
            else {
                this.horizontalNav(event, key, -1, 'headerCell');
            }
        };
        IgxGridNavigationService.prototype.focusTbody = function (event) {
            var _this = this;
            var _a;
            var gridRows = (_a = this.grid.verticalScrollContainer.totalItemCount) !== null && _a !== void 0 ? _a : this.grid.dataView.length;
            if (gridRows < 1) {
                this.activeNode = null;
                return;
            }
            if (!this.activeNode || !Object.keys(this.activeNode).length || this.activeNode.row < 0 || this.activeNode.row > gridRows - 1) {
                var hasLastActiveNode = Object.keys(this.lastActiveNode).length;
                var shouldClearSelection = hasLastActiveNode && (this.lastActiveNode.row < 0 || this.lastActiveNode.row > gridRows - 1);
                this.setActiveNode(this.lastActiveNode.row >= 0 && this.lastActiveNode.row < gridRows ?
                    this.firstVisibleNode(this.lastActiveNode.row) : this.firstVisibleNode());
                if (shouldClearSelection || (this.grid.cellSelection !== GridSelectionMode.multiple)) {
                    this.grid.clearCellSelection();
                    this.grid.navigateTo(this.activeNode.row, this.activeNode.column, function (obj) {
                        var _a;
                        (_a = obj.target) === null || _a === void 0 ? void 0 : _a.activate(event);
                        _this.grid.cdr.detectChanges();
                    });
                }
                else {
                    var range = { rowStart: this.activeNode.row, rowEnd: this.activeNode.row,
                        columnStart: this.activeNode.column, columnEnd: this.activeNode.column };
                    this.grid.selectRange(range);
                    this.grid.notifyChanges();
                }
            }
        };
        IgxGridNavigationService.prototype.focusFirstCell = function (header) {
            if (header === void 0) { header = true; }
            if ((header || this.grid.dataView.length) && this.activeNode &&
                (this.activeNode.row === -1 || this.activeNode.row === this.grid.dataView.length ||
                    (!header && !this.grid.hasSummarizedColumns))) {
                return;
            }
            var shouldScrollIntoView = this.lastActiveNode && (header && this.lastActiveNode.row !== -1) ||
                (!header && this.lastActiveNode.row !== this.grid.dataView.length);
            this.setActiveNode(this.firstVisibleNode(header ? -1 : this.grid.dataView.length));
            if (shouldScrollIntoView) {
                this.performHorizontalScrollToCell(this.activeNode.column);
            }
        };
        IgxGridNavigationService.prototype.isColumnFullyVisible = function (columnIndex) {
            if (columnIndex < 0 || this.isColumnPinned(columnIndex, this.forOfDir())) {
                return true;
            }
            var index = this.getColumnUnpinnedIndex(columnIndex);
            var width = this.forOfDir().getColumnScrollLeft(index + 1) - this.forOfDir().getColumnScrollLeft(index);
            if (this.displayContainerWidth < width && this.displayContainerScrollLeft === this.forOfDir().getColumnScrollLeft(index)) {
                return true;
            }
            return this.displayContainerWidth >= this.forOfDir().getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft &&
                this.displayContainerScrollLeft <= this.forOfDir().getColumnScrollLeft(index);
        };
        IgxGridNavigationService.prototype.shouldPerformHorizontalScroll = function (visibleColIndex, rowIndex) {
            if (rowIndex === void 0) { rowIndex = -1; }
            if (visibleColIndex < 0 || visibleColIndex > this.grid.visibleColumns.length - 1) {
                return false;
            }
            if (rowIndex < 0 || rowIndex > this.grid.dataView.length - 1) {
                return !this.isColumnFullyVisible(visibleColIndex);
            }
            var row = this.grid.dataView[rowIndex];
            return row.expression || row.detailsData ? false : !this.isColumnFullyVisible(visibleColIndex);
        };
        IgxGridNavigationService.prototype.shouldPerformVerticalScroll = function (targetRowIndex, visibleColIndex) {
            if (this.grid.isRecordPinnedByViewIndex(targetRowIndex)) {
                return false;
            }
            var scrollRowIndex = this.grid.hasPinnedRecords && this.grid.isRowPinningToTop ?
                targetRowIndex - this.grid.pinnedDataView.length : targetRowIndex;
            var targetRow = this.getRowElementByIndex(targetRowIndex);
            var rowHeight = this.grid.verticalScrollContainer.getSizeAt(scrollRowIndex);
            var containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
            var endTopOffset = targetRow ? targetRow.offsetTop + rowHeight + this.containerTopOffset : containerHeight + rowHeight;
            // this is workaround: endTopOffset - containerHeight > 5 and should be replaced with: containerHeight < endTopOffset
            // when the page is zoomed the grid does not scroll the row completely in the view
            return !targetRow || targetRow.offsetTop < Math.abs(this.containerTopOffset)
                || containerHeight && endTopOffset - containerHeight > 5;
        };
        IgxGridNavigationService.prototype.performVerticalScrollToCell = function (rowIndex, visibleColIndex, cb) {
            var _this = this;
            if (visibleColIndex === void 0) { visibleColIndex = -1; }
            if (!this.shouldPerformVerticalScroll(rowIndex, visibleColIndex)) {
                return;
            }
            this.pendingNavigation = true;
            // Only for top pinning we need to subtract pinned count because virtualization indexing doesn't count pinned rows.
            var scrollRowIndex = this.grid.hasPinnedRecords && this.grid.isRowPinningToTop ?
                rowIndex - this.grid.pinnedDataView.length : rowIndex;
            this.grid.verticalScrollContainer.scrollTo(scrollRowIndex);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(operators.first()).subscribe(function () {
                _this.pendingNavigation = false;
                if (cb) {
                    cb();
                }
            });
        };
        IgxGridNavigationService.prototype.performHorizontalScrollToCell = function (visibleColumnIndex, cb) {
            var _this = this;
            if (this.grid.rowList < 1 && this.grid.summariesRowList.length < 1 && this.grid.hasColumnGroups) {
                var column = this.grid.getColumnByVisibleIndex(visibleColumnIndex);
                while (column.parent) {
                    column = column.parent;
                }
                visibleColumnIndex = this.forOfDir().igxForOf.indexOf(column);
            }
            if (!this.shouldPerformHorizontalScroll(visibleColumnIndex)) {
                return;
            }
            this.pendingNavigation = true;
            this.grid.parentVirtDir.onChunkLoad
                .pipe(operators.first())
                .subscribe(function () {
                _this.pendingNavigation = false;
                if (cb) {
                    cb();
                }
            });
            this.forOfDir().scrollTo(this.getColumnUnpinnedIndex(visibleColumnIndex));
        };
        IgxGridNavigationService.prototype.isDataRow = function (rowIndex, includeSummary) {
            if (includeSummary === void 0) { includeSummary = false; }
            if (rowIndex < 0 || rowIndex > this.grid.dataView.length - 1) {
                return false;
            }
            var curRow = this.grid.dataView[rowIndex];
            return curRow && !this.grid.isGroupByRecord(curRow) && !this.grid.isDetailRecord(curRow)
                && !curRow.childGridsData && (includeSummary || !curRow.summaries);
        };
        IgxGridNavigationService.prototype.isGroupRow = function (rowIndex) {
            if (rowIndex < 0 || rowIndex > this.grid.dataView.length - 1) {
                return false;
            }
            var curRow = this.grid.dataView[rowIndex];
            return curRow && this.grid.isGroupByRecord(curRow);
        };
        IgxGridNavigationService.prototype.setActiveNode = function (activeNode) {
            if (!this.isActiveNodeChanged(activeNode)) {
                return;
            }
            if (!this.activeNode) {
                this.activeNode = activeNode;
            }
            Object.assign(this.activeNode, activeNode);
            var currRow = this.grid.dataView[activeNode.row];
            var type = activeNode.row < 0 ? 'headerCell' :
                this.isDataRow(activeNode.row) ? 'dataCell' :
                    currRow && this.grid.isGroupByRecord(currRow) ? 'groupRow' :
                        currRow && this.grid.isDetailRecord(currRow) ? 'masterDetailRow' : 'summaryCell';
            var args = {
                row: this.activeNode.row,
                column: this.activeNode.column,
                level: this.activeNode.level,
                tag: type
            };
            this.grid.activeNodeChange.emit(args);
        };
        IgxGridNavigationService.prototype.isActiveNodeChanged = function (activeNode) {
            var e_1, _e;
            var _this = this;
            var isChanged = false;
            var checkInnerProp = function (aciveNode, prop) {
                var e_2, _e;
                if (!aciveNode) {
                    isChanged = true;
                    return;
                }
                props = Object.getOwnPropertyNames(aciveNode);
                try {
                    for (var props_2 = __values(props), props_2_1 = props_2.next(); !props_2_1.done; props_2_1 = props_2.next()) {
                        var propName = props_2_1.value;
                        if (_this.activeNode[prop][propName] !== aciveNode[propName]) {
                            isChanged = true;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (props_2_1 && !props_2_1.done && (_e = props_2.return)) _e.call(props_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            };
            if (!this.activeNode) {
                return isChanged = true;
            }
            var props = Object.getOwnPropertyNames(activeNode);
            try {
                for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
                    var propName = props_1_1.value;
                    if (!!this.activeNode[propName] && typeof this.activeNode[propName] === 'object') {
                        checkInnerProp(activeNode[propName], propName);
                    }
                    else if (this.activeNode[propName] !== activeNode[propName]) {
                        isChanged = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (props_1_1 && !props_1_1.done && (_e = props_1.return)) _e.call(props_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return isChanged;
        };
        IgxGridNavigationService.prototype.getNextPosition = function (rowIndex, colIndex, key, shift, ctrl, event) {
            var _this = this;
            if (!this.isDataRow(rowIndex, true) && (key.indexOf('down') < 0 || key.indexOf('up') < 0) && ctrl) {
                return { rowIndex: rowIndex, colIndex: colIndex };
            }
            switch (key) {
                case 'pagedown':
                case 'pageup':
                    event.preventDefault();
                    if (key === 'pagedown') {
                        this.grid.verticalScrollContainer.scrollNextPage();
                    }
                    else {
                        this.grid.verticalScrollContainer.scrollPrevPage();
                    }
                    var editCell_1 = this.grid.crudService.cell;
                    this.grid.verticalScrollContainer.onChunkLoad
                        .pipe(operators.first()).subscribe(function () {
                        if (editCell_1 && _this.grid.rowList.map(function (r) { return r.index; }).indexOf(editCell_1.rowIndex) < 0) {
                            _this.grid.tbody.nativeElement.focus({ preventScroll: true });
                        }
                    });
                    break;
                case 'tab':
                    this.handleEditing(shift, event);
                    break;
                case 'end':
                    rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row;
                    colIndex = this.lastColumnIndex;
                    break;
                case 'home':
                    rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row;
                    colIndex = 0;
                    break;
                case 'arrowleft':
                case 'left':
                    colIndex = ctrl ? 0 : this.activeNode.column - 1;
                    break;
                case 'arrowright':
                case 'right':
                    colIndex = ctrl ? this.lastColumnIndex : this.activeNode.column + 1;
                    break;
                case 'arrowup':
                case 'up':
                    if (ctrl && !this.isDataRow(rowIndex) || (this.grid.rowEditable && this.grid.crudService.rowEditingBlocked)) {
                        break;
                    }
                    colIndex = this.activeNode.column !== undefined ? this.activeNode.column : 0;
                    rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row - 1;
                    break;
                case 'arrowdown':
                case 'down':
                    if ((ctrl && !this.isDataRow(rowIndex)) || (this.grid.rowEditable && this.grid.crudService.rowEditingBlocked)) {
                        break;
                    }
                    colIndex = this.activeNode.column !== undefined ? this.activeNode.column : 0;
                    rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row + 1;
                    break;
                case 'enter':
                case 'f2':
                    var cell = this.grid.getCellByColumnVisibleIndex(this.activeNode.row, this.activeNode.column);
                    if (!this.isDataRow(rowIndex) || !cell.editable) {
                        break;
                    }
                    this.grid.crudService.enterEditMode(cell, event);
                    break;
                case 'escape':
                case 'esc':
                    if (!this.isDataRow(rowIndex)) {
                        break;
                    }
                    if (this.grid.crudService.isInCompositionMode) {
                        return;
                    }
                    if (this.grid.crudService.cellInEditMode || this.grid.crudService.rowInEditMode) {
                        this.grid.endEdit(false, event);
                        if (isEdge()) {
                            this.grid.cdr.detectChanges();
                        }
                        this.grid.tbody.nativeElement.focus();
                    }
                    break;
                case ' ':
                case 'spacebar':
                case 'space':
                    var rowObj = this.grid.getRowByIndex(this.activeNode.row);
                    if (this.grid.isRowSelectable && rowObj) {
                        if (this.isDataRow(rowIndex)) {
                            if (rowObj.selected) {
                                this.grid.selectionService.deselectRow(rowObj.rowID, event);
                            }
                            else {
                                this.grid.selectionService.selectRowById(rowObj.rowID, false, event);
                            }
                        }
                        if (this.isGroupRow(rowIndex)) {
                            rowObj.onGroupSelectorClick(event);
                        }
                    }
                    break;
                default:
                    return;
            }
            return { rowIndex: rowIndex, colIndex: colIndex };
        };
        IgxGridNavigationService.prototype.horizontalNav = function (event, key, rowIndex, tag) {
            var ctrl = event.ctrlKey;
            if (!HORIZONTAL_NAV_KEYS.has(event.key.toLowerCase())) {
                return;
            }
            event.preventDefault();
            this.activeNode.row = rowIndex;
            if (rowIndex > 0) {
                if (this.emitKeyDown('summaryCell', this.activeNode.row, event)) {
                    return;
                }
            }
            var newActiveNode = {
                column: this.activeNode.column,
                mchCache: {
                    level: this.activeNode.level,
                    visibleIndex: this.activeNode.column
                }
            };
            if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {
                newActiveNode.column = ctrl || key === 'home' ? 0 : this.activeNode.column - 1;
            }
            if ((key.includes('right') || key === 'end') && this.activeNode.column < this.lastColumnIndex) {
                newActiveNode.column = ctrl || key === 'end' ? this.lastColumnIndex : this.activeNode.column + 1;
            }
            if (tag === 'headerCell') {
                var column = this.grid.getColumnByVisibleIndex(newActiveNode.column);
                newActiveNode.mchCache.level = column.level;
                newActiveNode.mchCache.visibleIndex = column.visibleIndex;
            }
            this.setActiveNode({ row: this.activeNode.row, column: newActiveNode.column, mchCache: newActiveNode.mchCache });
            this.performHorizontalScrollToCell(this.activeNode.column);
        };
        Object.defineProperty(IgxGridNavigationService.prototype, "lastColumnIndex", {
            get: function () {
                return Math.max.apply(Math, __spread(this.grid.visibleColumns.map(function (col) { return col.visibleIndex; })));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridNavigationService.prototype, "displayContainerWidth", {
            get: function () {
                return Math.round(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridNavigationService.prototype, "displayContainerScrollLeft", {
            get: function () {
                return Math.ceil(this.grid.headerContainer.scrollPosition);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridNavigationService.prototype, "containerTopOffset", {
            get: function () {
                return parseInt(this.grid.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            },
            enumerable: false,
            configurable: true
        });
        IgxGridNavigationService.prototype.getColumnUnpinnedIndex = function (visibleColumnIndex) {
            var column = this.grid.unpinnedColumns.find(function (col) { return !col.columnGroup && col.visibleIndex === visibleColumnIndex; });
            return this.grid.pinnedColumns.length ? this.grid.unpinnedColumns.filter(function (c) { return !c.columnGroup; }).indexOf(column) :
                visibleColumnIndex;
        };
        IgxGridNavigationService.prototype.forOfDir = function () {
            var forOfDir = this.grid.dataRowList.length > 0 ? this.grid.dataRowList.first.virtDirRow : this.grid.summariesRowList.length ?
                this.grid.summariesRowList.first.virtDirRow : this.grid.headerContainer;
            return forOfDir;
        };
        IgxGridNavigationService.prototype.handleAlt = function (key, event) {
            event.preventDefault();
            var row = this.grid.getRowByIndex(this.activeNode.row);
            if (!(this.isToggleKey(key) || this.isAddKey(key)) || !row) {
                return;
            }
            if (this.isAddKey(key)) {
                if (!this.grid.rowEditable) {
                    console.warn('The grid must be in row edit mode to perform row adding!');
                    return;
                }
                if (event.shiftKey && row.treeRow !== undefined) {
                    this.grid.beginAddRowByIndex(row.rowID, row.index, true, event);
                }
                else if (!event.shiftKey) {
                    this.grid.beginAddRowByIndex(row.rowID, row.index, false, event);
                }
            }
            else if (!row.expanded && ROW_EXPAND_KEYS.has(key)) {
                if (row.rowID === undefined) {
                    row.toggle();
                }
                else {
                    this.grid.gridAPI.set_row_expansion_state(row.rowID, true, event);
                }
            }
            else if (row.expanded && ROW_COLLAPSE_KEYS.has(key)) {
                if (row.rowID === undefined) {
                    row.toggle();
                }
                else {
                    this.grid.gridAPI.set_row_expansion_state(row.rowID, false, event);
                }
            }
            this.grid.notifyChanges();
        };
        IgxGridNavigationService.prototype.handleEditing = function (shift, event) {
            var _this = this;
            var _a;
            var next = shift ? this.grid.getPreviousCell(this.activeNode.row, this.activeNode.column, function (col) { return col.editable; }) :
                this.grid.getNextCell(this.activeNode.row, this.activeNode.column, function (col) { return col.editable; });
            if (!this.grid.rowInEditMode && this.isActiveNode(next.rowIndex, next.visibleColumnIndex)) {
                this.grid.endEdit(true, event);
                this.grid.tbody.nativeElement.focus();
                return;
            }
            event.preventDefault();
            if ((this.grid.rowInEditMode && this.grid.rowEditTabs.length) &&
                (this.activeNode.row !== next.rowIndex || this.isActiveNode(next.rowIndex, next.visibleColumnIndex))) {
                if ((_a = this.grid.crudService.row) === null || _a === void 0 ? void 0 : _a.isAddRow) {
                    this.grid.gridAPI.submit_add_value(event);
                    var row = this.grid.rowList.find(function (r) { return r.rowID === _this.grid.crudService.row.id; });
                    row.rowData = this.grid.crudService.row.data;
                }
                else {
                    this.grid.gridAPI.submit_value(event);
                }
                if (shift) {
                    this.grid.rowEditTabs.last.element.nativeElement.focus();
                }
                else {
                    this.grid.rowEditTabs.first.element.nativeElement.focus();
                }
                return;
            }
            if (this.grid.rowInEditMode && !this.grid.rowEditTabs.length) {
                if (shift && next.rowIndex === this.activeNode.row && next.visibleColumnIndex === this.activeNode.column) {
                    next.visibleColumnIndex = this.grid.lastEditableColumnIndex;
                }
                else if (!shift && next.rowIndex === this.activeNode.row && next.visibleColumnIndex === this.activeNode.column) {
                    next.visibleColumnIndex = this.grid.firstEditableColumnIndex;
                }
                else {
                    next.rowIndex = this.activeNode.row;
                }
            }
            this.navigateInBody(next.rowIndex, next.visibleColumnIndex, function (obj) {
                obj.target.activate(event);
                _this.grid.cdr.detectChanges();
            });
        };
        IgxGridNavigationService.prototype.navigateInBody = function (rowIndex, visibleColIndex, cb) {
            if (cb === void 0) { cb = null; }
            if (!this.isValidPosition(rowIndex, visibleColIndex) || this.isActiveNode(rowIndex, visibleColIndex)) {
                return;
            }
            this.grid.navigateTo(rowIndex, visibleColIndex, cb);
        };
        IgxGridNavigationService.prototype.emitKeyDown = function (type, rowIndex, event) {
            var _this = this;
            var _a, _b;
            var row = this.grid.summariesRowList.toArray().concat(this.grid.rowList.toArray()).find(function (r) { return r.index === rowIndex; });
            if (!row) {
                return;
            }
            var target = type === 'groupRow' ? row :
                type === 'dataCell' ? (_a = row.cells) === null || _a === void 0 ? void 0 : _a.find(function (c) { return c.visibleColumnIndex === _this.activeNode.column; }) : (_b = row.summaryCells) === null || _b === void 0 ? void 0 : _b.find(function (c) { return c.visibleColumnIndex === _this.activeNode.column; });
            var keydownArgs = { targetType: type, event: event, cancel: false, target: target };
            this.grid.onGridKeydown.emit(keydownArgs);
            if (keydownArgs.cancel && type === 'dataCell') {
                this.grid.selectionService.clear();
                this.grid.selectionService.keyboardState.active = true;
                return keydownArgs.cancel;
            }
        };
        IgxGridNavigationService.prototype.isColumnPinned = function (columnIndex, forOfDir) {
            var _a;
            var horizontalScroll = forOfDir.getScroll();
            return (!horizontalScroll.clientWidth || ((_a = this.grid.getColumnByVisibleIndex(columnIndex)) === null || _a === void 0 ? void 0 : _a.pinned));
        };
        IgxGridNavigationService.prototype.findFirstDataRowIndex = function () {
            var _this = this;
            return this.grid.dataView.findIndex(function (rec) { return !_this.grid.isGroupByRecord(rec) && !_this.grid.isDetailRecord(rec) && !rec.summaries; });
        };
        IgxGridNavigationService.prototype.findLastDataRowIndex = function () {
            if (this.grid.totalItemCount) {
                return this.grid.totalItemCount - 1;
            }
            var i = this.grid.dataView.length;
            while (i--) {
                if (this.isDataRow(i)) {
                    return i;
                }
            }
        };
        IgxGridNavigationService.prototype.getRowElementByIndex = function (index) {
            var _a;
            if (this.grid.hasDetails) {
                var detail = this.grid.nativeElement.querySelector("[detail=\"true\"][data-rowindex=\"" + index + "\"]");
                if (detail) {
                    return detail;
                }
            }
            return (_a = this.grid.rowList.toArray().concat(this.grid.summariesRowList.toArray()).find(function (r) { return r.index === index; })) === null || _a === void 0 ? void 0 : _a.nativeElement;
        };
        IgxGridNavigationService.prototype.isValidPosition = function (rowIndex, colIndex) {
            var _a;
            var length = (_a = this.grid.totalItemCount) !== null && _a !== void 0 ? _a : this.grid.dataView.length;
            if (rowIndex < 0 || colIndex < 0 || length - 1 < rowIndex || this.lastColumnIndex < colIndex) {
                return false;
            }
            return this.activeNode.column !== colIndex && !this.isDataRow(rowIndex, true) ? false : true;
        };
        IgxGridNavigationService.prototype.performHeaderKeyCombination = function (column, key, shift, ctrl, alt, event) {
            var _a;
            var direction = (_a = this.grid.sortingExpressions.find(function (expr) { return expr.fieldName === column.field; })) === null || _a === void 0 ? void 0 : _a.dir;
            if (ctrl && key.includes('up') && column.sortable && !column.columnGroup) {
                direction = direction === exports.SortingDirection.Asc ? exports.SortingDirection.None : exports.SortingDirection.Asc;
                this.grid.sort({ fieldName: column.field, dir: direction, ignoreCase: false });
                return;
            }
            if (ctrl && key.includes('down') && column.sortable && !column.columnGroup) {
                direction = direction === exports.SortingDirection.Desc ? exports.SortingDirection.None : exports.SortingDirection.Desc;
                this.grid.sort({ fieldName: column.field, dir: direction, ignoreCase: false });
                return;
            }
            if (shift && alt && this.isToggleKey(key) && !column.columnGroup && column.groupable) {
                direction = direction ? exports.SortingDirection.Desc : exports.SortingDirection.Asc;
                if (key.includes('right')) {
                    this.grid.groupBy({ fieldName: column.field, dir: direction, ignoreCase: false });
                }
                else {
                    this.grid.clearGrouping(column.field);
                }
                this.activeNode.column = key.includes('right') && this.grid.hideGroupedColumns &&
                    column.visibleIndex === this.lastColumnIndex ? this.lastColumnIndex - 1 : this.activeNode.column;
                return;
            }
            if (alt && (ROW_EXPAND_KEYS.has(key) || ROW_COLLAPSE_KEYS.has(key))) {
                this.handleMCHExpandCollapse(key, column);
                return;
            }
            if ([' ', 'spacebar', 'space'].indexOf(key) !== -1) {
                this.handleColumnSelection(column, event);
            }
            if (alt && (key === 'l' || key === '¬') && this.grid.allowAdvancedFiltering) {
                this.grid.openAdvancedFilteringDialog();
            }
            if (ctrl && shift && key === 'l' && this.grid.allowFiltering && !column.columnGroup && column.filterable) {
                if (this.grid.filterMode === FilterMode.excelStyleFilter) {
                    var headerEl = this.grid.nativeElement.querySelector(".igx-grid__th--active");
                    this.grid.filteringService.toggleFilterDropdown(headerEl, column, IgxGridExcelStyleFilteringComponent);
                }
                else {
                    this.performHorizontalScrollToCell(column.visibleIndex);
                    this.grid.filteringService.filteredColumn = column;
                    this.grid.filteringService.isFilterRowVisible = true;
                }
            }
        };
        IgxGridNavigationService.prototype.firstVisibleNode = function (rowIndex) {
            var _this = this;
            var _a, _b, _c, _d;
            var colIndex = this.lastActiveNode.column !== undefined ? this.lastActiveNode.column : (_a = this.grid.visibleColumns.sort(function (c1, c2) { return c1.visibleIndex - c2.visibleIndex; })
                .find(function (c) { return _this.isColumnFullyVisible(c.visibleIndex); })) === null || _a === void 0 ? void 0 : _a.visibleIndex;
            var column = this.grid.visibleColumns.find(function (col) { return !col.columnLayout && col.visibleIndex === colIndex; });
            var rowInd = rowIndex ? rowIndex : (_b = this.grid.rowList.find(function (r) { return !_this.shouldPerformVerticalScroll(r.index, colIndex); })) === null || _b === void 0 ? void 0 : _b.index;
            var node = { row: rowInd !== null && rowInd !== void 0 ? rowInd : 0,
                column: (_c = column === null || column === void 0 ? void 0 : column.visibleIndex) !== null && _c !== void 0 ? _c : 0, level: (_d = column === null || column === void 0 ? void 0 : column.level) !== null && _d !== void 0 ? _d : 0,
                mchCache: column ? { level: column.level, visibleIndex: column.visibleIndex } : {}, layout: column && column.columnLayoutChild ? { rowStart: column.rowStart, colStart: column.colStart,
                    rowEnd: column.rowEnd, colEnd: column.colEnd, columnVisibleIndex: column.visibleIndex } : null };
            return node;
        };
        IgxGridNavigationService.prototype.handleMCHeaderNav = function (key, ctrl) {
            var _this = this;
            var newHeaderNode = {
                visibleIndex: this.activeNode.mchCache.visibleIndex,
                level: this.activeNode.mchCache.level
            };
            var activeCol = this.currentActiveColumn;
            var lastGroupIndex = Math.max.apply(Math, __spread(this.grid.visibleColumns.
                filter(function (c) { return c.level <= _this.activeNode.level; }).map(function (col) { return col.visibleIndex; })));
            var nextCol = activeCol;
            if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {
                var index = ctrl || key === 'home' ? 0 : this.activeNode.column - 1;
                nextCol = this.getNextColumnMCH(index);
                newHeaderNode.visibleIndex = nextCol.visibleIndex;
            }
            if ((key.includes('right') || key === 'end') && activeCol.visibleIndex < lastGroupIndex) {
                var nextVIndex = activeCol.children ? Math.max.apply(Math, __spread(activeCol.allChildren.map(function (c) { return c.visibleIndex; }))) + 1 :
                    activeCol.visibleIndex + 1;
                nextCol = ctrl || key === 'end' ? this.getNextColumnMCH(this.lastColumnIndex) : this.getNextColumnMCH(nextVIndex);
                newHeaderNode.visibleIndex = nextCol.visibleIndex;
            }
            if (!ctrl && key.includes('up') && this.activeNode.level > 0) {
                nextCol = activeCol.parent;
                newHeaderNode.level = nextCol.level;
            }
            if (!ctrl && key.includes('down') && activeCol.children) {
                nextCol = activeCol.children.find(function (c) { return c.visibleIndex === newHeaderNode.visibleIndex; }) ||
                    activeCol.children.toArray().sort(function (a, b) { return b.visibleIndex - a.visibleIndex; })
                        .filter(function (col) { return col.visibleIndex < newHeaderNode.visibleIndex; })[0];
                newHeaderNode.level = nextCol.level;
            }
            this.setActiveNode({
                row: this.activeNode.row,
                column: nextCol.visibleIndex,
                level: nextCol.level,
                mchCache: newHeaderNode
            });
            this.performHorizontalScrollToCell(nextCol.visibleIndex);
        };
        IgxGridNavigationService.prototype.handleMCHExpandCollapse = function (key, column) {
            if (!column.children || !column.collapsible) {
                return;
            }
            if (!column.expanded && ROW_EXPAND_KEYS.has(key)) {
                column.expanded = true;
            }
            else if (column.expanded && ROW_COLLAPSE_KEYS.has(key)) {
                column.expanded = false;
            }
        };
        IgxGridNavigationService.prototype.handleColumnSelection = function (column, event) {
            if (!column.selectable || this.grid.columnSelection === GridSelectionMode.none) {
                return;
            }
            var clearSelection = this.grid.columnSelection === GridSelectionMode.single;
            var columnsToSelect = !column.children ? [column.field] :
                column.allChildren.filter(function (c) { return !c.hidden && c.selectable && !c.columnGroup; }).map(function (c) { return c.field; });
            if (column.selected) {
                this.grid.selectionService.deselectColumns(columnsToSelect, event);
            }
            else {
                this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, false, event);
            }
        };
        IgxGridNavigationService.prototype.getNextColumnMCH = function (visibleIndex) {
            var col = this.grid.getColumnByVisibleIndex(visibleIndex);
            var parent = col.parent;
            while (parent && col.level > this.activeNode.mchCache.level) {
                col = col.parent;
                parent = col.parent;
            }
            return col;
        };
        Object.defineProperty(IgxGridNavigationService.prototype, "currentActiveColumn", {
            get: function () {
                var _this = this;
                return this.grid.visibleColumns.find(function (c) { return c.visibleIndex === _this.activeNode.column && c.level === _this.activeNode.level; });
            },
            enumerable: false,
            configurable: true
        });
        IgxGridNavigationService.prototype.isActiveNode = function (rIndex, cIndex) {
            return this.activeNode ? this.activeNode.row === rIndex && this.activeNode.column === cIndex : false;
        };
        IgxGridNavigationService.prototype.isToggleKey = function (key) {
            return ROW_COLLAPSE_KEYS.has(key) || ROW_EXPAND_KEYS.has(key);
        };
        IgxGridNavigationService.prototype.isAddKey = function (key) {
            return ROW_ADD_KEYS.has(key);
        };
        return IgxGridNavigationService;
    }());
    IgxGridNavigationService.decorators = [
        { type: i0.Injectable }
    ];

    /**
     * @hidden
     * @internal
     */
    var IgxColumnResizingService = /** @class */ (function () {
        function IgxColumnResizingService(zone) {
            this.zone = zone;
            /**
             * @hidden
             */
            this.resizeCursor = null;
            /**
             * @hidden
             */
            this.showResizer = false;
        }
        Object.defineProperty(IgxColumnResizingService.prototype, "resizerHeight", {
            /**
             * @hidden
             */
            get: function () {
                var height = this.column.grid.getVisibleContentHeight();
                // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
                var columnHeightMultiplier = 1;
                if (this.column.columnLayoutChild) {
                    columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
                }
                if (this.column.level !== 0) {
                    height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
                }
                return height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnResizingService.prototype, "restrictResizeMin", {
            /**
             * Returns the minimal possible width to which the column can be resized.
             */
            get: function () {
                var actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
                var minWidth = this.column.minWidthPx < actualWidth ? this.column.minWidthPx : actualWidth;
                return actualWidth - minWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnResizingService.prototype, "restrictResizeMax", {
            /**
             * Returns the maximal possible width to which the column can be resized.
             */
            get: function () {
                var actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
                var maxWidth = this.column.maxWidthPx;
                if (this.column.maxWidth) {
                    return maxWidth - actualWidth;
                }
                else {
                    return Number.MAX_SAFE_INTEGER;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Autosizes the column to the longest currently visible cell value, including the header cell.
         * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
         * then the column is sized to its maxWidth.
         */
        IgxColumnResizingService.prototype.autosizeColumnOnDblClick = function () {
            var currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
            var isPercentageWidth = this.column.width && typeof this.column.width === 'string' && this.column.width.indexOf('%') !== -1;
            var size = this.column.getAutoSize();
            var maxWidth = isPercentageWidth ? this.column.maxWidthPercent : this.column.maxWidthPx;
            var minWidth = isPercentageWidth ? this.column.minWidthPercent : this.column.minWidthPx;
            if (this.column.maxWidth && (parseFloat(size) > maxWidth)) {
                size = isPercentageWidth ? maxWidth + '%' : maxWidth + 'px';
            }
            else if (parseFloat(size) < minWidth) {
                size = isPercentageWidth ? minWidth + '%' : minWidth + 'px';
            }
            this.column.width = size;
            this.zone.run(function () { });
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: currentColWidth.toString(),
                newWidth: this.column.width
            });
        };
        /**
         * Resizes the column regaridng to the column minWidth and maxWidth.
         */
        IgxColumnResizingService.prototype.resizeColumn = function (event) {
            this.showResizer = false;
            var diff = event.clientX - this.startResizePos;
            var colWidth = this.column.width;
            var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
            var currentColWidth = parseFloat(colWidth);
            var actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
            currentColWidth = Number.isNaN(currentColWidth) ? parseFloat(actualWidth) : currentColWidth;
            if (this.column.grid.hasColumnLayouts) {
                this.resizeColumnLayoutFor(this.column, diff);
            }
            else if (isPercentageWidth) {
                this._handlePercentageResize(diff, this.column);
            }
            else {
                this._handlePixelResize(diff, this.column);
            }
            this.zone.run(function () { });
            if (currentColWidth !== parseFloat(this.column.width)) {
                this.column.grid.onColumnResized.emit({
                    column: this.column,
                    prevWidth: isPercentageWidth ? currentColWidth + '%' : currentColWidth + 'px',
                    newWidth: this.column.width
                });
            }
            this.isColumnResizing = false;
        };
        IgxColumnResizingService.prototype._handlePixelResize = function (diff, column) {
            var currentColWidth = parseFloat(column.width);
            var colMinWidth = column.minWidthPx;
            var colMaxWidth = column.maxWidthPx;
            if (currentColWidth + diff < colMinWidth) {
                column.width = colMinWidth + 'px';
            }
            else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
                column.width = colMaxWidth + 'px';
            }
            else {
                column.width = (currentColWidth + diff) + 'px';
            }
        };
        IgxColumnResizingService.prototype._handlePercentageResize = function (diff, column) {
            var currentPercentWidth = parseFloat(column.width);
            var gridAvailableSize = column.grid.calcWidth;
            var diffPercentage = (diff / gridAvailableSize) * 100;
            var colMinWidth = column.minWidthPercent;
            var colMaxWidth = column.maxWidthPercent;
            if (currentPercentWidth + diffPercentage < colMinWidth) {
                column.width = colMinWidth + '%';
            }
            else if (colMaxWidth && (currentPercentWidth + diffPercentage > colMaxWidth)) {
                column.width = colMaxWidth + '%';
            }
            else {
                column.width = (currentPercentWidth + diffPercentage) + '%';
            }
        };
        IgxColumnResizingService.prototype.getColMinWidth = function (column) {
            var currentColWidth = parseFloat(column.width);
            var actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
            currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
            var actualMinWidth = parseFloat(column.minWidth);
            return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;
        };
        IgxColumnResizingService.prototype.resizeColumnLayoutFor = function (column, diff) {
            var _this = this;
            var relativeColumns = column.getResizableColUnderEnd();
            var combinedSpan = relativeColumns.reduce(function (acc, col) { return acc + col.spanUsed; }, 0);
            // Resize first those who might reach min/max width
            var columnsToResize = __spread(relativeColumns);
            var updatedDiff = diff;
            var updatedCombinedSpan = combinedSpan;
            var setMinMaxCols = false;
            var _loop_1 = function () {
                // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
                // This is because we can have at first 2 cols reaching min width and then after
                // recalculating the diff there might be 1 more that reaches min width.
                setMinMaxCols = false;
                var newCombinedSpan = updatedCombinedSpan;
                var newColsToResize = [];
                columnsToResize.forEach(function (col) {
                    var currentResizeWidth = parseFloat(col.target.calcWidth);
                    var resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                    var colWidth = col.target.width;
                    var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
                    var minWidth = col.target.minWidthPx;
                    var maxWidth = col.target.maxWidthPx;
                    if (currentResizeWidth + resizeScaled < minWidth) {
                        col.target.width = isPercentageWidth ? col.target.minWidthPercent + '%' : minWidth + 'px';
                        updatedDiff += (currentResizeWidth - minWidth);
                        newCombinedSpan -= col.spanUsed;
                        setMinMaxCols = true;
                    }
                    else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                        col.target.width = isPercentageWidth ? col.target.maxWidthPercent + '%' : col.target.maxWidthPx + 'px';
                        updatedDiff -= (maxWidth - currentResizeWidth);
                        newCombinedSpan -= col.spanUsed;
                        setMinMaxCols = true;
                    }
                    else {
                        // Save new ones that can be resized
                        newColsToResize.push(col);
                    }
                });
                updatedCombinedSpan = newCombinedSpan;
                columnsToResize = newColsToResize;
            };
            do {
                _loop_1();
            } while (setMinMaxCols);
            // Those left that don't reach min/max size resize them normally.
            columnsToResize.forEach(function (col) {
                var resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
                var colWidth = col.target.width;
                var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
                if (isPercentageWidth) {
                    _this._handlePercentageResize(resizeScaled, col.target);
                }
                else {
                    _this._handlePixelResize(resizeScaled, col.target);
                }
            });
        };
        return IgxColumnResizingService;
    }());
    IgxColumnResizingService.decorators = [
        { type: i0.Injectable }
    ];
    IgxColumnResizingService.ctorParameters = function () { return [
        { type: i0.NgZone }
    ]; };

    /**
     * @hidden
     */
    var IgxGridHeaderComponent = /** @class */ (function () {
        function IgxGridHeaderComponent(gridAPI, colResizingService, cdr, elementRef, zone) {
            this.gridAPI = gridAPI;
            this.colResizingService = colResizingService;
            this.cdr = cdr;
            this.elementRef = elementRef;
            this.zone = zone;
            this.hostRole = 'columnheader';
            this.sortDirection = exports.SortingDirection.None;
            this._destroy$ = new rxjs.Subject();
        }
        Object.defineProperty(IgxGridHeaderComponent.prototype, "ariaSelected", {
            /**
             * Returns the `aria-selected` of the header.
             */
            get: function () {
                return this.column.selected;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "styleClasses", {
            get: function () {
                var e_1, _a;
                var defaultClasses = [
                    'igx-grid__th--fw',
                    this.column.headerClasses
                ];
                var classList = {
                    'igx-grid__th': !this.column.columnGroup,
                    asc: this.ascending,
                    desc: this.descending,
                    'igx-grid__th--number': this.column.dataType === DataType.Number,
                    'igx-grid__th--sortable': this.column.sortable,
                    'igx-grid__th--selectable': this.selectable,
                    'igx-grid__th--filtrable': this.column.filterable && this.grid.filteringService.isFilterRowVisible,
                    'igx-grid__th--sorted': this.sorted,
                    'igx-grid__th--selected': this.selected
                };
                try {
                    for (var _b = __values(Object.keys(classList)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var klass = _c.value;
                        if (classList[klass]) {
                            defaultClasses.push(klass);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return defaultClasses.join(' ');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "height", {
            get: function () {
                if (this.grid.hasColumnGroups) {
                    return (this.grid.maxLevelHeaderDepth + 1 - this.column.level) * this.grid.defaultRowHeight / this.grid._baseFontSize;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "esfIconTemplate", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.excelStyleHeaderIconTemplate || this.defaultESFHeaderIconTemplate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "ascending", {
            get: function () {
                return this.sortDirection === exports.SortingDirection.Asc;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "descending", {
            get: function () {
                return this.sortDirection === exports.SortingDirection.Desc;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "sortingIcon", {
            get: function () {
                if (this.sortDirection !== exports.SortingDirection.None) {
                    // arrow_downward and arrow_upward
                    // are material icons ligature strings
                    return this.sortDirection === exports.SortingDirection.Asc ? 'arrow_upward' : 'arrow_downward';
                }
                return 'arrow_upward';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "sorted", {
            get: function () {
                return this.sortDirection !== exports.SortingDirection.None;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "filterIconClassName", {
            get: function () {
                return this.column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "selectable", {
            get: function () {
                return this.grid.columnSelection !== GridSelectionMode.none &&
                    this.column.applySelectableClass &&
                    !this.column.selected &&
                    !this.grid.filteringService.isFilterRowVisible;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "selected", {
            get: function () {
                return this.column.selected
                    && (!this.grid.filteringService.isFilterRowVisible || this.grid.filteringService.filteredColumn !== this.column);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "columnTitle", {
            get: function () {
                return this.column.title || this.column.header || this.column.field;
            },
            enumerable: false,
            configurable: true
        });
        IgxGridHeaderComponent.prototype.onClick = function (event) {
            if (!this.colResizingService.isColumnResizing) {
                if (this.grid.filteringService.isFilterRowVisible) {
                    if (this.column.filterCellTemplate) {
                        this.grid.filteringRow.close();
                        return;
                    }
                    if (this.column.filterable && !this.column.columnGroup &&
                        !this.grid.filteringService.isFilterComplex(this.column.field)) {
                        this.grid.filteringService.filteredColumn = this.column;
                    }
                }
                else if (this.grid.columnSelection !== GridSelectionMode.none && this.column.selectable) {
                    var clearSelection = this.grid.columnSelection === GridSelectionMode.single || !event.ctrlKey;
                    var rangeSelection = this.grid.columnSelection === GridSelectionMode.multiple && event.shiftKey;
                    if (!this.column.selected || (this.grid.selectionService.getSelectedColumns().length > 1 && clearSelection)) {
                        this.grid.selectionService.selectColumn(this.column.field, clearSelection, rangeSelection, event);
                    }
                    else {
                        this.grid.selectionService.deselectColumn(this.column.field, event);
                    }
                }
            }
            this.grid.theadRow.nativeElement.focus();
        };
        /**
         * @hidden
         */
        IgxGridHeaderComponent.prototype.onPinterEnter = function () {
            this.column.applySelectableClass = true;
        };
        /**
         * @hidden
         */
        IgxGridHeaderComponent.prototype.onPointerLeave = function () {
            this.column.applySelectableClass = false;
        };
        IgxGridHeaderComponent.prototype.ngDoCheck = function () {
            this.getSortDirection();
            this.cdr.markForCheck();
        };
        IgxGridHeaderComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next(true);
            this._destroy$.complete();
            this.grid.filteringService.hideExcelFiltering();
        };
        IgxGridHeaderComponent.prototype.onFilteringIconClick = function (event) {
            event.stopPropagation();
            this.grid.filteringService.toggleFilterDropdown(this.elementRef.nativeElement, this.column, IgxGridExcelStyleFilteringComponent);
        };
        Object.defineProperty(IgxGridHeaderComponent.prototype, "grid", {
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: false,
            configurable: true
        });
        IgxGridHeaderComponent.prototype.onSortingIconClick = function (event) {
            event.stopPropagation();
            this.triggerSort();
        };
        IgxGridHeaderComponent.prototype.getSortDirection = function () {
            var _this = this;
            var expr = this.gridAPI.grid.sortingExpressions.find(function (x) { return x.fieldName === _this.column.field; });
            this.sortDirection = expr ? expr.dir : exports.SortingDirection.None;
        };
        IgxGridHeaderComponent.prototype.triggerSort = function () {
            var _this = this;
            var groupingExpr = this.grid.groupingExpressions ?
                this.grid.groupingExpressions.find(function (expr) { return expr.fieldName === _this.column.field; }) : null;
            var sortDir = groupingExpr ?
                this.sortDirection + 1 > exports.SortingDirection.Desc ? exports.SortingDirection.Asc : exports.SortingDirection.Desc
                : this.sortDirection + 1 > exports.SortingDirection.Desc ? exports.SortingDirection.None : this.sortDirection + 1;
            this.sortDirection = sortDir;
            this.grid.sort({
                fieldName: this.column.field, dir: this.sortDirection, ignoreCase: this.column.sortingIgnoreCase,
                strategy: this.column.sortStrategy
            });
        };
        return IgxGridHeaderComponent;
    }());
    IgxGridHeaderComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-header',
                    template: "<ng-template #defaultColumn>\n    <span [title]=\"columnTitle\">{{ column.header || column.field }}</span>\n</ng-template>\n\n<ng-template #defaultESFHeaderIconTemplate>\n    <igx-icon>more_vert</igx-icon>\n</ng-template>\n\n<span class=\"igx-grid__th-title\">\n    <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n    </ng-container>\n</span>\n<div class=\"igx-grid__th-icons\" *ngIf=\"!column.columnGroup\">\n    <igx-icon\n        [attr.draggable]=\"false\"\n        [attr.data-sortIndex]=\"column.field | sortingIndex:grid.sortingExpressions\"\n        class=\"sort-icon\"\n        *ngIf=\"column.sortable\"\n        (click)=\"onSortingIconClick($event)\">\n        {{sortingIcon}}\n    </igx-icon>\n\n    <div *ngIf=\"grid.allowFiltering == true && column.filterable && grid.filterMode == 'excelStyleFilter'\"\n         (click)=\"onFilteringIconClick($event)\"\n         (pointerdown)=\"$event.stopPropagation()\"\n         [ngClass]=\"filterIconClassName\">\n\n        <ng-container *ngTemplateOutlet=\"esfIconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n    </div>\n\n</div>\n"
                },] }
    ];
    IgxGridHeaderComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: IgxColumnResizingService },
        { type: i0.ChangeDetectorRef },
        { type: i0.ElementRef },
        { type: i0.NgZone }
    ]; };
    IgxGridHeaderComponent.propDecorators = {
        hostRole: [{ type: i0.HostBinding, args: ['attr.role',] }],
        column: [{ type: i0.Input }],
        gridID: [{ type: i0.Input }],
        defaultESFHeaderIconTemplate: [{ type: i0.ViewChild, args: ['defaultESFHeaderIconTemplate', { read: i0.TemplateRef, static: true },] }],
        ariaSelected: [{ type: i0.HostBinding, args: ['attr.aria-selected',] }],
        styleClasses: [{ type: i0.HostBinding, args: ['class',] }],
        height: [{ type: i0.HostBinding, args: ['style.height.rem',] }],
        onClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }],
        onPinterEnter: [{ type: i0.HostListener, args: ['pointerenter',] }],
        onPointerLeave: [{ type: i0.HostListener, args: ['pointerleave',] }]
    };

    /**
     * @hidden
     */
    var IgxGridFilteringCellComponent = /** @class */ (function () {
        function IgxGridFilteringCellComponent(cdr, filteringService) {
            this.cdr = cdr;
            this.filteringService = filteringService;
            this.moreFiltersCount = 0;
            this.baseClass = 'igx-grid__filtering-cell-indicator';
            this.filteringService.subscribeToEvents();
        }
        Object.defineProperty(IgxGridFilteringCellComponent.prototype, "styleClasses", {
            get: function () {
                var classes = this.column && this.column.selected ?
                    'igx-grid__filtering-cell--selected' :
                    'igx-grid__filtering-cell';
                switch (this.column.grid.displayDensity) {
                    case DisplayDensity.compact:
                        classes = classes + ' igx-grid__filtering-cell--compact';
                        break;
                    case DisplayDensity.cosy:
                        classes = classes + ' igx-grid__filtering-cell--cosy';
                        break;
                }
                return classes;
            },
            enumerable: false,
            configurable: true
        });
        IgxGridFilteringCellComponent.prototype.ngOnInit = function () {
            this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
        };
        IgxGridFilteringCellComponent.prototype.ngAfterViewInit = function () {
            this.updateFilterCellArea();
        };
        IgxGridFilteringCellComponent.prototype.ngDoCheck = function () {
            this.updateFilterCellArea();
        };
        /**
         * Returns whether a chip with a given index is visible or not.
         */
        IgxGridFilteringCellComponent.prototype.isChipVisible = function (index) {
            var expression = this.expressionsList[index];
            return !!(expression && expression.isVisible);
        };
        /**
         * Updates the filtering cell area.
         */
        IgxGridFilteringCellComponent.prototype.updateFilterCellArea = function () {
            this.expressionsList = this.filteringService.getExpressions(this.column.field);
            this.updateVisibleFilters();
        };
        Object.defineProperty(IgxGridFilteringCellComponent.prototype, "displayDensity", {
            get: function () {
                return this.column.grid.displayDensity === DisplayDensity.comfortable ? DisplayDensity.cosy : this.column.grid.displayDensity;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringCellComponent.prototype, "template", {
            get: function () {
                if (!this.column.filterable) {
                    return null;
                }
                if (this.column.filterCellTemplate) {
                    return this.column.filterCellTemplate;
                }
                var expressionTree = this.column.filteringExpressionsTree;
                if (!expressionTree || expressionTree.filteringOperands.length === 0) {
                    return this.emptyFilter;
                }
                if (this.filteringService.isFilterComplex(this.column.field)) {
                    return this.complexFilter;
                }
                return this.defaultFilter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringCellComponent.prototype, "context", {
            /**
             * Gets the context passed to the filter template.
             *
             * @memberof IgxGridFilteringCellComponent
             */
            get: function () {
                return { column: this.column };
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Chip clicked event handler.
         */
        IgxGridFilteringCellComponent.prototype.onChipClicked = function (expression) {
            if (expression) {
                this.expressionsList.forEach(function (item) {
                    item.isSelected = (item.expression === expression);
                });
            }
            else if (this.expressionsList.length > 0) {
                this.expressionsList.forEach(function (item) {
                    item.isSelected = false;
                });
                this.expressionsList[0].isSelected = true;
            }
            this.filteringService.grid.navigation.performHorizontalScrollToCell(this.column.visibleIndex);
            this.filteringService.filteredColumn = this.column;
            this.filteringService.isFilterRowVisible = true;
            this.filteringService.selectedExpression = expression;
        };
        /**
         * Chip removed event handler.
         */
        IgxGridFilteringCellComponent.prototype.onChipRemoved = function (eventArgs, item) {
            var indexToRemove = this.expressionsList.indexOf(item);
            this.removeExpression(indexToRemove);
            this.filteringService.grid.theadRow.nativeElement.focus();
        };
        /**
         * Clears the filtering.
         */
        IgxGridFilteringCellComponent.prototype.clearFiltering = function () {
            this.filteringService.clearFilter(this.column.field);
            this.cdr.detectChanges();
        };
        /**
         * Returns the filtering indicator class.
         */
        IgxGridFilteringCellComponent.prototype.filteringIndicatorClass = function () {
            var _a;
            return _a = {},
                _a[this.baseClass] = !this.isMoreIconHidden(),
                _a[this.baseClass + "--hidden"] = this.isMoreIconHidden(),
                _a;
        };
        IgxGridFilteringCellComponent.prototype.removeExpression = function (indexToRemove) {
            if (indexToRemove === 0 && this.expressionsList.length === 1) {
                this.clearFiltering();
                return;
            }
            this.filteringService.removeExpression(this.column.field, indexToRemove);
            this.updateVisibleFilters();
            this.filteringService.filterInternal(this.column.field);
        };
        IgxGridFilteringCellComponent.prototype.isMoreIconHidden = function () {
            return this.filteringService.columnToMoreIconHidden.get(this.column.field);
        };
        IgxGridFilteringCellComponent.prototype.updateVisibleFilters = function () {
            this.expressionsList.forEach(function (ex) { return ex.isVisible = true; });
            if (this.moreIcon) {
                this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
            }
            this.cdr.detectChanges();
            if (this.chipsArea && this.expressionsList.length > 1) {
                var areaWidth = this.chipsArea.element.nativeElement.offsetWidth;
                var viewWidth = 0;
                var chipsAreaElements = this.chipsArea.element.nativeElement.children;
                var visibleChipsCount = 0;
                var moreIconWidth = this.moreIcon.nativeElement.offsetWidth -
                    parseInt(document.defaultView.getComputedStyle(this.moreIcon.nativeElement)['margin-left'], 10);
                for (var index = 0; index < chipsAreaElements.length - 1; index++) {
                    if (viewWidth + chipsAreaElements[index].offsetWidth < areaWidth) {
                        viewWidth += chipsAreaElements[index].offsetWidth;
                        if (index % 2 === 0) {
                            visibleChipsCount++;
                        }
                        else {
                            viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-left'], 10);
                            viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-right'], 10);
                        }
                    }
                    else {
                        if (index % 2 !== 0 && viewWidth + moreIconWidth > areaWidth) {
                            visibleChipsCount--;
                        }
                        else if (visibleChipsCount > 0 && viewWidth - chipsAreaElements[index - 1].offsetWidth + moreIconWidth > areaWidth) {
                            visibleChipsCount--;
                        }
                        this.moreFiltersCount = this.expressionsList.length - visibleChipsCount;
                        this.filteringService.columnToMoreIconHidden.set(this.column.field, false);
                        break;
                    }
                }
                for (var i = visibleChipsCount; i < this.expressionsList.length; i++) {
                    this.expressionsList[i].isVisible = false;
                }
                this.cdr.detectChanges();
            }
        };
        return IgxGridFilteringCellComponent;
    }());
    IgxGridFilteringCellComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-filtering-cell',
                    template: "<ng-template #emptyFilter>\n    <igx-chips-area [attr.draggable]=\"false\" class=\"igx-filtering-chips\">\n        <igx-chip #ghostChip [attr.draggable]=\"false\" (click)=\"onChipClicked()\" [displayDensity]=\"displayDensity\" tabIndex=\"-1\">\n            <igx-icon [attr.draggable]=\"false\" igxPrefix>filter_list</igx-icon>\n            <span [attr.draggable]=\"false\">{{filteringService.grid.resourceStrings.igx_grid_filter}}</span>\n        </igx-chip>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #defaultFilter>\n    <igx-chips-area #chipsArea class=\"igx-filtering-chips\">\n        <ng-container *ngFor=\"let item of expressionsList; let last = last; let index = index;\" >\n            <igx-chip *ngIf=\"isChipVisible(index)\"\n                [removable]=\"true\"\n                tabIndex=\"-1\"\n                [displayDensity]=\"displayDensity\"\n                (click)=\"onChipClicked(item.expression)\"\n                (remove)=\"onChipRemoved($event, item)\">\n                <igx-icon igxPrefix\n                    family=\"imx-icons\"\n                    [name]=\"item.expression.condition.iconName\">\n                </igx-icon>\n                <span #label>\n                    {{filteringService.getChipLabel(item.expression)}}\n                </span>\n            </igx-chip>\n            <span class=\"igx-filtering-chips__connector\" *ngIf=\"!last && isChipVisible(index + 1)\">{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n        </ng-container>\n        <div #moreIcon [ngClass]=\"filteringIndicatorClass()\" (click)=\"onChipClicked()\">\n            <igx-icon>filter_list</igx-icon>\n            <igx-badge [value]=\"moreFiltersCount\"></igx-badge>\n        </div>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #complexFilter>\n    <igx-chip #complexChip [removable]=\"true\" [displayDensity]=\"displayDensity\" (remove)=\"clearFiltering()\" tabIndex=\"-1\">\n        <igx-icon igxPrefix>filter_list</igx-icon>\n        <span>{{filteringService.grid.resourceStrings.igx_grid_complex_filter}}</span>\n    </igx-chip>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n"
                },] }
    ];
    IgxGridFilteringCellComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef },
        { type: IgxFilteringService }
    ]; };
    IgxGridFilteringCellComponent.propDecorators = {
        column: [{ type: i0.Input }],
        emptyFilter: [{ type: i0.ViewChild, args: ['emptyFilter', { read: i0.TemplateRef, static: true },] }],
        defaultFilter: [{ type: i0.ViewChild, args: ['defaultFilter', { read: i0.TemplateRef, static: true },] }],
        complexFilter: [{ type: i0.ViewChild, args: ['complexFilter', { read: i0.TemplateRef, static: true },] }],
        chipsArea: [{ type: i0.ViewChild, args: ['chipsArea', { read: IgxChipsAreaComponent },] }],
        moreIcon: [{ type: i0.ViewChild, args: ['moreIcon', { read: i0.ElementRef },] }],
        ghostChip: [{ type: i0.ViewChild, args: ['ghostChip', { read: IgxChipComponent },] }],
        complexChip: [{ type: i0.ViewChild, args: ['complexChip', { read: IgxChipComponent },] }],
        styleClasses: [{ type: i0.HostBinding, args: ['class',] }]
    };

    var Z_INDEX = 9999;
    /**
     * @hidden
     */
    var IgxGridHeaderGroupComponent = /** @class */ (function () {
        function IgxGridHeaderGroupComponent(cdr, gridAPI, element, colResizingService, filteringService) {
            this.cdr = cdr;
            this.gridAPI = gridAPI;
            this.element = element;
            this.colResizingService = colResizingService;
            this.filteringService = filteringService;
        }
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "gridRowSpan", {
            get: function () {
                return this.column.gridRowSpan;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "gridColumnSpan", {
            get: function () {
                return this.column.gridColumnSpan;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "rowEnd", {
            get: function () {
                return this.column.rowEnd;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "colEnd", {
            get: function () {
                return this.column.colEnd;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "rowStart", {
            get: function () {
                return this.column.rowStart;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "colStart", {
            get: function () {
                return this.column.colStart;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "headerID", {
            get: function () {
                return this.gridID + "_-1_" + this.column.level + "_" + this.column.visibleIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "active", {
            get: function () {
                var node = this.grid.navigation.activeNode;
                return node && !this.column.columnGroup ?
                    node.row === -1 && node.column === this.column.visibleIndex && node.level === this.column.level : false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "activeGroup", {
            get: function () {
                var node = this.grid.navigation.activeNode;
                return node ? node.row === -1 && node.column === this.column.visibleIndex && node.level === this.column.level : false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "width", {
            /**
             * Gets the width of the header group.
             *
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                return this.grid.getHeaderGroupWidth(this.column);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "styleClasses", {
            /**
             * Gets the style classes of the header group.
             *
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                var e_1, _a;
                var defaultClasses = [
                    'igx-grid__thead-item',
                    this.column.headerGroupClasses
                ];
                var classList = {
                    'igx-grid__th--pinned': this.isPinned,
                    'igx-grid__th--pinned-last': this.isLastPinned,
                    'igx-grid__th--pinned-first': this.isFirstPinned,
                    'igx-grid__drag-col-header': this.isHeaderDragged,
                    'igx-grid__th--filtering': this.isFiltered
                };
                try {
                    for (var _b = __values(Object.keys(classList)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var className = _c.value;
                        if (classList[className]) {
                            defaultClasses.push(className);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return defaultClasses.join(' ');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "zIndex", {
            /**
             * @hidden
             */
            get: function () {
                if (!this.column.pinned) {
                    return null;
                }
                return Z_INDEX - this.grid.pinnedColumns.indexOf(this.column);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "grid", {
            /**
             * Gets the grid of the header group.
             *
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "isFiltered", {
            /**
             * Gets whether the header group belongs to a column that is filtered.
             *
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                return this.filteringService.filteredColumn === this.column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "isLastPinned", {
            /**
             * Gets whether the header group is stored in the last column in the pinned area.
             *
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                return !this.grid.hasColumnLayouts ? this.column.isLastPinned : false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "isFirstPinned", {
            /**
             * Gets whether the header group is stored in the first column of the right pinned area.
             */
            get: function () {
                return !this.grid.hasColumnLayouts ? this.column.isFirstPinned : false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "groupDisplayStyle", {
            get: function () {
                return this.grid.hasColumnLayouts && this.column.children && !isIE() ? 'flex' : '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "isPinned", {
            /**
             * Gets whether the header group is stored in a pinned column.
             *
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                return this.column.pinned;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "isHeaderDragged", {
            /**
             * Gets whether the header group belongs to a column that is moved.
             *
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                return this.grid.draggedColumn === this.column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "hasLastPinnedChildColumn", {
            /**
             * @hidden
             */
            get: function () {
                return this.column.allChildren.some(function (child) { return child.isLastPinned; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "hasFirstPinnedChildColumn", {
            /**
             * @hidden
             */
            get: function () {
                return this.column.allChildren.some(function (child) { return child.isFirstPinned; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "selectable", {
            /**
             * @hidden
             */
            get: function () {
                var selectableChildren = this.column.allChildren.filter(function (c) { return !c.hidden && c.selectable && !c.columnGroup; });
                return this.grid.columnSelection !== GridSelectionMode.none &&
                    this.column.applySelectableClass
                    && !this.selected && selectableChildren.length > 0
                    && !this.grid.filteringService.isFilterRowVisible;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "selected", {
            /**
             * @hidden
             */
            get: function () {
                return this.column.selected;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "height", {
            /**
             * @hidden
             */
            get: function () {
                return this.element.nativeElement.getBoundingClientRect().height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "columnTitle", {
            /**
             * @hidden
             */
            get: function () {
                return this.column.title || this.column.header;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxGridHeaderGroupComponent.prototype.onMouseDown = function (event) {
            // hack for preventing text selection in IE and Edge while dragging the resizer
            event.preventDefault();
        };
        /**
         * @hidden
         */
        IgxGridHeaderGroupComponent.prototype.groupClicked = function (event) {
            var columnsToSelect = this.column.allChildren.filter(function (c) { return !c.hidden && c.selectable && !c.columnGroup; }).map(function (c) { return c.field; });
            if (this.grid.columnSelection !== GridSelectionMode.none
                && columnsToSelect.length > 0 && !this.grid.filteringService.isFilterRowVisible) {
                var clearSelection = this.grid.columnSelection === GridSelectionMode.single || !event.ctrlKey;
                var rangeSelection = this.grid.columnSelection === GridSelectionMode.multiple && event.shiftKey;
                if (!this.selected) {
                    this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, rangeSelection, event);
                }
                else {
                    var selectedFields = this.grid.selectionService.getSelectedColumns();
                    if ((selectedFields.length === columnsToSelect.length) && selectedFields.every(function (el) { return columnsToSelect.includes(el); })
                        || !clearSelection) {
                        this.grid.selectionService.deselectColumns(columnsToSelect, event);
                    }
                    else {
                        this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, rangeSelection, event);
                    }
                }
            }
        };
        /**
         * @hidden
         */
        IgxGridHeaderGroupComponent.prototype.toggleExpandState = function (event) {
            event.stopPropagation();
            this.column.expanded = !this.column.expanded;
        };
        /**
         * @hidden
         */
        // @HostListener('pointerdown', ['$event'])
        IgxGridHeaderGroupComponent.prototype.pointerdown = function (event) {
            event.stopPropagation();
            this.activate();
            this.grid.theadRow.nativeElement.focus();
        };
        /*
         * This method is necessary due to some specifics related with implementation of column moving
         * @hidden
         */
        IgxGridHeaderGroupComponent.prototype.activate = function () {
            this.grid.navigation.setActiveNode(this.activeNode);
            this.grid.theadRow.nativeElement.focus();
        };
        IgxGridHeaderGroupComponent.prototype.ngDoCheck = function () {
            this.cdr.markForCheck();
        };
        /**
         * @hidden
         */
        IgxGridHeaderGroupComponent.prototype.onPinterEnter = function () {
            this.column.applySelectableClass = true;
        };
        /**
         * @hidden
         */
        IgxGridHeaderGroupComponent.prototype.onPointerLeave = function () {
            this.column.applySelectableClass = false;
        };
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "activeNode", {
            get: function () {
                return { row: -1, column: this.column.visibleIndex, level: this.column.level,
                    mchCache: { level: this.column.level, visibleIndex: this.column.visibleIndex },
                    layout: this.column.columnLayoutChild ? {
                        rowStart: this.column.rowStart,
                        colStart: this.column.colStart,
                        rowEnd: this.column.rowEnd,
                        colEnd: this.column.colEnd,
                        columnVisibleIndex: this.column.visibleIndex
                    } : null };
            },
            enumerable: false,
            configurable: true
        });
        return IgxGridHeaderGroupComponent;
    }());
    IgxGridHeaderGroupComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-header-group',
                    template: "<ng-container *ngIf=\"grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-group igx-grid__mrl-block\"\n     [ngClass]=\"{\n         'igx-grid__th--pinned-last': hasLastPinnedChildColumn,\n         'igx-grid__th--pinned-first': hasFirstPinnedChildColumn\n        }\"\n     [ngStyle]=\"{'grid-template-rows':column.getGridTemplate(true, false),\n     'grid-template-columns':column.getGridTemplate(false, false),\n     '-ms-grid-rows':column.getGridTemplate(true, true),\n     '-ms-grid-columns':column.getGridTemplate(false, true)}\">\n        <ng-container *ngFor=\"let child of column.children\" >\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                [column]=\"child\"\n                [gridID]=\"child.grid.id\"\n                [igxColumnMovingDrag]=\"child\"\n                [ghostHost]=\"grid.outlet.nativeElement\"\n                [attr.droppable]=\"true\"\n                [igxColumnMovingDrop]=\"child\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n\n<ng-template #defaultColumn>\n    <span class=\"igx-grid__th-group-title\" [title]=\"columnTitle\">{{column.header}}</span>\n</ng-template>\n\n<ng-template #defaultCollapseIndicator>\n    <igx-icon [attr.draggable]=\"false\" >\n            {{column.expanded ? 'expand_more' : 'chevron_right'}} </igx-icon>\n</ng-template>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-title\"\n        role=\"columnheader\"\n        [attr.aria-label]=\"column.header || column.field\"\n        [attr.aria-expanded]=\"column.expanded\"\n        [attr.aria-selected]=\"column.selected\"\n        [ngClass]=\"{\n            'igx-grid__th--pinned-last': hasLastPinnedChildColumn,\n            'igx-grid__th--pinned-first': hasFirstPinnedChildColumn,\n            'igx-grid__th--collapsible': column.collapsible,\n            'igx-grid__th--selectable': selectable,\n            'igx-grid__th--selected': selected,\n            'igx-grid__th--active': activeGroup}\"\n        [igxColumnMovingDrag]=\"column\"\n        [ghostHost]=\"grid.outlet.nativeElement\"\n        [attr.droppable]=\"true\"\n        [igxColumnMovingDrop]=\"column\"\n        (pointerdown)=\"pointerdown($event)\"\n        (click)=\"groupClicked($event)\"\n        (pointerenter)=\"onPinterEnter()\"\n        (pointerleave)=\"onPointerLeave()\"\n        >\n        <ng-container *ngIf=\"column.collapsible\">\n            <div class=\"igx-grid__th-expander\" (click)=\"toggleExpandState($event)\">\n                <ng-container\n                    *ngTemplateOutlet=\"column.collapsibleIndicatorTemplate ? column.collapsibleIndicatorTemplate : defaultCollapseIndicator; context: {$implicit: column, column: column}\">\n                </ng-container>\n            </div>\n        </ng-container>\n        <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n        </ng-container>\n    </div>\n    <div class=\"igx-grid__thead-group\">\n        <ng-container *ngFor=\"let child of column.children\">\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                                [column]=\"child\"\n                                [gridID]=\"child.grid.id\"\n                                [style.min-width]=\"grid.getHeaderGroupWidth(child)\"\n                                [style.flex-basis]=\"grid.getHeaderGroupWidth(child)\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n<ng-container *ngIf=\"!column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <igx-grid-header [igxColumnMovingDrag]=\"column\" [ghostHost]=\"grid.outlet.nativeElement\" [attr.droppable]=\"true\" (pointerdown)=\"activate()\" [igxColumnMovingDrop]=\"column\" [gridID]=\"column.grid.id\" [column]=\"column\"></igx-grid-header>\n    <igx-grid-filtering-cell *ngIf=\"grid.allowFiltering && grid.filterMode == 'quickFilter'\" [column]=\"column\" [attr.draggable]=\"false\"></igx-grid-filtering-cell>\n    <span *ngIf=\"!column.columnGroup && column.resizable\" class=\"igx-grid__th-resize-handle\"\n        [igxResizeHandle]=\"column\"\n        [attr.draggable]=\"false\"\n        [style.cursor]=\"colResizingService.resizeCursor\">\n    </span>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n"
                },] }
    ];
    IgxGridHeaderGroupComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef },
        { type: GridBaseAPIService },
        { type: i0.ElementRef },
        { type: IgxColumnResizingService },
        { type: IgxFilteringService }
    ]; };
    IgxGridHeaderGroupComponent.propDecorators = {
        gridRowSpan: [{ type: i0.HostBinding, args: ['style.-ms-grid-row-span',] }],
        gridColumnSpan: [{ type: i0.HostBinding, args: ['style.-ms-grid-column-span',] }],
        rowEnd: [{ type: i0.HostBinding, args: ['style.grid-row-end',] }],
        colEnd: [{ type: i0.HostBinding, args: ['style.grid-column-end',] }],
        rowStart: [{ type: i0.HostBinding, args: ['style.-ms-grid-row',] }, { type: i0.HostBinding, args: ['style.grid-row-start',] }],
        colStart: [{ type: i0.HostBinding, args: ['style.-ms-grid-column',] }, { type: i0.HostBinding, args: ['style.grid-column-start',] }],
        headerID: [{ type: i0.HostBinding, args: ['attr.id',] }],
        column: [{ type: i0.Input }],
        gridID: [{ type: i0.Input }],
        active: [{ type: i0.HostBinding, args: ['class.igx-grid__th--active',] }],
        headerCell: [{ type: i0.ViewChild, args: [IgxGridHeaderComponent,] }],
        filterCell: [{ type: i0.ViewChild, args: [IgxGridFilteringCellComponent,] }],
        children: [{ type: i0.ViewChildren, args: [i0.forwardRef(function () { return IgxGridHeaderGroupComponent; }), { read: IgxGridHeaderGroupComponent },] }],
        styleClasses: [{ type: i0.HostBinding, args: ['class',] }],
        zIndex: [{ type: i0.HostBinding, args: ['style.z-index',] }],
        groupDisplayStyle: [{ type: i0.HostBinding, args: ['style.display',] }],
        onMouseDown: [{ type: i0.HostListener, args: ['mousedown', ['$event'],] }]
    };

    /** @hidden */
    var IgxGridSummaryService = /** @class */ (function () {
        function IgxGridSummaryService() {
            this.rootSummaryID = 'igxGridRootSummary';
            this.summaryHeight = 0;
            this.maxSummariesLenght = 0;
            this.groupingExpressions = [];
            this.retriggerRootPipe = 0;
            this.deleteOperation = false;
            this.summaryCacheMap = new Map();
        }
        IgxGridSummaryService.prototype.recalculateSummaries = function () {
            this.resetSummaryHeight();
            this.grid.notifyChanges(true);
        };
        IgxGridSummaryService.prototype.clearSummaryCache = function (args) {
            if (!this.summaryCacheMap.size) {
                return;
            }
            if (!args) {
                this.summaryCacheMap.clear();
                if (this.grid && this.grid.rootSummariesEnabled) {
                    this.retriggerRootPipe++;
                }
                return;
            }
            if (args.data) {
                var rowID = this.grid.primaryKey ? args.data[this.grid.primaryKey] : args.data;
                this.removeSummaries(rowID);
            }
            if (args.rowID !== undefined && args.rowID !== null) {
                var columnName = args.cellID ? this.grid.columnList.find(function (col) { return col.index === args.cellID.columnID; }).field : undefined;
                if (columnName && this.grid.rowEditable) {
                    return;
                }
                var isGroupedColumn = this.grid.groupingExpressions &&
                    this.grid.groupingExpressions.map(function (expr) { return expr.fieldName; }).indexOf(columnName) !== -1;
                if (columnName && isGroupedColumn) {
                    columnName = undefined;
                }
                this.removeSummaries(args.rowID, columnName);
            }
        };
        IgxGridSummaryService.prototype.removeSummaries = function (rowID, columnName) {
            var _this = this;
            this.deleteSummaryCache(this.rootSummaryID, columnName);
            if (this.summaryCacheMap.size === 1 && this.summaryCacheMap.has(this.rootSummaryID)) {
                return;
            }
            if (this.isTreeGrid) {
                if (this.grid.transactions.enabled && this.deleteOperation) {
                    this.deleteOperation = false;
                    // TODO: this.removeChildRowSummaries(rowID, columnName);
                    this.summaryCacheMap.clear();
                    return;
                }
                this.removeAllTreeGridSummaries(rowID, columnName);
            }
            else if (this.isHierarchicalGrid) {
                if (this.grid.transactions.enabled && this.deleteOperation) {
                    this.deleteOperation = false;
                    this.summaryCacheMap.clear();
                }
            }
            else {
                var summaryIds = this.getSummaryID(rowID, this.grid.groupingExpressions);
                summaryIds.forEach(function (id) {
                    _this.deleteSummaryCache(id, columnName);
                });
            }
        };
        IgxGridSummaryService.prototype.removeSummariesCachePerColumn = function (columnName) {
            this.summaryCacheMap.forEach(function (cache) {
                if (cache.get(columnName)) {
                    cache.delete(columnName);
                }
            });
            if (this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
        };
        IgxGridSummaryService.prototype.calcMaxSummaryHeight = function () {
            if (this.summaryHeight) {
                return this.summaryHeight;
            }
            if (!this.grid.data) {
                return this.summaryHeight = 0;
            }
            var maxSummaryLength = 0;
            this.grid.columnList.filter(function (col) { return col.hasSummary && !col.hidden; }).forEach(function (column) {
                var getCurrentSummaryColumn = column.summaries.operate([], [], column.field).length;
                if (getCurrentSummaryColumn) {
                    if (maxSummaryLength < getCurrentSummaryColumn) {
                        maxSummaryLength = getCurrentSummaryColumn;
                    }
                }
            });
            this.maxSummariesLenght = maxSummaryLength;
            this.summaryHeight = maxSummaryLength * this.grid.defaultSummaryHeight;
            return this.summaryHeight;
        };
        IgxGridSummaryService.prototype.calculateSummaries = function (rowID, data) {
            var _this = this;
            var rowSummaries = this.summaryCacheMap.get(rowID);
            if (!rowSummaries) {
                rowSummaries = new Map();
                this.summaryCacheMap.set(rowID, rowSummaries);
            }
            if (!this.hasSummarizedColumns || !data) {
                return rowSummaries;
            }
            this.grid.columnList.filter(function (col) { return col.hasSummary; }).forEach(function (column) {
                if (!rowSummaries.get(column.field)) {
                    var summaryResult = column.summaries.operate(data.map(function (r) { return resolveNestedPath(r, column.field); }), data, column.field, _this.grid.locale, column.pipeArgs);
                    rowSummaries.set(column.field, summaryResult);
                }
            });
            return rowSummaries;
        };
        IgxGridSummaryService.prototype.resetSummaryHeight = function () {
            this.summaryHeight = 0;
            this.grid._summaryPipeTrigger++;
            if (this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
        };
        IgxGridSummaryService.prototype.updateSummaryCache = function (groupingArgs) {
            if (this.summaryCacheMap.size === 0 || !this.hasSummarizedColumns) {
                return;
            }
            if (this.groupingExpressions.length === 0) {
                this.groupingExpressions = groupingArgs.expressions.map(function (record) { return record.fieldName; });
                return;
            }
            if (groupingArgs.length === 0) {
                this.groupingExpressions = [];
                this.clearSummaryCache();
                return;
            }
            this.compareGroupingExpressions(this.groupingExpressions, groupingArgs);
            this.groupingExpressions = groupingArgs.expressions.map(function (record) { return record.fieldName; });
        };
        Object.defineProperty(IgxGridSummaryService.prototype, "hasSummarizedColumns", {
            get: function () {
                var summarizedColumns = this.grid.columnList.filter(function (col) { return col.hasSummary && !col.hidden; });
                return summarizedColumns.length > 0;
            },
            enumerable: false,
            configurable: true
        });
        IgxGridSummaryService.prototype.deleteSummaryCache = function (id, columnName) {
            if (this.summaryCacheMap.get(id)) {
                var filteringApplied = columnName && this.grid.filteringExpressionsTree &&
                    this.grid.filteringExpressionsTree.filteringOperands.map(function (expr) { return expr.fieldName; }).indexOf(columnName) !== -1;
                if (columnName && this.summaryCacheMap.get(id).get(columnName) && !filteringApplied) {
                    this.summaryCacheMap.get(id).delete(columnName);
                }
                else {
                    this.summaryCacheMap.delete(id);
                }
                if (id === this.rootSummaryID && this.grid.rootSummariesEnabled) {
                    this.retriggerRootPipe++;
                }
            }
        };
        IgxGridSummaryService.prototype.getSummaryID = function (rowID, groupingExpressions) {
            var _this = this;
            if (groupingExpressions.length === 0) {
                return [];
            }
            var summaryIDs = [];
            var data = this.grid.data;
            if (this.grid.transactions.enabled) {
                data = DataUtil.mergeTransactions(cloneArray(this.grid.data), this.grid.transactions.getAggregatedChanges(true), this.grid.primaryKey);
            }
            var rowData = this.grid.primaryKey ? data.find(function (rec) { return rec[_this.grid.primaryKey] === rowID; }) : rowID;
            var id = '{ ';
            groupingExpressions.forEach(function (expr) {
                id += "'" + expr.fieldName + "': '" + rowData[expr.fieldName] + "'";
                summaryIDs.push(id.concat(' }'));
                id += ', ';
            });
            return summaryIDs;
        };
        IgxGridSummaryService.prototype.removeAllTreeGridSummaries = function (rowID, columnName) {
            var row = this.grid.records.get(rowID);
            if (!row) {
                return;
            }
            row = row.children ? row : row.parent;
            while (row) {
                rowID = row.rowID;
                this.deleteSummaryCache(rowID, columnName);
                row = row.parent;
            }
        };
        // TODO: remove only deleted rows
        IgxGridSummaryService.prototype.removeChildRowSummaries = function (rowID, columnName) {
        };
        IgxGridSummaryService.prototype.compareGroupingExpressions = function (current, groupingArgs) {
            var _this = this;
            var newExpressions = groupingArgs.expressions.map(function (record) { return record.fieldName; });
            var removedCols = groupingArgs.ungroupedColumns;
            if (current.length <= newExpressions.length) {
                var newExpr = newExpressions.slice(0, current.length).toString();
                if (current.toString() !== newExpr) {
                    this.clearSummaryCache();
                }
            }
            else {
                var currExpr = current.slice(0, newExpressions.length).toString();
                if (currExpr !== newExpressions.toString()) {
                    this.clearSummaryCache();
                    return;
                }
                removedCols.map(function (col) { return col.field; }).forEach(function (colName) {
                    _this.summaryCacheMap.forEach(function (cache, id) {
                        if (id.indexOf(colName) !== -1) {
                            _this.summaryCacheMap.delete(id);
                        }
                    });
                });
            }
        };
        Object.defineProperty(IgxGridSummaryService.prototype, "isTreeGrid", {
            get: function () {
                return this.grid.nativeElement.tagName.toLowerCase() === 'igx-tree-grid';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridSummaryService.prototype, "isHierarchicalGrid", {
            get: function () {
                return this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
            },
            enumerable: false,
            configurable: true
        });
        return IgxGridSummaryService;
    }());
    IgxGridSummaryService.decorators = [
        { type: i0.Injectable }
    ];

    var IgxSummaryCellComponent = /** @class */ (function () {
        function IgxSummaryCellComponent(element) {
            this.element = element;
            this.firstCellIndentation = 0;
            this.hasSummary = false;
        }
        Object.defineProperty(IgxSummaryCellComponent.prototype, "visibleColumnIndex", {
            get: function () {
                return this.column.visibleIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSummaryCellComponent.prototype, "attrCellID", {
            get: function () {
                return this.grid.id + "_" + this.rowIndex + "_" + this.visibleColumnIndex;
            },
            enumerable: false,
            configurable: true
        });
        IgxSummaryCellComponent.prototype.activate = function () {
            var currNode = this.grid.navigation.activeNode;
            if (currNode && this.rowIndex === currNode.row && this.visibleColumnIndex === currNode.column) {
                return;
            }
            this.grid.navigation.setActiveNode({ row: this.rowIndex, column: this.visibleColumnIndex }, 'summaryCell');
            this.grid.cdr.detectChanges();
        };
        Object.defineProperty(IgxSummaryCellComponent.prototype, "selectionNode", {
            get: function () {
                return {
                    row: this.rowIndex,
                    column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
                    isSummaryRow: true
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSummaryCellComponent.prototype, "width", {
            get: function () {
                return this.column.getCellWidth();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSummaryCellComponent.prototype, "nativeElement", {
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSummaryCellComponent.prototype, "columnDatatype", {
            get: function () {
                return this.column.dataType;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSummaryCellComponent.prototype, "itemHeight", {
            get: function () {
                return this.column.grid.defaultSummaryHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSummaryCellComponent.prototype, "grid", {
            /**
             * @hidden
             */
            get: function () {
                return this.column.grid;
            },
            enumerable: false,
            configurable: true
        });
        IgxSummaryCellComponent.prototype.translateSummary = function (summary) {
            return this.grid.resourceStrings["igx_grid_summary_" + summary.key] || summary.label;
        };
        return IgxSummaryCellComponent;
    }());
    IgxSummaryCellComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-summary-cell',
                    template: "<ng-container *ngIf=\"hasSummary\">\n    <ng-container *ngFor=\"let summary of summaryResults\">\n            <div class=\"igx-grid-summary__item\" [style.height.px]=\"itemHeight\">\n\n                <ng-container *ngIf=\"visibleColumnIndex === 0 && firstCellIndentation >= 0\">\n                    <div class=\"igx-grid__tree-cell--padding-level-{{firstCellIndentation}}\"></div>\n\n                    <div #indicator class=\"igx-grid__tree-grouping-indicator\" style=\"visibility: hidden\">\n                        <igx-icon>chevron_right</igx-icon>\n                    </div>\n                </ng-container>\n\n                <span class=\"igx-grid-summary__label\" [title]=\"summary.label\">{{ translateSummary(summary) }}</span>\n                <span class=\"igx-grid-summary__result\" [title]=\"summary.summaryResult\">\n                    {{ summary.summaryResult }}\n                </span>\n            </div>\n    </ng-container>\n</ng-container>\n"
                },] }
    ];
    IgxSummaryCellComponent.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxSummaryCellComponent.propDecorators = {
        summaryResults: [{ type: i0.Input }],
        column: [{ type: i0.Input }],
        firstCellIndentation: [{ type: i0.Input }],
        hasSummary: [{ type: i0.Input }],
        density: [{ type: i0.Input }],
        active: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.igx-grid-summary--active',] }],
        rowIndex: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.data-rowIndex',] }],
        visibleColumnIndex: [{ type: i0.HostBinding, args: ['attr.data-visibleIndex',] }],
        attrCellID: [{ type: i0.HostBinding, args: ['attr.id',] }],
        activate: [{ type: i0.HostListener, args: ['pointerdown',] }]
    };

    var IgxSummaryRowComponent = /** @class */ (function () {
        function IgxSummaryRowComponent(gridAPI, element, cdr) {
            this.gridAPI = gridAPI;
            this.element = element;
            this.cdr = cdr;
            this.firstCellIndentation = -1;
        }
        Object.defineProperty(IgxSummaryRowComponent.prototype, "dataRowIndex", {
            get: function () {
                return this.index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSummaryRowComponent.prototype, "minHeight", {
            get: function () {
                return this.grid.summaryService.calcMaxSummaryHeight() - 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSummaryRowComponent.prototype, "summaryCells", {
            get: function () {
                var res = new i0.QueryList();
                if (!this._summaryCells) {
                    return res;
                }
                var cList = this._summaryCells.filter(function (c) { return c.nativeElement.isConnected; });
                res.reset(cList);
                return res;
            },
            set: function (cells) { },
            enumerable: false,
            configurable: true
        });
        IgxSummaryRowComponent.prototype.ngDoCheck = function () {
            this.cdr.markForCheck();
        };
        Object.defineProperty(IgxSummaryRowComponent.prototype, "grid", {
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSummaryRowComponent.prototype, "nativeElement", {
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        IgxSummaryRowComponent.prototype.getColumnSummaries = function (columnName) {
            if (!this.summaries.get(columnName)) {
                return [];
            }
            return this.summaries.get(columnName);
        };
        /**
         * @hidden
         * @internal
         */
        IgxSummaryRowComponent.prototype.isCellActive = function (visibleColumnIndex) {
            var node = this.grid.navigation.activeNode;
            return node ? node.row === this.index && node.column === visibleColumnIndex : false;
        };
        Object.defineProperty(IgxSummaryRowComponent.prototype, "pinnedColumns", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.pinnedColumns;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSummaryRowComponent.prototype, "unpinnedColumns", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.unpinnedColumns;
            },
            enumerable: false,
            configurable: true
        });
        IgxSummaryRowComponent.prototype.getContext = function (row) {
            return {
                $implicit: row
            };
        };
        return IgxSummaryRowComponent;
    }());
    IgxSummaryRowComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-summary-row',
                    template: "<ng-container *ngIf=\"summaries.size\">\n    <ng-container *ngIf=\"grid.summariesMargin\">\n        <div\n        class=\"igx-grid__summaries-patch\"\n        [style.min-width.px]=\"grid.summariesMargin\"\n        [style.flex-basis.px]=\"grid.summariesMargin\"\n        (pointerdown)=\"$event.preventDefault()\"\n        ></div>\n    </ng-container>\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n        <ng-container *ngTemplateOutlet=\"summaryCellTemplate; context: getContext(this)\"></ng-container>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\" [igxForSizePropName]='\"calcPixelWidth\"' #igxDirRef>\n        <igx-grid-summary-cell\n            class=\"igx-grid-summary igx-grid-summary--fw\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            role=\"cell\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [class.igx-grid-summary--pinned-last]=\"col.isLastPinned\"\n            [column]=\"col\"\n            [rowIndex]=\"index\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\"\n            [style.min-width]=\"col.getCellWidth()\"\n            [style.max-width]=\"col.getCellWidth()\"\n            [style.flex-basis]=\"col.getCellWidth()\">\n        </igx-grid-summary-cell>\n    </ng-template>\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n        <ng-container *ngTemplateOutlet=\"summaryCellTemplate; context: getContext(this)\"></ng-container>\n    </ng-container>\n</ng-container>\n\n<ng-template #summaryCellTemplate let-col>\n    <igx-grid-summary-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            role=\"cell\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            class=\"igx-grid-summary igx-grid-summary--fw igx-grid-summary--pinned\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [class.igx-grid-summary--pinned-first]=\"col.isFirstPinned\"\n            [class.igx-grid-summary--pinned-last]=\"col.isLastPinned\"\n            [column]=\"col\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [rowIndex]=\"index\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\"\n            [style.min-width]=\"col.getCellWidth()\"\n            [style.max-width]=\"col.getCellWidth()\"\n            [style.flex-basis]=\"col.getCellWidth()\"\n            [style.left]=\"col.rightPinnedOffset\">\n        </igx-grid-summary-cell>\n</ng-template>\n",
                    providers: [IgxForOfSyncService]
                },] }
    ];
    IgxSummaryRowComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxSummaryRowComponent.propDecorators = {
        summaries: [{ type: i0.Input }],
        gridID: [{ type: i0.Input }],
        index: [{ type: i0.Input }],
        firstCellIndentation: [{ type: i0.Input }],
        dataRowIndex: [{ type: i0.HostBinding, args: ['attr.data-rowIndex',] }],
        _summaryCells: [{ type: i0.ViewChildren, args: [IgxSummaryCellComponent, { read: IgxSummaryCellComponent },] }],
        virtDirRow: [{ type: i0.ViewChild, args: ['igxDirRef', { read: IgxGridForOfDirective },] }]
    };

    var DragScrollDirection;
    (function (DragScrollDirection) {
        DragScrollDirection[DragScrollDirection["NONE"] = 0] = "NONE";
        DragScrollDirection[DragScrollDirection["LEFT"] = 1] = "LEFT";
        DragScrollDirection[DragScrollDirection["TOP"] = 2] = "TOP";
        DragScrollDirection[DragScrollDirection["RIGHT"] = 3] = "RIGHT";
        DragScrollDirection[DragScrollDirection["BOTTOM"] = 4] = "BOTTOM";
        DragScrollDirection[DragScrollDirection["TOPLEFT"] = 5] = "TOPLEFT";
        DragScrollDirection[DragScrollDirection["TOPRIGHT"] = 6] = "TOPRIGHT";
        DragScrollDirection[DragScrollDirection["BOTTOMLEFT"] = 7] = "BOTTOMLEFT";
        DragScrollDirection[DragScrollDirection["BOTTOMRIGHT"] = 8] = "BOTTOMRIGHT";
    })(DragScrollDirection || (DragScrollDirection = {}));
    var IgxGridDragSelectDirective = /** @class */ (function () {
        function IgxGridDragSelectDirective(ref, zone) {
            var _this = this;
            this.ref = ref;
            this.zone = zone;
            this.onDragStop = new i0.EventEmitter();
            this.onDragScroll = new i0.EventEmitter();
            this.end$ = new rxjs.Subject();
            this.lastDirection = DragScrollDirection.NONE;
            this.startDragSelection = function (ev) {
                if (!_this.activeDrag) {
                    return;
                }
                var x = ev.clientX;
                var y = ev.clientY;
                var direction = _this._measureDimensions(x, y);
                if (direction === _this.lastDirection) {
                    return;
                }
                _this.unsubscribe();
                _this._sub = _this._interval$.subscribe(function () { return _this.onDragScroll.emit(direction); });
                _this.lastDirection = direction;
            };
            this.stopDragSelection = function () {
                if (!_this.activeDrag) {
                    return;
                }
                _this.onDragStop.emit(false);
                _this.unsubscribe();
                _this.lastDirection = DragScrollDirection.NONE;
            };
            this._interval$ = rxjs.interval(100).pipe(operators.takeUntil(this.end$), operators.filter(function () { return _this.activeDrag; }));
        }
        Object.defineProperty(IgxGridDragSelectDirective.prototype, "activeDrag", {
            get: function () {
                return this._activeDrag;
            },
            set: function (val) {
                if (val !== this._activeDrag) {
                    this.unsubscribe();
                    this._activeDrag = val;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridDragSelectDirective.prototype, "nativeElement", {
            get: function () {
                return this.ref.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridDragSelectDirective.prototype, "clientRect", {
            get: function () {
                return this.nativeElement.getBoundingClientRect();
            },
            enumerable: false,
            configurable: true
        });
        IgxGridDragSelectDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                _this.nativeElement.addEventListener('pointerover', _this.startDragSelection);
                _this.nativeElement.addEventListener('pointerleave', _this.stopDragSelection);
            });
        };
        IgxGridDragSelectDirective.prototype.ngOnDestroy = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                _this.nativeElement.removeEventListener('pointerover', _this.startDragSelection);
                _this.nativeElement.removeEventListener('pointerleave', _this.stopDragSelection);
            });
            this.unsubscribe();
            this.end$.complete();
        };
        IgxGridDragSelectDirective.prototype._measureDimensions = function (x, y) {
            var direction;
            var rect = this.clientRect;
            var RATIO = 0.15;
            var offsetX = Math.trunc(x - rect.left);
            var offsetY = Math.trunc(y - rect.top);
            var left = offsetX <= rect.width * RATIO;
            var right = offsetX >= rect.width * (1 - RATIO);
            var top = offsetY <= rect.height * RATIO;
            var bottom = offsetY >= rect.height * (1 - RATIO);
            if (top && left) {
                direction = DragScrollDirection.TOPLEFT;
            }
            else if (top && right) {
                direction = DragScrollDirection.TOPRIGHT;
            }
            else if (bottom && left) {
                direction = DragScrollDirection.BOTTOMLEFT;
            }
            else if (bottom && right) {
                direction = DragScrollDirection.BOTTOMRIGHT;
            }
            else if (top) {
                direction = DragScrollDirection.TOP;
            }
            else if (bottom) {
                direction = DragScrollDirection.BOTTOM;
            }
            else if (left) {
                direction = DragScrollDirection.LEFT;
            }
            else if (right) {
                direction = DragScrollDirection.RIGHT;
            }
            else {
                direction = DragScrollDirection.NONE;
            }
            return direction;
        };
        IgxGridDragSelectDirective.prototype.unsubscribe = function () {
            if (this._sub) {
                this._sub.unsubscribe();
            }
        };
        return IgxGridDragSelectDirective;
    }());
    IgxGridDragSelectDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxGridDragSelect]'
                },] }
    ];
    IgxGridDragSelectDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.NgZone }
    ]; };
    IgxGridDragSelectDirective.propDecorators = {
        onDragStop: [{ type: i0.Output }],
        onDragScroll: [{ type: i0.Output }],
        activeDrag: [{ type: i0.Input, args: ['igxGridDragSelect',] }]
    };

    /**
     * @hidden
     */
    var IgxTemplateOutletDirective = /** @class */ (function () {
        function IgxTemplateOutletDirective(_viewContainerRef, _zone, cdr) {
            this._viewContainerRef = _viewContainerRef;
            this._zone = _zone;
            this.cdr = cdr;
            this.onViewCreated = new i0.EventEmitter();
            this.onViewMoved = new i0.EventEmitter();
            this.onCachedViewLoaded = new i0.EventEmitter();
            this.onBeforeViewDetach = new i0.EventEmitter();
            /**
             * The embedded views cache. Collection is key-value paired.
             * Key is the template id, value is the embedded view for the related template.
             */
            this._embeddedViewsMap = new Map();
        }
        IgxTemplateOutletDirective.prototype.ngOnChanges = function (changes) {
            var actionType = this._getActionType(changes);
            switch (actionType) {
                case TemplateOutletAction.CreateView:
                    this._recreateView();
                    break;
                case TemplateOutletAction.MoveView:
                    this._moveView();
                    break;
                case TemplateOutletAction.UseCachedView:
                    this._useCachedView();
                    break;
                case TemplateOutletAction.UpdateViewContext:
                    this._updateExistingContext(this.igxTemplateOutletContext);
                    break;
            }
        };
        IgxTemplateOutletDirective.prototype.cleanCache = function () {
            this._embeddedViewsMap.forEach(function (item) {
                if (!item.destroyed) {
                    item.destroy();
                }
            });
            this._embeddedViewsMap.clear();
        };
        IgxTemplateOutletDirective.prototype.cleanView = function (tmplID) {
            var embView = this._embeddedViewsMap.get(tmplID);
            if (embView) {
                embView.destroy();
                this._embeddedViewsMap.delete(tmplID);
            }
        };
        IgxTemplateOutletDirective.prototype._recreateView = function () {
            var prevIndex = this._viewRef ? this._viewContainerRef.indexOf(this._viewRef) : -1;
            // detach old and create new
            if (prevIndex !== -1) {
                this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                this._viewContainerRef.detach(prevIndex);
            }
            if (this.igxTemplateOutlet) {
                this._viewRef = this._viewContainerRef.createEmbeddedView(this.igxTemplateOutlet, this.igxTemplateOutletContext);
                this.onViewCreated.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                var tmplId = this.igxTemplateOutletContext['templateID'];
                if (tmplId) {
                    // if context contains a template id, check if we have a view for that template already stored in the cache
                    // if not create a copy and add it to the cache in detached state.
                    // Note: Views in detached state do not appear in the DOM, however they remain stored in memory.
                    var res = this._embeddedViewsMap.get(this.igxTemplateOutletContext['templateID']);
                    if (!res) {
                        this._embeddedViewsMap.set(this.igxTemplateOutletContext['templateID'], this._viewRef);
                    }
                }
            }
        };
        IgxTemplateOutletDirective.prototype._moveView = function () {
            // using external view and inserting it in current view.
            var view = this.igxTemplateOutletContext['moveView'];
            var owner = this.igxTemplateOutletContext['owner'];
            if (view !== this._viewRef) {
                if (owner._viewContainerRef.indexOf(view) !== -1) {
                    // detach in case view it is attached somewhere else at the moment.
                    this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                    owner._viewContainerRef.detach(owner._viewContainerRef.indexOf(view));
                }
                if (this._viewRef && this._viewContainerRef.indexOf(this._viewRef) !== -1) {
                    this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                    this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
                }
                this._viewRef = view;
                this._viewContainerRef.insert(view, 0);
                this._updateExistingContext(this.igxTemplateOutletContext);
                this.onViewMoved.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
            }
            else {
                this._updateExistingContext(this.igxTemplateOutletContext);
            }
        };
        IgxTemplateOutletDirective.prototype._useCachedView = function () {
            // use view for specific template cached in the current template outlet
            var tmplID = this.igxTemplateOutletContext['templateID'];
            var cachedView = tmplID ?
                this._embeddedViewsMap.get(tmplID) :
                null;
            // if view exists, but template has been changed and there is a view in the cache with the related template
            // then detach old view and insert the stored one with the matching template
            // after that update its context.
            if (this._viewContainerRef.length > 0) {
                this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
            }
            this._viewRef = cachedView;
            var oldContext = this._cloneContext(cachedView.context);
            this._viewContainerRef.insert(this._viewRef, 0);
            this._updateExistingContext(this.igxTemplateOutletContext);
            this.onCachedViewLoaded.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext, oldContext: oldContext });
        };
        IgxTemplateOutletDirective.prototype._shouldRecreateView = function (changes) {
            var ctxChange = changes['igxTemplateOutletContext'];
            return !!changes['igxTemplateOutlet'] || (ctxChange && this._hasContextShapeChanged(ctxChange));
        };
        IgxTemplateOutletDirective.prototype._hasContextShapeChanged = function (ctxChange) {
            var e_1, _a;
            var prevCtxKeys = Object.keys(ctxChange.previousValue || {});
            var currCtxKeys = Object.keys(ctxChange.currentValue || {});
            if (prevCtxKeys.length === currCtxKeys.length) {
                try {
                    for (var currCtxKeys_1 = __values(currCtxKeys), currCtxKeys_1_1 = currCtxKeys_1.next(); !currCtxKeys_1_1.done; currCtxKeys_1_1 = currCtxKeys_1.next()) {
                        var propName = currCtxKeys_1_1.value;
                        if (prevCtxKeys.indexOf(propName) === -1) {
                            return true;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (currCtxKeys_1_1 && !currCtxKeys_1_1.done && (_a = currCtxKeys_1.return)) _a.call(currCtxKeys_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return false;
            }
            else {
                return true;
            }
        };
        IgxTemplateOutletDirective.prototype._updateExistingContext = function (ctx) {
            var e_2, _a;
            try {
                for (var _b = __values(Object.keys(ctx)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var propName = _c.value;
                    this._viewRef.context[propName] = this.igxTemplateOutletContext[propName];
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        IgxTemplateOutletDirective.prototype._cloneContext = function (ctx) {
            var e_3, _a;
            var clone = {};
            try {
                for (var _b = __values(Object.keys(ctx)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var propName = _c.value;
                    clone[propName] = ctx[propName];
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return clone;
        };
        IgxTemplateOutletDirective.prototype._getActionType = function (changes) {
            var movedView = this.igxTemplateOutletContext['moveView'];
            var tmplID = this.igxTemplateOutletContext['templateID'];
            var cachedView = tmplID ?
                this._embeddedViewsMap.get(tmplID) :
                null;
            var shouldRecreate = this._shouldRecreateView(changes);
            if (movedView) {
                // view is moved from external source
                return TemplateOutletAction.MoveView;
            }
            else if (shouldRecreate && cachedView) {
                // should recreate (template or context change) and there is a matching template in cache
                return TemplateOutletAction.UseCachedView;
            }
            else if (!this._viewRef || shouldRecreate) {
                // no view or should recreate
                return TemplateOutletAction.CreateView;
            }
            else if (this.igxTemplateOutletContext) {
                // has context, update context
                return TemplateOutletAction.UpdateViewContext;
            }
        };
        return IgxTemplateOutletDirective;
    }());
    IgxTemplateOutletDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[igxTemplateOutlet]' },] }
    ];
    IgxTemplateOutletDirective.ctorParameters = function () { return [
        { type: i0.ViewContainerRef },
        { type: i0.NgZone },
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxTemplateOutletDirective.propDecorators = {
        igxTemplateOutletContext: [{ type: i0.Input }],
        igxTemplateOutlet: [{ type: i0.Input }],
        onViewCreated: [{ type: i0.Output }],
        onViewMoved: [{ type: i0.Output }],
        onCachedViewLoaded: [{ type: i0.Output }],
        onBeforeViewDetach: [{ type: i0.Output }]
    };
    var TemplateOutletAction;
    (function (TemplateOutletAction) {
        TemplateOutletAction[TemplateOutletAction["CreateView"] = 0] = "CreateView";
        TemplateOutletAction[TemplateOutletAction["MoveView"] = 1] = "MoveView";
        TemplateOutletAction[TemplateOutletAction["UseCachedView"] = 2] = "UseCachedView";
        TemplateOutletAction[TemplateOutletAction["UpdateViewContext"] = 3] = "UpdateViewContext";
    })(TemplateOutletAction || (TemplateOutletAction = {}));
    /**
     * @hidden
     */
    var IgxTemplateOutletModule = /** @class */ (function () {
        function IgxTemplateOutletModule() {
        }
        return IgxTemplateOutletModule;
    }());
    IgxTemplateOutletModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxTemplateOutletDirective],
                    entryComponents: [],
                    exports: [IgxTemplateOutletDirective],
                    imports: [i2.CommonModule]
                },] }
    ];

    /**
     * @hidden
     * @internal
     */
    var IgxColumnResizerDirective = /** @class */ (function () {
        function IgxColumnResizerDirective(element, document, zone) {
            var _this = this;
            this.element = element;
            this.document = document;
            this.zone = zone;
            this.restrictHResizeMin = Number.MIN_SAFE_INTEGER;
            this.restrictHResizeMax = Number.MAX_SAFE_INTEGER;
            this.resizeEnd = new rxjs.Subject();
            this.resizeStart = new rxjs.Subject();
            // eslint-disable-next-line @angular-eslint/no-output-native
            this.resize = new rxjs.Subject();
            this._destroy = new rxjs.Subject();
            this.resizeStart.pipe(operators.map(function (event) { return event.clientX; }), operators.takeUntil(this._destroy), operators.switchMap(function (offset) { return _this.resize.pipe(operators.map(function (event) { return event.clientX - offset; }), operators.takeUntil(_this.resizeEnd), operators.takeUntil(_this._destroy)); })).subscribe(function (pos) {
                var left = _this._left + pos;
                var min = _this._left - _this.restrictHResizeMin;
                var max = _this._left + _this.restrictHResizeMax;
                _this.left = left < min ? min : left;
                if (left > max) {
                    _this.left = max;
                }
            });
        }
        IgxColumnResizerDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                rxjs.fromEvent(_this.document.defaultView, 'mousemove').pipe(operators.throttle(function () { return rxjs.interval(0, rxjs.animationFrameScheduler); }), operators.takeUntil(_this._destroy)).subscribe(function (res) { return _this.onMousemove(res); });
                rxjs.fromEvent(_this.document.defaultView, 'mouseup').pipe(operators.takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onMouseup(res); });
            });
        };
        IgxColumnResizerDirective.prototype.ngOnDestroy = function () {
            this._destroy.next(true);
            this._destroy.complete();
        };
        Object.defineProperty(IgxColumnResizerDirective.prototype, "left", {
            set: function (val) {
                var _this = this;
                requestAnimationFrame(function () { return _this.element.nativeElement.style.left = val + 'px'; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnResizerDirective.prototype, "top", {
            set: function (val) {
                var _this = this;
                requestAnimationFrame(function () { return _this.element.nativeElement.style.top = val + 'px'; });
            },
            enumerable: false,
            configurable: true
        });
        IgxColumnResizerDirective.prototype.onMouseup = function (event) {
            this.resizeEnd.next(event);
            this.resizeEnd.complete();
        };
        IgxColumnResizerDirective.prototype.onMousedown = function (event) {
            event.preventDefault();
            var parent = this.element.nativeElement.parentElement.parentElement;
            this.left = this._left = event.clientX - parent.getBoundingClientRect().left;
            this.top = event.target.getBoundingClientRect().top - parent.getBoundingClientRect().top;
            this.resizeStart.next(event);
        };
        IgxColumnResizerDirective.prototype.onMousemove = function (event) {
            event.preventDefault();
            this.resize.next(event);
        };
        return IgxColumnResizerDirective;
    }());
    IgxColumnResizerDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxResizer]'
                },] }
    ];
    IgxColumnResizerDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: i0.NgZone }
    ]; };
    IgxColumnResizerDirective.propDecorators = {
        restrictHResizeMin: [{ type: i0.Input }],
        restrictHResizeMax: [{ type: i0.Input }],
        resizeEnd: [{ type: i0.Output }],
        resizeStart: [{ type: i0.Output }],
        resize: [{ type: i0.Output }]
    };

    var IgxGridColumnResizerComponent = /** @class */ (function () {
        function IgxGridColumnResizerComponent(colResizingService) {
            this.colResizingService = colResizingService;
        }
        return IgxGridColumnResizerComponent;
    }());
    IgxGridColumnResizerComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-column-resizer',
                    template: "<div class=\"igx-grid__th-resize-line\"\n    [style.left.px]=\"-99999\" igxResizer\n    [style.height.px]=\"colResizingService.resizerHeight\"\n    [restrictHResizeMax]=\"colResizingService.restrictResizeMax\"\n    [restrictHResizeMin]=\"colResizingService.restrictResizeMin\"\n    (resizeEnd)=\"colResizingService.resizeColumn($event)\">\n</div>\n"
                },] }
    ];
    IgxGridColumnResizerComponent.ctorParameters = function () { return [
        { type: IgxColumnResizingService }
    ]; };
    IgxGridColumnResizerComponent.propDecorators = {
        resizer: [{ type: i0.ViewChild, args: [IgxColumnResizerDirective, { static: true },] }]
    };

    /**
     * @hidden
     */
    var IgxGridFilteringRowComponent = /** @class */ (function () {
        function IgxGridFilteringRowComponent(filteringService, element, cdr) {
            this.filteringService = filteringService;
            this.element = element;
            this.cdr = cdr;
            this._positionSettings = {
                horizontalStartPoint: exports.HorizontalAlignment.Left,
                verticalStartPoint: exports.VerticalAlignment.Bottom
            };
            this._conditionsOverlaySettings = {
                closeOnOutsideClick: true,
                modal: false,
                scrollStrategy: new AbsoluteScrollStrategy(),
                positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
            };
            this._operatorsOverlaySettings = {
                closeOnOutsideClick: true,
                modal: false,
                scrollStrategy: new AbsoluteScrollStrategy(),
                positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
            };
            this.chipAreaScrollOffset = 0;
            this._column = null;
            this.isKeyPressed = false;
            this.isComposing = false;
            this._cancelChipClick = false;
        }
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "column", {
            get: function () {
                return this._column;
            },
            set: function (val) {
                if (this._column) {
                    this.expressionsList.forEach(function (exp) { return exp.isSelected = false; });
                }
                if (val) {
                    this._column = val;
                    this.expressionsList = this.filteringService.getExpressions(this._column.field);
                    this.resetExpression();
                    this.chipAreaScrollOffset = 0;
                    this.transform(this.chipAreaScrollOffset);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "value", {
            get: function () {
                return this.expression ? this.expression.searchVal : null;
            },
            set: function (val) {
                var _this = this;
                if (!val && val !== 0) {
                    this.expression.searchVal = null;
                    this.showHideArrowButtons();
                }
                else {
                    this.expression.searchVal = DataUtil.parseValue(this.column.dataType, val);
                    if (this.expressionsList.find(function (item) { return item.expression === _this.expression; }) === undefined) {
                        this.addExpression(true);
                    }
                }
                this.filter();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "displayDensity", {
            get: function () {
                return this.column.grid.displayDensity === DisplayDensity.comfortable ? DisplayDensity.cosy : this.column.grid.displayDensity;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "styleClasses", {
            get: function () {
                var classes = 'igx-grid__filtering-row';
                switch (this.column.grid.displayDensity) {
                    case DisplayDensity.compact:
                        classes = classes + ' igx-grid__filtering-row--compact';
                        break;
                    case DisplayDensity.cosy:
                        classes = classes + ' igx-grid__filtering-row--cosy';
                        break;
                }
                return classes;
            },
            enumerable: false,
            configurable: true
        });
        IgxGridFilteringRowComponent.prototype.onKeydownHandler = function (evt) {
            if (evt.key === "Escape" /* ESCAPE */ || evt.key === "Esc" /* ESCAPE_IE */ ||
                evt.ctrlKey && evt.shiftKey && evt.key.toLowerCase() === 'l') {
                evt.preventDefault();
                evt.stopPropagation();
                this.close();
            }
        };
        IgxGridFilteringRowComponent.prototype.ngAfterViewInit = function () {
            this._conditionsOverlaySettings.outlet = this.column.grid.outlet;
            this._operatorsOverlaySettings.outlet = this.column.grid.outlet;
            var selectedItem = this.expressionsList.find(function (expr) { return expr.isSelected === true; });
            if (selectedItem) {
                this.expression = selectedItem.expression;
            }
            this.input.nativeElement.focus();
        };
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "disabled", {
            get: function () {
                return !(this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "template", {
            get: function () {
                if (this.column.dataType === DataType.Date) {
                    return this.defaultDateUI;
                }
                return this.defaultFilterUI;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "type", {
            get: function () {
                switch (this.column.dataType) {
                    case DataType.String:
                    case DataType.Boolean:
                        return 'text';
                    case DataType.Number:
                    case DataType.Currency:
                        return 'number';
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "conditions", {
            get: function () {
                return this.column.filters.conditionList();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "isUnaryCondition", {
            get: function () {
                if (this.expression.condition) {
                    return this.expression.condition.isUnary;
                }
                else {
                    return true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "placeholder", {
            get: function () {
                if (this.expression.condition && this.expression.condition.isUnary) {
                    return this.filteringService.getChipLabel(this.expression);
                }
                else if (this.column.dataType === DataType.Date) {
                    return this.filteringService.grid.resourceStrings.igx_grid_filter_row_date_placeholder;
                }
                else if (this.column.dataType === DataType.Boolean) {
                    return this.filteringService.grid.resourceStrings.igx_grid_filter_row_boolean_placeholder;
                }
                else {
                    return this.filteringService.grid.resourceStrings.igx_grid_filter_row_placeholder;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Event handler for keydown on the input group's prefix.
         */
        IgxGridFilteringRowComponent.prototype.onPrefixKeyDown = function (event) {
            if ((event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) && this.dropDownConditions.collapsed) {
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
                event.stopImmediatePropagation();
            }
            else if (event.key === "Tab" /* TAB */ && !this.dropDownConditions.collapsed) {
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
            }
        };
        /**
         * Event handler for keydown on the input.
         */
        IgxGridFilteringRowComponent.prototype.onInputKeyDown = function (event) {
            this.isKeyPressed = true;
            event.stopPropagation();
            if (this.column.dataType === DataType.Boolean) {
                if (event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) {
                    this.inputGroupPrefix.nativeElement.focus();
                    this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
                    return;
                }
            }
            if (event.key === "Enter" /* ENTER */) {
                if (this.isComposing) {
                    return;
                }
                this.commitInput();
            }
            else if (event.altKey && (event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */)) {
                this.inputGroupPrefix.nativeElement.focus();
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
            }
            else if (event.key === "Escape" /* ESCAPE */ || event.key === "Esc" /* ESCAPE_IE */ ||
                event.ctrlKey && event.shiftKey && event.key.toLowerCase() === 'l') {
                this.close();
            }
        };
        /**
         * Event handler for keyup on the input.
         */
        IgxGridFilteringRowComponent.prototype.onInputKeyUp = function () {
            this.isKeyPressed = false;
        };
        /**
         * Event handler for input on the input.
         */
        IgxGridFilteringRowComponent.prototype.onInput = function (eventArgs) {
            // The 'iskeyPressed' flag is needed for a case in IE, because the input event is fired on focus and for some reason,
            // when you have a japanese character as a placeholder, on init the value here is empty string .
            var target = eventArgs.target;
            if (isEdge() && target.type !== 'number' || this.isKeyPressed && isIE() || target.value || target.checkValidity()) {
                this.value = target.value;
            }
        };
        /**
         * Event handler for compositionstart on the input.
         */
        IgxGridFilteringRowComponent.prototype.onCompositionStart = function () {
            this.isComposing = true;
        };
        /**
         * Event handler for compositionend on the input.
         */
        IgxGridFilteringRowComponent.prototype.onCompositionEnd = function () {
            this.isComposing = false;
        };
        /**
         * Event handler for input click event.
         */
        IgxGridFilteringRowComponent.prototype.onInputClick = function () {
            if (this.column.dataType === DataType.Boolean && this.dropDownConditions.collapsed) {
                this.inputGroupPrefix.nativeElement.focus();
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
            }
        };
        /**
         * Event handler for datepicker's close.
         */
        IgxGridFilteringRowComponent.prototype.datePickerClose = function () {
            this.input.nativeElement.focus();
        };
        /**
         * Returns the filtering operation condition for a given value.
         */
        IgxGridFilteringRowComponent.prototype.getCondition = function (value) {
            return this.column.filters.condition(value);
        };
        /**
         * Returns the translated condition name for a given value.
         */
        IgxGridFilteringRowComponent.prototype.translateCondition = function (value) {
            return this.filteringService.grid.resourceStrings["igx_grid_filter_" + this.getCondition(value).name] || value;
        };
        /**
         * Returns the icon name of the current condition.
         */
        IgxGridFilteringRowComponent.prototype.getIconName = function () {
            if (this.column.dataType === DataType.Boolean && this.expression.condition === null) {
                return this.getCondition(this.conditions[0]).iconName;
            }
            else {
                return this.expression.condition.iconName;
            }
        };
        /**
         * Returns whether a given condition is selected in dropdown.
         */
        IgxGridFilteringRowComponent.prototype.isConditionSelected = function (conditionName) {
            if (this.expression.condition) {
                return this.expression.condition.name === conditionName;
            }
            else {
                return false;
            }
        };
        /**
         * Clears the current filtering.
         */
        IgxGridFilteringRowComponent.prototype.clearFiltering = function () {
            this.filteringService.clearFilter(this.column.field);
            this.resetExpression();
            if (this.input) {
                this.input.nativeElement.focus();
            }
            this.cdr.detectChanges();
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
        };
        /**
         * Commits the value of the input.
         */
        IgxGridFilteringRowComponent.prototype.commitInput = function () {
            var selectedItem = this.expressionsList.filter(function (ex) { return ex.isSelected === true; });
            selectedItem.forEach(function (e) { return e.isSelected = false; });
            var indexToDeselect = -1;
            for (var index = 0; index < this.expressionsList.length; index++) {
                var expression = this.expressionsList[index].expression;
                if (expression.searchVal === null && !expression.condition.isUnary) {
                    indexToDeselect = index;
                }
            }
            if (indexToDeselect !== -1) {
                this.removeExpression(indexToDeselect, this.expression);
            }
            this.resetExpression();
            this.scrollChipsWhenAddingExpression();
        };
        /**
         * Clears the value of the input.
         */
        IgxGridFilteringRowComponent.prototype.clearInput = function () {
            this.value = null;
        };
        /**
         * Event handler for keydown on clear button.
         */
        IgxGridFilteringRowComponent.prototype.onClearKeyDown = function (eventArgs) {
            if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
                eventArgs.preventDefault();
                this.clearInput();
                this.input.nativeElement.focus();
            }
        };
        /**
         * Event handler for click on clear button.
         */
        IgxGridFilteringRowComponent.prototype.onClearClick = function () {
            this.clearInput();
            this.input.nativeElement.focus();
        };
        /**
         * Event handler for keydown on commit button.
         */
        IgxGridFilteringRowComponent.prototype.onCommitKeyDown = function (eventArgs) {
            if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
                eventArgs.preventDefault();
                this.commitInput();
                this.input.nativeElement.focus();
            }
        };
        /**
         * Event handler for click on commit button.
         */
        IgxGridFilteringRowComponent.prototype.onCommitClick = function () {
            this.commitInput();
            this.input.nativeElement.focus();
        };
        /**
         * Event handler for focusout on the input group.
         */
        IgxGridFilteringRowComponent.prototype.onInputGroupFocusout = function () {
            var _this = this;
            if (!this.value && this.value !== 0 &&
                this.expression.condition && !this.expression.condition.isUnary) {
                return;
            }
            requestAnimationFrame(function () {
                var focusedElement = document.activeElement;
                if (focusedElement.classList.contains('igx-chip__remove') || focusedElement.tagName === 'IGX-DAY-ITEM') {
                    return;
                }
                if (!(focusedElement && _this.inputGroup.nativeElement.contains(focusedElement))
                    && _this.dropDownConditions.collapsed) {
                    _this.commitInput();
                }
            });
        };
        /**
         * Closes the filtering edit row.
         */
        IgxGridFilteringRowComponent.prototype.close = function () {
            var _this = this;
            if (this.expressionsList.length === 1 &&
                this.expressionsList[0].expression.searchVal === null &&
                this.expressionsList[0].expression.condition.isUnary === false) {
                this.filteringService.getExpressions(this.column.field).pop();
                this.filter();
            }
            else {
                var condToRemove = this.expressionsList.filter(function (ex) { return ex.expression.searchVal === null && !ex.expression.condition.isUnary; });
                if (condToRemove && condToRemove.length > 0) {
                    condToRemove.forEach(function (c) { return _this.filteringService.removeExpression(_this.column.field, _this.expressionsList.indexOf(c)); });
                    this.filter();
                }
            }
            this.filteringService.isFilterRowVisible = false;
            this.filteringService.updateFilteringCell(this.column);
            this.filteringService.filteredColumn = null;
            this.filteringService.selectedExpression = null;
            this.filteringService.grid.theadRow.nativeElement.focus();
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
        };
        /**
         *  Event handler for date picker's selection.
         */
        IgxGridFilteringRowComponent.prototype.onDateSelected = function (value) {
            this.value = value;
        };
        /** @hidden @internal */
        IgxGridFilteringRowComponent.prototype.inputGroupPrefixClick = function (event) {
            event.stopPropagation();
            event.currentTarget.focus();
            this.toggleConditionsDropDown(event.currentTarget);
        };
        /**
         * Opens the conditions dropdown.
         */
        IgxGridFilteringRowComponent.prototype.toggleConditionsDropDown = function (target) {
            this._conditionsOverlaySettings.target = target;
            this._conditionsOverlaySettings.excludeFromOutsideClick = [target];
            this.dropDownConditions.toggle(this._conditionsOverlaySettings);
        };
        /**
         * Opens the logic operators dropdown.
         */
        IgxGridFilteringRowComponent.prototype.toggleOperatorsDropDown = function (eventArgs, index) {
            this._operatorsOverlaySettings.target = eventArgs.target.parentElement;
            this._operatorsOverlaySettings.excludeFromOutsideClick = [eventArgs.target.parentElement];
            this.dropDownOperators.toArray()[index].toggle(this._operatorsOverlaySettings);
        };
        /**
         * Event handler for change event in conditions dropdown.
         */
        IgxGridFilteringRowComponent.prototype.onConditionsChanged = function (eventArgs) {
            var _this = this;
            var value = eventArgs.newSelection.value;
            this.expression.condition = this.getCondition(value);
            if (this.expression.condition.isUnary) {
                // update grid's filtering on the next cycle to ensure the drop-down is closed
                // if the drop-down is not closed this event handler will be invoked multiple times
                requestAnimationFrame(function () { return _this.unaryConditionChangedCallback(); });
            }
            else {
                requestAnimationFrame(function () { return _this.conditionChangedCallback(); });
            }
            if (this.input) {
                // Add requestAnimationFrame becasue of an issue in IE, where you are still able to write in the input,
                // if it has been focused and then set to readonly.
                requestAnimationFrame(function () { return _this.input.nativeElement.focus(); });
            }
        };
        IgxGridFilteringRowComponent.prototype.onChipPointerdown = function (args, chip) {
            var activeElement = document.activeElement;
            this._cancelChipClick = chip.selected && activeElement &&
                this.inputGroup.nativeElement.contains(activeElement);
        };
        IgxGridFilteringRowComponent.prototype.onChipClick = function (args, item) {
            if (this._cancelChipClick) {
                this._cancelChipClick = false;
                return;
            }
            this.expressionsList.forEach(function (ex) { return ex.isSelected = false; });
            this.toggleChip(item);
        };
        IgxGridFilteringRowComponent.prototype.toggleChip = function (item) {
            item.isSelected = !item.isSelected;
            if (item.isSelected) {
                this.expression = item.expression;
                if (this.input) {
                    this.input.nativeElement.focus();
                }
            }
        };
        /**
         * Event handler for chip keydown event.
         */
        IgxGridFilteringRowComponent.prototype.onChipKeyDown = function (eventArgs, item) {
            if (eventArgs.key === "Enter" /* ENTER */) {
                eventArgs.preventDefault();
                this.toggleChip(item);
            }
        };
        /**
         * Scrolls the first chip into view if the tab key is pressed on the left arrow.
         */
        IgxGridFilteringRowComponent.prototype.onLeftArrowKeyDown = function (event) {
            if (event.key === "Tab" /* TAB */) {
                this.chipAreaScrollOffset = 0;
                this.transform(this.chipAreaScrollOffset);
            }
        };
        /**
         * Event handler for chip removed event.
         */
        IgxGridFilteringRowComponent.prototype.onChipRemoved = function (eventArgs, item) {
            var indexToRemove = this.expressionsList.indexOf(item);
            this.removeExpression(indexToRemove, item.expression);
            this.scrollChipsOnRemove();
        };
        /**
         * Event handler for logic operator changed event.
         */
        IgxGridFilteringRowComponent.prototype.onLogicOperatorChanged = function (eventArgs, expression) {
            var _this = this;
            if (eventArgs.oldSelection) {
                expression.afterOperator = eventArgs.newSelection.value;
                this.expressionsList[this.expressionsList.indexOf(expression) + 1].beforeOperator = expression.afterOperator;
                // update grid's filtering on the next cycle to ensure the drop-down is closed
                // if the drop-down is not closed this event handler will be invoked multiple times
                requestAnimationFrame(function () { return _this.filter(); });
            }
        };
        /**
         * Scrolls the chips into the chip area when left or right arrows are pressed.
         */
        IgxGridFilteringRowComponent.prototype.scrollChipsOnArrowPress = function (arrowPosition) {
            var e_1, _a, e_2, _b;
            var count = 0;
            var chipAraeChildren = this.chipsArea.element.nativeElement.children;
            var containerRect = this.container.nativeElement.getBoundingClientRect();
            if (arrowPosition === 'right') {
                try {
                    for (var chipAraeChildren_1 = __values(chipAraeChildren), chipAraeChildren_1_1 = chipAraeChildren_1.next(); !chipAraeChildren_1_1.done; chipAraeChildren_1_1 = chipAraeChildren_1.next()) {
                        var chip = chipAraeChildren_1_1.value;
                        if (Math.ceil(chip.getBoundingClientRect().right) < Math.ceil(containerRect.right)) {
                            count++;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (chipAraeChildren_1_1 && !chipAraeChildren_1_1.done && (_a = chipAraeChildren_1.return)) _a.call(chipAraeChildren_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (count < chipAraeChildren.length) {
                    this.chipAreaScrollOffset -= Math.ceil(chipAraeChildren[count].getBoundingClientRect().right) -
                        Math.ceil(containerRect.right) + 1;
                    this.transform(this.chipAreaScrollOffset);
                }
            }
            if (arrowPosition === 'left') {
                try {
                    for (var chipAraeChildren_2 = __values(chipAraeChildren), chipAraeChildren_2_1 = chipAraeChildren_2.next(); !chipAraeChildren_2_1.done; chipAraeChildren_2_1 = chipAraeChildren_2.next()) {
                        var chip = chipAraeChildren_2_1.value;
                        if (Math.ceil(chip.getBoundingClientRect().left) < Math.ceil(containerRect.left)) {
                            count++;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (chipAraeChildren_2_1 && !chipAraeChildren_2_1.done && (_b = chipAraeChildren_2.return)) _b.call(chipAraeChildren_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                if (count > 0) {
                    this.chipAreaScrollOffset += Math.ceil(containerRect.left) -
                        Math.ceil(chipAraeChildren[count - 1].getBoundingClientRect().left) + 1;
                    this.transform(this.chipAreaScrollOffset);
                }
            }
        };
        /**
         * @hidden
         * Resets the chips area
         * @memberof IgxGridFilteringRowComponent
         */
        IgxGridFilteringRowComponent.prototype.resetChipsArea = function () {
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
            this.showHideArrowButtons();
        };
        IgxGridFilteringRowComponent.prototype.showHideArrowButtons = function () {
            var _this = this;
            requestAnimationFrame(function () {
                if (_this.filteringService.isFilterRowVisible) {
                    var containerWidth = _this.container.nativeElement.getBoundingClientRect().width;
                    _this.chipsAreaWidth = _this.chipsArea.element.nativeElement.getBoundingClientRect().width;
                    _this.showArrows = _this.chipsAreaWidth >= containerWidth && _this.isColumnFiltered;
                    // TODO: revise the cdr.detectChanges() usage here
                    if (!_this.cdr.destroyed) {
                        _this.cdr.detectChanges();
                    }
                }
            });
        };
        IgxGridFilteringRowComponent.prototype.addExpression = function (isSelected) {
            var exprUI = new ExpressionUI();
            exprUI.expression = this.expression;
            exprUI.beforeOperator = this.expressionsList.length > 0 ? exports.FilteringLogic.And : null;
            exprUI.isSelected = isSelected;
            this.expressionsList.push(exprUI);
            var length = this.expressionsList.length;
            if (this.expressionsList[length - 2]) {
                this.expressionsList[length - 2].afterOperator = this.expressionsList[length - 1].beforeOperator;
            }
            this.showHideArrowButtons();
        };
        IgxGridFilteringRowComponent.prototype.removeExpression = function (indexToRemove, expression) {
            if (indexToRemove === 0 && this.expressionsList.length === 1) {
                this.clearFiltering();
                return;
            }
            this.filteringService.removeExpression(this.column.field, indexToRemove);
            this.filter();
            if (this.expression === expression) {
                this.resetExpression();
            }
            this.showHideArrowButtons();
        };
        IgxGridFilteringRowComponent.prototype.resetExpression = function () {
            this.expression = {
                fieldName: this.column.field,
                condition: null,
                searchVal: null,
                ignoreCase: this.column.filteringIgnoreCase
            };
            if (this.column.dataType !== DataType.Boolean) {
                this.expression.condition = this.getCondition(this.conditions[0]);
            }
            if (this.column.dataType === DataType.Date && this.input) {
                this.input.nativeElement.value = null;
            }
            this.showHideArrowButtons();
        };
        IgxGridFilteringRowComponent.prototype.scrollChipsWhenAddingExpression = function () {
            var chipAraeChildren = this.chipsArea.element.nativeElement.children;
            if (!chipAraeChildren || chipAraeChildren.length === 0) {
                return;
            }
            var containerRectRight = Math.ceil(this.container.nativeElement.getBoundingClientRect().right);
            var lastChipRectRight = Math.ceil(chipAraeChildren[chipAraeChildren.length - 1].getBoundingClientRect().right);
            if (lastChipRectRight >= containerRectRight) {
                this.chipAreaScrollOffset -= lastChipRectRight - containerRectRight;
                this.transform(this.chipAreaScrollOffset);
            }
        };
        IgxGridFilteringRowComponent.prototype.transform = function (offset) {
            var _this = this;
            requestAnimationFrame(function () {
                _this.chipsArea.element.nativeElement.style.transform = "translate(" + offset + "px)";
            });
        };
        IgxGridFilteringRowComponent.prototype.scrollChipsOnRemove = function () {
            var e_3, _a;
            var count = 0;
            var chipAraeChildren = this.chipsArea.element.nativeElement.children;
            var containerRect = this.container.nativeElement.getBoundingClientRect();
            try {
                for (var chipAraeChildren_3 = __values(chipAraeChildren), chipAraeChildren_3_1 = chipAraeChildren_3.next(); !chipAraeChildren_3_1.done; chipAraeChildren_3_1 = chipAraeChildren_3.next()) {
                    var chip = chipAraeChildren_3_1.value;
                    if (Math.ceil(chip.getBoundingClientRect().right) < Math.ceil(containerRect.left)) {
                        count++;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (chipAraeChildren_3_1 && !chipAraeChildren_3_1.done && (_a = chipAraeChildren_3.return)) _a.call(chipAraeChildren_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (count <= 2) {
                this.chipAreaScrollOffset = 0;
            }
            else {
                var dif = chipAraeChildren[count].id === 'chip' ? count - 2 : count - 1;
                this.chipAreaScrollOffset += Math.ceil(containerRect.left) - Math.ceil(chipAraeChildren[dif].getBoundingClientRect().left) + 1;
            }
            this.transform(this.chipAreaScrollOffset);
        };
        IgxGridFilteringRowComponent.prototype.conditionChangedCallback = function () {
            if (!!this.expression.searchVal || this.expression.searchVal === 0) {
                this.filter();
            }
            else if (this.value) {
                this.value = null;
            }
        };
        IgxGridFilteringRowComponent.prototype.unaryConditionChangedCallback = function () {
            var _this = this;
            if (this.value) {
                this.value = null;
            }
            if (this.expressionsList.find(function (item) { return item.expression === _this.expression; }) === undefined) {
                this.addExpression(true);
            }
            this.filter();
        };
        IgxGridFilteringRowComponent.prototype.filter = function () {
            this.filteringService.filterInternal(this.column.field);
        };
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "isColumnFiltered", {
            get: function () {
                return this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "isNarrowWidth", {
            get: function () {
                return this.element.nativeElement.offsetWidth < 432;
            },
            enumerable: false,
            configurable: true
        });
        return IgxGridFilteringRowComponent;
    }());
    IgxGridFilteringRowComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-filtering-row',
                    template: "<!-- Have to apply styles inline because of the overlay outlet ... -->\n<igx-drop-down #inputGroupConditions [displayDensity]=\"displayDensity\" [height]=\"'200px'\" (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\"\n        [value]=\"condition\"\n        [selected]=\"isConditionSelected(condition)\">\n        <div class=\"igx-grid__filtering-dropdown-items\">\n            <igx-icon family=\"imx-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n            <span class=\"igx-grid__filtering-dropdown-text\">{{ translateCondition(condition) }}</span>\n        </div>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<ng-template #defaultFilterUI>\n    <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"displayDensity\" (focusout)=\"onInputGroupFocusout()\">\n        <igx-prefix #inputGroupPrefix\n                    (click)=\"inputGroupPrefixClick($event)\"\n                    (keydown)=\"onPrefixKeyDown($event)\"\n                    tabindex=\"0\"\n                    [igxDropDownItemNavigation]=\"inputGroupConditions\">\n            <igx-icon family=\"imx-icons\" [name]=\"getIconName()\"></igx-icon>\n        </igx-prefix>\n        <input\n            #input\n            igxInput\n            tabindex=\"0\"\n            [placeholder]=\"placeholder\"\n            autocomplete=\"off\"\n            [value]=\"value\"\n            (input)=\"onInput($event)\"\n            [type]=\"type\"\n            [readonly]=\"isUnaryCondition\"\n            (click)=\"onInputClick()\"\n            (compositionstart)=\"onCompositionStart()\"\n            (compositionend)=\"onCompositionEnd()\"\n            (keydown)=\"onInputKeyDown($event)\"\n            (keyup)=\"onInputKeyUp()\"/>\n            <igx-suffix *ngIf=\"value || value === 0\" >\n                <igx-icon (keydown)=\"onCommitKeyDown($event)\" (click)=\"onCommitClick()\" tabindex=\"0\">done</igx-icon>\n                <igx-icon (keydown)=\"onClearKeyDown($event)\" (click)=\"onClearClick()\" tabindex=\"0\">clear</igx-icon>\n            </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-template #defaultDateUI>\n    <igx-date-picker\n        tabindex=\"0\"\n        mode=\"dropdown\"\n        [value]=\"value\"\n        [outlet]=\"filteringService.grid.outlet\"\n        [locale]=\"filteringService.grid.locale\"\n        (onSelection)=\"onDateSelected($event)\"\n        (onClosed)=\"datePickerClose()\">\n        <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\">\n            <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"displayDensity\" (focusout)=\"onInputGroupFocusout()\">\n                <igx-prefix #inputGroupPrefix\n                            tabindex=\"0\"\n                            (click)=\"inputGroupPrefixClick($event)\"\n                            (keydown)=\"onPrefixKeyDown($event)\"\n                            [igxDropDownItemNavigation]=\"inputGroupConditions\">\n                    <igx-icon family=\"imx-icons\" [name]=\"expression.condition.iconName\"></igx-icon>\n                </igx-prefix>\n                <input #input\n                       igxInput\n                       tabindex=\"0\"\n                       (click)=\"expression.condition.isUnary ? null : openDialog(inputGroup.element.nativeElement)\"\n                       [placeholder]=\"placeholder\"\n                       autocomplete=\"off\"\n                       [value]=\"\n                            column.formatter\n                            ? (value | columnFormatter:column.formatter)\n                            : (value | date:column.pipeArgs.format:undefined:filteringService.grid.locale)\n                        \"\n                       [readonly]=\"true\"\n                       (keydown)=\"onInputKeyDown($event)\"/>\n                <igx-suffix *ngIf=\"value\">\n                    <igx-icon (keydown)=\"onCommitKeyDown($event)\" (click)=\"onCommitClick()\" tabindex=\"0\">done</igx-icon>\n                    <igx-icon (keydown)=\"onClearKeyDown($event)\" (click)=\"clearInput()\" tabindex=\"0\">clear</igx-icon>\n                </igx-suffix>\n            </igx-input-group>\n            </ng-template>\n    </igx-date-picker>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this }\"></ng-container>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-start\" *ngIf=\"showArrows\" (keydown)=\"onLeftArrowKeyDown($event)\" (click)=\"scrollChipsOnArrowPress('left')\">\n    <igx-icon>navigate_before</igx-icon>\n</button>\n\n<div #container class=\"igx-grid__filtering-row-main\">\n    <div>\n         <igx-chips-area #chipsArea>\n            <ng-container *ngFor=\"let item of expressionsList; index as i; let last = last;\" tabindex=\"0\">\n                <igx-chip #chip id='chip'\n                    (pointerdown)=\"onChipPointerdown($event, chip)\"\n                    (click)=\"onChipClick($event, item)\"\n                    (keydown)=\"onChipKeyDown($event, item)\"\n                    (remove)=\"onChipRemoved($event, item)\"\n                    [selectable]=\"false\"\n                    [selected]=\"item.isSelected\"\n                    [displayDensity]=\"displayDensity\"\n                    [removable]=\"true\">\n                    <igx-icon\n                        igxPrefix\n                        family=\"imx-icons\"\n                        [name]=\"item.expression.condition.iconName\">\n                    </igx-icon>\n                    <span>{{filteringService.getChipLabel(item.expression)}}</span>\n                </igx-chip>\n\n                <span id='operand' *ngIf=\"!last\">\n                    <button igxButton (click)=\"toggleOperatorsDropDown($event, i)\" [igxDropDownItemNavigation]=\"operators\" [displayDensity]=\"column.grid.displayDensity\">\n                        <igx-icon>expand_more</igx-icon>\n                        <span>{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n                    </button>\n                    <igx-drop-down [displayDensity]=\"column.grid.displayDensity\" #operators (onSelection)=\"onLogicOperatorChanged($event, item)\">\n                            <igx-drop-down-item [value]=\"0\" [selected]=\"item.afterOperator === 0\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_and}}</igx-drop-down-item>\n                            <igx-drop-down-item [value]=\"1\" [selected]=\"item.afterOperator === 1\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_or}}</igx-drop-down-item>\n                    </igx-drop-down>\n                </span>\n            </ng-container>\n        </igx-chips-area>\n    </div>\n</div>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-end\" *ngIf=\"showArrows\" (click)=\"scrollChipsOnArrowPress('right')\">\n    <igx-icon>navigate_next</igx-icon>\n</button>\n\n<div #buttonsContainer [ngClass]=\"isNarrowWidth ? 'igx-grid__filtering-row-editing-buttons--small' : 'igx-grid__filtering-row-editing-buttons'\">\n    <button [displayDensity]=\"column.grid.displayDensity\" [igxButton]=\"isNarrowWidth ? 'icon' : 'flat'\" igxRipple (click)=\"clearFiltering()\" [disabled]=\"disabled\" [tabindex]=\"disabled\">\n        <igx-icon>refresh</igx-icon>\n        <span>{{isNarrowWidth ? '' : filteringService.grid.resourceStrings.igx_grid_filter_row_reset}}</span>\n    </button>\n    <button #closeButton [displayDensity]=\"column.grid.displayDensity\" [igxButton]=\"isNarrowWidth ? 'icon' : 'flat'\"  igxRipple (click)=\"close()\">\n        <igx-icon>close</igx-icon>\n        <span>{{isNarrowWidth ? '' : filteringService.grid.resourceStrings.igx_grid_filter_row_close}}</span>\n    </button>\n</div>\n"
                },] }
    ];
    IgxGridFilteringRowComponent.ctorParameters = function () { return [
        { type: IgxFilteringService },
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxGridFilteringRowComponent.propDecorators = {
        column: [{ type: i0.Input }],
        value: [{ type: i0.Input }],
        defaultFilterUI: [{ type: i0.ViewChild, args: ['defaultFilterUI', { read: i0.TemplateRef, static: true },] }],
        defaultDateUI: [{ type: i0.ViewChild, args: ['defaultDateUI', { read: i0.TemplateRef, static: true },] }],
        input: [{ type: i0.ViewChild, args: ['input', { read: i0.ElementRef },] }],
        dropDownConditions: [{ type: i0.ViewChild, args: ['inputGroupConditions', { read: IgxDropDownComponent, static: true },] }],
        chipsArea: [{ type: i0.ViewChild, args: ['chipsArea', { read: IgxChipsAreaComponent, static: true },] }],
        dropDownOperators: [{ type: i0.ViewChildren, args: ['operators', { read: IgxDropDownComponent },] }],
        inputGroup: [{ type: i0.ViewChild, args: ['inputGroup', { read: i0.ElementRef },] }],
        inputGroupPrefix: [{ type: i0.ViewChild, args: ['inputGroupPrefix', { read: i0.ElementRef },] }],
        container: [{ type: i0.ViewChild, args: ['container', { static: true },] }],
        operand: [{ type: i0.ViewChild, args: ['operand',] }],
        closeButton: [{ type: i0.ViewChild, args: ['closeButton', { static: true },] }],
        styleClasses: [{ type: i0.HostBinding, args: ['class',] }],
        onKeydownHandler: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
    };

    /**
     * @hidden
     * @internal
     */
    var IgxColumnMovingDragDirective = /** @class */ (function (_super) {
        __extends(IgxColumnMovingDragDirective, _super);
        function IgxColumnMovingDragDirective(element, viewContainer, zone, renderer, cdr, cms, _platformUtil) {
            var _this = _super.call(this, cdr, element, viewContainer, zone, renderer, _platformUtil) || this;
            _this.element = element;
            _this.viewContainer = viewContainer;
            _this.zone = zone;
            _this.renderer = renderer;
            _this.cdr = cdr;
            _this.cms = cms;
            _this._ghostClass = 'igx-grid__drag-ghost-image';
            _this.ghostImgIconClass = 'igx-grid__drag-ghost-image-icon';
            _this.ghostImgIconGroupClass = 'igx-grid__drag-ghost-image-icon-group';
            _this.columnSelectedClass = 'igx-grid__th--selected';
            return _this;
        }
        Object.defineProperty(IgxColumnMovingDragDirective.prototype, "column", {
            get: function () {
                return this.data;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnMovingDragDirective.prototype, "draggable", {
            get: function () {
                return this.column && (this.column.movable || (this.column.groupable && !this.column.columnGroup));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnMovingDragDirective.prototype, "icon", {
            get: function () {
                return this.cms.icon;
            },
            enumerable: false,
            configurable: true
        });
        IgxColumnMovingDragDirective.prototype.ngOnDestroy = function () {
            this._unsubscribe();
        };
        IgxColumnMovingDragDirective.prototype.onEscape = function (event) {
            this.cms.cancelDrop = true;
            this.onPointerUp(event);
        };
        IgxColumnMovingDragDirective.prototype.onPointerDown = function (event) {
            var _this = this;
            if (!this.draggable || event.target.getAttribute('draggable') === 'false') {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
            this._removeOnDestroy = false;
            this.cms.column = this.column;
            this.ghostClass = this._ghostClass;
            _super.prototype.onPointerDown.call(this, event);
            this.cms.isColumnMoving = true;
            this.column.grid.cdr.detectChanges();
            var args = {
                source: this.column
            };
            this.column.grid.onColumnMovingStart.emit(args);
            this.subscription$ = rxjs.fromEvent(this.column.grid.document.defaultView, 'keydown').subscribe(function (ev) {
                if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                    _this.onEscape(ev);
                }
            });
        };
        IgxColumnMovingDragDirective.prototype.onPointerMove = function (event) {
            event.preventDefault();
            _super.prototype.onPointerMove.call(this, event);
            if (this._dragStarted && this.ghostElement && !this.column.grid.draggedColumn) {
                this.column.grid.draggedColumn = this.column;
                this.column.grid.cdr.detectChanges();
            }
            if (this.cms.isColumnMoving) {
                var args = {
                    source: this.column,
                    cancel: false
                };
                this.column.grid.onColumnMoving.emit(args);
                if (args.cancel) {
                    this.onEscape(event);
                }
            }
        };
        IgxColumnMovingDragDirective.prototype.onPointerUp = function (event) {
            var _this = this;
            // Run it explicitly inside the zone because sometimes onPointerUp executes after the code below.
            this.zone.run(function () {
                _super.prototype.onPointerUp.call(_this, event);
                _this.cms.isColumnMoving = false;
                _this.column.grid.draggedColumn = null;
                _this.column.grid.cdr.detectChanges();
            });
            this._unsubscribe();
        };
        IgxColumnMovingDragDirective.prototype.createGhost = function (pageX, pageY) {
            _super.prototype.createGhost.call(this, pageX, pageY);
            this.ghostElement.style.height = null;
            this.ghostElement.style.minWidth = null;
            this.ghostElement.style.flexBasis = null;
            this.ghostElement.style.position = null;
            this.renderer.removeClass(this.ghostElement, this.columnSelectedClass);
            var icon = document.createElement('i');
            var text = document.createTextNode('block');
            icon.appendChild(text);
            icon.classList.add('material-icons');
            this.cms.icon = icon;
            if (!this.column.columnGroup) {
                this.renderer.addClass(icon, this.ghostImgIconClass);
                this.ghostElement.insertBefore(icon, this.ghostElement.firstElementChild);
                this.ghostLeft = this._ghostStartX = pageX - ((this.ghostElement.getBoundingClientRect().width / 3) * 2);
                this.ghostTop = this._ghostStartY = pageY - ((this.ghostElement.getBoundingClientRect().height / 3) * 2);
            }
            else {
                this.ghostElement.insertBefore(icon, this.ghostElement.childNodes[0]);
                this.renderer.addClass(icon, this.ghostImgIconGroupClass);
                this.ghostElement.children[0].style.paddingLeft = '0px';
                this.ghostLeft = this._ghostStartX = pageX - ((this.ghostElement.getBoundingClientRect().width / 3) * 2);
                this.ghostTop = this._ghostStartY = pageY - ((this.ghostElement.getBoundingClientRect().height / 3) * 2);
            }
        };
        IgxColumnMovingDragDirective.prototype._unsubscribe = function () {
            if (this.subscription$) {
                this.subscription$.unsubscribe();
                this.subscription$ = null;
            }
        };
        return IgxColumnMovingDragDirective;
    }(IgxDragDirective));
    IgxColumnMovingDragDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxColumnMovingDrag]',
                },] }
    ];
    IgxColumnMovingDragDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ViewContainerRef },
        { type: i0.NgZone },
        { type: i0.Renderer2 },
        { type: i0.ChangeDetectorRef },
        { type: IgxColumnMovingService },
        { type: PlatformUtil }
    ]; };
    IgxColumnMovingDragDirective.propDecorators = {
        data: [{ type: i0.Input, args: ['igxColumnMovingDrag',] }]
    };

    /**
     * @hidden
     */
    var IgxGroupByRowTemplateDirective = /** @class */ (function () {
        function IgxGroupByRowTemplateDirective(template) {
            this.template = template;
        }
        return IgxGroupByRowTemplateDirective;
    }());
    IgxGroupByRowTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxGroupByRow]'
                },] }
    ];
    IgxGroupByRowTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    /**
     * @hidden
     */
    var IgxGridDetailTemplateDirective = /** @class */ (function () {
        function IgxGridDetailTemplateDirective() {
        }
        return IgxGridDetailTemplateDirective;
    }());
    IgxGridDetailTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxGridDetail]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxRowExpandedIndicatorDirective = /** @class */ (function () {
        function IgxRowExpandedIndicatorDirective() {
        }
        return IgxRowExpandedIndicatorDirective;
    }());
    IgxRowExpandedIndicatorDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxRowExpandedIndicator]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxRowCollapsedIndicatorDirective = /** @class */ (function () {
        function IgxRowCollapsedIndicatorDirective() {
        }
        return IgxRowCollapsedIndicatorDirective;
    }());
    IgxRowCollapsedIndicatorDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxRowCollapsedIndicator]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxHeaderExpandIndicatorDirective = /** @class */ (function () {
        function IgxHeaderExpandIndicatorDirective() {
        }
        return IgxHeaderExpandIndicatorDirective;
    }());
    IgxHeaderExpandIndicatorDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxHeaderExpandedIndicator]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxHeaderCollapseIndicatorDirective = /** @class */ (function () {
        function IgxHeaderCollapseIndicatorDirective() {
        }
        return IgxHeaderCollapseIndicatorDirective;
    }());
    IgxHeaderCollapseIndicatorDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxHeaderCollapsedIndicator]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxExcelStyleHeaderIconDirective = /** @class */ (function () {
        function IgxExcelStyleHeaderIconDirective() {
        }
        return IgxExcelStyleHeaderIconDirective;
    }());
    IgxExcelStyleHeaderIconDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxExcelStyleHeaderIcon]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxGroupAreaDropDirective = /** @class */ (function (_super) {
        __extends(IgxGroupAreaDropDirective, _super);
        function IgxGroupAreaDropDirective(elementRef, renderer, zone) {
            var _this = _super.call(this, elementRef, renderer, zone) || this;
            _this.elementRef = elementRef;
            _this.renderer = renderer;
            _this.zone = zone;
            _this.hovered = false;
            return _this;
        }
        IgxGroupAreaDropDirective.prototype.onDragEnter = function (event) {
            var drag = event.detail.owner;
            var column = drag.column;
            if (!this.columnBelongsToGrid(column)) {
                return;
            }
            var grid = column.grid;
            var isGrouped = grid.groupingExpressions.findIndex(function (item) { return item.fieldName === column.field; }) !== -1;
            if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {
                drag.icon.innerText = 'group_work';
                this.hovered = true;
            }
            else {
                drag.icon.innerText = 'block';
                this.hovered = false;
            }
        };
        IgxGroupAreaDropDirective.prototype.onDragLeave = function (event) {
            var drag = event.detail.owner;
            var column = drag.column;
            if (!this.columnBelongsToGrid(column)) {
                return;
            }
            event.detail.owner.icon.innerText = 'block';
            this.hovered = false;
        };
        IgxGroupAreaDropDirective.prototype.onDragDrop = function (event) {
            var drag = event.detail.owner;
            if (drag instanceof IgxColumnMovingDragDirective) {
                var column_1 = drag.column;
                if (!this.columnBelongsToGrid(column_1)) {
                    return;
                }
                var grid = column_1.grid;
                var isGrouped = grid.groupingExpressions.findIndex(function (item) { return item.fieldName === column_1.field; }) !== -1;
                if (column_1.groupable && !isGrouped && !column_1.columnGroup && !!column_1.field) {
                    grid.groupBy({ fieldName: column_1.field, dir: exports.SortingDirection.Asc, ignoreCase: column_1.sortingIgnoreCase,
                        strategy: column_1.sortStrategy, groupingComparer: column_1.groupingComparer });
                }
            }
        };
        IgxGroupAreaDropDirective.prototype.closestParentByAttr = function (elem, attr) {
            return elem.hasAttribute(attr) ?
                elem :
                this.closestParentByAttr(elem.parentElement, attr);
        };
        IgxGroupAreaDropDirective.prototype.columnBelongsToGrid = function (column) {
            var elem = this.elementRef.nativeElement;
            var closestGridID = this.closestParentByAttr(elem, 'igxGroupAreaDrop').getAttribute('gridId');
            if (!column) {
                return false;
            }
            else {
                var grid = column.grid;
                if (!grid || grid.id !== closestGridID) {
                    return false;
                }
                return true;
            }
        };
        return IgxGroupAreaDropDirective;
    }(IgxDropDirective));
    IgxGroupAreaDropDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxGroupAreaDrop]'
                },] }
    ];
    IgxGroupAreaDropDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: i0.NgZone }
    ]; };
    IgxGroupAreaDropDirective.propDecorators = {
        hovered: [{ type: i0.HostBinding, args: ['class.igx-drop-area--hover',] }]
    };

    /**
     * @hidden
     */
    var ExpressionItem = /** @class */ (function () {
        function ExpressionItem(parent) {
            this.parent = parent;
        }
        return ExpressionItem;
    }());
    /**
     * @hidden
     */
    var ExpressionGroupItem = /** @class */ (function (_super) {
        __extends(ExpressionGroupItem, _super);
        function ExpressionGroupItem(operator, parent) {
            var _this = _super.call(this, parent) || this;
            _this.operator = operator;
            _this.children = [];
            return _this;
        }
        return ExpressionGroupItem;
    }(ExpressionItem));
    /**
     * @hidden
     */
    var ExpressionOperandItem = /** @class */ (function (_super) {
        __extends(ExpressionOperandItem, _super);
        function ExpressionOperandItem(expression, parent) {
            var _this = _super.call(this, parent) || this;
            _this.expression = expression;
            return _this;
        }
        return ExpressionOperandItem;
    }(ExpressionItem));
    /**
     * A component used for presenting advanced filtering UI for a Grid.
     * It is used internally in the Grid, but could also be hosted in a container outside of it.
     *
     * Example:
     * ```html
     * <igx-advanced-filtering-dialog
     *     [grid]="grid1">
     * </igx-advanced-filtering-dialog>
     * ```
     */
    var IgxAdvancedFilteringDialogComponent = /** @class */ (function () {
        function IgxAdvancedFilteringDialogComponent(cdr) {
            this.cdr = cdr;
            /**
             * @hidden @internal
             */
            this.display = 'block';
            /**
             * @hidden @internal
             */
            this.inline = true;
            /**
             * @hidden @internal
             */
            this.selectedExpressions = [];
            /**
             * @hidden @internal
             */
            this.selectedGroups = [];
            /**
             * @hidden @internal
             */
            this.lastActiveNode = {};
            /**
             * @hidden @internal
             */
            this.columnSelectOverlaySettings = {
                scrollStrategy: new AbsoluteScrollStrategy(),
                modal: false,
                closeOnOutsideClick: false
            };
            /**
             * @hidden @internal
             */
            this.conditionSelectOverlaySettings = {
                scrollStrategy: new AbsoluteScrollStrategy(),
                modal: false,
                closeOnOutsideClick: false
            };
            this.destroy$ = new rxjs.Subject();
            this._dblClickDelay = 200;
            this._preventChipClick = false;
            this._positionSettings = {
                horizontalStartPoint: exports.HorizontalAlignment.Right,
                verticalStartPoint: exports.VerticalAlignment.Top
            };
            this._overlaySettings = {
                closeOnOutsideClick: false,
                modal: false,
                positionStrategy: new ConnectedPositioningStrategy(this._positionSettings),
                scrollStrategy: new CloseScrollStrategy()
            };
        }
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "editingInputsContainer", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._editingInputsContainer;
            },
            /**
             * @hidden @internal
             */
            set: function (value) {
                var _this = this;
                if ((value && !this._editingInputsContainer) ||
                    (value && this._editingInputsContainer && this._editingInputsContainer.nativeElement !== value.nativeElement)) {
                    requestAnimationFrame(function () {
                        _this.scrollElementIntoView(value.nativeElement);
                    });
                }
                this._editingInputsContainer = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "addModeContainer", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._addModeContainer;
            },
            /**
             * @hidden @internal
             */
            set: function (value) {
                var _this = this;
                if ((value && !this._addModeContainer) ||
                    (value && this._addModeContainer && this._addModeContainer.nativeElement !== value.nativeElement)) {
                    requestAnimationFrame(function () {
                        _this.scrollElementIntoView(value.nativeElement);
                    });
                }
                this._addModeContainer = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "currentGroupButtonsContainer", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._currentGroupButtonsContainer;
            },
            /**
             * @hidden @internal
             */
            set: function (value) {
                var _this = this;
                if ((value && !this._currentGroupButtonsContainer) ||
                    (value && this._currentGroupButtonsContainer && this._currentGroupButtonsContainer.nativeElement !== value.nativeElement)) {
                    requestAnimationFrame(function () {
                        _this.scrollElementIntoView(value.nativeElement);
                    });
                }
                this._currentGroupButtonsContainer = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.ngAfterViewInit = function () {
            this._overlaySettings.outlet = this.overlayOutlet;
            this.columnSelectOverlaySettings.outlet = this.overlayOutlet;
            this.conditionSelectOverlaySettings.outlet = this.overlayOutlet;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "displayDensity", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.grid.displayDensity;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "selectedColumn", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._selectedColumn;
            },
            /**
             * @hidden @internal
             */
            set: function (value) {
                var oldValue = this._selectedColumn;
                if (this._selectedColumn !== value) {
                    this._selectedColumn = value;
                    if (oldValue && this._selectedColumn && this._selectedColumn.dataType !== oldValue.dataType) {
                        this.selectedCondition = null;
                        this.searchValue = null;
                        this.cdr.detectChanges();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "grid", {
            /**
             * Returns the grid.
             */
            get: function () {
                return this._grid;
            },
            /**
             * An @Input property that sets the grid.
             */
            set: function (grid) {
                var _this = this;
                this._grid = grid;
                if (this._filteringChange) {
                    this._filteringChange.unsubscribe();
                }
                if (this._grid) {
                    this._grid.filteringService.registerSVGIcons();
                    this._filteringChange = this._grid.advancedFilteringExpressionsTreeChange.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                        _this.init();
                    });
                    this.init();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "filterableColumns", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.grid.columns.filter(function (col) { return !col.columnGroup && col.filterable; });
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.dragStart = function (dragArgs) {
            if (!this._overlayComponentId) {
                dragArgs.cancel = true;
                return;
            }
            if (!this.contextMenuToggle.collapsed) {
                this.contextMenuToggle.element.style.display = 'none';
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.dragEnd = function () {
            if (!this.contextMenuToggle.collapsed) {
                this.calculateContextMenuTarget();
                this.contextMenuToggle.reposition();
                this.contextMenuToggle.element.style.display = '';
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onDragMove = function (e) {
            var deltaX = e.nextPageX - e.pageX;
            var deltaY = e.nextPageY - e.pageY;
            e.cancel = true;
            this._overlayService.setOffset(this._overlayComponentId, deltaX, deltaY);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.addCondition = function (parent, afterExpression) {
            this.cancelOperandAdd();
            var operandItem = new ExpressionOperandItem({
                fieldName: null,
                condition: null,
                ignoreCase: true,
                searchVal: null
            }, parent);
            if (afterExpression) {
                var index = parent.children.indexOf(afterExpression);
                parent.children.splice(index + 1, 0, operandItem);
            }
            else {
                parent.children.push(operandItem);
            }
            this.enterExpressionEdit(operandItem);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.addAndGroup = function (parent, afterExpression) {
            this.addGroup(exports.FilteringLogic.And, parent, afterExpression);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.addOrGroup = function (parent, afterExpression) {
            this.addGroup(exports.FilteringLogic.Or, parent, afterExpression);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.endGroup = function (groupItem) {
            this.currentGroup = groupItem.parent;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.commitOperandEdit = function () {
            if (this.editedExpression) {
                this.editedExpression.expression.fieldName = this.selectedColumn.field;
                this.editedExpression.expression.condition = this.selectedColumn.filters.condition(this.selectedCondition);
                this.editedExpression.expression.searchVal = DataUtil.parseValue(this.selectedColumn.dataType, this.searchValue);
                this.editedExpression.columnHeader = this.selectedColumn.header;
                this.editedExpression.inEditMode = false;
                this.editedExpression = null;
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.cancelOperandAdd = function () {
            if (this.addModeExpression) {
                this.addModeExpression.inAddMode = false;
                this.addModeExpression = null;
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.cancelOperandEdit = function () {
            if (this.editedExpression) {
                this.editedExpression.inEditMode = false;
                if (!this.editedExpression.expression.fieldName) {
                    this.deleteItem(this.editedExpression);
                }
                this.editedExpression = null;
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.operandCanBeCommitted = function () {
            return this.selectedColumn && this.selectedCondition &&
                (!!this.searchValue || this.selectedColumn.filters.condition(this.selectedCondition).isUnary);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.exitOperandEdit = function () {
            if (!this.editedExpression) {
                return;
            }
            if (this.operandCanBeCommitted()) {
                this.commitOperandEdit();
            }
            else {
                this.cancelOperandEdit();
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.isExpressionGroup = function (expression) {
            return expression instanceof ExpressionGroupItem;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onChipRemove = function (expressionItem) {
            this.deleteItem(expressionItem);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onChipClick = function (expressionItem) {
            var _this = this;
            this._clickTimer = setTimeout(function () {
                if (!_this._preventChipClick) {
                    _this.onToggleExpression(expressionItem);
                }
                _this._preventChipClick = false;
            }, this._dblClickDelay);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onChipDblClick = function (expressionItem) {
            clearTimeout(this._clickTimer);
            this._preventChipClick = true;
            this.enterExpressionEdit(expressionItem);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.enterExpressionEdit = function (expressionItem) {
            this.clearSelection();
            this.exitOperandEdit();
            this.cancelOperandAdd();
            if (this.editedExpression) {
                this.editedExpression.inEditMode = false;
            }
            expressionItem.hovered = false;
            this.selectedColumn = expressionItem.expression.fieldName ?
                this.grid.getColumnByName(expressionItem.expression.fieldName) : null;
            this.selectedCondition = expressionItem.expression.condition ?
                expressionItem.expression.condition.name : null;
            this.searchValue = expressionItem.expression.searchVal;
            expressionItem.inEditMode = true;
            this.editedExpression = expressionItem;
            this.cdr.detectChanges();
            this.columnSelectOverlaySettings.target = this.columnSelect.element;
            this.columnSelectOverlaySettings.excludeFromOutsideClick = [this.columnSelect.element];
            this.columnSelectOverlaySettings.positionStrategy = new AutoPositionStrategy();
            this.conditionSelectOverlaySettings.target = this.conditionSelect.element;
            this.conditionSelectOverlaySettings.excludeFromOutsideClick = [this.conditionSelect.element];
            this.conditionSelectOverlaySettings.positionStrategy = new AutoPositionStrategy();
            if (!this.selectedColumn) {
                this.columnSelect.input.nativeElement.focus();
            }
            else if (this.selectedColumn.filters.condition(this.selectedCondition).isUnary) {
                this.conditionSelect.input.nativeElement.focus();
            }
            else {
                this.searchValueInput.nativeElement.focus();
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.clearSelection = function () {
            var e_1, _a, e_2, _b;
            try {
                for (var _c = __values(this.selectedGroups), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    group.selected = false;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.selectedGroups = [];
            try {
                for (var _e = __values(this.selectedExpressions), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var expr = _f.value;
                    expr.selected = false;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this.selectedExpressions = [];
            this.toggleContextMenu();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.enterExpressionAdd = function (expressionItem) {
            this.clearSelection();
            this.exitOperandEdit();
            if (this.addModeExpression) {
                this.addModeExpression.inAddMode = false;
            }
            expressionItem.inAddMode = true;
            this.addModeExpression = expressionItem;
            if (expressionItem.selected) {
                this.toggleExpression(expressionItem);
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.contextMenuClosed = function () {
            this.contextualGroup = null;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onKeyDown = function (eventArgs) {
            eventArgs.stopPropagation();
            var key = eventArgs.key;
            if (!this.contextMenuToggle.collapsed && (key === "Escape" /* ESCAPE */ || key === "Esc" /* ESCAPE_IE */)) {
                this.clearSelection();
            }
            else if (key === "Escape" /* ESCAPE */ || key === "Esc" /* ESCAPE_IE */) {
                this.closeDialog();
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.createAndGroup = function () {
            this.createGroup(exports.FilteringLogic.And);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.createOrGroup = function () {
            this.createGroup(exports.FilteringLogic.Or);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.deleteFilters = function () {
            var e_3, _a;
            try {
                for (var _b = __values(this.selectedExpressions), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var expr = _c.value;
                    this.deleteItem(expr);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            this.clearSelection();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onGroupClick = function (groupItem) {
            this.toggleGroup(groupItem);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.ungroup = function () {
            var _a, e_4, _b;
            var selectedGroup = this.contextualGroup;
            var parent = selectedGroup.parent;
            if (parent) {
                var index = parent.children.indexOf(selectedGroup);
                (_a = parent.children).splice.apply(_a, __spread([index, 1], selectedGroup.children));
                try {
                    for (var _c = __values(selectedGroup.children), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var expr = _d.value;
                        expr.parent = parent;
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
            this.clearSelection();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.deleteGroup = function () {
            var selectedGroup = this.contextualGroup;
            var parent = selectedGroup.parent;
            if (parent) {
                var index = parent.children.indexOf(selectedGroup);
                parent.children.splice(index, 1);
            }
            else {
                this.rootGroup = null;
            }
            this.clearSelection();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.selectFilteringLogic = function (event) {
            this.contextualGroup.operator = event.index;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.getConditionFriendlyName = function (name) {
            return this.grid.resourceStrings["igx_grid_filter_" + name] || name;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.isDate = function (value) {
            return value instanceof Date;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onExpressionsScrolled = function () {
            if (!this.contextMenuToggle.collapsed) {
                this.calculateContextMenuTarget();
                this.contextMenuToggle.reposition();
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.invokeClick = function (eventArgs) {
            if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
                eventArgs.preventDefault();
                eventArgs.currentTarget.click();
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onOutletPointerDown = function (event) {
            // This prevents closing the select's dropdown when clicking the scroll
            event.preventDefault();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.getConditionList = function () {
            return this.selectedColumn ? this.selectedColumn.filters.conditionList() : [];
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.initialize = function (grid, overlayService, overlayComponentId) {
            this.inline = false;
            this.grid = grid;
            this._overlayService = overlayService;
            this._overlayComponentId = overlayComponentId;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.getFormatter = function (field) {
            return this.grid.getColumnByName(field).formatter;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.getFormat = function (field) {
            return this.grid.getColumnByName(field).pipeArgs.format;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.getTimezone = function (field) {
            return this.grid.getColumnByName(field).pipeArgs.timezone;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.setAddButtonFocus = function () {
            if (this.addRootAndGroupButton) {
                this.addRootAndGroupButton.nativeElement.focus();
            }
            else if (this.addConditionButton) {
                this.addConditionButton.nativeElement.focus();
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.context = function (expression, afterExpression) {
            return {
                $implicit: expression,
                afterExpression: afterExpression
            };
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onClearButtonClick = function (event) {
            this.grid.endEdit(false, event);
            this.grid.advancedFilteringExpressionsTree = null;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.closeDialog = function () {
            if (this._overlayComponentId) {
                this._overlayService.hide(this._overlayComponentId);
            }
            this.grid.navigation.activeNode = this.lastActiveNode;
            if (this.grid.navigation.activeNode && this.grid.navigation.activeNode.row === -1) {
                this.grid.theadRow.nativeElement.focus();
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.applyChanges = function (event) {
            this.grid.endEdit(false, event);
            this.exitOperandEdit();
            this.grid.advancedFilteringExpressionsTree = this.createExpressionsTreeFromGroupItem(this.rootGroup);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.cancelChanges = function () {
            if (!this._overlayComponentId) {
                this.init();
            }
            this.closeDialog();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onApplyButtonClick = function (event) {
            this.applyChanges(event);
            this.closeDialog();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onChipSelectionEnd = function () {
            var contextualGroup = this.findSingleSelectedGroup();
            if (contextualGroup || this.selectedExpressions.length > 1) {
                this.contextualGroup = contextualGroup;
                this.calculateContextMenuTarget();
                if (this.contextMenuToggle.collapsed) {
                    this.contextMenuToggle.open(this._overlaySettings);
                }
                else {
                    this.contextMenuToggle.reposition();
                }
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.onToggleExpression = function (expressionItem) {
            this.exitOperandEdit();
            this.toggleExpression(expressionItem);
            this.toggleContextMenu();
        };
        IgxAdvancedFilteringDialogComponent.prototype.toggleExpression = function (expressionItem) {
            expressionItem.selected = !expressionItem.selected;
            if (expressionItem.selected) {
                this.selectedExpressions.push(expressionItem);
            }
            else {
                var index = this.selectedExpressions.indexOf(expressionItem);
                this.selectedExpressions.splice(index, 1);
                this.deselectParentRecursive(expressionItem);
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.addGroup = function (operator, parent, afterExpression) {
            this.cancelOperandAdd();
            var groupItem = new ExpressionGroupItem(operator, parent);
            if (parent) {
                if (afterExpression) {
                    var index = parent.children.indexOf(afterExpression);
                    parent.children.splice(index + 1, 0, groupItem);
                }
                else {
                    parent.children.push(groupItem);
                }
            }
            else {
                this.rootGroup = groupItem;
            }
            this.addCondition(groupItem);
            this.currentGroup = groupItem;
        };
        IgxAdvancedFilteringDialogComponent.prototype.createExpressionGroupItem = function (expressionTree, parent) {
            var e_5, _a;
            var groupItem;
            if (expressionTree) {
                groupItem = new ExpressionGroupItem(expressionTree.operator, parent);
                try {
                    for (var _b = __values(expressionTree.filteringOperands), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var expr = _c.value;
                        if (expr instanceof FilteringExpressionsTree) {
                            groupItem.children.push(this.createExpressionGroupItem(expr, groupItem));
                        }
                        else {
                            var filteringExpr = expr;
                            var exprCopy = {
                                fieldName: filteringExpr.fieldName,
                                condition: filteringExpr.condition,
                                searchVal: filteringExpr.searchVal,
                                ignoreCase: filteringExpr.ignoreCase
                            };
                            var operandItem = new ExpressionOperandItem(exprCopy, groupItem);
                            var column = this.grid.getColumnByName(filteringExpr.fieldName);
                            operandItem.columnHeader = column.header;
                            groupItem.children.push(operandItem);
                        }
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
            }
            return groupItem;
        };
        IgxAdvancedFilteringDialogComponent.prototype.createExpressionsTreeFromGroupItem = function (groupItem) {
            var e_6, _a;
            if (!groupItem) {
                return null;
            }
            var expressionsTree = new FilteringExpressionsTree(groupItem.operator);
            try {
                for (var _b = __values(groupItem.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var item = _c.value;
                    if (item instanceof ExpressionGroupItem) {
                        var subTree = this.createExpressionsTreeFromGroupItem(item);
                        expressionsTree.filteringOperands.push(subTree);
                    }
                    else {
                        expressionsTree.filteringOperands.push(item.expression);
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_6) throw e_6.error; }
            }
            return expressionsTree;
        };
        IgxAdvancedFilteringDialogComponent.prototype.toggleContextMenu = function () {
            var contextualGroup = this.findSingleSelectedGroup();
            if (contextualGroup || this.selectedExpressions.length > 1) {
                this.contextualGroup = contextualGroup;
                if (contextualGroup) {
                    this.filteringLogics = [
                        {
                            label: this.grid.resourceStrings.igx_grid_filter_operator_and,
                            selected: contextualGroup.operator === exports.FilteringLogic.And
                        },
                        {
                            label: this.grid.resourceStrings.igx_grid_filter_operator_or,
                            selected: contextualGroup.operator === exports.FilteringLogic.Or
                        }
                    ];
                }
            }
            else if (this.contextMenuToggle) {
                this.contextMenuToggle.close();
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.findSingleSelectedGroup = function () {
            var e_7, _a;
            var _this = this;
            var _loop_1 = function (group) {
                var containsAllSelectedExpressions = this_1.selectedExpressions.every(function (op) { return _this.isInsideGroup(op, group); });
                if (containsAllSelectedExpressions) {
                    return { value: group };
                }
            };
            var this_1 = this;
            try {
                for (var _b = __values(this.selectedGroups), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var group = _c.value;
                    var state_1 = _loop_1(group);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_7) throw e_7.error; }
            }
            return null;
        };
        IgxAdvancedFilteringDialogComponent.prototype.isInsideGroup = function (item, group) {
            if (!item) {
                return false;
            }
            if (item.parent === group) {
                return true;
            }
            return this.isInsideGroup(item.parent, group);
        };
        IgxAdvancedFilteringDialogComponent.prototype.deleteItem = function (expressionItem) {
            if (!expressionItem.parent) {
                this.rootGroup = null;
                this.currentGroup = null;
                return;
            }
            if (expressionItem === this.currentGroup) {
                this.currentGroup = this.currentGroup.parent;
            }
            var children = expressionItem.parent.children;
            var index = children.indexOf(expressionItem);
            children.splice(index, 1);
            if (!children.length) {
                this.deleteItem(expressionItem.parent);
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.createGroup = function (operator) {
            var e_8, _a;
            var chips = this.chips.toArray();
            var minIndex = this.selectedExpressions.reduce(function (i, e) { return Math.min(i, chips.findIndex(function (c) { return c.data === e; })); }, Number.MAX_VALUE);
            var firstExpression = chips[minIndex].data;
            var parent = firstExpression.parent;
            var groupItem = new ExpressionGroupItem(operator, parent);
            var index = parent.children.indexOf(firstExpression);
            parent.children.splice(index, 0, groupItem);
            try {
                for (var _b = __values(this.selectedExpressions), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var expr = _c.value;
                    this.deleteItem(expr);
                    groupItem.children.push(expr);
                    expr.parent = groupItem;
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_8) throw e_8.error; }
            }
            this.clearSelection();
        };
        IgxAdvancedFilteringDialogComponent.prototype.toggleGroup = function (groupItem) {
            this.exitOperandEdit();
            if (groupItem.children && groupItem.children.length) {
                this.toggleGroupRecursive(groupItem, !groupItem.selected);
                if (!groupItem.selected) {
                    this.deselectParentRecursive(groupItem);
                }
                this.toggleContextMenu();
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.toggleGroupRecursive = function (groupItem, selected) {
            var e_9, _a;
            if (groupItem.selected !== selected) {
                groupItem.selected = selected;
                if (groupItem.selected) {
                    this.selectedGroups.push(groupItem);
                }
                else {
                    var index = this.selectedGroups.indexOf(groupItem);
                    this.selectedGroups.splice(index, 1);
                }
            }
            try {
                for (var _b = __values(groupItem.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var expr = _c.value;
                    if (expr instanceof ExpressionGroupItem) {
                        this.toggleGroupRecursive(expr, selected);
                    }
                    else {
                        var operandExpression = expr;
                        if (operandExpression.selected !== selected) {
                            this.toggleExpression(operandExpression);
                        }
                    }
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_9) throw e_9.error; }
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.deselectParentRecursive = function (expressionItem) {
            var parent = expressionItem.parent;
            if (parent) {
                if (parent.selected) {
                    parent.selected = false;
                    var index = this.selectedGroups.indexOf(parent);
                    this.selectedGroups.splice(index, 1);
                }
                this.deselectParentRecursive(parent);
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.calculateContextMenuTarget = function () {
            var _this = this;
            var containerRect = this.expressionsContainer.nativeElement.getBoundingClientRect();
            var chips = this.chips.filter(function (c) { return _this.selectedExpressions.indexOf(c.data) !== -1; });
            var minTop = chips.reduce(function (t, c) { return Math.min(t, c.elementRef.nativeElement.getBoundingClientRect().top); }, Number.MAX_VALUE);
            minTop = Math.max(containerRect.top, minTop);
            minTop = Math.min(containerRect.bottom, minTop);
            var maxRight = chips.reduce(function (r, c) { return Math.max(r, c.elementRef.nativeElement.getBoundingClientRect().right); }, 0);
            maxRight = Math.max(maxRight, containerRect.left);
            maxRight = Math.min(maxRight, containerRect.right);
            this._overlaySettings.target = new Point(maxRight, minTop);
        };
        IgxAdvancedFilteringDialogComponent.prototype.scrollElementIntoView = function (target) {
            var container = this.expressionsContainer.nativeElement;
            var targetOffset = target.offsetTop - container.offsetTop;
            var delta = 10;
            if (container.scrollTop + delta > targetOffset) {
                container.scrollTop = targetOffset - delta;
            }
            else if (container.scrollTop + container.clientHeight < targetOffset + target.offsetHeight + delta) {
                container.scrollTop = targetOffset + target.offsetHeight + delta - container.clientHeight;
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.init = function () {
            this.clearSelection();
            this.cancelOperandAdd();
            this.cancelOperandEdit();
            this.rootGroup = this.createExpressionGroupItem(this.grid.advancedFilteringExpressionsTree);
            this.currentGroup = this.rootGroup;
        };
        return IgxAdvancedFilteringDialogComponent;
    }());
    IgxAdvancedFilteringDialogComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-advanced-filtering-dialog',
                    template: "<article\n    *ngIf=\"grid\"\n    class=\"igx-advanced-filter\"\n    igxDrag\n    [ghost]=\"false\"\n    [dragTolerance]=\"0\"\n    (dragStart)=\"dragStart($event)\"\n    (dragEnd)=\"dragEnd()\"\n    (dragMove)=\"onDragMove($event)\"\n    (keydown)=\"onKeyDown($event)\"\n    [ngClass]=\"{\n        'igx-advanced-filter--cosy': grid.displayDensity === 'cosy',\n        'igx-advanced-filter--compact': grid.displayDensity === 'compact',\n        'igx-advanced-filter--inline': inline\n    }\"\n>\n    <header class=\"igx-advanced-filter__header\" igxDragHandle>\n        <h4 class=\"igx-typography__h6\" style=\"pointer-events: none;\">\n            {{ grid.resourceStrings.igx_grid_advanced_filter_title }}\n        </h4>\n        <div class=\"igx-filter-legend\">\n            <div class=\"igx-filter-legend__item--and\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_and_label }}</span>\n            </div>\n            <div class=\"igx-filter-legend__item--or\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_or_label }}</span>\n            </div>\n        </div>\n    </header>\n\n    <article #expressionsContainer\n             class=\"igx-advanced-filter__main\"\n             (scroll)=\"onExpressionsScrolled()\">\n        <ng-container *ngIf=\"!rootGroup\">\n\n            <button #addRootAndGroupButton\n                igxButton=\"outlined\"\n                [displayDensity]=\"displayDensity\"\n                (click)=\"addAndGroup()\"\n            >\n                <igx-icon>add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\" [displayDensity]=\"displayDensity\" (click)=\"addOrGroup()\">\n                <igx-icon>add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n            <div class=\"igx-filter-empty\">\n                <h6 class=\"igx-filter-empty__title\">\n                    {{grid.resourceStrings.igx_grid_advanced_filter_initial_text}}\n                </h6>\n            </div>\n        </ng-container>\n\n        <ng-template #addExpressionsTemplate let-expressionItem let-afterExpression=\"afterExpression\">\n            <button #addConditionButton\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addCondition(expressionItem, afterExpression)\"\n            >\n                <igx-icon>add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_add_condition}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addAndGroup(expressionItem, afterExpression)\">\n                <igx-icon>add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addOrGroup(expressionItem, afterExpression)\">\n                <igx-icon>add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n        </ng-template>\n\n        <ng-template #filterOperandTemplate let-expressionItem>\n            <div *ngIf=\"!expressionItem.inEditMode\"\n                class=\"igx-filter-tree__expression-item\"\n                (mouseenter)=\"expressionItem.hovered = true\"\n                (mouseleave)=\"expressionItem.hovered = false\"\n                >\n                <igx-chip [data]=\"expressionItem\"\n                          [displayDensity]=\"displayDensity === 'compact' ? 'cosy' : displayDensity\"\n                          [removable]=\"true\"\n                          [selected]=\"expressionItem.selected\"\n                          (keydown)=\"invokeClick($event)\"\n                          (click)=\"onChipClick(expressionItem)\"\n                          (dblclick)=\"onChipDblClick(expressionItem)\"\n                          (remove)=\"onChipRemove(expressionItem)\"\n                          (selectedChanged)=\"onChipSelectionEnd()\"\n                    >\n                    <span igxPrefix class=\"igx-filter-tree__expression-column\">{{ expressionItem.columnHeader || expressionItem.expression.fieldName }}</span>\n                    <igx-prefix>\n                        <igx-icon family=\"imx-icons\" [name]=\"expressionItem.expression.condition.iconName\">\n                    </igx-icon>\n                    </igx-prefix>\n                    <span class=\"igx-filter-tree__expression-condition\">\n                        {{ getConditionFriendlyName(expressionItem.expression.condition.name) }}\n                    </span>\n                    <span igxSuffix *ngIf=\"!expressionItem.expression.condition.isUnary\">\n                        {{\n                            isDate(expressionItem.expression.searchVal)\n                            ? getFormatter(expressionItem.expression.fieldName)\n                                ? (expressionItem.expression.searchVal | columnFormatter:getFormatter(expressionItem.expression.fieldName))\n                                : (expressionItem.expression.searchVal | date:getFormat(expressionItem.expression.fieldName):undefined:grid.locale)\n                            : expressionItem.expression.searchVal\n                        }}\n                    </span>\n                </igx-chip>\n                <div class=\"igx-filter-tree__expression-actions\"\n                *ngIf=\"(expressionItem.selected && selectedExpressions.length === 1) || expressionItem.hovered\">\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionEdit(expressionItem)\">\n                        edit\n                    </igx-icon>\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionAdd(expressionItem)\"\n                        *ngIf=\"!expressionItem.inAddMode && (expressionItem.parent !== currentGroup || expressionItem !== currentGroup.children[currentGroup.children.length - 1])\"\n                    >\n                        add\n                    </igx-icon>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inEditMode\"\n                #editingInputsContainer\n                class=\"igx-filter-tree__inputs\"\n            >\n                <igx-select #columnSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"columnSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_column_placeholder\"\n                            [(ngModel)]=\"selectedColumn\">\n                    <igx-select-item *ngFor=\"let column of filterableColumns\" [value]=\"column\">\n                        {{column.header || column.field}}\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-select #conditionSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"conditionSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_filter_condition_placeholder\"\n                            [(ngModel)]=\"selectedCondition\"\n                            [disabled]=\"!selectedColumn\">\n                    <igx-prefix *ngIf=\"selectedColumn && conditionSelect.value && selectedColumn.filters.condition(conditionSelect.value)\">\n                        <igx-icon family=\"imx-icons\" [name]=\"selectedColumn.filters.condition(conditionSelect.value).iconName\">\n                        </igx-icon>\n                    </igx-prefix>\n                    <igx-select-item *ngFor=\"let condition of getConditionList()\" [value]=\"condition\">\n                        <div class=\"igx-grid__filtering-dropdown-items\">\n                            <igx-icon family=\"imx-icons\"\n                                      [name]=\"selectedColumn.filters.condition(condition).iconName\">\n                            </igx-icon>\n                            <span class=\"igx-grid__filtering-dropdown-text\">{{getConditionFriendlyName(condition)}}</span>\n                        </div>\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-input-group *ngIf=\"!selectedColumn || selectedColumn.dataType !== 'date'\"\n                                 type=\"box\"\n                                 [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"\n                                 [displayDensity]=\"'compact'\">\n                    <input #searchValueInput\n                           igxInput\n                           [type]=\"selectedColumn && selectedColumn.dataType === 'number' ? 'number' : 'text'\"\n                           [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_value_placeholder\"\n                           [(ngModel)]=\"searchValue\"/>\n                </igx-input-group>\n\n                <igx-date-picker *ngIf=\"selectedColumn && selectedColumn.dataType === 'date'\"\n                                 mode=\"dropdown\"\n                                 [(ngModel)]=\"searchValue\"\n                                 [locale]=\"grid.locale\"\n                                 [outlet]=\"grid.outlet\">\n                    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n                        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"'compact'\">\n                            <input #searchValueInput\n                                    igxInput\n                                    tabindex=\"0\"\n                                    (keydown)=\"invokeClick($event)\"\n                                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                                    [placeholder]=\"grid.resourceStrings.igx_grid_filter_row_date_placeholder\"\n                                    autocomplete=\"off\"\n                                    [value]=\"\n                                        selectedColumn.formatter\n                                        ? (value | columnFormatter:selectedColumn.formatter)\n                                        : (value | date:selectedColumn.pipeArgs.format:undefined:grid.locale)\n                                    \"\n                                    [readonly]=\"true\"\n                                    [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"/>\n                        </igx-input-group>\n                    </ng-template>\n                </igx-date-picker>\n\n                <div class=\"igx-filter-tree__inputs-actions\">\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            [disabled]=\"!operandCanBeCommitted()\"\n                            (click)=\"commitOperandEdit()\">\n                        <igx-icon>check</igx-icon>\n                    </button>\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            (click)=\"cancelOperandEdit()\">\n                        <igx-icon>close</igx-icon>\n                    </button>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inAddMode\"\n                #addModeContainer\n                class=\"igx-filter-tree__buttons\"\n            >\n                <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem.parent, expressionItem)\"></ng-container>\n                <button igxButton=\"icon\"\n                        [displayDensity]=\"displayDensity\"\n                        (click)=\"cancelOperandAdd()\">\n                    <igx-icon>close</igx-icon>\n                </button>\n            </div>\n\n        </ng-template>\n\n        <ng-template #expressionTreeTemplate let-expressionItem>\n            <div class=\"igx-filter-tree\">\n                <div tabindex=\"0\"\n                     class=\"igx-filter-tree__line\"\n                     [ngClass]=\"{\n                         'igx-filter-tree__line--and': expressionItem.operator === 0,\n                         'igx-filter-tree__line--or': expressionItem.operator === 1,\n                         'igx-filter-tree__line--selected': expressionItem.selected\n                     }\"\n                     (keydown)=\"invokeClick($event)\"\n                     (click)=\"onGroupClick(expressionItem)\"\n                ></div>\n\n                <div class=\"igx-filter-tree__expression\">\n                    <ng-container *ngFor=\"let expr of expressionItem.children\">\n                        <ng-container *ngTemplateOutlet=\"isExpressionGroup(expr) ? expressionTreeTemplate : filterOperandTemplate; context: context(expr)\"></ng-container>\n                    </ng-container>\n                    <div *ngIf=\"currentGroup === expressionItem\"\n                        #currentGroupButtonsContainer\n                        class=\"igx-filter-tree__buttons\">\n                        <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem)\"></ng-container>\n                        <button igxButton=\"outlined\"\n                                *ngIf=\"expressionItem !== rootGroup\"\n                                [displayDensity]=\"displayDensity\"\n                                [disabled]=\"editedExpression || expressionItem.children.length < 2\"\n                                (click)=\"endGroup(expressionItem)\">\n                            <span>{{grid.resourceStrings.igx_grid_advanced_filter_end_group}}</span>\n                        </button>\n                    </div>\n                </div>\n            </div>\n\n        </ng-template>\n\n        <ng-container *ngIf=\"rootGroup\">\n            <ng-container *ngTemplateOutlet=\"expressionTreeTemplate; context: context(rootGroup)\"></ng-container>\n        </ng-container>\n\n        <div igxToggle\n            class=\"igx-filter-contextual-menu\"\n            (keydown)=\"onKeyDown($event)\"\n            (onClosed)=\"contextMenuClosed()\"\n            [ngClass]=\"{\n                'igx-filter-contextual-menu--cosy': displayDensity === 'cosy',\n                'igx-filter-contextual-menu--compact': displayDensity === 'compact'\n            }\"\n        >\n            <button igxButton=\"icon\"\n                    class=\"igx-filter-contextual-menu__close-btn\"\n                    (click)=\"clearSelection()\"\n            >\n                <igx-icon>close</igx-icon>\n            </button>\n\n            <ng-container *ngIf=\"contextualGroup\">\n                <igx-buttongroup [displayDensity]=\"displayDensity\"\n                                 [multiSelection]=\"false\"\n                                 [values]=\"filteringLogics\"\n                                 type=\"outline\"\n                                 (selected)=\"selectFilteringLogic($event)\">\n                </igx-buttongroup>\n\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"!contextualGroup.parent\"\n                    (click)=\"ungroup()\"\n                >\n                    <igx-icon family=\"imx-icons\" name=\"ungroup\"></igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_ungroup}}</span>\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteGroup()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    <igx-icon>delete</igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_delete}}</span>\n                </button>\n            </ng-container>\n            <ng-container *ngIf=\"!contextualGroup\">\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createAndGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_and_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createOrGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_or_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteFilters()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_delete_filters}}\n                </button>\n            </ng-container>\n        </div>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick($event)\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"cancelChanges()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick($event)\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n<div #overlayOutlet\n     igxOverlayOutlet\n     class=\"igx-advanced-filter__outlet\"\n     (pointerdown)=\"onOutletPointerDown($event)\">\n</div>\n"
                },] }
    ];
    IgxAdvancedFilteringDialogComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxAdvancedFilteringDialogComponent.propDecorators = {
        columnSelect: [{ type: i0.ViewChild, args: ['columnSelect', { read: IgxSelectComponent },] }],
        conditionSelect: [{ type: i0.ViewChild, args: ['conditionSelect', { read: IgxSelectComponent },] }],
        searchValueInput: [{ type: i0.ViewChild, args: ['searchValueInput', { read: i0.ElementRef },] }],
        addRootAndGroupButton: [{ type: i0.ViewChild, args: ['addRootAndGroupButton', { read: i0.ElementRef },] }],
        addConditionButton: [{ type: i0.ViewChild, args: ['addConditionButton', { read: i0.ElementRef },] }],
        editingInputsContainer: [{ type: i0.ViewChild, args: ['editingInputsContainer', { read: i0.ElementRef },] }],
        addModeContainer: [{ type: i0.ViewChild, args: ['addModeContainer', { read: i0.ElementRef },] }],
        currentGroupButtonsContainer: [{ type: i0.ViewChild, args: ['currentGroupButtonsContainer', { read: i0.ElementRef },] }],
        contextMenuToggle: [{ type: i0.ViewChild, args: [IgxToggleDirective,] }],
        chips: [{ type: i0.ViewChildren, args: [IgxChipComponent,] }],
        display: [{ type: i0.HostBinding, args: ['style.display',] }],
        expressionsContainer: [{ type: i0.ViewChild, args: ['expressionsContainer',] }],
        overlayOutlet: [{ type: i0.ViewChild, args: ['overlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
        grid: [{ type: i0.Input }]
    };

    /**
     * @hidden
     * @internal
     */
    var IgxRowSelectorDirective = /** @class */ (function () {
        function IgxRowSelectorDirective(templateRef) {
            this.templateRef = templateRef;
        }
        return IgxRowSelectorDirective;
    }());
    IgxRowSelectorDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxRowSelector]'
                },] }
    ];
    IgxRowSelectorDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    /**
     * @hidden
     * @internal
     */
    var IgxGroupByRowSelectorDirective = /** @class */ (function () {
        function IgxGroupByRowSelectorDirective(templateRef) {
            this.templateRef = templateRef;
        }
        return IgxGroupByRowSelectorDirective;
    }());
    IgxGroupByRowSelectorDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxGroupByRowSelector]'
                },] }
    ];
    IgxGroupByRowSelectorDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    /**
     * @hidden
     * @internal
     */
    var IgxHeadSelectorDirective = /** @class */ (function () {
        function IgxHeadSelectorDirective(templateRef) {
            this.templateRef = templateRef;
        }
        return IgxHeadSelectorDirective;
    }());
    IgxHeadSelectorDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxHeadSelector]'
                },] }
    ];
    IgxHeadSelectorDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };

    var ghostBackgroundClass = 'igx-grid__tr--ghost';
    var gridCellClass = 'igx-grid__td';
    var rowSelectedClass = 'igx-grid__tr--selected';
    var cellSelectedClass = 'igx-grid__td--selected';
    var cellActiveClass = 'igx-grid__td--active';
    /**
     * @hidden
     */
    var IgxRowDragDirective = /** @class */ (function (_super) {
        __extends(IgxRowDragDirective, _super);
        function IgxRowDragDirective() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this._rowDragStarted = false;
            _this.transitionEndEvent = function (evt) {
                if (_this.ghostElement) {
                    _this.ghostElement.removeEventListener('transitionend', _this.transitionEndEvent, false);
                }
                _this.endDragging();
            };
            return _this;
        }
        Object.defineProperty(IgxRowDragDirective.prototype, "row", {
            get: function () {
                return this.data;
            },
            enumerable: false,
            configurable: true
        });
        IgxRowDragDirective.prototype.onPointerDown = function (event) {
            event.preventDefault();
            this._rowDragStarted = false;
            this._removeOnDestroy = false;
            _super.prototype.onPointerDown.call(this, event);
        };
        IgxRowDragDirective.prototype.onPointerMove = function (event) {
            var _this = this;
            _super.prototype.onPointerMove.call(this, event);
            if (this._dragStarted && !this._rowDragStarted) {
                this._rowDragStarted = true;
                var args = {
                    dragDirective: this,
                    dragData: this.row,
                    cancel: false,
                    owner: this.row.grid
                };
                this.row.grid.onRowDragStart.emit(args);
                if (args.cancel) {
                    this.ghostElement.parentNode.removeChild(this.ghostElement);
                    this.ghostElement = null;
                    this._dragStarted = false;
                    this._clicked = false;
                    return;
                }
                this.row.grid.dragRowID = this.row.rowID;
                this.row.grid.rowDragging = true;
                this.row.grid.markForCheck();
                this.subscription$ = rxjs.fromEvent(this.row.grid.document.defaultView, 'keydown').subscribe(function (ev) {
                    if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                        _this._lastDropArea = false;
                        _this.onPointerUp(event);
                    }
                });
            }
        };
        IgxRowDragDirective.prototype.onPointerUp = function (event) {
            var _this = this;
            if (!this._clicked) {
                return;
            }
            var args = {
                dragDirective: this,
                dragData: this.row,
                animation: false,
                owner: this.row.grid
            };
            this.zone.run(function () {
                _this.row.grid.onRowDragEnd.emit(args);
            });
            var dropArea = this._lastDropArea;
            _super.prototype.onPointerUp.call(this, event);
            if (!dropArea && this.ghostElement) {
                this.ghostElement.addEventListener('transitionend', this.transitionEndEvent, false);
            }
            else {
                this.endDragging();
            }
        };
        IgxRowDragDirective.prototype.createGhost = function (pageX, pageY) {
            var e_1, _a;
            this.row.grid.endEdit(false);
            this.row.grid.markForCheck();
            this.ghostContext = {
                $implicit: this.row.rowData,
                data: this.row.rowData,
                grid: this.row.grid
            };
            _super.prototype.createGhost.call(this, pageX, pageY, this.row.nativeElement);
            // check if there is an expander icon and create the ghost at the corresponding position
            if (this.isHierarchicalGrid) {
                var row = this.row;
                if (row.expander) {
                    var expanderWidth = row.expander.nativeElement.getBoundingClientRect().width;
                    this._ghostHostX += expanderWidth;
                }
            }
            var ghost = this.ghostElement;
            var gridRect = this.row.grid.nativeElement.getBoundingClientRect();
            var rowRect = this.row.nativeElement.getBoundingClientRect();
            ghost.style.overflow = 'hidden';
            ghost.style.width = gridRect.width + 'px';
            ghost.style.height = rowRect.height + 'px';
            this.renderer.addClass(ghost, ghostBackgroundClass);
            this.renderer.removeClass(ghost, rowSelectedClass);
            var ghostCells = ghost.getElementsByClassName(gridCellClass);
            try {
                for (var ghostCells_1 = __values(ghostCells), ghostCells_1_1 = ghostCells_1.next(); !ghostCells_1_1.done; ghostCells_1_1 = ghostCells_1.next()) {
                    var cell = ghostCells_1_1.value;
                    this.renderer.removeClass(cell, cellSelectedClass);
                    this.renderer.removeClass(cell, cellActiveClass);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (ghostCells_1_1 && !ghostCells_1_1.done && (_a = ghostCells_1.return)) _a.call(ghostCells_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        IgxRowDragDirective.prototype._unsubscribe = function () {
            if (this.subscription$ && !this.subscription$.closed) {
                this.subscription$.unsubscribe();
            }
        };
        IgxRowDragDirective.prototype.endDragging = function () {
            this.onTransitionEnd(null);
            this.row.grid.dragRowID = null;
            this.row.grid.rowDragging = false;
            this.row.grid.markForCheck();
            this._unsubscribe();
        };
        Object.defineProperty(IgxRowDragDirective.prototype, "isHierarchicalGrid", {
            get: function () {
                return this.row.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
            },
            enumerable: false,
            configurable: true
        });
        return IgxRowDragDirective;
    }(IgxDragDirective));
    IgxRowDragDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxRowDrag]'
                },] }
    ];
    IgxRowDragDirective.propDecorators = {
        data: [{ type: i0.Input, args: ['igxRowDrag',] }]
    };
    /**
     * @hidden
     */
    var IgxDragIndicatorIconDirective = /** @class */ (function () {
        function IgxDragIndicatorIconDirective() {
        }
        return IgxDragIndicatorIconDirective;
    }());
    IgxDragIndicatorIconDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDragIndicatorIcon]'
                },] }
    ];
    /**
     * @hidden
     */
    var IgxRowDragGhostDirective = /** @class */ (function () {
        function IgxRowDragGhostDirective(templateRef) {
            this.templateRef = templateRef;
        }
        return IgxRowDragGhostDirective;
    }());
    IgxRowDragGhostDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxRowDragGhost]'
                },] }
    ];
    IgxRowDragGhostDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    var IgxRowDragModule = /** @class */ (function () {
        function IgxRowDragModule() {
        }
        return IgxRowDragModule;
    }());
    IgxRowDragModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective],
                    entryComponents: [],
                    exports: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective],
                    imports: []
                },] }
    ];

    var NEXT_ID$j = 0;
    /**
     * **Ignite UI for Angular Snackbar** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/snackbar.html)
     *
     * The Ignite UI Snack Bar provides feedback about an operation with a single-line message, which can
     * include a link to an action such as Undo.
     *
     * Example:
     * ```html
     * <button (click)="snackbar.show()">Send message</button>
     * <div>
     *   <igx-snackbar #snackbar message="Message sent">
     *   </igx-snackbar>
     * </div>
     * ```
     */
    var IgxSnackbarComponent = /** @class */ (function () {
        function IgxSnackbarComponent() {
            /**
             * Sets/gets the `id` of the snackbar.
             * If not set, the `id` of the first snackbar component  will be `"igx-snackbar-0"`;
             * ```html
             * <igx-snackbar id = "Snackbar1"></igx-snackbar>
             * ```
             * ```typescript
             * let snackbarId = this.snackbar.id;
             * ```
             *
             * @memberof IgxSnackbarComponent
             */
            this.id = "igx-snackbar-" + NEXT_ID$j++;
            /**
             * Enables/Disables the visibility of the snackbar.
             * If not set, the `isVisible` attribute will have value `false`.
             * ```html
             * <igx-snackbar [isVisible] = "true"></igx-snackbar>
             * ```
             * ```typescript
             * let isVisible =  this.snackbar.isVisible;
             * ```
             */
            this.isVisible = false;
            /**
             * Sets/gets if the snackbar will be automatically hidden after the `displayTime` is over.
             * Default value is `true`.
             * ```html
             * <igx-snackbar [autoHide] = "false"></igx-snackbar>
             * ```
             * ```typescript
             * let autoHide =  this.snackbar.autoHide;
             * ```
             */
            this.autoHide = true;
            /**
             * Sets/gets the duration of time(in milliseconds) in which the snackbar will be visible after it is being shown.
             * Default value is 4000.
             * ```html
             * <igx-snackbar [displayTime] = "2000"></igx-snackbar>
             * ```
             * ```typescript
             * let displayTime = this.snackbar.displayTime;
             * ```
             */
            this.displayTime = 4000;
            /**
             * An event that will be emitted when the action button is clicked.
             * Provides reference to the `IgxSnackbarComponent` as an argument.
             * ```html
             * <igx-snackbar (clicked)="clickedHandler($event)"></igx-snackbar>
             * ```
             */
            this.clicked = new i0.EventEmitter();
            /**
             * An event that will be emitted when the snackbar animation starts.
             * Provides reference to the `AnimationEvent` interface as an argument.
             * ```html
             * <igx-snackbar (animationStarted) = "animationStarted($event)"></igx-snackbar>
             * ```
             */
            this.animationStarted = new i0.EventEmitter();
            /**
             * An event that will be emitted when the snackbar animation ends.
             * Provides reference to the `AnimationEvent` interface as an argument.
             * ```html
             * <igx-snackbar (animationDone) = "animationDone($event)"></igx-snackbar>
             * ```
             */
            this.animationDone = new i0.EventEmitter();
            /**
             * @hidden
             * @internal
             */
            this.snackbarMessage = '';
        }
        Object.defineProperty(IgxSnackbarComponent.prototype, "message", {
            get: function () {
                return this.snackbarMessage;
            },
            /**
             * Sets/gets the `message` attribute.
             * ```html
             * <igx-snackbar [message] = "'Snackbar Component'"></igx-snackbar>
             * ```
             * ```typescript
             * let message =  this.snackbar.message;
             * ```
             */
            set: function (value) {
                this.snackbarMessage = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @deprecated
         * Shows the snackbar and hides it after the `displayTime` is over if `autoHide` is set to `true`.
         * ```typescript
         * this.snackbar.show();
         * ```
         */
        IgxSnackbarComponent.prototype.show = function (message) {
            this.open(message);
        };
        /**
         * @deprecated
         * Hides the snackbar.
         * ```typescript
         * this.snackbar.hide();
         * ```
         */
        IgxSnackbarComponent.prototype.hide = function () {
            this.close();
        };
        /**
         * Shows the snackbar and hides it after the `displayTime` is over if `autoHide` is set to `true`.
         * ```typescript
         * this.snackbar.open();
         * ```
         */
        IgxSnackbarComponent.prototype.open = function (message) {
            var _this = this;
            clearTimeout(this.timeoutId);
            if (message !== undefined) {
                this.snackbarMessage = message;
            }
            setTimeout(this.timeoutId);
            this.isVisible = true;
            if (this.autoHide) {
                this.timeoutId = setTimeout(function () {
                    _this.close();
                }, this.displayTime);
            }
        };
        /**
         * Hides the snackbar.
         * ```typescript
         * this.snackbar.close();
         * ```
         */
        IgxSnackbarComponent.prototype.close = function () {
            this.isVisible = false;
            clearTimeout(this.timeoutId);
        };
        /**
         * @hidden
         */
        IgxSnackbarComponent.prototype.triggerAction = function () {
            this.clicked.emit(this);
        };
        /**
         * @hidden
         * @memberof IgxSnackbarComponent
         */
        IgxSnackbarComponent.prototype.snackbarAnimationStarted = function (evt) {
            if (evt.phaseName === 'start') {
                this.animationStarted.emit(evt);
            }
        };
        /**
         * @hidden
         * @memberof IgxSnackbarComponent
         */
        IgxSnackbarComponent.prototype.snackbarAnimationDone = function (evt) {
            if (evt.phaseName === 'done') {
                this.animationDone.emit(evt);
            }
        };
        return IgxSnackbarComponent;
    }());
    IgxSnackbarComponent.decorators = [
        { type: i0.Component, args: [{
                    animations: [
                        i1.trigger('slideInOut', [
                            i1.transition('void => *', [
                                i1.useAnimation(slideInBottom, {
                                    params: {
                                        duration: '.35s',
                                        easing: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
                                        fromPosition: 'translateY(100%)',
                                        toPosition: 'translateY(0)'
                                    }
                                })
                            ]),
                            i1.transition('* => void', [
                                i1.useAnimation(slideOutBottom, {
                                    params: {
                                        duration: '.2s',
                                        easing: 'cubic-bezier(0.4, 0.0, 1, 1)',
                                        fromPosition: 'translateY(0)',
                                        toOpacity: 1,
                                        toPosition: 'translateY(100%)'
                                    }
                                })
                            ])
                        ]),
                        i1.trigger('fadeInOut', [
                            i1.transition('void => *', [
                                i1.useAnimation(fadeIn, {
                                    params: {
                                        duration: '.35s',
                                        easing: 'ease-out'
                                    }
                                })
                            ]),
                            i1.transition('* => void', [
                                i1.useAnimation(fadeOut, {
                                    params: {
                                        duration: '.2s',
                                        easing: 'ease-out'
                                    }
                                })
                            ])
                        ])
                    ],
                    selector: 'igx-snackbar',
                    template: "<div class=\"igx-snackbar\" *ngIf=\"isVisible\" (@slideInOut.start)=\"snackbarAnimationStarted($event)\" (@slideInOut.done)=\"snackbarAnimationDone($event)\"\n    [@slideInOut]=\"isVisible\">\n    <div class=\"igx-snackbar__message\" [@fadeInOut]=\"isVisible\">\n        {{ snackbarMessage }}\n        <ng-content></ng-content>\n    </div>\n    <button class=\"igx-snackbar__button\" igxRipple=\"white\" *ngIf=\"actionText\" [@fadeInOut] (click)=\"triggerAction()\">\n        {{ actionText }}\n    </button>\n</div>\n",
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                },] }
    ];
    IgxSnackbarComponent.ctorParameters = function () { return []; };
    IgxSnackbarComponent.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        message: [{ type: i0.Input }],
        isVisible: [{ type: i0.Input }],
        autoHide: [{ type: i0.Input }],
        displayTime: [{ type: i0.Input }],
        actionText: [{ type: i0.Input }],
        clicked: [{ type: i0.Output }],
        animationStarted: [{ type: i0.Output }],
        animationDone: [{ type: i0.Output }]
    };
    __decorate([
        DeprecateProperty("'message' property is deprecated.\n    You can use place the message in the snackbar content or pass a message parameter to the show method instead.")
    ], IgxSnackbarComponent.prototype, "message", null);
    __decorate([
        DeprecateMethod("'show' is deprecated. Use 'open' method instead.")
    ], IgxSnackbarComponent.prototype, "show", null);
    __decorate([
        DeprecateMethod("'hide' is deprecated. Use 'close' method instead.")
    ], IgxSnackbarComponent.prototype, "hide", null);
    /**
     * @hidden
     */
    var IgxSnackbarModule = /** @class */ (function () {
        function IgxSnackbarModule() {
        }
        return IgxSnackbarModule;
    }());
    IgxSnackbarModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxSnackbarComponent],
                    exports: [IgxSnackbarComponent],
                    imports: [i2.CommonModule]
                },] }
    ];

    var FAKE_ROW_ID = -1;
    var MINIMUM_COLUMN_WIDTH = 136;
    var FILTER_ROW_HEIGHT = 50;
    // By default row editing overlay outlet is inside grid body so that overlay is hidden below grid header when scrolling.
    // In cases when grid has 1-2 rows there isn't enough space in grid body and row editing overlay should be shown above header.
    // Default row editing overlay height is higher then row height that is why the case is valid also for row with 2 rows.
    // More accurate calculation is not possible, cause row editing overlay is still not shown and we don't know its height,
    // but in the same time we need to set row editing overlay outlet before opening the overlay itself.
    var MIN_ROW_EDITING_COUNT_THRESHOLD = 2;
    var IgxGridTransaction = new i0.InjectionToken('IgxGridTransaction');
    var IgxGridBaseDirective = /** @class */ (function (_super) {
        __extends(IgxGridBaseDirective, _super);
        function IgxGridBaseDirective(selectionService, crudService, colResizingService, gridAPI, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.selectionService = selectionService;
            _this.crudService = crudService;
            _this.colResizingService = colResizingService;
            _this.gridAPI = gridAPI;
            _this._transactions = _transactions;
            _this.elementRef = elementRef;
            _this.zone = zone;
            _this.document = document;
            _this.cdr = cdr;
            _this.resolver = resolver;
            _this.differs = differs;
            _this.viewRef = viewRef;
            _this.navigation = navigation;
            _this.filteringService = filteringService;
            _this.overlayService = overlayService;
            _this.summaryService = summaryService;
            _this._displayDensityOptions = _displayDensityOptions;
            _this.localeId = localeId;
            /**
             * Gets/Sets the display time for the row adding snackbar notification.
             *
             * @remarks
             * By default it is 6000ms.
             */
            _this.snackbarDisplayTime = 6000;
            /**
             * Gets/Sets whether to autogenerate the columns.
             *
             * @remarks
             * The default value is false. When set to true, it will override all columns declared through code or in markup.
             * @example
             * ```html
             * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.autoGenerate = false;
            /**
             * Controls the copy behavior of the grid.
             */
            _this.clipboardOptions = {
                /**
                 * Enables/disables the copy behavior
                 */
                enabled: true,
                /**
                 * Include the columns headers in the clipboard output.
                 */
                copyHeaders: true,
                /**
                 * Apply the columns formatters (if any) on the data in the clipboard output.
                 */
                copyFormatters: true,
                /**
                 * The separator used for formatting the copy output. Defaults to `\t`.
                 */
                separator: '\t'
            };
            /**
             * Emitted after filtering is performed.
             *
             * @remarks
             * Returns the filtering expressions tree of the column for which filtering was performed.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
             *              (filteringExpressionsTreeChange)="filteringExprTreeChange($event)"></igx-grid>
             * ```
             */
            _this.filteringExpressionsTreeChange = new i0.EventEmitter();
            /**
             * Emitted after advanced filtering is performed.
             *
             * @remarks
             * Returns the advanced filtering expressions tree.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
             *           (advancedFilteringExpressionsTreeChange)="advancedFilteringExprTreeChange($event)"></igx-grid>
             * ```
             */
            _this.advancedFilteringExpressionsTreeChange = new i0.EventEmitter();
            /**
             * Emitted when grid is scrolled horizontally/vertically.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
             *              (onScroll)="onScroll($event)"></igx-grid>
             * ```
             */
            _this.onScroll = new i0.EventEmitter();
            /**
             * Emitted after the current page is changed.
             *
             * @example
             * ```html
             * <igx-grid (pageChange)="onPageChange($event)"></igx-grid>
             * ```
             * ```typescript
             * public onPageChange(page: number) {
             *   this.currentPage = page;
             * }
             * ```
             */
            _this.pageChange = new i0.EventEmitter();
            /**
             * Emitted when `perPage` property value of the grid is changed.
             *
             * @example
             * ```html
             * <igx-grid #grid (perPageChange)="onPerPageChange($event)" [autoGenerate]="true"></igx-grid>
             * ```
             * ```typescript
             * public onPerPageChange(perPage: number) {
             *   this.perPage = perPage;
             * }
             * ```
             */
            _this.perPageChange = new i0.EventEmitter();
            /**
             * @hidden
             * @internal
             */
            _this.class = '';
            /**
             * Gets/Sets the styling classes applied to all even `IgxGridRowComponent`s in the grid.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-even-class'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.evenRowCSS = 'igx-grid__tr--even';
            /**
             * Gets/Sets the styling classes applied to all odd `IgxGridRowComponent`s in the grid.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-odd-class'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.oddRowCSS = 'igx-grid__tr--odd';
            /**
             * Emitted when `IgxGridCellComponent` is clicked.
             *
             * @remarks
             * Returns the `IgxGridCellComponent`.
             * @example
             * ```html
             * <igx-grid #grid (onCellClick)="onCellClick($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onCellClick = new i0.EventEmitter();
            /**
             * Emitted when `IgxGridCellComponent` is selected.
             *
             * @remarks
             *  Returns the `IgxGridCellComponent`.
             * @example
             * ```html
             * <igx-grid #grid (onSelection)="onCellSelect($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onSelection = new i0.EventEmitter();
            /**
             *  Emitted when `IgxGridRowComponent` is selected.
             *
             * @example
             * ```html
             * <igx-grid #grid (onRowSelectionChange)="onCellClickChange($event)" [data]="localData" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onRowSelectionChange = new i0.EventEmitter();
            /**
             *  Emitted when `IgxColumnComponent` is selected.
             *
             * @example
             * ```html
             * <igx-grid #grid (onColumnSelectionChange)="onColumnSelectionChange($event)" [data]="localData" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onColumnSelectionChange = new i0.EventEmitter();
            /**
             * Emitted before `IgxColumnComponent` is pinned.
             *
             * @remarks
             * The index at which to insert the column may be changed through the `insertAtIndex` property.
             * @example
             * ```typescript
             * public columnPinning(event) {
             *     if (event.column.field === "Name") {
             *       event.insertAtIndex = 0;
             *     }
             * }
             * ```
             */
            _this.onColumnPinning = new i0.EventEmitter();
            /**
             * Emitted after `IgxColumnComponent` is pinned.
             *
             * @remarks
             * The index that the column is inserted at may be changed through the `insertAtIndex` property.
             * @example
             * ```typescript
             * public columnPinning(event) {
             *     if (event.column.field === "Name") {
             *       event.insertAtIndex = 0;
             *     }
             * }
             * ```
             */
            _this.columnPinned = new i0.EventEmitter();
            /**
             * Emitted when cell enters edit mode.
             *
             * @remarks
             * This event is cancelable.
             * @example
             * ```html
             * <igx-grid #grid3 (cellEditEnter)="editStart($event)" [data]="data" [primaryKey]="'ProductID'">
             * </igx-grid>
             * ```
             */
            _this.cellEditEnter = new i0.EventEmitter();
            /**
             * Emitted when cell exits edit mode.
             *
             * @example
             * ```html
             * <igx-grid #grid3 (cellEditExit)="editExit($event)" [data]="data" [primaryKey]="'ProductID'">
             * </igx-grid>
             * ```
             */
            _this.cellEditExit = new i0.EventEmitter();
            /**
             * Emitted when cell has been edited.
             *
             * @remarks
             * Event is fired after editing is completed, when the cell is exiting edit mode.
             * This event is cancelable.
             * @example
             * ```html
             * <igx-grid #grid3 (cellEdit)="editDone($event)" [data]="data" [primaryKey]="'ProductID'">
             * </igx-grid>
             * ```
             */
            _this.cellEdit = new i0.EventEmitter();
            /**
             * Emitted after cell has been edited and editing has been committed.
             *
             * @example
             * ```html
             * <igx-grid #grid3 (cellEditDone)="editDone($event)" [data]="data" [primaryKey]="'ProductID'">
             * </igx-grid>
             * ```
             */
            _this.cellEditDone = new i0.EventEmitter();
            /**
             * Emitted when a row enters edit mode.
             *
             * @remarks
             * Emitted when [rowEditable]="true".
             * This event is cancelable.
             * @example
             * ```html
             * <igx-grid #grid3 (rowEditEnter)="editStart($event)" [primaryKey]="'ProductID'" [rowEditable]="true">
             * </igx-grid>
             * ```
             */
            _this.rowEditEnter = new i0.EventEmitter();
            /**
             * Emitted when exiting edit mode for a row.
             *
             * @remarks
             * Emitted when [rowEditable]="true" & `endEdit(true)` is called.
             * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,
             * performing paging operation, column resizing, pinning, moving or hitting `Done`
             * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.
             * This event is cancelable.
             * @example
             * ```html
             * <igx-grid #grid3 (rowEdit)="editDone($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
             * </igx-grid>
             * ```
             */
            _this.rowEdit = new i0.EventEmitter();
            /**
             * Emitted after exiting edit mode for a row and editing has been committed.
             *
             * @remarks
             * Emitted when [rowEditable]="true" & `endEdit(true)` is called.
             * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,
             * performing paging operation, column resizing, pinning, moving or hitting `Done`
             * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.
             * @example
             * ```html
             * <igx-grid #grid3 (rowEditDone)="editDone($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
             * </igx-grid>
             * ```
             */
            _this.rowEditDone = new i0.EventEmitter();
            /**
             * Emitted when row editing is canceled.
             *
             * @remarks
             * Emits when [rowEditable]="true" & `endEdit(false)` is called.
             * Emitted when changing hitting `Esc` key during cell editing and when click on the `Cancel` button
             * in the row editing overlay.
             * @example
             * ```html
             * <igx-grid #grid3 (rowEditExit)="editExit($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
             * </igx-grid>
             * ```
             */
            _this.rowEditExit = new i0.EventEmitter();
            /**
             * Emitted when a column is initialized.
             *
             * @remarks
             * Returns the column object.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [onColumnInit]="initColumns($event)" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onColumnInit = new i0.EventEmitter();
            /**
             * Emitted before sorting expressions are applied.
             *
             * @remarks
             * Returns an `ISortingEventArgs` object. `sortingExpressions` key holds the sorting expressions.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [autoGenerate]="true" (onSorting)="sorting($event)"></igx-grid>
             * ```
             */
            _this.sorting = new i0.EventEmitter();
            /**
             * Emitted after sorting is completed.
             *
             * @remarks
             * Returns the sorting expression.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [autoGenerate]="true" (onSortingDone)="sortingDone($event)"></igx-grid>
             * ```
             */
            _this.onSortingDone = new i0.EventEmitter();
            /**
             * Emitted before filtering expressions are applied.
             *
             * @remarks
             * Returns an `IFilteringEventArgs` object. `filteringExpressions` key holds the filtering expressions for the column.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (filtering)="filtering($event)"></igx-grid>
             * ```
             */
            _this.filtering = new i0.EventEmitter();
            /**
             * Emitted after filtering is performed through the UI.
             *
             * @remarks
             * Returns the filtering expressions tree of the column for which filtering was performed.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onFilteringDone)="filteringDone($event)"></igx-grid>
             * ```
             */
            _this.onFilteringDone = new i0.EventEmitter();
            /**
             * Emitted after paging is performed.
             *
             * @remarks
             * Returns an object consisting of the previous and next pages.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onPagingDone)="pagingDone($event)"></igx-grid>
             * ```
             */
            _this.onPagingDone = new i0.EventEmitter();
            /**
             * Emitted when a row added through the API.
             *
             * @remarks
             * Returns the data for the new `IgxGridRowComponent` object.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" (onRowAdded)="rowAdded($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onRowAdded = new i0.EventEmitter();
            /**
             * Emitted when a row is deleted through API.
             *
             * @remarks
             * Returns an `IRowDataEventArgs` object.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" (onRowDeleted)="rowDeleted($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onRowDeleted = new i0.EventEmitter();
            /**
             * Emitted after column is resized.
             *
             * @remarks
             * Returns the `IgxColumnComponent` object's old and new width.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" (onColumnResized)="resizing($event)" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onColumnResized = new i0.EventEmitter();
            /**
             * Emitted when a cell is right clicked.
             *
             * @remarks
             * Returns the `IgxGridCellComponent` object.
             * ```html
             * <igx-grid #grid [data]="localData" (onContextMenu)="contextMenu($event)" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onContextMenu = new i0.EventEmitter();
            /**
             * Emitted when a cell is double clicked.
             *
             * @remarks
             * Returns the `IgxGridCellComponent` object.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" (onDoubleClick)="dblClick($event)" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onDoubleClick = new i0.EventEmitter();
            /**
             * Emitted before column visibility is changed.
             *
             * @remarks
             * Args: { column: any, newValue: boolean }
             * @example
             * ```html
             * <igx-grid [columnHiding]="true" [showToolbar]="true" (columnVisibilityChanging)="visibilityChanging($event)"></igx-grid>
             * ```
             */
            _this.columnVisibilityChanging = new i0.EventEmitter();
            /**
             * Emitted after column visibility is changed.
             *
             * @remarks
             * Args: { column: IgxColumnComponent, newValue: boolean }
             * @example
             * ```html
             * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnVisibilityChanged)="visibilityChanged($event)"></igx-grid>
             * ```
             */
            _this.onColumnVisibilityChanged = new i0.EventEmitter();
            /**
             * Emitted when column moving starts.
             *
             * @remarks
             * Returns the moved `IgxColumnComponent` object.
             * @example
             * ```html
             * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingStart)="movingStart($event)"></igx-grid>
             * ```
             */
            _this.onColumnMovingStart = new i0.EventEmitter();
            /**
             * Emitted during the column moving operation.
             *
             * @remarks
             * Returns the source and target `IgxColumnComponent` objects. This event is cancelable.
             * @example
             * ```html
             * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMoving)="moving($event)"></igx-grid>
             * ```
             */
            _this.onColumnMoving = new i0.EventEmitter();
            /**
             * Emitted when column moving ends.
             *
             * @remarks
             * Returns the source and target `IgxColumnComponent` objects.
             * @example
             * ```html
             * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingEnd)="movingEnds($event)"></igx-grid>
             * ```
             */
            _this.onColumnMovingEnd = new i0.EventEmitter();
            /**
             * Emitted when keydown is triggered over element inside grid's body.
             *
             * @remarks
             * This event is fired only if the key combination is supported in the grid.
             * Return the target type, target object and the original event. This event is cancelable.
             * @example
             * ```html
             *  <igx-grid (onGridKeydown)="customKeydown($event)"></igx-grid>
             * ```
             */
            _this.onGridKeydown = new i0.EventEmitter();
            /**
             * Emitted when start dragging a row.
             *
             * @remarks
             * Return the dragged row.
             */
            _this.onRowDragStart = new i0.EventEmitter();
            /**
             * Emitted when dropping a row.
             *
             * @remarks
             * Return the dropped row.
             */
            _this.onRowDragEnd = new i0.EventEmitter();
            /**
             * Emitted when a copy operation is executed.
             *
             * @remarks
             * Fired only if copy behavior is enabled through the [`clipboardOptions`]{@link IgxGridBaseDirective#clipboardOptions}.
             */
            _this.onGridCopy = new i0.EventEmitter();
            /**
             * @hidden @internal
             */
            _this.expansionStatesChange = new i0.EventEmitter();
            /**
             * Emitted when the expanded state of a row gets changed.
             *
             * @example
             * ```html
             * <igx-grid [data]="employeeData" (onRowToggle)="rowToggle($event)" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onRowToggle = new i0.EventEmitter();
            /**
             * Emitted when the pinned state of a row is changed.
             *
             * @example
             * ```html
             * <igx-grid [data]="employeeData" (onRowPinning)="rowPin($event)" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onRowPinning = new i0.EventEmitter();
            /**
             * Emmited when the active node is changed.
             *
             * @example
             * ```
             * <igx-grid [data]="data" [autoGenerate]="true" (activeNodeChange)="activeNodeChange($event)"></igx-grid>
             * ```
             */
            _this.activeNodeChange = new i0.EventEmitter();
            /**
             * Emitted before sorting is performed.
             *
             * @remarks
             * Returns the sorting expressions.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [autoGenerate]="true" (sortingExpressionsChange)="sortingExprChange($event)"></igx-grid>
             * ```
             */
            _this.sortingExpressionsChange = new i0.EventEmitter();
            /**
             * Emitted when an export process is initiated by the user.
             *
             * @example
             * ```typescript
             * toolbarExporting(event: IGridToolbarExportEventArgs){
             *     const toolbarExporting = event;
             * }
             * ```
             */
            _this.onToolbarExporting = new i0.EventEmitter();
            /* End of toolbar related definitions */
            /**
             * Emitted when making a range selection.
             *
             * @remarks
             * Range selection can be made either through drag selection or through keyboard selection.
             */
            _this.onRangeSelection = new i0.EventEmitter();
            /** Emitted after the ngAfterViewInit hook. At this point the grid exists in the DOM */
            _this.rendered = new i0.EventEmitter();
            /**
             * @hidden @internal
             */
            _this.columnList = new i0.QueryList();
            /**
             * @hidden @internal
             */
            _this.tmpOutlets = new i0.QueryList();
            /**
             * The custom template, if any, that should be used when rendering a row expand indicator.
             */
            _this.rowExpandedIndicatorTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering a row collapse indicator.
             */
            _this.rowCollapsedIndicatorTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering a header expand indicator.
             */
            _this.headerExpandIndicatorTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering a header collapse indicator.
             */
            _this.headerCollapseIndicatorTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering a row expand indicator.
             */
            _this.excelStyleHeaderIconTemplate = null;
            /**
             * @hidden @internal
             */
            _this.tabindex = 0;
            /**
             * @hidden @internal
             */
            _this.hostRole = 'grid';
            /**
             * @hidden @internal
             */
            _this.cancelAddMode = false;
            /**
             * @hidden
             * @internal
             */
            _this.rowDragging = false;
            /**
             * Gets the row ID that is being dragged.
             *
             * @remarks
             * The row ID is either the primaryKey value or the data record instance.
             */
            _this.dragRowID = null;
            /**
             * @hidden @interal
             */
            _this.addRowParent = null;
            /**
             * @hidden @internal
             */
            _this.snackbarActionText = _this.resourceStrings.igx_grid_snackbar_addrow_actiontext;
            /**
             * @hidden @internal
             */
            _this.snackbarLabel = _this.resourceStrings.igx_grid_snackbar_addrow_label;
            /**
             * @hidden @internal
             */
            _this.calcHeight = 0;
            /**
             * @hidden @internal
             */
            _this.chipsGoupingExpressions = [];
            /**
             * @hidden @internal
             */
            _this.disableTransitions = false;
            /**
             * @hidden @internal
             */
            _this.lastSearchInfo = {
                searchText: '',
                caseSensitive: false,
                exactMatch: false,
                activeMatchIndex: 0,
                matchInfoCache: []
            };
            /**
             * @hidden @internal
             */
            _this.columnWidthSetByUser = false;
            _this.rendered$ = _this.rendered.asObservable().pipe(operators.shareReplay(1));
            /** @hidden @internal */
            _this.resizeNotify = new rxjs.Subject();
            /**
             * @hidden @internal
             */
            _this.paginatorSettings = null;
            _this._destroyed = false;
            /**
             * @hidden @internal
             */
            _this._totalRecords = -1;
            /**
             * @hidden @internal
             */
            _this.columnsWithNoSetWidths = null;
            /**
             * @hidden
             */
            _this._perPage = 15;
            /**
             * @hidden
             */
            _this._page = 0;
            /**
             * @hidden
             */
            _this._paging = false;
            /**
             * @hidden
             */
            _this._pagingMode = exports.GridPagingMode.Local;
            /**
             * @hidden
             */
            _this._hideRowSelectors = false;
            /**
             * @hidden
             */
            _this._rowDrag = false;
            /**
             * @hidden
             */
            _this._pipeTrigger = 0;
            /**
             * @hidden
             */
            _this._filteringPipeTrigger = 0;
            /**
             * @hidden
             */
            _this._summaryPipeTrigger = 0;
            /**
             * @hidden
             */
            _this._columns = [];
            /**
             * @hidden
             */
            _this._pinnedColumns = [];
            /**
             * @hidden
             */
            _this._unpinnedColumns = [];
            /**
             * @hidden
             */
            _this._filteringExpressionsTree = new FilteringExpressionsTree(exports.FilteringLogic.And);
            /**
             * @hidden
             */
            _this._sortingExpressions = [];
            /**
             * @hidden
             */
            _this._maxLevelHeaderDepth = null;
            /**
             * @hidden
             */
            _this._columnHiding = false;
            /**
             * @hidden
             */
            _this._columnPinning = false;
            _this._pinnedRecordIDs = [];
            /**
             * @hidden
             */
            _this.destroy$ = new rxjs.Subject();
            _this._allowFiltering = false;
            _this._allowAdvancedFiltering = false;
            _this._filterMode = FilterMode.quickFilter;
            _this.observer = new ResizeObserver__default['default'](function () { });
            _this._defaultTargetRecordNumber = 10;
            _this._expansionStates = new Map();
            _this._defaultExpandState = false;
            _this._headerFeaturesWidth = NaN;
            _this._init = true;
            _this._cdrRequestRepaint = false;
            /* Toolbar related definitions */
            _this._showToolbar = false;
            _this._exportExcel = false;
            _this._exportCsv = false;
            _this._toolbarTitle = null;
            _this._rowEditable = false;
            _this._filteredSortedData = null;
            _this._cdrRequests = false;
            _this._emptyGridMessage = null;
            _this._emptyFilteredGridMessage = null;
            _this._isLoading = false;
            _this.overlayIDs = [];
            _this._pinning = { columns: exports.ColumnPinningPosition.Start };
            _this._advancedFilteringPositionSettings = {
                verticalDirection: exports.VerticalAlignment.Middle,
                horizontalDirection: exports.HorizontalAlignment.Center,
                horizontalStartPoint: exports.HorizontalAlignment.Center,
                verticalStartPoint: exports.VerticalAlignment.Middle
            };
            _this._advancedFilteringOverlaySettings = {
                closeOnOutsideClick: false,
                modal: false,
                positionStrategy: new ConnectedPositioningStrategy(_this._advancedFilteringPositionSettings),
            };
            _this._hiddenColumnsText = '';
            _this._pinnedColumnsText = '';
            _this._height = '100%';
            _this._width = '100%';
            _this._horizontalForOfs = [];
            _this._multiRowLayoutRowSize = 1;
            // Caches
            _this._totalWidth = NaN;
            _this._pinnedVisible = [];
            _this._unpinnedVisible = [];
            _this._pinnedWidth = NaN;
            _this._unpinnedWidth = NaN;
            _this._visibleColumns = [];
            _this._columnGroups = false;
            _this._autoGeneratedCols = [];
            _this._summaryPosition = GridSummaryPosition.bottom;
            _this._summaryCalculationMode = GridSummaryCalculationMode.rootAndChildLevels;
            _this._showSummaryOnCollapse = false;
            _this._cellSelectionMode = GridSelectionMode.multiple;
            _this._rowSelectionMode = GridSelectionMode.none;
            _this._selectRowOnClick = true;
            _this._columnSelectionMode = GridSelectionMode.none;
            _this.rowEditPositioningStrategy = new RowEditPositionStrategy({
                horizontalDirection: exports.HorizontalAlignment.Right,
                verticalDirection: exports.VerticalAlignment.Bottom,
                horizontalStartPoint: exports.HorizontalAlignment.Left,
                verticalStartPoint: exports.VerticalAlignment.Bottom,
                closeAnimation: null
            });
            _this.rowEditSettings = {
                scrollStrategy: new AbsoluteScrollStrategy(),
                modal: false,
                closeOnOutsideClick: false,
                outlet: _this.rowOutletDirective,
                positionStrategy: _this.rowEditPositioningStrategy
            };
            /**
             * @hidden @internal
             */
            _this.preventContainerScroll = function (evt) {
                if (evt.target.scrollTop !== 0) {
                    _this.verticalScrollContainer.addScrollTop(evt.target.scrollTop);
                    evt.target.scrollTop = 0;
                }
                if (evt.target.scrollLeft !== 0) {
                    _this.headerContainer.scrollPosition += evt.target.scrollLeft;
                    evt.target.scrollLeft = 0;
                }
            };
            _this.locale = _this.locale || _this.localeId;
            _this.datePipe = new i2.DatePipe(_this.locale);
            _this.decimalPipe = new i2.DecimalPipe(_this.locale);
            _this.currencyPipe = new i2.CurrencyPipe(_this.locale);
            _this.percentPipe = new i2.PercentPipe(_this.locale);
            _this.cdr.detach();
            return _this;
        }
        Object.defineProperty(IgxGridBaseDirective.prototype, "resourceStrings", {
            get: function () {
                if (!this._resourceStrings) {
                    this._resourceStrings = CurrentResourceStrings.GridResStrings;
                }
                return this._resourceStrings;
            },
            /**
             * Gets/Sets the resource strings.
             *
             * @remarks
             * By default it uses EN resources.
             */
            set: function (value) {
                this._resourceStrings = Object.assign({}, this._resourceStrings, value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "filteringLogic", {
            /**
             * Gets/Sets the filtering logic of the `IgxGridComponent`.
             *
             * @remarks
             * The default is AND.
             * @example
             * ```html
             * <igx-grid [data]="Data" [autoGenerate]="true" [filteringLogic]="filtering"></igx-grid>
             * ```
             */
            get: function () {
                return this._filteringExpressionsTree.operator;
            },
            set: function (value) {
                this._filteringExpressionsTree.operator = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "filteringExpressionsTree", {
            /**
             * Gets/Sets the filtering state.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(filteringExpressionsTree)]="model.filteringExpressions"></igx-grid>
             * ```
             * @remarks
             * Supports two-way binding.
             */
            get: function () {
                return this._filteringExpressionsTree;
            },
            set: function (value) {
                if (value && value instanceof FilteringExpressionsTree) {
                    var val = value;
                    for (var index = 0; index < val.filteringOperands.length; index++) {
                        if (!(val.filteringOperands[index] instanceof FilteringExpressionsTree)) {
                            var newExpressionsTree = new FilteringExpressionsTree(exports.FilteringLogic.And, val.filteringOperands[index].fieldName);
                            newExpressionsTree.filteringOperands.push(val.filteringOperands[index]);
                            val.filteringOperands[index] = newExpressionsTree;
                        }
                    }
                    value.type = exports.FilteringExpressionsTreeType.Regular;
                    this._filteringExpressionsTree = value;
                    this._filteringPipeTrigger++;
                    this.filteringExpressionsTreeChange.emit(this._filteringExpressionsTree);
                    if (this.filteringService.isFilteringExpressionsTreeEmpty(this._filteringExpressionsTree) &&
                        !this.advancedFilteringExpressionsTree) {
                        this.filteredData = null;
                    }
                    this.filteringService.refreshExpressions();
                    this.selectionService.clearHeaderCBState();
                    this.summaryService.clearSummaryCache();
                    this.notifyChanges();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "advancedFilteringExpressionsTree", {
            /**
             * Gets/Sets the advanced filtering state.
             *
             * @example
             * ```typescript
             * let advancedFilteringExpressionsTree = this.grid.advancedFilteringExpressionsTree;
             * this.grid.advancedFilteringExpressionsTree = logic;
             * ```
             */
            get: function () {
                return this._advancedFilteringExpressionsTree;
            },
            set: function (value) {
                var _this = this;
                if (value && value instanceof FilteringExpressionsTree) {
                    value.type = exports.FilteringExpressionsTreeType.Advanced;
                    this._advancedFilteringExpressionsTree = value;
                    this._filteringPipeTrigger++;
                }
                else {
                    this._advancedFilteringExpressionsTree = null;
                }
                this.advancedFilteringExpressionsTreeChange.emit(this._advancedFilteringExpressionsTree);
                if (this.filteringService.isFilteringExpressionsTreeEmpty(this._advancedFilteringExpressionsTree) &&
                    !this.advancedFilteringExpressionsTree) {
                    this.filteredData = null;
                }
                this.selectionService.clearHeaderCBState();
                this.summaryService.clearSummaryCache();
                this.notifyChanges();
                // Wait for the change detection to update filtered data through the pipes and then emit the event.
                requestAnimationFrame(function () { return _this.onFilteringDone.emit(_this._advancedFilteringExpressionsTree); });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "locale", {
            /**
             * Gets/Sets the locale.
             *
             * @remarks
             * If not set, returns browser's language.
             */
            get: function () {
                return this._locale;
            },
            set: function (value) {
                if (value !== this._locale) {
                    this._locale = value;
                    this._currencyPositionLeft = undefined;
                    this.summaryService.clearSummaryCache();
                    this._pipeTrigger++;
                    this.notifyChanges();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "pagingMode", {
            get: function () {
                return this._pagingMode;
            },
            set: function (val) {
                this._pagingMode = val;
                this._pipeTrigger++;
                this.notifyChanges(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "paging", {
            /**
             * Gets/Sets whether the paging feature is enabled.
             *
             * @remarks
             * The default state is disabled (false).
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [autoGenerate]="true" [paging]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._paging;
            },
            set: function (value) {
                this._paging = value;
                this._pipeTrigger++;
                this.notifyChanges(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "page", {
            /**
             * Gets/Sets the current page index.
             *
             * @example
             * ```html
             *  <igx-grid #grid [data]="Data" [paging]="true" [(page)]="model.page" [autoGenerate]="true"></igx-grid>
             * ```
             * @remarks
             * Supports two-way binding.
             */
            get: function () {
                return this._page;
            },
            set: function (val) {
                if (val === this._page || val < 0 || val > this.totalPages - 1) {
                    return;
                }
                this.selectionService.clear(true);
                this.onPagingDone.emit({ previous: this._page, current: val });
                this._page = val;
                this.pageChange.emit(this._page);
                this.navigateTo(0);
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "perPage", {
            /**
             * Gets/Sets the number of visible items per page.
             *
             * @remarks
             * The default is 15.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [paging]="true" [(perPage)]="model.perPage" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._perPage;
            },
            set: function (val) {
                if (val < 0) {
                    return;
                }
                this.selectionService.clear(true);
                this._perPage = val;
                this.perPageChange.emit(this._perPage);
                this.page = 0;
                this.endEdit(false);
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "columnHiding", {
            /**
             * Gets/Sets whether the column hiding UI is enabled.
             *
             * @deprecated
             *
             * @remarks
             * By default it is disabled (false). In order for the UI to work, you need to enable the toolbar as shown in the example below.
             * @example
             * ```html
             * <igx-grid [data]="Data" [autoGenerate]="true" [showToolbar]="true" [columnHiding]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._columnHiding;
            },
            set: function (value) {
                this._columnHiding = value;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hideRowSelectors", {
            /**
             * Gets/Sets if the row selectors are hidden.
             *
             * @remarks
             *  By default row selectors are shown
             */
            get: function () {
                return this._hideRowSelectors;
            },
            set: function (value) {
                this._hideRowSelectors = value;
                this.notifyChanges(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowDraggable", {
            /**
             * Gets/Sets whether rows can be moved.
             *
             * @example
             * ```html
             * <igx-grid #grid [rowDraggable]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._rowDrag && this.hasVisibleColumns;
            },
            set: function (val) {
                this._rowDrag = val;
                this.notifyChanges(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowEditable", {
            /**
             * Gets/Sets whether the rows are editable.
             *
             * @remarks
             * By default it is set to false.
             * @example
             * ```html
             * <igx-grid #grid [showToolbar]="true" [rowEditable]="true" [primaryKey]="'ProductID'" [columnHiding]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._rowEditable;
            },
            set: function (val) {
                if (!this._init) {
                    this.refreshGridState();
                }
                this._rowEditable = val;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "height", {
            /**
             * Gets/Sets the height.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._height;
            },
            set: function (value) {
                if (this._height !== value) {
                    this._height = value;
                    this.nativeElement.style.height = value;
                    this.notifyChanges(true);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hostWidth", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._width || this._hostWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "width", {
            /**
             * Gets/Sets the width of the grid.
             *
             * @example
             * ```typescript
             * let gridWidth = this.grid.width;
             * ```
             */
            get: function () {
                return this._width;
            },
            set: function (value) {
                if (this._width !== value) {
                    this._width = value;
                    this.nativeElement.style.width = value;
                    this.notifyChanges(true);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "headerWidth", {
            /**
             * Gets the width of the header.
             *
             * @example
             * ```html
             * let gridHeaderWidth = this.grid.headerWidth;
             * ```
             */
            get: function () {
                return parseInt(this.width, 10) - 17;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowHeight", {
            /**
             * Gets/Sets the row height.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [showToolbar]="true" [rowHeight]="100" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._rowHeight ? this._rowHeight : this.defaultRowHeight;
            },
            set: function (value) {
                this._rowHeight = parseInt(value, 10);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "columnWidth", {
            /**
             * Gets/Sets the default width of the columns.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [showToolbar]="true" [columnWidth]="100" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._columnWidth;
            },
            set: function (value) {
                this._columnWidth = value;
                this.columnWidthSetByUser = true;
                this.notifyChanges(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "emptyGridMessage", {
            get: function () {
                return this._emptyGridMessage || this.resourceStrings.igx_grid_emptyGrid_message;
            },
            /**
             * Get/Sets the message displayed when there are no records.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            set: function (value) {
                this._emptyGridMessage = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isLoading", {
            get: function () {
                return this._isLoading;
            },
            /**
             * Gets/Sets whether the grid is going to show a loading indicator.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [isLoading]="true" [autoGenerate]="true"></igx-grid>
             * ```
             */
            set: function (value) {
                var _this = this;
                if (this._isLoading !== value) {
                    this._isLoading = value;
                    this.evaluateLoadingState();
                }
                Promise.resolve().then(function () {
                    // wait for the current detection cycle to end before triggering a new one.
                    _this.notifyChanges();
                });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "emptyFilteredGridMessage", {
            get: function () {
                return this._emptyFilteredGridMessage || this.resourceStrings.igx_grid_emptyFilteredGrid_message;
            },
            /**
             * Gets/Sets the message displayed when there are no records and the grid is filtered.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            set: function (value) {
                this._emptyFilteredGridMessage = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "columnHidingTitle", {
            /**
             * Gets/Sets the title to be displayed in the built-in column hiding UI.
             *
             * @deprecated
             *
             * @example
             * ```html
             * <igx-grid [showToolbar]="true" [columnHiding]="true" columnHidingTitle="Column Hiding"></igx-grid>
             * ```
             */
            get: function () {
                return this._columnHidingTitle;
            },
            set: function (v) {
                this._columnHidingTitle = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "columnHidingTitleInternal", {
            /** @hidden @internal */
            get: function () {
                return this._columnHidingTitle;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "pinning", {
            /**
             * Gets/Sets the initial pinning configuration.
             *
             * @remarks
             * Allows to apply pinning the columns to the start or the end.
             * Note that pinning to both sides at a time is not allowed.
             * @example
             * ```html
             * <igx-grid [pinning]="pinningConfig"></igx-grid>
             * ```
             */
            get: function () {
                return this._pinning;
            },
            set: function (value) {
                if (value !== this._pinning) {
                    this.resetCaches();
                }
                this._pinning = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "columnPinning", {
            /**
             * Gets/Sets if the built-in column pinning UI should be shown in the toolbar.
             *
             * @deprecated
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [columnPinning]="'true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._columnPinning;
            },
            set: function (value) {
                this._columnPinning = value;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "columnPinningTitle", {
            /**
             * Gets/Sets the title to be displayed in the UI of the column pinning.
             *
             * @deprecated
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [columnPinning]="'true" [columnPinningTitle]="'Column Hiding'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._columnPinningTitle;
            },
            set: function (v) {
                this._columnPinningTitle = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "columnPinningTitleInternal", {
            /** @hidden @internal */
            get: function () {
                return this._columnPinningTitle;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "allowFiltering", {
            /**
             * Gets/Sets if the filtering is enabled.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [allowFiltering]="true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._allowFiltering;
            },
            set: function (value) {
                if (this._allowFiltering !== value) {
                    this._allowFiltering = value;
                    this.filteringService.registerSVGIcons();
                    if (!this._init) {
                        this.calcGridHeadRow();
                    }
                    this.filteringService.isFilterRowVisible = false;
                    this.filteringService.filteredColumn = null;
                    this.notifyChanges(true);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "allowAdvancedFiltering", {
            /**
             * Gets/Sets a value indicating whether the advanced filtering is enabled.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [allowAdvancedFiltering]="true" [showToolbar]="true" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._allowAdvancedFiltering;
            },
            set: function (value) {
                if (this._allowAdvancedFiltering !== value) {
                    this._allowAdvancedFiltering = value;
                    this.filteringService.registerSVGIcons();
                    if (!this._init) {
                        this.notifyChanges(true);
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "filterMode", {
            /**
             * Gets/Sets the filter mode.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [filterMode]="'quickFilter'" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             * @remarks
             * By default it's set to FilterMode.quickFilter.
             */
            get: function () {
                return this._filterMode;
            },
            set: function (value) {
                this._filterMode = value;
                if (this.filteringService.isFilterRowVisible) {
                    this.filteringRow.close();
                }
                this.notifyChanges(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "summaryPosition", {
            /**
             * Gets/Sets the summary position.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" summaryPosition="top" [autoGenerate]="true"></igx-grid>
             * ```
             * @remarks
             * By default it is bottom.
             */
            get: function () {
                return this._summaryPosition;
            },
            set: function (value) {
                this._summaryPosition = value;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "summaryCalculationMode", {
            /**
             * Gets/Sets the summary calculation mode.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" summaryCalculationMode="rootLevelOnly" [autoGenerate]="true"></igx-grid>
             * ```
             * @remarks
             * By default it is rootAndChildLevels which means the summaries are calculated for the root level and each child level.
             */
            get: function () {
                return this._summaryCalculationMode;
            },
            set: function (value) {
                this._summaryCalculationMode = value;
                if (!this._init) {
                    this.endEdit(false);
                    this.summaryService.resetSummaryHeight();
                    this.notifyChanges(true);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "showSummaryOnCollapse", {
            /**
             * Controls whether the summary row is visible when groupBy/parent row is collapsed.
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [showSummaryOnCollapse]="true" [autoGenerate]="true"></igx-grid>
             * ```
             * @remarks
             * By default showSummaryOnCollapse is set to 'false' which means that the summary row is not visible
             * when the groupBy/parent row is collapsed.
             */
            get: function () {
                return this._showSummaryOnCollapse;
            },
            set: function (value) {
                this._showSummaryOnCollapse = value;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "filterStrategy", {
            /**
             * Gets/Sets the filtering strategy of the grid.
             *
             * @example
             * ```html
             *  <igx-grid #grid [data]="localData" [filterStrategy]="filterStrategy"></igx-grid>
             * ```
             */
            get: function () {
                return this._filteringStrategy;
            },
            set: function (classRef) {
                this._filteringStrategy = classRef;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "sortStrategy", {
            /**
             * Gets/Sets the sorting strategy of the grid.
             *
             * @example
             * ```html
             *  <igx-grid #grid [data]="localData" [sortStrategy]="sortStrategy"></igx-grid>
             * ```
             */
            get: function () {
                return this._sortingStrategy;
            },
            set: function (value) {
                this._sortingStrategy = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "selectedRows", {
            get: function () {
                return this.selectionService.getSelectedRows();
            },
            /**
             * Gets/Sets the current selection state.
             *
             * @remarks
             * Represents the selected rows' IDs (primary key or rowData)
             * @example
             * ```html
             * <igx-grid [data]="localData" primaryKey="ID" rowSelection="multiple" [selectedRows]="[0, 1, 2]"><igx-grid>
             * ```
             */
            set: function (rowIDs) {
                this.selectRows(rowIDs || [], true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "excelStyleFilteringComponent", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.excelStyleFilteringComponents.first;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "headerGroupsList", {
            /**
             * A list of all `IgxGridHeaderGroupComponent`.
             *
             * @example
             * ```typescript
             * const headerGroupsList = this.grid.headerGroupsList;
             * ```
             */
            get: function () {
                return this.headerGroups ? flatten(this.headerGroups.toArray()) : [];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "headerCellList", {
            /**
             * A list of all `IgxGridHeaderComponent`.
             *
             * @example
             * ```typescript
             * const headers = this.grid.headerCellList;
             * ```
             */
            get: function () {
                return this.headerGroupsList.map(function (headerGroup) { return headerGroup.headerCell; }).filter(function (headerCell) { return headerCell; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "filterCellList", {
            /**
             * A list of all `IgxGridFilteringCellComponent`.
             *
             * @example
             * ```typescript
             * const filterCells = this.grid.filterCellList;
             * ```
             */
            get: function () {
                return this.headerGroupsList.map(function (headerGroup) { return headerGroup.filterCell; }).filter(function (filterCell) { return filterCell; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "summariesRowList", {
            /**
             * @hidden @internal
             */
            get: function () {
                var res = new i0.QueryList();
                if (!this._summaryRowList) {
                    return res;
                }
                var sumList = this._summaryRowList.filter(function (item) { return item.element.nativeElement.parentElement !== null; });
                res.reset(sumList);
                return res;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowList", {
            /**
             * A list of `IgxGridRowComponent`.
             *
             * @example
             * ```typescript
             * const rowList = this.grid.rowList;
             * ```
             */
            get: function () {
                var res = new i0.QueryList();
                if (!this._rowList) {
                    return res;
                }
                var rList = this._rowList
                    .filter(function (item) { return item.element.nativeElement.parentElement !== null; })
                    .sort(function (a, b) { return a.index - b.index; });
                res.reset(rList);
                return res;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "dataRowList", {
            /**
             * A list of currently rendered `IgxGridRowComponent`'s.
             *
             * @example
             * ```typescript
             * const dataList = this.grid.dataRowList;
             * ```
             */
            get: function () {
                var res = new i0.QueryList();
                if (!this._dataRowList) {
                    return res;
                }
                var rList = this._dataRowList.filter(function (item) { return item.element.nativeElement.parentElement !== null; }).sort(function (a, b) { return a.index - b.index; });
                res.reset(rList);
                return res;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "headSelectorTemplate", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.headSelectorsTemplates && this.headSelectorsTemplates.first) {
                    return this.headSelectorsTemplates.first.templateRef;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isPinningToStart", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.pinning.columns !== exports.ColumnPinningPosition.End;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isRowPinningToTop", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.pinning.rows !== exports.RowPinningPosition.Bottom;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowSelectorTemplate", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.rowSelectorsTemplates && this.rowSelectorsTemplates.first) {
                    return this.rowSelectorsTemplates.first.templateRef;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowOutletDirective", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.rowEditingOutletDirective;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "parentRowOutletDirective", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.outlet;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowEditContainer", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.rowEditCustom ? this.rowEditCustom : this.defaultRowEditTemplate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "dragIndicatorIconTemplate", {
            /**
             * The custom template, if any, that should be used when rendering the row drag indicator icon
             */
            get: function () {
                return this._customDragIndicatorIconTemplate || this.dragIndicatorIconTemplates.first;
            },
            set: function (val) {
                this._customDragIndicatorIconTemplate = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowInEditMode", {
            /**
             * @hidden @internal
             */
            get: function () {
                var editRowState = this.crudService.row;
                return editRowState !== null ? this.rowList.find(function (e) { return e.rowID === editRowState.id; }) : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "firstEditableColumnIndex", {
            /**
             * @hidden @internal
             */
            get: function () {
                var index = this.visibleColumns.filter(function (col) { return col.editable; })
                    .map(function (c) { return c.visibleIndex; }).sort(function (a, b) { return a - b; });
                return index.length ? index[0] : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "lastEditableColumnIndex", {
            /**
             * @hidden @internal
             */
            get: function () {
                var index = this.visibleColumns.filter(function (col) { return col.editable; })
                    .map(function (c) { return c.visibleIndex; }).sort(function (a, b) { return a > b ? -1 : 1; });
                return index.length ? index[0] : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowEditTabs", {
            /**
             * @hidden @internal
             * TODO: Nav service logic doesn't handle 0 results from this querylist
             */
            get: function () {
                return this.rowEditTabsCUSTOM.length ? this.rowEditTabsCUSTOM : this.rowEditTabsDEFAULT;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "activeDescendant", {
            get: function () {
                var activeElem = this.navigation.activeNode;
                if (!activeElem || !Object.keys(activeElem).length) {
                    return this.id;
                }
                return activeElem.row < 0 ?
                    this.id + "_" + activeElem.row + "_" + activeElem.mchCache.level + "_" + activeElem.column :
                    this.id + "_" + activeElem.row + "_" + activeElem.column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hostClass", {
            /**
             * @hidden @internal
             */
            get: function () {
                var classes = [this.getComponentDensityClass('igx-grid')];
                // The custom classes should be at the end.
                classes.push(this.class);
                return classes.join(' ');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "bannerClass", {
            get: function () {
                var position = this.rowEditPositioningStrategy.isTop ? 'igx-banner__border-top' : 'igx-banner__border-bottom';
                return this.getComponentDensityClass('igx-banner') + " " + position;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "pipeTrigger", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._pipeTrigger;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "filteringPipeTrigger", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._filteringPipeTrigger;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "summaryPipeTrigger", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._summaryPipeTrigger;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "sortingExpressions", {
            /**
             * Gets/Sets the sorting state.
             *
             * @remarks
             * Supports two-way data binding.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(sortingExpressions)]="model.sortingExpressions"></igx-grid>
             * ```
             */
            get: function () {
                return this._sortingExpressions;
            },
            set: function (value) {
                this._sortingExpressions = cloneArray(value);
                this.sortingExpressionsChange.emit(this._sortingExpressions);
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "maxLevelHeaderDepth", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this._maxLevelHeaderDepth === null) {
                    this._maxLevelHeaderDepth = this.hasColumnLayouts ?
                        this.columnList.reduce(function (acc, col) { return Math.max(acc, col.rowStart); }, 0) :
                        this.columnList.reduce(function (acc, col) { return Math.max(acc, col.level); }, 0);
                }
                return this._maxLevelHeaderDepth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hiddenColumnsCount", {
            /**
             * Gets the number of hidden columns.
             *
             * @example
             * ```typescript
             * const hiddenCol = this.grid.hiddenColumnsCount;
             * ``
             */
            get: function () {
                return this.columnList.filter(function (col) { return col.columnGroup === false && col.hidden === true; }).length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "pinnedColumnsCount", {
            /**
             * Gets the number of pinned columns.
             */
            get: function () {
                return this.pinnedColumns.filter(function (col) { return !col.columnLayout; }).length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hiddenColumnsText", {
            /**
             * Gets/Sets the text to be displayed inside the toggle button.
             *
             * @deprecated
             *
             * @remarks
             * Used for the built-in column hiding UI of the`IgxColumnComponent`.
             * @example
             * ```html
             * <igx-grid [columnHiding]="true" [showToolbar]="true" [hiddenColumnsText]="'Hidden Columns'"></igx-grid>
             * ```
             */
            // @DeprecateProperty('`hiddenColumnsText` is deprecated')
            get: function () {
                return this._hiddenColumnsText;
            },
            set: function (value) {
                this._hiddenColumnsText = value;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "pinnedColumnsText", {
            /**
             * Gets/Sets the text to be displayed inside the toggle button.
             *
             * @deprecated
             *
             * @remarks
             * Used for the built-in column pinning UI of the`IgxColumnComponent`.
             * @example
             * ```html
             * <igx-grid [pinnedColumnsText]="'PinnedCols Text" [data]="data" [width]="'100%'" [height]="'500px'"></igx-grid>
             * ```
             */
            get: function () {
                return this._pinnedColumnsText;
            },
            set: function (value) {
                this._pinnedColumnsText = value;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "pinnedColumnsTextInternal", {
            /** @hidden @internal */
            get: function () {
                return this._pinnedColumnsText;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "transactions", {
            /**
             * Get transactions service for the grid.
             */
            get: function () {
                return this._transactions;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "currentRowState", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._currentRowState;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "currencyPositionLeft", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this._currencyPositionLeft !== undefined) {
                    return this._currencyPositionLeft;
                }
                var format = i2.getLocaleNumberFormat(this.locale, i2.NumberFormatStyle.Currency);
                var formatParts = format.split(',');
                var i = formatParts.indexOf(formatParts.find(function (c) { return c.includes('¤'); }));
                return this._currencyPositionLeft = i < 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "showToolbar", {
            /**
             * Gets/Sets whether the toolbar is shown.
             *
             * @deprecated
             *
             * @example
             * ```html
             * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" ></igx-grid>
             * ```
             */
            get: function () {
                return this._showToolbar;
            },
            set: function (newValue) {
                this._showToolbar = newValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "toolbarTitle", {
            /**
             * Gets/Sets the toolbar's title.
             *
             * @deprecated
             *
             * @example
             * ```html
             * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [toolbarTitle]="'My Grid'"></igx-grid>
             * ```
             */
            get: function () {
                return this._toolbarTitle;
            },
            set: function (newValue) {
                this._toolbarTitle = newValue;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "exportExcel", {
            /**
             * Gets/Sets whether exporting to MS Excel is enabled or disabled.
             *
             * @deprecated
             *
             * @example
             * ```html
             * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportExcel]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this.getExportExcel();
            },
            set: function (newValue) {
                this._exportExcel = newValue;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "exportCsv", {
            /**
             * Gets/Sets whether the option for exporting to CSV is enabled or disabled.
             *
             * @deprecated
             *
             * ```html
             * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportCsv]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this.getExportCsv();
            },
            set: function (newValue) {
                this._exportCsv = newValue;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "exportText", {
            /**
             * Gets/Sets the textual content for the main export button.
             *
             * @deprecated
             *
             * @example
             * ```html
             * <igx-grid [data]="localData" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._exportText;
            },
            set: function (newValue) {
                this._exportText = newValue;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "exportExcelText", {
            /**
             * Gets/Sets the textual content for the MS Excel export button.
             *
             * @deprecated
             *
             * ```html
             * <igx-grid [exportExcelText]="'My Excel Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._exportExcelText;
            },
            set: function (newValue) {
                this._exportExcelText = newValue;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "exportCsvText", {
            /**
             * Gets/Sets the textual content for the CSV export button.
             *
             * @deprecated
             *
             * @example
             * ```html
             * <igx-grid [exportCsvText]="'My Csv Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportExcel]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._exportCsvText;
            },
            set: function (newValue) {
                this._exportCsvText = newValue;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "cellSelection", {
            /**
             * Gets/Sets cell selection mode.
             *
             * @remarks
             * By default the cell selection mode is multiple
             * @param selectionMode: GridSelectionMode
             */
            get: function () {
                return this._cellSelectionMode;
            },
            set: function (selectionMode) {
                this._cellSelectionMode = selectionMode;
                if (this.gridAPI.grid) {
                    this.selectionService.clear(true);
                    this.notifyChanges();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowSelection", {
            /**
             * Gets/Sets row selection mode
             *
             * @remarks
             * By default the row selection mode is 'none'
             * Note that in IgxGrid and IgxHierarchicalGrid 'multipleCascade' behaves like 'multiple'
             */
            get: function () {
                return this._rowSelectionMode;
            },
            set: function (selectionMode) {
                this._rowSelectionMode = selectionMode;
                if (!this._init) {
                    this.selectionService.clearAllSelectedRows();
                    this.notifyChanges(true);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "columnSelection", {
            /**
             * Gets/Sets column selection mode
             *
             * @remarks
             * By default the row selection mode is none
             * @param selectionMode: GridSelectionMode
             */
            get: function () {
                return this._columnSelectionMode;
            },
            set: function (selectionMode) {
                this._columnSelectionMode = selectionMode;
                if (this.gridAPI.grid) {
                    this.selectionService.clearAllSelectedColumns();
                    this.notifyChanges(true);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "scrollSize", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.verticalScrollContainer.getScrollNativeSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "filteredSortedData", {
            /**
             * Returns an array containing the filtered sorted data.
             *
             * @example
             * ```typescript
             * const filteredSortedData = this.grid1.filteredSortedData;
             * ```
             */
            get: function () {
                return this._filteredSortedData;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowChangesCount", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (!this.crudService.row) {
                    return 0;
                }
                var f = function (obj) {
                    var changes = 0;
                    Object.keys(obj).forEach(function (key) { return isObject(obj[key]) ? changes += f(obj[key]) : changes++; });
                    return changes;
                };
                var rowChanges = this.transactions.getAggregatedValue(this.crudService.row.id, false);
                return rowChanges ? f(rowChanges) : 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "dataWithAddedInTransactionRows", {
            /**
             * @hidden @internal
             */
            get: function () {
                var result = cloneArray(this.gridAPI.get_all_data());
                if (this.transactions.enabled) {
                    result.push.apply(result, __spread(this.transactions.getAggregatedChanges(true)
                        .filter(function (t) { return t.type === exports.TransactionType.ADD; })
                        .map(function (t) { return t.newValue; })));
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "dataLength", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.transactions.enabled ? this.dataWithAddedInTransactionRows.length : this.gridAPI.get_all_data().length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "template", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this.isLoading && (this.hasZeroResultFilter || this.hasNoData)) {
                    return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
                }
                if (this.hasZeroResultFilter) {
                    return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
                }
                if (this.hasNoData) {
                    return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasZeroResultFilter", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.filteredData && this.filteredData.length === 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasNoData", {
            /**
             * @hidden @internal
             */
            get: function () {
                return !this.data || this.dataLength === 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "shouldOverlayLoading", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.isLoading && !this.hasNoData && !this.hasZeroResultFilter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isMultiRowSelectionEnabled", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.rowSelection === GridSelectionMode.multiple
                    || this.rowSelection === GridSelectionMode.multipleCascade;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isRowSelectable", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.rowSelection !== GridSelectionMode.none;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isCellSelectable", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.cellSelection !== GridSelectionMode.none;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.hideActionStrip = function () {
            var _a;
            (_a = this.actionStrip) === null || _a === void 0 ? void 0 : _a.hide();
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "headerFeaturesWidth", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this._headerFeaturesWidth;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.isDetailRecord = function (rec) {
            return false;
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.isGroupByRecord = function (rec) {
            return false;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.isGhostRecord = function (record) {
            return record.ghostRecord !== undefined;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.isAddRowRecord = function (record) {
            return record.addRow !== undefined;
        };
        /**
         * @hidden
         * Returns the row index of a row that takes into account the full view data like pinning.
         */
        IgxGridBaseDirective.prototype.getDataViewIndex = function (rowIndex, pinned) {
            if (pinned && !this.isRowPinningToTop) {
                rowIndex = rowIndex + this.unpinnedDataView.length;
            }
            else if (!pinned && this.isRowPinningToTop) {
                rowIndex = rowIndex + this.pinnedDataView.length;
            }
            return rowIndex;
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasDetails", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "virtualizationState", {
            /**
             * Returns the state of the grid virtualization.
             *
             * @remarks
             * Includes the start index and how many records are rendered.
             * @example
             * ```typescript
             * const gridVirtState = this.grid1.virtualizationState;
             * ```
             */
            get: function () {
                return this.verticalScrollContainer.state;
            },
            /**
             * @hidden
             */
            set: function (state) {
                this.verticalScrollContainer.state = state;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.hideOverlays = function () {
            var _this = this;
            this.overlayIDs.forEach(function (overlayID) {
                _this.overlayService.hide(overlayID);
                _this.overlayService.onClosed.pipe(operators.filter(function (o) { return o.id === overlayID; }), operators.takeUntil(_this.destroy$)).subscribe(function () {
                    _this.nativeElement.focus();
                });
            });
        };
        /**
         * Returns whether the record is pinned or not.
         *
         * @param rowIndex Index of the record in the `dataView` collection.
         *
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.isRecordPinnedByViewIndex = function (rowIndex) {
            return this.hasPinnedRecords && (this.isRowPinningToTop && rowIndex < this.pinnedDataView.length) ||
                (!this.isRowPinningToTop && rowIndex >= this.unpinnedDataView.length);
        };
        /**
         * Returns whether the record is pinned or not.
         *
         * @param rowIndex Index of the record in the `filteredSortedData` collection.
         */
        IgxGridBaseDirective.prototype.isRecordPinnedByIndex = function (rowIndex) {
            return this.hasPinnedRecords && (this.isRowPinningToTop && rowIndex < this._filteredSortedPinnedData.length) ||
                (!this.isRowPinningToTop && rowIndex >= this._filteredSortedUnpinnedData.length);
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.isRecordPinned = function (rec) {
            return this.getInitialPinnedIndex(rec) !== -1;
        };
        /**
         * @hidden
         * @internal
         * Returns the record index in order of pinning by the user. Does not consider sorting/filtering.
         */
        IgxGridBaseDirective.prototype.getInitialPinnedIndex = function (rec) {
            var id = this.gridAPI.get_row_id(rec);
            return this._pinnedRecordIDs.indexOf(id);
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasPinnedRecords", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this._pinnedRecordIDs.length > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "pinnedRecordsCount", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this._pinnedRecordIDs.length;
            },
            enumerable: false,
            configurable: true
        });
        IgxGridBaseDirective.prototype._setupServices = function () {
            this.gridAPI.grid = this;
            this.crudService.grid = this;
            this.selectionService.grid = this;
            this.navigation.grid = this;
            this.filteringService.grid = this;
            this.summaryService.grid = this;
        };
        IgxGridBaseDirective.prototype._setupListeners = function () {
            var _this = this;
            var destructor = operators.takeUntil(this.destroy$);
            rxjs.fromEvent(this.nativeElement, 'focusout').pipe(operators.filter(function () { return !!_this.navigation.activeNode; }), destructor).subscribe(function (event) {
                if (_this.selectionService.dragMode && isIE()) {
                    return;
                }
                if (!_this.crudService.cell &&
                    !!_this.navigation.activeNode &&
                    ((event.target === _this.tbody.nativeElement && _this.navigation.activeNode.row >= 0 &&
                        _this.navigation.activeNode.row < _this.dataView.length)
                        || (event.target === _this.theadRow.nativeElement && _this.navigation.activeNode.row === -1)
                        || (event.target === _this.tfoot.nativeElement.children[0] &&
                            _this.navigation.activeNode.row === _this.dataView.length)) &&
                    !(_this.rowEditable && _this.crudService.rowEditingBlocked && _this.crudService.rowInEditMode)) {
                    _this.navigation.lastActiveNode = _this.navigation.activeNode;
                    _this.navigation.activeNode = {};
                    _this.notifyChanges();
                }
            });
            this.onRowAdded.pipe(destructor).subscribe(function (args) { return _this.refreshGridState(args); });
            this.onRowDeleted.pipe(destructor).subscribe(function (args) {
                _this.summaryService.deleteOperation = true;
                _this.summaryService.clearSummaryCache(args);
            });
            this.transactions.onStateUpdate.pipe(destructor).subscribe(function (event) {
                var e_1, _h;
                var actions = [];
                if (event.origin === exports.TransactionEventOrigin.REDO) {
                    actions = event.actions ? event.actions.filter(function (x) { return x.transaction.type === exports.TransactionType.DELETE; }) : [];
                }
                else if (event.origin === exports.TransactionEventOrigin.UNDO) {
                    actions = event.actions ? event.actions.filter(function (x) { return x.transaction.type === exports.TransactionType.ADD; }) : [];
                }
                if (actions.length > 0) {
                    try {
                        for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                            var action = actions_1_1.value;
                            if (_this.selectionService.isRowSelected(action.transaction.id)) {
                                _this.selectionService.deselectRow(action.transaction.id);
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (actions_1_1 && !actions_1_1.done && (_h = actions_1.return)) _h.call(actions_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                _this.selectionService.clearHeaderCBState();
                _this.summaryService.clearSummaryCache();
                _this._pipeTrigger++;
                _this.notifyChanges();
            });
            this.resizeNotify.pipe(destructor, operators.filter(function () { return !_this._init; }), operators.throttleTime(100, undefined, { leading: true, trailing: true }))
                .subscribe(function () {
                _this.zone.run(function () {
                    _this.notifyChanges(true);
                });
            });
            this.onPagingDone.pipe(destructor).subscribe(function () {
                _this.endEdit(false);
                _this.selectionService.clear(true);
            });
            this.onColumnMovingEnd.pipe(destructor).subscribe(function () { return _this.endEdit(false); });
            this.overlayService.onOpening.pipe(destructor).subscribe(function (event) {
                if (_this._advancedFilteringOverlayId === event.id) {
                    var instance = event.componentRef.instance;
                    if (instance) {
                        instance.initialize(_this, _this.overlayService, event.id);
                    }
                }
            });
            this.overlayService.onOpened.pipe(destructor).subscribe(function (event) {
                var _a, _b;
                var overlaySettings = (_a = _this.overlayService.getOverlayById(event.id)) === null || _a === void 0 ? void 0 : _a.settings;
                // do not hide the advanced filtering overlay on scroll
                if (_this._advancedFilteringOverlayId === event.id) {
                    var instance = event.componentRef.instance;
                    if (instance) {
                        instance.lastActiveNode = _this.navigation.activeNode;
                        instance.setAddButtonFocus();
                    }
                    return;
                }
                // do not hide the overlay if it's attached to a row
                if (((_b = _this.rowEditingOverlay) === null || _b === void 0 ? void 0 : _b.overlayId) === event.id) {
                    return;
                }
                if ((overlaySettings === null || overlaySettings === void 0 ? void 0 : overlaySettings.outlet) === _this.outlet && _this.overlayIDs.indexOf(event.id) === -1) {
                    _this.overlayIDs.push(event.id);
                }
            });
            this.overlayService.onClosed.pipe(destructor, operators.filter(function () { return !_this._init; })).subscribe(function (event) {
                if (_this._advancedFilteringOverlayId === event.id) {
                    _this._advancedFilteringOverlayId = null;
                    return;
                }
                var ind = _this.overlayIDs.indexOf(event.id);
                if (ind !== -1) {
                    _this.overlayIDs.splice(ind, 1);
                }
            });
            this.verticalScrollContainer.onDataChanging.pipe(destructor, operators.filter(function () { return !_this._init; })).subscribe(function ($event) {
                var shouldRecalcSize = _this.isPercentHeight &&
                    (!_this.calcHeight || _this.calcHeight === _this.getDataBasedBodyHeight() ||
                        _this.calcHeight === _this.renderedRowHeight * _this._defaultTargetRecordNumber);
                if (shouldRecalcSize) {
                    _this.calculateGridHeight();
                    $event.containerSize = _this.calcHeight;
                }
                _this.evaluateLoadingState();
            });
            this.verticalScrollContainer.onScrollbarVisibilityChanged.pipe(destructor, operators.filter(function () { return !_this._init; })).subscribe(function () {
                // called to recalc all widths that may have changes as a result of
                // the vert. scrollbar showing/hiding
                _this.notifyChanges(true);
            });
            this.verticalScrollContainer.onContentSizeChange.pipe(destructor, operators.filter(function () { return !_this._init; })).subscribe(function ($event) {
                _this.calculateGridSizes(false);
            });
            this.onDensityChanged.pipe(destructor).subscribe(function () {
                _this.endEdit(false);
                _this.summaryService.summaryHeight = 0;
                _this.notifyChanges(true);
            });
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this._setupServices();
            this._setupListeners();
            this.rowListDiffer = this.differs.find([]).create(null);
            this.columnListDiffer = this.differs.find([]).create(null);
            this.calcWidth = this.width && this.width.indexOf('%') === -1 ? parseInt(this.width, 10) : 0;
            this.shouldGenerate = this.autoGenerate;
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.resetColumnsCaches = function () {
            this.columnList.forEach(function (column) { return column.resetCaches(); });
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.generateRowID = function () {
            var _this = this;
            var primaryColumn = this.columnList.find(function (col) { return col.field === _this.primaryKey; });
            var idType = this.data.length ? typeof (this.data[0][this.primaryKey]) : primaryColumn ? primaryColumn.dataType : 'string';
            return idType === 'string' ? uuid.v4() : FAKE_ROW_ID--;
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.resetForOfCache = function () {
            var firstVirtRow = this.dataRowList.first;
            if (firstVirtRow) {
                if (this._cdrRequests) {
                    firstVirtRow.virtDirRow.cdr.detectChanges();
                }
                firstVirtRow.virtDirRow.assumeMaster();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.setFilteredData = function (data, pinned) {
            if (this.hasPinnedRecords && pinned) {
                this._filteredPinnedData = data || [];
                var filteredUnpinned = this._filteredUnpinnedData || [];
                var filteredData = __spread(this._filteredPinnedData, filteredUnpinned);
                this.filteredData = filteredData.length > 0 ? filteredData : this._filteredUnpinnedData;
            }
            else if (this.hasPinnedRecords && !pinned) {
                this._filteredUnpinnedData = data;
            }
            else {
                this.filteredData = data;
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.resetColumnCollections = function () {
            this._visibleColumns.length = 0;
            this._pinnedVisible.length = 0;
            this._unpinnedVisible.length = 0;
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.resetCachedWidths = function () {
            this._unpinnedWidth = NaN;
            this._pinnedWidth = NaN;
            this._totalWidth = NaN;
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.resetCaches = function (recalcFeatureWidth) {
            if (recalcFeatureWidth === void 0) { recalcFeatureWidth = true; }
            if (recalcFeatureWidth) {
                this._headerFeaturesWidth = NaN;
            }
            this.resetForOfCache();
            this.resetColumnsCaches();
            this.resetColumnCollections();
            this.resetCachedWidths();
            this.hasVisibleColumns = undefined;
            this._columnGroups = this.columnList.some(function (col) { return col.columnGroup; });
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.setupColumns();
            this.toolbar.changes.pipe(operators.takeUntil(this.destroy$), operators.filter(function () { return !_this._init; })).subscribe(function () { return _this.notifyChanges(true); });
            if (this.actionStrip) {
                this.actionStrip.menuOverlaySettings.outlet = this.outlet;
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.setFilteredSortedData = function (data, pinned) {
            data = data || [];
            if (this.pinnedRecordsCount > 0 && pinned) {
                this._filteredSortedPinnedData = data;
                this.pinnedRecords = data;
                this._filteredSortedData = this.isRowPinningToTop ? __spread(this._filteredSortedPinnedData, this._filteredSortedUnpinnedData) : __spread(this._filteredSortedUnpinnedData, this._filteredSortedPinnedData);
                this.refreshSearch(true, false);
            }
            else if (this.pinnedRecordsCount > 0 && !pinned) {
                this._filteredSortedUnpinnedData = data;
            }
            else {
                this._filteredSortedData = data;
                this.refreshSearch(true, false);
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.resetHorizontalForOfs = function () {
            var _this = this;
            var elementFilter = function (item) { return _this.isDefined(item.nativeElement.parentElement); };
            this._horizontalForOfs = __spread(this._dataRowList.filter(elementFilter).map(function (item) { return item.virtDirRow; }), this._summaryRowList.filter(elementFilter).map(function (item) { return item.virtDirRow; }));
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype._setupRowObservers = function () {
            var _this = this;
            var elementFilter = function (item) { return _this.isDefined(item.nativeElement.parentElement); };
            var extractForOfs = rxjs.pipe(operators.map(function (collection) { return collection.filter(elementFilter).map(function (item) { return item.virtDirRow; }); }));
            var rowListObserver = extractForOfs(this._dataRowList.changes);
            var summaryRowObserver = extractForOfs(this._summaryRowList.changes);
            rowListObserver.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                _this.resetHorizontalForOfs();
            });
            summaryRowObserver.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                _this.resetHorizontalForOfs();
            });
            this.resetHorizontalForOfs();
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype._zoneBegoneListeners = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                _this.verticalScrollContainer.getScroll().addEventListener('scroll', _this.verticalScrollHandler.bind(_this));
                _this.headerContainer.getScroll().addEventListener('scroll', _this.horizontalScrollHandler.bind(_this));
                _this.observer = new ResizeObserver__default['default'](function () { return _this.resizeNotify.next(); });
                _this.observer.observe(_this.nativeElement);
            });
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            var _a;
            this.initPinning();
            this.calculateGridSizes();
            this._init = false;
            this.cdr.reattach();
            this._setupRowObservers();
            this._zoneBegoneListeners();
            this.paginatorSettings = { outlet: this.outlet };
            var vertScrDC = this.verticalScrollContainer.displayContainer;
            vertScrDC.addEventListener('scroll', this.preventContainerScroll.bind(this));
            this._pinnedRowList.changes
                .pipe(operators.takeUntil(this.destroy$))
                .subscribe(function (change) {
                _this.onPinnedRowsChanged(change);
            });
            (_a = this.addRowSnackbar) === null || _a === void 0 ? void 0 : _a.clicked.subscribe(function () {
                var rec = _this.filteredSortedData[_this.lastAddedRowIndex];
                _this.scrollTo(rec, 0);
                _this.addRowSnackbar.close();
            });
            // Keep the stream open for future subscribers
            this.rendered$.pipe(operators.takeUntil(this.destroy$)).subscribe(rxjs.noop);
            Promise.resolve().then(function () { return _this.rendered.next(true); });
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.notifyChanges = function (repaint) {
            if (repaint === void 0) { repaint = false; }
            this._cdrRequests = true;
            this._cdrRequestRepaint = repaint;
            this.cdr.markForCheck();
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.ngDoCheck = function () {
            _super.prototype.ngDoCheck.call(this);
            if (this._init) {
                return;
            }
            if (this._cdrRequestRepaint) {
                this.resetNotifyChanges();
                this.calculateGridSizes();
                this.refreshSearch(true);
                return;
            }
            if (this._cdrRequests) {
                this.resetNotifyChanges();
                this.cdr.detectChanges();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.getDragGhostCustomTemplate = function () {
            if (this.dragGhostCustomTemplates && this.dragGhostCustomTemplates.first) {
                return this.dragGhostCustomTemplates.first;
            }
            return null;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.ngOnDestroy = function () {
            var _this = this;
            this.tmpOutlets.forEach(function (tmplOutlet) {
                tmplOutlet.cleanCache();
            });
            this.destroy$.next(true);
            this.destroy$.complete();
            this._destroyed = true;
            if (this._advancedFilteringOverlayId) {
                this.overlayService.hide(this._advancedFilteringOverlayId);
            }
            this.zone.runOutsideAngular(function () {
                var _a, _b, _c, _d, _e;
                _this.observer.disconnect();
                (_b = (_a = _this.verticalScrollContainer) === null || _a === void 0 ? void 0 : _a.getScroll()) === null || _b === void 0 ? void 0 : _b.removeEventListener('scroll', _this.verticalScrollHandler);
                (_d = (_c = _this.headerContainer) === null || _c === void 0 ? void 0 : _c.getScroll()) === null || _d === void 0 ? void 0 : _d.removeEventListener('scroll', _this.horizontalScrollHandler);
                var vertScrDC = (_e = _this.verticalScrollContainer) === null || _e === void 0 ? void 0 : _e.displayContainer;
                vertScrDC === null || vertScrDC === void 0 ? void 0 : vertScrDC.removeEventListener('scroll', _this.preventContainerScroll);
            });
        };
        /**
         * Toggles the specified column's visibility.
         *
         * @example
         * ```typescript
         * this.grid1.toggleColumnVisibility({
         *       column: this.grid1.columns[0],
         *       newValue: true
         * });
         * ```
         */
        IgxGridBaseDirective.prototype.toggleColumnVisibility = function (args) {
            var col = args.column ? this.columnList.find(function (c) { return c === args.column; }) : undefined;
            if (!col) {
                return;
            }
            col.toggleVisibility(args.newValue);
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "expansionStates", {
            /**
             * Gets/Sets a list of key-value pairs [row ID, expansion state].
             *
             * @remarks
             * Includes only states that differ from the default one.
             * Supports two-way binding.
             * @example
             * ```html
             * <igx-grid #grid [data]="data" [(expansionStates)]="model.expansionStates">
             * </igx-grid>
             * ```
             */
            get: function () {
                return this._expansionStates;
            },
            set: function (value) {
                this._expansionStates = new Map(value);
                this.expansionStatesChange.emit(this._expansionStates);
                this.notifyChanges(true);
                if (this.gridAPI.grid) {
                    this.cdr.detectChanges();
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Expands all rows.
         *
         * @example
         * ```typescript
         * this.grid.expandAll();
         * ```
         */
        IgxGridBaseDirective.prototype.expandAll = function () {
            this._defaultExpandState = true;
            this.expansionStates = new Map();
        };
        /**
         * Collapses all rows.
         *
         * @example
         * ```typescript
         * this.grid.collapseAll();
         * ```
         */
        IgxGridBaseDirective.prototype.collapseAll = function () {
            this._defaultExpandState = false;
            this.expansionStates = new Map();
        };
        /**
         * Expands the row by its id.
         *
         * @remarks
         * ID is either the primaryKey value or the data record instance.
         * @example
         * ```typescript
         * this.grid.expandRow(rowID);
         * ```
         * @param rowID The row id - primaryKey value or the data record instance.
         */
        IgxGridBaseDirective.prototype.expandRow = function (rowID) {
            this.gridAPI.set_row_expansion_state(rowID, true);
        };
        /**
         * Collapses the row by its id.
         *
         * @remarks
         * ID is either the primaryKey value or the data record instance.
         * @example
         * ```typescript
         * this.grid.collapseRow(rowID);
         * ```
         * @param rowID The row id - primaryKey value or the data record instance.
         */
        IgxGridBaseDirective.prototype.collapseRow = function (rowID) {
            this.gridAPI.set_row_expansion_state(rowID, false);
        };
        /**
         * Toggles the row by its id.
         *
         * @remarks
         * ID is either the primaryKey value or the data record instance.
         * @example
         * ```typescript
         * this.grid.toggleRow(rowID);
         * ```
         * @param rowID The row id - primaryKey value or the data record instance.
         */
        IgxGridBaseDirective.prototype.toggleRow = function (rowID) {
            var rec = this.gridAPI.get_rec_by_id(rowID);
            var state = this.gridAPI.get_row_expansion_state(rec);
            this.gridAPI.set_row_expansion_state(rowID, !state);
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.getDefaultExpandState = function (rec) {
            return this._defaultExpandState;
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "nativeElement", {
            /**
             * Gets the native element.
             *
             * @example
             * ```typescript
             * const nativeEl = this.grid.nativeElement.
             * ```
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "outlet", {
            /**
             * Gets/Sets the outlet used to attach the grid's overlays to.
             *
             * @remark
             * If set, returns the outlet defined outside the grid. Otherwise returns the grid's internal outlet directive.
             */
            get: function () {
                return this.resolveOutlet();
            },
            set: function (val) {
                this._userOutletDirective = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "defaultRowHeight", {
            /**
             * Gets the default row height.
             *
             * @example
             * ```typescript
             * const rowHeigh = this.grid.defaultRowHeight;
             * ```
             */
            get: function () {
                switch (this.displayDensity) {
                    case DisplayDensity.cosy:
                        return 40;
                    case DisplayDensity.compact:
                        return 32;
                    default:
                        return 50;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "defaultSummaryHeight", {
            /**
             * @hidden @internal
             */
            get: function () {
                switch (this.displayDensity) {
                    case DisplayDensity.cosy:
                        return 30;
                    case DisplayDensity.compact:
                        return 24;
                    default:
                        return 36;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "defaultHeaderGroupMinWidth", {
            /**
             * Returns the `IgxGridHeaderGroupComponent`'s minimum allowed width.
             *
             * @remarks
             * Used internally for restricting header group component width.
             * The values below depend on the header cell default right/left padding values.
             */
            get: function () {
                switch (this.displayDensity) {
                    case DisplayDensity.cosy:
                        return 32;
                    case DisplayDensity.compact:
                        return 24;
                    default:
                        return 48;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.paginatorClassName = function () {
            switch (this.displayDensity) {
                case DisplayDensity.cosy:
                    return 'igx-paginator--cosy';
                case DisplayDensity.compact:
                    return 'igx-paginator--compact';
                default:
                    return 'igx-paginator';
            }
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "pinnedWidth", {
            /**
             * Gets the current width of the container for the pinned `IgxColumnComponent`s.
             *
             * @example
             * ```typescript
             * const pinnedWidth = this.grid.getPinnedWidth;
             * ```
             */
            get: function () {
                if (!isNaN(this._pinnedWidth)) {
                    return this._pinnedWidth;
                }
                this._pinnedWidth = this.getPinnedWidth();
                return this._pinnedWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "unpinnedWidth", {
            /**
             * Gets the current width of the container for the unpinned `IgxColumnComponent`s.
             *
             * @example
             * ```typescript
             * const unpinnedWidth = this.grid.getUnpinnedWidth;
             * ```
             */
            get: function () {
                if (!isNaN(this._unpinnedWidth)) {
                    return this._unpinnedWidth;
                }
                this._unpinnedWidth = this.getUnpinnedWidth();
                return this._unpinnedWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isHorizontalScrollHidden", {
            /**
             * @hidden @internal
             */
            get: function () {
                var diff = this.unpinnedWidth - this.totalWidth;
                return this.width === null || diff >= 0;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
         */
        IgxGridBaseDirective.prototype.featureColumnsWidth = function (expander) {
            var _a, _b, _c, _d, _e, _f, _g;
            if (Number.isNaN(this._headerFeaturesWidth)) {
                // TODO: platformUtil.isBrowser check
                var rowSelectArea = ((_b = (_a = this.headerSelectorContainer) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect) ?
                    this.headerSelectorContainer.nativeElement.getBoundingClientRect().width : 0;
                var rowDragArea = this.rowDraggable && ((_d = (_c = this.headerDragContainer) === null || _c === void 0 ? void 0 : _c.nativeElement) === null || _d === void 0 ? void 0 : _d.getBoundingClientRect) ?
                    this.headerDragContainer.nativeElement.getBoundingClientRect().width : 0;
                var groupableArea = ((_f = (_e = this.headerGroupContainer) === null || _e === void 0 ? void 0 : _e.nativeElement) === null || _f === void 0 ? void 0 : _f.getBoundingClientRect) ?
                    this.headerGroupContainer.nativeElement.getBoundingClientRect().width : 0;
                var expanderWidth = ((_g = expander === null || expander === void 0 ? void 0 : expander.nativeElement) === null || _g === void 0 ? void 0 : _g.getBoundingClientRect) ? expander.nativeElement.getBoundingClientRect().width : 0;
                this._headerFeaturesWidth = rowSelectArea + rowDragArea + groupableArea + expanderWidth;
            }
            return this._headerFeaturesWidth;
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "summariesMargin", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.featureColumnsWidth();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "columns", {
            /**
             * Gets an array of `IgxColumnComponent`s.
             *
             * @example
             * ```typescript
             * const colums = this.grid.columns.
             * ```
             */
            get: function () {
                return this._columns;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "pinnedColumns", {
            /**
             * Gets an array of the pinned `IgxColumnComponent`s.
             *
             * @example
             * ```typescript
             * const pinnedColumns = this.grid.pinnedColumns.
             * ```
             */
            get: function () {
                if (this._pinnedVisible.length) {
                    return this._pinnedVisible;
                }
                this._pinnedVisible = this._pinnedColumns.filter(function (col) { return !col.hidden; });
                return this._pinnedVisible;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "pinnedRows", {
            /**
             * Gets an array of the pinned `IgxRowComponent`s.
             *
             * @example
             * ```typescript
             * const pinnedRow = this.grid.pinnedRows;
             * ```
             */
            get: function () {
                return this._pinnedRowList.toArray().sort(function (a, b) { return a.index - b.index; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "unpinnedColumns", {
            /**
             * Gets an array of unpinned `IgxColumnComponent`s.
             *
             * @example
             * ```typescript
             * const unpinnedColumns = this.grid.unpinnedColumns.
             * ```
             */
            get: function () {
                if (this._unpinnedVisible.length) {
                    return this._unpinnedVisible;
                }
                this._unpinnedVisible = this._unpinnedColumns.filter(function (col) { return !col.hidden; });
                return this._unpinnedVisible;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Gets the `width` to be set on `IgxGridHeaderGroupComponent`.
         */
        IgxGridBaseDirective.prototype.getHeaderGroupWidth = function (column) {
            if (this.hasColumnLayouts) {
                return '';
            }
            var colWidth = parseFloat(column.calcWidth);
            var minWidth = this.defaultHeaderGroupMinWidth;
            if (colWidth < minWidth) {
                return minWidth + 'px';
            }
            return colWidth + 'px';
        };
        /**
         * Returns the `IgxColumnComponent` by field name.
         *
         * @example
         * ```typescript
         * const myCol = this.grid1.getColumnByName("ID");
         * ```
         * @param name
         */
        IgxGridBaseDirective.prototype.getColumnByName = function (name) {
            return this.columnList.find(function (col) { return col.field === name; });
        };
        IgxGridBaseDirective.prototype.getColumnByVisibleIndex = function (index) {
            return this.visibleColumns.find(function (col) { return !col.columnGroup && !col.columnLayout &&
                col.visibleIndex === index; });
        };
        /**
         * Returns the `IgxRowDirective` by index.
         *
         * @example
         * ```typescript
         * const myRow = this.grid1.getRowByIndex(1);
         * ```
         * @param index
         */
        IgxGridBaseDirective.prototype.getRowByIndex = function (index) {
            return this.gridAPI.get_row_by_index(index);
        };
        /**
         * Returns `IgxGridRowComponent` object by the specified primary key .
         *
         * @remarks
         * Requires that the `primaryKey` property is set.
         * @example
         * ```typescript
         * const myRow = this.grid1.getRowByKey("cell5");
         * ```
         * @param keyValue
         */
        IgxGridBaseDirective.prototype.getRowByKey = function (keyValue) {
            return this.gridAPI.get_row_by_key(keyValue);
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "visibleColumns", {
            /**
             * Returns an array of visible `IgxColumnComponent`s.
             *
             * @example
             * ```typescript
             * const visibleColumns = this.grid.visibleColumns.
             * ```
             */
            get: function () {
                if (this._visibleColumns.length) {
                    return this._visibleColumns;
                }
                this._visibleColumns = this.columnList.filter(function (c) { return !c.hidden; });
                return this._visibleColumns;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns the `IgxGridCellComponent` that matches the conditions.
         *
         * @example
         * ```typescript
         * const myCell = this.grid1.getCellByColumn(2,"UnitPrice");
         * ```
         * @param rowIndex
         * @param columnField
         */
        IgxGridBaseDirective.prototype.getCellByColumn = function (rowIndex, columnField) {
            var columnId = this.columnList.map(function (column) { return column.field; }).indexOf(columnField);
            if (columnId !== -1) {
                return this.gridAPI.get_cell_by_index(rowIndex, columnId);
            }
        };
        IgxGridBaseDirective.prototype.getCellByColumnVisibleIndex = function (rowIndex, index) {
            return this.gridAPI.get_cell_by_visible_index(rowIndex, index);
        };
        /**
         * Returns an `IgxGridCellComponent` object by the specified primary key and column field.
         *
         * @remarks
         * Requires that the primaryKey property is set.
         * @example
         * ```typescript
         * grid.getCellByKey(1, 'index');
         * ```
         * @param rowSelector match any rowID
         * @param columnField
         */
        IgxGridBaseDirective.prototype.getCellByKey = function (rowSelector, columnField) {
            return this.gridAPI.get_cell_by_key(rowSelector, columnField);
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "totalPages", {
            /**
             * Gets the total number of pages.
             *
             * @example
             * ```typescript
             * const totalPages = this.grid.totalPages;
             * ```
             */
            get: function () {
                if (this.pagingState) {
                    return this.pagingState.metadata.countPages;
                }
                return this._totalRecords >= 0 ? Math.ceil(this._totalRecords / this.perPage) : -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isFirstPage", {
            /**
             * Gets if the current page is the first page.
             *
             * @example
             * ```typescript
             * const firstPage = this.grid.isFirstPage;
             * ```
             */
            get: function () {
                return this.page === 0;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Goes to the next page, if the grid is not already at the last page.
         *
         * @example
         * ```typescript
         * this.grid1.nextPage();
         * ```
         */
        IgxGridBaseDirective.prototype.nextPage = function () {
            if (!this.isLastPage) {
                this.page += 1;
            }
        };
        /**
         * Goes to the previous page, if the grid is not already at the first page.
         *
         * @example
         * ```typescript
         * this.grid1.previousPage();
         * ```
         */
        IgxGridBaseDirective.prototype.previousPage = function () {
            if (!this.isFirstPage) {
                this.page -= 1;
            }
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "totalRecords", {
            /**
             * Returns the total number of records.
             *
             * @remarks
             * Only functions when paging is enabled.
             * @example
             * ```typescript
             * const totalRecords = this.grid.totalRecords;
             * ```
             */
            get: function () {
                var _a;
                return this._totalRecords >= 0 ? this._totalRecords : (_a = this.pagingState) === null || _a === void 0 ? void 0 : _a.metadata.countRecords;
            },
            set: function (total) {
                if (total >= 0) {
                    this._totalRecords = total;
                    this._pipeTrigger++;
                    this.notifyChanges();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isLastPage", {
            /**
             * Returns if the current page is the last page.
             *
             * @example
             * ```typescript
             * const lastPage = this.grid.isLastPage;
             * ```
             */
            get: function () {
                return this.page + 1 >= this.totalPages;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "totalWidth", {
            /**
             * Returns the total width of the `IgxGridComponent`.
             *
             * @example
             * ```typescript
             * const gridWidth = this.grid.totalWidth;
             * ```
             */
            get: function () {
                if (!isNaN(this._totalWidth)) {
                    return this._totalWidth;
                }
                // Take only top level columns
                var cols = this.visibleColumns.filter(function (col) { return col.level === 0 && !col.pinned; });
                var totalWidth = 0;
                var i = 0;
                for (i; i < cols.length; i++) {
                    totalWidth += parseInt(cols[i].calcWidth, 10) || 0;
                }
                this._totalWidth = totalWidth;
                return totalWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "showRowSelectors", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.isRowSelectable && this.hasVisibleColumns && !this.hideRowSelectors;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "showAddButton", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.rowEditable && this.dataView.length === 0 && this.columns.length > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "showDragIcons", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.rowDraggable && this.columns.length > this.hiddenColumnsCount;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Places a column before or after the specified target column.
         *
         * @example
         * ```typescript
         * grid.moveColumn(column, target);
         * ```
         */
        IgxGridBaseDirective.prototype.moveColumn = function (column, target, pos) {
            if (pos === void 0) { pos = DropPosition.AfterDropTarget; }
            if (column === target || (column.level !== target.level) ||
                (column.topLevelParent !== target.topLevelParent)) {
                return;
            }
            if (column.level) {
                this._moveChildColumns(column.parent, column, target, pos);
            }
            var columnPinStateChanged;
            // pinning and unpinning will work correctly even without passing index
            // but is easier to calclulate the index here, and later use it in the pinning event args
            if (target.pinned && !column.pinned) {
                var pinnedIndex = this._pinnedColumns.indexOf(target);
                var index = pos === DropPosition.AfterDropTarget ? pinnedIndex + 1 : pinnedIndex;
                columnPinStateChanged = column.pin(index);
            }
            if (!target.pinned && column.pinned) {
                var unpinnedIndex = this._unpinnedColumns.indexOf(target);
                var index = pos === DropPosition.AfterDropTarget ? unpinnedIndex + 1 : unpinnedIndex;
                columnPinStateChanged = column.unpin(index);
            }
            if (target.pinned && column.pinned && !columnPinStateChanged) {
                this._reorderColumns(column, target, pos, this._pinnedColumns);
            }
            if (!target.pinned && !column.pinned && !columnPinStateChanged) {
                this._reorderColumns(column, target, pos, this._unpinnedColumns);
            }
            this._moveColumns(column, target, pos);
            this._columnsReordered(column, target);
            this.onColumnMovingEnd.emit({ source: column, target: target });
        };
        /**
         * Goes to the desired page index.
         *
         * @example
         * ```typescript
         * this.grid1.paginate(1);
         * ```
         * @param val
         */
        IgxGridBaseDirective.prototype.paginate = function (val) {
            if (val < 0 || val > this.totalPages - 1) {
                return;
            }
            this.page = val;
        };
        /**
         * Manually marks the `IgxGridComponent` for change detection.
         *
         * @example
         * ```typescript
         * this.grid1.markForCheck();
         * ```
         */
        IgxGridBaseDirective.prototype.markForCheck = function () {
            this.cdr.detectChanges();
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.beginAddRowByIndex = function (rowID, index, asChild, event) {
            var _this = this;
            if (!this.rowEditable) {
                console.warn('The grid must use row edit mode to perform row adding! Please set rowEditable to true.');
                return;
            }
            this.endEdit(true, event);
            this.cancelAddMode = false;
            var isInPinnedArea = this.isRecordPinnedByViewIndex(index);
            var pinIndex = this.pinnedRecords.findIndex(function (x) { return x[_this.primaryKey] === rowID; });
            var unpinIndex = this.getUnpinnedIndexById(rowID);
            if (this.expansionStates.get(rowID)) {
                this.collapseRow(rowID);
            }
            this.addRowParent = {
                rowID: rowID,
                index: isInPinnedArea ? pinIndex : unpinIndex,
                asChild: asChild,
                isPinned: isInPinnedArea
            };
            this._pipeTrigger++;
            this.cdr.detectChanges();
            if (isInPinnedArea) {
                this.calculateGridHeight();
            }
            var newRowIndex = this.addRowParent.index + 1;
            // ensure adding row is in view.
            var shouldScroll = this.navigation.shouldPerformVerticalScroll(newRowIndex, -1);
            if (shouldScroll) {
                this.navigateTo(newRowIndex, -1);
            }
            var row = this.getRowByIndex(index + 1);
            row.animateAdd = true;
            row.onAnimationEnd.pipe(operators.first()).subscribe(function () {
                row.animateAdd = false;
                var cell = row.cells.find(function (c) { return c.editable; });
                if (cell) {
                    _this.gridAPI.submit_value(event);
                    _this.crudService.enterEditMode(cell, event);
                    cell.activate();
                }
            });
        };
        /**
         * Creates a new `IgxGridRowComponent` and adds the data record to the end of the data source.
         *
         * @example
         * ```typescript
         * this.grid1.addRow(record);
         * ```
         * @param data
         */
        IgxGridBaseDirective.prototype.addRow = function (data) {
            // commit pending states prior to adding a row
            this.endEdit(true);
            this.gridAPI.addRowToData(data);
            this.onRowAdded.emit({ data: data });
            this._pipeTrigger++;
            this.notifyChanges();
        };
        /**
         * Removes the `IgxGridRowComponent` and the corresponding data record by primary key.
         *
         * @remarks
         * Requires that the `primaryKey` property is set.
         * The method accept rowSelector as a parameter, which is the rowID.
         * @example
         * ```typescript
         * this.grid1.deleteRow(0);
         * ```
         * @param rowSelector
         */
        IgxGridBaseDirective.prototype.deleteRow = function (rowSelector) {
            if (this.primaryKey !== undefined && this.primaryKey !== null) {
                this.deleteRowById(rowSelector);
            }
        };
        /** @hidden */
        IgxGridBaseDirective.prototype.deleteRowById = function (rowId) {
            this.gridAPI.deleteRowById(rowId);
        };
        /**
         * Updates the `IgxGridRowComponent` and the corresponding data record by primary key.
         *
         * @remarks
         * Requires that the `primaryKey` property is set.
         * @example
         * ```typescript
         * this.gridWithPK.updateCell('Updated', 1, 'ProductName');
         * ```
         * @param value the new value which is to be set.
         * @param rowSelector corresponds to rowID.
         * @param column corresponds to column field.
         */
        IgxGridBaseDirective.prototype.updateCell = function (value, rowSelector, column) {
            if (this.isDefined(this.primaryKey)) {
                var col = this.columnList.toArray().find(function (c) { return c.field === column; });
                if (col) {
                    // Simplify
                    var rowData = this.gridAPI.getRowData(rowSelector);
                    var index = this.gridAPI.get_row_index_in_data(rowSelector);
                    // If row passed is invalid
                    if (index < 0) {
                        return;
                    }
                    var id = {
                        rowID: rowSelector,
                        columnID: col.index,
                        rowIndex: index
                    };
                    var cell = new IgxCell(id, index, col, rowData[col.field], rowData[col.field], rowData, this);
                    var args = this.gridAPI.update_cell(cell, value);
                    if (this.crudService.cell && this.crudService.sameCell(cell)) {
                        if (args.cancel) {
                            return;
                        }
                        this.crudService.exitCellEdit();
                    }
                    this.cdr.detectChanges();
                }
            }
        };
        /**
         * Updates the `IgxGridRowComponent`
         *
         * @remarks
         * The row is specified by
         * rowSelector parameter and the data source record with the passed value.
         * This method will apply requested update only if primary key is specified in the grid.
         * @example
         * ```typescript
         * grid.updateRow({
         *       ProductID: 1, ProductName: 'Spearmint', InStock: true, UnitsInStock: 1, OrderDate: new Date('2005-03-21')
         *   }, 1);
         * ```
         * @param value
         * @param rowSelector correspond to rowID
         */
        IgxGridBaseDirective.prototype.updateRow = function (value, rowSelector) {
            if (this.isDefined(this.primaryKey)) {
                var editableCell = this.crudService.cell;
                if (editableCell && editableCell.id.rowID === rowSelector) {
                    this.crudService.exitCellEdit();
                }
                var row = new IgxRow(rowSelector, -1, this.gridAPI.getRowData(rowSelector), this);
                this.gridAPI.update_row(row, value);
                // TODO: fix for #5934 and probably break for #5763
                // consider adding of third optional boolean parameter in updateRow.
                // If developer set this parameter to true we should call notifyChanges(true), and
                // vise-versa if developer set it to false we should call notifyChanges(false).
                // The parameter should default to false
                this.notifyChanges();
            }
        };
        /**
         * Returns the data that is contained in the row component.
         *
         * @remarks
         * If the primary key is not specified the row selector match the row data.
         * @example
         * ```typescript
         * const data = grid.getRowData(94741);
         * ```
         * @param rowSelector correspond to rowID
         */
        IgxGridBaseDirective.prototype.getRowData = function (rowSelector) {
            if (!this.primaryKey) {
                return rowSelector;
            }
            var data = this.gridAPI.get_all_data(this.transactions.enabled);
            var index = this.gridAPI.get_row_index_in_data(rowSelector);
            return index < 0 ? {} : data[index];
        };
        /**
         * Sort a single `IgxColumnComponent`.
         *
         * @remarks
         * Sort the `IgxGridComponent`'s `IgxColumnComponent` based on the provided array of sorting expressions.
         * @example
         * ```typescript
         * this.grid.sort({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
         * ```
         */
        IgxGridBaseDirective.prototype.sort = function (expression) {
            var e_2, _h;
            var _this = this;
            var sortingState = cloneArray(this.sortingExpressions);
            if (expression instanceof Array) {
                try {
                    for (var expression_1 = __values(expression), expression_1_1 = expression_1.next(); !expression_1_1.done; expression_1_1 = expression_1.next()) {
                        var each = expression_1_1.value;
                        if (each.dir === exports.SortingDirection.None) {
                            this.gridAPI.remove_grouping_expression(each.fieldName);
                        }
                        this.gridAPI.prepare_sorting_expression([sortingState], each);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (expression_1_1 && !expression_1_1.done && (_h = expression_1.return)) _h.call(expression_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            else {
                if (expression.dir === exports.SortingDirection.None) {
                    this.gridAPI.remove_grouping_expression(expression.fieldName);
                }
                this.gridAPI.prepare_sorting_expression([sortingState], expression);
            }
            var eventArgs = { owner: this, sortingExpressions: sortingState, cancel: false };
            this.sorting.emit(eventArgs);
            if (eventArgs.cancel) {
                return;
            }
            this.endEdit(false);
            if (expression instanceof Array) {
                this.gridAPI.sort_multiple(expression);
            }
            else {
                this.gridAPI.sort(expression);
            }
            requestAnimationFrame(function () { return _this.onSortingDone.emit(expression); });
        };
        /**
         * Filters a single `IgxColumnComponent`.
         *
         * @example
         * ```typescript
         * public filter(term) {
         *      this.grid.filter("ProductName", term, IgxStringFilteringOperand.instance().condition("contains"));
         * }
         * ```
         * @param name
         * @param value
         * @param conditionOrExpressionTree
         * @param ignoreCase
         */
        IgxGridBaseDirective.prototype.filter = function (name, value, conditionOrExpressionTree, ignoreCase) {
            this.filteringService.filter(name, value, conditionOrExpressionTree, ignoreCase);
        };
        /**
         * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
         *
         * @example
         * ```typescript
         * grid.filterGlobal('some', IgxStringFilteringOperand.instance().condition('contains'));
         * ```
         * @param value
         * @param condition
         * @param ignoreCase
         */
        IgxGridBaseDirective.prototype.filterGlobal = function (value, condition, ignoreCase) {
            this.filteringService.filterGlobal(value, condition, ignoreCase);
        };
        /**
         * Enables summaries for the specified column and applies your customSummary.
         *
         * @remarks
         * If you do not provide the customSummary, then the default summary for the column data type will be applied.
         * @example
         * ```typescript
         * grid.enableSummaries([{ fieldName: 'ProductName' }, { fieldName: 'ID' }]);
         * ```
         * Enable summaries for the listed columns.
         * @example
         * ```typescript
         * grid.enableSummaries('ProductName');
         * ```
         * @param rest
         */
        IgxGridBaseDirective.prototype.enableSummaries = function () {
            var rest = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                rest[_i] = arguments[_i];
            }
            if (rest.length === 1 && Array.isArray(rest[0])) {
                this._multipleSummaries(rest[0], true);
            }
            else {
                this._summaries(rest[0], true, rest[1]);
            }
        };
        /**
         * Disable summaries for the specified column.
         *
         * @example
         * ```typescript
         * grid.disableSummaries('ProductName');
         * ```
         * @remarks
         * Disable summaries for the listed columns.
         * @example
         * ```typescript
         * grid.disableSummaries([{ fieldName: 'ProductName' }]);
         * ```
         */
        IgxGridBaseDirective.prototype.disableSummaries = function () {
            var rest = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                rest[_i] = arguments[_i];
            }
            if (rest.length === 1 && Array.isArray(rest[0])) {
                this._disableMultipleSummaries(rest[0]);
            }
            else {
                this._summaries(rest[0], false);
            }
        };
        /**
         * If name is provided, clears the filtering state of the corresponding `IgxColumnComponent`.
         *
         * @remarks
         * Otherwise clears the filtering state of all `IgxColumnComponent`s.
         * @example
         * ```typescript
         * this.grid.clearFilter();
         * ```
         * @param name
         */
        IgxGridBaseDirective.prototype.clearFilter = function (name) {
            this.filteringService.clearFilter(name);
        };
        /**
         * If name is provided, clears the sorting state of the corresponding `IgxColumnComponent`.
         *
         * @remarks
         * otherwise clears the sorting state of all `IgxColumnComponent`.
         * @example
         * ```typescript
         * this.grid.clearSort();
         * ```
         * @param name
         */
        IgxGridBaseDirective.prototype.clearSort = function (name) {
            if (!name) {
                this.sortingExpressions = [];
                return;
            }
            if (!this.gridAPI.get_column_by_name(name)) {
                return;
            }
            this.gridAPI.clear_sort(name);
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.refreshGridState = function (args) {
            this.endEdit(true);
            this.selectionService.clearHeaderCBState();
            this.summaryService.clearSummaryCache();
            this.cdr.detectChanges();
        };
        // TODO: We have return values here. Move them to event args ??
        /**
         * Pins a column by field name.
         *
         * @remarks
         * Returns whether the operation is successful.
         * @example
         * ```typescript
         * this.grid.pinColumn("ID");
         * ```
         * @param columnName
         * @param index
         */
        IgxGridBaseDirective.prototype.pinColumn = function (columnName, index) {
            var col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
            return col.pin(index);
        };
        /**
         * Unpins a column by field name. Returns whether the operation is successful.
         *
         * @example
         * ```typescript
         * this.grid.pinColumn("ID");
         * ```
         * @param columnName
         * @param index
         */
        IgxGridBaseDirective.prototype.unpinColumn = function (columnName, index) {
            var col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
            return col.unpin(index);
        };
        /**
         * Pin the row by its id.
         *
         * @remarks
         * ID is either the primaryKey value or the data record instance.
         * @example
         * ```typescript
         * this.grid.pinRow(rowID);
         * ```
         * @param rowID The row id - primaryKey value or the data record instance.
         * @param index The index at which to insert the row in the pinned collection.
         */
        IgxGridBaseDirective.prototype.pinRow = function (rowID, index) {
            if (this._pinnedRecordIDs.indexOf(rowID) !== -1) {
                return false;
            }
            var row = this.gridAPI.get_row_by_key(rowID);
            var eventArgs = {
                insertAtIndex: index,
                isPinned: true,
                rowID: rowID,
                row: row
            };
            this.onRowPinning.emit(eventArgs);
            this.endEdit(false);
            var insertIndex = typeof eventArgs.insertAtIndex === 'number' ? eventArgs.insertAtIndex : this._pinnedRecordIDs.length;
            this._pinnedRecordIDs.splice(insertIndex, 0, rowID);
            this._pipeTrigger++;
            if (this.gridAPI.grid) {
                this.notifyChanges();
            }
        };
        /**
         * Unpin the row by its id.
         *
         * @remarks
         * ID is either the primaryKey value or the data record instance.
         * @example
         * ```typescript
         * this.grid.unpinRow(rowID);
         * ```
         * @param rowID The row id - primaryKey value or the data record instance.
         */
        IgxGridBaseDirective.prototype.unpinRow = function (rowID) {
            var index = this._pinnedRecordIDs.indexOf(rowID);
            if (index === -1) {
                return false;
            }
            var row = this.gridAPI.get_row_by_key(rowID);
            var eventArgs = {
                isPinned: false,
                rowID: rowID,
                row: row
            };
            this.onRowPinning.emit(eventArgs);
            this.endEdit(false);
            this._pinnedRecordIDs.splice(index, 1);
            this._pipeTrigger++;
            if (this.gridAPI.grid) {
                this.cdr.detectChanges();
            }
            return true;
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "pinnedRowHeight", {
            get: function () {
                var containerHeight = this.pinContainer ? this.pinContainer.nativeElement.offsetHeight : 0;
                return this.hasPinnedRecords ? containerHeight : 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "totalHeight", {
            get: function () {
                return this.calcHeight ? this.calcHeight + this.pinnedRowHeight : this.calcHeight;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Recalculates grid width/height dimensions.
         *
         * @remarks
         * Should be run when changing DOM elements dimentions manually that affect the grid's size.
         * @example
         * ```typescript
         * this.grid.reflow();
         * ```
         */
        IgxGridBaseDirective.prototype.reflow = function () {
            this.calculateGridSizes();
        };
        /**
         * Finds the next occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
         *
         * @remarks
         * Returns how many times the grid contains the string.
         * @example
         * ```typescript
         * this.grid.findNext("financial");
         * ```
         * @param text the string to search.
         * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
         * @param exactMatch optionally, if the text should match the entire value  (defaults to false).
         */
        IgxGridBaseDirective.prototype.findNext = function (text, caseSensitive, exactMatch) {
            return this.find(text, 1, caseSensitive, exactMatch);
        };
        /**
         * Finds the previous occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
         *
         * @remarks
         * Returns how many times the grid contains the string.
         * @example
         * ```typescript
         * this.grid.findPrev("financial");
         * ```
         * @param text the string to search.
         * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
         * @param exactMatch optionally, if the text should match the entire value (defaults to false).
         */
        IgxGridBaseDirective.prototype.findPrev = function (text, caseSensitive, exactMatch) {
            return this.find(text, -1, caseSensitive, exactMatch);
        };
        /**
         * Reapplies the existing search.
         *
         * @remarks
         * Returns how many times the grid contains the last search.
         * @example
         * ```typescript
         * this.grid.refreshSearch();
         * ```
         * @param updateActiveInfo
         */
        IgxGridBaseDirective.prototype.refreshSearch = function (updateActiveInfo, endEdit) {
            var _this = this;
            if (endEdit === void 0) { endEdit = true; }
            if (this.lastSearchInfo.searchText) {
                this.rebuildMatchCache();
                if (updateActiveInfo) {
                    var activeInfo_1 = IgxTextHighlightDirective.highlightGroupsMap.get(this.id);
                    this.lastSearchInfo.matchInfoCache.forEach(function (match, i) {
                        if (match.column === activeInfo_1.column &&
                            match.row === activeInfo_1.row &&
                            match.index === activeInfo_1.index &&
                            compareMaps(match.metadata, activeInfo_1.metadata)) {
                            _this.lastSearchInfo.activeMatchIndex = i;
                        }
                    });
                }
                return this.find(this.lastSearchInfo.searchText, 0, this.lastSearchInfo.caseSensitive, this.lastSearchInfo.exactMatch, false, endEdit);
            }
            else {
                return 0;
            }
        };
        /**
         * Removes all the highlights in the cell.
         *
         * @example
         * ```typescript
         * this.grid.clearSearch();
         * ```
         */
        IgxGridBaseDirective.prototype.clearSearch = function () {
            this.lastSearchInfo = {
                searchText: '',
                caseSensitive: false,
                exactMatch: false,
                activeMatchIndex: 0,
                matchInfoCache: []
            };
            this.rowList.forEach(function (row) {
                if (row.cells) {
                    row.cells.forEach(function (c) {
                        c.clearHighlight();
                    });
                }
            });
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasSortableColumns", {
            /**
             * Returns if the `IgxGridComponent` has sortable columns.
             *
             * @example
             * ```typescript
             * const sortableGrid = this.grid.hasSortableColumns;
             * ```
             */
            get: function () {
                return this.columnList.some(function (col) { return col.sortable; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasEditableColumns", {
            /**
             * Returns if the `IgxGridComponent` has editable columns.
             *
             * @example
             * ```typescript
             * const editableGrid = this.grid.hasEditableColumns;
             * ```
             */
            get: function () {
                return this.columnList.some(function (col) { return col.editable; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasFilterableColumns", {
            /**
             * Returns if the `IgxGridComponent` has filterable columns.
             *
             * @example
             * ```typescript
             * const filterableGrid = this.grid.hasFilterableColumns;
             * ```
             */
            get: function () {
                return this.columnList.some(function (col) { return col.filterable; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasSummarizedColumns", {
            /**
             * Returns if the `IgxGridComponent` has summarized columns.
             *
             * @example
             * ```typescript
             * const summarizedGrid = this.grid.hasSummarizedColumns;
             * ```
             */
            get: function () {
                return this.summaryService.hasSummarizedColumns;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rootSummariesEnabled", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.summaryCalculationMode !== GridSummaryCalculationMode.childLevelsOnly;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasVisibleColumns", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this._hasVisibleColumns === undefined) {
                    return this.columnList ? this.columnList.some(function (c) { return !c.hidden; }) : false;
                }
                return this._hasVisibleColumns;
            },
            set: function (value) {
                this._hasVisibleColumns = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasMovableColumns", {
            /**
             * Returns if the `IgxGridComponent` has moveable columns.
             *
             * @example
             * ```typescript
             * const movableGrid = this.grid.hasMovableColumns;
             * ```
             */
            get: function () {
                return this.columnList && this.columnList.some(function (col) { return col.movable; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasColumnGroups", {
            /**
             * Returns if the `IgxGridComponent` has column groups.
             *
             * @example
             * ```typescript
             * const groupGrid = this.grid.hasColumnGroups;
             * ```
             */
            get: function () {
                return this._columnGroups;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasColumnLayouts", {
            /**
             * Returns if the `IgxGridComponent` has column layouts for multi-row layout definition.
             *
             * @example
             * ```typescript
             * const layoutGrid = this.grid.hasColumnLayouts;
             * ```
             */
            get: function () {
                return !!this.columnList.some(function (col) { return col.columnLayout; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "selectedCells", {
            /**
             * Returns an array of the selected `IgxGridCellComponent`s.
             *
             * @example
             * ```typescript
             * const selectedCells = this.grid.selectedCells;
             * ```
             */
            get: function () {
                if (this.dataRowList) {
                    return this.dataRowList.map(function (row) { return row.cells.filter(function (cell) { return cell.selected; }); })
                        .reduce(function (a, b) { return a.concat(b); }, []);
                }
                return [];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "multiRowLayoutRowSize", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._multiRowLayoutRowSize;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowBasedHeight", {
            /**
             * @hidden
             */
            get: function () {
                return this.dataLength * this.rowHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isPercentWidth", {
            /**
             * @hidden
             */
            get: function () {
                return this.width && this.width.indexOf('%') !== -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isPercentHeight", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._height && this._height.indexOf('%') !== -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "defaultTargetBodyHeight", {
            /**
             * @hidden
             */
            get: function () {
                var allItems = this.dataLength;
                return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "renderedRowHeight", {
            /**
             * @hidden @internal
             * The rowHeight input is bound to min-height css prop of rows that adds a 1px border in all cases
             */
            get: function () {
                return this.rowHeight + 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "outerWidth", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.hasVerticalScroll() ? this.calcWidth + this.scrollSize : this.calcWidth;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         * Gets the visible content height that includes header + tbody + footer.
         */
        IgxGridBaseDirective.prototype.getVisibleContentHeight = function () {
            var height = this.theadRow.nativeElement.clientHeight + this.tbody.nativeElement.clientHeight;
            if (this.hasSummarizedColumns) {
                height += this.tfoot.nativeElement.clientHeight;
            }
            return height;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.getPossibleColumnWidth = function (baseWidth) {
            if (baseWidth === void 0) { baseWidth = null; }
            var computedWidth;
            if (baseWidth !== null) {
                computedWidth = baseWidth;
            }
            else {
                computedWidth = this.calcWidth ||
                    parseInt(this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width'), 10);
            }
            computedWidth -= this.featureColumnsWidth();
            var visibleChildColumns = this.visibleColumns.filter(function (c) { return !c.columnGroup; });
            // Column layouts related
            var visibleCols = [];
            var columnBlocks = this.visibleColumns.filter(function (c) { return c.columnGroup; });
            var colsPerBlock = columnBlocks.map(function (block) { return block.getInitialChildColumnSizes(block.children); });
            var combinedBlocksSize = colsPerBlock.reduce(function (acc, item) { return acc + item.length; }, 0);
            colsPerBlock.forEach(function (blockCols) { return visibleCols = visibleCols.concat(blockCols); });
            //
            var columnsWithSetWidths = this.hasColumnLayouts ?
                visibleCols.filter(function (c) { return c.widthSetByUser; }) :
                visibleChildColumns.filter(function (c) { return c.widthSetByUser; });
            var columnsToSize = this.hasColumnLayouts ?
                combinedBlocksSize - columnsWithSetWidths.length :
                visibleChildColumns.length - columnsWithSetWidths.length;
            var sumExistingWidths = columnsWithSetWidths
                .reduce(function (prev, curr) {
                var colWidth = curr.width;
                var widthValue = parseInt(colWidth, 10);
                var currWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1 ?
                    widthValue / 100 * computedWidth :
                    widthValue;
                return prev + currWidth;
            }, 0);
            // When all columns are hidden, return 0px width
            if (!sumExistingWidths && !columnsToSize) {
                return '0px';
            }
            var columnWidth = Math.floor(!Number.isFinite(sumExistingWidths) ?
                Math.max(computedWidth / columnsToSize, MINIMUM_COLUMN_WIDTH) :
                Math.max((computedWidth - sumExistingWidths) / columnsToSize, MINIMUM_COLUMN_WIDTH));
            return columnWidth + 'px';
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.hasVerticalScroll = function () {
            if (this._init) {
                return false;
            }
            var isScrollable = this.verticalScrollContainer ? this.verticalScrollContainer.isScrollable() : false;
            return !!(this.calcWidth && this.dataView && this.dataView.length > 0 && isScrollable);
        };
        /**
         * Gets calculated width of the pinned area.
         *
         * @example
         * ```typescript
         * const pinnedWidth = this.grid.getPinnedWidth();
         * ```
         * @param takeHidden If we should take into account the hidden columns in the pinned area.
         */
        IgxGridBaseDirective.prototype.getPinnedWidth = function (takeHidden) {
            var e_3, _h;
            if (takeHidden === void 0) { takeHidden = false; }
            var fc = takeHidden ? this._pinnedColumns : this.pinnedColumns;
            var sum = 0;
            try {
                for (var fc_1 = __values(fc), fc_1_1 = fc_1.next(); !fc_1_1.done; fc_1_1 = fc_1.next()) {
                    var col = fc_1_1.value;
                    if (col.level === 0) {
                        sum += parseInt(col.calcWidth, 10);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (fc_1_1 && !fc_1_1.done && (_h = fc_1.return)) _h.call(fc_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (this.isPinningToStart) {
                sum += this.featureColumnsWidth();
            }
            return sum;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.onlyTopLevel = function (arr) {
            return arr.filter(function (c) { return c.level === 0; });
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.isColumnGrouped = function (fieldName) {
            return false;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.onHeaderSelectorClick = function (event) {
            if (!this.isMultiRowSelectionEnabled) {
                return;
            }
            if (this.selectionService.areAllRowSelected()) {
                this.selectionService.clearRowSelection(event);
            }
            else {
                this.selectionService.selectAllRows(event);
            }
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "headSelectorBaseAriaLabel", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this._filteringExpressionsTree.filteringOperands.length > 0) {
                    return this.selectionService.areAllRowSelected() ? 'Deselect all filtered' : 'Select all filtered';
                }
                return this.selectionService.areAllRowSelected() ? 'Deselect all' : 'Select all';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "totalRowsCountAfterFilter", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.data) {
                    return this.selectionService.allData.length;
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "pinnedDataView", {
            /**
             * Returns the currently transformed paged/filtered/sorted/grouped pinned row data, displayed in the grid.
             *
             * @example
             * ```typescript
             *      const pinnedDataView = this.grid.pinnedDataView;
             * ```
             */
            get: function () {
                return this.pinnedRecords ? this.pinnedRecords : [];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "unpinnedDataView", {
            /**
             * Returns currently transformed paged/filtered/sorted/grouped unpinned row data, displayed in the grid.
             *
             * @example
             * ```typescript
             *      const pinnedDataView = this.grid.pinnedDataView;
             * ```
             */
            get: function () {
                return this.unpinnedRecords ? this.unpinnedRecords : this.verticalScrollContainer.igxForOf || [];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "dataView", {
            /**
             * Returns the currently transformed paged/filtered/sorted/grouped/pinned/unpinned row data, displayed in the grid.
             *
             * @example
             * ```typescript
             *      const dataView = this.grid.dataView;
             * ```
             */
            get: function () {
                return this.isRowPinningToTop ? __spread(this.pinnedDataView, this.unpinnedDataView) : __spread(this.unpinnedDataView, this.pinnedDataView);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "selectRowOnClick", {
            /**
             * Gets/Sets whether clicking over a row should select/deselect it
             *
             * @remarks
             * By default it is set to true
             * @param enabled: boolean
             */
            get: function () {
                return this._selectRowOnClick;
            },
            set: function (enabled) {
                this._selectRowOnClick = enabled;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Select specified rows by ID.
         *
         * @example
         * ```typescript
         * this.grid.selectRows([1,2,5], true);
         * ```
         * @param rowIDs
         * @param clearCurrentSelection if true clears the current selection
         */
        IgxGridBaseDirective.prototype.selectRows = function (rowIDs, clearCurrentSelection) {
            this.selectionService.selectRowsWithNoEvent(rowIDs, clearCurrentSelection);
            this.notifyChanges();
        };
        /**
         * Deselect specified rows by ID.
         *
         * @example
         * ```typescript
         * this.grid.deselectRows([1,2,5]);
         * ```
         * @param rowIDs
         */
        IgxGridBaseDirective.prototype.deselectRows = function (rowIDs) {
            this.selectionService.deselectRowsWithNoEvent(rowIDs);
            this.notifyChanges();
        };
        /**
         * Selects all rows
         *
         * @remarks
         * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
         * If you set the parameter onlyFilterData to false that will select all rows in the grid exept deleted rows.
         * @example
         * ```typescript
         * this.grid.selectAllRows();
         * this.grid.selectAllRows(false);
         * ```
         * @param onlyFilterData
         */
        IgxGridBaseDirective.prototype.selectAllRows = function (onlyFilterData) {
            var _this = this;
            if (onlyFilterData === void 0) { onlyFilterData = true; }
            var data = onlyFilterData && this.filteredData ? this.filteredData : this.gridAPI.get_all_data(true);
            var rowIDs = this.selectionService.getRowIDs(data).filter(function (rID) { return !_this.gridAPI.row_deleted_transaction(rID); });
            this.selectRows(rowIDs);
        };
        /**
         * Deselects all rows
         *
         * @remarks
         * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
         * If you set the parameter onlyFilterData to false that will deselect all rows in the grid exept deleted rows.
         * @example
         * ```typescript
         * this.grid.deselectAllRows();
         * ```
         * @param onlyFilterData
         */
        IgxGridBaseDirective.prototype.deselectAllRows = function (onlyFilterData) {
            if (onlyFilterData === void 0) { onlyFilterData = true; }
            if (onlyFilterData && this.filteredData && this.filteredData.length > 0) {
                this.deselectRows(this.selectionService.getRowIDs(this.filteredData));
            }
            else {
                this.selectionService.clearAllSelectedRows();
                this.notifyChanges();
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.clearCellSelection = function () {
            this.selectionService.clear(true);
            this.notifyChanges();
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.dragScroll = function (dir) {
            var scrollDelta = 48;
            var horizontal = this.headerContainer.getScroll();
            var vertical = this.verticalScrollContainer.getScroll();
            switch (dir) {
                case DragScrollDirection.LEFT:
                    horizontal.scrollLeft -= scrollDelta;
                    break;
                case DragScrollDirection.RIGHT:
                    horizontal.scrollLeft += scrollDelta;
                    break;
                case DragScrollDirection.TOP:
                    vertical.scrollTop -= scrollDelta;
                    break;
                case DragScrollDirection.BOTTOM:
                    vertical.scrollTop += scrollDelta;
                    break;
                case DragScrollDirection.BOTTOMLEFT:
                    horizontal.scrollLeft -= scrollDelta;
                    vertical.scrollTop += scrollDelta;
                    break;
                case DragScrollDirection.BOTTOMRIGHT:
                    horizontal.scrollLeft += scrollDelta;
                    vertical.scrollTop += scrollDelta;
                    break;
                case DragScrollDirection.TOPLEFT:
                    horizontal.scrollLeft -= scrollDelta;
                    vertical.scrollTop -= scrollDelta;
                    break;
                case DragScrollDirection.TOPRIGHT:
                    horizontal.scrollLeft += scrollDelta;
                    vertical.scrollTop -= scrollDelta;
                    break;
                default:
                    return;
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.isDefined = function (arg) {
            return arg !== undefined && arg !== null;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.selectRange = function (arg) {
            var _this = this;
            if (!this.isDefined(arg)) {
                this.clearCellSelection();
                return;
            }
            if (arg instanceof Array) {
                arg.forEach(function (range) { return _this.setSelection(range); });
            }
            else {
                this.setSelection(arg);
            }
            this.notifyChanges();
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.columnToVisibleIndex = function (field) {
            var visibleColumns = this.visibleColumns;
            if (typeof field === 'number') {
                return field;
            }
            return visibleColumns.find(function (column) { return column.field === field; }).visibleIndex;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.setSelection = function (range) {
            var startNode = { row: range.rowStart, column: this.columnToVisibleIndex(range.columnStart) };
            var endNode = { row: range.rowEnd, column: this.columnToVisibleIndex(range.columnEnd) };
            this.selectionService.pointerState.node = startNode;
            this.selectionService.selectRange(endNode, this.selectionService.pointerState);
            this.selectionService.addRangeMeta(endNode, this.selectionService.pointerState);
            this.selectionService.initPointerState();
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.getSelectedRanges = function () {
            return this.selectionService.ranges;
        };
        /**
         *
         * Returns an array of the current cell selection in the form of `[{ column.field: cell.value }, ...]`.
         *
         * @remarks
         * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
         * If `headers` is enabled, it will use the column header (if any) instead of the column field.
         */
        IgxGridBaseDirective.prototype.getSelectedData = function (formatters, headers) {
            if (formatters === void 0) { formatters = false; }
            if (headers === void 0) { headers = false; }
            var source = this.filteredSortedData;
            return this.extractDataFromSelection(source, formatters, headers);
        };
        /**
         * Get current selected columns.
         *
         * @example
         * Returns an array with selected columns
         * ```typescript
         * const selectedColumns = this.grid.selectedColumns();
         * ```
         */
        IgxGridBaseDirective.prototype.selectedColumns = function () {
            var _this = this;
            var fields = this.selectionService.getSelectedColumns();
            return fields.map(function (field) { return _this.getColumnByName(field); }).filter(function (field) { return field; });
        };
        /**
         * Select specified columns.
         *
         * @example
         * ```typescript
         * this.grid.selectColumns(['ID','Name'], true);
         * ```
         * @param columns
         * @param clearCurrentSelection if true clears the current selection
         */
        IgxGridBaseDirective.prototype.selectColumns = function (columns, clearCurrentSelection) {
            var fieldToSelect = [];
            if (columns.length === 0 || typeof columns[0] === 'string') {
                fieldToSelect = columns;
            }
            else {
                columns.forEach(function (col) {
                    if (col.columnGroup) {
                        var children = col.allChildren.filter(function (c) { return !c.columnGroup; }).map(function (c) { return c.field; });
                        fieldToSelect = __spread(fieldToSelect, children);
                    }
                    else {
                        fieldToSelect.push(col.field);
                    }
                });
            }
            this.selectionService.selectColumnsWithNoEvent(fieldToSelect, clearCurrentSelection);
            this.notifyChanges();
        };
        /**
         * Deselect specified columns by filed.
         *
         * @example
         * ```typescript
         * this.grid.deselectColumns(['ID','Name']);
         * ```
         * @param columns
         */
        IgxGridBaseDirective.prototype.deselectColumns = function (columns) {
            var fieldToDeselect = [];
            if (columns.length === 0 || typeof columns[0] === 'string') {
                fieldToDeselect = columns;
            }
            else {
                columns.forEach(function (col) {
                    if (col.columnGroup) {
                        var children = col.allChildren.filter(function (c) { return !c.columnGroup; }).map(function (c) { return c.field; });
                        fieldToDeselect = __spread(fieldToDeselect, children);
                    }
                    else {
                        fieldToDeselect.push(col.field);
                    }
                });
            }
            this.selectionService.deselectColumnsWithNoEvent(fieldToDeselect);
            this.notifyChanges();
        };
        /**
         * Deselects all columns
         *
         * @example
         * ```typescript
         * this.grid.deselectAllColumns();
         * ```
         */
        IgxGridBaseDirective.prototype.deselectAllColumns = function () {
            this.selectionService.clearAllSelectedColumns();
            this.notifyChanges();
        };
        /**
         * Selects all columns
         *
         * @example
         * ```typescript
         * this.grid.deselectAllColumns();
         * ```
         */
        IgxGridBaseDirective.prototype.selectAllColumns = function () {
            this.selectColumns(this.columnList.filter(function (c) { return !c.columnGroup; }));
        };
        /**
         *
         * Returns an array of the current columns selection in the form of `[{ column.field: cell.value }, ...]`.
         *
         * @remarks
         * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
         * If `headers` is enabled, it will use the column header (if any) instead of the column field.
         */
        IgxGridBaseDirective.prototype.getSelectedColumnsData = function (formatters, headers) {
            if (formatters === void 0) { formatters = false; }
            if (headers === void 0) { headers = false; }
            var source = this.filteredSortedData ? this.filteredSortedData : this.data;
            return this.extractDataFromColumnsSelection(source, formatters, headers);
        };
        IgxGridBaseDirective.prototype.combineSelectedCellAndColumnData = function (columnData, formatters, headers) {
            if (formatters === void 0) { formatters = false; }
            if (headers === void 0) { headers = false; }
            var source = this.filteredSortedData;
            return this.extractDataFromSelection(source, formatters, headers, columnData);
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.copyHandler = function (event) {
            var selectedColumns = this.gridAPI.grid.selectedColumns();
            var columnData = this.getSelectedColumnsData(this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);
            var selectedData = this.getSelectedData(this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);
            var data = [];
            var result;
            if (event.code === 'KeyC' && (event.ctrlKey || event.metaKey) && event.currentTarget.className === 'igx-grid__thead-wrapper') {
                if (selectedData.length) {
                    if (columnData.length === 0) {
                        result = this.prepareCopyData(event, selectedData);
                    }
                    else {
                        data = this.combineSelectedCellAndColumnData(columnData, this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);
                        result = this.prepareCopyData(event, data[0], data[1]);
                    }
                }
                else {
                    data = columnData;
                    result = this.prepareCopyData(event, data);
                }
                if (isIE()) {
                    window.clipboardData.setData('Text', result);
                    return;
                }
                navigator.clipboard.writeText(result).then().catch(function (e) { return console.error(e); });
            }
            else if (!this.clipboardOptions.enabled || this.crudService.cellInEditMode || (!isIE() && event.type === 'keydown')) {
                return;
            }
            else {
                if (selectedColumns.length) {
                    data = this.combineSelectedCellAndColumnData(columnData, this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);
                    result = this.prepareCopyData(event, data[0], data[1]);
                }
                else {
                    data = selectedData;
                    result = this.prepareCopyData(event, data);
                }
                if (isIE()) {
                    window.clipboardData.setData('Text', result);
                    return;
                }
                event.clipboardData.setData('text/plain', result);
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.prepareCopyData = function (event, data, keys) {
            var ev = { data: data, cancel: false };
            this.onGridCopy.emit(ev);
            if (ev.cancel) {
                return;
            }
            var transformer = new CharSeparatedValueData(ev.data, this.clipboardOptions.separator);
            var result = keys ? transformer.prepareData(keys) : transformer.prepareData();
            if (!this.clipboardOptions.copyHeaders) {
                result = result.substring(result.indexOf('\n') + 1);
            }
            event.preventDefault();
            /* Necessary for the hiearachical case but will probably have to
               change how getSelectedData is propagated in the hiearachical grid
            */
            event.stopPropagation();
            return result;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.showSnackbarFor = function (index) {
            this.addRowSnackbar.actionText = index === -1 ? '' : this.snackbarActionText;
            this.lastAddedRowIndex = index;
            this.addRowSnackbar.open();
        };
        /**
         * Navigates to a position in the grid based on provided `rowindex` and `visibleColumnIndex`.
         *
         * @remarks
         * Also can execute a custom logic over the target element,
         * through a callback function that accepts { targetType: GridKeydownTargetType, target: Object }
         * @example
         * ```typescript
         *  this.grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); });
         * ```
         */
        IgxGridBaseDirective.prototype.navigateTo = function (rowIndex, visibleColIndex, cb) {
            var _this = this;
            if (visibleColIndex === void 0) { visibleColIndex = -1; }
            if (cb === void 0) { cb = null; }
            var _a;
            var totalItems = (_a = this.totalItemCount) !== null && _a !== void 0 ? _a : this.dataView.length - 1;
            if (rowIndex < 0 || rowIndex > totalItems || (visibleColIndex !== -1
                && this.columnList.map(function (col) { return col.visibleIndex; }).indexOf(visibleColIndex) === -1)) {
                return;
            }
            if (this.dataView.slice(rowIndex, rowIndex + 1).find(function (rec) { return rec.expression || rec.childGridsData; })) {
                visibleColIndex = -1;
            }
            // If the target row is pinned no need to scroll as well.
            var shouldScrollVertically = this.navigation.shouldPerformVerticalScroll(rowIndex, visibleColIndex);
            var shouldScrollHorizontally = this.navigation.shouldPerformHorizontalScroll(visibleColIndex, rowIndex);
            if (shouldScrollVertically) {
                this.navigation.performVerticalScrollToCell(rowIndex, visibleColIndex, function () {
                    if (shouldScrollHorizontally) {
                        _this.navigation.performHorizontalScrollToCell(visibleColIndex, function () { return _this.executeCallback(rowIndex, visibleColIndex, cb); });
                    }
                    else {
                        _this.executeCallback(rowIndex, visibleColIndex, cb);
                    }
                });
            }
            else if (shouldScrollHorizontally) {
                this.navigation.performHorizontalScrollToCell(visibleColIndex, function () {
                    if (shouldScrollVertically) {
                        _this.navigation.performVerticalScrollToCell(rowIndex, visibleColIndex, function () { return _this.executeCallback(rowIndex, visibleColIndex, cb); });
                    }
                    else {
                        _this.executeCallback(rowIndex, visibleColIndex, cb);
                    }
                });
            }
            else {
                this.executeCallback(rowIndex, visibleColIndex, cb);
            }
        };
        /**
         * Returns `ICellPosition` which defines the next cell,
         * according to the current position, that match specific criteria.
         *
         * @remarks
         * You can pass callback function as a third parameter of `getPreviousCell` method.
         * The callback function accepts IgxColumnComponent as a param
         * @example
         * ```typescript
         *  const nextEditableCellPosition = this.grid.getNextCell(0, 3, (column) => column.editable);
         * ```
         */
        IgxGridBaseDirective.prototype.getNextCell = function (currRowIndex, curVisibleColIndex, callback) {
            if (callback === void 0) { callback = null; }
            var columns = this.columnList.filter(function (col) { return !col.columnGroup && col.visibleIndex >= 0; });
            if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            var colIndexes = callback ? columns.filter(function (col) { return callback(col); }).map(function (editCol) { return editCol.visibleIndex; }).sort(function (a, b) { return a - b; }) :
                columns.map(function (editCol) { return editCol.visibleIndex; }).sort(function (a, b) { return a - b; });
            var nextCellIndex = colIndexes.find(function (index) { return index > curVisibleColIndex; });
            if (this.dataView.slice(currRowIndex, currRowIndex + 1)
                .find(function (rec) { return !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData; }) && nextCellIndex !== undefined) {
                return { rowIndex: currRowIndex, visibleColumnIndex: nextCellIndex };
            }
            else {
                if (colIndexes.length === 0 || this.getNextDataRowIndex(currRowIndex) === currRowIndex) {
                    return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
                }
                else {
                    return { rowIndex: this.getNextDataRowIndex(currRowIndex), visibleColumnIndex: colIndexes[0] };
                }
            }
        };
        /**
         * Returns `ICellPosition` which defines the previous cell,
         * according to the current position, that match specific criteria.
         *
         * @remarks
         * You can pass callback function as a third parameter of `getPreviousCell` method.
         * The callback function accepts IgxColumnComponent as a param
         * @example
         * ```typescript
         *  const previousEditableCellPosition = this.grid.getPreviousCell(0, 3, (column) => column.editable);
         * ```
         */
        IgxGridBaseDirective.prototype.getPreviousCell = function (currRowIndex, curVisibleColIndex, callback) {
            if (callback === void 0) { callback = null; }
            var columns = this.columnList.filter(function (col) { return !col.columnGroup && col.visibleIndex >= 0; });
            if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            var colIndexes = callback ? columns.filter(function (col) { return callback(col); }).map(function (editCol) { return editCol.visibleIndex; }).sort(function (a, b) { return b - a; }) :
                columns.map(function (editCol) { return editCol.visibleIndex; }).sort(function (a, b) { return b - a; });
            var prevCellIndex = colIndexes.find(function (index) { return index < curVisibleColIndex; });
            if (this.dataView.slice(currRowIndex, currRowIndex + 1)
                .find(function (rec) { return !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData; }) && prevCellIndex !== undefined) {
                return { rowIndex: currRowIndex, visibleColumnIndex: prevCellIndex };
            }
            else {
                if (colIndexes.length === 0 || this.getNextDataRowIndex(currRowIndex, true) === currRowIndex) {
                    return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
                }
                else {
                    return { rowIndex: this.getNextDataRowIndex(currRowIndex, true), visibleColumnIndex: colIndexes[0] };
                }
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.trackColumnChanges = function (index, col) {
            return col.field + col._calcWidth;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.isExpandedGroup = function (_group) {
            return undefined;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.openRowOverlay = function (id) {
            this.configureRowEditingOverlay(id, this.rowList.length <= MIN_ROW_EDITING_COUNT_THRESHOLD);
            this.rowEditingOverlay.open(this.rowEditSettings);
            this.rowEditingOverlay.element.addEventListener('wheel', this.rowEditingWheelHandler.bind(this));
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.closeRowEditingOverlay = function () {
            this.rowEditingOverlay.element.removeEventListener('wheel', this.rowEditingWheelHandler);
            this.rowEditPositioningStrategy.isTopInitialPosition = null;
            this.rowEditingOverlay.close();
            this.rowEditingOverlay.element.parentElement.style.display = '';
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.toggleRowEditingOverlay = function (show) {
            var rowStyle = this.rowEditingOverlay.element.style;
            if (show) {
                rowStyle.display = 'block';
            }
            else {
                rowStyle.display = 'none';
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.repositionRowEditingOverlay = function (row) {
            if (row && !this.rowEditingOverlay.collapsed) {
                var rowStyle = this.rowEditingOverlay.element.parentElement.style;
                if (row) {
                    rowStyle.display = '';
                    this.configureRowEditingOverlay(row.rowID);
                    this.rowEditingOverlay.reposition();
                }
                else {
                    rowStyle.display = 'none';
                }
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.cachedViewLoaded = function (args) {
            var _this = this;
            if (this.hasHorizontalScroll()) {
                var tmplId_1 = args.context.templateID;
                var index_1 = args.context.index;
                args.view.detectChanges();
                this.zone.onStable.pipe(operators.first()).subscribe(function () {
                    var row = tmplId_1 === 'dataRow' ? _this.getRowByIndex(index_1) : null;
                    var summaryRow = tmplId_1 === 'summaryRow' ? _this.summariesRowList.find(function (sr) { return sr.dataRowIndex === index_1; }) : null;
                    if (row && row instanceof IgxRowDirective) {
                        _this._restoreVirtState(row);
                    }
                    else if (summaryRow) {
                        _this._restoreVirtState(summaryRow);
                    }
                });
            }
        };
        /**
         * Opens the advanced filtering dialog.
         */
        IgxGridBaseDirective.prototype.openAdvancedFilteringDialog = function () {
            if (!this._advancedFilteringOverlayId) {
                this._advancedFilteringOverlaySettings.target =
                    this.rootGrid ? this.rootGrid.nativeElement : this.nativeElement;
                this._advancedFilteringOverlaySettings.outlet = this.outlet;
                this._advancedFilteringOverlayId = this.overlayService.attach(IgxAdvancedFilteringDialogComponent, this._advancedFilteringOverlaySettings, {
                    injector: this.viewRef.injector,
                    componentFactoryResolver: this.resolver
                });
                this.overlayService.show(this._advancedFilteringOverlayId, this._advancedFilteringOverlaySettings);
            }
        };
        /**
         * Closes the advanced filtering dialog.
         *
         * @param applyChanges indicates whether the changes should be applied
         */
        IgxGridBaseDirective.prototype.closeAdvancedFilteringDialog = function (applyChanges) {
            if (this._advancedFilteringOverlayId) {
                var advancedFilteringOverlay = this.overlayService.getOverlayById(this._advancedFilteringOverlayId);
                var advancedFilteringDialog = advancedFilteringOverlay.componentRef.instance;
                if (applyChanges) {
                    advancedFilteringDialog.applyChanges();
                }
                advancedFilteringDialog.closeDialog();
            }
        };
        IgxGridBaseDirective.prototype.getEmptyRecordObjectFor = function (rec) {
            var row = Object.assign({}, rec);
            Object.keys(row).forEach(function (key) { return row[key] = undefined; });
            row[this.primaryKey] = this.generateRowID();
            return row;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.hasHorizontalScroll = function () {
            return this.totalWidth - this.unpinnedWidth > 0;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.isSummaryRow = function (rowData) {
            return rowData.summaries && (rowData.summaries instanceof Map);
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.endRowTransaction = function (commit, row, event) {
            row.newData = this.transactions.getAggregatedValue(row.id, true);
            var rowEditArgs = row.createEditEventArgs(true, event);
            if (!commit) {
                this.transactions.endPending(false);
            }
            else {
                rowEditArgs = this.gridAPI.update_row(row, row.newData, event);
                if (rowEditArgs === null || rowEditArgs === void 0 ? void 0 : rowEditArgs.cancel) {
                    return true;
                }
            }
            this.crudService.endRowEdit();
            var nonCancelableArgs = row.createDoneEditEventArgs(rowEditArgs.oldValue, event);
            this.rowEditExit.emit(nonCancelableArgs);
            this.closeRowEditingOverlay();
        };
        // TODO: Refactor
        /**
         * Finishes the row transactions on the current row.
         *
         * @remarks
         * If `commit === true`, passes them from the pending state to the data (or transaction service)
         * @example
         * ```html
         * <button igxButton (click)="grid.endEdit(true)">Commit Row</button>
         * ```
         * @param commit
         */
        IgxGridBaseDirective.prototype.endEdit = function (commit, event) {
            if (commit === void 0) { commit = true; }
            var row = this.crudService.row;
            var cell = this.crudService.cell;
            var canceled = false;
            // TODO: Merge the crudService with with BaseAPI service
            if (!row && !cell) {
                return;
            }
            if (row === null || row === void 0 ? void 0 : row.isAddRow) {
                canceled = this.endAdd(commit, event);
                return canceled;
            }
            if (commit) {
                canceled = this.gridAPI.submit_value(event);
                if (canceled) {
                    return true;
                }
            }
            else {
                this.crudService.exitCellEdit(event);
            }
            canceled = this.crudService.exitRowEdit(commit, event);
            this.crudService.rowEditingBlocked = canceled;
            if (canceled) {
                return true;
            }
            var activeCell = this.selectionService.activeElement;
            if (event && activeCell) {
                var rowIndex = activeCell.row;
                var visibleColIndex = activeCell.layout ? activeCell.layout.columnVisibleIndex : activeCell.column;
                this.navigateTo(rowIndex, visibleColIndex);
            }
            return false;
        };
        IgxGridBaseDirective.prototype.endAdd = function (commit, event) {
            var _this = this;
            if (commit === void 0) { commit = true; }
            var row = this.crudService.row;
            var cell = this.crudService.cell;
            var cachedRowData = Object.assign({}, row.data);
            var cancelable = false;
            if (!row && !cell) {
                return;
            }
            if (commit) {
                this.onRowAdded.pipe(operators.first()).subscribe(function (args) {
                    var rowData = args.data;
                    var pinnedIndex = _this.pinnedRecords.findIndex(function (x) { return x[_this.primaryKey] === rowData[_this.primaryKey]; });
                    // A check whether the row is in the current view
                    var viewIndex = pinnedIndex !== -1 ? pinnedIndex : _this.findRecordIndexInView(rowData);
                    var dataIndex = _this.filteredSortedData.findIndex(function (data) { return data[_this.primaryKey] === rowData[_this.primaryKey]; });
                    var isInView = viewIndex !== -1 && !_this.navigation.shouldPerformVerticalScroll(viewIndex, 0);
                    var showIndex = isInView ? -1 : dataIndex;
                    _this.showSnackbarFor(showIndex);
                });
                cancelable = this.gridAPI.submit_add_value(event);
                if (!cancelable) {
                    var args = row.createEditEventArgs(true, event);
                    this.rowEdit.emit(args);
                    if (args.cancel) {
                        return args.cancel;
                    }
                    var parentId = this._getParentRecordId();
                    this.gridAPI.addRowToData(row.data, parentId);
                    var doneArgs = row.createDoneEditEventArgs(cachedRowData, event);
                    this.rowEditDone.emit(doneArgs);
                    this.crudService.endRowEdit();
                    if (this.addRowParent.isPinned) {
                        this.pinRow(row.id);
                    }
                }
                this.addRowParent = null;
                this.cancelAddMode = cancelable;
            }
            else {
                this.crudService.exitCellEdit(event);
                this.cancelAddMode = true;
            }
            this.crudService.endRowEdit();
            this.closeRowEditingOverlay();
            this._pipeTrigger++;
            if (!this.cancelAddMode) {
                this.cdr.detectChanges();
                this.onRowAdded.emit({ data: row.data });
            }
            var nonCancelableArgs = row.createDoneEditEventArgs(cachedRowData, event);
            this.rowEditExit.emit(nonCancelableArgs);
            return this.cancelAddMode;
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.endRowEdit = function (commit, event) {
            if (commit === void 0) { commit = true; }
            var canceled = this.endEdit(commit, event);
            if (canceled) {
                return true;
            }
            var activeCell = this.navigation.activeNode;
            if (activeCell && activeCell.row !== -1) {
                this.tbody.nativeElement.focus();
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.triggerPipes = function () {
            this._pipeTrigger++;
            this.cdr.detectChanges();
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.endAddRow = function () {
            this.cancelAddMode = true;
            this.triggerPipes();
        };
        IgxGridBaseDirective.prototype.writeToData = function (rowIndex, value) {
            mergeObjects(this.gridAPI.get_all_data()[rowIndex], value);
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype._getParentRecordId = function () {
            return this.addRowParent.asChild ? this.addRowParent.rowID : undefined;
        };
        IgxGridBaseDirective.prototype.findRecordIndexInView = function (rec) {
            var _this = this;
            return this.dataView.findIndex(function (data) { return data[_this.primaryKey] === rec[_this.primaryKey]; });
        };
        IgxGridBaseDirective.prototype.getUnpinnedIndexById = function (id) {
            var _this = this;
            return this.unpinnedRecords.findIndex(function (x) { return x[_this.primaryKey] === id; });
        };
        IgxGridBaseDirective.prototype._restoreVirtState = function (row) {
            // check virtualization state of data record added from cache
            // in case state is no longer valid - update it.
            var rowForOf = row.virtDirRow;
            var gridScrLeft = rowForOf.getScroll().scrollLeft;
            var left = -parseInt(rowForOf.dc.instance._viewContainer.element.nativeElement.style.left, 10);
            var actualScrollLeft = left + rowForOf.getColumnScrollLeft(rowForOf.state.startIndex);
            if (gridScrLeft !== actualScrollLeft) {
                rowForOf.onHScroll(gridScrLeft);
                rowForOf.cdr.detectChanges();
            }
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getExportExcel = function () {
            return this._exportExcel;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getExportCsv = function () {
            return this._exportCsv;
        };
        IgxGridBaseDirective.prototype.changeRowEditingOverlayStateOnScroll = function (row) {
            if (!this.rowEditable || !this.rowEditingOverlay || this.rowEditingOverlay.collapsed) {
                return;
            }
            if (!row) {
                this.toggleRowEditingOverlay(false);
            }
            else {
                this.repositionRowEditingOverlay(row);
            }
        };
        /**
         * Should be called when data and/or isLoading input changes so that the overlay can be
         * hidden/shown based on the current value of shouldOverlayLoading
         */
        IgxGridBaseDirective.prototype.evaluateLoadingState = function () {
            if (this.shouldOverlayLoading) {
                // a new overlay should be shown
                var overlaySettings = {
                    outlet: this.loadingOutlet,
                    closeOnOutsideClick: false,
                    positionStrategy: new ContainerPositionStrategy()
                };
                this.loadingOverlay.open(overlaySettings);
            }
            else {
                this.loadingOverlay.close();
            }
        };
        /**
         * @hidden
         * Sets grid width i.e. this.calcWidth
         */
        IgxGridBaseDirective.prototype.calculateGridWidth = function () {
            var width;
            if (this.isPercentWidth) {
                /* width in %*/
                var computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width');
                width = computed.indexOf('%') === -1 ? parseInt(computed, 10) : null;
            }
            else {
                width = parseInt(this.width, 10);
            }
            if (!width && this.nativeElement) {
                width = this.nativeElement.offsetWidth;
            }
            if (this.width === null || !width) {
                width = this.getColumnWidthSum();
            }
            if (this.hasVerticalScroll() && this.width !== null) {
                width -= this.scrollSize;
            }
            if ((Number.isFinite(width) || width === null) && width !== this.calcWidth) {
                this.calcWidth = width;
            }
            this._derivePossibleWidth();
        };
        /**
         * @hidden
         * Sets columns defaultWidth property
         */
        IgxGridBaseDirective.prototype._derivePossibleWidth = function () {
            var _this = this;
            if (!this.columnWidthSetByUser) {
                this._columnWidth = this.width !== null ? this.getPossibleColumnWidth() : MINIMUM_COLUMN_WIDTH + 'px';
            }
            this.columnList.forEach(function (column) {
                if (_this.hasColumnLayouts && parseInt(_this._columnWidth, 10)) {
                    var columnWidthCombined = parseInt(_this._columnWidth, 10) * (column.colEnd ? column.colEnd - column.colStart : 1);
                    column.defaultWidth = columnWidthCombined + 'px';
                }
                else {
                    // D.K. March 29th, 2021 #9145 Consider min/max width when setting defaultWidth property
                    column.defaultWidth = _this.getExtremumBasedColWidth(column);
                    column.resetCaches();
                }
            });
            this.resetCachedWidths();
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.getExtremumBasedColWidth = function (column) {
            var width = this._columnWidth;
            if (width && typeof width !== 'string') {
                width = String(width);
            }
            var minWidth = width.indexOf('%') === -1 ? column.minWidthPx : column.minWidthPercent;
            var maxWidth = width.indexOf('%') === -1 ? column.maxWidthPx : column.maxWidthPercent;
            if (column.hidden) {
                return width;
            }
            if (minWidth > parseFloat(width)) {
                width = String(column.minWidth);
            }
            else if (maxWidth < parseFloat(width)) {
                width = String(column.maxWidth);
            }
            // if no px or % are defined in maxWidth/minWidth consider it px
            if (width.indexOf('%') === -1 && width.indexOf('px') === -1) {
                width += 'px';
            }
            return width;
        };
        IgxGridBaseDirective.prototype.resetNotifyChanges = function () {
            this._cdrRequestRepaint = false;
            this._cdrRequests = false;
        };
        IgxGridBaseDirective.prototype.resolveOutlet = function () {
            return this._userOutletDirective ? this._userOutletDirective : this._outletDirective;
        };
        /**
         * Reorder columns in the main columnList and _columns collections.
         *
         * @hidden
         */
        IgxGridBaseDirective.prototype._moveColumns = function (from, to, pos) {
            var list = this.columnList.toArray();
            this._reorderColumns(from, to, pos, list);
            var newList = this._resetColumnList(list);
            this.columnList.reset(newList);
            this.columnList.notifyOnChanges();
            this._columns = this.columnList.toArray();
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype._resetColumnList = function (list) {
            if (!list) {
                list = this.columnList.toArray();
            }
            var newList = [];
            list.filter(function (c) { return c.level === 0; }).forEach(function (p) {
                newList.push(p);
                if (p.columnGroup) {
                    newList = newList.concat(p.allChildren);
                }
            });
            return newList;
        };
        /**
         * Reorders columns inside the passed column collection.
         * When reordering column group collection, the collection is not flattened.
         * In all other cases, the columns collection is flattened, this is why adittional calculations on the dropIndex are done.
         *
         * @hidden
         */
        IgxGridBaseDirective.prototype._reorderColumns = function (from, to, position, columnCollection, inGroup) {
            if (inGroup === void 0) { inGroup = false; }
            var fromIndex = columnCollection.indexOf(from);
            var childColumnsCount = inGroup ? 1 : from.allChildren.length + 1;
            columnCollection.splice(fromIndex, childColumnsCount);
            var dropIndex = columnCollection.indexOf(to);
            if (position === DropPosition.AfterDropTarget) {
                dropIndex++;
                if (!inGroup && to.columnGroup) {
                    dropIndex += to.allChildren.length;
                }
            }
            columnCollection.splice(dropIndex, 0, from);
        };
        /**
         * Reorder column group collection.
         *
         * @hidden
         */
        IgxGridBaseDirective.prototype._moveChildColumns = function (parent, from, to, pos) {
            var buffer = parent.children.toArray();
            this._reorderColumns(from, to, pos, buffer, true);
            parent.children.reset(buffer);
        };
        IgxGridBaseDirective.prototype.setupColumns = function () {
            var _this = this;
            if (this.autoGenerate) {
                this.autogenerateColumns();
            }
            this.initColumns(this.columnList, function (col) { return _this.onColumnInit.emit(col); });
            this.columnListDiffer.diff(this.columnList);
            this.columnList.changes
                .pipe(operators.takeUntil(this.destroy$))
                .subscribe(function (change) {
                _this.onColumnsChanged(change);
            });
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.deleteRowFromData = function (rowID, index) {
            //  if there is a row (index !== 0) delete it
            //  if there is a row in ADD or UPDATE state change it's state to DELETE
            if (index !== -1) {
                if (this.transactions.enabled) {
                    var transaction = { id: rowID, type: exports.TransactionType.DELETE, newValue: null };
                    this.transactions.add(transaction, this.data[index]);
                }
                else {
                    this.data.splice(index, 1);
                }
            }
            else {
                var state = this.transactions.getState(rowID);
                this.transactions.add({ id: rowID, type: exports.TransactionType.DELETE, newValue: null }, state && state.recordRef);
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.getDataBasedBodyHeight = function () {
            return !this.data || (this.data.length < this._defaultTargetRecordNumber) ?
                0 : this.defaultTargetBodyHeight;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.onPinnedRowsChanged = function (change) {
            var diff = this.rowListDiffer.diff(change);
            if (diff) {
                this.notifyChanges(true);
            }
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.onColumnsChanged = function (change) {
            var _this = this;
            var diff = this.columnListDiffer.diff(change);
            if (this.autoGenerate && this.columnList.length === 0 && this._autoGeneratedCols.length > 0) {
                // In Ivy if there are nested conditional templates the content children are re-evaluated
                // hence autogenerated columns are cleared and need to be reset.
                this.columnList.reset(this._autoGeneratedCols);
                return;
            }
            if (diff) {
                var added_1 = false;
                var removed_1 = false;
                diff.forEachAddedItem(function (record) {
                    _this.onColumnInit.emit(record.item);
                    added_1 = true;
                    if (record.item.pinned) {
                        _this._pinnedColumns.push(record.item);
                    }
                    else {
                        _this._unpinnedColumns.push(record.item);
                    }
                });
                this.initColumns(this.columnList);
                diff.forEachRemovedItem(function (record) {
                    var isColumnGroup = record.item instanceof IgxColumnGroupComponent;
                    if (!isColumnGroup) {
                        // Clear Grouping
                        _this.gridAPI.clear_groupby(record.item.field);
                        // Clear Filtering
                        _this.filteringService.clear_filter(record.item.field);
                        // Close filter row
                        if (_this.filteringService.isFilterRowVisible
                            && _this.filteringService.filteredColumn
                            && _this.filteringService.filteredColumn.field === record.item.field) {
                            _this.filteringRow.close();
                        }
                        // Clear Sorting
                        _this.gridAPI.clear_sort(record.item.field);
                        // Remove column selection
                        _this.selectionService.deselectColumnsWithNoEvent([record.item.field]);
                    }
                    removed_1 = true;
                });
                this.resetCaches();
                if (added_1 || removed_1) {
                    this.summaryService.clearSummaryCache();
                    Promise.resolve().then(function () {
                        // `onColumnsChanged` can be executed midway a current detectChange cycle and markForCheck will be ignored then.
                        // This ensures that we will wait for the current cycle to end so we can trigger a new one and ngDoCheck to fire.
                        _this.notifyChanges(true);
                    });
                }
            }
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.calculateGridSizes = function (recalcFeatureWidth) {
            var _this = this;
            if (recalcFeatureWidth === void 0) { recalcFeatureWidth = true; }
            /*
                TODO: (R.K.) This layered lasagne should be refactored
                ASAP. The reason I have to reset the caches so many times is because
                after teach `detectChanges` call they are filled with invalid
                state. Of course all of this happens midway through the grid
                sizing process which of course, uses values from the caches, thus resulting
                in a broken layout.
            */
            this.resetCaches(recalcFeatureWidth);
            this.cdr.detectChanges();
            var hasScroll = this.hasVerticalScroll();
            this.calculateGridWidth();
            this.resetCaches(recalcFeatureWidth);
            this.cdr.detectChanges();
            this.calculateGridHeight();
            if (this.rowEditable) {
                this.repositionRowEditingOverlay(this.rowInEditMode);
            }
            if (this.filteringService.isFilterRowVisible) {
                this.filteringRow.resetChipsArea();
            }
            this.cdr.detectChanges();
            // in case scrollbar has appeared recalc to size correctly.
            if (hasScroll !== this.hasVerticalScroll()) {
                this.calculateGridWidth();
                this.cdr.detectChanges();
            }
            if (this.zone.isStable) {
                this.zone.run(function () {
                    _this._applyWidthHostBinding();
                    _this.cdr.detectChanges();
                });
            }
            else {
                this.zone.onStable.pipe(operators.first()).subscribe(function () {
                    _this.zone.run(function () {
                        _this._applyWidthHostBinding();
                    });
                });
            }
            this.resetCaches(recalcFeatureWidth);
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.calcGridHeadRow = function () {
            if (this.maxLevelHeaderDepth) {
                this._baseFontSize = parseFloat(getComputedStyle(this.document.documentElement).getPropertyValue('font-size'));
                var minSize = (this.maxLevelHeaderDepth + 1) * this.defaultRowHeight / this._baseFontSize;
                if (this._allowFiltering && this._filterMode === FilterMode.quickFilter) {
                    minSize += (FILTER_ROW_HEIGHT + 1) / this._baseFontSize;
                }
                this.theadRow.nativeElement.style.minHeight = minSize + "rem";
            }
        };
        /**
         * @hidden
         * Sets TBODY height i.e. this.calcHeight
         */
        IgxGridBaseDirective.prototype.calculateGridHeight = function () {
            this.calcGridHeadRow();
            this.summariesHeight = 0;
            if (this.hasSummarizedColumns && this.rootSummariesEnabled) {
                this.summariesHeight = this.summaryService.calcMaxSummaryHeight();
            }
            this.calcHeight = this._calculateGridBodyHeight();
            if (this.pinnedRowHeight && this.calcHeight) {
                this.calcHeight -= this.pinnedRowHeight;
            }
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getGroupAreaHeight = function () {
            return 0;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getComputedHeight = function (elem) {
            return elem.offsetHeight ? parseFloat(this.document.defaultView.getComputedStyle(elem).getPropertyValue('height')) : 0;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getFooterHeight = function () {
            return this.summariesHeight || this.getComputedHeight(this.tfoot.nativeElement);
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getTheadRowHeight = function () {
            var height = this.getComputedHeight(this.theadRow.nativeElement);
            return (!this.allowFiltering || (this.allowFiltering && this.filterMode !== FilterMode.quickFilter)) ?
                height - this.getFilterCellHeight() :
                height;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getToolbarHeight = function () {
            var toolbarHeight = 0;
            if (this.toolbar.first) {
                toolbarHeight = this.getComputedHeight(this.toolbar.first.nativeElement);
            }
            return toolbarHeight;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getPagingFooterHeight = function () {
            var pagingHeight = 0;
            if (this.footer) {
                var height = this.getComputedHeight(this.footer.nativeElement);
                pagingHeight = this.footer.nativeElement.firstElementChild ?
                    height : 0;
            }
            return pagingHeight;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getFilterCellHeight = function () {
            var headerGroupNativeEl = (this.headerGroupsList.length !== 0) ?
                this.headerGroupsList[0].element.nativeElement : null;
            var filterCellNativeEl = (headerGroupNativeEl) ?
                headerGroupNativeEl.querySelector('igx-grid-filtering-cell') : null;
            return (filterCellNativeEl) ? filterCellNativeEl.offsetHeight : 0;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype._calculateGridBodyHeight = function () {
            if (!this._height) {
                return null;
            }
            var actualTheadRow = this.getTheadRowHeight();
            var footerHeight = this.getFooterHeight();
            var toolbarHeight = this.getToolbarHeight();
            var pagingHeight = this.getPagingFooterHeight();
            var groupAreaHeight = this.getGroupAreaHeight();
            var scrHeight = this.getComputedHeight(this.scr.nativeElement);
            var renderedHeight = toolbarHeight + actualTheadRow +
                footerHeight + pagingHeight + groupAreaHeight +
                scrHeight;
            var gridHeight = 0;
            if (this.isPercentHeight) {
                var computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('height');
                var autoSize = this._shouldAutoSize(renderedHeight);
                if (autoSize || computed.indexOf('%') !== -1) {
                    var bodyHeight = this.getDataBasedBodyHeight();
                    return bodyHeight > 0 ? bodyHeight : null;
                }
                gridHeight = parseFloat(computed);
            }
            else {
                gridHeight = parseInt(this._height, 10);
            }
            var height = Math.abs(gridHeight - renderedHeight);
            if (Math.round(height) === 0 || isNaN(gridHeight)) {
                var bodyHeight = this.defaultTargetBodyHeight;
                return bodyHeight > 0 ? bodyHeight : null;
            }
            return height;
        };
        IgxGridBaseDirective.prototype.checkContainerSizeChange = function () {
            var origHeight = this.nativeElement.parentElement.offsetHeight;
            this.nativeElement.style.display = 'none';
            var height = this.nativeElement.parentElement.offsetHeight;
            this.nativeElement.style.display = '';
            return origHeight !== height;
        };
        IgxGridBaseDirective.prototype._shouldAutoSize = function (renderedHeight) {
            this.tbody.nativeElement.style.display = 'none';
            var res = !this.nativeElement.parentElement ||
                this.nativeElement.parentElement.clientHeight === 0 ||
                this.nativeElement.parentElement.clientHeight === renderedHeight;
            if (!isChromium()) {
                // If grid causes the parent container to extend (for example when container is flex)
                // we should always auto-size since the actual size of the container will continuously change as the grid renders elements.
                res = this.checkContainerSizeChange();
            }
            this.tbody.nativeElement.style.display = '';
            return res;
        };
        /**
         * @hidden
         * Gets calculated width of the unpinned area
         * @param takeHidden If we should take into account the hidden columns in the pinned area.
         */
        IgxGridBaseDirective.prototype.getUnpinnedWidth = function (takeHidden) {
            if (takeHidden === void 0) { takeHidden = false; }
            var width = this.isPercentWidth ?
                this.calcWidth :
                parseInt(this.width, 10) || parseInt(this.hostWidth, 10) || this.calcWidth;
            if (this.hasVerticalScroll() && !this.isPercentWidth) {
                width -= this.scrollSize;
            }
            if (!this.isPinningToStart) {
                width -= this.featureColumnsWidth();
            }
            return width - this.getPinnedWidth(takeHidden);
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype._summaries = function (fieldName, hasSummary, summaryOperand) {
            var column = this.gridAPI.get_column_by_name(fieldName);
            if (column) {
                column.hasSummary = hasSummary;
                if (summaryOperand) {
                    if (this.rootSummariesEnabled) {
                        this.summaryService.retriggerRootPipe++;
                    }
                    column.summaries = summaryOperand;
                }
            }
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype._multipleSummaries = function (expressions, hasSummary) {
            var _this = this;
            expressions.forEach(function (element) {
                _this._summaries(element.fieldName, hasSummary, element.customSummary);
            });
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype._disableMultipleSummaries = function (expressions) {
            var _this = this;
            expressions.forEach(function (column) {
                var columnName = column && column.fieldName ? column.fieldName : column;
                _this._summaries(columnName, false);
            });
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.resolveDataTypes = function (rec) {
            if (typeof rec === 'number') {
                return DataType.Number;
            }
            else if (typeof rec === 'boolean') {
                return DataType.Boolean;
            }
            else if (typeof rec === 'object' && rec instanceof Date) {
                return DataType.Date;
            }
            return DataType.String;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.autogenerateColumns = function () {
            var _this = this;
            var data = this.gridAPI.get_data();
            var factory = this.resolver.resolveComponentFactory(IgxColumnComponent);
            var fields = this.generateDataFields(data);
            var columns = [];
            fields.forEach(function (field) {
                var ref = factory.create(_this.viewRef.injector);
                ref.instance.field = field;
                ref.instance.dataType = _this.resolveDataTypes(data[0][field]);
                ref.changeDetectorRef.detectChanges();
                columns.push(ref.instance);
            });
            this._autoGeneratedCols = columns;
            this.columnList.reset(columns);
            if (data && data.length > 0) {
                this.shouldGenerate = false;
            }
        };
        IgxGridBaseDirective.prototype.generateDataFields = function (data) {
            return Object.keys(data && data.length !== 0 ? data[0] : []);
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.initColumns = function (collection, cb) {
            var _this = this;
            if (cb === void 0) { cb = null; }
            this._columnGroups = this.columnList.some(function (col) { return col.columnGroup; });
            if (this.hasColumnLayouts) {
                // Set overall row layout size
                this.columnList.forEach(function (col) {
                    if (col.columnLayout) {
                        var layoutSize = col.children ?
                            col.children.reduce(function (acc, val) { return Math.max(val.rowStart + val.gridRowSpan - 1, acc); }, 1) :
                            1;
                        _this._multiRowLayoutRowSize = Math.max(layoutSize, _this._multiRowLayoutRowSize);
                    }
                });
            }
            if (this.hasColumnLayouts && this.hasColumnGroups) {
                // invalid configuration - multi-row and column groups
                // remove column groups
                var columnLayoutColumns = this.columnList.filter(function (col) { return col.columnLayout || col.columnLayoutChild; });
                this.columnList.reset(columnLayoutColumns);
            }
            this._maxLevelHeaderDepth = null;
            this._columns = this.columnList.toArray();
            collection.forEach(function (column) {
                column.defaultWidth = _this.columnWidthSetByUser ? _this._columnWidth : column.defaultWidth ? column.defaultWidth : '';
                if (cb) {
                    cb(column);
                }
            });
            this.reinitPinStates();
            if (this.hasColumnLayouts) {
                collection.forEach(function (column) {
                    column.populateVisibleIndexes();
                });
            }
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.reinitPinStates = function () {
            var _this = this;
            this._pinnedColumns = this.columnList
                .filter(function (c) { return c.pinned; }).sort(function (a, b) { return _this._pinnedColumns.indexOf(a) - _this._pinnedColumns.indexOf(b); });
            this._unpinnedColumns = this.hasColumnGroups ? this.columnList.filter(function (c) { return !c.pinned; }) :
                this.columnList.filter(function (c) { return !c.pinned; })
                    .sort(function (a, b) { return a.index - b.index; });
        };
        IgxGridBaseDirective.prototype.extractDataFromSelection = function (source, formatters, headers, columnData) {
            var e_4, _h;
            if (formatters === void 0) { formatters = false; }
            if (headers === void 0) { headers = false; }
            var _a;
            var columnsArray;
            var record = {};
            var selectedData = [];
            var keys = [];
            var keysAndData = [];
            var activeEl = this.selectionService.activeElement;
            var totalItems = (_a = this.totalItemCount) !== null && _a !== void 0 ? _a : 0;
            var isRemote = totalItems && totalItems > this.dataView.length;
            var selectionMap = isRemote ? Array.from(this.selectionService.selection) :
                Array.from(this.selectionService.selection).filter(function (tuple) { return tuple[0] < source.length; });
            if (this.cellSelection === GridSelectionMode.single && activeEl) {
                selectionMap.push([activeEl.row, new Set().add(activeEl.column)]);
            }
            if (this.cellSelection === GridSelectionMode.none && activeEl) {
                selectionMap.push([activeEl.row, new Set().add(activeEl.column)]);
            }
            if (columnData) {
                selectedData = columnData;
            }
            var _loop_1 = function (row, set) {
                var e_5, _h, e_6, _j;
                row = this_1.paging ? row + (this_1.perPage * this_1.page) : row;
                row = isRemote ? row - this_1.virtualizationState.startIndex : row;
                if (!source[row] || source[row].detailsData !== undefined) {
                    return "continue";
                }
                var temp = Array.from(set);
                try {
                    for (var temp_1 = (e_5 = void 0, __values(temp)), temp_1_1 = temp_1.next(); !temp_1_1.done; temp_1_1 = temp_1.next()) {
                        var each = temp_1_1.value;
                        columnsArray = this_1.getSelectableColumnsAt(each);
                        columnsArray.forEach(function (col) {
                            if (col) {
                                var key = headers ? col.header || col.field : col.field;
                                var value = source[row].ghostRecord ?
                                    resolveNestedPath(source[row].recordRef, col.field) : resolveNestedPath(source[row], col.field);
                                record[key] = formatters && col.formatter ? col.formatter(value) : value;
                                if (columnData) {
                                    if (!record[key]) {
                                        record[key] = '';
                                    }
                                    record[key] = record[key].toString().concat('recordRow-' + row);
                                }
                            }
                        });
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (temp_1_1 && !temp_1_1.done && (_h = temp_1.return)) _h.call(temp_1);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                if (Object.keys(record).length) {
                    if (columnData) {
                        if (!keys.length) {
                            keys = Object.keys(columnData[0]);
                        }
                        try {
                            for (var _k = (e_6 = void 0, __values(Object.entries(record))), _l = _k.next(); !_l.done; _l = _k.next()) {
                                var _m = __read(_l.value, 2), key = _m[0], value = _m[1];
                                if (!keys.includes(key)) {
                                    keys.push(key);
                                }
                                var c = value;
                                var rowNumber = +c.split('recordRow-')[1];
                                c = c.split('recordRow-')[0];
                                record[key] = c;
                                var mergedObj = Object.assign(selectedData[rowNumber], record);
                                selectedData[rowNumber] = mergedObj;
                            }
                        }
                        catch (e_6_1) { e_6 = { error: e_6_1 }; }
                        finally {
                            try {
                                if (_l && !_l.done && (_j = _k.return)) _j.call(_k);
                            }
                            finally { if (e_6) throw e_6.error; }
                        }
                    }
                    else {
                        selectedData.push(record);
                    }
                }
                record = {};
            };
            var this_1 = this;
            try {
                // eslint-disable-next-line prefer-const
                for (var selectionMap_1 = __values(selectionMap), selectionMap_1_1 = selectionMap_1.next(); !selectionMap_1_1.done; selectionMap_1_1 = selectionMap_1.next()) {
                    var _j = __read(selectionMap_1_1.value, 2), row = _j[0], set = _j[1];
                    _loop_1(row, set);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (selectionMap_1_1 && !selectionMap_1_1.done && (_h = selectionMap_1.return)) _h.call(selectionMap_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
            if (keys.length) {
                keysAndData.push(selectedData);
                keysAndData.push(keys);
                return keysAndData;
            }
            else {
                return selectedData;
            }
        };
        IgxGridBaseDirective.prototype.getSelectableColumnsAt = function (index) {
            if (this.hasColumnLayouts) {
                var visibleLayoutColumns = this.visibleColumns
                    .filter(function (col) { return col.columnLayout; })
                    .sort(function (a, b) { return a.visibleIndex - b.visibleIndex; });
                var colLayout = visibleLayoutColumns[index];
                return colLayout ? colLayout.children.toArray() : [];
            }
            else {
                var visibleColumns = this.visibleColumns
                    .filter(function (col) { return !col.columnGroup; })
                    .sort(function (a, b) { return a.visibleIndex - b.visibleIndex; });
                return [visibleColumns[index]];
            }
        };
        IgxGridBaseDirective.prototype.extractDataFromColumnsSelection = function (source, formatters, headers) {
            var e_7, _h;
            if (formatters === void 0) { formatters = false; }
            if (headers === void 0) { headers = false; }
            var record = {};
            var selectedData = [];
            var selectedColumns = this.selectedColumns();
            if (selectedColumns.length === 0) {
                return [];
            }
            var _loop_2 = function (data) {
                selectedColumns.forEach(function (col) {
                    var key = headers ? col.header || col.field : col.field;
                    record[key] = formatters && col.formatter ? col.formatter(data[col.field])
                        : data[col.field];
                });
                if (Object.keys(record).length) {
                    selectedData.push(record);
                }
                record = {};
            };
            try {
                for (var source_1 = __values(source), source_1_1 = source_1.next(); !source_1_1.done; source_1_1 = source_1.next()) {
                    var data = source_1_1.value;
                    _loop_2(data);
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (source_1_1 && !source_1_1.done && (_h = source_1.return)) _h.call(source_1);
                }
                finally { if (e_7) throw e_7.error; }
            }
            return selectedData;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.initPinning = function () {
            var e_8, _h;
            var pinnedColumns = [];
            var unpinnedColumns = [];
            this.calculateGridWidth();
            this.resetCaches();
            // When a column is a group or is inside a group, pin all related.
            this._pinnedColumns.forEach(function (col) {
                if (col.parent) {
                    col.parent.pinned = true;
                }
                if (col.columnGroup) {
                    col.children.forEach(function (child) { return child.pinned = true; });
                }
            });
            try {
                // Make sure we don't exceed unpinned area min width and get pinned and unpinned col collections.
                // We take into account top level columns (top level groups and non groups).
                // If top level is unpinned the pinning handles all children to be unpinned as well.
                for (var _j = __values(this._columns), _k = _j.next(); !_k.done; _k = _j.next()) {
                    var column = _k.value;
                    if (column.pinned && !column.parent) {
                        pinnedColumns.push(column);
                    }
                    else if (column.pinned && column.parent) {
                        if (column.topLevelParent.pinned) {
                            pinnedColumns.push(column);
                        }
                        else {
                            column.pinned = false;
                            unpinnedColumns.push(column);
                        }
                    }
                    else {
                        unpinnedColumns.push(column);
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_k && !_k.done && (_h = _j.return)) _h.call(_j);
                }
                finally { if (e_8) throw e_8.error; }
            }
            // Assign the applicaple collections.
            this._pinnedColumns = pinnedColumns;
            this._unpinnedColumns = unpinnedColumns;
            this.notifyChanges();
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.scrollTo = function (row, column, inCollection) {
            var _this = this;
            if (inCollection === void 0) { inCollection = this._filteredSortedUnpinnedData; }
            var delayScrolling = false;
            if (this.paging && typeof (row) !== 'number') {
                var rowIndex = inCollection.indexOf(row);
                var page = Math.floor(rowIndex / this.perPage);
                if (this.page !== page) {
                    delayScrolling = true;
                    this.page = page;
                }
            }
            if (delayScrolling) {
                this.verticalScrollContainer.onDataChanged.pipe(operators.first()).subscribe(function () {
                    _this.scrollDirective(_this.verticalScrollContainer, typeof (row) === 'number' ? row : _this.unpinnedDataView.indexOf(row));
                });
            }
            else {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(row));
            }
            this.scrollToHorizontally(column);
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.scrollToHorizontally = function (column) {
            var columnIndex = typeof column === 'number' ? column : this.getColumnByName(column).visibleIndex;
            var scrollRow = this.rowList.find(function (r) { return r.virtDirRow; });
            var virtDir = scrollRow ? scrollRow.virtDirRow : null;
            if (this.isPinningToStart && this.pinnedColumns.length) {
                if (columnIndex >= this.pinnedColumns.length) {
                    columnIndex -= this.pinnedColumns.length;
                    this.scrollDirective(virtDir, columnIndex);
                }
            }
            else {
                this.scrollDirective(virtDir, columnIndex);
            }
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.scrollDirective = function (directive, goal) {
            if (!directive) {
                return;
            }
            directive.scrollTo(goal);
        };
        IgxGridBaseDirective.prototype.getColumnWidthSum = function () {
            var colSum = 0;
            var cols = this.hasColumnLayouts ?
                this.visibleColumns.filter(function (x) { return x.columnLayout; }) : this.visibleColumns.filter(function (x) { return !x.columnGroup; });
            cols.forEach(function (item) {
                colSum += parseInt((item.calcWidth || item.defaultWidth), 10) || MINIMUM_COLUMN_WIDTH;
            });
            if (!colSum) {
                return null;
            }
            this.cdr.detectChanges();
            colSum += this.featureColumnsWidth();
            return colSum;
        };
        /**
         * Notiy changes, reset cache and populateVisibleIndexes.
         *
         * @hidden
         */
        IgxGridBaseDirective.prototype._columnsReordered = function (column, target) {
            this.notifyChanges();
            if (this.hasColumnLayouts) {
                this.columns.filter(function (x) { return x.columnLayout; }).forEach(function (x) { return x.populateVisibleIndexes(); });
            }
            // after reordering is done reset cached column collections.
            this.resetColumnCollections();
            column.resetCaches();
        };
        IgxGridBaseDirective.prototype._applyWidthHostBinding = function () {
            var width = this._width;
            if (width === null) {
                var currentWidth = this.calcWidth;
                if (this.hasVerticalScroll()) {
                    currentWidth += this.scrollSize;
                }
                width = currentWidth + 'px';
                this.resetCaches();
            }
            this._hostWidth = width;
            this.cdr.markForCheck();
        };
        IgxGridBaseDirective.prototype.verticalScrollHandler = function (event) {
            var _this = this;
            var _a;
            this.verticalScrollContainer.onScroll(event);
            this.disableTransitions = true;
            this.zone.run(function () {
                _this.zone.onStable.pipe(operators.first()).subscribe(function () {
                    _this.verticalScrollContainer.onChunkLoad.emit(_this.verticalScrollContainer.state);
                    if (_this.rowEditable) {
                        _this.changeRowEditingOverlayStateOnScroll(_this.rowInEditMode);
                    }
                });
            });
            this.disableTransitions = false;
            this.hideOverlays();
            (_a = this.actionStrip) === null || _a === void 0 ? void 0 : _a.hide();
            var args = {
                direction: 'vertical',
                event: event,
                scrollPosition: this.verticalScrollContainer.scrollPosition
            };
            this.onScroll.emit(args);
        };
        IgxGridBaseDirective.prototype.horizontalScrollHandler = function (event) {
            var _this = this;
            var scrollLeft = event.target.scrollLeft;
            this.headerContainer.onHScroll(scrollLeft);
            this._horizontalForOfs.forEach(function (vfor) { return vfor.onHScroll(scrollLeft); });
            this.cdr.markForCheck();
            this.zone.run(function () {
                _this.zone.onStable.pipe(operators.first()).subscribe(function () {
                    _this.parentVirtDir.onChunkLoad.emit(_this.headerContainer.state);
                });
            });
            this.hideOverlays();
            var args = { direction: 'horizontal', event: event, scrollPosition: this.headerContainer.scrollPosition };
            this.onScroll.emit(args);
        };
        IgxGridBaseDirective.prototype.executeCallback = function (rowIndex, visibleColIndex, cb) {
            var _this = this;
            if (visibleColIndex === void 0) { visibleColIndex = -1; }
            if (cb === void 0) { cb = null; }
            if (!cb) {
                return;
            }
            var row = this.summariesRowList.filter(function (s) { return s.index !== 0; }).concat(this.rowList.toArray()).find(function (r) { return r.index === rowIndex; });
            if (!row) {
                if (this.totalItemCount) {
                    this.verticalScrollContainer.onDataChanged.pipe(operators.first()).subscribe(function () {
                        _this.cdr.detectChanges();
                        row = _this.summariesRowList.filter(function (s) { return s.index !== 0; }).concat(_this.rowList.toArray()).find(function (r) { return r.index === rowIndex; });
                        var cbArgs = _this.getNavigationArguments(row, visibleColIndex);
                        cb(cbArgs);
                    });
                }
                if (this.dataView[rowIndex].detailsData) {
                    this.navigation.setActiveNode({ row: rowIndex });
                    this.cdr.detectChanges();
                }
                return;
            }
            var args = this.getNavigationArguments(row, visibleColIndex);
            cb(args);
        };
        IgxGridBaseDirective.prototype.getNavigationArguments = function (row, visibleColIndex) {
            var targetType;
            var target;
            switch (row.nativeElement.tagName.toLowerCase()) {
                case 'igx-grid-groupby-row':
                    targetType = 'groupRow';
                    target = row;
                    break;
                case 'igx-grid-summary-row':
                    targetType = 'summaryCell';
                    target = visibleColIndex !== -1 ?
                        row.summaryCells.find(function (c) { return c.visibleColumnIndex === visibleColIndex; }) : row.summaryCells.first;
                    break;
                case 'igx-child-grid-row':
                    targetType = 'hierarchicalRow';
                    target = row;
                    break;
                default:
                    targetType = 'dataCell';
                    target = visibleColIndex !== -1 ? row.cells.find(function (c) { return c.visibleColumnIndex === visibleColIndex; }) : row.cells.first;
                    break;
            }
            return { targetType: targetType, target: target };
        };
        IgxGridBaseDirective.prototype.getNextDataRowIndex = function (currentRowIndex, previous) {
            var _this = this;
            if (previous === void 0) { previous = false; }
            if (currentRowIndex < 0 || (currentRowIndex === 0 && previous) || (currentRowIndex >= this.dataView.length - 1 && !previous)) {
                return currentRowIndex;
            }
            // find next/prev record that is editable.
            var nextRowIndex = previous ? this.findPrevEditableDataRowIndex(currentRowIndex) :
                this.dataView.findIndex(function (rec, index) { return index > currentRowIndex && _this.isEditableDataRecordAtIndex(index); });
            return nextRowIndex !== -1 ? nextRowIndex : currentRowIndex;
        };
        /**
         * Returns the previous editable row index or -1 if no such row is found.
         *
         * @param currentIndex The index of the current editable record.
         */
        IgxGridBaseDirective.prototype.findPrevEditableDataRowIndex = function (currentIndex) {
            var i = this.dataView.length;
            while (i--) {
                if (i < currentIndex && this.isEditableDataRecordAtIndex(i)) {
                    return i;
                }
            }
            return -1;
        };
        /**
         * Returns if the record at the specified data view index is a an editable data record.
         * If record is group rec, summary rec, child rec, ghost rec. etc. it is not editable.
         *
         * @param dataViewIndex The index of that record in the data view.
         */
        IgxGridBaseDirective.prototype.isEditableDataRecordAtIndex = function (dataViewIndex) {
            var rec = this.dataView[dataViewIndex];
            return !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData &&
                !this.isGhostRecordAtIndex(dataViewIndex);
        };
        /**
         * Returns if the record at the specified data view index is a ghost.
         * If record is pinned but is not in pinned area then it is a ghost record.
         *
         * @param dataViewIndex The index of that record in the data view.
         */
        IgxGridBaseDirective.prototype.isGhostRecordAtIndex = function (dataViewIndex) {
            var isPinned = this.isRecordPinned(this.dataView[dataViewIndex]);
            var isInPinnedArea = this.isRecordPinnedByViewIndex(dataViewIndex);
            return isPinned && !isInPinnedArea;
        };
        IgxGridBaseDirective.prototype.isValidPosition = function (rowIndex, colIndex) {
            var rows = this.summariesRowList.filter(function (s) { return s.index !== 0; }).concat(this.rowList.toArray()).length;
            var cols = this.columnList.filter(function (col) { return !col.columnGroup && col.visibleIndex >= 0 && !col.hidden; }).length;
            if (rows < 1 || cols < 1) {
                return false;
            }
            if (rowIndex > -1 && rowIndex < this.dataView.length &&
                colIndex > -1 && colIndex <= Math.max.apply(Math, __spread(this.visibleColumns.map(function (c) { return c.visibleIndex; })))) {
                return true;
            }
            return false;
        };
        IgxGridBaseDirective.prototype.find = function (text, increment, caseSensitive, exactMatch, scroll, endEdit) {
            if (endEdit === void 0) { endEdit = true; }
            if (!this.rowList) {
                return 0;
            }
            if (endEdit) {
                this.endEdit(false);
            }
            if (!text) {
                this.clearSearch();
                return 0;
            }
            var caseSensitiveResolved = caseSensitive ? true : false;
            var exactMatchResolved = exactMatch ? true : false;
            var rebuildCache = false;
            if (this.lastSearchInfo.searchText !== text ||
                this.lastSearchInfo.caseSensitive !== caseSensitiveResolved ||
                this.lastSearchInfo.exactMatch !== exactMatchResolved) {
                this.lastSearchInfo = {
                    searchText: text,
                    activeMatchIndex: 0,
                    caseSensitive: caseSensitiveResolved,
                    exactMatch: exactMatchResolved,
                    matchInfoCache: []
                };
                rebuildCache = true;
            }
            else {
                this.lastSearchInfo.activeMatchIndex += increment;
            }
            if (rebuildCache) {
                this.rowList.forEach(function (row) {
                    if (row.cells) {
                        row.cells.forEach(function (c) {
                            c.highlightText(text, caseSensitiveResolved, exactMatchResolved);
                        });
                    }
                });
                this.rebuildMatchCache();
            }
            if (this.lastSearchInfo.activeMatchIndex >= this.lastSearchInfo.matchInfoCache.length) {
                this.lastSearchInfo.activeMatchIndex = 0;
            }
            else if (this.lastSearchInfo.activeMatchIndex < 0) {
                this.lastSearchInfo.activeMatchIndex = this.lastSearchInfo.matchInfoCache.length - 1;
            }
            if (this.lastSearchInfo.matchInfoCache.length) {
                var matchInfo = this.lastSearchInfo.matchInfoCache[this.lastSearchInfo.activeMatchIndex];
                this.lastSearchInfo = Object.assign({}, this.lastSearchInfo);
                if (scroll !== false) {
                    this.scrollTo(matchInfo.row, matchInfo.column);
                }
                IgxTextHighlightDirective.setActiveHighlight(this.id, {
                    column: matchInfo.column,
                    row: matchInfo.row,
                    index: matchInfo.index,
                    metadata: matchInfo.metadata,
                });
            }
            else {
                IgxTextHighlightDirective.clearActiveHighlight(this.id);
            }
            return this.lastSearchInfo.matchInfoCache.length;
        };
        IgxGridBaseDirective.prototype.rebuildMatchCache = function () {
            var _this = this;
            this.lastSearchInfo.matchInfoCache = [];
            var caseSensitive = this.lastSearchInfo.caseSensitive;
            var exactMatch = this.lastSearchInfo.exactMatch;
            var searchText = caseSensitive ? this.lastSearchInfo.searchText : this.lastSearchInfo.searchText.toLowerCase();
            var data = this.filteredSortedData;
            var columnItems = this.visibleColumns.filter(function (c) { return !c.columnGroup; }).sort(function (c1, c2) { return c1.visibleIndex - c2.visibleIndex; });
            data.forEach(function (dataRow, rowIndex) {
                columnItems.forEach(function (c) {
                    var pipeArgs = _this.getColumnByName(c.field).pipeArgs;
                    var value = c.formatter ? c.formatter(resolveNestedPath(dataRow, c.field)) :
                        c.dataType === 'number' ? _this.decimalPipe.transform(resolveNestedPath(dataRow, c.field), pipeArgs.digitsInfo, _this.locale) :
                            c.dataType === 'date' ? _this.datePipe.transform(resolveNestedPath(dataRow, c.field), pipeArgs.format, pipeArgs.timezone, _this.locale)
                                : resolveNestedPath(dataRow, c.field);
                    if (value !== undefined && value !== null && c.searchable) {
                        var searchValue = caseSensitive ? String(value) : String(value).toLowerCase();
                        if (exactMatch) {
                            if (searchValue === searchText) {
                                var metadata = new Map();
                                metadata.set('pinned', _this.isRecordPinnedByIndex(rowIndex));
                                _this.lastSearchInfo.matchInfoCache.push({
                                    row: dataRow,
                                    column: c.field,
                                    index: 0,
                                    metadata: metadata,
                                });
                            }
                        }
                        else {
                            var occurenceIndex = 0;
                            var searchIndex = searchValue.indexOf(searchText);
                            while (searchIndex !== -1) {
                                var metadata = new Map();
                                metadata.set('pinned', _this.isRecordPinnedByIndex(rowIndex));
                                _this.lastSearchInfo.matchInfoCache.push({
                                    row: dataRow,
                                    column: c.field,
                                    index: occurenceIndex++,
                                    metadata: metadata,
                                });
                                searchValue = searchValue.substring(searchIndex + searchText.length);
                                searchIndex = searchValue.indexOf(searchText);
                            }
                        }
                    }
                });
            });
        };
        IgxGridBaseDirective.prototype.configureRowEditingOverlay = function (rowID, useOuter) {
            if (useOuter === void 0) { useOuter = false; }
            var settings = this.rowEditSettings;
            var overlay = this.overlayService.getOverlayById(this.rowEditingOverlay.overlayId);
            if (overlay) {
                settings = overlay.settings;
            }
            settings.outlet = useOuter ? this.parentRowOutletDirective : this.rowOutletDirective;
            this.rowEditPositioningStrategy.settings.container = this.tbody.nativeElement;
            var pinned = this._pinnedRecordIDs.indexOf(rowID) !== -1;
            var targetRow = !pinned ? this.gridAPI.get_row_by_key(rowID) : this.pinnedRows.find(function (x) { return x.rowID === rowID; });
            if (!targetRow) {
                return;
            }
            settings.target = targetRow.element.nativeElement;
            this.toggleRowEditingOverlay(true);
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.rowEditingWheelHandler = function (event) {
            if (event.deltaY > 0) {
                this.verticalScrollContainer.scrollNext();
            }
            else {
                this.verticalScrollContainer.scrollPrev();
            }
        };
        return IgxGridBaseDirective;
    }(DisplayDensityBase));
    IgxGridBaseDirective.decorators = [
        { type: i0.Directive }
    ];
    IgxGridBaseDirective.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: IgxColumnResizingService },
        { type: GridBaseAPIService },
        { type: undefined, decorators: [{ type: i0.Inject, args: [IgxGridTransaction,] }] },
        { type: i0.ElementRef },
        { type: i0.NgZone },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: i0.ChangeDetectorRef },
        { type: i0.ComponentFactoryResolver },
        { type: i0.IterableDiffers },
        { type: i0.ViewContainerRef },
        { type: IgxGridNavigationService },
        { type: IgxFilteringService },
        { type: IgxOverlayService, decorators: [{ type: i0.Inject, args: [IgxOverlayService,] }] },
        { type: IgxGridSummaryService },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] },
        { type: String, decorators: [{ type: i0.Inject, args: [i0.LOCALE_ID,] }] }
    ]; };
    IgxGridBaseDirective.propDecorators = {
        snackbarDisplayTime: [{ type: i0.Input }],
        autoGenerate: [{ type: i0.Input }],
        emptyGridTemplate: [{ type: i0.Input }],
        addRowEmptyTemplate: [{ type: i0.Input }],
        loadingGridTemplate: [{ type: i0.Input }],
        clipboardOptions: [{ type: i0.Input }],
        filteringExpressionsTreeChange: [{ type: i0.Output }],
        advancedFilteringExpressionsTreeChange: [{ type: i0.Output }],
        onScroll: [{ type: i0.Output }],
        pageChange: [{ type: i0.Output }],
        perPageChange: [{ type: i0.Output }],
        paginationTemplate: [{ type: i0.Input }],
        class: [{ type: i0.Input }],
        evenRowCSS: [{ type: i0.Input }],
        oddRowCSS: [{ type: i0.Input }],
        primaryKey: [{ type: i0.Input }],
        uniqueColumnValuesStrategy: [{ type: i0.Input }],
        excelStyleFilteringComponents: [{ type: i0.ContentChildren, args: [IgxGridExcelStyleFilteringComponent, { read: IgxGridExcelStyleFilteringComponent, descendants: false },] }],
        headerGroups: [{ type: i0.ViewChildren, args: [IgxGridHeaderGroupComponent, { read: IgxGridHeaderGroupComponent },] }],
        onCellClick: [{ type: i0.Output }],
        onSelection: [{ type: i0.Output }],
        onRowSelectionChange: [{ type: i0.Output }],
        onColumnSelectionChange: [{ type: i0.Output }],
        onColumnPinning: [{ type: i0.Output }],
        columnPinned: [{ type: i0.Output }],
        cellEditEnter: [{ type: i0.Output }],
        cellEditExit: [{ type: i0.Output }],
        cellEdit: [{ type: i0.Output }],
        cellEditDone: [{ type: i0.Output }],
        rowEditEnter: [{ type: i0.Output }],
        rowEdit: [{ type: i0.Output }],
        rowEditDone: [{ type: i0.Output }],
        rowEditExit: [{ type: i0.Output }],
        onColumnInit: [{ type: i0.Output }],
        sorting: [{ type: i0.Output }],
        onSortingDone: [{ type: i0.Output }],
        filtering: [{ type: i0.Output }],
        onFilteringDone: [{ type: i0.Output }],
        onPagingDone: [{ type: i0.Output }],
        onRowAdded: [{ type: i0.Output }],
        onRowDeleted: [{ type: i0.Output }],
        onColumnResized: [{ type: i0.Output }],
        onContextMenu: [{ type: i0.Output }],
        onDoubleClick: [{ type: i0.Output }],
        columnVisibilityChanging: [{ type: i0.Output }],
        onColumnVisibilityChanged: [{ type: i0.Output }],
        onColumnMovingStart: [{ type: i0.Output }],
        onColumnMoving: [{ type: i0.Output }],
        onColumnMovingEnd: [{ type: i0.Output }],
        onGridKeydown: [{ type: i0.Output }],
        onRowDragStart: [{ type: i0.Output }],
        onRowDragEnd: [{ type: i0.Output }],
        onGridCopy: [{ type: i0.Output }],
        expansionStatesChange: [{ type: i0.Output }],
        onRowToggle: [{ type: i0.Output }],
        onRowPinning: [{ type: i0.Output }],
        activeNodeChange: [{ type: i0.Output }],
        sortingExpressionsChange: [{ type: i0.Output }],
        onToolbarExporting: [{ type: i0.Output }],
        onRangeSelection: [{ type: i0.Output }],
        rendered: [{ type: i0.Output }],
        addRowSnackbar: [{ type: i0.ViewChild, args: [IgxSnackbarComponent,] }],
        resizeLine: [{ type: i0.ViewChild, args: [IgxGridColumnResizerComponent,] }],
        loadingOverlay: [{ type: i0.ViewChild, args: ['loadingOverlay', { read: IgxToggleDirective, static: true },] }],
        loadingOutlet: [{ type: i0.ViewChild, args: ['igxLoadingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
        columnList: [{ type: i0.ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: true },] }],
        actionStrip: [{ type: i0.ContentChild, args: [IgxActionStripComponent,] }],
        excelStyleLoadingValuesTemplateDirective: [{ type: i0.ContentChild, args: [IgxExcelStyleLoadingValuesTemplateDirective, { read: IgxExcelStyleLoadingValuesTemplateDirective, static: true },] }],
        emptyFilteredGridTemplate: [{ type: i0.ViewChild, args: ['emptyFilteredGrid', { read: i0.TemplateRef, static: true },] }],
        emptyGridDefaultTemplate: [{ type: i0.ViewChild, args: ['defaultEmptyGrid', { read: i0.TemplateRef, static: true },] }],
        loadingGridDefaultTemplate: [{ type: i0.ViewChild, args: ['defaultLoadingGrid', { read: i0.TemplateRef, static: true },] }],
        parentVirtDir: [{ type: i0.ViewChild, args: ['scrollContainer', { read: IgxGridForOfDirective, static: true },] }],
        headSelectorsTemplates: [{ type: i0.ContentChildren, args: [IgxHeadSelectorDirective, { read: IgxHeadSelectorDirective, descendants: false },] }],
        rowSelectorsTemplates: [{ type: i0.ContentChildren, args: [IgxRowSelectorDirective, { read: IgxRowSelectorDirective, descendants: false },] }],
        dragGhostCustomTemplates: [{ type: i0.ContentChildren, args: [IgxRowDragGhostDirective, { read: i0.TemplateRef, descendants: false },] }],
        verticalScrollContainer: [{ type: i0.ViewChild, args: ['verticalScrollContainer', { read: IgxGridForOfDirective, static: true },] }],
        verticalScroll: [{ type: i0.ViewChild, args: ['verticalScrollHolder', { read: IgxGridForOfDirective, static: true },] }],
        scr: [{ type: i0.ViewChild, args: ['scr', { read: i0.ElementRef, static: true },] }],
        footer: [{ type: i0.ViewChild, args: ['footer', { read: i0.ElementRef },] }],
        headerContainer: [{ type: i0.ViewChild, args: ['hContainer', { read: IgxGridForOfDirective, static: true },] }],
        headerSelectorContainer: [{ type: i0.ViewChild, args: ['headerSelectorContainer',] }],
        headerDragContainer: [{ type: i0.ViewChild, args: ['headerDragContainer',] }],
        headerGroupContainer: [{ type: i0.ViewChild, args: ['headerGroupContainer',] }],
        filteringRow: [{ type: i0.ViewChild, args: ['filteringRow', { read: IgxGridFilteringRowComponent },] }],
        theadRow: [{ type: i0.ViewChild, args: ['theadRow', { static: true },] }],
        tbody: [{ type: i0.ViewChild, args: ['tbody', { static: true },] }],
        pinContainer: [{ type: i0.ViewChild, args: ['pinContainer', { read: i0.ElementRef },] }],
        tfoot: [{ type: i0.ViewChild, args: ['tfoot', { static: true },] }],
        rowEditingOutletDirective: [{ type: i0.ViewChild, args: ['igxRowEditingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
        tmpOutlets: [{ type: i0.ViewChildren, args: [IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective },] }],
        dragIndicatorIconBase: [{ type: i0.ViewChild, args: ['dragIndicatorIconBase', { read: i0.TemplateRef, static: true },] }],
        rowEditCustom: [{ type: i0.ContentChild, args: [IgxRowEditTemplateDirective, { read: i0.TemplateRef },] }],
        rowEditText: [{ type: i0.ContentChild, args: [IgxRowEditTextDirective, { read: i0.TemplateRef },] }],
        rowEditActions: [{ type: i0.ContentChild, args: [IgxRowEditActionsDirective, { read: i0.TemplateRef },] }],
        rowExpandedIndicatorTemplate: [{ type: i0.ContentChild, args: [IgxRowExpandedIndicatorDirective, { read: i0.TemplateRef },] }],
        rowCollapsedIndicatorTemplate: [{ type: i0.ContentChild, args: [IgxRowCollapsedIndicatorDirective, { read: i0.TemplateRef },] }],
        headerExpandIndicatorTemplate: [{ type: i0.ContentChild, args: [IgxHeaderExpandIndicatorDirective, { read: i0.TemplateRef },] }],
        headerCollapseIndicatorTemplate: [{ type: i0.ContentChild, args: [IgxHeaderCollapseIndicatorDirective, { read: i0.TemplateRef },] }],
        excelStyleHeaderIconTemplate: [{ type: i0.ContentChild, args: [IgxExcelStyleHeaderIconDirective, { read: i0.TemplateRef },] }],
        dragIndicatorIconTemplates: [{ type: i0.ContentChildren, args: [IgxDragIndicatorIconDirective, { read: i0.TemplateRef, descendants: false },] }],
        rowEditTabsDEFAULT: [{ type: i0.ViewChildren, args: [IgxRowEditTabStopDirective,] }],
        rowEditTabsCUSTOM: [{ type: i0.ContentChildren, args: [IgxRowEditTabStopDirective, { descendants: true },] }],
        rowEditingOverlay: [{ type: i0.ViewChild, args: ['rowEditingOverlay', { read: IgxToggleDirective },] }],
        tabindex: [{ type: i0.HostBinding, args: ['attr.tabindex',] }],
        hostRole: [{ type: i0.HostBinding, args: ['attr.role',] }],
        toolbar: [{ type: i0.ContentChildren, args: [IgxGridToolbarComponent,] }],
        _outletDirective: [{ type: i0.ViewChild, args: ['igxFilteringOverlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
        defaultExpandedTemplate: [{ type: i0.ViewChild, args: ['defaultExpandedTemplate', { read: i0.TemplateRef, static: true },] }],
        defaultCollapsedTemplate: [{ type: i0.ViewChild, args: ['defaultCollapsedTemplate', { read: i0.TemplateRef, static: true },] }],
        defaultESFHeaderIconTemplate: [{ type: i0.ViewChild, args: ['defaultESFHeaderIcon', { read: i0.TemplateRef, static: true },] }],
        _summaryRowList: [{ type: i0.ViewChildren, args: ['summaryRow', { read: IgxSummaryRowComponent },] }],
        _rowList: [{ type: i0.ViewChildren, args: ['row',] }],
        _pinnedRowList: [{ type: i0.ViewChildren, args: ['pinnedRow',] }],
        defaultRowEditTemplate: [{ type: i0.ViewChild, args: ['defaultRowEditTemplate', { read: i0.TemplateRef, static: true },] }],
        _dataRowList: [{ type: i0.ViewChildren, args: [IgxRowDirective, { read: IgxRowDirective },] }],
        resourceStrings: [{ type: i0.Input }],
        filteringLogic: [{ type: i0.Input }],
        filteringExpressionsTree: [{ type: i0.Input }],
        advancedFilteringExpressionsTree: [{ type: i0.Input }],
        locale: [{ type: i0.Input }],
        pagingMode: [{ type: i0.Input }],
        paging: [{ type: i0.Input }],
        page: [{ type: i0.Input }],
        perPage: [{ type: i0.Input }],
        columnHiding: [{ type: i0.Input }],
        hideRowSelectors: [{ type: i0.Input }],
        rowDraggable: [{ type: i0.Input }],
        rowEditable: [{ type: i0.Input }],
        height: [{ type: i0.HostBinding, args: ['style.height',] }, { type: i0.Input }],
        hostWidth: [{ type: i0.HostBinding, args: ['style.width',] }],
        width: [{ type: i0.Input }],
        rowHeight: [{ type: i0.Input }],
        columnWidth: [{ type: i0.Input }],
        emptyGridMessage: [{ type: i0.Input }],
        isLoading: [{ type: i0.Input }],
        emptyFilteredGridMessage: [{ type: i0.Input }],
        columnHidingTitle: [{ type: i0.Input }],
        pinning: [{ type: i0.Input }],
        columnPinning: [{ type: i0.Input }],
        columnPinningTitle: [{ type: i0.Input }],
        allowFiltering: [{ type: i0.Input }],
        allowAdvancedFiltering: [{ type: i0.Input }],
        filterMode: [{ type: i0.Input }],
        summaryPosition: [{ type: i0.Input }],
        summaryCalculationMode: [{ type: i0.Input }],
        showSummaryOnCollapse: [{ type: i0.Input }],
        filterStrategy: [{ type: i0.Input }],
        sortStrategy: [{ type: i0.Input }],
        selectedRows: [{ type: i0.Input }],
        hostClass: [{ type: i0.HostBinding, args: ['attr.class',] }],
        sortingExpressions: [{ type: i0.Input }],
        hiddenColumnsText: [{ type: i0.Input }],
        pinnedColumnsText: [{ type: i0.Input }],
        showToolbar: [{ type: i0.Input }],
        toolbarTitle: [{ type: i0.Input }],
        exportExcel: [{ type: i0.Input }],
        exportCsv: [{ type: i0.Input }],
        exportText: [{ type: i0.Input }],
        exportExcelText: [{ type: i0.Input }],
        exportCsvText: [{ type: i0.Input }],
        cellSelection: [{ type: i0.Input }],
        rowSelection: [{ type: i0.Input }],
        columnSelection: [{ type: i0.Input }],
        hideActionStrip: [{ type: i0.HostListener, args: ['mouseleave',] }],
        expansionStates: [{ type: i0.Input }],
        outlet: [{ type: i0.Input }],
        totalRecords: [{ type: i0.Input }],
        selectRowOnClick: [{ type: i0.Input }]
    };
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "primaryKey", void 0);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "filteringLogic", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "filteringExpressionsTree", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "advancedFilteringExpressionsTree", null);
    __decorate([
        DeprecateProperty('`columnHiding` is deprecated.')
    ], IgxGridBaseDirective.prototype, "columnHiding", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "hideRowSelectors", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "rowEditable", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "height", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "width", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "rowHeight", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "columnWidth", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "isLoading", null);
    __decorate([
        DeprecateProperty('`columnHidingTitle` is deprecated')
    ], IgxGridBaseDirective.prototype, "columnHidingTitle", null);
    __decorate([
        DeprecateProperty('`columnPinning` is deprecated')
    ], IgxGridBaseDirective.prototype, "columnPinning", null);
    __decorate([
        DeprecateProperty('`columnPinningTitle` is deprecated')
    ], IgxGridBaseDirective.prototype, "columnPinningTitle", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "sortingExpressions", null);
    __decorate([
        DeprecateProperty('`pinnedColumnsText` is deprecated')
    ], IgxGridBaseDirective.prototype, "pinnedColumnsText", null);
    __decorate([
        DeprecateProperty('`showToolbar` is deprecated')
    ], IgxGridBaseDirective.prototype, "showToolbar", null);
    __decorate([
        DeprecateProperty('`toolbarTitle` is deprecated')
    ], IgxGridBaseDirective.prototype, "toolbarTitle", null);
    __decorate([
        DeprecateProperty('`exportExcel` is deprecated')
    ], IgxGridBaseDirective.prototype, "exportExcel", null);
    __decorate([
        DeprecateProperty('`exportCsv` is deprecated')
    ], IgxGridBaseDirective.prototype, "exportCsv", null);
    __decorate([
        DeprecateProperty('`exportText` is deprecated')
    ], IgxGridBaseDirective.prototype, "exportText", null);
    __decorate([
        DeprecateProperty('`exportExcelText` is deprecated')
    ], IgxGridBaseDirective.prototype, "exportExcelText", null);
    __decorate([
        DeprecateProperty('`exportCsvText` is deprecated')
    ], IgxGridBaseDirective.prototype, "exportCsvText", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "cellSelection", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "rowSelection", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "columnSelection", null);
    __decorate([
        WatchChanges()
    ], IgxGridBaseDirective.prototype, "selectRowOnClick", null);

    var IgxGridFooterComponent = /** @class */ (function () {
        function IgxGridFooterComponent() {
        }
        return IgxGridFooterComponent;
    }());
    IgxGridFooterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-grid-footer',
                    template: '<ng-content></ng-content>'
                },] }
    ];

    /**
     * The `<igx-select-item>` is a container intended for row items in
     * a `<igx-select>` container.
     */
    var IgxSelectGroupComponent = /** @class */ (function (_super) {
        __extends(IgxSelectGroupComponent, _super);
        function IgxSelectGroupComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return IgxSelectGroupComponent;
    }(IgxDropDownGroupComponent));
    IgxSelectGroupComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-select-item-group',
                    template: "\n        <label id=\"{{labelId}}\">{{ label }}</label>\n        <ng-content select=\"igx-select-item\"></ng-content>\n    "
                },] }
    ];

    /** @hidden @internal */
    var IgxSelectItemNavigationDirective = /** @class */ (function (_super) {
        __extends(IgxSelectItemNavigationDirective, _super);
        function IgxSelectItemNavigationDirective() {
            var _this = _super.call(this, null) || this;
            _this._target = null;
            /* eslint-disable @typescript-eslint/member-ordering */
            _this.inputStream = '';
            _this.clearStream$ = rxjs.Subscription.EMPTY;
            return _this;
        }
        Object.defineProperty(IgxSelectItemNavigationDirective.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = target ? target : this.dropdown;
            },
            enumerable: false,
            configurable: true
        });
        /** Captures keydown events and calls the appropriate handlers on the target component */
        IgxSelectItemNavigationDirective.prototype.handleKeyDown = function (event) {
            if (!event) {
                return;
            }
            var key = event.key.toLowerCase();
            if (event.altKey && (key === 'arrowdown' || key === 'arrowup' || key === 'down' || key === 'up')) {
                this.target.toggle();
                return;
            }
            if (this.target.collapsed) {
                switch (key) {
                    case 'space':
                    case 'spacebar':
                    case ' ':
                    case 'enter':
                        event.preventDefault();
                        this.target.open();
                        return;
                    case 'arrowdown':
                    case 'down':
                        this.target.navigateNext();
                        this.target.selectItem(this.target.focusedItem);
                        event.preventDefault();
                        return;
                    case 'arrowup':
                    case 'up':
                        this.target.navigatePrev();
                        this.target.selectItem(this.target.focusedItem);
                        event.preventDefault();
                        return;
                    default:
                        break;
                }
            }
            else if (key === 'tab' || event.shiftKey && key === 'tab') {
                this.target.close();
            }
            _super.prototype.handleKeyDown.call(this, event);
            this.captureKey(event);
        };
        IgxSelectItemNavigationDirective.prototype.captureKey = function (event) {
            var _this = this;
            // relying only on key, available on all major browsers:
            // https://caniuse.com/#feat=keyboardevent-key (IE/Edge quirk doesn't affect letter typing)
            if (!event || !event.key || event.key.length > 1 || event.key === ' ' || event.key === 'spacebar') {
                // ignore longer keys ('Alt', 'ArrowDown', etc) AND spacebar (used of open/close)
                return;
            }
            this.clearStream$.unsubscribe();
            this.clearStream$ = rxjs.timer(500).subscribe(function () {
                _this.inputStream = '';
            });
            this.inputStream += event.key;
            var focusedItem = this.target.focusedItem;
            // select the item
            if (focusedItem && this.inputStream.length > 1 && focusedItem.itemText.toLowerCase().startsWith(this.inputStream.toLowerCase())) {
                return;
            }
            this.activateItemByText(this.inputStream);
        };
        IgxSelectItemNavigationDirective.prototype.activateItemByText = function (text) {
            var items = this.target.items;
            // ^ this is focused OR selected if the dd is closed
            var nextItem = this.findNextItem(items, text);
            // If there is no such an item starting with the current text input stream AND the last Char in the input stream
            // is the same as the first one, find next item starting with the same first Char.
            // Covers cases of holding down the same key Ex: "pppppp" that iterates trough list items starting with "p".
            if (!nextItem && text.charAt(0) === text.charAt(text.length - 1)) {
                text = text.slice(0, 1);
                nextItem = this.findNextItem(items, text);
            }
            // If there is no other item to be found, do not change the active item.
            if (!nextItem) {
                return;
            }
            if (this.target.collapsed) {
                this.target.selectItem(nextItem);
            }
            this.target.navigateItem(items.indexOf(nextItem));
        };
        IgxSelectItemNavigationDirective.prototype.findNextItem = function (items, text) {
            var activeItemIndex = items.indexOf(this.target.focusedItem) || 0;
            // Match next item in ddl items and wrap around if needed
            return items.slice(activeItemIndex + 1).find(function (x) { return !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase())); }) ||
                items.slice(0, activeItemIndex).find(function (x) { return !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase())); });
        };
        IgxSelectItemNavigationDirective.prototype.ngOnDestroy = function () {
            this.clearStream$.unsubscribe();
        };
        return IgxSelectItemNavigationDirective;
    }(IgxDropDownItemNavigationDirective));
    IgxSelectItemNavigationDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxSelectItemNavigation]'
                },] }
    ];
    IgxSelectItemNavigationDirective.ctorParameters = function () { return []; };
    IgxSelectItemNavigationDirective.propDecorators = {
        target: [{ type: i0.Input, args: ['igxSelectItemNavigation',] }]
    };

    /** @hidden */
    var IgxSelectModule = /** @class */ (function () {
        function IgxSelectModule() {
        }
        return IgxSelectModule;
    }());
    IgxSelectModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxSelectComponent,
                        IgxSelectFooterDirective,
                        IgxSelectGroupComponent,
                        IgxSelectHeaderDirective,
                        IgxSelectItemComponent,
                        IgxSelectItemNavigationDirective,
                        IgxSelectToggleIconDirective
                    ],
                    exports: [
                        IgxSelectComponent,
                        IgxSelectFooterDirective,
                        IgxSelectGroupComponent,
                        IgxSelectHeaderDirective,
                        IgxSelectItemComponent,
                        IgxSelectItemNavigationDirective,
                        IgxSelectToggleIconDirective,
                        IgxInputGroupModule
                    ],
                    imports: [
                        i2.CommonModule,
                        forms.FormsModule,
                        IgxButtonModule,
                        IgxDropDownModule,
                        IgxIconModule,
                        IgxInputGroupModule,
                        IgxRippleModule,
                        IgxToggleModule,
                        forms.ReactiveFormsModule
                    ],
                    providers: []
                },] }
    ];

    var IgxPaginatorComponent = /** @class */ (function (_super) {
        __extends(IgxPaginatorComponent, _super);
        function IgxPaginatorComponent(_displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this._displayDensityOptions = _displayDensityOptions;
            /**
             * An @Input property that sets if the pager in the paginator should be enabled.
             * ```html
             * <igx-paginator [pagerEnabled]="true"></igx-paginator>
             * ```
             *
             * @memberof IgxPaginatorComponent
             */
            _this.pagerEnabled = true;
            /**
             * An @Input property that sets if the pager in the paginator should be hidden.
             * ```html
             * <igx-paginator [pagerHidden]="true"></igx-paginator>
             * ```
             *
             * @memberof IgxPaginatorComponent
             */
            _this.pagerHidden = false;
            /**
             * An @Input property that sets if the dropdown in the paginator should be enabled.
             * ```html
             * <igx-paginator [dropdownEnabled]="true"></igx-paginator>
             * ```
             *
             * @memberof IgxPaginatorComponent
             */
            _this.dropdownEnabled = true;
            /**
             * An @Input property that sets if the dropdown in the paginator should be hidden.
             * ```html
             * <igx-paginator [dropdownHidden]="true"></igx-paginator>
             * ```
             *
             * @memberof IgxPaginatorComponent
             */
            _this.dropdownHidden = false;
            /**
             * Emitted when `perPage` property value of the paginator is changed.
             *
             * @example
             * ```html
             * <igx-paginator (perPageChange)="onPerPageChange($event)"></igx-paginator>
             * ```
             * ```typescript
             * public onPerPageChange(perPage: number) {
             *   this.perPage = perPage;
             * }
             * ```
             */
            _this.perPageChange = new i0.EventEmitter();
            /**
             * Emitted after the current page is changed.
             *
             * @example
             * ```html
             * <igx-paginator (pageChange)="onPageChange($event)"></igx-paginator>
             * ```
             * ```typescript
             * public onPageChange(page: number) {
             *   this.currentPage = page;
             * }
             * ```
             */
            _this.pageChange = new i0.EventEmitter();
            _this._page = 0;
            _this._perPage = 15;
            _this._resourceStrings = CurrentResourceStrings.PaginatorResStrings;
            _this._overlaySettings = {};
            _this.defaultSelectValues = [5, 10, 15, 25, 50, 100, 500];
            return _this;
        }
        Object.defineProperty(IgxPaginatorComponent.prototype, "classCosy", {
            /**
             * Sets the class of the IgxPaginatorComponent based
             * on the provided displayDensity.
             */
            get: function () {
                return this.displayDensity === DisplayDensity.cosy;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "classCompact", {
            get: function () {
                return this.displayDensity === DisplayDensity.compact;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "classComfortable", {
            get: function () {
                return this.displayDensity === DisplayDensity.comfortable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "page", {
            /**
             * An @Input property, sets current page of the `IgxPaginatorComponent`.
             * The default is 0.
             * ```typescript
             * let page = this.paginator.page;
             * ```
             *
             * @memberof IgxPaginatorComponent
             */
            get: function () {
                return this._page;
            },
            set: function (value) {
                this._page = value;
                this.pageChange.emit(this._page);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "perPage", {
            /**
             * An @Input property, sets number of visible items per page in the `IgxPaginatorComponent`.
             * The default is 15.
             * ```typescript
             * let itemsPerPage = this.paginator.perPage;
             * ```
             *
             * @memberof IgxPaginatorComponent
             */
            get: function () {
                return this._perPage;
            },
            set: function (value) {
                this._perPage = Number(value);
                this.perPageChange.emit(this._perPage);
                this._selectOptions = this.sortUniqueOptions(this.defaultSelectValues, this._perPage);
                this.totalPages = Math.ceil(this.totalRecords / this._perPage);
                if (this.totalPages !== 0 && this.page >= this.totalPages) {
                    this.page = this.totalPages - 1;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "totalRecords", {
            /**
             * An @Input property that sets the total records.
             * ```typescript
             * let totalRecords = this.paginator.totalRecords;
             * ```
             *
             * @memberof IgxPaginatorComponent
             */
            get: function () {
                return this._totalRecords;
            },
            set: function (value) {
                this._totalRecords = value;
                this.totalPages = Math.ceil(this.totalRecords / this.perPage);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "selectOptions", {
            /**
             * An @Input property that sets custom options in the select of the paginator
             * ```typescript
             * let options = this.paginator.selectOptions;
             * ```
             *
             * @memberof IgxPaginatorComponent
             */
            get: function () {
                return this._selectOptions;
            },
            set: function (value) {
                this._selectOptions = this.sortUniqueOptions(value, this._perPage);
                this.defaultSelectValues = __spread(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "overlaySettings", {
            /**
             * An @Input property that sets custom OverlaySettings.
             * ```html
             * <igx-paginator [overlaySettings] = "customOverlaySettings"></igx-paginator>
             * ```
             */
            get: function () {
                return this._overlaySettings;
            },
            set: function (value) {
                this._overlaySettings = Object.assign({}, this._overlaySettings, value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "resourceStrings", {
            /**
             * An accessor that returns the resource strings.
             */
            get: function () {
                return this._resourceStrings;
            },
            /**
             * An accessor that sets the resource strings.
             * By default it uses EN resources.
             */
            set: function (value) {
                this._resourceStrings = Object.assign({}, this._resourceStrings, value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "isLastPage", {
            /**
             * Returns if the current page is the last page.
             * ```typescript
             * const lastPage = this.paginator.isLastPage;
             * ```
             */
            get: function () {
                return this.page + 1 >= this.totalPages;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "isFirstPage", {
            /**
             * Returns if the current page is the first page.
             * ```typescript
             * const lastPage = this.paginator.isFirstPage;
             * ```
             */
            get: function () {
                return this.page === 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "isFirstPageDisabled", {
            /**
             * Returns if the first pager buttons should be disabled
             */
            get: function () {
                return this.isFirstPage || !this.pagerEnabled;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "isLastPageDisabled", {
            /**
             * Returns if the last pager buttons should be disabled
             */
            get: function () {
                return this.isLastPage || !this.pagerEnabled;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Sets DisplayDensity for the <select> inside the paginator
         *
         * @hidden
         */
        IgxPaginatorComponent.prototype.paginatorSelectDisplayDensity = function () {
            if (this.displayDensity === DisplayDensity.comfortable) {
                return DisplayDensity.cosy;
            }
            return DisplayDensity.compact;
        };
        /**
         * Goes to the next page of the `IgxPaginatorComponent`, if the paginator is not already at the last page.
         * ```typescript
         * this.paginator.nextPage();
         * ```
         *
         * @memberof IgxPaginatorComponent
         */
        IgxPaginatorComponent.prototype.nextPage = function () {
            if (!this.isLastPage) {
                this.page += 1;
            }
        };
        /**
         * Goes to the previous page of the `IgxPaginatorComponent`, if the paginator is not already at the first page.
         * ```typescript
         * this.paginator.previousPage();
         * ```
         *
         * @memberof IgxPaginatorComponent
         */
        IgxPaginatorComponent.prototype.previousPage = function () {
            if (!this.isFirstPage) {
                this.page -= 1;
            }
        };
        /**
         * Goes to the desired page index.
         * ```typescript
         * this.paginator.paginate(1);
         * ```
         *
         * @param val
         * @memberof IgxPaginatorComponent
         */
        IgxPaginatorComponent.prototype.paginate = function (val) {
            if (val < 0 || val > this.totalPages - 1) {
                return;
            }
            this.page = val;
        };
        IgxPaginatorComponent.prototype.sortUniqueOptions = function (values, newOption) {
            return Array.from(new Set(__spread(values, [newOption]))).sort(function (a, b) { return a - b; });
        };
        return IgxPaginatorComponent;
    }(DisplayDensityBase));
    IgxPaginatorComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-paginator',
                    template: "<div class=\"igx-paginator__select\" [hidden]=\"dropdownHidden\">\n    <label class=\"igx-paginator__label\">{{ resourceStrings.igx_paginator_label }}</label>\n    <div class=\"igx-paginator__select-input\">\n        <igx-select [overlaySettings]=\"overlaySettings\" [(ngModel)]=\"perPage\" [displayDensity]=\"paginatorSelectDisplayDensity()\" type=\"border\"\n            [disabled]=\"!dropdownEnabled\">\n            <label igxLabel [hidden]=\"true\">{{ resourceStrings.igx_paginator_label }}</label>\n            <igx-select-item [value]=\"val\" *ngFor=\"let val of selectOptions\">\n                {{val}}\n            </igx-select-item>\n        </igx-select>\n    </div>\n</div>\n<div class=\"igx-paginator__pager\" [hidden]=\"pagerHidden\" role=\"navigation\">\n    <button [title]=\"resourceStrings.igx_paginator_first_page_button_text\" [disabled]=\"isFirstPageDisabled\" [attr.aria-disabled]=\"isFirstPageDisabled\" (click)=\"paginate(0)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon>first_page</igx-icon>\n    </button>\n    <button [title]=\"resourceStrings.igx_paginator_previous_page_button_text\" [disabled]=\"isFirstPageDisabled\" [attr.aria-disabled]=\"isFirstPageDisabled\" (click)=\"previousPage()\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon>chevron_left</igx-icon>\n    </button>\n    <div class='igx-paginator__pager-text' aria-current=\"page\">\n        <span>{{ page + 1 }}</span>\n        <span>&nbsp;{{ resourceStrings.igx_paginator_pager_text }}&nbsp;</span>\n        <span>{{ totalPages }}</span>\n    </div>\n    <button [title]=\"resourceStrings.igx_paginator_next_page_button_text\" [disabled]=\"isLastPageDisabled\" [attr.aria-disabled]=\"isLastPageDisabled\" (click)=\"nextPage()\" igxRipple igxRippleCentered=\"true\" igxButton=\"icon\">\n        <igx-icon>chevron_right</igx-icon>\n    </button>\n    <button [title]=\"resourceStrings.igx_paginator_last_page_button_text\" [disabled]=\"isLastPageDisabled\" [attr.aria-disabled]=\"isLastPageDisabled\" (click)=\"paginate(totalPages - 1)\" igxButton=\"icon\" igxRipple\n        igxRippleCentered=\"true\">\n        <igx-icon>last_page</igx-icon>\n    </button>\n</div>\n"
                },] }
    ];
    IgxPaginatorComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxPaginatorComponent.propDecorators = {
        pagerEnabled: [{ type: i0.Input }],
        pagerHidden: [{ type: i0.Input }],
        dropdownEnabled: [{ type: i0.Input }],
        dropdownHidden: [{ type: i0.Input }],
        selectLabel: [{ type: i0.Input }],
        prepositionPage: [{ type: i0.Input }],
        perPageChange: [{ type: i0.Output }],
        pageChange: [{ type: i0.Output }],
        classCosy: [{ type: i0.HostBinding, args: ['class.igx-paginator--cosy',] }],
        classCompact: [{ type: i0.HostBinding, args: ['class.igx-paginator--compact',] }],
        classComfortable: [{ type: i0.HostBinding, args: ['class.igx-paginator',] }],
        page: [{ type: i0.Input }],
        perPage: [{ type: i0.Input }],
        totalRecords: [{ type: i0.Input }],
        selectOptions: [{ type: i0.Input }],
        overlaySettings: [{ type: i0.Input }],
        resourceStrings: [{ type: i0.Input }]
    };
    __decorate([
        DeprecateProperty("'selectLabel' property is deprecated. Use 'resourceStrings' instead.")
    ], IgxPaginatorComponent.prototype, "selectLabel", void 0);
    __decorate([
        DeprecateProperty("'prepositionPage' property is deprecated. Use 'resourceStrings' instead.")
    ], IgxPaginatorComponent.prototype, "prepositionPage", void 0);
    var IgxPaginatorModule = /** @class */ (function () {
        function IgxPaginatorModule() {
        }
        return IgxPaginatorModule;
    }());
    IgxPaginatorModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxPaginatorComponent],
                    exports: [IgxPaginatorComponent],
                    imports: [i2.CommonModule, IgxSelectModule, forms.FormsModule, IgxIconModule, IgxButtonModule, IgxRippleModule, IgxInputGroupModule]
                },] }
    ];

    var NEXT_ID$k = 0;
    /**
     * Providing reference to `IgxColumnActionsComponent`:
     * ```typescript
     *  @ViewChild('columnActions', { read: IgxColumnActionsComponent })
     *  public columnActions: IgxColumnActionsComponent;
     */
    var IgxColumnActionsComponent = /** @class */ (function () {
        function IgxColumnActionsComponent(differs) {
            var _this = this;
            this.differs = differs;
            /**
             * Gets/sets the indentation of columns in the column list based on their hierarchy level.
             *
             * @example
             * ```
             * <igx-column-actions [indentation]="15"></igx-column-actions>
             * ```
             */
            this.indentation = 30;
            /**
             * Sets/Gets the css class selector.
             * By default the value of the `class` attribute is `"igx-column-actions"`.
             * ```typescript
             * let cssCLass =  this.columnHidingUI.cssClass;
             * ```
             * ```typescript
             * this.columnHidingUI.cssClass = 'column-chooser';
             * ```
             */
            this.cssClass = 'igx-column-actions';
            /**
             * Gets/sets the max height of the columns area.
             *
             * @remarks
             * The default max height is 100%.
             * @example
             * ```html
             * <igx-column-actions [columnsAreaMaxHeight]="200px"></igx-column-actions>
             * ```
             */
            this.columnsAreaMaxHeight = '100%';
            /**
             * Shows/hides the columns filtering input from the UI.
             *
             * @example
             * ```html
             *  <igx-column-actions [hideFilter]="true"></igx-column-actions>
             * ```
             */
            this.hideFilter = false;
            /**
             * Gets/sets the title of the column actions component.
             *
             * @example
             * ```html
             * <igx-column-actions [title]="'Pin Columns'"></igx-column-actions>
             * ```
             */
            this.title = '';
            /**
             * An event that is emitted after a column's checked state is changed.
             * Provides references to the `column` and the `checked` properties as event arguments.
             * ```html
             *  <igx-column-actions (onColumnToggled)="onColumnToggled($event)"></igx-column-actions>
             * ```
             */
            this.onColumnToggled = new i0.EventEmitter();
            /**
             * @hidden @internal
             */
            this.actionableColumns = [];
            /**
             * @hidden @internal
             */
            this.filteredColumns = [];
            /**
             * @hidden @internal
             */
            this.pipeTrigger = 0;
            this._differ = null;
            /**
             * @hidden @internal
             */
            this._filterColumnsPrompt = '';
            /**
             * @hidden @internal
             */
            this._filterCriteria = '';
            /**
             * @hidden @internal
             */
            this._columnDisplayOrder = ColumnDisplayOrder.DisplayOrder;
            /**
             * @hidden @internal
             */
            this._id = "igx-column-actions-" + NEXT_ID$k++;
            /**
             * @hidden @internal
             */
            this.trackChanges = function (index, col) { return col.field + '_' + _this.actionsDirective.actionEnabledColumnsFilter(col, index, []); };
            this._differ = this.differs.find([]).create(this.trackChanges);
        }
        Object.defineProperty(IgxColumnActionsComponent.prototype, "columns", {
            /**
             * Gets the grid columns to provide an action for.
             *
             * @deprecated
             * @example
             * ```typescript
             * let gridColumns = this.columnActions.columns;
             * ```
             */
            get: function () {
                var _a;
                return (_a = this.grid) === null || _a === void 0 ? void 0 : _a.columns;
            },
            set: function (value) {
                if (value && value.length > 0) {
                    this.grid = value[0].grid;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnActionsComponent.prototype, "filterColumnsPrompt", {
            /**
             * Gets the prompt that is displayed in the filter input.
             *
             * @example
             * ```typescript
             * let filterColumnsPrompt = this.columnActions.filterColumnsPrompt;
             * ```
             */
            get: function () {
                return this._filterColumnsPrompt;
            },
            /**
             * Sets the prompt that is displayed in the filter input.
             *
             * @example
             * ```html
             * <igx-column-actions [filterColumnsPrompt]="'Type here to search'"></igx-column-actions>
             * ```
             */
            set: function (value) {
                this._filterColumnsPrompt = value || '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnActionsComponent.prototype, "filterCriteria", {
            /**
             * Gets the value which filters the columns list.
             *
             * @example
             * ```typescript
             * let filterCriteria =  this.columnActions.filterCriteria;
             * ```
             */
            get: function () {
                return this._filterCriteria;
            },
            /**
             * Sets the value which filters the columns list.
             *
             * @example
             * ```html
             *  <igx-column-actions [filterCriteria]="'ID'"></igx-column-actions>
             * ```
             */
            set: function (value) {
                value = value || '';
                if (value !== this._filterCriteria) {
                    this._filterCriteria = value;
                    this.pipeTrigger++;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnActionsComponent.prototype, "columnDisplayOrder", {
            /**
             * Gets the display order of the columns.
             *
             * @example
             * ```typescript
             * let columnDisplayOrder = this.columnActions.columnDisplayOrder;
             * ```
             */
            get: function () {
                return this._columnDisplayOrder;
            },
            /**
             * Sets the display order of the columns.
             *
             * @example
             * ```typescript
             * this.columnActions.columnDisplayOrder = ColumnDisplayOrder.Alphabetical;
             * ```
             */
            set: function (value) {
                if (value && value !== this._columnDisplayOrder) {
                    this._columnDisplayOrder = value;
                    this.pipeTrigger++;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnActionsComponent.prototype, "uncheckAllText", {
            /**
             * Gets the text of the button that unchecks all columns.
             *
             * @remarks
             * If unset it is obtained from the IgxColumnActionsBased derived directive applied.
             * @example
             * ```typescript
             * let uncheckAllText = this.columnActions.uncheckAllText;
             * ```
             */
            get: function () {
                return this._uncheckAllText || this.actionsDirective.uncheckAllLabel;
            },
            /**
             * Sets the text of the button that unchecks all columns.
             *
             * @example
             * ```html
             * <igx-column-actions [uncheckAllText]="'Show All'"></igx-column-actions>
             * ```
             */
            set: function (value) {
                this._uncheckAllText = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnActionsComponent.prototype, "checkAllText", {
            /**
             * Gets the text of the button that checks all columns.
             *
             * @remarks
             * If unset it is obtained from the IgxColumnActionsBased derived directive applied.
             * @example
             * ```typescript
             * let uncheckAllText = this.columnActions.uncheckAllText;
             * ```
             */
            get: function () {
                return this._checkAllText || this.actionsDirective.checkAllLabel;
            },
            /**
             * Sets the text of the button that checks all columns.
             *
             * @remarks
             * If unset it is obtained from the IgxColumnActionsBased derived directive applied.
             * @example
             * ```html
             * <igx-column-actions [checkAllText]="'Hide All'"></igx-column-actions>
             * ```
             */
            set: function (value) {
                this._checkAllText = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnActionsComponent.prototype, "checkAllDisabled", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.actionsDirective.allUnchecked;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnActionsComponent.prototype, "uncheckAllDisabled", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.actionsDirective.allChecked;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnActionsComponent.prototype, "id", {
            /**
             * Gets/Sets the value of the `id` attribute.
             *
             * @remarks
             * If not provided it will be automatically generated.
             * @example
             * ```html
             * <igx-column-actions [id]="'igx-actions-1'"></igx-column-actions>
             * ```
             */
            get: function () {
                return this._id;
            },
            set: function (value) {
                this._id = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnActionsComponent.prototype, "titleID", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.id + '_title';
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxColumnActionsComponent.prototype.ngDoCheck = function () {
            var _a;
            if (this._differ) {
                var changes = this._differ.diff((_a = this.grid) === null || _a === void 0 ? void 0 : _a.columns);
                if (changes) {
                    this.pipeTrigger++;
                }
            }
        };
        /**
         * Unchecks all columns and performs the appropriate action.
         *
         * @example
         * ```typescript
         * this.columnActions.uncheckAllColumns();
         * ```
         */
        IgxColumnActionsComponent.prototype.uncheckAllColumns = function () {
            this.actionsDirective.uncheckAll();
        };
        /**
         * Checks all columns and performs the appropriate action.
         *
         * @example
         * ```typescript
         * this.columnActions.checkAllColumns();
         * ```
         */
        IgxColumnActionsComponent.prototype.checkAllColumns = function () {
            this.actionsDirective.checkAll();
        };
        /**
         * @hidden @internal
         */
        IgxColumnActionsComponent.prototype.toggleColumn = function (column) {
            this.actionsDirective.toggleColumn(column);
            this.onColumnToggled.emit({ column: column, checked: this.actionsDirective.columnChecked(column) });
        };
        return IgxColumnActionsComponent;
    }());
    IgxColumnActionsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-column-actions',
                    template: "<div class=\"igx-column-actions__header\">\n    <h4 [attr.id]='titleID' class=\"igx-column-actions__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-actions__header-input\" *ngIf=\"!hideFilter\">\n        <input igxInput\n            type=\"text\"\n            [attr.aria-describedby]='titleID'\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-actions__columns\" tabindex=\"0\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox\n        *ngFor=\"let column of grid?.columns\n            | columnActionEnabled:actionsDirective.actionEnabledColumnsFilter:pipeTrigger\n            | filterActionColumns:filterCriteria:pipeTrigger\n            | sortActionColumns:columnDisplayOrder:pipeTrigger;\"\n        class=\"igx-column-actions__columns-item\"\n        [readonly]=\"true\"\n        (click)=\"toggleColumn(column)\"\n        [checked]=\"actionsDirective.columnChecked(column)\"\n        [style.margin-left.px]=\"column.level * indentation\">\n        {{ column.header || column.field }}\n    </igx-checkbox>\n</div>\n\n<div class=\"igx-column-actions__buttons\">\n    <button igxButton igxRipple (click)=\"uncheckAllColumns()\" [disabled]=\"uncheckAllDisabled\">{{ uncheckAllText }}</button>\n    <button igxButton igxRipple (click)=\"checkAllColumns()\" [disabled]=\"checkAllDisabled\">{{ checkAllText }}</button>\n</div>\n"
                },] }
    ];
    IgxColumnActionsComponent.ctorParameters = function () { return [
        { type: i0.IterableDiffers }
    ]; };
    IgxColumnActionsComponent.propDecorators = {
        grid: [{ type: i0.Input }],
        indentation: [{ type: i0.Input }],
        cssClass: [{ type: i0.HostBinding, args: ['attr.class',] }],
        columnsAreaMaxHeight: [{ type: i0.Input }],
        hideFilter: [{ type: i0.Input }],
        columnItems: [{ type: i0.ViewChildren, args: [IgxCheckboxComponent,] }],
        title: [{ type: i0.Input }],
        onColumnToggled: [{ type: i0.Output }],
        columns: [{ type: i0.Input }],
        filterColumnsPrompt: [{ type: i0.Input }],
        filterCriteria: [{ type: i0.Input }],
        columnDisplayOrder: [{ type: i0.Input }],
        uncheckAllText: [{ type: i0.Input }],
        checkAllText: [{ type: i0.Input }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }]
    };
    __decorate([
        DeprecateProperty("Deprecated. Use 'grid' input instead.")
    ], IgxColumnActionsComponent.prototype, "columns", null);

    /**
     * @hidden
     * @internal
     */
    var IgxGridCellStyleClassesPipe = /** @class */ (function () {
        function IgxGridCellStyleClassesPipe() {
        }
        IgxGridCellStyleClassesPipe.prototype.transform = function (cssClasses, _, data, field, index, __) {
            var e_1, _c;
            if (!cssClasses) {
                return '';
            }
            var result = [];
            try {
                for (var _d = __values(Object.keys(cssClasses)), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var cssClass = _e.value;
                    var callbackOrValue = cssClasses[cssClass];
                    var apply = typeof callbackOrValue === 'function' ?
                        callbackOrValue(data, field, resolveNestedPath(data, field), index) : callbackOrValue;
                    if (apply) {
                        result.push(cssClass);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result.join(' ');
        };
        return IgxGridCellStyleClassesPipe;
    }());
    IgxGridCellStyleClassesPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'igxCellStyleClasses'
                },] }
    ];
    /**
     * @hidden
     * @internal
     */
    var IgxGridCellStylesPipe = /** @class */ (function () {
        function IgxGridCellStylesPipe() {
        }
        IgxGridCellStylesPipe.prototype.transform = function (styles, _, data, field, index, __) {
            var e_2, _c;
            var css = {};
            if (!styles) {
                return css;
            }
            try {
                for (var _d = __values(Object.keys(styles)), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var prop = _e.value;
                    var res = styles[prop];
                    css[prop] = typeof res === 'function' ? res(data, field, resolveNestedPath(data, field), index) : res;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return css;
        };
        return IgxGridCellStylesPipe;
    }());
    IgxGridCellStylesPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'igxCellStyles'
                },] }
    ];
    /**
     * @hidden
     * @internal
     */
    var IgxGridNotGroupedPipe = /** @class */ (function () {
        function IgxGridNotGroupedPipe() {
        }
        IgxGridNotGroupedPipe.prototype.transform = function (value) {
            return value.filter(function (item) { return !item.columnGroup; });
        };
        return IgxGridNotGroupedPipe;
    }());
    IgxGridNotGroupedPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'igxNotGrouped'
                },] }
    ];
    /**
     * @hidden
     * @internal
     */
    var IgxGridTopLevelColumns = /** @class */ (function () {
        function IgxGridTopLevelColumns() {
        }
        IgxGridTopLevelColumns.prototype.transform = function (value) {
            return value.filter(function (item) { return item.level === 0; });
        };
        return IgxGridTopLevelColumns;
    }());
    IgxGridTopLevelColumns.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'igxTopLevel'
                },] }
    ];
    /**
     * @hidden
     * @internal
     */
    var IgxGridFilterConditionPipe = /** @class */ (function () {
        function IgxGridFilterConditionPipe() {
        }
        IgxGridFilterConditionPipe.prototype.transform = function (value) {
            return value.split(/(?=[A-Z])/).join(' ');
        };
        return IgxGridFilterConditionPipe;
    }());
    IgxGridFilterConditionPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'filterCondition',
                    pure: true
                },] }
    ];
    /**
     * @hidden
     * @internal
     */
    var IgxGridTransactionPipe = /** @class */ (function () {
        function IgxGridTransactionPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridTransactionPipe.prototype.transform = function (collection, id, pipeTrigger) {
            var grid = this.gridAPI.grid;
            if (grid.transactions.enabled) {
                var result = DataUtil.mergeTransactions(cloneArray(collection), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
                return result;
            }
            return collection;
        };
        return IgxGridTransactionPipe;
    }());
    IgxGridTransactionPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'gridTransaction',
                    pure: true
                },] }
    ];
    IgxGridTransactionPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    /**
     * @hidden
     * @internal
     */
    var IgxGridPaginatorOptionsPipe = /** @class */ (function () {
        function IgxGridPaginatorOptionsPipe() {
        }
        IgxGridPaginatorOptionsPipe.prototype.transform = function (values) {
            return Array.from(new Set(__spread(values))).sort(function (a, b) { return a - b; });
        };
        return IgxGridPaginatorOptionsPipe;
    }());
    IgxGridPaginatorOptionsPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'paginatorOptions',
                    pure: true,
                },] }
    ];
    /**
     * @hidden
     * @internal
     */
    var IgxHasVisibleColumnsPipe = /** @class */ (function () {
        function IgxHasVisibleColumnsPipe() {
        }
        IgxHasVisibleColumnsPipe.prototype.transform = function (values, hasVisibleColumns) {
            if (!(values && values.length)) {
                return values;
            }
            return hasVisibleColumns ? values : [];
        };
        return IgxHasVisibleColumnsPipe;
    }());
    IgxHasVisibleColumnsPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'visibleColumns',
                    pure: true
                },] }
    ];
    /**
     * @hidden
     */
    var IgxGridRowPinningPipe = /** @class */ (function () {
        function IgxGridRowPinningPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridRowPinningPipe.prototype.transform = function (collection, id, isPinned, pipeTrigger) {
            if (isPinned === void 0) { isPinned = false; }
            var grid = this.gridAPI.grid;
            if (grid.hasPinnedRecords && isPinned) {
                var result = collection.filter(function (rec) { return grid.isRecordPinned(rec); });
                result.sort(function (rec1, rec2) { return grid.getInitialPinnedIndex(rec1) - grid.getInitialPinnedIndex(rec2); });
                return result;
            }
            grid.unpinnedRecords = collection;
            if (!grid.hasPinnedRecords) {
                grid.pinnedRecords = [];
                return isPinned ? [] : collection;
            }
            return collection.map(function (rec) { return grid.isRecordPinned(rec) ? { recordRef: rec, ghostRecord: true } : rec; });
        };
        return IgxGridRowPinningPipe;
    }());
    IgxGridRowPinningPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'gridRowPinning',
                    pure: true
                },] }
    ];
    IgxGridRowPinningPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    var IgxColumnActionEnabledPipe = /** @class */ (function () {
        function IgxColumnActionEnabledPipe(columnActions) {
            this.columnActions = columnActions;
        }
        IgxColumnActionEnabledPipe.prototype.transform = function (collection, actionFilter, pipeTrigger) {
            if (!collection) {
                return collection;
            }
            var copy = collection.slice(0);
            if (copy.length && copy[0].grid.hasColumnLayouts) {
                copy = copy.filter(function (c) { return c.columnLayout; });
            }
            if (actionFilter) {
                copy = copy.filter(actionFilter);
            }
            // Preserve the actionable collection for use in the component
            this.columnActions.actionableColumns = copy;
            return copy;
        };
        return IgxColumnActionEnabledPipe;
    }());
    IgxColumnActionEnabledPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'columnActionEnabled',
                    pure: true
                },] }
    ];
    IgxColumnActionEnabledPipe.ctorParameters = function () { return [
        { type: IgxColumnActionsComponent, decorators: [{ type: i0.Inject, args: [IgxColumnActionsComponent,] }] }
    ]; };
    var IgxFilterActionColumnsPipe = /** @class */ (function () {
        function IgxFilterActionColumnsPipe(columnActions) {
            this.columnActions = columnActions;
        }
        IgxFilterActionColumnsPipe.prototype.transform = function (collection, filterCriteria, pipeTrigger) {
            if (!collection) {
                return collection;
            }
            var copy = collection.slice(0);
            if (filterCriteria && filterCriteria.length > 0) {
                var filterFunc_1 = function (c) {
                    var _a, _b;
                    var filterText = c.header || c.field;
                    if (!filterText) {
                        return false;
                    }
                    return filterText.toLocaleLowerCase().indexOf(filterCriteria.toLocaleLowerCase()) >= 0 ||
                        ((_b = (_a = c.children) === null || _a === void 0 ? void 0 : _a.some(filterFunc_1)) !== null && _b !== void 0 ? _b : false);
                };
                copy = collection.filter(filterFunc_1);
            }
            // Preserve the filtered collection for use in the component
            this.columnActions.filteredColumns = copy;
            return copy;
        };
        return IgxFilterActionColumnsPipe;
    }());
    IgxFilterActionColumnsPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'filterActionColumns',
                    pure: true
                },] }
    ];
    IgxFilterActionColumnsPipe.ctorParameters = function () { return [
        { type: IgxColumnActionsComponent, decorators: [{ type: i0.Inject, args: [IgxColumnActionsComponent,] }] }
    ]; };
    var IgxSortActionColumnsPipe = /** @class */ (function () {
        function IgxSortActionColumnsPipe() {
        }
        IgxSortActionColumnsPipe.prototype.transform = function (collection, displayOrder, pipeTrigger) {
            if (displayOrder === ColumnDisplayOrder.Alphabetical) {
                return collection.sort(function (a, b) { return (a.header || a.field).localeCompare(b.header || b.field); });
            }
            return collection;
        };
        return IgxSortActionColumnsPipe;
    }());
    IgxSortActionColumnsPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'sortActionColumns',
                    pure: true
                },] }
    ];
    var IgxGridDataMapperPipe = /** @class */ (function () {
        function IgxGridDataMapperPipe() {
        }
        IgxGridDataMapperPipe.prototype.transform = function (data, field, _, val, isNestedPath) {
            return isNestedPath ? resolveNestedPath(data, field) : val;
        };
        return IgxGridDataMapperPipe;
    }());
    IgxGridDataMapperPipe.decorators = [
        { type: i0.Pipe, args: [{ name: 'dataMapper' },] }
    ];
    var IgxStringReplacePipe = /** @class */ (function () {
        function IgxStringReplacePipe() {
        }
        IgxStringReplacePipe.prototype.transform = function (value, search, replacement) {
            return value.replace(search, replacement);
        };
        return IgxStringReplacePipe;
    }());
    IgxStringReplacePipe.decorators = [
        { type: i0.Pipe, args: [{ name: 'igxStringReplace' },] }
    ];
    var IgxGridTransactionStatePipe = /** @class */ (function () {
        function IgxGridTransactionStatePipe() {
        }
        IgxGridTransactionStatePipe.prototype.transform = function (row_id, field, rowEditable, transactions, _, __, ___) {
            var _a;
            if (rowEditable) {
                var rowCurrentState = transactions.getAggregatedValue(row_id, false);
                if (rowCurrentState) {
                    var value = resolveNestedPath(rowCurrentState, field);
                    return value !== undefined && value !== null;
                }
            }
            else {
                var transaction = transactions.getState(row_id);
                var value = resolveNestedPath((_a = transaction === null || transaction === void 0 ? void 0 : transaction.value) !== null && _a !== void 0 ? _a : {}, field);
                return transaction && transaction.value && (value || value === 0 || value === false);
            }
        };
        return IgxGridTransactionStatePipe;
    }());
    IgxGridTransactionStatePipe.decorators = [
        { type: i0.Pipe, args: [{ name: 'transactionState' },] }
    ];
    var IgxColumnFormatterPipe = /** @class */ (function () {
        function IgxColumnFormatterPipe() {
        }
        IgxColumnFormatterPipe.prototype.transform = function (value, formatter) {
            return formatter(value);
        };
        return IgxColumnFormatterPipe;
    }());
    IgxColumnFormatterPipe.decorators = [
        { type: i0.Pipe, args: [{ name: 'columnFormatter' },] }
    ];
    var IgxGridAddRowPipe = /** @class */ (function () {
        function IgxGridAddRowPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridAddRowPipe.prototype.transform = function (collection, isPinned, pipeTrigger) {
            if (isPinned === void 0) { isPinned = false; }
            var grid = this.gridAPI.grid;
            if (!grid.rowEditable || !grid.addRowParent || grid.cancelAddMode || isPinned !== grid.addRowParent.isPinned) {
                return collection;
            }
            var copy = collection.slice(0);
            var parentIndex = grid.addRowParent.index;
            var row = grid.getEmptyRecordObjectFor(collection[parentIndex]);
            var rec = {
                recordRef: row,
                addRow: true
            };
            copy.splice(parentIndex + 1, 0, rec);
            if (isPinned) {
                grid.pinnedRecords = copy;
            }
            else {
                grid.unpinnedRecords = copy;
            }
            return copy;
        };
        return IgxGridAddRowPipe;
    }());
    IgxGridAddRowPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'gridAddRow',
                    pure: true
                },] }
    ];
    IgxGridAddRowPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };

    var IgxGridPipesModule = /** @class */ (function () {
        function IgxGridPipesModule() {
        }
        return IgxGridPipesModule;
    }());
    IgxGridPipesModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxGridFilterConditionPipe,
                        IgxGridTransactionPipe,
                        IgxGridNotGroupedPipe,
                        IgxGridTopLevelColumns,
                        IgxGridCellStylesPipe,
                        IgxGridCellStyleClassesPipe,
                        IgxGridPaginatorOptionsPipe,
                        IgxHasVisibleColumnsPipe,
                        IgxGridRowPinningPipe,
                        IgxColumnActionEnabledPipe,
                        IgxFilterActionColumnsPipe,
                        IgxSortActionColumnsPipe,
                        IgxGridDataMapperPipe,
                        IgxStringReplacePipe,
                        IgxGridTransactionStatePipe,
                        IgxGridAddRowPipe,
                        IgxColumnFormatterPipe
                    ],
                    exports: [
                        IgxGridFilterConditionPipe,
                        IgxGridTransactionPipe,
                        IgxGridNotGroupedPipe,
                        IgxGridTopLevelColumns,
                        IgxGridCellStylesPipe,
                        IgxGridCellStyleClassesPipe,
                        IgxGridPaginatorOptionsPipe,
                        IgxHasVisibleColumnsPipe,
                        IgxGridRowPinningPipe,
                        IgxColumnActionEnabledPipe,
                        IgxFilterActionColumnsPipe,
                        IgxSortActionColumnsPipe,
                        IgxGridDataMapperPipe,
                        IgxStringReplacePipe,
                        IgxGridTransactionStatePipe,
                        IgxGridAddRowPipe,
                        IgxColumnFormatterPipe
                    ],
                    imports: [
                        i2.CommonModule
                    ]
                },] }
    ];

    var IgxProcessBarTextTemplateDirective = /** @class */ (function () {
        function IgxProcessBarTextTemplateDirective(template) {
            this.template = template;
        }
        return IgxProcessBarTextTemplateDirective;
    }());
    IgxProcessBarTextTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxProcessBarText]'
                },] }
    ];
    IgxProcessBarTextTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    var IgxProgressBarGradientDirective = /** @class */ (function () {
        function IgxProgressBarGradientDirective(template) {
            this.template = template;
        }
        return IgxProgressBarGradientDirective;
    }());
    IgxProgressBarGradientDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxProgressBarGradient]'
                },] }
    ];
    IgxProgressBarGradientDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };

    /**
     * @hidden
     */
    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
    function DIR_DOCUMENT_FACTORY() {
        return i0.inject(i2.DOCUMENT);
    }
    /**
     * Injection token is used to inject the document into Directionality
     * which factory could be faked for testing purposes.
     *
     * We can't provide and mock the DOCUMENT token from platform-browser because configureTestingModule
     * allows override of the default providers, directive, pipes, modules of the test injector
     * which causes errors.
     *
     * @hidden
     */
    var DIR_DOCUMENT = new i0.InjectionToken('dir-doc', {
        providedIn: 'root',
        factory: DIR_DOCUMENT_FACTORY
    });
    /**
     * @hidden
     *
     * Bidirectional service that extracts the value of the direction attribute on the body or html elements.
     *
     * The dir attribute over the body element takes precedence.
     */
    var IgxDirectionality = /** @class */ (function () {
        function IgxDirectionality(document) {
            this._document = document;
            var bodyDir = this._document.body ? this._document.body.dir : null;
            var htmlDir = this._document.documentElement ? this._document.documentElement.dir : null;
            var extractedDir = bodyDir || htmlDir;
            this._dir = (extractedDir === 'ltr' || extractedDir === 'rtl') ? extractedDir : 'ltr';
        }
        Object.defineProperty(IgxDirectionality.prototype, "value", {
            get: function () {
                return this._dir;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDirectionality.prototype, "document", {
            get: function () {
                return this._document;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDirectionality.prototype, "rtl", {
            get: function () {
                return this._dir === 'rtl';
            },
            enumerable: false,
            configurable: true
        });
        return IgxDirectionality;
    }());
    IgxDirectionality.ɵprov = i0.ɵɵdefineInjectable({ factory: function IgxDirectionality_Factory() { return new IgxDirectionality(i0.ɵɵinject(DIR_DOCUMENT)); }, token: IgxDirectionality, providedIn: "root" });
    IgxDirectionality.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    IgxDirectionality.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [DIR_DOCUMENT,] }] }
    ]; };

    var ONE_PERCENT = 0.01;
    var MIN_VALUE = 0;
    var IgxTextAlign = mkenum({
        START: 'start',
        CENTER: 'center',
        END: 'end'
    });
    var IgxProgressType = mkenum({
        ERROR: 'error',
        INFO: 'info',
        WARNING: 'warning',
        SUCCESS: 'success'
    });
    /**
     * @hidden
     */
    var BaseProgressDirective = /** @class */ (function () {
        function BaseProgressDirective() {
            /**
             * An event, which is triggered after a progress is changed.
             * ```typescript
             * public progressChange(event) {
             *     alert("Progress made!");
             * }
             *  //...
             * ```
             * ```html
             * <igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
             * <igx-linear-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-linear-bar>
             * ```
             */
            this.onProgressChanged = new i0.EventEmitter();
            this._initValue = 0;
            this._contentInit = false;
            this._valueInPercent = MIN_VALUE;
            this._max = 100;
            this._value = MIN_VALUE;
            this._newVal = MIN_VALUE;
            this._animate = true;
            this.requestAnimationId = undefined;
        }
        Object.defineProperty(BaseProgressDirective.prototype, "step", {
            /**
             * Returns the value which update the progress indicator of the `progress bar`.
             * ```typescript
             *  @ViewChild("MyProgressBar")
             * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
             * public stepValue(event) {
             *     let step = this.progressBar.step;
             *     alert(step);
             * }
             * ```
             */
            get: function () {
                if (this._step) {
                    return this._step;
                }
                return this._max * ONE_PERCENT;
            },
            /**
             * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
             * ```html
             * <igx-linear-bar [max]="200" [value]="0" [step]="1"></igx-linear-bar>
             * <igx-circular-bar [max]="200" [value]="0" [step]="1"></igx-circular-bar>
             * ```
             */
            set: function (val) {
                this._step = Number(val);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseProgressDirective.prototype, "animate", {
            /**
             * Returns whether the `progress bar` has animation true/false.
             * ```typescript
             *  @ViewChild("MyProgressBar")
             * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
             * public animationStatus(event) {
             *     let animationStatus = this.progressBar.animate;
             *     alert(animationStatus);
             * }
             * ```
             */
            get: function () {
                return this._animate;
            },
            /**
             * Animating the progress. By default it is set to true.
             * ```html
             * <igx-linear-bar [animate]="false" [max]="200" [value]="50"></igx-linear-bar>
             * <igx-circular-bar [animate]="false" [max]="200" [value]="50"></igx-circular-bar>
             * ```
             */
            set: function (animate) {
                this._animate = animate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseProgressDirective.prototype, "max", {
            /**
             * Returns the the maximum progress value of the `progress bar`.
             * ```typescript
             *  @ViewChild("MyProgressBar")
             * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
             * public maxValue(event) {
             *     let max = this.progressBar.max;
             *     alert(max);
             * }
             * ```
             */
            get: function () {
                return this._max;
            },
            /**
             * Set maximum value that can be passed. By default it is set to 100.
             * ```html
             * <igx-linear-bar [max]="200" [value]="0"></igx-linear-bar>
             * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
             * ```
             */
            set: function (maxNum) {
                this._max = maxNum;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseProgressDirective.prototype, "valueInPercent", {
            /**
             * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
             * ```typescript
             *  @ViewChild("MyProgressBar")
             * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
             * public valuePercent(event){
             *     let percentValue = this.progressBar.valueInPercent;
             *     alert(percentValue);
             * }
             * ```
             */
            get: function () {
                return this._valueInPercent;
            },
            /**
             * Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
             * ```typescript
             *  @ViewChild("MyProgressBar")
             * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
             *     public setValue(event){
             *     this.progressBar.valueInPercent = 56;
             * }
             * ```
             */
            set: function (value) {
                this._valueInPercent = value;
            },
            enumerable: false,
            configurable: true
        });
        BaseProgressDirective.prototype.triggerProgressTransition = function (oldVal, newVal) {
            if (oldVal === newVal) {
                return;
            }
            var changedValues = {
                currentValue: newVal,
                previousValue: oldVal
            };
            var stepDirection = this.directionFlow(oldVal, newVal);
            if (this._animate) {
                this.runAnimation(newVal, stepDirection);
            }
            else {
                this.updateProgressDirectly(newVal);
            }
            this.onProgressChanged.emit(changedValues);
        };
        /**
         * @hidden
         */
        BaseProgressDirective.prototype.runAnimation = function (val, step) {
            var _this = this;
            this.requestAnimationId = requestAnimationFrame(function () { return _this.updateProgressSmoothly.call(_this, val, step); });
        };
        /**
         * @hidden
         */
        BaseProgressDirective.prototype.updateProgressSmoothly = function (val, step) {
            var _this = this;
            this._value = valueInRange(this._value, this._max) + step;
            var passedValue = toPercent(val, this._max);
            var progressValue = toPercent(this._value, this._max);
            if (this.valueInPercent === passedValue) {
                this.updateProgress(val);
                cancelAnimationFrame(this.requestAnimationId);
            }
            else if (this.isInLimitRange(progressValue, passedValue, step)) {
                this.updateProgress(val);
                cancelAnimationFrame(this.requestAnimationId);
            }
            else {
                this.valueInPercent = progressValue;
                this.requestAnimationId = requestAnimationFrame(function () { return _this.updateProgressSmoothly.call(_this, val, step); });
            }
        };
        /**
         * @hidden
         */
        BaseProgressDirective.prototype.updateProgressDirectly = function (val) {
            this._value = valueInRange(val, this._max);
            this.valueInPercent = toPercent(this._value, this._max);
        };
        /**
         * @hidden
         */
        BaseProgressDirective.prototype.directionFlow = function (currentValue, prevValue) {
            return currentValue < prevValue ? this.step : -this.step;
        };
        /**
         * @hidden
         */
        BaseProgressDirective.prototype.isInLimitRange = function (val, comparator, step) {
            return this.isExceedingUpperLimit(val, comparator, step) || this.isExceedingLowerLimit(val, comparator, step);
        };
        /**
         * @hidden
         *
         *
         * @param val
         * @param comparator
         * @param step
         */
        BaseProgressDirective.prototype.isExceedingUpperLimit = function (val, comparator, step) {
            return val > comparator && step > 0;
        };
        /**
         * @hidden
         *
         * @param val
         * @param comparator
         * @param step
         */
        BaseProgressDirective.prototype.isExceedingLowerLimit = function (val, comparator, step) {
            return val < comparator && step < 0;
        };
        /**
         * @hidden
         * @param step
         */
        BaseProgressDirective.prototype.updateProgress = function (val) {
            this._value = valueInRange(val, this._max);
            this.valueInPercent = toPercent(this._value, this._max);
        };
        return BaseProgressDirective;
    }());
    BaseProgressDirective.decorators = [
        { type: i0.Directive }
    ];
    BaseProgressDirective.propDecorators = {
        onProgressChanged: [{ type: i0.Output }],
        step: [{ type: i0.Input }],
        animate: [{ type: i0.Input }],
        max: [{ type: i0.HostBinding, args: ['attr.aria-valuemax',] }, { type: i0.Input }]
    };
    var NEXT_LINEAR_ID = 0;
    var NEXT_CIRCULAR_ID = 0;
    var NEXT_GRADIENT_ID = 0;
    var IgxLinearProgressBarComponent = /** @class */ (function (_super) {
        __extends(IgxLinearProgressBarComponent, _super);
        function IgxLinearProgressBarComponent() {
            var _this = _super.call(this) || this;
            _this.valueMin = 0;
            _this.cssClass = 'igx-linear-bar';
            /**
             * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
             * ```html
             * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
             * ```
             */
            _this.striped = false;
            /**
             * Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
             * ```html
             * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
             * ```
             */
            _this.indeterminate = false;
            /**
             * An @Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
             * ```html
             * <igx-linear-bar role="progressbar"></igx-linear-bar>
             * ```
             */
            _this.role = 'progressbar';
            /**
             * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
             * ```html
             * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
             * ```
             */
            _this.id = "igx-linear-bar-" + NEXT_LINEAR_ID++;
            /**
             * Set the position that defines where the text is aligned.
             * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
             * ```typescript
             * public positionCenter: IgxTextAlign;
             * public ngOnInit() {
             *     this.positionCenter = IgxTextAlign.CENTER;
             * }
             *  //...
             * ```
             *  ```html
             * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
             * ```
             */
            _this.textAlign = IgxTextAlign.START;
            /**
             * Set the text to be visible. By default it is set to true.
             * ```html
             *  <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
             * ```
             */
            _this.textVisibility = true;
            /**
             * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
             * ```html
             *  <igx-linear-bar type="error" [textTop]="true"></igx-linear-bar>
             * ```
             */
            _this.textTop = false;
            /**
             * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.
             * ```html
             * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="error"></igx-linear-bar>
             * ```
             */
            _this.type = 'default';
            return _this;
        }
        Object.defineProperty(IgxLinearProgressBarComponent.prototype, "value", {
            /**
             * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
             * ```typescript
             *  @ViewChild("MyProgressBar")
             * public progressBar: IgxLinearProgressBarComponent;
             * public getValue(event) {
             *     let value = this.progressBar.value;
             *     alert(value);
             * }
             * ```
             */
            get: function () {
                return this._value;
            },
            /**
             * Set value that indicates the current `IgxLinearProgressBarComponent` position.
             * ```html
             * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
             * ```
             */
            set: function (val) {
                var valInRange = valueInRange(val, this.max);
                if (isNaN(valInRange) || this._value === val || this.indeterminate) {
                    return;
                }
                if (this._contentInit) {
                    this.triggerProgressTransition(this._value, valInRange);
                }
                else {
                    this._initValue = valInRange;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxLinearProgressBarComponent.prototype, "error", {
            /**
             * @hidden
             */
            get: function () {
                return this.type === IgxProgressType.ERROR;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxLinearProgressBarComponent.prototype, "info", {
            /**
             * @hidden
             */
            get: function () {
                return this.type === IgxProgressType.INFO;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxLinearProgressBarComponent.prototype, "warning", {
            /**
             * @hidden
             */
            get: function () {
                return this.type === IgxProgressType.WARNING;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxLinearProgressBarComponent.prototype, "success", {
            /**
             * @hidden
             */
            get: function () {
                return this.type === IgxProgressType.SUCCESS;
            },
            enumerable: false,
            configurable: true
        });
        IgxLinearProgressBarComponent.prototype.ngAfterContentInit = function () {
            this.triggerProgressTransition(MIN_VALUE, this._initValue);
            this._contentInit = true;
        };
        return IgxLinearProgressBarComponent;
    }(BaseProgressDirective));
    IgxLinearProgressBarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-linear-bar',
                    template: "<div class=\"igx-linear-bar__base\">\n    <div class=\"igx-linear-bar__indicator\" [style.width.%]=\"valueInPercent\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n"
                },] }
    ];
    IgxLinearProgressBarComponent.ctorParameters = function () { return []; };
    IgxLinearProgressBarComponent.propDecorators = {
        valueMin: [{ type: i0.HostBinding, args: ['attr.aria-valuemin',] }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-linear-bar',] }],
        striped: [{ type: i0.HostBinding, args: ['class.igx-linear-bar--striped',] }, { type: i0.Input }],
        indeterminate: [{ type: i0.HostBinding, args: ['class.igx-linear-bar--indeterminate',] }, { type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }, { type: i0.Input }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        textAlign: [{ type: i0.Input }],
        textVisibility: [{ type: i0.Input }],
        textTop: [{ type: i0.Input }],
        text: [{ type: i0.Input }],
        type: [{ type: i0.Input }],
        value: [{ type: i0.HostBinding, args: ['attr.aria-valuenow',] }, { type: i0.Input }],
        error: [{ type: i0.HostBinding, args: ['class.igx-linear-bar--danger',] }],
        info: [{ type: i0.HostBinding, args: ['class.igx-linear-bar--info',] }],
        warning: [{ type: i0.HostBinding, args: ['class.igx-linear-bar--warning',] }],
        success: [{ type: i0.HostBinding, args: ['class.igx-linear-bar--success',] }]
    };
    var IgxCircularProgressBarComponent = /** @class */ (function (_super) {
        __extends(IgxCircularProgressBarComponent, _super);
        function IgxCircularProgressBarComponent(renderer, _directionality) {
            var _this = _super.call(this) || this;
            _this.renderer = renderer;
            _this._directionality = _directionality;
            /** @hidden */
            _this.cssClass = 'igx-circular-bar';
            /**
             * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
             * ```html
             * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
             * ```
             */
            _this.id = "igx-circular-bar-" + NEXT_CIRCULAR_ID++;
            /**
             * An @Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
             * ```html
             * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
             * ```
             */
            _this.indeterminate = false;
            /**
             * Sets the text visibility. By default it is set to true.
             * ```html
             * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
             * ```
             */
            _this.textVisibility = true;
            /**
             * @hidden
             */
            _this.gradientId = "igx-circular-gradient-" + NEXT_GRADIENT_ID++;
            _this._circleRadius = 46;
            _this._circumference = 2 * Math.PI * _this._circleRadius;
            _this.STROKE_OPACITY_DVIDER = 100;
            _this.STROKE_OPACITY_ADDITION = .2;
            return _this;
        }
        Object.defineProperty(IgxCircularProgressBarComponent.prototype, "context", {
            /**
             * @hidden
             */
            get: function () {
                return {
                    $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxCircularProgressBarComponent.prototype, "value", {
            /**
             * Returns value that indicates the current `IgxCircularProgressBarComponent` position.
             * ```typescript
             *  @ViewChild("MyProgressBar")
             * public progressBar: IgxCircularProgressBarComponent;
             * public getValue(event) {
             *     let value = this.progressBar.value;
             *     alert(value);
             * }
             * ```
             * ```html
             * <button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
             * ```
             */
            get: function () {
                return this._value;
            },
            /**
             * Set value that indicates the current `IgxCircularProgressBarComponent` position.
             * ```html
             * <igx-circular-bar [value]="50"></igx-circular-bar>
             * ```
             */
            set: function (val) {
                var valInRange = valueInRange(val, this.max);
                if (isNaN(valInRange) || this._value === val || this.indeterminate) {
                    return;
                }
                if (this._contentInit) {
                    this.triggerProgressTransition(this._value, valInRange);
                }
                else {
                    this._initValue = valInRange;
                }
            },
            enumerable: false,
            configurable: true
        });
        IgxCircularProgressBarComponent.prototype.ngAfterContentInit = function () {
            this.triggerProgressTransition(MIN_VALUE, this._initValue);
            this._contentInit = true;
        };
        IgxCircularProgressBarComponent.prototype.ngAfterViewInit = function () {
            this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke', "url(#" + this.gradientId + ")");
        };
        /**
         * @hidden
         */
        IgxCircularProgressBarComponent.prototype.updateProgressSmoothly = function (val, step) {
            // Set frames for the animation
            var FRAMES = [{
                    strokeDashoffset: this.getProgress(this._value),
                    strokeOpacity: (this._value / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
                }, {
                    strokeDashoffset: this.getProgress(this.valueInPercent),
                    strokeOpacity: (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
                }];
            this._svgCircle.nativeElement.animate(FRAMES, {
                easing: 'ease-out',
                fill: 'forwards'
            });
            _super.prototype.updateProgressSmoothly.call(this, val, step);
        };
        Object.defineProperty(IgxCircularProgressBarComponent.prototype, "textContent", {
            /**
             * @hidden
             */
            get: function () {
                return this.text;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxCircularProgressBarComponent.prototype.updateProgressDirectly = function (val) {
            _super.prototype.updateProgressDirectly.call(this, val);
            this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-dashoffset', this.getProgress(this.valueInPercent));
            this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-opacity', (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION);
        };
        IgxCircularProgressBarComponent.prototype.getProgress = function (percentage) {
            return this._directionality.rtl ?
                this._circumference + (percentage * this._circumference / 100) :
                this._circumference - (percentage * this._circumference / 100);
        };
        return IgxCircularProgressBarComponent;
    }(BaseProgressDirective));
    IgxCircularProgressBarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-circular-bar',
                    template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:text *ngIf=\"textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n        </ng-container>\n    </svg:text>\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultTextTemplate>\n        <svg:tspan class=\"igx-circular-bar__text\">\n            {{textContent ? textContent: valueInPercent + '%'}}\n        </svg:tspan>\n    </ng-template>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n"
                },] }
    ];
    IgxCircularProgressBarComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 },
        { type: IgxDirectionality }
    ]; };
    IgxCircularProgressBarComponent.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-circular-bar',] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        indeterminate: [{ type: i0.HostBinding, args: ['class.igx-circular-bar--indeterminate',] }, { type: i0.Input }],
        textVisibility: [{ type: i0.Input }],
        text: [{ type: i0.Input }],
        textTemplate: [{ type: i0.ContentChild, args: [IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective },] }],
        gradientTemplate: [{ type: i0.ContentChild, args: [IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective },] }],
        _svgCircle: [{ type: i0.ViewChild, args: ['circle', { static: true },] }],
        value: [{ type: i0.Input }]
    };
    var valueInRange = function (value, max, min) {
        if (min === void 0) { min = 0; }
        return Math.max(Math.min(value, max), min);
    };
    var toPercent = function (value, max) { return Math.floor(100 * value / max); };
    /**
     * @hidden
     */
    var IgxProgressBarModule = /** @class */ (function () {
        function IgxProgressBarModule() {
        }
        return IgxProgressBarModule;
    }());
    IgxProgressBarModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxLinearProgressBarComponent,
                        IgxCircularProgressBarComponent,
                        IgxProcessBarTextTemplateDirective,
                        IgxProgressBarGradientDirective,
                    ],
                    exports: [
                        IgxLinearProgressBarComponent,
                        IgxCircularProgressBarComponent,
                        IgxProcessBarTextTemplateDirective,
                        IgxProgressBarGradientDirective,
                    ],
                    imports: [i2.CommonModule]
                },] }
    ];

    /**
     * @hidden
     */
    var IgxGridExcelStyleFilteringModule = /** @class */ (function () {
        function IgxGridExcelStyleFilteringModule() {
        }
        return IgxGridExcelStyleFilteringModule;
    }());
    IgxGridExcelStyleFilteringModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxGridExcelStyleFilteringComponent,
                        IgxExcelStyleHeaderComponent,
                        IgxExcelStyleSortingComponent,
                        IgxExcelStylePinningComponent,
                        IgxExcelStyleHidingComponent,
                        IgxExcelStyleSelectingComponent,
                        IgxExcelStyleClearFiltersComponent,
                        IgxExcelStyleConditionalFilterComponent,
                        IgxExcelStyleMovingComponent,
                        IgxExcelStyleSearchComponent,
                        IgxExcelStyleCustomDialogComponent,
                        IgxExcelStyleDefaultExpressionComponent,
                        IgxExcelStyleDateExpressionComponent,
                        IgxExcelStyleColumnOperationsTemplateDirective,
                        IgxExcelStyleFilterOperationsTemplateDirective,
                        IgxExcelStyleLoadingValuesTemplateDirective
                    ],
                    exports: [
                        IgxGridExcelStyleFilteringComponent,
                        IgxExcelStyleColumnOperationsTemplateDirective,
                        IgxExcelStyleFilterOperationsTemplateDirective,
                        IgxExcelStyleLoadingValuesTemplateDirective,
                        IgxExcelStyleDateExpressionComponent,
                        IgxExcelStyleHeaderComponent,
                        IgxExcelStyleSortingComponent,
                        IgxExcelStylePinningComponent,
                        IgxExcelStyleHidingComponent,
                        IgxExcelStyleSelectingComponent,
                        IgxExcelStyleClearFiltersComponent,
                        IgxExcelStyleConditionalFilterComponent,
                        IgxExcelStyleMovingComponent,
                        IgxExcelStyleSearchComponent,
                        IgxExcelStyleHeaderComponent
                    ],
                    imports: [
                        i2.CommonModule,
                        forms.FormsModule,
                        IgxGridPipesModule,
                        IgxButtonModule,
                        IgxButtonGroupModule,
                        IgxDatePickerModule,
                        IgxIconModule,
                        IgxRippleModule,
                        IgxInputGroupModule,
                        IgxDropDownModule,
                        IgxForOfModule,
                        IgxCheckboxModule,
                        IgxFilterModule,
                        IgxToggleModule,
                        IgxListModule,
                        IgxProgressBarModule,
                        IgxSelectModule,
                    ],
                    entryComponents: [
                        IgxGridExcelStyleFilteringComponent
                    ],
                    providers: [
                        IgxSelectionAPIService
                    ]
                },] }
    ];

    var IgxGridSelectionModule = /** @class */ (function () {
        function IgxGridSelectionModule() {
        }
        return IgxGridSelectionModule;
    }());
    IgxGridSelectionModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxRowSelectorDirective,
                        IgxGroupByRowSelectorDirective,
                        IgxHeadSelectorDirective,
                        IgxGridDragSelectDirective
                    ],
                    exports: [
                        IgxRowSelectorDirective,
                        IgxGroupByRowSelectorDirective,
                        IgxHeadSelectorDirective,
                        IgxGridDragSelectDirective
                    ]
                },] }
    ];

    /**
     * @hidden
     * @internal
     */
    var IgxResizeHandleDirective = /** @class */ (function () {
        function IgxResizeHandleDirective(zone, element, colResizingService) {
            this.zone = zone;
            this.element = element;
            this.colResizingService = colResizingService;
            /**
             * @hidden
             */
            this._dblClick = false;
            /**
             * @hidden
             */
            this.destroy$ = new rxjs.Subject();
            this.DEBOUNCE_TIME = 200;
        }
        /**
         * @hidden
         */
        IgxResizeHandleDirective.prototype.onMouseOver = function () {
            this.colResizingService.resizeCursor = 'col-resize';
        };
        /**
         * @hidden
         */
        IgxResizeHandleDirective.prototype.onDoubleClick = function () {
            this._dblClick = true;
            this.colResizingService.column = this.column;
            this.colResizingService.autosizeColumnOnDblClick();
        };
        /**
         * @hidden
         */
        IgxResizeHandleDirective.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden
         */
        IgxResizeHandleDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (!this.column.columnGroup && this.column.resizable) {
                this.zone.runOutsideAngular(function () {
                    rxjs.fromEvent(_this.element.nativeElement, 'mousedown').pipe(operators.debounceTime(_this.DEBOUNCE_TIME), operators.takeUntil(_this.destroy$)).subscribe(function (event) {
                        if (_this._dblClick) {
                            _this._dblClick = false;
                            return;
                        }
                        if (event.button === 0) {
                            _this._onResizeAreaMouseDown(event);
                            _this.column.grid.resizeLine.resizer.onMousedown(event);
                        }
                    });
                });
                rxjs.fromEvent(this.element.nativeElement, 'mouseup').pipe(operators.debounceTime(this.DEBOUNCE_TIME), operators.takeUntil(this.destroy$)).subscribe(function () {
                    _this.colResizingService.isColumnResizing = false;
                    _this.colResizingService.showResizer = false;
                    _this.column.grid.cdr.detectChanges();
                });
            }
        };
        /**
         * @hidden
         */
        IgxResizeHandleDirective.prototype._onResizeAreaMouseDown = function (event) {
            this.colResizingService.column = this.column;
            this.colResizingService.isColumnResizing = true;
            this.colResizingService.startResizePos = event.clientX;
            this.colResizingService.showResizer = true;
            this.column.grid.cdr.detectChanges();
        };
        return IgxResizeHandleDirective;
    }());
    IgxResizeHandleDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxResizeHandle]'
                },] }
    ];
    IgxResizeHandleDirective.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: i0.ElementRef },
        { type: IgxColumnResizingService }
    ]; };
    IgxResizeHandleDirective.propDecorators = {
        column: [{ type: i0.Input, args: ['igxResizeHandle',] }],
        onMouseOver: [{ type: i0.HostListener, args: ['mouseover',] }],
        onDoubleClick: [{ type: i0.HostListener, args: ['dblclick',] }]
    };

    var IgxGridResizingModule = /** @class */ (function () {
        function IgxGridResizingModule() {
        }
        return IgxGridResizingModule;
    }());
    IgxGridResizingModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxGridColumnResizerComponent,
                        IgxResizeHandleDirective,
                        IgxColumnResizerDirective
                    ],
                    imports: [
                        i2.CommonModule
                    ],
                    exports: [
                        IgxGridColumnResizerComponent,
                        IgxResizeHandleDirective,
                        IgxColumnResizerDirective
                    ],
                    providers: [
                        IgxColumnResizingService
                    ]
                },] }
    ];

    var IgxColumnMovingDropDirective = /** @class */ (function (_super) {
        __extends(IgxColumnMovingDropDirective, _super);
        function IgxColumnMovingDropDirective(elementRef, renderer, zone, cms) {
            var _this = _super.call(this, elementRef, renderer, zone) || this;
            _this.elementRef = elementRef;
            _this.renderer = renderer;
            _this.zone = zone;
            _this.cms = cms;
            _this._dropIndicator = null;
            _this._lastDropIndicator = null;
            _this._dragLeave = new rxjs.Subject();
            _this._dropIndicatorClass = 'igx-grid__th-drop-indicator--active';
            return _this;
        }
        Object.defineProperty(IgxColumnMovingDropDirective.prototype, "data", {
            set: function (val) {
                if (val instanceof IgxColumnComponent) {
                    this._column = val;
                }
                if (val instanceof IgxGridForOfDirective) {
                    this._hVirtDir = val;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnMovingDropDirective.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnMovingDropDirective.prototype, "isDropTarget", {
            get: function () {
                return this._column && this._column.grid.hasMovableColumns && this.cms.column.movable &&
                    ((!this._column.pinned && this.cms.column.disablePinning) || !this.cms.column.disablePinning);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnMovingDropDirective.prototype, "horizontalScroll", {
            get: function () {
                if (this._hVirtDir) {
                    return this._hVirtDir;
                }
            },
            enumerable: false,
            configurable: true
        });
        IgxColumnMovingDropDirective.prototype.ngOnDestroy = function () {
            this._dragLeave.next(true);
            this._dragLeave.complete();
        };
        IgxColumnMovingDropDirective.prototype.onDragOver = function (event) {
            var drag = event.detail.owner;
            if (!(drag instanceof IgxColumnMovingDragDirective)) {
                return;
            }
            if (this.isDropTarget &&
                this.cms.column !== this.column &&
                this.cms.column.level === this.column.level &&
                this.cms.column.parent === this.column.parent) {
                if (this._lastDropIndicator) {
                    this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
                }
                var clientRect = this.elementRef.nativeElement.getBoundingClientRect();
                var pos = clientRect.left + clientRect.width / 2;
                var parent = this.elementRef.nativeElement.parentElement;
                if (event.detail.pageX < pos) {
                    this._dropPos = DropPosition.BeforeDropTarget;
                    this._lastDropIndicator = this._dropIndicator = parent.firstElementChild;
                }
                else {
                    this._dropPos = DropPosition.AfterDropTarget;
                    this._lastDropIndicator = this._dropIndicator = parent.lastElementChild;
                }
                if (this.cms.icon.innerText !== 'block') {
                    this.renderer.addClass(this._dropIndicator, this._dropIndicatorClass);
                }
            }
        };
        IgxColumnMovingDropDirective.prototype.onDragEnter = function (event) {
            var _this = this;
            var drag = event.detail.owner;
            if (!(drag instanceof IgxColumnMovingDragDirective)) {
                return;
            }
            if (this.column && this.cms.column.grid.id !== this.column.grid.id) {
                this.cms.icon.innerText = 'block';
                return;
            }
            if (this.isDropTarget &&
                this.cms.column !== this.column &&
                this.cms.column.level === this.column.level &&
                this.cms.column.parent === this.column.parent) {
                if (!this.column.pinned || (this.column.pinned && this.cms.column.pinned)) {
                    this.cms.icon.innerText = 'swap_horiz';
                }
                this.cms.icon.innerText = 'lock';
            }
            else {
                this.cms.icon.innerText = 'block';
            }
            if (this.horizontalScroll) {
                this.cms.icon.innerText = event.target.id === 'right' ? 'arrow_forward' : 'arrow_back';
                rxjs.interval(100).pipe(operators.takeUntil(this._dragLeave)).subscribe(function () {
                    if (event.target.id === 'right') {
                        _this.horizontalScroll.scrollPosition += 15;
                    }
                    else {
                        _this.horizontalScroll.scrollPosition -= 15;
                    }
                });
            }
        };
        IgxColumnMovingDropDirective.prototype.onDragLeave = function (event) {
            var drag = event.detail.owner;
            if (!(drag instanceof IgxColumnMovingDragDirective)) {
                return;
            }
            this.cms.icon.innerText = 'block';
            if (this._dropIndicator) {
                this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
            }
            if (this.horizontalScroll) {
                this._dragLeave.next(true);
            }
        };
        IgxColumnMovingDropDirective.prototype.onDragDrop = function (event) {
            event.preventDefault();
            var drag = event.detail.owner;
            if (!(drag instanceof IgxColumnMovingDragDirective)) {
                return;
            }
            if (this.column && (this.cms.column.grid.id !== this.column.grid.id)) {
                return;
            }
            if (this.horizontalScroll) {
                this._dragLeave.next(true);
            }
            if (this.isDropTarget) {
                var args = {
                    source: this.cms.column,
                    target: this.column
                };
                this.column.grid.moveColumn(this.cms.column, this.column, this._dropPos);
                this.column.grid.draggedColumn = null;
                this.column.grid.cdr.detectChanges();
            }
        };
        return IgxColumnMovingDropDirective;
    }(IgxDropDirective));
    IgxColumnMovingDropDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxColumnMovingDrop]'
                },] }
    ];
    IgxColumnMovingDropDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: i0.NgZone },
        { type: IgxColumnMovingService }
    ]; };
    IgxColumnMovingDropDirective.propDecorators = {
        data: [{ type: i0.Input, args: ['igxColumnMovingDrop',] }]
    };

    var IgxColumnMovingModule = /** @class */ (function () {
        function IgxColumnMovingModule() {
        }
        return IgxColumnMovingModule;
    }());
    IgxColumnMovingModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxColumnMovingDropDirective,
                        IgxColumnMovingDragDirective
                    ],
                    exports: [
                        IgxColumnMovingDropDirective,
                        IgxColumnMovingDragDirective
                    ]
                },] }
    ];

    var IgxGridAPIService = /** @class */ (function (_super) {
        __extends(IgxGridAPIService, _super);
        function IgxGridAPIService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxGridAPIService.prototype.groupBy = function (expression) {
            var groupingState = cloneArray(this.grid.groupingExpressions);
            var sortingState = cloneArray(this.grid.sortingExpressions);
            this.prepare_sorting_expression([sortingState, groupingState], expression);
            this.grid.groupingExpressions = groupingState;
            this.arrange_sorting_expressions();
        };
        IgxGridAPIService.prototype.groupBy_multiple = function (expressions) {
            var e_1, _a;
            var groupingState = cloneArray(this.grid.groupingExpressions);
            var sortingState = cloneArray(this.grid.sortingExpressions);
            try {
                for (var expressions_1 = __values(expressions), expressions_1_1 = expressions_1.next(); !expressions_1_1.done; expressions_1_1 = expressions_1.next()) {
                    var each = expressions_1_1.value;
                    this.prepare_sorting_expression([sortingState, groupingState], each);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (expressions_1_1 && !expressions_1_1.done && (_a = expressions_1.return)) _a.call(expressions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.grid.groupingExpressions = groupingState;
            this.arrange_sorting_expressions();
        };
        IgxGridAPIService.prototype.clear_groupby = function (name) {
            var e_2, _a;
            var _this = this;
            var groupingState = cloneArray(this.grid.groupingExpressions);
            var sortingState = cloneArray(this.grid.sortingExpressions);
            if (name) {
                var names_1 = typeof name === 'string' ? [name] : name;
                var groupedCols = groupingState.filter(function (state) { return names_1.indexOf(state.fieldName) < 0; });
                var newSortingExpr = sortingState.filter(function (state) { return names_1.indexOf(state.fieldName) < 0; });
                this.grid.groupingExpressions = groupedCols;
                this.grid.sortingExpressions = newSortingExpr;
                names_1.forEach(function (colName) {
                    var grExprIndex = groupingState.findIndex(function (exp) { return exp.fieldName === colName; });
                    var grpExpandState = _this.grid.groupingExpansionState;
                    /* remove expansion states related to the cleared group
                       and all with deeper hierarchy than the cleared group */
                    var newExpandState = grpExpandState.filter(function (val) { return val.hierarchy && val.hierarchy.length <= grExprIndex; });
                    /* Do not set the new instance produced by filter
                        when there are no differences between expansion states */
                    if (newExpandState.length !== grpExpandState.length) {
                        _this.grid.groupingExpansionState = newExpandState;
                    }
                });
            }
            else {
                // clear all
                this.grid.groupingExpressions = [];
                this.grid.groupingExpansionState = [];
                var _loop_1 = function (grExpr) {
                    var sortExprIndex = sortingState.findIndex(function (exp) { return exp.fieldName === grExpr.fieldName; });
                    if (sortExprIndex > -1) {
                        sortingState.splice(sortExprIndex, 1);
                    }
                };
                try {
                    for (var groupingState_1 = __values(groupingState), groupingState_1_1 = groupingState_1.next(); !groupingState_1_1.done; groupingState_1_1 = groupingState_1.next()) {
                        var grExpr = groupingState_1_1.value;
                        _loop_1(grExpr);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (groupingState_1_1 && !groupingState_1_1.done && (_a = groupingState_1.return)) _a.call(groupingState_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                this.grid.sortingExpressions = sortingState;
            }
        };
        IgxGridAPIService.prototype.groupBy_get_expanded_for_group = function (groupRow) {
            var grState = this.grid.groupingExpansionState;
            var hierarchy = DataUtil.getHierarchy(groupRow);
            return grState.find(function (state) { return DataUtil.isHierarchyMatch(state.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy); });
        };
        IgxGridAPIService.prototype.groupBy_is_row_in_group = function (groupRow, rowID) {
            var grid = this.grid;
            var rowInGroup = false;
            groupRow.records.forEach(function (row) {
                if (grid.primaryKey ? row[grid.primaryKey] === rowID : row === rowID) {
                    rowInGroup = true;
                }
            });
            return rowInGroup;
        };
        IgxGridAPIService.prototype.groupBy_toggle_group = function (groupRow) {
            var grid = this.grid;
            if (grid.crudService.cellInEditMode) {
                grid.endEdit(false);
            }
            var expansionState = grid.groupingExpansionState;
            var state = this.groupBy_get_expanded_for_group(groupRow);
            if (state) {
                state.expanded = !state.expanded;
            }
            else {
                expansionState.push({
                    expanded: !grid.groupsExpanded,
                    hierarchy: DataUtil.getHierarchy(groupRow)
                });
            }
            this.grid.groupingExpansionState = __spread(expansionState);
            if (grid.rowEditable) {
                grid.repositionRowEditingOverlay(grid.rowInEditMode);
            }
        };
        IgxGridAPIService.prototype.groupBy_fully_expand_group = function (groupRow) {
            var state = this.groupBy_get_expanded_for_group(groupRow);
            var expanded = state ? state.expanded : this.grid.groupsExpanded;
            if (!expanded) {
                this.groupBy_toggle_group(groupRow);
            }
            if (groupRow.groupParent) {
                this.groupBy_fully_expand_group(groupRow.groupParent);
            }
        };
        IgxGridAPIService.prototype.groupBy_select_all_rows_in_group = function (groupRow, clearPrevSelection) {
            var _this = this;
            this.grid.selectionService.selectRowsWithNoEvent(this.grid.primaryKey ?
                groupRow.records.map(function (x) { return x[_this.grid.primaryKey]; }) : groupRow.records, clearPrevSelection);
        };
        IgxGridAPIService.prototype.groupBy_deselect_all_rows_in_group = function (groupRow) {
            var _this = this;
            this.grid.selectionService.deselectRowsWithNoEvent(this.grid.primaryKey ?
                groupRow.records.map(function (x) { return x[_this.grid.primaryKey]; }) : groupRow.records);
        };
        IgxGridAPIService.prototype.arrange_sorting_expressions = function () {
            var groupingState = this.grid.groupingExpressions;
            this.grid.sortingExpressions.sort(function (a, b) {
                var groupExprA = groupingState.find(function (expr) { return expr.fieldName === a.fieldName; });
                var groupExprB = groupingState.find(function (expr) { return expr.fieldName === b.fieldName; });
                if (groupExprA && groupExprB) {
                    return groupingState.indexOf(groupExprA) > groupingState.indexOf(groupExprB) ? 1 : -1;
                }
                else if (groupExprA) {
                    return -1;
                }
                else if (groupExprB) {
                    return 1;
                }
                else {
                    return 0;
                }
            });
        };
        IgxGridAPIService.prototype.get_groupBy_record_id = function (gRow) {
            var recordId = '{ ';
            var hierrarchy = DataUtil.getHierarchy(gRow);
            for (var i = 0; i < hierrarchy.length; i++) {
                var groupByKey = hierrarchy[i];
                recordId += "'" + groupByKey.fieldName + "': '" + groupByKey.value + "'";
                if (i < hierrarchy.length - 1) {
                    recordId += ', ';
                }
            }
            recordId += ' }';
            return recordId;
        };
        IgxGridAPIService.prototype.remove_grouping_expression = function (fieldName) {
            var groupingExpressions = this.grid.groupingExpressions;
            var index = groupingExpressions.findIndex(function (expr) { return expr.fieldName === fieldName; });
            if (index !== -1) {
                groupingExpressions.splice(index, 1);
            }
        };
        return IgxGridAPIService;
    }(GridBaseAPIService));
    IgxGridAPIService.decorators = [
        { type: i0.Injectable }
    ];

    var IgxGridGroupByRowComponent = /** @class */ (function () {
        function IgxGridGroupByRowComponent(gridAPI, gridSelection, element, cdr, filteringService) {
            var _this = this;
            this.gridAPI = gridAPI;
            this.gridSelection = gridSelection;
            this.element = element;
            this.cdr = cdr;
            this.filteringService = filteringService;
            /**
             * @hidden
             */
            this.isFocused = false;
            /**
             * @hidden
             */
            this.destroy$ = new rxjs.Subject();
            /**
             * @hidden
             */
            this.defaultCssClass = 'igx-grid__group-row';
            /**
             * @hidden
             */
            this.paddingIndentationCssClass = 'igx-grid__group-row--padding-level';
            this.gridSelection.selectedRowsChange.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                _this.cdr.markForCheck();
            });
        }
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "focused", {
            /**
             * Returns whether the row is focused.
             * ```
             * let gridRowFocused = this.grid1.rowList.first.focused;
             * ```
             */
            get: function () {
                return this.isActive();
            },
            enumerable: false,
            configurable: true
        });
        IgxGridGroupByRowComponent.prototype.activate = function () {
            this.grid.navigation.setActiveNode({ row: this.index });
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridGroupByRowComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next();
            this.destroy$.complete();
        };
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "expanded", {
            /**
             * Returns whether the group row is expanded.
             * ```typescript
             * const groupRowExpanded = this.grid1.rowList.first.expanded;
             * ```
             */
            get: function () {
                return this.grid.isExpandedGroup(this.groupRow);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "describedBy", {
            /**
             * @hidden
             */
            get: function () {
                var grRowExpr = this.groupRow.expression !== undefined ? this.groupRow.expression.fieldName : '';
                return this.gridID + '_' + grRowExpr;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "dataRowIndex", {
            get: function () {
                return this.index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "nativeElement", {
            /**
             * Returns a reference to the underlying HTML element.
             * ```typescript
             * const groupRowElement = this.nativeElement;
             * ```
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "attrCellID", {
            get: function () {
                return this.gridID + "_" + this.index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "styleClasses", {
            /**
             * Returns the style classes applied to the group rows.
             * ```typescript
             * const groupCssStyles = this.grid1.rowList.first.styleClasses;
             * ```
             */
            get: function () {
                return this.defaultCssClass + " " + (this.paddingIndentationCssClass + "-") + this.groupRow.level +
                    (this.isActive() ? " " + this.defaultCssClass + "--active" : '');
            },
            enumerable: false,
            configurable: true
        });
        IgxGridGroupByRowComponent.prototype.isActive = function () {
            return this.grid.navigation.activeNode ? this.grid.navigation.activeNode.row === this.index : false;
        };
        /**
         * @hidden @internal
         */
        IgxGridGroupByRowComponent.prototype.getRowID = function (rowData) {
            return this.grid.primaryKey ? rowData[this.grid.primaryKey] : rowData;
        };
        /**
         * @hidden @internal
         */
        IgxGridGroupByRowComponent.prototype.onGroupSelectorClick = function (event) {
            var _this = this;
            if (!this.grid.isMultiRowSelectionEnabled) {
                return;
            }
            event.stopPropagation();
            if (this.areAllRowsInTheGroupSelected) {
                this.groupRow.records.forEach(function (row) {
                    _this.gridSelection.deselectRow(_this.getRowID(row), event);
                });
            }
            else {
                this.groupRow.records.forEach(function (row) {
                    _this.gridSelection.selectRowById(_this.getRowID(row), false, event);
                });
            }
        };
        /**
         * Toggles the group row.
         * ```typescript
         * this.grid1.rowList.first.toggle()
         * ```
         */
        IgxGridGroupByRowComponent.prototype.toggle = function () {
            this.grid.toggleGroup(this.groupRow);
        };
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "iconTemplate", {
            get: function () {
                if (this.expanded) {
                    return this.grid.rowExpandedIndicatorTemplate || this.defaultGroupByExpandedTemplate;
                }
                else {
                    return this.grid.rowCollapsedIndicatorTemplate || this.defaultGroupByCollapsedTemplate;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "selectionNode", {
            get: function () {
                return {
                    row: this.index,
                    column: this.gridSelection.activeElement ? this.gridSelection.activeElement.column : 0
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "grid", {
            /**
             * Returns a reference to the `IgxGridComponent` the `IgxGridGroupByRowComponent` belongs to.
             * ```typescript
             * this.grid1.rowList.first.grid;
             * ```
             */
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "dataType", {
            /**
             * @hidden
             */
            get: function () {
                var column = this.groupRow.column;
                return (column && column.dataType) || DataType.String;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "areAllRowsInTheGroupSelected", {
            /**
             * @hidden @internal
             */
            get: function () {
                var _this = this;
                return this.groupRow.records.every(function (x) { return _this.gridSelection.isRowSelected(_this.getRowID(x)); });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "selectedRowsInTheGroup", {
            /**
             * @hidden @internal
             */
            get: function () {
                var _this = this;
                return this.groupRow.records.filter(function (rowID) { return _this.gridSelection.filteredSelectedRowIds.indexOf(_this.getRowID(rowID)) > -1; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "groupByRowCheckboxIndeterminateState", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this.selectedRowsInTheGroup.length > 0) {
                    return !this.areAllRowsInTheGroupSelected;
                }
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "groupByRowSelectorBaseAriaLabel", {
            /**
             * @hidden @internal
             */
            get: function () {
                var ariaLabel = this.areAllRowsInTheGroupSelected ?
                    this.grid.resourceStrings.igx_grid_groupByArea_deselect_message : this.grid.resourceStrings.igx_grid_groupByArea_select_message;
                return ariaLabel.replace('{0}', this.groupRow.expression.fieldName).replace('{1}', this.groupRow.value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "showRowSelectors", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.grid.rowSelection !== GridSelectionMode.none && !this.hideGroupRowSelectors;
            },
            enumerable: false,
            configurable: true
        });
        return IgxGridGroupByRowComponent;
    }());
    IgxGridGroupByRowComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-groupby-row',
                    template: "<ng-container #defaultGroupRow>\n\n    <ng-container *ngIf=\"rowDraggable\">\n        <div class=\"igx-grid__drag-indicator igx-grid__tr-action\">\n            <igx-icon [style.visibility]=\"'hidden'\">drag_indicator</igx-icon>\n        </div>\n    </ng-container>\n\n    <ng-container *ngIf=\"showRowSelectors\">\n        <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" style=\"background: none;\" (pointerdown)=\"$event.preventDefault()\"\n            (click)=\"onGroupSelectorClick($event)\">\n            <ng-template #groupByRowSelector *ngTemplateOutlet=\"\n                this.grid.groupByRowSelectorTemplate ? this.grid.groupByRowSelectorTemplate : groupByRowSelectorBaseTemplate;\n                context: { $implicit: {\n                    selectedCount: selectedRowsInTheGroup.length,\n                    totalCount: this.groupRow.records.length,\n                    groupRow: this.groupRow }}\">\n            </ng-template>\n        </div>\n    </ng-container>\n\n    <div (click)=\"toggle()\" class=\"igx-grid__grouping-indicator\">\n        <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n        </ng-container>\n    </div>\n\n    <div class=\"igx-grid__group-content\" #groupContent>\n        <ng-container\n            *ngTemplateOutlet=\"grid.groupRowTemplate ? grid.groupRowTemplate : defaultGroupByTemplate; context: { $implicit: groupRow }\">\n        </ng-container>\n    </div>\n\n    <ng-template #defaultGroupByExpandedTemplate>\n        <igx-icon>expand_more</igx-icon>\n    </ng-template>\n\n    <ng-template #defaultGroupByCollapsedTemplate>\n        <igx-icon>chevron_right</igx-icon>\n    </ng-template>\n\n\n    <ng-template #defaultGroupByTemplate>\n        <div class=\"igx-group-label\">\n            <igx-icon class=\"igx-group-label__icon\">group_work</igx-icon>\n            <span class=\"igx-group-label__column-name\">\n                {{ groupRow.column && groupRow.column.header ?\n                groupRow.column.header :\n                (groupRow.expression ? groupRow.expression.fieldName : '') }}:\n            </span>\n\n            <ng-container *ngIf=\"dataType === 'boolean' || dataType === 'string'; else default\">\n                <span class=\"igx-group-label__text\">{{ groupRow.value }}</span>\n            </ng-container>\n            <ng-template #default>\n                <ng-container *ngIf=\"dataType === 'number'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | number }}</span>\n                </ng-container>\n                <ng-container *ngIf=\"dataType === 'date'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | date }}</span>\n                </ng-container>\n            </ng-template>\n\n            <igx-badge [value]=\"groupRow.records ? groupRow.records.length : 0\" class='igx-group-label__count-badge'>\n            </igx-badge>\n        </div>\n    </ng-template>\n    <ng-template #groupByRowSelectorBaseTemplate let-context>\n        <div class=\"igx-grid__cbx-padding\">\n            <igx-checkbox [tabindex]=\"-1\" [readonly]=\"true\" [checked]=\"areAllRowsInTheGroupSelected\"\n                disableRipple=\"true\" [indeterminate]=\"groupByRowCheckboxIndeterminateState\"\n                [disabled]=\"this.grid.rowSelection === 'single'\" [aria-label]=\"groupByRowSelectorBaseAriaLabel\"\n                #groupByRowCheckbox>\n            </igx-checkbox>\n        </div>\n    </ng-template>\n</ng-container>\n"
                },] }
    ];
    IgxGridGroupByRowComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: IgxGridSelectionService },
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: IgxFilteringService }
    ]; };
    IgxGridGroupByRowComponent.propDecorators = {
        hideGroupRowSelectors: [{ type: i0.Input }],
        rowDraggable: [{ type: i0.Input }],
        index: [{ type: i0.Input }],
        gridID: [{ type: i0.Input }],
        groupRow: [{ type: i0.Input }],
        groupContent: [{ type: i0.ViewChild, args: ['groupContent', { static: true },] }],
        isFocused: [{ type: i0.Input }],
        defaultGroupByExpandedTemplate: [{ type: i0.ViewChild, args: ['defaultGroupByExpandedTemplate', { read: i0.TemplateRef, static: true },] }],
        defaultGroupByCollapsedTemplate: [{ type: i0.ViewChild, args: ['defaultGroupByCollapsedTemplate', { read: i0.TemplateRef, static: true },] }],
        activate: [{ type: i0.HostListener, args: ['pointerdown',] }],
        expanded: [{ type: i0.HostBinding, args: ['attr.aria-expanded',] }],
        describedBy: [{ type: i0.HostBinding, args: ['attr.aria-describedby',] }],
        dataRowIndex: [{ type: i0.HostBinding, args: ['attr.data-rowIndex',] }],
        attrCellID: [{ type: i0.HostBinding, args: ['attr.id',] }],
        styleClasses: [{ type: i0.HostBinding, args: ['class',] }]
    };

    /** @hidden */
    var IgxGridMRLNavigationService = /** @class */ (function (_super) {
        __extends(IgxGridMRLNavigationService, _super);
        function IgxGridMRLNavigationService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxGridMRLNavigationService.prototype.isValidPosition = function (rowIndex, colIndex) {
            if (rowIndex < 0 || colIndex < 0 || this.grid.dataView.length - 1 < rowIndex ||
                Math.max.apply(Math, __spread(this.grid.visibleColumns.map(function (col) { return col.visibleIndex; }))) < colIndex ||
                (this.activeNode.column !== colIndex && !this.isDataRow(rowIndex, true))) {
                return false;
            }
            return true;
        };
        IgxGridMRLNavigationService.prototype.shouldPerformVerticalScroll = function (targetRowIndex, visibleColIndex) {
            if (!_super.prototype.shouldPerformVerticalScroll.call(this, targetRowIndex, visibleColIndex)) {
                return false;
            }
            if (!this.isDataRow(targetRowIndex) || visibleColIndex < 0) {
                return _super.prototype.shouldPerformVerticalScroll.call(this, targetRowIndex, visibleColIndex);
            }
            var targetRow = _super.prototype.getRowElementByIndex.call(this, targetRowIndex);
            var containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
            var scrollPos = this.getVerticalScrollPositions(targetRowIndex, visibleColIndex);
            return (!targetRow || targetRow.offsetTop + scrollPos.topOffset < Math.abs(this.containerTopOffset)
                || containerHeight && containerHeight < scrollPos.rowBottom - Math.ceil(this.scrollTop));
        };
        IgxGridMRLNavigationService.prototype.isColumnFullyVisible = function (visibleColIndex) {
            var targetCol = this.grid.getColumnByVisibleIndex(visibleColIndex);
            if (this.isParentColumnFullyVisible(targetCol === null || targetCol === void 0 ? void 0 : targetCol.parent) || _super.prototype.isColumnPinned.call(this, visibleColIndex, this.forOfDir())) {
                return true;
            }
            var scrollPos = this.getChildColumnScrollPositions(visibleColIndex);
            var colWidth = scrollPos.rightScroll - scrollPos.leftScroll;
            if (this.displayContainerWidth < colWidth && this.displayContainerScrollLeft === scrollPos.leftScroll) {
                return true;
            }
            return this.displayContainerWidth >= scrollPos.rightScroll - this.displayContainerScrollLeft &&
                this.displayContainerScrollLeft <= scrollPos.leftScroll;
        };
        IgxGridMRLNavigationService.prototype.getVerticalScrollPositions = function (rowIndex, visibleIndex) {
            var targetCol = this.grid.getColumnByVisibleIndex(visibleIndex);
            var rowSpan = targetCol.rowEnd && targetCol.rowEnd - targetCol.rowStart ? targetCol.rowEnd - targetCol.rowStart : 1;
            var topOffset = this.grid.defaultRowHeight * (targetCol.rowStart - 1);
            var rowTop = this.grid.verticalScrollContainer.sizesCache[rowIndex] + topOffset;
            return { topOffset: topOffset, rowTop: rowTop, rowBottom: rowTop + (this.grid.defaultRowHeight * rowSpan) };
        };
        IgxGridMRLNavigationService.prototype.performHorizontalScrollToCell = function (visibleColumnIndex, cb) {
            if (!this.shouldPerformHorizontalScroll(visibleColumnIndex)) {
                return;
            }
            var scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);
            var startScroll = scrollPos.rightScroll - this.displayContainerScrollLeft;
            var nextScroll = !(this.displayContainerScrollLeft <= scrollPos.leftScroll) && this.displayContainerWidth >= startScroll ?
                scrollPos.leftScroll : scrollPos.rightScroll - this.displayContainerWidth;
            this.forOfDir().getScroll().scrollLeft = nextScroll;
            this.grid.parentVirtDir.onChunkLoad
                .pipe(operators.first())
                .subscribe(function () {
                if (cb) {
                    cb();
                }
            });
        };
        IgxGridMRLNavigationService.prototype.performVerticalScrollToCell = function (rowIndex, visibleColIndex, cb) {
            var _a;
            var children = (_a = this.parentByChildIndex(visibleColIndex || 0)) === null || _a === void 0 ? void 0 : _a.children;
            if (!_super.prototype.isDataRow.call(this, rowIndex) || (children && children.length < 2) || visibleColIndex < 0) {
                return _super.prototype.performVerticalScrollToCell.call(this, rowIndex, visibleColIndex, cb);
            }
            var containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
            var pos = this.getVerticalScrollPositions(rowIndex, visibleColIndex);
            var row = _super.prototype.getRowElementByIndex.call(this, rowIndex);
            if ((this.scrollTop > pos.rowTop) && (!row || row.offsetTop + pos.topOffset < Math.abs(this.containerTopOffset))) {
                if (pos.topOffset === 0) {
                    this.grid.verticalScrollContainer.scrollTo(rowIndex);
                }
                else {
                    this.grid.verticalScrollContainer.scrollPosition = pos.rowTop;
                }
            }
            else {
                this.grid.verticalScrollContainer.addScrollTop(Math.abs(pos.rowBottom - this.scrollTop - containerHeight));
            }
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(operators.first()).subscribe(function () {
                if (cb) {
                    cb();
                }
            });
        };
        IgxGridMRLNavigationService.prototype.getNextHorizontalCellPosition = function (previous) {
            var _this = this;
            if (previous === void 0) { previous = false; }
            var parent = this.parentByChildIndex(this.activeNode.column);
            if (!this.hasNextHorizontalPosition(previous, parent)) {
                return { row: this.activeNode.row, column: this.activeNode.column };
            }
            var columns = previous ? parent.children.filter(function (c) { return c.rowStart <= _this.activeNode.layout.rowStart; })
                .sort(function (a, b) { return b.visibleIndex - a.visibleIndex; }) : parent.children.filter(function (c) { return c.rowStart <= _this.activeNode.layout.rowStart; });
            var column = columns.find(function (col) { return previous ?
                col.visibleIndex < _this.activeNode.column && _this.rowEnd(col) > _this.activeNode.layout.rowStart :
                col.visibleIndex > _this.activeNode.column && col.colStart > _this.activeNode.layout.colStart; });
            if (!column || (previous && this.activeNode.layout.colStart === 1)) {
                var index_1 = previous ? parent.visibleIndex - 1 : parent.visibleIndex + 1;
                var children = this.grid.columnList.find(function (cols) { return cols.columnLayout && cols.visibleIndex === index_1; }).children;
                column = previous ? children.toArray().reverse().find(function (child) { return child.rowStart <= _this.activeNode.layout.rowStart; }) :
                    children.find(function (child) { return _this.rowEnd(child) > _this.activeNode.layout.rowStart && child.colStart === 1; });
            }
            return { row: this.activeNode.row, column: column.visibleIndex };
        };
        IgxGridMRLNavigationService.prototype.getNextVerticalPosition = function (previous) {
            if (previous === void 0) { previous = false; }
            this.activeNode.column = this.activeNode.column || 0;
            if (!this.hasNextVerticalPosition(previous)) {
                return { row: this.activeNode.row, column: this.activeNode.column };
            }
            var currentRowStart = this.grid.getColumnByVisibleIndex(this.activeNode.column).rowStart;
            var nextBlock = !this.isDataRow(this.activeNode.row) ||
                (previous ? currentRowStart === 1 : currentRowStart === this.lastRowStartPerBlock());
            var nextRI = previous ? this.activeNode.row - 1 : this.activeNode.row + 1;
            if (nextBlock && !this.isDataRow(nextRI)) {
                return { row: nextRI, column: this.activeNode.column };
            }
            var children = this.parentByChildIndex(this.activeNode.column).children;
            var col = previous ? this.getPreviousRowIndex(children, nextBlock) : this.getNextRowIndex(children, nextBlock);
            return { row: nextBlock ? nextRI : this.activeNode.row, column: col.visibleIndex };
        };
        IgxGridMRLNavigationService.prototype.headerNavigation = function (event) {
            var key = event.key.toLowerCase();
            if (!HEADER_KEYS.has(key)) {
                return;
            }
            event.preventDefault();
            if (!this.activeNode.layout) {
                this.activeNode.layout = this.layout(this.activeNode.column || 0);
            }
            var alt = event.altKey;
            var ctrl = event.ctrlKey;
            this.performHeaderKeyCombination(this.grid.getColumnByVisibleIndex(this.activeNode.column), key, event.shiftKey, ctrl, alt, event);
            if (!ctrl && !alt && (key.includes('down') || key.includes('up'))) {
                var children = this.parentByChildIndex(this.activeNode.column).children;
                var col = key.includes('down') ? this.getNextRowIndex(children, false) : this.getPreviousRowIndex(children, false);
                if (!col) {
                    return;
                }
                this.activeNode.column = col.visibleIndex;
                var layout = this.layout(this.activeNode.column);
                var nextLayout = Object.assign(Object.assign({}, this.activeNode.layout), { rowStart: layout.rowStart, rowEnd: layout.rowEnd });
                this.setActiveNode({ row: this.activeNode.row, layout: nextLayout });
                return;
            }
            this.horizontalNav(event, key, -1, 'headerCell');
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridMRLNavigationService.prototype.layout = function (visibleIndex) {
            var column = this.grid.getColumnByVisibleIndex(visibleIndex);
            return { colStart: column.colStart, rowStart: column.rowStart,
                colEnd: column.colEnd, rowEnd: column.rowEnd, columnVisibleIndex: column.visibleIndex };
        };
        IgxGridMRLNavigationService.prototype.getNextPosition = function (rowIndex, colIndex, key, shift, ctrl, event) {
            if (!this.activeNode.layout) {
                this.activeNode.layout = this.layout(this.activeNode.column || 0);
            }
            switch (key) {
                case 'tab':
                case ' ':
                case 'spacebar':
                case 'space':
                case 'escape':
                case 'esc':
                case 'enter':
                case 'f2':
                    _super.prototype.getNextPosition.call(this, rowIndex, colIndex, key, shift, ctrl, event);
                    break;
                case 'end':
                    rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row;
                    colIndex = ctrl ? this.lastColIndexPerMRLBlock(this.lastIndexPerRow) : this.lastIndexPerRow;
                    break;
                case 'home':
                    rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row;
                    colIndex = ctrl ? 0 : this.firstIndexPerRow;
                    break;
                case 'arrowleft':
                case 'left':
                    colIndex = ctrl ? this.firstIndexPerRow : this.getNextHorizontalCellPosition(true).column;
                    break;
                case 'arrowright':
                case 'right':
                    colIndex = ctrl ? this.lastIndexPerRow : this.getNextHorizontalCellPosition().column;
                    break;
                case 'arrowup':
                case 'up':
                    var prevPos = this.getNextVerticalPosition(true);
                    colIndex = ctrl ? this.activeNode.column : prevPos.column;
                    rowIndex = ctrl ? this.findFirstDataRowIndex() : prevPos.row;
                    break;
                case 'arrowdown':
                case 'down':
                    var nextPos = this.getNextVerticalPosition();
                    colIndex = ctrl ? this.activeNode.column : nextPos.column;
                    rowIndex = ctrl ? this.findLastDataRowIndex() : nextPos.row;
                    break;
                default:
                    return;
            }
            var nextLayout = this.layout(colIndex);
            var newLayout = key.includes('up') || key.includes('down') ? { rowStart: nextLayout.rowStart } : { colStart: nextLayout.colStart };
            Object.assign(this.activeNode.layout, newLayout, { rowEnd: nextLayout.rowEnd });
            if (ctrl && (key === 'home' || key === 'end')) {
                this.activeNode.layout = nextLayout;
            }
            return { rowIndex: rowIndex, colIndex: colIndex };
        };
        IgxGridMRLNavigationService.prototype.horizontalNav = function (event, key, rowIndex, tag) {
            var ctrl = event.ctrlKey;
            if (!HORIZONTAL_NAV_KEYS.has(key) || event.altKey) {
                return;
            }
            this.activeNode.row = rowIndex;
            var newActiveNode = {
                column: this.activeNode.column,
                mchCache: {
                    level: this.activeNode.level,
                    visibleIndex: this.activeNode.column
                }
            };
            if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {
                newActiveNode.column = ctrl || key === 'home' ? this.firstIndexPerRow : this.getNextHorizontalCellPosition(true).column;
            }
            if ((key.includes('right') || key === 'end') && this.activeNode.column !== this.lastIndexPerRow) {
                newActiveNode.column = ctrl || key === 'end' ? this.lastIndexPerRow : this.getNextHorizontalCellPosition().column;
            }
            if (tag === 'headerCell') {
                var column = this.grid.getColumnByVisibleIndex(newActiveNode.column);
                newActiveNode.mchCache.level = column.level;
                newActiveNode.mchCache.visibleIndex = column.visibleIndex;
            }
            var layout = this.layout(newActiveNode.column);
            var newLayout = Object.assign(Object.assign({}, this.activeNode.layout), { colStart: layout.colStart, rowEnd: layout.rowEnd });
            this.setActiveNode({ row: this.activeNode.row, column: newActiveNode.column,
                layout: newLayout, mchCache: newActiveNode.mchCache });
            this.performHorizontalScrollToCell(newActiveNode.column);
        };
        IgxGridMRLNavigationService.prototype.isParentColumnFullyVisible = function (parent) {
            if (!this.forOfDir().getScroll().clientWidth || (parent === null || parent === void 0 ? void 0 : parent.pinned)) {
                return true;
            }
            var index = this.forOfDir().igxForOf.indexOf(parent);
            return this.displayContainerWidth >= this.forOfDir().getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft &&
                this.displayContainerScrollLeft <= this.forOfDir().getColumnScrollLeft(index);
        };
        IgxGridMRLNavigationService.prototype.getChildColumnScrollPositions = function (visibleColIndex) {
            var targetCol = this.grid.getColumnByVisibleIndex(visibleColIndex);
            var parentVIndex = this.forOfDir().igxForOf.indexOf(targetCol.parent);
            var leftScroll = this.forOfDir().getColumnScrollLeft(parentVIndex);
            var rightScroll = this.forOfDir().getColumnScrollLeft(parentVIndex + 1);
            targetCol.parent.children.forEach(function (c) {
                if (c.rowStart >= targetCol.rowStart && c.visibleIndex < targetCol.visibleIndex) {
                    leftScroll += parseInt(c.width, 10);
                }
                if (c.rowStart <= targetCol.rowStart && c.visibleIndex > targetCol.visibleIndex) {
                    rightScroll -= parseInt(c.width, 10);
                }
            });
            return { leftScroll: leftScroll, rightScroll: rightScroll };
        };
        IgxGridMRLNavigationService.prototype.getNextRowIndex = function (children, next) {
            var _this = this;
            var rowStart = next ? 1 : this.rowEnd(this.grid.getColumnByVisibleIndex(this.activeNode.column));
            var col = children.filter(function (c) { return c.rowStart === rowStart; });
            return col.find(function (co) { return co.colStart === _this.activeNode.layout.colStart; }) ||
                col.sort(function (a, b) { return b.visibleIndex - a.visibleIndex; }).find(function (co) { return co.colStart <= _this.activeNode.layout.colStart; });
        };
        IgxGridMRLNavigationService.prototype.getPreviousRowIndex = function (children, prev) {
            var _this = this;
            var end = prev ? Math.max.apply(Math, __spread(children.map(function (c) { return _this.rowEnd(c); }))) :
                this.grid.getColumnByVisibleIndex(this.activeNode.column).rowStart;
            var col = children.filter(function (c) { return _this.rowEnd(c) === end; });
            return col.find(function (co) { return co.colStart === _this.activeNode.layout.colStart; }) ||
                col.sort(function (a, b) { return b.visibleIndex - a.visibleIndex; }).find(function (co) { return co.colStart <= _this.activeNode.layout.colStart; });
        };
        Object.defineProperty(IgxGridMRLNavigationService.prototype, "lastIndexPerRow", {
            get: function () {
                var _this = this;
                var children = this.grid.visibleColumns.find(function (c) { return c.visibleIndex === _this.lastLayoutIndex && c.columnLayout; })
                    .children.toArray().reverse();
                var column = children.find(function (co) { return co.rowStart === _this.activeNode.layout.rowStart; }) ||
                    children.find(function (co) { return co.rowStart <= _this.activeNode.layout.rowStart; });
                return column.visibleIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridMRLNavigationService.prototype, "firstIndexPerRow", {
            get: function () {
                var _this = this;
                var children = this.grid.visibleColumns.find(function (c) { return c.visibleIndex === 0 && c.columnLayout; }).children;
                var column = children.find(function (co) { return co.rowStart === _this.activeNode.layout.rowStart; }) ||
                    children.find(function (co) { return co.rowStart <= _this.activeNode.layout.rowStart; });
                return column.visibleIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridMRLNavigationService.prototype, "lastLayoutIndex", {
            get: function () {
                return Math.max.apply(Math, __spread(this.grid.visibleColumns.filter(function (c) { return c.columnLayout; }).map(function (col) { return col.visibleIndex; })));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridMRLNavigationService.prototype, "scrollTop", {
            get: function () {
                return Math.abs(this.grid.verticalScrollContainer.getScroll().scrollTop);
            },
            enumerable: false,
            configurable: true
        });
        IgxGridMRLNavigationService.prototype.lastColIndexPerMRLBlock = function (visibleIndex) {
            if (visibleIndex === void 0) { visibleIndex = this.activeNode.column; }
            return this.parentByChildIndex(visibleIndex).children.last.visibleIndex;
        };
        IgxGridMRLNavigationService.prototype.lastRowStartPerBlock = function (visibleIndex) {
            if (visibleIndex === void 0) { visibleIndex = this.activeNode.column; }
            return Math.max.apply(Math, __spread(this.parentByChildIndex(visibleIndex).children.map(function (c) { return c.rowStart; })));
        };
        IgxGridMRLNavigationService.prototype.rowEnd = function (column) {
            return column.rowEnd && column.rowEnd - column.rowStart ? column.rowStart + column.rowEnd - column.rowStart : column.rowStart + 1;
        };
        IgxGridMRLNavigationService.prototype.parentByChildIndex = function (visibleIndex) {
            var _a;
            return (_a = this.grid.getColumnByVisibleIndex(visibleIndex)) === null || _a === void 0 ? void 0 : _a.parent;
        };
        IgxGridMRLNavigationService.prototype.hasNextHorizontalPosition = function (previous, parent) {
            if (previous === void 0) { previous = false; }
            if (previous && parent.visibleIndex === 0 && this.activeNode.layout.colStart === 1 ||
                !previous && parent.visibleIndex === this.lastLayoutIndex && this.activeNode.column === this.lastIndexPerRow) {
                return false;
            }
            return true;
        };
        IgxGridMRLNavigationService.prototype.hasNextVerticalPosition = function (prev) {
            if (prev === void 0) { prev = false; }
            if ((prev && this.activeNode.row === 0 && (!this.isDataRow(this.activeNode.row) || this.activeNode.layout.rowStart === 1)) ||
                (!prev && this.activeNode.row >= this.grid.dataView.length - 1 && this.activeNode.column === this.lastColIndexPerMRLBlock())) {
                return false;
            }
            return true;
        };
        return IgxGridMRLNavigationService;
    }(IgxGridNavigationService));
    IgxGridMRLNavigationService.decorators = [
        { type: i0.Injectable }
    ];

    var NEXT_ID$l = 0;
    /**
     * Grid provides a way to present and manipulate tabular data.
     *
     * @igxModule IgxGridModule
     * @igxGroup Grids & Lists
     * @igxKeywords grid, table
     * @igxTheme igx-grid-theme
     * @remarks
     * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
     * has been bound, it can be manipulated through filtering, sorting & editing operations.
     * @example
     * ```html
     * <igx-grid [data]="employeeData" autoGenerate="false">
     *   <igx-column field="first" header="First Name"></igx-column>
     *   <igx-column field="last" header="Last Name"></igx-column>
     *   <igx-column field="role" header="Role"></igx-column>
     * </igx-grid>
     * ```
     */
    var IgxGridComponent = /** @class */ (function (_super) {
        __extends(IgxGridComponent, _super);
        function IgxGridComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            /**
             * Emitted when a new chunk of data is loaded from virtualization.
             *
             * @example
             * ```typescript
             *  <igx-grid #grid [data]="localData" [autoGenerate]="true" (onDataPreLoad)='handleDataPreloadEvent()'></igx-grid>
             * ```
             */
            _this.onDataPreLoad = new i0.EventEmitter();
            /**
             * @hidden
             */
            _this.groupingExpressionsChange = new i0.EventEmitter();
            /**
             * @hidden @internal
             */
            _this.groupingExpansionStateChange = new i0.EventEmitter();
            /**
             * Emitted when columns are grouped/ungrouped.
             *
             * @remarks
             * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
             * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
             * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
             * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
             * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
             * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
             * columns.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onGroupingDone = new i0.EventEmitter();
            /**
             * Gets/Sets whether created groups are rendered expanded or collapsed.
             *
             * @remarks
             * The default rendered state is expanded.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.groupsExpanded = true;
            /**
             * @hidden @internal
             */
            _this.detailTemplate = null;
            /**
             * @hidden @internal
             */
            _this.role = 'grid';
            /**
             * Gets/Sets the value of the `id` attribute.
             *
             * @remarks
             * If not provided it will be automatically generated.
             * @example
             * ```html
             * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.id = "igx-grid-" + NEXT_ID$l++;
            /**
             * Gets the hierarchical representation of the group by records.
             *
             * @example
             * ```typescript
             * let groupRecords = this.grid.groupsRecords;
             * ```
             */
            _this.groupsRecords = [];
            /**
             * @hidden
             */
            _this._groupingExpressions = [];
            /**
             * @hidden
             */
            _this._groupingExpandState = [];
            _this._hideGroupedColumns = false;
            _this._dropAreaMessage = null;
            _this._showGroupArea = true;
            _this._filteredData = null;
            _this.childDetailTemplates = new Map();
            return _this;
        }
        Object.defineProperty(IgxGridComponent.prototype, "data", {
            /**
             * Gets/Sets the array of data that populates the `IgxGridComponent`.
             *
             * @example
             * ```html
             * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._data;
            },
            set: function (value) {
                this._data = value || [];
                this.summaryService.clearSummaryCache();
                if (this.shouldGenerate) {
                    this.setupColumns();
                }
                this.cdr.markForCheck();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "filteredData", {
            /**
             * Gets/Sets an array of objects containing the filtered data.
             *
             * @example
             * ```typescript
             * let filteredData = this.grid.filteredData;
             * this.grid.filteredData = [...];
             * ```
             */
            get: function () {
                return this._filteredData;
            },
            set: function (value) {
                this._filteredData = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "totalItemCount", {
            get: function () {
                return this.verticalScrollContainer.totalItemCount;
            },
            /**
             * Gets/Sets the total number of records in the data source.
             *
             * @remarks
             * This property is required for remote grid virtualization to function when it is bound to remote data.
             * @example
             * ```typescript
             * const itemCount = this.grid1.totalItemCount;
             * this.grid1.totalItemCount = 55;
             * ```
             */
            set: function (count) {
                this.verticalScrollContainer.totalItemCount = count;
                this.cdr.detectChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "_gridAPI", {
            get: function () {
                return this.gridAPI;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "groupingExpressions", {
            /**
             * Gets/Sets the group by state.
             *
             * @example
             * ```typescript
             * let groupByState = this.grid.groupingExpressions;
             * this.grid.groupingExpressions = [...];
             * ```
             * @remarks
             * Supports two-way data binding.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpressions)]="model.groupingExpressions"></igx-grid>
             * ```
             */
            get: function () {
                return this._groupingExpressions;
            },
            set: function (value) {
                var _this = this;
                if (this.groupingExpressions === value) {
                    return;
                }
                if (value && value.length > 10) {
                    throw Error('Maximum amount of grouped columns is 10.');
                }
                var oldExpressions = this.groupingExpressions;
                var newExpressions = value;
                this._groupingExpressions = cloneArray(value);
                this.groupingExpressionsChange.emit(this._groupingExpressions);
                this.chipsGoupingExpressions = cloneArray(value);
                if (this._gridAPI.grid) {
                    /* grouping should work in conjunction with sorting
                    and without overriding separate sorting expressions */
                    this._applyGrouping();
                    this._gridAPI.arrange_sorting_expressions();
                    this.notifyChanges();
                }
                else {
                    // setter called before grid is registered in grid API service
                    this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);
                }
                if (!this._init && JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {
                    var groupedCols_1 = [];
                    var ungroupedCols_1 = [];
                    var groupedColsArr = newExpressions.filter(function (obj) { return !oldExpressions.some(function (obj2) { return obj.fieldName === obj2.fieldName; }); });
                    groupedColsArr.forEach(function (elem) {
                        groupedCols_1.push(_this.getColumnByName(elem.fieldName));
                    }, this);
                    var ungroupedColsArr = oldExpressions.filter(function (obj) { return !newExpressions.some(function (obj2) { return obj.fieldName === obj2.fieldName; }); });
                    ungroupedColsArr.forEach(function (elem) {
                        ungroupedCols_1.push(_this.getColumnByName(elem.fieldName));
                    }, this);
                    this.notifyChanges();
                    var groupingDoneArgs = {
                        expressions: newExpressions,
                        groupedColumns: groupedCols_1,
                        ungroupedColumns: ungroupedCols_1
                    };
                    this.onGroupingDone.emit(groupingDoneArgs);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "groupingExpansionState", {
            /**
             * Gets/Sets a list of expansion states for group rows.
             *
             * @remarks
             * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
             * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
             * Supports two-way data binding.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpansionState)]="model.groupingExpansionState"></igx-grid>
             * ```
             */
            get: function () {
                return this._groupingExpandState;
            },
            set: function (value) {
                if (value !== this._groupingExpandState) {
                    this.groupingExpansionStateChange.emit(value);
                }
                this._groupingExpandState = value;
                if (this.gridAPI.grid) {
                    this.cdr.detectChanges();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "hideGroupedColumns", {
            /**
             * Gets/Sets whether the grouped columns should be hidden.
             *
             * @remarks
             * The default value is "false"
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._hideGroupedColumns;
            },
            set: function (value) {
                if (value) {
                    this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
                }
                else {
                    this.groupingDiffer = null;
                }
                if (this.columnList && this.groupingExpressions) {
                    this._setGroupColsVisibility(value);
                }
                this._hideGroupedColumns = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "dropAreaMessage", {
            get: function () {
                return this._dropAreaMessage || this.resourceStrings.igx_grid_groupByArea_message;
            },
            /**
             * Gets/Sets the message displayed inside the GroupBy drop area where columns can be dragged on.
             *
             * @remarks
             * The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
             * @example
             * ```html
             * <igx-grid dropAreaMessage="Drop here to group!">
             *      <igx-column [groupable]="true" field="ID"></igx-column>
             * </igx-grid>
             * ```
             */
            set: function (value) {
                this._dropAreaMessage = value;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "groupsRowList", {
            /**
             * Gets the list of group rows.
             *
             * @example
             * ```typescript
             * const groupList = this.grid.groupsRowList;
             * ```
             */
            get: function () {
                var res = new i0.QueryList();
                if (!this._groupsRowList) {
                    return res;
                }
                var rList = this._groupsRowList.filter(function (item) { return item.element.nativeElement.parentElement !== null; })
                    .sort(function (item1, item2) { return item1.index - item2.index; });
                res.reset(rList);
                return res;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "groupByRowSelectorTemplate", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.groupByRowSelectorsTemplates && this.groupByRowSelectorsTemplates.first) {
                    return this.groupByRowSelectorsTemplates.first.templateRef;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.getDetailsContext = function (rowData, index) {
            return {
                $implicit: rowData,
                index: index
            };
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.trackChanges = function (index, rec) {
            if (rec.detailsData !== undefined) {
                return rec.detailsData;
            }
            return rec;
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.detailsViewFocused = function (container, rowIndex) {
            this.navigation.setActiveNode({ row: rowIndex });
        };
        Object.defineProperty(IgxGridComponent.prototype, "hasDetails", {
            /**
             * @hidden @internal
             */
            get: function () {
                return !!this.gridDetailsTemplate;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.getRowTemplate = function (rowData) {
            if (this.isGroupByRecord(rowData)) {
                return this.defaultGroupTemplate;
            }
            else if (this.isSummaryRow(rowData)) {
                return this.summaryTemplate;
            }
            else if (this.hasDetails && this.isDetailRecord(rowData)) {
                return this.detailTemplateContainer;
            }
            else {
                return this.recordTemplate;
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.isDetailRecord = function (record) {
            return record.detailsData !== undefined;
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.isDetailActive = function (rowIndex) {
            return this.navigation.activeNode ? this.navigation.activeNode.row === rowIndex : false;
        };
        Object.defineProperty(IgxGridComponent.prototype, "groupAreaHostClass", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.getComponentDensityClass('igx-drop-area');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "groupRowTemplate", {
            /**
             * Gets/Sets the template reference for the group row.
             *
             * @example
             * ```
             * const groupRowTemplate = this.grid.groupRowTemplate;
             * this.grid.groupRowTemplate = myRowTemplate;
             * ```
             */
            get: function () {
                return this._groupRowTemplate;
            },
            set: function (template) {
                this._groupRowTemplate = template;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "groupAreaTemplate", {
            /**
             * Gets/Sets the template reference of the `IgxGridComponent`'s group area.
             *
             * @example
             * ```typescript
             * const groupAreaTemplate = this.grid.groupAreaTemplate;
             * this.grid.groupAreaTemplate = myAreaTemplate.
             * ```
             */
            get: function () {
                return this._groupAreaTemplate;
            },
            set: function (template) {
                this._groupAreaTemplate = template;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
         *
         * @remarks
         * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
         * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
         * @example
         * ```typescript
         * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
         * this.grid.groupBy([
         *     { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
         *     { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
         *     { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
         * ]);
         * ```
         */
        IgxGridComponent.prototype.groupBy = function (expression) {
            if (this.checkIfNoColumnField(expression)) {
                return;
            }
            this.endEdit(false);
            if (expression instanceof Array) {
                this._gridAPI.groupBy_multiple(expression);
            }
            else {
                this._gridAPI.groupBy(expression);
            }
            this.notifyChanges(true);
        };
        /**
         * Clears grouping for particular column, array of columns or all columns.
         *
         * @remarks
         * Clears all grouping in the grid, if no parameter is passed.
         * If a parameter is provided, clears grouping for a particular column or an array of columns.
         * @example
         * ```typescript
         * this.grid.clearGrouping(); //clears all grouping
         * this.grid.clearGrouping("ID"); //ungroups a single column
         * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
         * ```
         * @param name Name of column or array of column names to be ungrouped.
         */
        IgxGridComponent.prototype.clearGrouping = function (name) {
            this._gridAPI.clear_groupby(name);
            this.notifyChanges(true);
        };
        IgxGridComponent.prototype.preventHeaderScroll = function (args) {
            if (args.target.scrollLeft !== 0) {
                this.navigation.forOfDir().getScroll().scrollLeft = args.target.scrollLeft;
                args.target.scrollLeft = 0;
            }
        };
        /**
         * Returns if a group is expanded or not.
         *
         * @param group The group record.
         * @example
         * ```typescript
         * public groupRow: IGroupByRecord;
         * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
         * ```
         */
        IgxGridComponent.prototype.isExpandedGroup = function (group) {
            var state = this._getStateForGroupRow(group);
            return state ? state.expanded : this.groupsExpanded;
        };
        /**
         * Toggles the expansion state of a group.
         *
         * @param groupRow The group record to toggle.
         * @example
         * ```typescript
         * public groupRow: IGroupByRecord;
         * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
         * ```
         */
        IgxGridComponent.prototype.toggleGroup = function (groupRow) {
            this._toggleGroup(groupRow);
            this.notifyChanges();
        };
        /**
         * Select all rows within a group.
         *
         * @param groupRow: The group record which rows would be selected.
         * @param clearCurrentSelection if true clears the current selection
         * @example
         * ```typescript
         * this.grid.selectRowsInGroup(this.groupRow, true);
         * ```
         */
        IgxGridComponent.prototype.selectRowsInGroup = function (groupRow, clearPrevSelection) {
            this._gridAPI.groupBy_select_all_rows_in_group(groupRow, clearPrevSelection);
            this.notifyChanges();
        };
        /**
         * Deselect all rows within a group.
         *
         * @param groupRow The group record which rows would be deselected.
         * @example
         * ```typescript
         * public groupRow: IGroupByRecord;
         * this.grid.deselectRowsInGroup(this.groupRow);
         * ```
         */
        IgxGridComponent.prototype.deselectRowsInGroup = function (groupRow) {
            this._gridAPI.groupBy_deselect_all_rows_in_group(groupRow);
            this.notifyChanges();
        };
        /**
         * Expands the specified group and all of its parent groups.
         *
         * @param groupRow The group record to fully expand.
         * @example
         * ```typescript
         * public groupRow: IGroupByRecord;
         * this.grid.fullyExpandGroup(this.groupRow);
         * ```
         */
        IgxGridComponent.prototype.fullyExpandGroup = function (groupRow) {
            this._fullyExpandGroup(groupRow);
            this.notifyChanges();
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.isGroupByRecord = function (record) {
            // return record.records instance of GroupedRecords fails under Webpack
            return record.records && record.records.length;
        };
        /**
         * Toggles the expansion state of all group rows recursively.
         *
         * @example
         * ```typescript
         * this.grid.toggleAllGroupRows;
         * ```
         */
        IgxGridComponent.prototype.toggleAllGroupRows = function () {
            this.groupingExpansionState = [];
            this.groupsExpanded = !this.groupsExpanded;
            this.notifyChanges();
        };
        Object.defineProperty(IgxGridComponent.prototype, "hasGroupableColumns", {
            /**
             * Returns if the `IgxGridComponent` has groupable columns.
             *
             * @example
             * ```typescript
             * const groupableGrid = this.grid.hasGroupableColumns;
             * ```
             */
            get: function () {
                return this.columnList.some(function (col) { return col.groupable && !col.columnGroup; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "showGroupArea", {
            /**
             * Returns whether the `IgxGridComponent` has group area.
             *
             * @example
             * ```typescript
             * let isGroupAreaVisible = this.grid.showGroupArea;
             * ```
             *
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [showGroupArea]="false"></igx-grid>
             * ```
             */
            get: function () {
                return this._showGroupArea;
            },
            set: function (value) {
                this._showGroupArea = value;
                this.notifyChanges(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "dropAreaVisible", {
            /**
             * Gets if the grid's group by drop area is visible.
             *
             * @example
             * ```typescript
             * const dropVisible = this.grid.dropAreaVisible;
             * ```
             */
            get: function () {
                return (this.draggedColumn && this.draggedColumn.groupable) ||
                    !this.chipsGoupingExpressions.length;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.isColumnGrouped = function (fieldName) {
            return this.groupingExpressions.find(function (exp) { return exp.fieldName === fieldName; }) ? true : false;
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.getContext = function (rowData, rowIndex, pinned) {
            if (this.isDetailRecord(rowData)) {
                var cachedData = this.childDetailTemplates.get(rowData.detailsData);
                var rowID = this.primaryKey ? rowData.detailsData[this.primaryKey] : this.data.indexOf(rowData.detailsData);
                if (cachedData) {
                    var view = cachedData.view;
                    var tmlpOutlet = cachedData.owner;
                    return {
                        $implicit: rowData.detailsData,
                        moveView: view,
                        owner: tmlpOutlet,
                        index: this.dataView.indexOf(rowData),
                        templateID: 'detailRow-' + rowID
                    };
                }
                else {
                    // child rows contain unique grids, hence should have unique templates
                    return {
                        $implicit: rowData.detailsData,
                        templateID: 'detailRow-' + rowID,
                        index: this.dataView.indexOf(rowData)
                    };
                }
            }
            return {
                $implicit: this.isGhostRecord(rowData) || this.isAddRowRecord(rowData) ? rowData.recordRef : rowData,
                index: this.getDataViewIndex(rowIndex, pinned),
                templateID: this.isGroupByRecord(rowData) ? 'groupRow' : this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',
                disabled: this.isGhostRecord(rowData),
                addRow: this.isAddRowRecord(rowData) ? rowData.addRow : false
            };
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.viewCreatedHandler = function (args) {
            if (args.context.templateID.indexOf('detailRow') !== -1) {
                this.childDetailTemplates.set(args.context.$implicit, args);
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.viewMovedHandler = function (args) {
            if (args.context.templateID.indexOf('detailRow') !== -1) {
                // view was moved, update owner in cache
                var key = args.context.$implicit;
                var cachedData = this.childDetailTemplates.get(key);
                cachedData.owner = args.owner;
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.onChipRemoved = function (event) {
            this.clearGrouping(event.owner.id);
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.chipsOrderChanged = function (event) {
            var e_1, _a;
            var newGrouping = [];
            var _loop_1 = function (chip) {
                var expr = this_1.groupingExpressions.filter(function (item) { return item.fieldName === chip.id; })[0];
                if (!this_1.getColumnByName(expr.fieldName).groupable) {
                    return { value: void 0 };
                }
                newGrouping.push(expr);
            };
            var this_1 = this;
            try {
                for (var _b = __values(event.chipsArray), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var chip = _c.value;
                    var state_1 = _loop_1(chip);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.groupingExpansionState = [];
            this.chipsGoupingExpressions = newGrouping;
            if (event.originalEvent instanceof KeyboardEvent) {
                // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
                this.groupingExpressions = this.chipsGoupingExpressions;
            }
            this.notifyChanges();
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.chipsMovingEnded = function () {
            this.groupingExpressions = this.chipsGoupingExpressions;
            this.notifyChanges();
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.onChipClicked = function (event) {
            var sortingExpr = this.sortingExpressions;
            var columnExpr = sortingExpr.find(function (expr) { return expr.fieldName === event.owner.id; });
            columnExpr.dir = 3 - columnExpr.dir;
            this.sort(columnExpr);
            this.notifyChanges();
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.onChipKeyDown = function (event) {
            if (event.originalEvent.key === ' ' || event.originalEvent.key === 'Spacebar' || event.originalEvent.key === 'Enter') {
                var sortingExpr = this.sortingExpressions;
                var columnExpr = sortingExpr.find(function (expr) { return expr.fieldName === event.owner.id; });
                columnExpr.dir = 3 - columnExpr.dir;
                this.sort(columnExpr);
                this.notifyChanges();
            }
        };
        Object.defineProperty(IgxGridComponent.prototype, "dropAreaTemplateResolved", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this.dropAreaTemplate) {
                    return this.dropAreaTemplate;
                }
                else {
                    return this.defaultDropAreaTemplate;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.getGroupByChipTitle = function (expression) {
            var column = this.getColumnByName(expression.fieldName);
            return (column && column.header) || expression.fieldName;
        };
        Object.defineProperty(IgxGridComponent.prototype, "iconTemplate", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this.groupsExpanded) {
                    return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
                }
                else {
                    return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.getColumnGroupable = function (fieldName) {
            var column = this.getColumnByName(fieldName);
            return column && column.groupable;
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.ngAfterContentInit = function () {
            _super.prototype.ngAfterContentInit.call(this);
            if (this.allowFiltering && this.hasColumnLayouts) {
                this.filterMode = FilterMode.excelStyleFilter;
            }
            if (this.groupTemplate) {
                this._groupRowTemplate = this.groupTemplate.template;
            }
            if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {
                this._setGroupColsVisibility(this.hideGroupedColumns);
            }
            this._setupNavigationService();
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            _super.prototype.ngAfterViewInit.call(this);
            this.verticalScrollContainer.onBeforeViewDestroyed.pipe(operators.takeUntil(this.destroy$)).subscribe(function (view) {
                var rowData = view.context.$implicit;
                if (_this.isDetailRecord(rowData)) {
                    var cachedData = _this.childDetailTemplates.get(rowData.detailsData);
                    if (cachedData) {
                        var tmlpOutlet = cachedData.owner;
                        tmlpOutlet._viewContainerRef.detach(0);
                    }
                }
            });
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.ngOnInit = function () {
            var _this = this;
            _super.prototype.ngOnInit.call(this);
            this.onGroupingDone.pipe(operators.takeUntil(this.destroy$)).subscribe(function (args) {
                _this.endEdit(false);
                _this.summaryService.updateSummaryCache(args);
                _this._headerFeaturesWidth = NaN;
            });
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.ngDoCheck = function () {
            var _this = this;
            if (this.groupingDiffer && this.columnList && !this.hasColumnLayouts) {
                var changes = this.groupingDiffer.diff(this.groupingExpressions);
                if (changes && this.columnList.length > 0) {
                    changes.forEachAddedItem(function (rec) {
                        var col = _this.getColumnByName(rec.item.fieldName);
                        col.hidden = true;
                    });
                    changes.forEachRemovedItem(function (rec) {
                        var col = _this.getColumnByName(rec.item.fieldName);
                        col.hidden = false;
                    });
                }
            }
            _super.prototype.ngDoCheck.call(this);
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.dataLoading = function (event) {
            this.onDataPreLoad.emit(event);
        };
        /**
         * @inheritdoc
         */
        IgxGridComponent.prototype.getSelectedData = function (formatters, headers) {
            var _this = this;
            if (formatters === void 0) { formatters = false; }
            if (headers === void 0) { headers = false; }
            if (this.groupingExpressions.length || this.hasDetails) {
                var source_1 = [];
                var process = function (record) {
                    if (record.expression || record.summaries || _this.isDetailRecord(record)) {
                        source_1.push(null);
                        return;
                    }
                    source_1.push(record);
                };
                this.dataView.forEach(process);
                return this.extractDataFromSelection(source_1, formatters, headers);
            }
            else {
                return _super.prototype.getSelectedData.call(this, formatters, headers);
            }
        };
        Object.defineProperty(IgxGridComponent.prototype, "defaultTargetBodyHeight", {
            /**
             * @hidden @internal
             */
            get: function () {
                var allItems = this.totalItemCount || this.dataLength;
                return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.getGroupAreaHeight = function () {
            return this.groupArea ? this.getComputedHeight(this.groupArea.nativeElement) : 0;
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.scrollTo = function (row, column) {
            if (this.groupingExpressions && this.groupingExpressions.length
                && typeof (row) !== 'number') {
                var rowIndex = this.groupingResult.indexOf(row);
                var groupByRecord = this.groupingMetadata[rowIndex];
                if (groupByRecord) {
                    this._fullyExpandGroup(groupByRecord);
                }
            }
            _super.prototype.scrollTo.call(this, row, column, this.groupingFlatResult);
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype._getStateForGroupRow = function (groupRow) {
            return this._gridAPI.groupBy_get_expanded_for_group(groupRow);
        };
        /**
         * @hidden
         */
        IgxGridComponent.prototype._toggleGroup = function (groupRow) {
            this._gridAPI.groupBy_toggle_group(groupRow);
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype._fullyExpandGroup = function (groupRow) {
            this._gridAPI.groupBy_fully_expand_group(groupRow);
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype._applyGrouping = function () {
            this._gridAPI.sort_multiple(this._groupingExpressions);
        };
        IgxGridComponent.prototype._setupNavigationService = function () {
            if (this.hasColumnLayouts) {
                this.navigation = new IgxGridMRLNavigationService();
                this.navigation.grid = this;
            }
        };
        IgxGridComponent.prototype.checkIfNoColumnField = function (expression) {
            var e_2, _a;
            if (expression instanceof Array) {
                try {
                    for (var expression_1 = __values(expression), expression_1_1 = expression_1.next(); !expression_1_1.done; expression_1_1 = expression_1.next()) {
                        var singleExpression = expression_1_1.value;
                        if (!singleExpression.fieldName) {
                            return true;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (expression_1_1 && !expression_1_1.done && (_a = expression_1.return)) _a.call(expression_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                return false;
            }
            return !expression.fieldName;
        };
        IgxGridComponent.prototype._setGroupColsVisibility = function (value) {
            var _this = this;
            if (this.columnList.length > 0 && !this.hasColumnLayouts) {
                this.groupingExpressions.forEach(function (expr) {
                    var col = _this.getColumnByName(expr.fieldName);
                    col.hidden = value;
                });
            }
        };
        return IgxGridComponent;
    }(IgxGridBaseDirective));
    IgxGridComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    providers: [
                        IgxGridNavigationService,
                        IgxGridSummaryService,
                        IgxGridSelectionService,
                        IgxGridCRUDService,
                        { provide: GridBaseAPIService, useClass: IgxGridAPIService },
                        { provide: IgxGridBaseDirective, useExisting: i0.forwardRef(function () { return IgxGridComponent; }) },
                        IgxFilteringService,
                        IgxColumnResizingService,
                        IgxForOfSyncService,
                        IgxForOfScrollSyncService
                    ],
                    selector: 'igx-grid',
                    template: "<ng-content select=\"igx-grid-toolbar\"></ng-content>\n\n<div [style.flex-basis.px]='outerWidth' class=\"igx-grid__grouparea\"\n    *ngIf=\"showGroupArea && (groupingExpressions.length > 0 || hasGroupableColumns)\" #groupArea>\n    <igx-chips-area (reorder)=\"chipsOrderChanged($event)\" (moveEnd)=\"chipsMovingEnded()\">\n        <ng-container *ngFor=\"let expr of chipsGoupingExpressions; let last = last;\">\n            <igx-chip [id]=\"expr.fieldName\" [title]=\"getGroupByChipTitle(expr)\"\n                [removable]=\"getColumnGroupable(expr.fieldName)\"\n                [draggable]=\"getColumnGroupable(expr.fieldName)\" [displayDensity]=\"displayDensity\"\n                (keyDown)=\"onChipKeyDown($event)\" (remove)=\"onChipRemoved($event)\"\n                (chipClick)=\"getColumnGroupable(expr.fieldName) ? onChipClicked($event): null\"\n                [disabled]='!getColumnGroupable(expr.fieldName)'>\n                <span>{{ getGroupByChipTitle(expr) }}</span>\n                <igx-icon igxSuffix>{{ expr.dir == 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n            </igx-chip>\n            <span class=\"igx-grid__grouparea-connector\">\n                <igx-icon [style.visibility]=\"(!last || dropAreaVisible) ? 'visible' : 'hidden'\">arrow_forward\n                </igx-icon>\n            </span>\n        </ng-container>\n        <div igxGroupAreaDrop [style.visibility]=\"dropAreaVisible ? 'visible' : 'hidden'\" [class]=\"groupAreaHostClass\"\n            [attr.gridId]='this.id'>\n            <ng-container *ngTemplateOutlet=\"dropAreaTemplateResolved\"></ng-container>\n        </div>\n    </igx-chips-area>\n</div>\n\n<div class=\"igx-grid__thead\" role=\"rowgroup\">\n    <div class=\"igx-grid__thead-wrapper\" (keydown.meta.c)=\"copyHandler($event)\" (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" \n    [class.igx-grid__tr--mrl]='hasColumnLayouts' (focus)=\"navigation.focusFirstCell()\" [attr.aria-activedescendant]=\"activeDescendant\"\n    [style.width.px]='calcWidth' tabindex=\"0\" (keydown)=\"navigation.headerNavigation($event)\" (scroll)=\"preventHeaderScroll($event)\" #theadRow>\n    <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"pinnedWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator igx-grid__tr-action\" [ngClass]=\"{\n                    'igx-grid__drag-indicator--header': !isRowSelectable\n                }\" (pointerdown)=\"$event.preventDefault()\"  #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                }\" (pointerdown)=\"$event.preventDefault()\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"groupingExpressions.length > 0\">\n                <div class=\"igx-grid__header-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"\n                    #headerGroupContainer  (click)=\"toggleAllGroupRows()\" (pointerdown)=\"$event.preventDefault()\">\n\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\" [style.left]=\"col.rightPinnedOffset\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollSize\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\" role=\"rowgroup\">\n    <div class=\"igx-grid__tbody-content\" tabindex=\"0\" (keydown)=\"navigation.handleNavigation($event)\" (focus)=\"navigation.focusTbody($event)\"\n        (onDragStop)=\"selectionService.dragMode = $event\" (scroll)='preventContainerScroll($event)'\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth || null' #tbody [attr.aria-activedescendant]=\"activeDescendant\">\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n    <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\">\n    </ng-container>\n    <ng-template #pinnedRecordsTemplate>\n        <ng-container *ngIf='data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridRowPinning:id:true:pipeTrigger\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger:true\n        | gridAddRow:true:pipeTrigger as pinnedData'>\n            <div #pinContainer *ngIf='pinnedData.length > 0'\n                [ngClass]=\"{\n                    'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                    'igx-grid__tr--pinned-top': isRowPinningToTop\n                }\"\n                class='igx-grid__tr--pinned' [style.width.px]='calcWidth'>\n                <ng-container *ngFor=\"let rowData of pinnedData; let rowIndex = index\">\n                    <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                    </ng-container>\n                </ng-container>\n            </div>\n        </ng-container>\n    </ng-template>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger\n        | gridGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:groupsRecords:pipeTrigger\n        | gridPaging:page:perPage:id:pipeTrigger\n        | gridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:showSummaryOnCollapse:pipeTrigger:summaryPipeTrigger\n        | gridDetails:hasDetails:expansionStates:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\n        | gridAddRow:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight'\n            [igxForItemSize]=\"hasColumnLayouts ? rowHeight * multiRowLayoutRowSize + 1 : renderedRowHeight\"\n            [igxForTrackBy]='trackChanges'\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template\n                [igxTemplateOutlet]='getRowTemplate(rowData)'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'\n                (onViewCreated)='viewCreatedHandler($event)'\n                (onViewMoved)='viewMovedHandler($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-rowData let-disabledRow=\"disabled\" let-isAddRow=\"addRow\">\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" [disabled]=\"disabledRow\" [addRow]=\"isAddRow\" #row>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData let-isAddRow=\"addRow\">\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" [addRow]=\"isAddRow\" #row #pinnedRow>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #group_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" [hideGroupRowSelectors]=\"hideRowSelectors\" [rowDraggable]=\"rowDraggable\" #row>\n            </igx-grid-groupby-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row role=\"row\" [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-template #detail_template_container let-rowIndex=\"index\" let-rowData>\n            <div detail='true' style=\"overflow: auto; width: 100%;\" id=\"{{id}}_{{rowIndex}}\" (pointerdown)='detailsViewFocused(detailsContainer, rowIndex)' #detailsContainer [attr.data-rowindex]='rowIndex'\n                [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr-container--active': isDetailActive(rowIndex)\n            }\">\n                <div class=\"igx-grid__hierarchical-indent\" style='display: flex;'>\n                        <ng-container *ngIf=\"this.groupingExpressions.length > 0\">\n                                <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"></div>\n                        </ng-container>\n                        <ng-template\n                    [ngTemplateOutlet]='detailTemplate'\n                    [ngTemplateOutletContext]='getDetailsContext(rowData, rowIndex)'>\n                    </ng-template>\n                </div>\n            </div>\n        </ng-template>\n\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <div igxToggle #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\" (pointerdown)=\"$event.preventDefault()\">\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [actionText]=\"snackbarActionText\" [displayTime]='snackbarDisplayTime'>{{snackbarLabel}}</igx-snackbar>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <div tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\" (keydown)=\"navigation.summaryNav($event)\" [attr.aria-activedescendant]=\"activeDescendant\">\n        <igx-grid-summary-row [style.width.px]='calcWidth'  [style.height.px]='summariesHeight'\n            *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n            [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n            class=\"igx-grid__summaries\" #summaryRow>\n        </igx-grid-summary-row>\n        <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n            [style.width.px]=\"scrollSize\"></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\" (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [overlaySettings]=\"paginatorSettings\" [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button igxButton=\"raised\" igxRipple (click)='beginAddRowByIndex(null, -1, $event)'>\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultDropArea>\n    <igx-icon class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{dropAreaMessage}}</span>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n   [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_less</igx-icon>\n</ng-template>\n\n <ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n    [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_more</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle #rowEditingOverlay>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\" *ngIf=\"!this.crudService.row?.isAddRow\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon>drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n"
                },] }
    ];
    IgxGridComponent.propDecorators = {
        onDataPreLoad: [{ type: i0.Output }],
        groupingExpressionsChange: [{ type: i0.Output }],
        groupingExpansionStateChange: [{ type: i0.Output }],
        onGroupingDone: [{ type: i0.Output }],
        groupsExpanded: [{ type: i0.Input }],
        dropAreaTemplate: [{ type: i0.Input }],
        detailTemplate: [{ type: i0.ContentChild, args: [IgxGridDetailTemplateDirective, { read: i0.TemplateRef, static: false },] }],
        defaultDropAreaTemplate: [{ type: i0.ViewChild, args: ['defaultDropArea', { read: i0.TemplateRef, static: true },] }],
        groupArea: [{ type: i0.ViewChild, args: ['groupArea',] }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        recordTemplate: [{ type: i0.ViewChild, args: ['record_template', { read: i0.TemplateRef, static: true },] }],
        detailTemplateContainer: [{ type: i0.ViewChild, args: ['detail_template_container', { read: i0.TemplateRef, static: true },] }],
        defaultGroupTemplate: [{ type: i0.ViewChild, args: ['group_template', { read: i0.TemplateRef, static: true },] }],
        summaryTemplate: [{ type: i0.ViewChild, args: ['summary_template', { read: i0.TemplateRef, static: true },] }],
        groupTemplate: [{ type: i0.ContentChild, args: [IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective },] }],
        gridDetailsTemplate: [{ type: i0.ContentChild, args: [IgxGridDetailTemplateDirective, { read: IgxGridDetailTemplateDirective, static: false },] }],
        groupByRowSelectorsTemplates: [{ type: i0.ContentChildren, args: [IgxGroupByRowSelectorDirective, { read: IgxGroupByRowSelectorDirective, descendants: false },] }],
        _groupsRowList: [{ type: i0.ViewChildren, args: [IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent },] }],
        data: [{ type: i0.Input }],
        groupingExpressions: [{ type: i0.Input }],
        groupingExpansionState: [{ type: i0.Input }],
        hideGroupedColumns: [{ type: i0.Input }],
        dropAreaMessage: [{ type: i0.Input }],
        showGroupArea: [{ type: i0.Input }]
    };

    var IgxGridStateDirective = /** @class */ (function () {
        /**
         * @hidden
         */
        function IgxGridStateDirective(grid, resolver, viewRef) {
            this.grid = grid;
            this.resolver = resolver;
            this.viewRef = viewRef;
            this.featureKeys = [];
            this._options = {
                columns: true,
                filtering: true,
                advancedFiltering: true,
                sorting: true,
                groupBy: true,
                paging: true,
                cellSelection: true,
                rowSelection: true,
                columnSelection: true,
                rowPinning: true,
                expansion: true,
                rowIslands: true
            };
            this.FEATURES = {
                sorting: {
                    getFeatureState: function (context) {
                        var sortingState = context.currGrid.sortingExpressions;
                        sortingState.forEach(function (s) {
                            delete s.strategy;
                            delete s.owner;
                        });
                        return { sorting: sortingState };
                    },
                    restoreFeatureState: function (context, state) {
                        context.currGrid.sortingExpressions = state;
                    }
                },
                filtering: {
                    getFeatureState: function (context) {
                        var e_1, _a;
                        var filteringState = context.currGrid.filteringExpressionsTree;
                        if (filteringState) {
                            delete filteringState.owner;
                            try {
                                for (var _b = __values(filteringState.filteringOperands), _c = _b.next(); !_c.done; _c = _b.next()) {
                                    var item = _c.value;
                                    delete item.owner;
                                }
                            }
                            catch (e_1_1) { e_1 = { error: e_1_1 }; }
                            finally {
                                try {
                                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                }
                                finally { if (e_1) throw e_1.error; }
                            }
                        }
                        return { filtering: filteringState };
                    },
                    restoreFeatureState: function (context, state) {
                        var filterTree = context.createExpressionsTreeFromObject(state);
                        context.currGrid.filteringExpressionsTree = filterTree;
                    }
                },
                advancedFiltering: {
                    getFeatureState: function (context) {
                        var e_2, _a;
                        var filteringState = context.currGrid.advancedFilteringExpressionsTree;
                        var advancedFiltering;
                        if (filteringState) {
                            delete filteringState.owner;
                            try {
                                for (var _b = __values(filteringState.filteringOperands), _c = _b.next(); !_c.done; _c = _b.next()) {
                                    var item = _c.value;
                                    delete item.owner;
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                            advancedFiltering = filteringState;
                        }
                        else {
                            advancedFiltering = {};
                        }
                        return { advancedFiltering: advancedFiltering };
                    },
                    restoreFeatureState: function (context, state) {
                        var filterTree = context.createExpressionsTreeFromObject(state);
                        context.currGrid.advancedFilteringExpressionsTree = filterTree;
                    }
                },
                columns: {
                    getFeatureState: function (context) {
                        var gridColumns = context.currGrid.columns.map(function (c) { return ({
                            pinned: c.pinned,
                            sortable: c.sortable,
                            filterable: c.filterable,
                            editable: c.editable,
                            sortingIgnoreCase: c.sortingIgnoreCase,
                            filteringIgnoreCase: c.filteringIgnoreCase,
                            headerClasses: c.headerClasses,
                            headerGroupClasses: c.headerGroupClasses,
                            maxWidth: c.maxWidth,
                            groupable: c.groupable,
                            movable: c.movable,
                            hidden: c.hidden,
                            dataType: c.dataType,
                            hasSummary: c.hasSummary,
                            field: c.field,
                            width: c.width,
                            header: c.header,
                            resizable: c.resizable,
                            searchable: c.searchable,
                            selectable: c.selectable
                        }); });
                        return { columns: gridColumns };
                    },
                    restoreFeatureState: function (context, state) {
                        var newColumns = [];
                        var factory = context.resolver.resolveComponentFactory(IgxColumnComponent);
                        state.forEach(function (colState) {
                            var ref = factory.create(context.viewRef.injector);
                            Object.assign(ref.instance, colState);
                            ref.changeDetectorRef.detectChanges();
                            newColumns.push(ref.instance);
                        });
                        context.currGrid.columnList.reset(newColumns);
                        context.currGrid.columnList.notifyOnChanges();
                    }
                },
                groupBy: {
                    getFeatureState: function (context) {
                        var grid = context.currGrid;
                        var groupingExpressions = grid.groupingExpressions;
                        groupingExpressions.forEach(function (expr) {
                            delete expr.strategy;
                        });
                        var expansionState = grid.groupingExpansionState;
                        var groupsExpanded = grid.groupsExpanded;
                        return { groupBy: { expressions: groupingExpressions, expansion: expansionState, defaultExpanded: groupsExpanded } };
                    },
                    restoreFeatureState: function (context, state) {
                        var grid = context.currGrid;
                        grid.groupingExpressions = state.expressions;
                        if (grid.groupsExpanded !== state.defaultExpanded) {
                            grid.toggleAllGroupRows();
                        }
                        else {
                            grid.groupingExpansionState = state.expansion;
                        }
                    }
                },
                paging: {
                    getFeatureState: function (context) {
                        var pagingState = context.currGrid.pagingState;
                        return { paging: pagingState };
                    },
                    restoreFeatureState: function (context, state) {
                        if (context.currGrid.perPage !== state.recordsPerPage) {
                            context.currGrid.perPage = state.recordsPerPage;
                            context.currGrid.cdr.detectChanges();
                        }
                        context.currGrid.page = state.index;
                    }
                },
                rowSelection: {
                    getFeatureState: function (context) {
                        var selection = context.currGrid.selectedRows;
                        return { rowSelection: selection };
                    },
                    restoreFeatureState: function (context, state) {
                        context.currGrid.selectRows(state, true);
                    }
                },
                cellSelection: {
                    getFeatureState: function (context) {
                        var selection = context.currGrid.getSelectedRanges().map(function (range) { return ({ rowStart: range.rowStart, rowEnd: range.rowEnd, columnStart: range.columnStart, columnEnd: range.columnEnd }); });
                        return { cellSelection: selection };
                    },
                    restoreFeatureState: function (context, state) {
                        state.forEach(function (r) {
                            var range = { rowStart: r.rowStart, rowEnd: r.rowEnd, columnStart: r.columnStart, columnEnd: r.columnEnd };
                            context.currGrid.selectRange(range);
                        });
                    }
                },
                columnSelection: {
                    getFeatureState: function (context) {
                        var selection = context.currGrid.selectedColumns().map(function (c) { return c.field; });
                        return { columnSelection: selection };
                    },
                    restoreFeatureState: function (context, state) {
                        context.currGrid.deselectAllColumns();
                        context.currGrid.selectColumns(state);
                    }
                },
                rowPinning: {
                    getFeatureState: function (context) {
                        var pinned = context.currGrid.pinnedRows.map(function (x) { return x.rowID; });
                        return { rowPinning: pinned };
                    },
                    restoreFeatureState: function (context, state) {
                        // clear current state.
                        context.currGrid.pinnedRows.forEach(function (row) { return row.unpin(); });
                        state.forEach(function (rowID) { return context.currGrid.pinRow(rowID); });
                    }
                },
                pinningConfig: {
                    getFeatureState: function (context) { return ({ pinningConfig: context.currGrid.pinning }); },
                    restoreFeatureState: function (context, state) {
                        context.currGrid.pinning = state;
                    }
                },
                expansion: {
                    getFeatureState: function (context) {
                        var expansionStates = Array.from(context.currGrid.expansionStates);
                        return { expansion: expansionStates };
                    },
                    restoreFeatureState: function (context, state) {
                        var expansionStates = new Map(state);
                        context.currGrid.expansionStates = expansionStates;
                    }
                },
                rowIslands: {
                    getFeatureState: function (context) {
                        var _this = this;
                        var childGridStates = [];
                        var rowIslands = context.currGrid.allLayoutList;
                        if (rowIslands) {
                            rowIslands.forEach(function (rowIsland) {
                                var childGrids = rowIsland.rowIslandAPI.getChildGrids();
                                childGrids.forEach(function (chGrid) {
                                    var parentRowID = _this.getParentRowID(chGrid);
                                    context.currGrid = chGrid;
                                    if (context.currGrid) {
                                        var childGridState = context.buildState(context.featureKeys);
                                        childGridStates.push({ id: "" + rowIsland.id, parentRowID: parentRowID, state: childGridState });
                                    }
                                });
                            });
                        }
                        context.currGrid = context.grid;
                        return { rowIslands: childGridStates };
                    },
                    restoreFeatureState: function (context, state) {
                        var _this = this;
                        var rowIslands = context.currGrid.allLayoutList;
                        if (rowIslands) {
                            rowIslands.forEach(function (rowIsland) {
                                var childGrids = rowIsland.rowIslandAPI.getChildGrids();
                                childGrids.forEach(function (chGrid) {
                                    var parentRowID = _this.getParentRowID(chGrid);
                                    context.currGrid = chGrid;
                                    var childGridState = state.find(function (st) { return st.id === rowIsland.id && st.parentRowID === parentRowID; });
                                    if (childGridState && context.currGrid) {
                                        context.restoreGridState(childGridState.state, context.featureKeys);
                                    }
                                });
                            });
                        }
                        context.currGrid = context.grid;
                    },
                    /**
                     * Traverses the hierarchy up to the root grid to return the ID of the expanded row.
                     */
                    getParentRowID: function (grid) {
                        var childGrid;
                        var childRow;
                        while (grid.parent) {
                            childRow = grid.childRow;
                            childGrid = grid;
                            grid = grid.parent;
                        }
                        return grid.hgridAPI.getParentRowId(childGrid);
                    }
                }
            };
        }
        Object.defineProperty(IgxGridStateDirective.prototype, "options", {
            /**
             *  An object with options determining if a certain feature state should be saved.
             * ```html
             * <igx-grid [igxGridState]="options"></igx-grid>
             * ```
             * ```typescript
             * public options = {selection: false, advancedFiltering: false};
             * ```
             */
            get: function () {
                return this._options;
            },
            set: function (value) {
                Object.assign(this._options, value);
                if (!(this.grid instanceof IgxGridComponent)) {
                    delete this._options.groupBy;
                }
                else {
                    delete this._options.rowIslands;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Gets the state of a feature or states of all grid features, unless a certain feature is disabled through the `options` property.
         *
         * @param `serialize` determines whether the returned object will be serialized to JSON string. Default value is true.
         * @param `feature` string or array of strings determining the features to be added in the state. If skipped, all features are added.
         * @returns Returns the serialized to JSON string IGridState object, or the non-serialized IGridState object.
         * ```html
         * <igx-grid [igxGridState]="options"></igx-grid>
         * ```
         * ```typescript
         * @ViewChild(IgxGridStateDirective, { static: true }) public state;
         * let state = this.state.getState(); // returns string
         * let state = this.state(false) // returns `IGridState` object
         * ```
         */
        IgxGridStateDirective.prototype.getState = function (serialize, features) {
            if (serialize === void 0) { serialize = true; }
            var state;
            this.currGrid = this.grid;
            this.state = state = this.buildState(features);
            if (serialize) {
                state = JSON.stringify(state, this.stringifyCallback);
            }
            return state;
        };
        /**
         * Restores grid features' state based on the IGridState object passed as an argument.
         *
         * @param IGridState object to restore state from.
         * @returns
         * ```html
         * <igx-grid [igxGridState]="options"></igx-grid>
         * ```
         * ```typescript
         * @ViewChild(IgxGridStateDirective, { static: true }) public state;
         * this.state.setState(gridState);
         * ```
         */
        IgxGridStateDirective.prototype.setState = function (state, features) {
            if (typeof state === 'string') {
                state = JSON.parse(state);
            }
            this.currGrid = this.grid;
            this.restoreGridState(state, features);
            this.grid.cdr.detectChanges(); // TODO
        };
        /**
         * Builds an IGridState object.
         */
        IgxGridStateDirective.prototype.buildState = function (keys) {
            var _this = this;
            this.applyFeatures(keys);
            var gridState = {};
            this.featureKeys.forEach(function (f) {
                if (_this.options[f]) {
                    if (!(_this.grid instanceof IgxGridComponent) && f === 'groupBy') {
                        return;
                    }
                    var feature = _this.getFeature(f);
                    var featureState = feature.getFeatureState(_this);
                    gridState = Object.assign(gridState, featureState);
                }
            });
            return gridState;
        };
        /**
         * The method that calls corresponding methods to restore features from the passed IGridState object.
         */
        IgxGridStateDirective.prototype.restoreGridState = function (state, features) {
            var _this = this;
            this.applyFeatures(features);
            this.featureKeys.forEach(function (f) {
                if (_this.options[f]) {
                    var featureState = state[f];
                    if (featureState) {
                        var feature = _this.getFeature(f);
                        feature.restoreFeatureState(_this, featureState);
                    }
                }
            });
        };
        /**
         * Returns a collection of all grid features.
         */
        IgxGridStateDirective.prototype.applyFeatures = function (keys) {
            var e_3, _a;
            this.featureKeys = [];
            if (!keys) {
                try {
                    for (var _b = __values(Object.keys(this.options)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var key = _c.value;
                        this.featureKeys.push(key);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
            else if (Array.isArray(keys)) {
                this.featureKeys = __spread(keys);
            }
            else {
                this.featureKeys.push(keys);
            }
        };
        /**
         * This method builds a FilteringExpressionsTree from a provided object.
         */
        IgxGridStateDirective.prototype.createExpressionsTreeFromObject = function (exprTreeObject) {
            var e_4, _a;
            if (!exprTreeObject || !exprTreeObject.filteringOperands) {
                return null;
            }
            var expressionsTree = new FilteringExpressionsTree(exprTreeObject.operator, exprTreeObject.fieldName);
            var _loop_1 = function (item) {
                // Check if item is an expressions tree or a single expression.
                if (item.filteringOperands) {
                    var subTree = this_1.createExpressionsTreeFromObject(item);
                    expressionsTree.filteringOperands.push(subTree);
                }
                else {
                    var expr_1 = item;
                    var dataType = void 0;
                    if (this_1.currGrid.columnList.length > 0) {
                        dataType = this_1.currGrid.columnList.find(function (c) { return c.field === expr_1.fieldName; }).dataType;
                    }
                    else {
                        dataType = this_1.state.columns.find(function (c) { return c.field === expr_1.fieldName; }).dataType;
                    }
                    // when ESF, values are stored in Set.
                    // First those values are converted to an array before returning string in the stringifyCallback
                    // now we need to convert those back to Set
                    if (Array.isArray(expr_1.searchVal)) {
                        expr_1.searchVal = new Set(expr_1.searchVal);
                    }
                    else {
                        expr_1.searchVal = (dataType === 'date') ? new Date(Date.parse(expr_1.searchVal)) : expr_1.searchVal;
                    }
                    expr_1.condition = this_1.generateFilteringCondition(dataType, expr_1.condition.name);
                    expressionsTree.filteringOperands.push(expr_1);
                }
            };
            var this_1 = this;
            try {
                for (var _b = __values(exprTreeObject.filteringOperands), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var item = _c.value;
                    _loop_1(item);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
            return expressionsTree;
        };
        /**
         * Returns the filtering logic function for a given dataType and condition (contains, greaterThan, etc.)
         */
        IgxGridStateDirective.prototype.generateFilteringCondition = function (dataType, name) {
            var filters;
            switch (dataType) {
                case DataType.Boolean:
                    filters = IgxBooleanFilteringOperand.instance();
                    break;
                case DataType.Number:
                    filters = IgxNumberFilteringOperand.instance();
                    break;
                case DataType.Date:
                    filters = IgxDateFilteringOperand.instance();
                    break;
                case DataType.String:
                default:
                    filters = IgxStringFilteringOperand.instance();
                    break;
            }
            return filters.condition(name);
        };
        IgxGridStateDirective.prototype.stringifyCallback = function (key, val) {
            if (key === 'searchVal' && val instanceof Set) {
                return Array.from(val);
            }
            return val;
        };
        IgxGridStateDirective.prototype.getFeature = function (key) {
            var feature = this.FEATURES[key];
            return feature;
        };
        return IgxGridStateDirective;
    }());
    IgxGridStateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxGridState]'
                },] }
    ];
    IgxGridStateDirective.ctorParameters = function () { return [
        { type: IgxGridBaseDirective, decorators: [{ type: i0.Host }, { type: i0.Optional }] },
        { type: i0.ComponentFactoryResolver },
        { type: i0.ViewContainerRef }
    ]; };
    IgxGridStateDirective.propDecorators = {
        options: [{ type: i0.Input, args: ['igxGridState',] }]
    };
    /**
     * @hidden
     */
    var IgxGridStateModule = /** @class */ (function () {
        function IgxGridStateModule() {
        }
        return IgxGridStateModule;
    }());
    IgxGridStateModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxGridStateDirective],
                    exports: [IgxGridStateDirective]
                },] }
    ];

    var IgxGridSharedModules = /** @class */ (function () {
        function IgxGridSharedModules() {
        }
        return IgxGridSharedModules;
    }());
    IgxGridSharedModules.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i2.CommonModule,
                        forms.FormsModule,
                        IgxButtonModule,
                        IgxDatePickerModule,
                        IgxIconModule,
                        IgxRippleModule,
                        IgxInputGroupModule,
                        IgxFocusModule,
                        IgxToggleModule,
                        IgxForOfModule,
                        IgxTemplateOutletModule,
                        IgxTextHighlightModule,
                        IgxTextSelectionModule,
                        IgxCheckboxModule,
                        IgxBadgeModule,
                        IgxChipsModule,
                        IgxDragDropModule,
                        IgxDropDownModule,
                        IgxButtonGroupModule,
                        IgxProgressBarModule,
                        IgxSelectModule,
                        IgxGridStateModule,
                        IgxSnackbarModule
                    ],
                    exports: [
                        i2.CommonModule,
                        forms.FormsModule,
                        IgxButtonModule,
                        IgxDatePickerModule,
                        IgxIconModule,
                        IgxRippleModule,
                        IgxInputGroupModule,
                        IgxFocusModule,
                        IgxToggleModule,
                        IgxForOfModule,
                        IgxTemplateOutletModule,
                        IgxTextHighlightModule,
                        IgxGridStateModule,
                        IgxTextSelectionModule,
                        IgxCheckboxModule,
                        IgxBadgeModule,
                        IgxChipsModule,
                        IgxDragDropModule,
                        IgxDropDownModule,
                        IgxButtonGroupModule,
                        IgxProgressBarModule,
                        IgxSelectModule,
                        IgxSnackbarModule
                    ]
                },] }
    ];

    var IgxSummaryDataPipe = /** @class */ (function () {
        function IgxSummaryDataPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxSummaryDataPipe.prototype.transform = function (id, trigger) {
            if (trigger === void 0) { trigger = 0; }
            var summaryService = this.gridAPI.grid.summaryService;
            return summaryService.calculateSummaries(summaryService.rootSummaryID, this.gridAPI.get_summary_data());
        };
        return IgxSummaryDataPipe;
    }());
    IgxSummaryDataPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'igxGridSummaryDataPipe',
                    pure: true
                },] }
    ];
    IgxSummaryDataPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };

    var IgxGridSummaryModule = /** @class */ (function () {
        function IgxGridSummaryModule() {
        }
        return IgxGridSummaryModule;
    }());
    IgxGridSummaryModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxSummaryCellComponent,
                        IgxSummaryRowComponent,
                        IgxSummaryDataPipe
                    ],
                    imports: [
                        IgxGridPipesModule,
                        IgxGridSharedModules
                    ],
                    exports: [
                        IgxSummaryCellComponent,
                        IgxSummaryRowComponent,
                        IgxSummaryDataPipe
                    ]
                },] }
    ];

    var IgxColumnActionsBaseDirective = /** @class */ (function () {
        function IgxColumnActionsBaseDirective() {
        }
        return IgxColumnActionsBaseDirective;
    }());
    IgxColumnActionsBaseDirective.decorators = [
        { type: i0.Directive }
    ];

    var IgxColumnHidingDirective = /** @class */ (function (_super) {
        __extends(IgxColumnHidingDirective, _super);
        function IgxColumnHidingDirective(columnActions) {
            var _this = _super.call(this) || this;
            _this.columnActions = columnActions;
            /**
             * @hidden @internal
             */
            _this.actionEnabledColumnsFilter = function (c) { return !c.disableHiding; };
            columnActions.actionsDirective = _this;
            return _this;
        }
        Object.defineProperty(IgxColumnHidingDirective.prototype, "checkAllLabel", {
            /**
             * @hidden @internal
             */
            get: function () {
                var _a, _b;
                return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_hiding_check_all_label) !== null && _b !== void 0 ? _b : 'Show All';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnHidingDirective.prototype, "uncheckAllLabel", {
            /**
             * @hidden @internal
             */
            get: function () {
                var _a, _b;
                return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_hiding_uncheck_all_label) !== null && _b !== void 0 ? _b : 'Hide All';
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxColumnHidingDirective.prototype.checkAll = function () {
            this.columnActions.filteredColumns.forEach(function (c) { return c.toggleVisibility(false); });
        };
        /**
         * @hidden @internal
         */
        IgxColumnHidingDirective.prototype.uncheckAll = function () {
            this.columnActions.filteredColumns.forEach(function (c) { return c.toggleVisibility(true); });
        };
        /**
         * @hidden @internal
         */
        IgxColumnHidingDirective.prototype.columnChecked = function (column) {
            return !column.hidden;
        };
        /**
         * @hidden @internal
         */
        IgxColumnHidingDirective.prototype.toggleColumn = function (column) {
            column.toggleVisibility();
        };
        Object.defineProperty(IgxColumnHidingDirective.prototype, "allChecked", {
            get: function () {
                var _this = this;
                return this.columnActions.filteredColumns.every(function (col) { return !_this.columnChecked(col); });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnHidingDirective.prototype, "allUnchecked", {
            get: function () {
                var _this = this;
                return this.columnActions.filteredColumns.every(function (col) { return _this.columnChecked(col); });
            },
            enumerable: false,
            configurable: true
        });
        return IgxColumnHidingDirective;
    }(IgxColumnActionsBaseDirective));
    IgxColumnHidingDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxColumnHiding]'
                },] }
    ];
    IgxColumnHidingDirective.ctorParameters = function () { return [
        { type: IgxColumnActionsComponent, decorators: [{ type: i0.Inject, args: [IgxColumnActionsComponent,] }] }
    ]; };

    var IgxColumnPinningDirective = /** @class */ (function (_super) {
        __extends(IgxColumnPinningDirective, _super);
        function IgxColumnPinningDirective(columnActions) {
            var _this = _super.call(this) || this;
            _this.columnActions = columnActions;
            /**
             * @hidden @internal
             */
            _this.actionEnabledColumnsFilter = function (c) { return !c.disablePinning && !c.level; };
            columnActions.actionsDirective = _this;
            return _this;
        }
        Object.defineProperty(IgxColumnPinningDirective.prototype, "checkAllLabel", {
            /**
             * @hidden @internal
             */
            get: function () {
                var _a, _b;
                return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_pinning_check_all_label) !== null && _b !== void 0 ? _b : 'Pin All';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnPinningDirective.prototype, "uncheckAllLabel", {
            /**
             * @hidden @internal
             */
            get: function () {
                var _a, _b;
                return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_pinning_uncheck_all_label) !== null && _b !== void 0 ? _b : 'Unpin All';
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxColumnPinningDirective.prototype.checkAll = function () {
            this.columnActions.filteredColumns.forEach(function (c) { return c.pinned = true; });
        };
        /**
         * @hidden @internal
         */
        IgxColumnPinningDirective.prototype.uncheckAll = function () {
            this.columnActions.filteredColumns.forEach(function (c) { return c.pinned = false; });
        };
        /**
         * @hidden @internal
         */
        IgxColumnPinningDirective.prototype.columnChecked = function (column) {
            return column.pinned;
        };
        /**
         * @hidden @internal
         */
        IgxColumnPinningDirective.prototype.toggleColumn = function (column) {
            column.pinned = !column.pinned;
        };
        Object.defineProperty(IgxColumnPinningDirective.prototype, "allUnchecked", {
            get: function () {
                var _this = this;
                return !this.columnActions.filteredColumns.some(function (col) { return !_this.columnChecked(col); });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnPinningDirective.prototype, "allChecked", {
            get: function () {
                var _this = this;
                return !this.columnActions.filteredColumns.some(function (col) { return _this.columnChecked(col); });
            },
            enumerable: false,
            configurable: true
        });
        return IgxColumnPinningDirective;
    }(IgxColumnActionsBaseDirective));
    IgxColumnPinningDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxColumnPinning]'
                },] }
    ];
    IgxColumnPinningDirective.ctorParameters = function () { return [
        { type: IgxColumnActionsComponent, decorators: [{ type: i0.Inject, args: [IgxColumnActionsComponent,] }] }
    ]; };

    var IgxColumnActionsModule = /** @class */ (function () {
        function IgxColumnActionsModule() {
        }
        return IgxColumnActionsModule;
    }());
    IgxColumnActionsModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxColumnHidingDirective,
                        IgxColumnPinningDirective,
                        IgxColumnActionsComponent,
                    ],
                    imports: [
                        IgxGridSharedModules,
                        IgxGridPipesModule
                    ],
                    exports: [
                        IgxColumnHidingDirective,
                        IgxColumnPinningDirective,
                        IgxColumnActionsComponent
                    ]
                },] }
    ];

    /**
     * Provides a pre-configured button to open the advanced filtering dialog of the grid.
     *
     *
     * @igxModule IgxGridToolbarModule
     * @igxParent IgxGridToolbarComponent
     *
     * @example
     * ```html
     * <igx-grid-toolbar-advanced-filtering></igx-grid-toolbar-advanced-filtering>
     * <igx-grid-toolbar-advanced-filtering>Custom text</igx-grid-toolbar-advanced-filtering>
     * ```
     */
    var IgxGridToolbarAdvancedFilteringComponent = /** @class */ (function () {
        function IgxGridToolbarAdvancedFilteringComponent(toolbar) {
            this.toolbar = toolbar;
        }
        Object.defineProperty(IgxGridToolbarAdvancedFilteringComponent.prototype, "grid", {
            /**
             * Returns the grid containing this component.
             */
            get: function () {
                return this.toolbar.grid;
            },
            enumerable: false,
            configurable: true
        });
        return IgxGridToolbarAdvancedFilteringComponent;
    }());
    IgxGridToolbarAdvancedFilteringComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-grid-toolbar-advanced-filtering',
                    template: "<button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" name=\"btnAdvancedFiltering\" igxRipple\n    [title]=\"grid?.resourceStrings.igx_grid_toolbar_advanced_filtering_button_tooltip\"\n    (click)=\"grid.openAdvancedFilteringDialog()\"\n    [ngClass]=\"grid.advancedFilteringExpressionsTree ? 'igx-grid-toolbar__adv-filter--filtered' : 'igx-grid-toolbar__adv-filter'\">\n    <igx-icon>filter_list</igx-icon>\n    <span #ref>\n        <ng-content></ng-content>\n    </span>\n    <span *ngIf=\"!ref.childNodes.length\">{{ grid?.resourceStrings.igx_grid_toolbar_advanced_filtering_button_label }}</span>\n</button>\n"
                },] }
    ];
    IgxGridToolbarAdvancedFilteringComponent.ctorParameters = function () { return [
        { type: IgxGridToolbarComponent, decorators: [{ type: i0.Host }] }
    ]; };

    /**
     * Base class for the pinning/hiding column and exporter actions.
     *
     * @hidden @internal
     */
    var BaseToolbarDirective = /** @class */ (function () {
        function BaseToolbarDirective(toolbar) {
            this.toolbar = toolbar;
            /**
             * Emits an event before the toggle container is opened.
             */
            this.opening = new i0.EventEmitter();
            /**
             * Emits an event after the toggle container is opened.
             */
            this.opened = new i0.EventEmitter();
            /**
             * Emits an event before the toggle container is closed.
             */
            this.closing = new i0.EventEmitter();
            /**
             * Emits an event after the toggle container is closed.
             */
            this.closed = new i0.EventEmitter();
            /**
             * Emits when after a column's checked state is changed
             */
            this.columnToggle = new i0.EventEmitter();
            this.$destroyer = new rxjs.Subject();
        }
        Object.defineProperty(BaseToolbarDirective.prototype, "grid", {
            /**
             * Returns the grid containing this component.
             */
            get: function () {
                return this.toolbar.grid;
            },
            enumerable: false,
            configurable: true
        });
        BaseToolbarDirective.prototype.ngOnDestroy = function () {
            this.$destroyer.next(true);
        };
        /** @hidden @internal */
        BaseToolbarDirective.prototype.toggle = function (anchorElement, toggleRef, actions) {
            var _this = this;
            if (actions) {
                this._setupListeners(toggleRef, actions);
                var setHeight = function () { var _a; return actions.columnsAreaMaxHeight = (_a = _this.columnListHeight) !== null && _a !== void 0 ? _a : Math.max(_this.grid.calcHeight, 200) + "px"; };
                toggleRef.onOpening.pipe(operators.first()).subscribe(setHeight);
            }
            toggleRef.toggle(Object.assign(Object.assign({}, _makeOverlaySettings()), { target: anchorElement, outlet: this.grid.outlet,
                excludeFromOutsideClick: [anchorElement] }));
        };
        /** @hidden @internal */
        BaseToolbarDirective.prototype.focusSearch = function (columnActions) {
            var _a;
            (_a = columnActions.querySelector('input')) === null || _a === void 0 ? void 0 : _a.focus();
        };
        BaseToolbarDirective.prototype._setupListeners = function (toggleRef, actions) {
            var _this = this;
            if (actions) {
                if (!this.$sub || this.$sub.closed) {
                    this.$sub = actions.onColumnToggled.subscribe(function (event) { return _this.columnToggle.emit(event); });
                }
                else {
                    this.$sub.unsubscribe();
                }
            }
            /** The if statement prevents emitting open and close events twice  */
            if (toggleRef.collapsed) {
                toggleRef.onOpening.pipe(operators.first(), operators.takeUntil(this.$destroyer)).subscribe(function (event) { return _this.opening.emit(event); });
                toggleRef.onOpened.pipe(operators.first(), operators.takeUntil(this.$destroyer)).subscribe(function (event) { return _this.opened.emit(event); });
            }
            else {
                toggleRef.onClosing.pipe(operators.first(), operators.takeUntil(this.$destroyer)).subscribe(function (event) { return _this.closing.emit(event); });
                toggleRef.onClosed.pipe(operators.first(), operators.takeUntil(this.$destroyer)).subscribe(function (event) { return _this.closed.emit(event); });
            }
        };
        return BaseToolbarDirective;
    }());
    BaseToolbarDirective.decorators = [
        { type: i0.Directive }
    ];
    BaseToolbarDirective.ctorParameters = function () { return [
        { type: IgxGridToolbarComponent, decorators: [{ type: i0.Host }] }
    ]; };
    BaseToolbarDirective.propDecorators = {
        columnListHeight: [{ type: i0.Input }],
        title: [{ type: i0.Input }],
        prompt: [{ type: i0.Input }],
        opening: [{ type: i0.Output }],
        opened: [{ type: i0.Output }],
        closing: [{ type: i0.Output }],
        closed: [{ type: i0.Output }],
        columnToggle: [{ type: i0.Output }]
    };
    /**
     * @hidden @internal
     * Base class for pinning/hiding column actions
     */
    var BaseToolbarColumnActionsDirective = /** @class */ (function (_super) {
        __extends(BaseToolbarColumnActionsDirective, _super);
        function BaseToolbarColumnActionsDirective() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.hideFilter = false;
            _this.filterCriteria = '';
            _this.columnDisplayOrder = ColumnDisplayOrder.DisplayOrder;
            _this.columnsAreaMaxHeight = '100%';
            _this.indentetion = 30;
            return _this;
        }
        BaseToolbarColumnActionsDirective.prototype.checkAll = function () {
            this.columnActionsUI.checkAllColumns();
        };
        BaseToolbarColumnActionsDirective.prototype.uncheckAll = function () {
            this.columnActionsUI.uncheckAllColumns();
        };
        return BaseToolbarColumnActionsDirective;
    }(BaseToolbarDirective));
    BaseToolbarColumnActionsDirective.decorators = [
        { type: i0.Directive }
    ];
    BaseToolbarColumnActionsDirective.propDecorators = {
        hideFilter: [{ type: i0.Input }],
        filterCriteria: [{ type: i0.Input }],
        columnDisplayOrder: [{ type: i0.Input }],
        columnsAreaMaxHeight: [{ type: i0.Input }],
        uncheckAllText: [{ type: i0.Input }],
        checkAllText: [{ type: i0.Input }],
        indentetion: [{ type: i0.Input }]
    };
    var _makeOverlaySettings = function () {
        var positionSettings = {
            horizontalDirection: exports.HorizontalAlignment.Left,
            horizontalStartPoint: exports.HorizontalAlignment.Right,
            verticalDirection: exports.VerticalAlignment.Bottom,
            verticalStartPoint: exports.VerticalAlignment.Bottom
        };
        return {
            positionStrategy: new ConnectedPositioningStrategy(positionSettings),
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnEscape: true,
            closeOnOutsideClick: true
        };
    };
    var ɵ0$5 = _makeOverlaySettings;

    /**
     * Provides a pre-configured exporter component for the grid.
     *
     * @remarks
     * This component still needs the actual exporter service(s) provided in the DI chain
     * in order to export something.
     *
     * @igxModule IgxGridToolbarModule
     * @igxParent IgxGridToolbarComponent
     *
     */
    var IgxGridToolbarExporterComponent = /** @class */ (function (_super) {
        __extends(IgxGridToolbarExporterComponent, _super);
        function IgxGridToolbarExporterComponent(toolbar, excelExporter, csvExporter) {
            var _this = _super.call(this, toolbar) || this;
            _this.toolbar = toolbar;
            _this.excelExporter = excelExporter;
            _this.csvExporter = csvExporter;
            /**
             * Show entry for CSV export.
             */
            _this.exportCSV = true;
            /**
             * Show entry for Excel export.
             */
            _this.exportExcel = true;
            /**
             * The name for the exported file.
             */
            _this.filename = 'ExportedData';
            /**
             * Emitted when starting an export operation. Re-emitted additionally
             * by the grid itself.
             */
            _this.exportStarted = new i0.EventEmitter();
            /**
             * Emitted on successful ending of an export operation.
             */
            _this.exportEnded = new i0.EventEmitter();
            /**
             * Indicates whether there is an export in progress.
             */
            _this.isExporting = false;
            return _this;
        }
        Object.defineProperty(IgxGridToolbarExporterComponent.prototype, "hasCsvExporter", {
            /**
             * Returns whether the CSV exporter service is available in the DI chain.
             */
            get: function () {
                return !!this.csvExporter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridToolbarExporterComponent.prototype, "hasExcelExporter", {
            /**
             * Returns whether the Excel exporter service is available in the DI chain.
             */
            get: function () {
                return !!this.excelExporter;
            },
            enumerable: false,
            configurable: true
        });
        IgxGridToolbarExporterComponent.prototype.export = function (type, toggleRef) {
            var _this = this;
            var options;
            var exporter;
            toggleRef === null || toggleRef === void 0 ? void 0 : toggleRef.close();
            switch (type) {
                case 'csv':
                    options = new IgxCsvExporterOptions(this.filename, exports.CsvFileTypes.CSV);
                    exporter = this.csvExporter;
                    break;
                case 'excel':
                    options = new IgxExcelExporterOptions(this.filename);
                    exporter = this.excelExporter;
            }
            var args = { exporter: exporter, options: options, grid: this.grid, cancel: false };
            this.exportStarted.emit(args);
            this.grid.onToolbarExporting.emit(args);
            this.isExporting = true;
            this.toolbar.showProgress = true;
            if (args.cancel) {
                return;
            }
            exporter.exportEnded.pipe(operators.first()).subscribe(function () {
                _this.exportEnded.emit();
                _this.isExporting = false;
                _this.toolbar.showProgress = false;
            });
            exporter.export(this.grid, options);
        };
        return IgxGridToolbarExporterComponent;
    }(BaseToolbarDirective));
    IgxGridToolbarExporterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-grid-toolbar-exporter',
                    template: "<div class=\"igx-grid-toolbar__dropdown\" id=\"btnExport\">\n    <button [title]=\"grid?.resourceStrings.igx_grid_toolbar_exporter_button_tooltip\" [disabled]=\"isExporting\"\n        igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" igxRipple #btn (click)=\"toggle(btn, toggleRef)\">\n        <igx-icon>import_export</igx-icon>\n        <span #ref>\n            <ng-content></ng-content>\n        </span>\n        <span *ngIf=\"!ref.childNodes.length\">\n            {{ grid.exportText || grid?.resourceStrings.igx_grid_toolbar_exporter_button_label }}\n        </span>\n        <igx-icon>arrow_drop_down</igx-icon>\n    </button>\n\n    <ul class=\"igx-grid-toolbar__dd-list\" igxToggle #toggleRef=\"toggle\">\n        <li *ngIf=\"grid.exportExcel || exportExcel\" #btnExportExcel id=\"btnExportExcel\"\n            class=\"igx-grid-toolbar__dd-list-items\" igxRipple (click)=\"export('excel', toggleRef)\">\n            <ng-template #excel>\n                <ng-content select=[excelText],excel-text></ng-content>\n            </ng-template>\n            <excel-text *ngIf=\"!hasExcelAttr\">\n                {{ grid.exportExcelText || grid?.resourceStrings.igx_grid_toolbar_exporter_excel_entry_text}}\n            </excel-text>\n            <ng-container *ngTemplateOutlet=\"excel\"></ng-container>\n        </li>\n\n        <li *ngIf=\"grid.exportCsv || exportCSV\" #btnExportCsv id=\"btnExportCsv\" class=\"igx-grid-toolbar__dd-list-items\"\n            igxRipple (click)=\"export('csv', toggleRef)\">\n            <ng-template #csv>\n                <ng-content select=[csvText],csv-text></ng-content>\n            </ng-template>\n            <csv-text *ngIf=\"!hasCSVAttr\">\n                {{ grid.exportCsvText || grid?.resourceStrings.igx_grid_toolbar_exporter_csv_entry_text }}</csv-text>\n            <ng-container *ngTemplateOutlet=\"csv\"></ng-container>\n        </li>\n    </ul>\n</div>\n"
                },] }
    ];
    IgxGridToolbarExporterComponent.ctorParameters = function () { return [
        { type: IgxGridToolbarComponent, decorators: [{ type: i0.Host }] },
        { type: IgxExcelExporterService, decorators: [{ type: i0.Optional }] },
        { type: IgxCsvExporterService, decorators: [{ type: i0.Optional }] }
    ]; };
    IgxGridToolbarExporterComponent.propDecorators = {
        hasExcelAttr: [{ type: i0.ContentChild, args: [IgxExcelTextDirective,] }],
        hasCSVAttr: [{ type: i0.ContentChild, args: [IgxCSVTextDirective,] }],
        exportCSV: [{ type: i0.Input }],
        exportExcel: [{ type: i0.Input }],
        filename: [{ type: i0.Input }],
        exportStarted: [{ type: i0.Output }],
        exportEnded: [{ type: i0.Output }]
    };

    /**
     * Provides a pre-configured column hiding component for the grid.
     *
     *
     * @igxModule IgxGridToolbarModule
     * @igxParent IgxGridToolbarComponent
     *
     * @example
     * ```html
     *  <igx-grid-toolbar-hiding></igx-grid-toolbar-hiding>
     * ```
     */
    var IgxGridToolbarHidingComponent = /** @class */ (function (_super) {
        __extends(IgxGridToolbarHidingComponent, _super);
        function IgxGridToolbarHidingComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IgxGridToolbarHidingComponent.prototype, "content", {
            set: function (content) {
                this.columnActionsUI = content;
            },
            enumerable: false,
            configurable: true
        });
        return IgxGridToolbarHidingComponent;
    }(BaseToolbarColumnActionsDirective));
    IgxGridToolbarHidingComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-grid-toolbar-hiding',
                    template: "<ng-container *ngIf=\"grid.rendered$ | async\">\n    <button [title]=\"grid?.resourceStrings.igx_grid_toolbar_hiding_button_tooltip\" #btn igxButton=\"outlined\"\n        name=\"btnColumnHiding\" (click)=\"toggle(btn, ref, actions)\" [displayDensity]=\"grid.displayDensity\">\n        <igx-icon>{{ !grid.hiddenColumnsCount ? 'visibility' : 'visibility_off' }}</igx-icon>\n        <span>{{ grid.hiddenColumnsCount }}</span>\n        <span>{{ grid.hiddenColumnsText }}</span>\n    </button>\n    <igx-column-actions #actions igxColumnHiding igxToggle (onOpened)=\"focusSearch(ref.element)\" #ref=\"toggle\"\n        [grid]=\"grid\" [title]=\"grid.columnHidingTitleInternal || title || grid?.resourceStrings.igx_grid_toolbar_hiding_title\"\n        [filterColumnsPrompt]=\"prompt || grid?.resourceStrings.igx_grid_toolbar_actions_filter_prompt\"\n        [hideFilter]=\"hideFilter\" [filterCriteria]=\"filterCriteria\" [columnDisplayOrder]=\"columnDisplayOrder\" [columnsAreaMaxHeight]=\"columnsAreaMaxHeight\"\n        [uncheckAllText]=\"uncheckAllText\" [checkAllText]=\"checkAllText\" [indentation]=\"indentetion\">\n    </igx-column-actions>\n</ng-container>\n"
                },] }
    ];
    IgxGridToolbarHidingComponent.propDecorators = {
        content: [{ type: i0.ViewChild, args: [IgxColumnHidingDirective, { read: IgxColumnActionsComponent },] }]
    };

    /**
     * Provides a pre-configured column pinning component for the grid.
     *
     *
     * @igxModule IgxGridToolbarModule
     * @igxParent IgxGridToolbarComponent
     *
     * @example
     * ```html
     *  <igx-grid-toolbar-pinning></igx-grid-toolbar-pinning>
     * ```
     */
    var IgxGridToolbarPinningComponent = /** @class */ (function (_super) {
        __extends(IgxGridToolbarPinningComponent, _super);
        function IgxGridToolbarPinningComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IgxGridToolbarPinningComponent.prototype, "content", {
            set: function (content) {
                this.columnActionsUI = content;
            },
            enumerable: false,
            configurable: true
        });
        return IgxGridToolbarPinningComponent;
    }(BaseToolbarColumnActionsDirective));
    IgxGridToolbarPinningComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-grid-toolbar-pinning',
                    template: "<ng-container *ngIf=\"grid.rendered$ | async\">\n    <button [title]=\"grid?.resourceStrings.igx_grid_toolbar_pinning_button_tooltip\" #btn igxButton=\"outlined\"\n        name=\"btnColumnPinning\" (click)=\"toggle(btn, ref, actions)\" [displayDensity]=\"grid.displayDensity\">\n        <igx-icon family=\"imx-icons\" [name]=\"!grid.pinnedColumnsCount ? 'unpin-left' : 'pin-left'\"></igx-icon>\n        <span>{{ grid.pinnedColumnsCount }}</span>\n        <span>{{ grid.pinnedColumnsTextInternal }}</span>\n    </button>\n    <igx-column-actions #actions igxColumnPinning igxToggle (onOpened)=\"focusSearch(ref.element)\" #ref=\"toggle\"\n        [grid]=\"grid\" [title]=\"grid.columnPinningTitleInternal || title || grid?.resourceStrings.igx_grid_toolbar_pinning_title\"\n        [filterColumnsPrompt]=\"prompt || grid?.resourceStrings.igx_grid_toolbar_actions_filter_prompt\"\n        [hideFilter]=\"hideFilter\" [filterCriteria]=\"filterCriteria\" [columnDisplayOrder]=\"columnDisplayOrder\" [columnsAreaMaxHeight]=\"columnsAreaMaxHeight\"\n        [uncheckAllText]=\"uncheckAllText\" [checkAllText]=\"checkAllText\" [indentation]=\"indentetion\">\n    </igx-column-actions>\n</ng-container>\n"
                },] }
    ];
    IgxGridToolbarPinningComponent.propDecorators = {
        content: [{ type: i0.ViewChild, args: [IgxColumnPinningDirective, { read: IgxColumnActionsComponent },] }]
    };

    var IgxGridToolbarModule = /** @class */ (function () {
        function IgxGridToolbarModule() {
        }
        return IgxGridToolbarModule;
    }());
    IgxGridToolbarModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxCSVTextDirective,
                        IgxExcelTextDirective,
                        IgxGridToolbarActionsDirective,
                        IgxGridToolbarAdvancedFilteringComponent,
                        IgxGridToolbarComponent,
                        IgxGridToolbarExporterComponent,
                        IgxGridToolbarHidingComponent,
                        IgxGridToolbarPinningComponent,
                        IgxGridToolbarTitleDirective,
                        IgxGridToolbarDirective
                    ],
                    imports: [
                        IgxColumnActionsModule,
                        IgxGridSharedModules
                    ],
                    exports: [
                        IgxCSVTextDirective,
                        IgxExcelTextDirective,
                        IgxGridToolbarActionsDirective,
                        IgxGridToolbarAdvancedFilteringComponent,
                        IgxGridToolbarComponent,
                        IgxGridToolbarExporterComponent,
                        IgxGridToolbarHidingComponent,
                        IgxGridToolbarPinningComponent,
                        IgxGridToolbarTitleDirective,
                        IgxGridToolbarDirective
                    ]
                },] }
    ];

    var IgxColumnLayoutComponent = /** @class */ (function (_super) {
        __extends(IgxColumnLayoutComponent, _super);
        function IgxColumnLayoutComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.childrenVisibleIndexes = [];
            return _this;
        }
        Object.defineProperty(IgxColumnLayoutComponent.prototype, "width", {
            /**
             * Gets the width of the column layout.
             * ```typescript
             * let columnGroupWidth = this.columnGroup.width;
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                var width = this.getFilledChildColumnSizes(this.children).reduce(function (acc, val) { return acc + parseInt(val, 10); }, 0);
                return width;
            },
            set: function (val) { },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnLayoutComponent.prototype, "columnLayout", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxColumnLayoutComponent.prototype.getCalcWidth = function () {
            var borderWidth = 0;
            if (this.headerGroup && this.headerGroup.hasLastPinnedChildColumn) {
                var headerStyles = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement.children[0]);
                borderWidth = parseInt(headerStyles.borderRightWidth, 10);
            }
            return _super.prototype.getCalcWidth.call(this) + borderWidth;
        };
        Object.defineProperty(IgxColumnLayoutComponent.prototype, "visibleIndex", {
            /**
             * Gets the column visible index.
             * If the column is not visible, returns `-1`.
             * ```typescript
             * let visibleColumnIndex =  this.column.visibleIndex;
             * ```
             *
             * @memberof IgxColumnComponent
             */
            get: function () {
                if (!isNaN(this._vIndex)) {
                    return this._vIndex;
                }
                var unpinnedColumns = this.grid.unpinnedColumns.filter(function (c) { return c.columnLayout && !c.hidden; });
                var pinnedColumns = this.grid.pinnedColumns.filter(function (c) { return c.columnLayout && !c.hidden; });
                var vIndex = -1;
                if (!this.pinned) {
                    var indexInCollection = unpinnedColumns.indexOf(this);
                    vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
                }
                else {
                    vIndex = pinnedColumns.indexOf(this);
                }
                this._vIndex = vIndex;
                return vIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnLayoutComponent.prototype, "hidden", {
            /*
             * Gets whether the column layout is hidden.
             * ```typescript
             * let isHidden = this.columnGroup.hidden;
             * ```
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this._hidden;
            },
            /**
             * Sets the column layout hidden property.
             * ```typescript
             * <igx-column-layout [hidden] = "true"></igx-column->
             * ```
             *
             * @memberof IgxColumnGroupComponent
             */
            set: function (value) {
                var _this = this;
                this._hidden = value;
                this.children.forEach(function (child) { return child.hidden = value; });
                if (this.grid && this.grid.columns && this.grid.columns.length > 0) {
                    // reset indexes in case columns are hidden/shown runtime
                    var columns = this.grid && this.grid.pinnedColumns && this.grid.unpinnedColumns ?
                        this.grid.pinnedColumns.concat(this.grid.unpinnedColumns) : [];
                    if (!this._hidden && !columns.find(function (c) { return c.field === _this.field; })) {
                        this.grid.resetColumnCollections();
                    }
                    this.grid.columns.filter(function (x) { return x.columnLayout; }).forEach(function (x) { return x.populateVisibleIndexes(); });
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxColumnLayoutComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            _super.prototype.ngAfterContentInit.call(this);
            if (!this.hidden) {
                this.hidden = this.allChildren.some(function (x) { return x.hidden; });
            }
            else {
                this.children.forEach(function (child) { return child.hidden = _this.hidden; });
            }
            this.children.forEach(function (child) {
                child.movable = false;
            });
        };
        Object.defineProperty(IgxColumnLayoutComponent.prototype, "hasLastPinnedChildColumn", {
            /*
             * Gets whether the group contains the last pinned child column of the column layout.
             * ```typescript
             * let columsHasLastPinned = this.columnLayout.hasLastPinnedChildColumn;
             * ```
             * @memberof IgxColumnLayoutComponent
             */
            get: function () {
                return this.children.some(function (child) { return child.isLastPinned; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxColumnLayoutComponent.prototype, "hasFirstPinnedChildColumn", {
            /*
             * Gets whether the group contains the first pinned child column of the column layout.
             * ```typescript
             * let hasFirstPinnedChildColumn = this.columnLayout.hasFirstPinnedChildColumn;
             * ```
             * @memberof IgxColumnLayoutComponent
             */
            get: function () {
                return this.children.some(function (child) { return child.isFirstPinned; });
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxColumnLayoutComponent.prototype.populateVisibleIndexes = function () {
            var _this = this;
            this.childrenVisibleIndexes = [];
            var grid = this.gridAPI.grid;
            var columns = grid && grid.pinnedColumns && grid.unpinnedColumns ? grid.pinnedColumns.concat(grid.unpinnedColumns) : [];
            var orderedCols = columns
                .filter(function (x) { return !x.columnGroup && !x.hidden; })
                .sort(function (a, b) { return a.rowStart - b.rowStart || columns.indexOf(a.parent) - columns.indexOf(b.parent) || a.colStart - b.colStart; });
            this.children.forEach(function (child) {
                var rs = child.rowStart || 1;
                var vIndex = 0;
                // filter out all cols with larger rowStart
                var cols = orderedCols.filter(function (c) { return !c.columnGroup && (c.rowStart || 1) <= rs; });
                vIndex = cols.indexOf(child);
                _this.childrenVisibleIndexes.push({ column: child, index: vIndex });
            });
        };
        return IgxColumnLayoutComponent;
    }(IgxColumnGroupComponent));
    IgxColumnLayoutComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: IgxColumnComponent, useExisting: i0.forwardRef(function () { return IgxColumnLayoutComponent; }) }],
                    selector: 'igx-column-layout',
                    template: ""
                },] }
    ];
    IgxColumnLayoutComponent.propDecorators = {
        hidden: [{ type: i0.Input }]
    };

    var IgxGridColumnModule = /** @class */ (function () {
        function IgxGridColumnModule() {
        }
        return IgxGridColumnModule;
    }());
    IgxGridColumnModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxFilterCellTemplateDirective,
                        IgxCellTemplateDirective,
                        IgxCellHeaderTemplateDirective,
                        IgxCellFooterTemplateDirective,
                        IgxCellEditorTemplateDirective,
                        IgxCollapsibleIndicatorTemplateDirective,
                        IgxColumnComponent,
                        IgxColumnGroupComponent,
                        IgxColumnLayoutComponent
                    ],
                    entryComponents: [
                        IgxColumnComponent,
                        IgxColumnGroupComponent,
                        IgxColumnLayoutComponent
                    ],
                    exports: [
                        IgxFilterCellTemplateDirective,
                        IgxCellTemplateDirective,
                        IgxCellHeaderTemplateDirective,
                        IgxCellFooterTemplateDirective,
                        IgxCellEditorTemplateDirective,
                        IgxCollapsibleIndicatorTemplateDirective,
                        IgxColumnComponent,
                        IgxColumnGroupComponent,
                        IgxColumnLayoutComponent
                    ]
                },] }
    ];

    var IgxGridFilteringModule = /** @class */ (function () {
        function IgxGridFilteringModule() {
        }
        return IgxGridFilteringModule;
    }());
    IgxGridFilteringModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxGridFilteringCellComponent,
                        IgxGridFilteringRowComponent
                    ],
                    imports: [
                        IgxGridSharedModules,
                        IgxGridPipesModule
                    ],
                    exports: [
                        IgxGridFilteringCellComponent,
                        IgxGridFilteringRowComponent
                    ]
                },] }
    ];

    var SortingIndexPipe = /** @class */ (function () {
        function SortingIndexPipe() {
        }
        SortingIndexPipe.prototype.transform = function (columnField, sortingExpressions) {
            var sortIndex = sortingExpressions.findIndex(function (expression) { return expression.fieldName === columnField; });
            return sortIndex !== -1 ? ++sortIndex : null;
        };
        return SortingIndexPipe;
    }());
    SortingIndexPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'sortingIndex',
                    pure: true
                },] }
    ];

    var IgxGridHeadersModule = /** @class */ (function () {
        function IgxGridHeadersModule() {
        }
        return IgxGridHeadersModule;
    }());
    IgxGridHeadersModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxGridHeaderComponent,
                        IgxGridHeaderGroupComponent,
                        SortingIndexPipe
                    ],
                    imports: [
                        IgxGridSharedModules,
                        IgxGridFilteringModule,
                        IgxColumnMovingModule,
                        IgxGridResizingModule
                    ],
                    exports: [
                        IgxGridHeaderComponent,
                        IgxGridHeaderGroupComponent
                    ]
                },] }
    ];

    /**
     * @hidden
     */
    var IgxGridCommonModule = /** @class */ (function () {
        function IgxGridCommonModule() {
        }
        return IgxGridCommonModule;
    }());
    IgxGridCommonModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxRowDirective,
                        IgxGridCellComponent,
                        IgxRowEditTemplateDirective,
                        IgxRowEditActionsDirective,
                        IgxRowEditTextDirective,
                        IgxRowEditTabStopDirective,
                        IgxGridBodyDirective,
                        IgxGridFooterComponent,
                        IgxAdvancedFilteringDialogComponent,
                        IgxRowExpandedIndicatorDirective,
                        IgxRowCollapsedIndicatorDirective,
                        IgxHeaderExpandIndicatorDirective,
                        IgxHeaderCollapseIndicatorDirective,
                        IgxExcelStyleHeaderIconDirective,
                    ],
                    entryComponents: [
                        IgxAdvancedFilteringDialogComponent
                    ],
                    exports: [
                        IgxGridCellComponent,
                        IgxRowEditTemplateDirective,
                        IgxRowEditActionsDirective,
                        IgxRowEditTextDirective,
                        IgxRowEditTabStopDirective,
                        IgxGridBodyDirective,
                        IgxColumnActionsModule,
                        IgxGridColumnModule,
                        IgxGridHeadersModule,
                        IgxGridPipesModule,
                        IgxGridFilteringModule,
                        IgxGridExcelStyleFilteringModule,
                        IgxRowDragModule,
                        IgxPaginatorModule,
                        IgxGridFooterComponent,
                        IgxGridResizingModule,
                        IgxColumnMovingModule,
                        IgxGridSelectionModule,
                        IgxGridSummaryModule,
                        IgxGridToolbarModule,
                        IgxAdvancedFilteringDialogComponent,
                        IgxGridSharedModules,
                        IgxRowExpandedIndicatorDirective,
                        IgxRowCollapsedIndicatorDirective,
                        IgxHeaderExpandIndicatorDirective,
                        IgxHeaderCollapseIndicatorDirective,
                        IgxExcelStyleHeaderIconDirective,
                    ],
                    imports: [
                        IgxGridColumnModule,
                        IgxGridHeadersModule,
                        IgxColumnMovingModule,
                        IgxGridResizingModule,
                        IgxGridSelectionModule,
                        IgxGridSummaryModule,
                        IgxGridToolbarModule,
                        IgxColumnActionsModule,
                        IgxGridPipesModule,
                        IgxGridFilteringModule,
                        IgxGridExcelStyleFilteringModule,
                        IgxRowDragModule,
                        IgxPaginatorModule,
                        IgxGridSharedModules
                    ],
                    providers: [
                        { provide: IgxGridTransaction, useClass: IgxBaseTransactionService }
                    ]
                },] }
    ];

    /**
     * @hidden
     */
    var IgxGridSortingPipe = /** @class */ (function () {
        function IgxGridSortingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridSortingPipe.prototype.transform = function (collection, expressions, sorting, id, pipeTrigger, pinned) {
            var grid = this.gridAPI.grid;
            var result;
            if (!expressions.length) {
                result = collection;
            }
            else {
                result = DataUtil.sort(cloneArray(collection), expressions, sorting, grid);
            }
            grid.setFilteredSortedData(result, pinned);
            return result;
        };
        return IgxGridSortingPipe;
    }());
    IgxGridSortingPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'gridSort',
                    pure: true
                },] }
    ];
    IgxGridSortingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    /**
     * @hidden
     */
    var IgxGridGroupingPipe = /** @class */ (function () {
        function IgxGridGroupingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridGroupingPipe.prototype.transform = function (collection, expression, expansion, defaultExpanded, id, groupsRecords, pipeTrigger) {
            var state = { expressions: [], expansion: [], defaultExpanded: defaultExpanded };
            var grid = this.gridAPI.grid;
            state.expressions = grid.groupingExpressions;
            var result;
            var fullResult = { data: [], metadata: [] };
            if (!state.expressions.length) {
                // empty the array without changing reference
                groupsRecords.splice(0, groupsRecords.length);
                result = {
                    data: collection,
                    metadata: collection
                };
            }
            else {
                state.expansion = grid.groupingExpansionState;
                state.defaultExpanded = grid.groupsExpanded;
                result = DataUtil.group(cloneArray(collection), state, grid, groupsRecords, fullResult);
            }
            grid.groupingFlatResult = result.data;
            grid.groupingResult = fullResult.data;
            grid.groupingMetadata = fullResult.metadata;
            return result;
        };
        return IgxGridGroupingPipe;
    }());
    IgxGridGroupingPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'gridGroupBy',
                    pure: true
                },] }
    ];
    IgxGridGroupingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    /**
     * @hidden
     */
    var IgxGridPagingPipe = /** @class */ (function () {
        function IgxGridPagingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridPagingPipe.prototype.transform = function (collection, page, perPage, id, pipeTrigger) {
            if (page === void 0) { page = 0; }
            if (perPage === void 0) { perPage = 15; }
            if (!this.gridAPI.grid.paging || this.gridAPI.grid.pagingMode !== exports.GridPagingMode.Local) {
                return collection;
            }
            var state = {
                index: page,
                recordsPerPage: perPage
            };
            var total = this.gridAPI.grid._totalRecords >= 0 ? this.gridAPI.grid._totalRecords : collection.data.length;
            DataUtil.correctPagingState(state, total);
            var result = {
                data: DataUtil.page(cloneArray(collection.data), state, total),
                metadata: DataUtil.page(cloneArray(collection.metadata), state, total)
            };
            if (this.gridAPI.grid.page !== state.index) {
                this.gridAPI.grid.page = state.index;
            }
            this.gridAPI.grid.pagingState = state;
            return result;
        };
        return IgxGridPagingPipe;
    }());
    IgxGridPagingPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'gridPaging',
                    pure: true
                },] }
    ];
    IgxGridPagingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    /**
     * @hidden
     */
    var IgxGridFilteringPipe = /** @class */ (function () {
        function IgxGridFilteringPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridFilteringPipe.prototype.transform = function (collection, expressionsTree, filterStrategy, advancedExpressionsTree, id, pipeTrigger, filteringPipeTrigger, pinned) {
            var grid = this.gridAPI.grid;
            var state = {
                expressionsTree: expressionsTree,
                strategy: filterStrategy,
                advancedExpressionsTree: advancedExpressionsTree
            };
            if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
                return collection;
            }
            var result = DataUtil.filter(cloneArray(collection), state, grid);
            grid.setFilteredData(result, pinned);
            return result;
        };
        return IgxGridFilteringPipe;
    }());
    IgxGridFilteringPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'gridFiltering',
                    pure: true
                },] }
    ];
    IgxGridFilteringPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };

    var IgxGridRowComponent = /** @class */ (function (_super) {
        __extends(IgxGridRowComponent, _super);
        function IgxGridRowComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IgxGridRowComponent.prototype, "hasColumnLayouts", {
            get: function () {
                return this.grid.hasColumnLayouts;
            },
            enumerable: false,
            configurable: true
        });
        IgxGridRowComponent.prototype.getContext = function (col, row) {
            return {
                $implicit: col,
                row: row
            };
        };
        Object.defineProperty(IgxGridRowComponent.prototype, "mrlRightPinnedOffset", {
            get: function () {
                return !this.grid.isPinningToStart ?
                    -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' :
                    null;
            },
            enumerable: false,
            configurable: true
        });
        IgxGridRowComponent.prototype.getContextMRL = function (pinnedCols, row) {
            return {
                $implicit: pinnedCols,
                row: row
            };
        };
        Object.defineProperty(IgxGridRowComponent.prototype, "expanded", {
            get: function () {
                return this.gridAPI.get_row_expansion_state(this.rowData);
            },
            enumerable: false,
            configurable: true
        });
        return IgxGridRowComponent;
    }(IgxRowDirective));
    IgxGridRowComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-row',
                    template: "<ng-container *ngTemplateOutlet='addRow ? addTemp : defaultTemp'></ng-container>\n\n<ng-template #addTemp>\n    <div class='igx-grid__tr--inner' [class.igx-grid__tr--add-animate]='animateAdd' (animationend)='animationEndHandler()'>\n        <ng-container *ngTemplateOutlet='defaultTemp'></ng-container>\n    </div>\n</ng-template>\n<ng-template #defaultTemp>\n    <ng-container *ngIf=\"rowDraggable\">\n        <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n            <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n        </div>\n    </ng-container>\n    <ng-container *ngIf=\"this.showRowSelectors\">\n        <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" (pointerdown)=\"$event.preventDefault()\" (click)=\"onRowSelectorClick($event)\">\n            <ng-template *ngTemplateOutlet=\"\n                this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n                context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n            </ng-template>\n        </div>\n    </ng-container>\n    <ng-container *ngIf=\"grid.groupingExpressions.length > 0\">\n        <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{grid.groupingExpressions.length}}\" (pointerdown)=\"$event.preventDefault()\" (click)=\"$event.stopPropagation()\"></div>\n    </ng-container>\n\n\n    <ng-container *ngIf=\"!grid.hasColumnLayouts\">\n        <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n            <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n                    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n            </ng-template>\n        </ng-container>\n        <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n            <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n        </ng-template>\n        <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n            <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n                    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n            </ng-template>\n        </ng-container>\n    </ng-container>\n\n    <ng-container *ngIf=\"grid.hasColumnLayouts\">\n        <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n            <ng-container *ngTemplateOutlet=\"mrlPinnedTemplate; context: getContextMRL(pinnedColumns, this)\"></ng-container>\n        </ng-container>\n        <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n            <div class=\"igx-grid__mrl-block\" [ngStyle]=\"{\n                'grid-template-rows':col.getGridTemplate(true, false),\n                'grid-template-columns':col.getGridTemplate(false, false),\n                '-ms-grid-rows':col.getGridTemplate(true, true),\n                '-ms-grid-columns':col.getGridTemplate(false, true)\n            }\">\n                <ng-template ngFor let-col [ngForOf]=\"col.children\">\n                        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? mrlExpandableCellTemplate : mrlCellTemplate; context: getContext(col, this)\"></ng-container>\n                </ng-template>\n            </div>\n        </ng-template>\n\n        <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n            <ng-container *ngTemplateOutlet=\"mrlPinnedTemplate; context: getContextMRL(pinnedColumns, this)\"></ng-container>\n        </ng-container>\n    </ng-container>\n</ng-template>\n\n<ng-template #mrlPinnedTemplate let-pinnedColumns>\n    <div *ngFor=\"let col of pinnedColumns | igxTopLevel\" class=\"igx-grid__mrl-block\"\n    [class.igx-grid__td--pinned-last]=\"col.hasLastPinnedChildColumn\"\n    [class.igx-grid__td--pinned-first]=\"col.hasFirstPinnedChildColumn\"\n    [style.left]=\"mrlRightPinnedOffset\"\n    [ngStyle]=\"{\n        'grid-template-rows':col.getGridTemplate(true, false),\n        'grid-template-columns':col.getGridTemplate(false, false),\n        'z-index': col.pinned ? 1 : null,\n        '-ms-grid-rows':col.getGridTemplate(true, true),\n        '-ms-grid-columns':col.getGridTemplate(false, true)\n    }\">\n        <ng-template ngFor let-col [ngForOf]=\"col.children\">\n                <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails? mrlExpandableCellTemplate : mrlCellTemplate; context: getContext(col, this)\"></ng-container>\n        </ng-template>\n    </div>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [checked]=\"selected\"\n            [readonly]=\"true\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<ng-template #cellTemplate let-col>\n        <igx-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [firstPinned]=\"col.columnLayoutChild ? null : col.isFirstPinned\"\n        [style.min-height.px]=\"cellHeight\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [style.left]=\"col.rightPinnedOffset\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #expandableCellTemplate let-col>\n    <igx-expandable-grid-cell\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n        [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [expanded]=\"expanded\"\n        [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [style.min-height.px]=\"cellHeight\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-expandable-grid-cell>\n</ng-template>\n\n<ng-template #mrlCellTemplate let-col>\n    <igx-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n        [column]=\"col\"\n        [style.-ms-grid-row-span]=\"col.gridRowSpan\"\n        [style.-ms-grid-column-span]=\"col.gridColumnSpan\"\n        [style.grid-row-end]=\"col.rowEnd\"\n        [style.grid-column-end]=\"col.colEnd\"\n        [style.-ms-grid-row]=\"col.rowStart\"\n        [style.grid-row-start]=\"col.rowStart\"\n        [style.-ms-grid-column]=\"col.colStart\"\n        [style.grid-column-start]=\"col.colStart\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [firstPinned]=\"col.columnLayoutChild ? null : col.isFirstPinned\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"cellHeight\"\n        [rowData]=\"rowData\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #mrlExpandableCellTemplate let-col>\n    <igx-expandable-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n        [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [expanded]=\"expanded\"\n        [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n        [column]=\"col\"\n        [style.-ms-grid-row-span]=\"col.gridRowSpan\"\n        [style.-ms-grid-column-span]=\"col.gridColumnSpan\"\n        [style.grid-row-end]=\"col.rowEnd\"\n        [style.grid-column-end]=\"col.colEnd\"\n        [style.-ms-grid-row]=\"col.rowStart\"\n        [style.grid-row-start]=\"col.rowStart\"\n        [style.-ms-grid-column]=\"col.colStart\"\n        [style.grid-column-start]=\"col.colStart\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"cellHeight\"\n        [rowData]=\"rowData\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-expandable-grid-cell>\n</ng-template>\n",
                    providers: [{ provide: IgxRowDirective, useExisting: i0.forwardRef(function () { return IgxGridRowComponent; }) }]
                },] }
    ];
    IgxGridRowComponent.propDecorators = {
        hasColumnLayouts: [{ type: i0.HostBinding, args: ['class.igx-grid__tr--mrl',] }]
    };

    /** @hidden */
    var IgxGridSummaryPipe = /** @class */ (function () {
        function IgxGridSummaryPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridSummaryPipe.prototype.transform = function (collection, hasSummary, summaryCalculationMode, summaryPosition, id, showSummary, pipeTrigger, summaryPipeTrigger) {
            if (!collection.data || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
                return collection.data;
            }
            return this.addSummaryRows(id, collection, summaryPosition, showSummary);
        };
        IgxGridSummaryPipe.prototype.addSummaryRows = function (gridId, collection, summaryPosition, showSummary) {
            var _a, e_1, _b, e_2, _c;
            var recordsWithSummary = [];
            var lastChildMap = new Map();
            var grid = this.gridAPI.grid;
            var maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
            if (collection.metadata.length && !grid.isGroupByRecord(collection.data[0]) &&
                grid.isGroupByRecord(collection.metadata[0]) && summaryPosition === GridSummaryPosition.bottom) {
                var groups = [];
                groups.push(collection.metadata[0]);
                while (groups[groups.length - 1].groupParent) {
                    groups.push(groups[groups.length - 1].groupParent);
                }
                groups.reverse();
                groups.forEach(function (g) { return g.skip = true; });
                (_a = collection.data).splice.apply(_a, __spread([0, 0], groups));
            }
            try {
                for (var _d = __values(collection.data), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var record = _e.value;
                    var skipAdd = false;
                    var recordId = void 0;
                    var groupByRecord = null;
                    if (grid.isGroupByRecord(record)) {
                        skipAdd = !!record.skip;
                        record.skip = null;
                        groupByRecord = record;
                        recordId = this.gridAPI.get_groupBy_record_id(groupByRecord);
                    }
                    else {
                        recordId = this.gridAPI.get_row_id(record);
                    }
                    if (!skipAdd) {
                        recordsWithSummary.push(record);
                    }
                    if (summaryPosition === GridSummaryPosition.bottom && showSummary && (groupByRecord && !grid.isExpandedGroup(groupByRecord))) {
                        var records = this.removeDeletedRecord(grid, groupByRecord.records.slice());
                        var summaries = grid.summaryService.calculateSummaries(recordId, records);
                        var summaryRecord = {
                            summaries: summaries,
                            max: maxSummaryHeight
                        };
                        recordsWithSummary.push(summaryRecord);
                    }
                    if (summaryPosition === GridSummaryPosition.bottom && lastChildMap.has(recordId)) {
                        var groupRecords = lastChildMap.get(recordId);
                        try {
                            for (var groupRecords_1 = (e_2 = void 0, __values(groupRecords)), groupRecords_1_1 = groupRecords_1.next(); !groupRecords_1_1.done; groupRecords_1_1 = groupRecords_1.next()) {
                                var groupRecord = groupRecords_1_1.value;
                                var groupRecordId = this.gridAPI.get_groupBy_record_id(groupRecord);
                                var records = this.removeDeletedRecord(grid, groupRecord.records.slice());
                                var summaries = grid.summaryService.calculateSummaries(groupRecordId, records);
                                var summaryRecord = {
                                    summaries: summaries,
                                    max: maxSummaryHeight
                                };
                                recordsWithSummary.push(summaryRecord);
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (groupRecords_1_1 && !groupRecords_1_1.done && (_c = groupRecords_1.return)) _c.call(groupRecords_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                    var showSummaries = showSummary ? false : (groupByRecord && !grid.isExpandedGroup(groupByRecord));
                    if (groupByRecord === null || showSummaries) {
                        continue;
                    }
                    if (summaryPosition === GridSummaryPosition.top) {
                        var records = this.removeDeletedRecord(grid, groupByRecord.records.slice());
                        var summaries = grid.summaryService.calculateSummaries(recordId, records);
                        var summaryRecord = {
                            summaries: summaries,
                            max: maxSummaryHeight
                        };
                        recordsWithSummary.push(summaryRecord);
                    }
                    else if (summaryPosition === GridSummaryPosition.bottom) {
                        var lastChild = groupByRecord;
                        while (lastChild.groups && lastChild.groups.length > 0 && grid.isExpandedGroup(lastChild)) {
                            lastChild = lastChild.groups[lastChild.groups.length - 1];
                        }
                        var lastChildId = void 0;
                        if (grid.isExpandedGroup(lastChild)) {
                            lastChildId = this.gridAPI.get_row_id(lastChild.records[lastChild.records.length - 1]);
                        }
                        else {
                            lastChildId = this.gridAPI.get_groupBy_record_id(lastChild);
                        }
                        var groupRecords = lastChildMap.get(lastChildId);
                        if (!groupRecords) {
                            groupRecords = [];
                            lastChildMap.set(lastChildId, groupRecords);
                        }
                        groupRecords.unshift(groupByRecord);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return recordsWithSummary;
        };
        IgxGridSummaryPipe.prototype.removeDeletedRecord = function (grid, data) {
            if (!grid.transactions.enabled) {
                return data;
            }
            var deletedRows = grid.transactions.getTransactionLog().filter(function (t) { return t.type === 'delete'; }).map(function (t) { return t.id; });
            deletedRows.forEach(function (rowID) {
                var tempData = grid.primaryKey ? data.map(function (rec) { return rec[grid.primaryKey]; }) : data;
                var index = tempData.indexOf(rowID);
                if (index !== -1) {
                    data.splice(index, 1);
                }
            });
            return data;
        };
        return IgxGridSummaryPipe;
    }());
    IgxGridSummaryPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'gridSummary',
                    pure: true
                },] }
    ];
    IgxGridSummaryPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };

    /** @hidden */
    var IgxGridDetailsPipe = /** @class */ (function () {
        function IgxGridDetailsPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridDetailsPipe.prototype.transform = function (collection, hasDetails, expansionStates, pipeTrigger) {
            if (!hasDetails) {
                return collection;
            }
            var res = this.addDetailRows(collection, expansionStates);
            return res;
        };
        IgxGridDetailsPipe.prototype.addDetailRows = function (collection, expansionStates) {
            var _this = this;
            var result = [];
            collection.forEach(function (v) {
                result.push(v);
                if (!_this.gridAPI.grid.isGroupByRecord(v) && !_this.gridAPI.grid.isSummaryRow(v) &&
                    _this.gridAPI.get_row_expansion_state(v)) {
                    var detailsObj = { detailsData: v };
                    result.push(detailsObj);
                }
            });
            return result;
        };
        return IgxGridDetailsPipe;
    }());
    IgxGridDetailsPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'gridDetails',
                    pure: true
                },] }
    ];
    IgxGridDetailsPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };

    var IgxGridExpandableCellComponent = /** @class */ (function (_super) {
        __extends(IgxGridExpandableCellComponent, _super);
        function IgxGridExpandableCellComponent(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil) {
            var _this = _super.call(this, selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil) || this;
            _this.zone = zone;
            _this.document = document;
            _this.platformUtil = platformUtil;
            /**
             * @hidden
             */
            _this.expanded = false;
            return _this;
        }
        /**
         * @hidden
         */
        IgxGridExpandableCellComponent.prototype.toggle = function (event) {
            event.stopPropagation();
            var expansionState = this.gridAPI.get_row_expansion_state(this.row.rowData);
            this.gridAPI.set_row_expansion_state(this.row.rowID, !expansionState, event);
        };
        /**
         * @hidden
         */
        IgxGridExpandableCellComponent.prototype.onIndicatorFocus = function (event) {
            this.gridAPI.submit_value(event);
        };
        /**
         * @hidden
         */
        IgxGridExpandableCellComponent.prototype.calculateSizeToFit = function (range) {
            var indicatorWidth = this.indicator.nativeElement.getBoundingClientRect().width;
            var indicatorStyle = this.document.defaultView.getComputedStyle(this.indicator.nativeElement);
            var indicatorMargin = parseFloat(indicatorStyle.marginRight);
            var leftPadding = 0;
            if (this.indentationDiv) {
                var indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);
                leftPadding = parseFloat(indentationStyle.paddingLeft);
            }
            var largestWidth = Math.max.apply(Math, __spread(Array.from(this.nativeElement.children)
                .map(function (child) { return getNodeSizeViaRange(range, child); })));
            return largestWidth + indicatorWidth + indicatorMargin + leftPadding;
        };
        Object.defineProperty(IgxGridExpandableCellComponent.prototype, "iconTemplate", {
            /**
             * @hidden
             */
            get: function () {
                if (this.expanded) {
                    return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
                }
                else {
                    return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxGridExpandableCellComponent.prototype, "showExpanderIndicator", {
            /**
             * @hidden
             */
            get: function () {
                var isGhost = this.row.pinned && this.row.disabled;
                return !this.editMode && (!this.row.pinned || isGhost);
            },
            enumerable: false,
            configurable: true
        });
        return IgxGridExpandableCellComponent;
    }(IgxGridCellComponent));
    IgxGridExpandableCellComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    selector: 'igx-expandable-grid-cell',
                    template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip *ngIf=\"displayPinnedChip\" class=\"igx-grid__td--pinned-chip\" [disabled]=\"true\" [displayDensity]=\"'compact'\">{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip>\n</ng-template>\n<ng-template #defaultCell>\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n        [cssClass]=\"highlightClass\"\n        [activeCssClass]=\"activeHighlightClass\"\n        [groupName]=\"gridID\"\n        [value]=\"formatter ? (value | columnFormatter: formatter)\n            : column.dataType === 'number'\n            ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n            : column.dataType === 'date'\n            ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n            : column.dataType === 'currency'\n            ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n            : column.dataType === 'percent' ? (value | percent:column.pipeArgs.digitsInfo:grid.locale) : value\"\n        [row]=\"rowData\"\n        [column]=\"this.column.field\"\n        [containerClass]=\"'igx-grid__td-text'\"\n        [metadata]=\"searchMetadata\">{{ formatter ? (value | columnFormatter: formatter) : column.dataType === \"number\"\n            ? (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === \"date\"\n            ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : column.dataType === 'currency'\n            ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'percent'\n            ? (value | percent:column.pipeArgs.digitsInfo:grid.locale) : value }}</div>\n</ng-template>\n<ng-template #addRowCell let-cell=\"cell\">\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n    [cssClass]=\"highlightClass\"\n    [activeCssClass]=\"activeHighlightClass\"\n    [groupName]=\"gridID\"\n    [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ?\n        (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ?\n        (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : column.dataType === 'currency'?\n        (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'percent' ?\n        (value | percent:column.pipeArgs.digitsInfo:grid.locale) : value\"\n    [row]=\"rowData\"\n    [column]=\"this.column.field\"\n    [containerClass]=\"'igx-grid__td-text'\"\n    [metadata]=\"searchMetadata\">{{\n        value ? value : (column.header || column.field)\n    }}</div>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"true\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"true\" [step]=\"step\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outlet\" mode=\"dropdown\"\n        [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"true\" [labelVisibility]=\"false\">\n    </igx-date-picker>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'currency'\">\n        <igx-input-group displayDensity=\"compact\">\n            <igx-prefix *ngIf=\"grid.currencyPositionLeft\">{{ currencyCodeSymbol }}</igx-prefix>\n            <input  igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\" [step]=\"step\" type=\"number\"/>\n            <igx-suffix *ngIf=\"!grid.currencyPositionLeft\" >{{ currencyCodeSymbol }}</igx-suffix>\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'percent'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\" [step]=\"step\"\n                [igxFocus]=\"true\" type=\"number\"/>\n            <igx-suffix> {{ editValue | percent:column.pipeArgs.digitsInfo:grid.locale }} </igx-suffix>\n        </igx-input-group>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"showExpanderIndicator\">\n    <div #indicator\n         class=\"igx-grid__tree-grouping-indicator\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus($event)\">\n         <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n    </div>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon>expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon>chevron_right</igx-icon>\n</ng-template>\n",
                    providers: [HammerGesturesManager]
                },] }
    ];
    IgxGridExpandableCellComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: GridBaseAPIService },
        { type: i0.ChangeDetectorRef },
        { type: i0.ElementRef },
        { type: i0.NgZone },
        { type: HammerGesturesManager },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: PlatformUtil }
    ]; };
    IgxGridExpandableCellComponent.propDecorators = {
        expanded: [{ type: i0.Input }],
        indicator: [{ type: i0.ViewChild, args: ['indicator', { read: i0.ElementRef },] }],
        indentationDiv: [{ type: i0.ViewChild, args: ['indentationDiv', { read: i0.ElementRef },] }],
        defaultExpandedTemplate: [{ type: i0.ViewChild, args: ['defaultExpandedTemplate', { read: i0.TemplateRef, static: true },] }],
        defaultCollapsedTemplate: [{ type: i0.ViewChild, args: ['defaultCollapsedTemplate', { read: i0.TemplateRef, static: true },] }]
    };

    /**
     * @hidden
     */
    var IgxGridModule = /** @class */ (function () {
        function IgxGridModule() {
        }
        return IgxGridModule;
    }());
    IgxGridModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxGridComponent,
                        IgxGridRowComponent,
                        IgxGridGroupByRowComponent,
                        IgxGroupByRowTemplateDirective,
                        IgxGridDetailTemplateDirective,
                        IgxGroupAreaDropDirective,
                        IgxGridGroupingPipe,
                        IgxGridPagingPipe,
                        IgxGridSortingPipe,
                        IgxGridFilteringPipe,
                        IgxGridSummaryPipe,
                        IgxGridDetailsPipe,
                        IgxGridExpandableCellComponent
                    ],
                    exports: [
                        IgxGridComponent,
                        IgxGridExpandableCellComponent,
                        IgxGridGroupByRowComponent,
                        IgxGridRowComponent,
                        IgxGroupByRowTemplateDirective,
                        IgxGridDetailTemplateDirective,
                        IgxGroupAreaDropDirective,
                        IgxGridGroupingPipe,
                        IgxGridPagingPipe,
                        IgxGridSortingPipe,
                        IgxGridFilteringPipe,
                        IgxGridSummaryPipe,
                        IgxGridDetailsPipe,
                        IgxGridCommonModule
                    ],
                    imports: [
                        IgxGridCommonModule,
                    ],
                    schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                },] }
    ];

    var IgxTreeGridAPIService = /** @class */ (function (_super) {
        __extends(IgxTreeGridAPIService, _super);
        function IgxTreeGridAPIService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxTreeGridAPIService.prototype.get_all_data = function (transactions) {
            var grid = this.grid;
            var data = grid && grid.flatData ? grid.flatData : [];
            data = transactions ? grid.dataWithAddedInTransactionRows : data;
            return data;
        };
        IgxTreeGridAPIService.prototype.get_summary_data = function () {
            var grid = this.grid;
            var data = grid.processedRootRecords.filter(function (row) { return row.isFilteredOutParent === undefined || row.isFilteredOutParent === false; })
                .map(function (rec) { return rec.data; });
            if (grid.transactions.enabled) {
                var deletedRows = grid.transactions.getTransactionLog().filter(function (t) { return t.type === exports.TransactionType.DELETE; }).map(function (t) { return t.id; });
                deletedRows.forEach(function (rowID) {
                    var tempData = grid.primaryKey ? data.map(function (rec) { return rec[grid.primaryKey]; }) : data;
                    var index = tempData.indexOf(rowID);
                    if (index !== -1) {
                        data.splice(index, 1);
                    }
                });
            }
            return data;
        };
        IgxTreeGridAPIService.prototype.allow_expansion_state_change = function (rowID, expanded) {
            var grid = this.grid;
            var row = grid.records.get(rowID);
            if (row.expanded === expanded ||
                ((!row.children || !row.children.length) && (!grid.loadChildrenOnDemand ||
                    (grid.hasChildrenKey && !row.data[grid.hasChildrenKey])))) {
                return false;
            }
            return true;
        };
        IgxTreeGridAPIService.prototype.expand_path_to_record = function (record) {
            var grid = this.grid;
            var expandedStates = grid.expansionStates;
            while (record.parent) {
                record = record.parent;
                var expanded = this.get_row_expansion_state(record);
                if (!expanded) {
                    expandedStates.set(record.rowID, true);
                }
            }
            grid.expansionStates = expandedStates;
            if (grid.rowEditable) {
                grid.endEdit(false);
            }
        };
        IgxTreeGridAPIService.prototype.get_row_expansion_state = function (record) {
            var grid = this.grid;
            var states = grid.expansionStates;
            var expanded = states.get(record.rowID);
            if (expanded !== undefined) {
                return expanded;
            }
            else {
                return record.children && record.children.length && record.level < grid.expansionDepth;
            }
        };
        IgxTreeGridAPIService.prototype.should_apply_number_style = function (column) {
            return column.dataType === DataType.Number && column.visibleIndex !== 0;
        };
        IgxTreeGridAPIService.prototype.deleteRowById = function (rowID) {
            var treeGrid = this.grid;
            var flatDataWithCascadeOnDeleteAndTransactions = treeGrid.primaryKey &&
                treeGrid.foreignKey &&
                treeGrid.cascadeOnDelete &&
                treeGrid.transactions.enabled;
            if (flatDataWithCascadeOnDeleteAndTransactions) {
                treeGrid.transactions.startPending();
            }
            _super.prototype.deleteRowById.call(this, rowID);
            if (flatDataWithCascadeOnDeleteAndTransactions) {
                treeGrid.transactions.endPending(true);
            }
        };
        IgxTreeGridAPIService.prototype.deleteRowFromData = function (rowID, index) {
            var e_1, _b;
            var treeGrid = this.grid;
            var record = treeGrid.records.get(rowID);
            if (treeGrid.primaryKey && treeGrid.foreignKey) {
                index = treeGrid.primaryKey ?
                    treeGrid.data.map(function (c) { return c[treeGrid.primaryKey]; }).indexOf(rowID) :
                    treeGrid.data.indexOf(rowID);
                _super.prototype.deleteRowFromData.call(this, rowID, index);
                if (treeGrid.cascadeOnDelete) {
                    if (record && record.children) {
                        try {
                            for (var _c = __values(record.children), _d = _c.next(); !_d.done; _d = _c.next()) {
                                var child = _d.value;
                                _super.prototype.deleteRowById.call(this, child.rowID);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                }
            }
            else {
                var collection = record.parent ? record.parent.data[treeGrid.childDataKey] : treeGrid.data;
                index = treeGrid.primaryKey ?
                    collection.map(function (c) { return c[treeGrid.primaryKey]; }).indexOf(rowID) :
                    collection.indexOf(rowID);
                var selectedChildren = [];
                this.get_selected_children(record, selectedChildren);
                if (selectedChildren.length > 0) {
                    treeGrid.deselectRows(selectedChildren);
                }
                if (treeGrid.transactions.enabled) {
                    var path = treeGrid.generateRowPath(rowID);
                    treeGrid.transactions.add({
                        id: rowID,
                        type: exports.TransactionType.DELETE,
                        newValue: null,
                        path: path
                    }, collection[index]);
                }
                else {
                    collection.splice(index, 1);
                }
            }
        };
        IgxTreeGridAPIService.prototype.get_selected_children = function (record, selectedRowIDs) {
            var e_2, _b;
            var grid = this.grid;
            if (!record.children || record.children.length === 0) {
                return;
            }
            try {
                for (var _c = __values(record.children), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var child = _d.value;
                    if (grid.selectionService.isRowSelected(child.rowID)) {
                        selectedRowIDs.push(child.rowID);
                    }
                    this.get_selected_children(child, selectedRowIDs);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        IgxTreeGridAPIService.prototype.row_deleted_transaction = function (rowID) {
            return this.row_deleted_parent(rowID) || _super.prototype.row_deleted_transaction.call(this, rowID);
        };
        IgxTreeGridAPIService.prototype.get_rec_by_id = function (rowID) {
            return this.grid.records.get(rowID);
        };
        IgxTreeGridAPIService.prototype.addRowToData = function (data, parentRowID) {
            if (parentRowID !== undefined && parentRowID !== null) {
                var state = this.grid.transactions.getState(parentRowID);
                // we should not allow adding of rows as child of deleted row
                if (state && state.type === exports.TransactionType.DELETE) {
                    throw Error("Cannot add child row to deleted parent row");
                }
                var parentRecord = this.grid.records.get(parentRowID);
                if (!parentRecord) {
                    throw Error('Invalid parent row ID!');
                }
                this.grid.summaryService.clearSummaryCache({ rowID: parentRecord.rowID });
                if (this.grid.primaryKey && this.grid.foreignKey) {
                    data[this.grid.foreignKey] = parentRowID;
                    _super.prototype.addRowToData.call(this, data);
                }
                else {
                    var parentData = parentRecord.data;
                    var childKey = this.grid.childDataKey;
                    if (this.grid.transactions.enabled) {
                        var rowId = this.grid.primaryKey ? data[this.grid.primaryKey] : data;
                        var path = [];
                        path.push.apply(path, __spread(this.grid.generateRowPath(parentRowID)));
                        path.push(parentRowID);
                        this.grid.transactions.add({
                            id: rowId,
                            path: path,
                            newValue: data,
                            type: exports.TransactionType.ADD
                        }, null);
                    }
                    else {
                        if (!parentData[childKey]) {
                            parentData[childKey] = [];
                        }
                        parentData[childKey].push(data);
                    }
                }
            }
            else {
                _super.prototype.addRowToData.call(this, data);
            }
        };
        IgxTreeGridAPIService.prototype.filterDataByExpressions = function (expressionsTree) {
            var _a;
            var records = this.grid.rootRecords;
            if (expressionsTree.filteringOperands.length) {
                var state = {
                    expressionsTree: expressionsTree,
                    strategy: (_a = this.grid.filterStrategy) !== null && _a !== void 0 ? _a : new TreeGridFilteringStrategy()
                };
                records = DataUtil.filter(cloneArray(records), state, this.grid);
            }
            var data = [];
            this.getFlatDataFromFilteredRecords(records, data);
            return data;
        };
        IgxTreeGridAPIService.prototype.update_row_in_array = function (value, rowID, index) {
            var grid = this.grid;
            if (grid.primaryKey && grid.foreignKey) {
                _super.prototype.update_row_in_array.call(this, value, rowID, index);
            }
            else {
                var record = grid.records.get(rowID);
                var childData = record.parent ? record.parent.data[grid.childDataKey] : grid.data;
                index = grid.primaryKey ? childData.map(function (c) { return c[grid.primaryKey]; }).indexOf(rowID) :
                    childData.indexOf(rowID);
                childData[index] = value;
            }
        };
        /**
         * Updates related row of provided grid's data source with provided new row value
         *
         * @param grid Grid to update data for
         * @param rowID ID of the row to update
         * @param rowValueInDataSource Initial value of the row as it is in data source
         * @param rowCurrentValue Current value of the row as it is with applied previous transactions
         * @param rowNewValue New value of the row
         */
        IgxTreeGridAPIService.prototype.updateData = function (grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
            if (grid.transactions.enabled) {
                var path = grid.generateRowPath(rowID);
                var transaction = {
                    id: rowID,
                    type: exports.TransactionType.UPDATE,
                    newValue: rowNewValue,
                    path: path
                };
                grid.transactions.add(transaction, rowCurrentValue);
            }
            else {
                mergeObjects(rowValueInDataSource, rowNewValue);
            }
        };
        IgxTreeGridAPIService.prototype.row_deleted_parent = function (rowID) {
            var grid = this.grid;
            if (!grid) {
                return false;
            }
            if ((grid.cascadeOnDelete && grid.foreignKey) || grid.childDataKey) {
                var node = grid.records.get(rowID);
                while (node) {
                    var state = grid.transactions.getState(node.rowID);
                    if (state && state.type === exports.TransactionType.DELETE) {
                        return true;
                    }
                    node = node.parent;
                }
            }
            return false;
        };
        IgxTreeGridAPIService.prototype.getFlatDataFromFilteredRecords = function (records, data) {
            var e_3, _b;
            if (!records || records.length === 0) {
                return;
            }
            try {
                for (var records_1 = __values(records), records_1_1 = records_1.next(); !records_1_1.done; records_1_1 = records_1.next()) {
                    var record = records_1_1.value;
                    if (!record.isFilteredOutParent) {
                        data.push(record.data);
                    }
                    this.getFlatDataFromFilteredRecords(record.children, data);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (records_1_1 && !records_1_1.done && (_b = records_1.return)) _b.call(records_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        };
        return IgxTreeGridAPIService;
    }(GridBaseAPIService));
    IgxTreeGridAPIService.decorators = [
        { type: i0.Injectable }
    ];

    /**
     * @hidden
     */
    var IgxRowLoadingIndicatorTemplateDirective = /** @class */ (function () {
        function IgxRowLoadingIndicatorTemplateDirective(template) {
            this.template = template;
        }
        return IgxRowLoadingIndicatorTemplateDirective;
    }());
    IgxRowLoadingIndicatorTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxRowLoadingIndicator]'
                },] }
    ];
    IgxRowLoadingIndicatorTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };

    var IgxTreeGridSelectionService = /** @class */ (function (_super) {
        __extends(IgxTreeGridSelectionService, _super);
        function IgxTreeGridSelectionService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /** Select specified rows. No event is emitted. */
        IgxTreeGridSelectionService.prototype.selectRowsWithNoEvent = function (rowIDs, clearPrevSelection) {
            if (this.grid && this.grid.rowSelection === GridSelectionMode.multipleCascade) {
                this.cascadeSelectRowsWithNoEvent(rowIDs, clearPrevSelection);
                return;
            }
            _super.prototype.selectRowsWithNoEvent.call(this, rowIDs, clearPrevSelection);
        };
        /** Deselect specified rows. No event is emitted. */
        IgxTreeGridSelectionService.prototype.deselectRowsWithNoEvent = function (rowIDs) {
            if (this.grid.rowSelection === GridSelectionMode.multipleCascade) {
                this.cascadeDeselectRowsWithNoEvent(rowIDs);
                return;
            }
            _super.prototype.deselectRowsWithNoEvent.call(this, rowIDs);
        };
        IgxTreeGridSelectionService.prototype.emitRowSelectionEvent = function (newSelection, added, removed, event) {
            if (this.grid.rowSelection === GridSelectionMode.multipleCascade) {
                this.emitCascadeRowSelectionEvent(newSelection, added, removed, event);
                return;
            }
            _super.prototype.emitRowSelectionEvent.call(this, newSelection, added, removed, event);
        };
        IgxTreeGridSelectionService.prototype.updateCascadeSelectionOnFilterAndCRUD = function (parents, crudRowID, visibleRowIDs) {
            var _this = this;
            if (visibleRowIDs === void 0) { visibleRowIDs = null; }
            if (visibleRowIDs === null) {
                // if the tree grid has flat structure
                // do not explicitly handle the selection state of the rows
                if (!parents.size) {
                    return;
                }
                visibleRowIDs = this.getRowIDs(this.allData);
                this.rowsToBeSelected = new Set(this.rowSelection);
                this.rowsToBeIndeterminate = new Set(this.indeterminateRows);
                if (crudRowID) {
                    this.rowSelection.delete(crudRowID);
                }
            }
            if (!parents.size) {
                this.rowSelection = new Set(this.rowsToBeSelected);
                this.indeterminateRows = new Set(this.rowsToBeIndeterminate);
                // TODO: emit selectionChangeD event, calculate its args through the handleAddedAndRemovedArgs method
                this.clearHeaderCBState();
                this.selectedRowsChange.next();
                return;
            }
            var newParents = new Set();
            parents.forEach(function (parent) {
                _this.handleRowSelectionState(parent, visibleRowIDs);
                if (parent && parent.parent) {
                    newParents.add(parent.parent);
                }
            });
            this.updateCascadeSelectionOnFilterAndCRUD(newParents, null, visibleRowIDs);
        };
        IgxTreeGridSelectionService.prototype.cascadeSelectRowsWithNoEvent = function (rowIDs, clearPrevSelection) {
            if (clearPrevSelection) {
                this.indeterminateRows.clear();
                this.rowSelection.clear();
                this.calculateRowsNewSelectionState({ added: rowIDs, removed: [] });
            }
            else {
                var oldSelection = this.getSelectedRows();
                var newSelection = __spread(oldSelection, rowIDs);
                var args = { oldSelection: oldSelection, newSelection: newSelection };
                // retrieve only the rows without their parents/children which has to be added to the selection
                this.handleAddedAndRemovedArgs(args);
                this.calculateRowsNewSelectionState(args);
            }
            this.rowSelection = new Set(this.rowsToBeSelected);
            this.indeterminateRows = new Set(this.rowsToBeIndeterminate);
            this.clearHeaderCBState();
            this.selectedRowsChange.next();
        };
        IgxTreeGridSelectionService.prototype.cascadeDeselectRowsWithNoEvent = function (rowIDs) {
            var args = { added: [], removed: rowIDs };
            this.calculateRowsNewSelectionState(args);
            this.rowSelection = new Set(this.rowsToBeSelected);
            this.indeterminateRows = new Set(this.rowsToBeIndeterminate);
            this.clearHeaderCBState();
            this.selectedRowsChange.next();
        };
        Object.defineProperty(IgxTreeGridSelectionService.prototype, "selectionService", {
            get: function () {
                return this.grid.selectionService;
            },
            enumerable: false,
            configurable: true
        });
        IgxTreeGridSelectionService.prototype.emitCascadeRowSelectionEvent = function (newSelection, added, removed, event) {
            var currSelection = this.getSelectedRows();
            if (this.areEqualCollections(currSelection, newSelection)) {
                return;
            }
            var args = {
                oldSelection: currSelection,
                newSelection: newSelection,
                added: added, removed: removed, event: event,
                cancel: false
            };
            this.calculateRowsNewSelectionState(args);
            args.newSelection = Array.from(this.rowsToBeSelected);
            // retrieve rows/parents/children which has been added/removed from the selection
            this.handleAddedAndRemovedArgs(args);
            this.grid.onRowSelectionChange.emit(args);
            if (args.cancel) {
                return;
            }
            // if args.newSelection hasn't been modified
            if (this.areEqualCollections(Array.from(this.rowsToBeSelected), args.newSelection)) {
                this.rowSelection = new Set(this.rowsToBeSelected);
                this.indeterminateRows = new Set(this.rowsToBeIndeterminate);
                this.clearHeaderCBState();
                this.selectedRowsChange.next();
            }
            else {
                // select the rows within the modified args.newSelection with no event
                this.cascadeSelectRowsWithNoEvent(args.newSelection, true);
            }
        };
        /**
         * retrieve the rows which should be added/removed to/from the old selection
         */
        IgxTreeGridSelectionService.prototype.handleAddedAndRemovedArgs = function (args) {
            args.removed = args.oldSelection.filter(function (x) { return args.newSelection.indexOf(x) < 0; });
            args.added = args.newSelection.filter(function (x) { return args.oldSelection.indexOf(x) < 0; });
        };
        /**
         * adds to rowsToBeProcessed set all visible children of the rows which was initially within the rowsToBeProcessed set
         *
         * @param rowsToBeProcessed set of the rows (without their parents/children) to be selected/deselected
         * @param visibleRowIDs list of all visible rowIds
         * @returns a new set with all direct parents of the rows within rowsToBeProcessed set
         */
        IgxTreeGridSelectionService.prototype.collectRowsChildrenAndDirectParents = function (rowsToBeProcessed, visibleRowIDs) {
            var _this = this;
            var processedRowsParents = new Set();
            Array.from(rowsToBeProcessed).forEach(function (rowID) {
                var rowTreeRecord = _this.grid.gridAPI.get_rec_by_id(rowID);
                var rowAndAllChildren = _this.get_all_children(rowTreeRecord);
                rowAndAllChildren.forEach(function (row) {
                    if (visibleRowIDs.indexOf(row.rowID) >= 0) {
                        rowsToBeProcessed.add(row.rowID);
                    }
                });
                if (rowTreeRecord && rowTreeRecord.parent) {
                    processedRowsParents.add(rowTreeRecord.parent);
                }
            });
            return processedRowsParents;
        };
        /**
         * populates the rowsToBeSelected and rowsToBeIndeterminate sets
         * with the rows which will be eventually in selected/indeterminate state
         */
        IgxTreeGridSelectionService.prototype.calculateRowsNewSelectionState = function (args) {
            var _this = this;
            this.rowsToBeSelected = new Set(args.oldSelection ? args.oldSelection : this.getSelectedRows());
            this.rowsToBeIndeterminate = new Set(this.getIndeterminateRows());
            var visibleRowIDs = this.getRowIDs(this.allData);
            var removed = new Set(args.removed);
            var added = new Set(args.added);
            if (removed && removed.size) {
                var removedRowsParents = new Set();
                removedRowsParents = this.collectRowsChildrenAndDirectParents(removed, visibleRowIDs);
                removed.forEach(function (removedRow) {
                    _this.rowsToBeSelected.delete(removedRow);
                    _this.rowsToBeIndeterminate.delete(removedRow);
                });
                Array.from(removedRowsParents).forEach(function (parent) {
                    _this.handleParentSelectionState(parent, visibleRowIDs);
                });
            }
            if (added && added.size) {
                var addedRowsParents = new Set();
                addedRowsParents = this.collectRowsChildrenAndDirectParents(added, visibleRowIDs);
                added.forEach(function (addedRow) {
                    _this.rowsToBeSelected.add(addedRow);
                    _this.rowsToBeIndeterminate.delete(addedRow);
                });
                Array.from(addedRowsParents).forEach(function (parent) {
                    _this.handleParentSelectionState(parent, visibleRowIDs);
                });
            }
        };
        /**
         * recursively handle the selection state of the direct and indirect parents
         */
        IgxTreeGridSelectionService.prototype.handleParentSelectionState = function (treeRow, visibleRowIDs) {
            if (!treeRow) {
                return;
            }
            this.handleRowSelectionState(treeRow, visibleRowIDs);
            if (treeRow.parent) {
                this.handleParentSelectionState(treeRow.parent, visibleRowIDs);
            }
        };
        /**
         * Handle the selection state of a given row based the selection states of its direct children
         */
        IgxTreeGridSelectionService.prototype.handleRowSelectionState = function (treeRow, visibleRowIDs) {
            var _this = this;
            var visibleChildren = [];
            if (treeRow && treeRow.children) {
                visibleChildren = treeRow.children.filter(function (child) { return visibleRowIDs.indexOf(child.rowID) >= 0; });
            }
            if (visibleChildren.length) {
                if (visibleChildren.every(function (row) { return _this.rowsToBeSelected.has(row.rowID); })) {
                    this.rowsToBeSelected.add(treeRow.rowID);
                    this.rowsToBeIndeterminate.delete(treeRow.rowID);
                }
                else if (visibleChildren.some(function (row) { return _this.rowsToBeSelected.has(row.rowID) || _this.rowsToBeIndeterminate.has(row.rowID); })) {
                    this.rowsToBeIndeterminate.add(treeRow.rowID);
                    this.rowsToBeSelected.delete(treeRow.rowID);
                }
                else {
                    this.rowsToBeIndeterminate.delete(treeRow.rowID);
                    this.rowsToBeSelected.delete(treeRow.rowID);
                }
            }
            else {
                // if the children of the row has been deleted and the row was selected do not change its state
                if (this.isRowSelected(treeRow.rowID)) {
                    this.rowsToBeSelected.add(treeRow.rowID);
                    this.rowsToBeIndeterminate.delete(treeRow.rowID);
                }
                else {
                    this.rowsToBeSelected.delete(treeRow.rowID);
                    this.rowsToBeIndeterminate.delete(treeRow.rowID);
                }
            }
        };
        IgxTreeGridSelectionService.prototype.get_all_children = function (record) {
            var e_1, _a;
            var children = [];
            if (record && record.children && record.children.length) {
                try {
                    for (var _b = __values(record.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        children.push.apply(children, __spread(this.get_all_children(child)));
                        children.push(child);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return children;
        };
        return IgxTreeGridSelectionService;
    }(IgxGridSelectionService));
    IgxTreeGridSelectionService.decorators = [
        { type: i0.Injectable }
    ];

    var NEXT_ID$m = 0;
    /**
     * **Ignite UI for Angular Tree Grid** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid)
     *
     * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
     * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
     *
     * Example:
     * ```html
     * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" autoGenerate="false">
     *   <igx-column field="first" header="First Name"></igx-column>
     *   <igx-column field="last" header="Last Name"></igx-column>
     *   <igx-column field="role" header="Role"></igx-column>
     * </igx-tree-grid>
     * ```
     */
    var IgxTreeGridComponent = /** @class */ (function (_super) {
        __extends(IgxTreeGridComponent, _super);
        function IgxTreeGridComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            /**
             * An @Input property indicating whether child records should be deleted when their parent gets deleted.
             * By default it is set to true and deletes all children along with the parent.
             * ```html
             * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
             * </igx-tree-grid>
             * ```
             *
             * @memberof IgxTreeGridComponent
             */
            _this.cascadeOnDelete = true;
            /**
             * @hidden @internal
             */
            _this.role = 'treegrid';
            /**
             * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
             * ```html
             * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
             * ```
             *
             * @memberof IgxTreeGridComponent
             */
            _this.id = "igx-tree-grid-" + NEXT_ID$m++;
            /**
             * Returns a map of all `ITreeGridRecord`s.
             * ```typescript
             * // gets the record with primaryKey=2
             * const states = this.grid.records.get(2);
             * ```
             *
             * @memberof IgxTreeGridComponent
             */
            _this.records = new Map();
            /**
             * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
             * ```typescript
             * // gets the processed record with primaryKey=2
             * const states = this.grid.processedRecords.get(2);
             * ```
             *
             * @memberof IgxTreeGridComponent
             */
            _this.processedRecords = new Map();
            /**
             * @hidden
             */
            _this.loadingRows = new Set();
            _this._expansionDepth = Infinity;
            _this._filteredData = null;
            return _this;
        }
        Object.defineProperty(IgxTreeGridComponent.prototype, "data", {
            /**
             * An @Input property that lets you fill the `IgxTreeGridComponent` with an array of data.
             * ```html
             * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
             * ```
             *
             * @memberof IgxTreeGridComponent
             */
            get: function () {
                return this._data;
            },
            set: function (value) {
                this._data = value || [];
                this.summaryService.clearSummaryCache();
                if (this.shouldGenerate) {
                    this.setupColumns();
                }
                this.cdr.markForCheck();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridComponent.prototype, "filteredData", {
            /**
             * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
             * ```typescript
             * let filteredData = this.grid.filteredData;
             * ```
             *
             * @memberof IgxTreeGridComponent
             */
            get: function () {
                return this._filteredData;
            },
            /**
             * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
             * ```typescript
             * this.grid.filteredData = [{
             *       ID: 1,
             *       Name: "A"
             * }];
             * ```
             *
             * @memberof IgxTreeGridComponent
             */
            set: function (value) {
                this._filteredData = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridComponent.prototype, "transactions", {
            /**
             * Get transactions service for the grid.
             *
             * @experimental @hidden
             */
            get: function () {
                return this._transactions;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridComponent.prototype, "expansionDepth", {
            /**
             * An @Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
             * set to `Infinity` which means all levels would be expanded.
             * ```html
             * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
             * ```
             *
             * @memberof IgxTreeGridComponent
             */
            get: function () {
                return this._expansionDepth;
            },
            set: function (value) {
                this._expansionDepth = value;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridComponent.prototype, "rowLoadingIndicatorTemplate", {
            /**
             * An @Input property that provides a template for the row loading indicator when load on demand is enabled.
             * ```html
             * <ng-template #rowLoadingTemplate>
             *     <igx-icon>loop</igx-icon>
             * </ng-template>
             *
             * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
             *                [loadChildrenOnDemand]="loadChildren"
             *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
             * </igx-tree-grid>
             * ```
             *
             * @memberof IgxTreeGridComponent
             */
            get: function () {
                return this._rowLoadingIndicatorTemplate;
            },
            set: function (value) {
                this._rowLoadingIndicatorTemplate = value;
                this.notifyChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridComponent.prototype, "_gridAPI", {
            // Kind of stupid
            get: function () {
                return this.gridAPI;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTreeGridComponent.prototype.ngOnInit = function () {
            var _this = this;
            _super.prototype.ngOnInit.call(this);
            this.onRowToggle.pipe(operators.takeUntil(this.destroy$)).subscribe(function (args) {
                _this.loadChildrenOnRowExpansion(args);
            });
            this.onRowAdded.pipe(operators.takeUntil(this.destroy$)).subscribe(function (args) {
                if (_this.rowSelection === GridSelectionMode.multipleCascade) {
                    var rec_1 = _this._gridAPI.get_rec_by_id(_this.primaryKey ? args.data[_this.primaryKey] : args.data);
                    if (rec_1 && rec_1.parent) {
                        _this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec_1.parent]), rec_1.parent.rowID);
                    }
                    else {
                        // The record is still not available
                        // Wait for the change detection to update records through pipes
                        requestAnimationFrame(function () {
                            rec_1 = _this._gridAPI.get_rec_by_id(_this.primaryKey ?
                                args.data[_this.primaryKey] : args.data);
                            if (rec_1 && rec_1.parent) {
                                _this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec_1.parent]), rec_1.parent.rowID);
                            }
                            _this.notifyChanges();
                        });
                    }
                }
            });
            this.onRowDeleted.pipe(operators.takeUntil(this.destroy$)).subscribe(function (args) {
                if (_this.rowSelection === GridSelectionMode.multipleCascade) {
                    if (args.data) {
                        var rec = _this._gridAPI.get_rec_by_id(_this.primaryKey ? args.data[_this.primaryKey] : args.data);
                        _this.handleCascadeSelection(args, rec);
                    }
                    else {
                        // if a row has been added and before commiting the transaction deleted
                        var leafRowsDirectParents_1 = new Set();
                        _this.records.forEach(function (record) {
                            if (record && !record.children && record.parent) {
                                leafRowsDirectParents_1.add(record.parent);
                            }
                        });
                        // Wait for the change detection to update records through pipes
                        requestAnimationFrame(function () {
                            _this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(leafRowsDirectParents_1);
                            _this.notifyChanges();
                        });
                    }
                }
            });
            this.onFilteringDone.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                if (_this.rowSelection === GridSelectionMode.multipleCascade) {
                    var leafRowsDirectParents_2 = new Set();
                    _this.records.forEach(function (record) {
                        if (record && !record.children && record.parent) {
                            leafRowsDirectParents_2.add(record.parent);
                        }
                    });
                    _this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(leafRowsDirectParents_2);
                    _this.notifyChanges();
                }
            });
            this.transactions.onStateUpdate.pipe(operators.takeUntil(this.destroy$)).subscribe(function (event) {
                var e_1, _b;
                var actions = [];
                if (event.origin === exports.TransactionEventOrigin.REDO) {
                    actions = event.actions ? event.actions.filter(function (x) { return x.transaction.type === exports.TransactionType.DELETE; }) : [];
                    if (_this.rowSelection === GridSelectionMode.multipleCascade) {
                        _this.handleCascadeSelection(event);
                    }
                }
                else if (event.origin === exports.TransactionEventOrigin.UNDO) {
                    actions = event.actions ? event.actions.filter(function (x) { return x.transaction.type === exports.TransactionType.ADD; }) : [];
                    if (_this.rowSelection === GridSelectionMode.multipleCascade) {
                        if (event.actions[0].transaction.type === 'add') {
                            var rec = _this._gridAPI.get_rec_by_id(event.actions[0].transaction.id);
                            _this.handleCascadeSelection(event, rec);
                        }
                        else {
                            _this.handleCascadeSelection(event);
                        }
                    }
                }
                if (actions.length) {
                    try {
                        for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                            var action = actions_1_1.value;
                            _this.deselectChildren(action.transaction.id);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (actions_1_1 && !actions_1_1.done && (_b = actions_1.return)) _b.call(actions_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            });
        };
        IgxTreeGridComponent.prototype.ngDoCheck = function () {
            _super.prototype.ngDoCheck.call(this);
        };
        /**
         * @hidden
         */
        IgxTreeGridComponent.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            // TODO: pipesExectured event
            // run after change detection in super triggers pipes for records structure
            if (this.rowSelection === GridSelectionMode.multipleCascade && this.selectedRows.length) {
                var selRows = this.selectedRows;
                this.selectionService.clearRowSelection();
                this.selectRows(selRows, true);
                this.cdr.detectChanges();
            }
        };
        /**
         * @hidden
         */
        IgxTreeGridComponent.prototype.ngAfterContentInit = function () {
            if (this.rowLoadingTemplate) {
                this._rowLoadingIndicatorTemplate = this.rowLoadingTemplate.template;
            }
            _super.prototype.ngAfterContentInit.call(this);
        };
        IgxTreeGridComponent.prototype.getDefaultExpandState = function (record) {
            return record.children && record.children.length && record.level < this.expansionDepth;
        };
        /**
         * Expands all rows.
         * ```typescript
         * this.grid.expandAll();
         * ```
         *
         * @memberof IgxTreeGridComponent
         */
        IgxTreeGridComponent.prototype.expandAll = function () {
            this._expansionDepth = Infinity;
            this.expansionStates = new Map();
        };
        /**
         * Collapses all rows.
         *
         * ```typescript
         * this.grid.collapseAll();
         *  ```
         *
         * @memberof IgxTreeGridComponent
         */
        IgxTreeGridComponent.prototype.collapseAll = function () {
            this._expansionDepth = 0;
            this.expansionStates = new Map();
        };
        /**
         * @hidden
         */
        IgxTreeGridComponent.prototype.refreshGridState = function (args) {
            _super.prototype.refreshGridState.call(this);
            if (this.primaryKey && this.foreignKey) {
                var rowID = args.data[this.foreignKey];
                this.summaryService.clearSummaryCache({ rowID: rowID });
                this._pipeTrigger++;
                this.cdr.detectChanges();
            }
        };
        /**
         * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
         * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
         * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
         * ```typescript
         * const record = {
         *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
         *     Name: this.newRecord
         * };
         * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
         * ```
         *
         * @param data
         * @param parentRowID
         * @memberof IgxTreeGridComponent
         */
        IgxTreeGridComponent.prototype.addRow = function (data, parentRowID) {
            _super.prototype.endEdit.call(this, true);
            this.gridAPI.addRowToData(data, parentRowID);
            this.onRowAdded.emit({ data: data });
            this._pipeTrigger++;
            this.notifyChanges();
        };
        /**
         * @hidden
         */
        IgxTreeGridComponent.prototype.getContext = function (rowData, rowIndex, pinned) {
            return {
                $implicit: this.isGhostRecord(rowData) || this.isAddRowRecord(rowData) ? rowData.recordRef : rowData,
                index: this.getDataViewIndex(rowIndex, pinned),
                templateID: this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',
                disabled: this.isGhostRecord(rowData) ? rowData.recordRef.isFilteredOutParent === undefined : false,
                addRow: this.isAddRowRecord(rowData) ? rowData.addRow : false
            };
        };
        /**
         * @hidden
         * @internal
         */
        IgxTreeGridComponent.prototype.getInitialPinnedIndex = function (rec) {
            return this._pinnedRecordIDs.indexOf(rec.rowID);
        };
        /**
         * @inheritdoc
         */
        IgxTreeGridComponent.prototype.getSelectedData = function (formatters, headers) {
            if (formatters === void 0) { formatters = false; }
            if (headers === void 0) { headers = false; }
            var source = [];
            var process = function (record) {
                if (record.summaries) {
                    source.push(null);
                    return;
                }
                source.push(record.data);
            };
            this.unpinnedDataView.forEach(process);
            source = this.isRowPinningToTop ? __spread(this.pinnedDataView, source) : __spread(source, this.pinnedDataView);
            return this.extractDataFromSelection(source, formatters, headers);
        };
        IgxTreeGridComponent.prototype.getEmptyRecordObjectFor = function (rec) {
            var _this = this;
            var row = Object.assign({}, rec);
            var data = rec || {};
            row.data = Object.assign({}, data);
            Object.keys(row.data).forEach(function (key) {
                // persist foreign key if one is set.
                if (_this.foreignKey && key === _this.foreignKey) {
                    row.data[key] = rec.data[key];
                }
                else {
                    row.data[key] = undefined;
                }
            });
            var id = this.generateRowID();
            var rootRecPK = this.foreignKey && this.rootRecords && this.rootRecords.length > 0 ?
                this.rootRecords[0].data[this.foreignKey] : null;
            if (id === rootRecPK) {
                // safeguard in case generated id matches the root foreign key.
                id = this.generateRowID();
            }
            row.rowID = id;
            row.data[this.primaryKey] = id;
            return row;
        };
        /** @hidden */
        IgxTreeGridComponent.prototype.deleteRowById = function (rowId) {
            //  if this is flat self-referencing data, and CascadeOnDelete is set to true
            //  and if we have transactions we should start pending transaction. This allows
            //  us in case of delete action to delete all child rows as single undo action
            this._gridAPI.deleteRowById(rowId);
        };
        /** @hidden */
        IgxTreeGridComponent.prototype.generateRowPath = function (rowId) {
            var path = [];
            var record = this.records.get(rowId);
            while (record.parent) {
                path.push(record.parent.rowID);
                record = record.parent;
            }
            return path.reverse();
        };
        IgxTreeGridComponent.prototype.findRecordIndexInView = function (rec) {
            var _this = this;
            return this.dataView.findIndex(function (x) { return x.data[_this.primaryKey] === rec[_this.primaryKey]; });
        };
        IgxTreeGridComponent.prototype.getUnpinnedIndexById = function (id) {
            var _this = this;
            return this.unpinnedRecords.findIndex(function (x) { return x.data[_this.primaryKey] === id; });
        };
        /**
         * @hidden
         * @internal
         */
        IgxTreeGridComponent.prototype._getParentRecordId = function () {
            var _a;
            if (this.addRowParent.asChild) {
                return _super.prototype._getParentRecordId.call(this);
            }
            else if (this.addRowParent.rowID !== null && this.addRowParent.rowID !== undefined) {
                var spawnedForRecord = this._gridAPI.get_rec_by_id(this.addRowParent.rowID);
                return (_a = spawnedForRecord === null || spawnedForRecord === void 0 ? void 0 : spawnedForRecord.parent) === null || _a === void 0 ? void 0 : _a.rowID;
            }
        };
        /**
         * @hidden @internal
         */
        IgxTreeGridComponent.prototype.getDataBasedBodyHeight = function () {
            return !this.flatData || (this.flatData.length < this._defaultTargetRecordNumber) ?
                0 : this.defaultTargetBodyHeight;
        };
        /**
         * @hidden
         */
        IgxTreeGridComponent.prototype.scrollTo = function (row, column) {
            var _this = this;
            var delayScrolling = false;
            var record;
            if (typeof (row) !== 'number') {
                var rowData = row;
                var rowID = this._gridAPI.get_row_id(rowData);
                record = this.processedRecords.get(rowID);
                this._gridAPI.expand_path_to_record(record);
                if (this.paging) {
                    var rowIndex = this.processedExpandedFlatData.indexOf(rowData);
                    var page = Math.floor(rowIndex / this.perPage);
                    if (this.page !== page) {
                        delayScrolling = true;
                        this.page = page;
                    }
                }
            }
            if (delayScrolling) {
                this.verticalScrollContainer.onDataChanged.pipe(operators.first()).subscribe(function () {
                    _this.scrollDirective(_this.verticalScrollContainer, typeof (row) === 'number' ? row : _this.unpinnedDataView.indexOf(record));
                });
            }
            else {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(record));
            }
            this.scrollToHorizontally(column);
        };
        IgxTreeGridComponent.prototype.writeToData = function (rowIndex, value) {
            mergeObjects(this.flatData[rowIndex], value);
        };
        /**
         * @hidden
         */
        IgxTreeGridComponent.prototype.initColumns = function (collection, cb) {
            if (cb === void 0) { cb = null; }
            if (this.hasColumnLayouts) {
                // invalid configuration - tree grid should not allow column layouts
                // remove column layouts
                var nonColumnLayoutColumns = this.columnList.filter(function (col) { return !col.columnLayout && !col.columnLayoutChild; });
                this.columnList.reset(nonColumnLayoutColumns);
            }
            _super.prototype.initColumns.call(this, collection, cb);
        };
        /**
         * @description A recursive way to deselect all selected children of a given record
         * @param recordID ID of the record whose children to deselect
         * @hidden
         * @internal
         */
        IgxTreeGridComponent.prototype.deselectChildren = function (recordID) {
            var _this = this;
            var selectedChildren = [];
            var rowToDeselect = this.getRowByKey(recordID).treeRow;
            this.selectionService.deselectRow(recordID);
            this._gridAPI.get_selected_children(rowToDeselect, selectedChildren);
            if (selectedChildren.length > 0) {
                selectedChildren.forEach(function (x) { return _this.deselectChildren(x); });
            }
        };
        IgxTreeGridComponent.prototype.addChildRows = function (children, parentID) {
            var e_2, _b, _c;
            var _this = this;
            if (this.primaryKey && this.foreignKey) {
                try {
                    for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
                        var child = children_1_1.value;
                        child[this.foreignKey] = parentID;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (children_1_1 && !children_1_1.done && (_b = children_1.return)) _b.call(children_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                (_c = this.data).push.apply(_c, __spread(children));
            }
            else if (this.childDataKey) {
                var parent = this.records.get(parentID);
                var parentData = parent.data;
                if (this.transactions.enabled && this.transactions.getAggregatedChanges(true).length) {
                    var path = [];
                    while (parent) {
                        path.push(parent.rowID);
                        parent = parent.parent;
                    }
                    var collection = this.data;
                    var record = void 0;
                    var _loop_1 = function (i) {
                        var pid = path[i];
                        record = collection.find(function (r) { return r[_this.primaryKey] === pid; });
                        if (!record) {
                            return "break";
                        }
                        collection = record[this_1.childDataKey];
                    };
                    var this_1 = this;
                    for (var i = path.length - 1; i >= 0; i--) {
                        var state_1 = _loop_1(i);
                        if (state_1 === "break")
                            break;
                    }
                    if (record) {
                        parentData = record;
                    }
                }
                parentData[this.childDataKey] = children;
            }
            this.selectionService.clearHeaderCBState();
            this._pipeTrigger++;
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                // Force pipe triggering for building the data structure
                this.cdr.detectChanges();
                if (this.selectionService.isRowSelected(parentID)) {
                    this.selectionService.rowSelection.delete(parentID);
                    this.selectionService.selectRowsWithNoEvent([parentID]);
                }
            }
        };
        IgxTreeGridComponent.prototype.loadChildrenOnRowExpansion = function (args) {
            var _this = this;
            if (this.loadChildrenOnDemand) {
                var parentID_1 = args.rowID;
                if (args.expanded && !this._expansionStates.has(parentID_1)) {
                    this.loadingRows.add(parentID_1);
                    this.loadChildrenOnDemand(parentID_1, function (children) {
                        _this.loadingRows.delete(parentID_1);
                        _this.addChildRows(children, parentID_1);
                        _this.notifyChanges();
                    });
                }
            }
        };
        IgxTreeGridComponent.prototype.handleCascadeSelection = function (event, rec) {
            var _this = this;
            if (rec === void 0) { rec = null; }
            // Wait for the change detection to update records through the pipes
            requestAnimationFrame(function () {
                if (rec === null) {
                    rec = _this._gridAPI.get_rec_by_id(event.actions[0].transaction.id);
                }
                if (rec && rec.parent) {
                    _this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec.parent]), rec.parent.rowID);
                    _this.notifyChanges();
                }
            });
        };
        return IgxTreeGridComponent;
    }(IgxGridBaseDirective));
    IgxTreeGridComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-tree-grid',
                    template: "<ng-content select=\"igx-grid-toolbar\"></ng-content>\n\n<div class=\"igx-grid__thead\" role=\"rowgroup\">\n    <div class=\"igx-grid__thead-wrapper\" (keydown.meta.c)=\"copyHandler($event)\" (keydown.control.c)=\"copyHandler($event)\" \n    (copy)=\"copyHandler($event)\" [style.width.px]='calcWidth' tabindex=\"0\" (focus)=\"navigation.focusFirstCell()\" \n    (keydown)=\"navigation.headerNavigation($event)\" #theadRow [attr.aria-activedescendant]=\"activeDescendant\">\n        <div class=\"igx-grid__tr\" [style.width.px]='calcWidth' role=\"row\">\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator igx-grid__tr-action\" (pointerdown)=\"$event.preventDefault()\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible }\" (pointerdown)=\"$event.preventDefault()\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                 </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]=\"'calcPixelWidth'\" #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\" [style.left]=\"col.rightPinnedOffset\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollSize\"></div>\n    <div igxToggle #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\" role=\"rowgroup\">\n    <div class=\"igx-grid__tbody-content\"  tabindex=\"0\" (focus)=\"navigation.focusTbody($event)\" (keydown)=\"navigation.handleNavigation($event)\" \n    (onDragStop)=\"selectionService.dragMode = $event\" [attr.aria-activedescendant]=\"activeDescendant\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth' #tbody (scroll)='preventContainerScroll($event)'>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template #pinnedRecordsTemplate>\n            <ng-container *ngIf='data\n            | treeGridTransaction:pipeTrigger\n            | visibleColumns:hasVisibleColumns\n            | treeGridNormalizeRecord:pipeTrigger\n            | gridRowPinning:id:true:pipeTrigger\n            | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:pipeTrigger:filteringPipeTrigger:true\n            | treeGridSorting:sortingExpressions:sortStrategy:pipeTrigger:true\n            | gridAddRow:true:pipeTrigger as pinnedData'>\n                <div #pinContainer *ngIf='pinnedData.length > 0'\n                    [ngClass]=\"{\n                        'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                        'igx-grid__tr--pinned-top': isRowPinningToTop\n                    }\"\n                    class='igx-grid__tr--pinned' [style.width.px]='calcWidth'>\n                    <ng-container *ngFor=\"let rowData of pinnedData;let rowIndex = index;\">\n                        <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                        </ng-container>\n                    </ng-container>\n                </div>\n            </ng-container>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | treeGridTransaction:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:pipeTrigger:filteringPipeTrigger\n        | treeGridSorting:sortingExpressions:sortStrategy:pipeTrigger\n        | treeGridFlattening:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:page:perPage:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:showSummaryOnCollapse:pipeTrigger:summaryPipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\n        | gridAddRow:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" #verticalScrollContainer>\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex, false)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-disabledRow=\"disabled\" let-rowData let-isAddRow=\"addRow\">\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" [disabled]=\"disabledRow\" [addRow]=\"isAddRow\" #row>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData let-isAddRow=\"addRow\">\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" [addRow]=\"isAddRow\" #row #pinnedRow>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\"\n                [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" role=\"row\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\"  (pointerdown)=\"$event.preventDefault()\"\n            [style.height.px]='calcHeight'>\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [actionText]=\"snackbarActionText\" [displayTime]='snackbarDisplayTime'>{{snackbarLabel}}</igx-snackbar>\n    </div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <div tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\" \n    (keydown)=\"navigation.summaryNav($event)\" [attr.aria-activedescendant]=\"activeDescendant\">\n        <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n            *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n            [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n            class=\"igx-grid__summaries\" #summaryRow>\n        </igx-grid-summary-row>\n        <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n            [style.width.px]=\"scrollSize\"></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\" (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [overlaySettings]=\"paginatorSettings\" [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\"\n        [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button igxButton=\"raised\" igxRipple (click)='beginAddRowByIndex(null, -1, $event)'>\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle #rowEditingOverlay>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\" *ngIf=\"!this.crudService.row?.isAddRow\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon>drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [readonly]=\"true\"\n            disableRipple=\"true\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n",
                    providers: [
                        IgxGridCRUDService,
                        IgxGridSummaryService,
                        IgxGridNavigationService,
                        { provide: IgxGridSelectionService, useClass: IgxTreeGridSelectionService },
                        { provide: GridBaseAPIService, useClass: IgxTreeGridAPIService },
                        { provide: IgxGridBaseDirective, useExisting: i0.forwardRef(function () { return IgxTreeGridComponent; }) },
                        IgxFilteringService,
                        IgxForOfSyncService,
                        IgxForOfScrollSyncService
                    ]
                },] }
    ];
    IgxTreeGridComponent.propDecorators = {
        childDataKey: [{ type: i0.Input }],
        foreignKey: [{ type: i0.Input }],
        hasChildrenKey: [{ type: i0.Input }],
        cascadeOnDelete: [{ type: i0.Input }],
        loadChildrenOnDemand: [{ type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        dragIndicatorIconBase: [{ type: i0.ViewChild, args: ['dragIndicatorIconBase', { read: i0.TemplateRef, static: true },] }],
        recordTemplate: [{ type: i0.ViewChild, args: ['record_template', { read: i0.TemplateRef, static: true },] }],
        summaryTemplate: [{ type: i0.ViewChild, args: ['summary_template', { read: i0.TemplateRef, static: true },] }],
        rowLoadingTemplate: [{ type: i0.ContentChild, args: [IgxRowLoadingIndicatorTemplateDirective, { read: IgxRowLoadingIndicatorTemplateDirective },] }],
        data: [{ type: i0.Input }],
        expansionDepth: [{ type: i0.Input }],
        rowLoadingIndicatorTemplate: [{ type: i0.Input }]
    };

    var IgxTreeGridRowComponent = /** @class */ (function (_super) {
        __extends(IgxTreeGridRowComponent, _super);
        function IgxTreeGridRowComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IgxTreeGridRowComponent.prototype, "treeRow", {
            /**
             * The `ITreeGridRecord` passed to the row component.
             *
             * ```typescript
             * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
             * const treeRow = row.treeRow;
             * ```
             */
            get: function () {
                return this._treeRow;
            },
            set: function (value) {
                if (this._treeRow !== value) {
                    this._treeRow = value;
                    this.rowData = this._treeRow.data;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridRowComponent.prototype, "pinned", {
            /**
             * Gets whether the row is pinned.
             * ```typescript
             * let isPinned = row.pinned;
             * ```
             */
            get: function () {
                return this.grid.isRecordPinned(this._treeRow);
            },
            /**
             * Sets whether the row is pinned.
             * Default value is `false`.
             * ```typescript
             * this.grid.selectedRows[0].pinned = true;
             * ```
             */
            set: function (value) {
                if (value) {
                    this.grid.pinRow(this.rowID);
                }
                else {
                    this.grid.unpinRow(this.rowID);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridRowComponent.prototype, "isRoot", {
            /**
             * @hidden
             */
            get: function () {
                var _this = this;
                var treeRec = this.treeRow;
                var isPinnedArea = this.pinned && !this.disabled;
                if (isPinnedArea) {
                    treeRec = this.grid.unpinnedRecords.find(function (x) { return x.data === _this.rowData; });
                }
                return treeRec.level === 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridRowComponent.prototype, "hasChildren", {
            /**
             * @hidden
             */
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridRowComponent.prototype, "expanded", {
            /**
             * Returns a value indicating whether the row component is expanded.
             *
             * ```typescript
             * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
             * const expanded = row.expanded;
             * ```
             */
            get: function () {
                return this._treeRow.expanded;
            },
            /**
             * Sets a value indicating whether the row component is expanded.
             *
             * ```typescript
             * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
             * row.expanded = true;
             * ```
             */
            set: function (value) {
                this.gridAPI.set_row_expansion_state(this._treeRow.rowID, value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridRowComponent.prototype, "viewIndex", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.index + this.grid.page * this.grid.perPage;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridRowComponent.prototype, "showIndicator", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.loadChildrenOnDemand ?
                    this.grid.expansionStates.has(this.rowID) ?
                        this.treeRow.children && this.treeRow.children.length :
                        this.grid.hasChildrenKey ?
                            this.rowData[this.grid.hasChildrenKey] :
                            true :
                    this.treeRow.children && this.treeRow.children.length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridRowComponent.prototype, "indeterminate", {
            /**
             * @hidden
             */
            get: function () {
                return this.selectionService.isRowInIndeterminateState(this.rowID);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTreeGridRowComponent.prototype.ngDoCheck = function () {
            this.isLoading = this.grid.loadChildrenOnDemand ? this.grid.loadingRows.has(this.rowID) : false;
            _super.prototype.ngDoCheck.call(this);
        };
        /**
         * Spawns the add child row UI for the specific row.
         *
         * @example
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * row.beginAddChild();
         * ```
         * @param rowID
         */
        IgxTreeGridRowComponent.prototype.beginAddChild = function () {
            this.grid.beginAddRowByIndex(this.rowID, this.index, true);
        };
        /**
         * @hidden
         */
        IgxTreeGridRowComponent.prototype.resolveClasses = function () {
            var classes = _super.prototype.resolveClasses.call(this);
            var filteredClass = this.treeRow.isFilteredOutParent ? 'igx-grid__tr--filtered' : '';
            return classes + " " + filteredClass;
        };
        return IgxTreeGridRowComponent;
    }(IgxRowDirective));
    IgxTreeGridRowComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    selector: 'igx-tree-grid-row',
                    template: "<ng-container *ngTemplateOutlet='addRow ? addTemp : defaultTemp'></ng-container>\n\n<ng-template #addTemp>\n    <div class='igx-grid__tr--inner' [class.igx-grid__tr--add-animate]='animateAdd' (animationend)='animationEndHandler()'>\n        <ng-container *ngTemplateOutlet='defaultTemp'></ng-container>\n    </div>\n</ng-template>\n<ng-template #defaultTemp>\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" (click)=\"onRowSelectorClick($event)\" (pointerdown)=\"$event.preventDefault()\">\n        <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n        </ng-template>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n    <ng-container *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-container>\n</ng-container>\n<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]=\"'calcPixelWidth'\" [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <ng-template #cellTemplate>\n        <igx-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"cellHeight\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n            #treeCell>\n        </igx-grid-cell>\n    </ng-template>\n    <ng-template #treeCellTemplate>\n        <igx-tree-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n            [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [level]=\"treeRow.level\"\n            [expanded]=\"treeRow.expanded\"\n            [showIndicator]=\"showIndicator\"\n            [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"cellHeight\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n            [isLoading]=\"isLoading\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n            #treeCell>\n        </igx-tree-grid-cell>\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n</ng-template>\n<ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n    <ng-container *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-container>\n</ng-container>\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"selected\"\n            [indeterminate]=\"indeterminate\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<ng-template #pinnedCellsTemplate let-col>\n    <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n        <ng-template #cellTemplate>\n            <igx-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n                [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n                [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n                [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [firstPinned]=\"col.isFirstPinned\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"cellHeight\"\n                [rowData]=\"rowData\"\n                [style.min-width]=\"col.width\"\n                [style.max-width]=\"col.width\"\n                [style.flex-basis]=\"col.width\"\n                [style.left]=\"col.rightPinnedOffset\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [lastSearchInfo]=\"grid.lastSearchInfo\"\n                [active]=\"isCellActive(col.visibleIndex)\"\n                [cellSelectionMode]=\"grid.cellSelection\"\n                [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n                #treeCell>\n            </igx-grid-cell>\n            </ng-template>\n        <ng-template #treeCellTemplate>\n            <igx-tree-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell igx-grid__td--pinned\"\n                [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n                [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n                [level]=\"treeRow.level\"\n                [expanded]=\"treeRow.expanded\"\n                [showIndicator]=\"showIndicator\"\n                [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"cellHeight\"\n                [rowData]=\"rowData\"\n                [style.min-width]=\"col.width\"\n                [style.max-width]=\"col.width\"\n                [style.flex-basis]=\"col.width\"\n                [style.left]=\"col.rightPinnedOffset\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n                [isLoading]=\"isLoading\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [lastSearchInfo]=\"grid.lastSearchInfo\"\n                [active]=\"isCellActive(col.visibleIndex)\"\n                [cellSelectionMode]=\"grid.cellSelection\"\n                [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n                #treeCell>\n            </igx-tree-grid-cell>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n    </ng-template>\n</ng-template>\n",
                    providers: [{ provide: IgxRowDirective, useExisting: i0.forwardRef(function () { return IgxTreeGridRowComponent; }) }]
                },] }
    ];
    IgxTreeGridRowComponent.propDecorators = {
        _cells: [{ type: i0.ViewChildren, args: ['treeCell',] }],
        treeRow: [{ type: i0.Input }],
        expanded: [{ type: i0.HostBinding, args: ['attr.aria-expanded',] }]
    };

    /**
     * @hidden
     */
    var IgxTreeGridHierarchizingPipe = /** @class */ (function () {
        function IgxTreeGridHierarchizingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridHierarchizingPipe.prototype.transform = function (collection, primaryKey, foreignKey, childDataKey, _) {
            var _this = this;
            var grid = this.gridAPI.grid;
            var hierarchicalRecords = [];
            var treeGridRecordsMap = new Map();
            var flatData = [];
            if (primaryKey && foreignKey) {
                hierarchicalRecords = this.hierarchizeFlatData(collection, primaryKey, foreignKey, treeGridRecordsMap, flatData);
            }
            else if (childDataKey) {
                hierarchicalRecords = this.hierarchizeRecursive(collection, primaryKey, childDataKey, undefined, flatData, 0, treeGridRecordsMap);
            }
            grid.flatData = grid.transactions.enabled ?
                flatData.filter(function (rec) { return !grid.transactions.getState(_this.getRowID(primaryKey, rec)); }) : flatData;
            grid.records = treeGridRecordsMap;
            grid.rootRecords = hierarchicalRecords;
            return hierarchicalRecords;
        };
        IgxTreeGridHierarchizingPipe.prototype.getRowID = function (primaryKey, rowData) {
            return primaryKey ? rowData[primaryKey] : rowData;
        };
        IgxTreeGridHierarchizingPipe.prototype.hierarchizeFlatData = function (collection, primaryKey, foreignKey, map, flatData) {
            var _this = this;
            var result = [];
            var missingParentRecords = [];
            collection.forEach(function (row) {
                var record = {
                    rowID: _this.getRowID(primaryKey, row),
                    data: row,
                    children: []
                };
                var parent = map.get(row[foreignKey]);
                if (parent) {
                    record.parent = parent;
                    parent.children.push(record);
                }
                else {
                    missingParentRecords.push(record);
                }
                map.set(row[primaryKey], record);
            });
            missingParentRecords.forEach(function (record) {
                var parent = map.get(record.data[foreignKey]);
                if (parent) {
                    record.parent = parent;
                    parent.children.push(record);
                }
                else {
                    result.push(record);
                }
            });
            this.setIndentationLevels(result, 0, flatData);
            return result;
        };
        IgxTreeGridHierarchizingPipe.prototype.setIndentationLevels = function (collection, indentationLevel, flatData) {
            var e_1, _a;
            try {
                for (var collection_1 = __values(collection), collection_1_1 = collection_1.next(); !collection_1_1.done; collection_1_1 = collection_1.next()) {
                    var record = collection_1_1.value;
                    record.level = indentationLevel;
                    record.expanded = this.gridAPI.get_row_expansion_state(record);
                    flatData.push(record.data);
                    if (record.children && record.children.length > 0) {
                        this.setIndentationLevels(record.children, indentationLevel + 1, flatData);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (collection_1_1 && !collection_1_1.done && (_a = collection_1.return)) _a.call(collection_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        IgxTreeGridHierarchizingPipe.prototype.hierarchizeRecursive = function (collection, primaryKey, childDataKey, parent, flatData, indentationLevel, map) {
            var e_2, _a;
            var result = [];
            try {
                for (var collection_2 = __values(collection), collection_2_1 = collection_2.next(); !collection_2_1.done; collection_2_1 = collection_2.next()) {
                    var item = collection_2_1.value;
                    var record = {
                        rowID: this.getRowID(primaryKey, item),
                        data: item,
                        parent: parent,
                        level: indentationLevel
                    };
                    record.expanded = this.gridAPI.get_row_expansion_state(record);
                    flatData.push(item);
                    map.set(record.rowID, record);
                    record.children = item[childDataKey] ?
                        this.hierarchizeRecursive(item[childDataKey], primaryKey, childDataKey, record, flatData, indentationLevel + 1, map) :
                        undefined;
                    result.push(record);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (collection_2_1 && !collection_2_1.done && (_a = collection_2.return)) _a.call(collection_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return result;
        };
        return IgxTreeGridHierarchizingPipe;
    }());
    IgxTreeGridHierarchizingPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'treeGridHierarchizing',
                    pure: true
                },] }
    ];
    IgxTreeGridHierarchizingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    /**
     * @hidden
     */
    var IgxTreeGridFlatteningPipe = /** @class */ (function () {
        function IgxTreeGridFlatteningPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridFlatteningPipe.prototype.transform = function (collection, expandedLevels, expandedStates, _) {
            var grid = this.gridAPI.grid;
            var data = [];
            grid.processedRootRecords = collection;
            grid.processedRecords = new Map();
            this.getFlatDataRecursive(collection, data, expandedLevels, expandedStates, true);
            grid.processedExpandedFlatData = data.map(function (r) { return r.data; });
            return data;
        };
        IgxTreeGridFlatteningPipe.prototype.getFlatDataRecursive = function (collection, data, expandedLevels, expandedStates, parentExpanded) {
            var e_3, _a;
            if (!collection || !collection.length) {
                return;
            }
            var grid = this.gridAPI.grid;
            try {
                for (var collection_3 = __values(collection), collection_3_1 = collection_3.next(); !collection_3_1.done; collection_3_1 = collection_3.next()) {
                    var hierarchicalRecord = collection_3_1.value;
                    if (parentExpanded) {
                        data.push(hierarchicalRecord);
                    }
                    hierarchicalRecord.expanded = this.gridAPI.get_row_expansion_state(hierarchicalRecord);
                    this.updateNonProcessedRecordExpansion(grid, hierarchicalRecord);
                    grid.processedRecords.set(hierarchicalRecord.rowID, hierarchicalRecord);
                    this.getFlatDataRecursive(hierarchicalRecord.children, data, expandedLevels, expandedStates, parentExpanded && hierarchicalRecord.expanded);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (collection_3_1 && !collection_3_1.done && (_a = collection_3.return)) _a.call(collection_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
        };
        IgxTreeGridFlatteningPipe.prototype.updateNonProcessedRecordExpansion = function (grid, record) {
            var rec = grid.records.get(record.rowID);
            rec.expanded = record.expanded;
        };
        return IgxTreeGridFlatteningPipe;
    }());
    IgxTreeGridFlatteningPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'treeGridFlattening',
                    pure: true
                },] }
    ];
    IgxTreeGridFlatteningPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    /** @hidden */
    var IgxTreeGridSortingPipe = /** @class */ (function () {
        function IgxTreeGridSortingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridSortingPipe.prototype.transform = function (hierarchicalData, expressions, sorting, _, pinned) {
            var grid = this.gridAPI.grid;
            var result;
            if (!expressions.length) {
                result = hierarchicalData;
            }
            else {
                result = DataUtil.treeGridSort(hierarchicalData, expressions, sorting, null, grid);
            }
            var filteredSortedData = [];
            this.flattenTreeGridRecords(result, filteredSortedData);
            grid.setFilteredSortedData(filteredSortedData, pinned);
            return result;
        };
        IgxTreeGridSortingPipe.prototype.flattenTreeGridRecords = function (records, flatData) {
            var e_4, _a;
            if (records && records.length) {
                try {
                    for (var records_1 = __values(records), records_1_1 = records_1.next(); !records_1_1.done; records_1_1 = records_1.next()) {
                        var record = records_1_1.value;
                        flatData.push(record.data);
                        this.flattenTreeGridRecords(record.children, flatData);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (records_1_1 && !records_1_1.done && (_a = records_1.return)) _a.call(records_1);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        };
        return IgxTreeGridSortingPipe;
    }());
    IgxTreeGridSortingPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'treeGridSorting',
                    pure: true
                },] }
    ];
    IgxTreeGridSortingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    /** @hidden */
    var IgxTreeGridPagingPipe = /** @class */ (function () {
        function IgxTreeGridPagingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridPagingPipe.prototype.transform = function (collection, page, perPage, _) {
            if (page === void 0) { page = 0; }
            if (perPage === void 0) { perPage = 15; }
            var grid = this.gridAPI.grid;
            if (!grid.paging || grid.pagingMode !== exports.GridPagingMode.Local) {
                return collection;
            }
            var len = grid._totalRecords >= 0 ? grid._totalRecords : collection.length;
            var totalPages = Math.ceil(len / perPage);
            var state = {
                index: (totalPages > 0 && page >= totalPages) ? totalPages - 1 : page,
                recordsPerPage: perPage
            };
            var result = DataUtil.page(cloneArray(collection), state, len);
            grid.pagingState = state;
            grid._page = state.index;
            return result;
        };
        return IgxTreeGridPagingPipe;
    }());
    IgxTreeGridPagingPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'treeGridPaging',
                    pure: true
                },] }
    ];
    IgxTreeGridPagingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    /** @hidden */
    var IgxTreeGridTransactionPipe = /** @class */ (function () {
        function IgxTreeGridTransactionPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridTransactionPipe.prototype.transform = function (collection, _) {
            var grid = this.gridAPI.grid;
            if (grid.transactions.enabled) {
                var aggregatedChanges = grid.transactions.getAggregatedChanges(true);
                if (aggregatedChanges.length > 0) {
                    var primaryKey = grid.primaryKey;
                    if (!primaryKey) {
                        return collection;
                    }
                    var foreignKey = grid.foreignKey;
                    var childDataKey = grid.childDataKey;
                    if (foreignKey) {
                        var flatDataClone = cloneArray(collection);
                        return DataUtil.mergeTransactions(flatDataClone, aggregatedChanges, grid.primaryKey);
                    }
                    else if (childDataKey) {
                        var hierarchicalDataClone = cloneHierarchicalArray(collection, childDataKey);
                        return DataUtil.mergeHierarchicalTransactions(hierarchicalDataClone, aggregatedChanges, childDataKey, grid.primaryKey);
                    }
                }
            }
            return collection;
        };
        return IgxTreeGridTransactionPipe;
    }());
    IgxTreeGridTransactionPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'treeGridTransaction',
                    pure: true
                },] }
    ];
    IgxTreeGridTransactionPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    /**
     * This pipe maps the original record to ITreeGridRecord format used in TreeGrid.
     */
    var IgxTreeGridNormalizeRecordsPipe = /** @class */ (function () {
        function IgxTreeGridNormalizeRecordsPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridNormalizeRecordsPipe.prototype.transform = function (_, __) {
            var grid = this.gridAPI.grid;
            var primaryKey = grid.primaryKey;
            // using flattened data because origin data may be hierarchical.
            var flatData = grid.flatData;
            var res = flatData.map(function (rec) { return ({
                rowID: grid.primaryKey ? rec[primaryKey] : rec,
                data: rec,
                level: 0,
                children: []
            }); });
            return res;
        };
        return IgxTreeGridNormalizeRecordsPipe;
    }());
    IgxTreeGridNormalizeRecordsPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'treeGridNormalizeRecord',
                    pure: true
                },] }
    ];
    IgxTreeGridNormalizeRecordsPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };

    var IgxTreeGridCellComponent = /** @class */ (function (_super) {
        __extends(IgxTreeGridCellComponent, _super);
        function IgxTreeGridCellComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            /**
             * @hidden
             */
            _this.level = 0;
            /**
             * @hidden
             */
            _this.showIndicator = false;
            return _this;
        }
        Object.defineProperty(IgxTreeGridCellComponent.prototype, "treeGridAPI", {
            get: function () {
                return this.gridAPI;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTreeGridCellComponent.prototype.toggle = function (event) {
            event.stopPropagation();
            this.treeGridAPI.set_row_expansion_state(this.row.rowID, !this.row.expanded, event);
        };
        /**
         * @hidden
         */
        IgxTreeGridCellComponent.prototype.onLoadingDblClick = function (event) {
            event.stopPropagation();
        };
        return IgxTreeGridCellComponent;
    }(IgxGridExpandableCellComponent));
    IgxTreeGridCellComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    selector: 'igx-tree-grid-cell',
                    template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip\n        *ngIf=\"displayPinnedChip\"\n        class=\"igx-grid__td--pinned-chip\"\n        [disabled]=\"true\"\n        [displayDensity]=\"'compact'\"\n        >{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip\n    >\n</ng-template>\n<ng-template #defaultCell>\n    <div *ngIf=\"column.dataType !== 'boolean'\"\n        igxTextHighlight\n        class=\"igx-grid__td-text\"\n        style=\"pointer-events: none;\"\n        [cssClass]=\"highlightClass\"\n        [activeCssClass]=\"activeHighlightClass\"\n        [groupName]=\"gridID\"\n        [value]=\"\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === 'number'\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'date'\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : column.dataType === 'currency'\n                ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'percent'\n                ? (value | percent:column.pipeArgs.digitsInfo:grid.locale)\n                : value\n        \"\n        [row]=\"rowData\"\n        [column]=\"this.column.field\"\n        [containerClass]=\"'igx-grid__td-text'\"\n        [metadata]=\"searchMetadata\"\n    >{{\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === \"number\"\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === \"date\"\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : column.dataType === 'currency'\n                ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'percent'\n                ? (value | percent:column.pipeArgs.digitsInfo:grid.locale)\n                : value\n        }}</div>\n    <igx-icon\n        *ngIf=\"column.dataType === 'boolean'\"\n        [ngClass]=\"{ 'igx-icon--success': value, 'igx-icon--error': !value }\"\n        >{{ value ? \"check\" : \"close\" }}</igx-icon\n    >\n</ng-template>\n<ng-template #addRowCell let-cell=\"cell\">\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n    [cssClass]=\"highlightClass\"\n    [activeCssClass]=\"activeHighlightClass\"\n    [groupName]=\"gridID\"\n    [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ?\n        (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ?\n        (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : column.dataType === 'currency'?\n        (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'percent' ?\n        (value | percent:column.pipeArgs.digitsInfo:grid.locale) : value\"\n    [row]=\"rowData\"\n    [column]=\"this.column.field\"\n    [containerClass]=\"'igx-grid__td-text'\"\n    [metadata]=\"searchMetadata\">{{\n        !isEmptyAddRowCell ? value : (column.header || column.field)\n    }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"true\" />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [(ngModel)]=\"editValue\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox\n            (change)=\"editValue = $event.checked\"\n            [value]=\"editValue\"\n            [checked]=\"editValue\"\n            [disableRipple]=\"true\"\n        ></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker\n            [style.width.%]=\"100\"\n            [outlet]=\"grid.outlet\"\n            mode=\"dropdown\"\n            [locale]=\"grid.locale\"\n            [(value)]=\"editValue\"\n            [igxFocus]=\"true\"\n            [labelVisibility]=\"false\"\n        >\n        </igx-date-picker>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'currency'\">\n        <igx-input-group displayDensity=\"compact\">\n            <igx-prefix *ngIf=\"grid.currencyPositionLeft\">{{ currencyCodeSymbol }}</igx-prefix>\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n            <igx-suffix *ngIf=\"!grid.currencyPositionLeft\" >{{ currencyCodeSymbol }}</igx-suffix>\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'percent'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n            <igx-suffix> {{ editValue | percent:column.pipeArgs.digitsInfo:grid.locale }} </igx-suffix>\n        </igx-input-group>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"!editMode\">\n    <ng-container *ngIf=\"level > 0\">\n        <div\n            #indentationDiv\n            class=\"igx-grid__tree-cell--padding-level-{{ level }}\"\n        ></div>\n    </ng-container>\n    <div\n        #indicator\n        *ngIf=\"!isLoading\"\n        class=\"igx-grid__tree-grouping-indicator\"\n        [ngStyle]=\"{ visibility: showIndicator ? 'visible' : 'hidden' }\"\n        (click)=\"toggle($event)\"\n        (focus)=\"onIndicatorFocus($event)\"\n    >\n        <ng-container\n            *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\"\n        >\n        </ng-container>\n        <ng-container\n            *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\"\n        >\n        </ng-container>\n    </div>\n    <div\n        *ngIf=\"isLoading\"\n        (dblclick)=\"onLoadingDblClick($event)\"\n        class=\"igx-grid__tree-loading-indicator\"\n    >\n        <ng-container\n            *ngTemplateOutlet=\"\n                grid.rowLoadingIndicatorTemplate\n                    ? grid.rowLoadingIndicatorTemplate\n                    : defaultLoadingIndicatorTemplate\n            \"\n        >\n        </ng-container>\n    </div>\n    <ng-template #defaultLoadingIndicatorTemplate>\n        <igx-circular-bar [indeterminate]=\"true\"> </igx-circular-bar>\n    </ng-template>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\"> </ng-container>\n<ng-template #defaultExpandedTemplate>\n    <igx-icon>expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n    <igx-icon>chevron_right</igx-icon>\n</ng-template>\n",
                    providers: [HammerGesturesManager]
                },] }
    ];
    IgxTreeGridCellComponent.propDecorators = {
        level: [{ type: i0.Input }],
        showIndicator: [{ type: i0.Input }],
        isLoading: [{ type: i0.Input }]
    };

    /** @hidden */
    var IgxTreeGridFilteringPipe = /** @class */ (function () {
        function IgxTreeGridFilteringPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridFilteringPipe.prototype.transform = function (hierarchyData, expressionsTree, filterStrategy, advancedFilteringExpressionsTree, _, __, pinned) {
            var grid = this.gridAPI.grid;
            var state = {
                expressionsTree: expressionsTree,
                advancedExpressionsTree: advancedFilteringExpressionsTree,
                strategy: new TreeGridFilteringStrategy()
            };
            if (filterStrategy) {
                state.strategy = filterStrategy;
            }
            if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
                grid.setFilteredData(null, pinned);
                return hierarchyData;
            }
            var result = this.filter(hierarchyData, state, grid);
            var filteredData = [];
            this.expandAllRecursive(grid, result, grid.expansionStates, filteredData);
            grid.setFilteredData(filteredData, pinned);
            return result;
        };
        IgxTreeGridFilteringPipe.prototype.expandAllRecursive = function (grid, data, expandedStates, filteredData) {
            var e_1, _a;
            try {
                for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                    var rec = data_1_1.value;
                    filteredData.push(rec.data);
                    if (rec.children && rec.children.length > 0) {
                        expandedStates.set(rec.rowID, true);
                        this.expandAllRecursive(grid, rec.children, expandedStates, filteredData);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        IgxTreeGridFilteringPipe.prototype.filter = function (data, state, grid) {
            return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree, grid);
        };
        return IgxTreeGridFilteringPipe;
    }());
    IgxTreeGridFilteringPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'treeGridFiltering',
                    pure: true
                },] }
    ];
    IgxTreeGridFilteringPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };

    /** @hidden */
    var IgxTreeGridSummaryPipe = /** @class */ (function () {
        function IgxTreeGridSummaryPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridSummaryPipe.prototype.transform = function (flatData, hasSummary, summaryCalculationMode, summaryPosition, showSummaryOnCollapse, _, __) {
            var grid = this.gridAPI.grid;
            if (!flatData || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
                return flatData;
            }
            return this.addSummaryRows(grid, flatData, summaryPosition, showSummaryOnCollapse);
        };
        IgxTreeGridSummaryPipe.prototype.addSummaryRows = function (grid, collection, summaryPosition, showSummaryOnCollapse) {
            var e_1, _a;
            var recordsWithSummary = [];
            var maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
            try {
                for (var collection_1 = __values(collection), collection_1_1 = collection_1.next(); !collection_1_1.done; collection_1_1 = collection_1.next()) {
                    var record = collection_1_1.value;
                    recordsWithSummary.push(record);
                    var isCollapsed = !record.expanded && record.children && record.children.length > 0 && showSummaryOnCollapse;
                    if (isCollapsed) {
                        var childData = record.children.filter(function (r) { return !r.isFilteredOutParent; }).map(function (r) { return r.data; });
                        childData = this.removeDeletedRecord(grid, record.rowID, childData);
                        var summaries = grid.summaryService.calculateSummaries(record.rowID, childData);
                        var summaryRecord = {
                            summaries: summaries,
                            max: maxSummaryHeight,
                            cellIndentation: record.level + 1
                        };
                        recordsWithSummary.push(summaryRecord);
                    }
                    var isExpanded = record.children && record.children.length > 0 && record.expanded;
                    if (summaryPosition === GridSummaryPosition.bottom && !isExpanded) {
                        var childRecord = record;
                        var parent = record.parent;
                        while (parent) {
                            var children = parent.children;
                            if (children[children.length - 1] === childRecord) {
                                var childData = children.filter(function (r) { return !r.isFilteredOutParent; }).map(function (r) { return r.data; });
                                childData = this.removeDeletedRecord(grid, parent.rowID, childData);
                                var summaries = grid.summaryService.calculateSummaries(parent.rowID, childData);
                                var summaryRecord = {
                                    summaries: summaries,
                                    max: maxSummaryHeight,
                                    cellIndentation: parent.level + 1
                                };
                                recordsWithSummary.push(summaryRecord);
                                childRecord = parent;
                                parent = childRecord.parent;
                            }
                            else {
                                break;
                            }
                        }
                    }
                    else if (summaryPosition === GridSummaryPosition.top && isExpanded) {
                        var childData = record.children.filter(function (r) { return !r.isFilteredOutParent; }).map(function (r) { return r.data; });
                        childData = this.removeDeletedRecord(grid, record.rowID, childData);
                        var summaries = grid.summaryService.calculateSummaries(record.rowID, childData);
                        var summaryRecord = {
                            summaries: summaries,
                            max: maxSummaryHeight,
                            cellIndentation: record.level + 1
                        };
                        recordsWithSummary.push(summaryRecord);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (collection_1_1 && !collection_1_1.done && (_a = collection_1.return)) _a.call(collection_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return recordsWithSummary;
        };
        IgxTreeGridSummaryPipe.prototype.removeDeletedRecord = function (grid, rowId, data) {
            if (!grid.transactions.enabled || !grid.cascadeOnDelete) {
                return data;
            }
            var deletedRows = grid.transactions.getTransactionLog().filter(function (t) { return t.type === 'delete'; }).map(function (t) { return t.id; });
            var row = grid.records.get(rowId);
            if (!row && deletedRows.lenght === 0) {
                return [];
            }
            row = row.children ? row : row.parent;
            while (row) {
                rowId = row.rowID;
                if (deletedRows.indexOf(rowId) !== -1) {
                    return [];
                }
                row = row.parent;
            }
            deletedRows.forEach(function (rowID) {
                var tempData = grid.primaryKey ? data.map(function (rec) { return rec[grid.primaryKey]; }) : data;
                var index = tempData.indexOf(rowID);
                if (index !== -1) {
                    data.splice(index, 1);
                }
            });
            return data;
        };
        return IgxTreeGridSummaryPipe;
    }());
    IgxTreeGridSummaryPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'treeGridSummary',
                    pure: true
                },] }
    ];
    IgxTreeGridSummaryPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };

    /**
     * @hidden
     */
    var IgxTreeGridModule = /** @class */ (function () {
        function IgxTreeGridModule() {
        }
        return IgxTreeGridModule;
    }());
    IgxTreeGridModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxTreeGridComponent,
                        IgxTreeGridRowComponent,
                        IgxTreeGridCellComponent,
                        IgxTreeGridHierarchizingPipe,
                        IgxTreeGridFlatteningPipe,
                        IgxTreeGridSortingPipe,
                        IgxTreeGridFilteringPipe,
                        IgxTreeGridPagingPipe,
                        IgxTreeGridTransactionPipe,
                        IgxTreeGridSummaryPipe,
                        IgxRowLoadingIndicatorTemplateDirective,
                        IgxTreeGridNormalizeRecordsPipe
                    ],
                    exports: [
                        IgxTreeGridComponent,
                        IgxTreeGridRowComponent,
                        IgxTreeGridCellComponent,
                        IgxRowLoadingIndicatorTemplateDirective,
                        IgxGridCommonModule
                    ],
                    imports: [
                        IgxGridCommonModule,
                    ],
                    schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                },] }
    ];

    var IgxChildGridRowComponent = /** @class */ (function () {
        function IgxChildGridRowComponent(gridAPI, element, resolver, cdr) {
            this.gridAPI = gridAPI;
            this.element = element;
            this.cdr = cdr;
            /**
             *  The data passed to the row component.
             *
             * ```typescript
             * // get the row data for the first selected row
             * let selectedRowData = this.grid.selectedRows[0].rowData;
             * ```
             */
            this.rowData = [];
            /**
             * Returns whether the row is expanded.
             * ```typescript
             * const RowExpanded = this.grid1.rowList.first.expanded;
             * ```
             */
            this.expanded = false;
            this.resolver = resolver;
        }
        Object.defineProperty(IgxChildGridRowComponent.prototype, "parentHasScroll", {
            /**
             * @hidden
             */
            get: function () {
                return !this.parentGrid.verticalScrollContainer.dc.instance.notVirtual;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxChildGridRowComponent.prototype, "parentGrid", {
            /**
             * Get a reference to the grid that contains the selected row.
             *
             * ```typescript
             * handleRowSelection(event) {
             *  // the grid on which the onRowSelectionChange event was triggered
             *  const grid = event.row.grid;
             * }
             * ```
             *
             * ```html
             *  <igx-grid
             *    [data]="data"
             *    (onRowSelectionChange)="handleRowSelection($event)">
             *  </igx-grid>
             * ```
             */
            // TODO: Refactor
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxChildGridRowComponent.prototype, "level", {
            get: function () {
                return this.layout.level;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxChildGridRowComponent.prototype, "nativeElement", {
            /**
             * The native DOM element representing the row. Could be null in certain environments.
             *
             * ```typescript
             * // get the nativeElement of the second selected row
             * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
             * ```
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxChildGridRowComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.layout.onLayoutChange.subscribe(function (ch) {
                _this._handleLayoutChanges(ch);
            });
            var changes = this.layout.initialChanges;
            changes.forEach(function (change) {
                _this._handleLayoutChanges(change);
            });
            this.hGrid.parent = this.parentGrid;
            this.hGrid.parentIsland = this.layout;
            this.hGrid.childRow = this;
            // handler logic that re-emits hgrid events on the row island
            this.setupEventEmitters();
            this.layout.onGridCreated.emit({
                owner: this.layout,
                parentID: this.rowData.rowID,
                grid: this.hGrid
            });
        };
        /**
         * @hidden
         */
        IgxChildGridRowComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.hGrid.childLayoutList = this.layout.children;
            var layouts = this.hGrid.childLayoutList.toArray();
            layouts.forEach(function (l) { return _this.hGrid.hgridAPI.registerChildRowIsland(l); });
            this.parentGrid.hgridAPI.registerChildGrid(this.rowData.rowID, this.layout.key, this.hGrid);
            this.layout.rowIslandAPI.registerChildGrid(this.rowData.rowID, this.hGrid);
            this.layout.onGridInitialized.emit({
                owner: this.layout,
                parentID: this.rowData.rowID,
                grid: this.hGrid
            });
            this.hGrid.cdr.detectChanges();
        };
        IgxChildGridRowComponent.prototype.setupEventEmitters = function () {
            var _this = this;
            var destructor = operators.takeUntil(this.hGrid.destroy$);
            var factory = this.resolver.resolveComponentFactory(IgxGridComponent);
            // exclude outputs related to two-way binding functionality
            var inputNames = factory.inputs.map(function (input) { return input.propName; });
            var outputs = factory.outputs.filter(function (o) {
                var matchingInputPropName = o.propName.slice(0, o.propName.indexOf('Change'));
                return inputNames.indexOf(matchingInputPropName) === -1;
            });
            // TODO: Skip the `rendered` output. Rendered should be called once per grid.
            outputs.filter(function (o) { return o.propName !== 'rendered'; }).forEach(function (output) {
                if (_this.hGrid[output.propName]) {
                    _this.hGrid[output.propName].pipe(destructor).subscribe(function (args) {
                        if (!args) {
                            args = {};
                        }
                        args.owner = _this.hGrid;
                        _this.layout[output.propName].emit(args);
                    });
                }
            });
        };
        IgxChildGridRowComponent.prototype._handleLayoutChanges = function (changes) {
            for (var change in changes) {
                if (changes.hasOwnProperty(change)) {
                    this.hGrid[change] = changes[change].currentValue;
                }
            }
        };
        return IgxChildGridRowComponent;
    }());
    IgxChildGridRowComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-child-grid-row',
                    template: "<div class=\"igx-grid__hierarchical-indent\" [ngClass]=\"{'igx-grid__hierarchical-indent--scroll': parentHasScroll}\">\n    <igx-hierarchical-grid #hgrid [data]='rowData.childGridsData[layout.key]'></igx-hierarchical-grid>\n</div>\n"
                },] }
    ];
    IgxChildGridRowComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: i0.ElementRef },
        { type: i0.ComponentFactoryResolver },
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxChildGridRowComponent.propDecorators = {
        layout: [{ type: i0.Input }],
        parentGridID: [{ type: i0.Input }],
        rowData: [{ type: i0.Input }],
        index: [{ type: i0.Input }],
        hGrid: [{ type: i0.ViewChild, args: ['hgrid', { static: true },] }],
        level: [{ type: i0.HostBinding, args: ['attr.aria-level',] }]
    };

    var IgxHierarchicalGridNavigationService = /** @class */ (function (_super) {
        __extends(IgxHierarchicalGridNavigationService, _super);
        function IgxHierarchicalGridNavigationService() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this._pendingNavigation = false;
            return _this;
        }
        IgxHierarchicalGridNavigationService.prototype.dispatchEvent = function (event) {
            var key = event.key.toLowerCase();
            if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) &&
                !this.grid.crudService.rowEditingBlocked && !this.grid.rowInEditMode) {
                return;
            }
            var targetGrid = this.getClosestElemByTag(event.target, 'igx-hierarchical-grid');
            if (targetGrid !== this.grid.nativeElement) {
                return;
            }
            if (this._pendingNavigation && NAVIGATION_KEYS.has(key)) {
                // In case focus needs to be moved from one grid to another, however there is a pending scroll operation
                // which is an async operation, any additional navigation keys should be ignored
                // untill operation complete.
                event.preventDefault();
                return;
            }
            _super.prototype.dispatchEvent.call(this, event);
        };
        IgxHierarchicalGridNavigationService.prototype.navigateInBody = function (rowIndex, visibleColIndex, cb) {
            var _this = this;
            if (cb === void 0) { cb = null; }
            var rec = this.grid.dataView[rowIndex];
            if (rec && this.grid.isChildGridRecord(rec)) {
                // target is child grid
                var virtState = this.grid.verticalScrollContainer.state;
                var inView = rowIndex >= virtState.startIndex && rowIndex <= virtState.startIndex + virtState.chunkSize;
                var isNext_1 = this.activeNode.row < rowIndex;
                var targetLayoutIndex_1 = isNext_1 ? null : this.grid.childLayoutKeys.length - 1;
                if (inView) {
                    this._moveToChild(rowIndex, visibleColIndex, isNext_1, targetLayoutIndex_1, cb);
                }
                else {
                    var scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(rowIndex, !isNext_1);
                    scrollAmount += isNext_1 ? 1 : -1;
                    this.grid.verticalScrollContainer.getScroll().scrollTop = scrollAmount;
                    this._pendingNavigation = true;
                    this.grid.verticalScrollContainer.onChunkLoad.pipe(operators.first()).subscribe(function () {
                        _this._moveToChild(rowIndex, visibleColIndex, isNext_1, targetLayoutIndex_1, cb);
                        _this._pendingNavigation = false;
                    });
                }
                return;
            }
            var isLast = rowIndex === this.grid.dataView.length;
            if ((rowIndex === -1 || isLast) &&
                this.grid.parent !== null) {
                // reached end of child grid
                var nextSiblingIndex = this.nextSiblingIndex(isLast);
                if (nextSiblingIndex !== null) {
                    this.grid.parent.navigation._moveToChild(this.grid.childRow.index, visibleColIndex, isLast, nextSiblingIndex, cb);
                }
                else {
                    this._moveToParent(isLast, visibleColIndex, cb);
                }
                return;
            }
            if (this.grid.parent) {
                var isNext_2 = this.activeNode && typeof this.activeNode.row === 'number' ? rowIndex > this.activeNode.row : false;
                var cbHandler = function (args) {
                    _this._handleScrollInChild(rowIndex, isNext_2);
                    cb(args);
                };
                if (!this.activeNode) {
                    this.activeNode = { row: null, column: null };
                }
                _super.prototype.navigateInBody.call(this, rowIndex, visibleColIndex, cbHandler);
                return;
            }
            if (!this.activeNode) {
                this.activeNode = { row: null, column: null };
            }
            _super.prototype.navigateInBody.call(this, rowIndex, visibleColIndex, cb);
        };
        IgxHierarchicalGridNavigationService.prototype.shouldPerformVerticalScroll = function (index, visibleColumnIndex, isNext) {
            if (visibleColumnIndex === void 0) { visibleColumnIndex = -1; }
            var targetRec = this.grid.dataView[index];
            if (this.grid.isChildGridRecord(targetRec)) {
                var scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(index, !isNext);
                var currScroll = this.grid.verticalScrollContainer.getScroll().scrollTop;
                var shouldScroll = !isNext ? scrollAmount > currScroll : currScroll < scrollAmount;
                return shouldScroll;
            }
            else {
                return _super.prototype.shouldPerformVerticalScroll.call(this, index, visibleColumnIndex);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.focusTbody = function (event) {
            var _this = this;
            if (!this.activeNode || this.activeNode.row === null) {
                this.activeNode = {
                    row: 0,
                    column: 0
                };
                this.grid.navigateTo(0, 0, function (obj) {
                    _this.grid.clearCellSelection();
                    obj.target.activate(event);
                });
            }
            else {
                _super.prototype.focusTbody.call(this, event);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.nextSiblingIndex = function (isNext) {
            var layoutKey = this.grid.childRow.layout.key;
            var layoutIndex = this.grid.parent.childLayoutKeys.indexOf(layoutKey);
            var nextIndex = isNext ? layoutIndex + 1 : layoutIndex - 1;
            if (nextIndex <= this.grid.parent.childLayoutKeys.length - 1 && nextIndex > -1) {
                return nextIndex;
            }
            else {
                return null;
            }
        };
        /**
         * Handles scrolling in child grid and ensures target child row is in main grid view port.
         *
         * @param rowIndex The row index which should be in view.
         * @param isNext  Optional. Whether we are navigating to next. Used to determine scroll direction.
         * @param cb  Optional.Callback function called when operation is complete.
         */
        IgxHierarchicalGridNavigationService.prototype._handleScrollInChild = function (rowIndex, isNext, cb) {
            var _this = this;
            var shouldScroll = this.shouldPerformVerticalScroll(rowIndex, -1, isNext);
            if (shouldScroll) {
                this.grid.navigation.performVerticalScrollToCell(rowIndex, -1, function () {
                    _this.positionInParent(rowIndex, isNext, cb);
                });
            }
            else {
                this.positionInParent(rowIndex, isNext, cb);
            }
        };
        /**
         *
         * @param rowIndex Row index that should come in view.
         * @param isNext  Whether we are navigating to next. Used to determine scroll direction.
         * @param cb  Optional.Callback function called when operation is complete.
         */
        IgxHierarchicalGridNavigationService.prototype.positionInParent = function (rowIndex, isNext, cb) {
            var _this = this;
            var rowObj = this.grid.getRowByIndex(rowIndex);
            if (!rowObj) {
                if (cb) {
                    cb();
                }
                return;
            }
            var positionInfo = this.getPositionInfo(rowObj, isNext);
            if (!positionInfo.inView) {
                // stop event from triggering multiple times before scrolling is complete.
                this._pendingNavigation = true;
                var scrollableGrid = isNext ? this.getNextScrollableDown(this.grid) : this.getNextScrollableUp(this.grid);
                scrollableGrid.grid.verticalScrollContainer.recalcUpdateSizes();
                scrollableGrid.grid.verticalScrollContainer.addScrollTop(positionInfo.offset);
                scrollableGrid.grid.verticalScrollContainer.onChunkLoad.pipe(operators.first()).subscribe(function () {
                    _this._pendingNavigation = false;
                    if (cb) {
                        cb();
                    }
                });
            }
            else {
                if (cb) {
                    cb();
                }
            }
        };
        /**
         * Moves navigation to child grid.
         *
         * @param parentRowIndex The parent row index, at which the child grid is rendered.
         * @param childLayoutIndex Optional. The index of the child row island to which the child grid belongs to. Uses first if not set.
         */
        IgxHierarchicalGridNavigationService.prototype._moveToChild = function (parentRowIndex, visibleColIndex, isNext, childLayoutIndex, cb) {
            var ri = typeof childLayoutIndex !== 'number' ?
                this.grid.childLayoutList.first : this.grid.childLayoutList.toArray()[childLayoutIndex];
            var rowId = this.grid.dataView[parentRowIndex].rowID;
            var pathSegment = {
                rowID: rowId,
                rowIslandKey: ri.key
            };
            var childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
            var targetIndex = isNext ? 0 : childGrid.dataView.length - 1;
            var targetRec = childGrid.dataView[targetIndex];
            if (!targetRec) {
                // if no target rec, then move on in next sibling or parent
                childGrid.navigation.navigateInBody(targetIndex, visibleColIndex, cb);
                return;
            }
            if (childGrid.isChildGridRecord(targetRec)) {
                // if target is a child grid record should move into it.
                this.grid.navigation.activeNode.row = null;
                childGrid.navigation.activeNode = { row: targetIndex, column: this.activeNode.column };
                childGrid.navigation._handleScrollInChild(targetIndex, isNext, function () {
                    var targetLayoutIndex = isNext ? 0 : childGrid.childLayoutList.toArray().length - 1;
                    childGrid.navigation._moveToChild(targetIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
                });
                return;
            }
            var childGridNav = childGrid.navigation;
            this.clearActivation();
            var lastVisibleIndex = childGridNav.lastColumnIndex;
            var columnIndex = visibleColIndex <= lastVisibleIndex ? visibleColIndex : lastVisibleIndex;
            childGridNav.activeNode = { row: targetIndex, column: columnIndex };
            childGrid.tbody.nativeElement.focus({ preventScroll: true });
            this._pendingNavigation = false;
            childGrid.navigation._handleScrollInChild(targetIndex, isNext, function () {
                childGrid.navigateTo(targetIndex, columnIndex, cb);
            });
        };
        /**
         * Moves navigation back to parent grid.
         *
         * @param rowIndex
         */
        IgxHierarchicalGridNavigationService.prototype._moveToParent = function (isNext, columnIndex, cb) {
            var _this = this;
            var indexInParent = this.grid.childRow.index;
            var hasNextTarget = this.hasNextTarget(this.grid.parent, indexInParent, isNext);
            if (!hasNextTarget) {
                return;
            }
            this.clearActivation();
            var targetRowIndex = isNext ? indexInParent + 1 : indexInParent - 1;
            var lastVisibleIndex = this.grid.parent.navigation.lastColumnIndex;
            var nextColumnIndex = columnIndex <= lastVisibleIndex ? columnIndex : lastVisibleIndex;
            this._pendingNavigation = true;
            var cbFunc = function (args) {
                _this._pendingNavigation = false;
                cb(args);
                args.target.grid.tbody.nativeElement.focus();
            };
            this.grid.parent.navigation.navigateInBody(targetRowIndex, nextColumnIndex, cbFunc);
        };
        /**
         * Gets information on the row position relative to the root grid view port.
         * Returns whether the row is in view and its offset.
         *
         * @param rowObj
         * @param isNext
         */
        IgxHierarchicalGridNavigationService.prototype.getPositionInfo = function (rowObj, isNext) {
            var rowElem = rowObj.nativeElement;
            if (rowObj instanceof IgxChildGridRowComponent) {
                var childLayoutKeys = this.grid.childLayoutKeys;
                var riKey = isNext ? childLayoutKeys[0] : childLayoutKeys[childLayoutKeys.length - 1];
                var pathSegment = {
                    rowID: rowObj.rowData.rowID,
                    rowIslandKey: riKey
                };
                var childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
                rowElem = childGrid.tfoot.nativeElement;
            }
            var gridBottom = this._getMinBottom(this.grid);
            var diffBottom = rowElem.getBoundingClientRect().bottom - gridBottom;
            var gridTop = this._getMaxTop(this.grid);
            var diffTop = rowElem.getBoundingClientRect().bottom -
                rowElem.offsetHeight - gridTop;
            var isInView = isNext ? diffBottom <= 0 : diffTop >= 0;
            var calcOffset = isNext ? diffBottom : diffTop;
            return { inView: isInView, offset: calcOffset };
        };
        /**
         * Gets closest element by its tag name.
         *
         * @param sourceElem The element from which to start the search.
         * @param targetTag The target element tag name, for which to search.
         */
        IgxHierarchicalGridNavigationService.prototype.getClosestElemByTag = function (sourceElem, targetTag) {
            var result = sourceElem;
            while (result !== null && result.nodeType === 1) {
                if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {
                    return result;
                }
                result = result.parentNode;
            }
            return null;
        };
        IgxHierarchicalGridNavigationService.prototype.clearActivation = function () {
            // clear if previous activation exists.
            if (this.activeNode) {
                this.activeNode.row = null;
            }
        };
        IgxHierarchicalGridNavigationService.prototype.hasNextTarget = function (grid, index, isNext) {
            var targetRowIndex = isNext ? index + 1 : index - 1;
            var hasTargetRecord = !!grid.dataView[targetRowIndex];
            if (hasTargetRecord) {
                return true;
            }
            else {
                var hasTargetRecordInParent = false;
                if (grid.parent) {
                    var indexInParent = grid.childRow.index;
                    hasTargetRecordInParent = this.hasNextTarget(grid.parent, indexInParent, isNext);
                }
                return hasTargetRecordInParent;
            }
        };
        /**
         * Gets the max top view in the current grid hierarchy.
         *
         * @param grid
         */
        IgxHierarchicalGridNavigationService.prototype._getMaxTop = function (grid) {
            var currGrid = grid;
            var top = currGrid.tbody.nativeElement.getBoundingClientRect().top;
            while (currGrid.parent) {
                currGrid = currGrid.parent;
                var pinnedRowsHeight = currGrid.hasPinnedRecords && currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
                top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top + pinnedRowsHeight);
            }
            return top;
        };
        /**
         * Gets the min bottom view in the current grid hierarchy.
         *
         * @param grid
         */
        IgxHierarchicalGridNavigationService.prototype._getMinBottom = function (grid) {
            var currGrid = grid;
            var bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;
            while (currGrid.parent) {
                currGrid = currGrid.parent;
                var pinnedRowsHeight = currGrid.hasPinnedRecords && !currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
                bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom - pinnedRowsHeight);
            }
            return bottom;
        };
        /**
         * Finds the next grid that allows scrolling down.
         *
         * @param grid The grid from which to begin the search.
         */
        IgxHierarchicalGridNavigationService.prototype.getNextScrollableDown = function (grid) {
            var currGrid = grid.parent;
            if (!currGrid) {
                return { grid: grid, prev: null };
            }
            var scrollTop = currGrid.verticalScrollContainer.scrollPosition;
            var scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
            var nonScrollable = scrollHeight === 0 ||
                Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
            var prev = grid;
            while (nonScrollable && currGrid.parent !== null) {
                prev = currGrid;
                currGrid = currGrid.parent;
                scrollTop = currGrid.verticalScrollContainer.scrollPosition;
                scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
                nonScrollable = scrollHeight === 0 ||
                    Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
            }
            return { grid: currGrid, prev: prev };
        };
        /**
         * Finds the next grid that allows scrolling up.
         *
         * @param grid The grid from which to begin the search.
         */
        IgxHierarchicalGridNavigationService.prototype.getNextScrollableUp = function (grid) {
            var currGrid = grid.parent;
            if (!currGrid) {
                return { grid: grid, prev: null };
            }
            var nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
            var prev = grid;
            while (nonScrollable && currGrid.parent !== null) {
                prev = currGrid;
                currGrid = currGrid.parent;
                nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
            }
            return { grid: currGrid, prev: prev };
        };
        return IgxHierarchicalGridNavigationService;
    }(IgxGridNavigationService));
    IgxHierarchicalGridNavigationService.decorators = [
        { type: i0.Injectable }
    ];

    var hierarchicalTransactionServiceFactory = function () { return new IgxTransactionService(); };
    var IgxHierarchicalTransactionServiceFactory = {
        provide: IgxGridTransaction,
        useFactory: hierarchicalTransactionServiceFactory
    };
    var IgxHierarchicalGridBaseDirective = /** @class */ (function (_super) {
        __extends(IgxHierarchicalGridBaseDirective, _super);
        function IgxHierarchicalGridBaseDirective(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId) {
            var _this = _super.call(this, selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId) || this;
            _this.selectionService = selectionService;
            _this.colResizingService = colResizingService;
            _this.transactionFactory = transactionFactory;
            _this.document = document;
            _this.overlayService = overlayService;
            _this.summaryService = summaryService;
            _this._displayDensityOptions = _displayDensityOptions;
            /**
             * Gets/Sets whether the expand/collapse all button in the header should be rendered.
             *
             * @remark
             * The default value is false.
             * @example
             * ```html
             * <igx-hierarchical-grid #grid [data]="localData" [showExpandAll]="true">
             * </igx-hierarchical-grid>
             * ```
             */
            _this.showExpandAll = false;
            /**
             * Emitted when a new chunk of data is loaded from virtualization.
             *
             * @example
             * ```typescript
             *  <igx-hierarchical-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true" (onDataPreLoad)="handleEvent()">
             *  </igx-hierarchical-grid>
             * ```
             */
            _this.onDataPreLoad = new i0.EventEmitter();
            _this.hgridAPI = gridAPI;
            return _this;
        }
        Object.defineProperty(IgxHierarchicalGridBaseDirective.prototype, "maxLevelHeaderDepth", {
            /**
             * @hidden
             */
            get: function () {
                if (this._maxLevelHeaderDepth === null) {
                    this._maxLevelHeaderDepth = this.columnList.reduce(function (acc, col) { return Math.max(acc, col.level); }, 0);
                }
                return this._maxLevelHeaderDepth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridBaseDirective.prototype, "outlet", {
            /**
             * Gets the outlet used to attach the grid's overlays to.
             *
             * @remark
             * If set, returns the outlet defined outside the grid. Otherwise returns the grid's internal outlet directive.
             */
            get: function () {
                return this.rootGrid ? this.rootGrid.resolveOutlet() : this.resolveOutlet();
            },
            /**
             * Sets the outlet used to attach the grid's overlays to.
             */
            set: function (val) {
                this._userOutletDirective = val;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxHierarchicalGridBaseDirective.prototype.createColumnsList = function (cols) {
            var _this = this;
            var columns = [];
            var topLevelCols = this.onlyTopLevel(cols);
            topLevelCols.forEach(function (col) {
                var ref = _this._createColumn(col);
                ref.changeDetectorRef.detectChanges();
                columns.push(ref.instance);
            });
            var result = flatten$1(columns);
            this.columnList.reset(result);
            this.columnList.notifyOnChanges();
            this.initPinning();
            var factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);
            var outputs = factoryColumn.outputs.filter(function (o) { return o.propName !== 'onColumnChange'; });
            outputs.forEach(function (output) {
                _this.columnList.forEach(function (column) {
                    if (column[output.propName]) {
                        column[output.propName].pipe(operators.takeUntil(column.destroy$)).subscribe(function (args) {
                            var rowIslandColumn = _this.parentIsland.childColumns.find(function (col) { return col.field === column.field; });
                            rowIslandColumn[output.propName].emit({ args: args, owner: _this });
                        });
                    }
                });
            });
        };
        IgxHierarchicalGridBaseDirective.prototype._createColumn = function (col) {
            var ref;
            if (col instanceof IgxColumnGroupComponent) {
                ref = this._createColGroupComponent(col);
            }
            else {
                ref = this._createColComponent(col);
            }
            return ref;
        };
        IgxHierarchicalGridBaseDirective.prototype._createColGroupComponent = function (col) {
            var _this = this;
            var factoryGroup = this.resolver.resolveComponentFactory(IgxColumnGroupComponent);
            var ref = this.viewRef.createComponent(factoryGroup, null, this.viewRef.injector);
            ref.changeDetectorRef.detectChanges();
            factoryGroup.inputs.forEach(function (input) {
                var propName = input.propName;
                ref.instance[propName] = col[propName];
            });
            if (col.children.length > 0) {
                var newChildren_1 = [];
                col.children.forEach(function (child) {
                    var newCol = _this._createColumn(child).instance;
                    newCol.parent = ref.instance;
                    newChildren_1.push(newCol);
                });
                ref.instance.children.reset(newChildren_1);
                ref.instance.children.notifyOnChanges();
            }
            return ref;
        };
        IgxHierarchicalGridBaseDirective.prototype._createColComponent = function (col) {
            var factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);
            var ref = this.viewRef.createComponent(factoryColumn, null, this.viewRef.injector);
            factoryColumn.inputs.forEach(function (input) {
                var propName = input.propName;
                if (!(col[propName] instanceof IgxSummaryOperand)) {
                    ref.instance[propName] = col[propName];
                }
                else {
                    ref.instance[propName] = col[propName].constructor;
                }
            });
            return ref;
        };
        IgxHierarchicalGridBaseDirective.prototype.getGridsForIsland = function (rowIslandID) {
            return this.hgridAPI.getChildGridsForRowIsland(rowIslandID);
        };
        IgxHierarchicalGridBaseDirective.prototype.getChildGrid = function (path) {
            if (!path) {
                return;
            }
            return this.hgridAPI.getChildGrid(path);
        };
        return IgxHierarchicalGridBaseDirective;
    }(IgxGridBaseDirective));
    IgxHierarchicalGridBaseDirective.decorators = [
        { type: i0.Directive }
    ];
    IgxHierarchicalGridBaseDirective.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: IgxColumnResizingService },
        { type: GridBaseAPIService },
        { type: undefined, decorators: [{ type: i0.Inject, args: [IgxGridTransaction,] }] },
        { type: i0.ElementRef },
        { type: i0.NgZone },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: i0.ChangeDetectorRef },
        { type: i0.ComponentFactoryResolver },
        { type: i0.IterableDiffers },
        { type: i0.ViewContainerRef },
        { type: IgxHierarchicalGridNavigationService },
        { type: IgxFilteringService },
        { type: IgxOverlayService, decorators: [{ type: i0.Inject, args: [IgxOverlayService,] }] },
        { type: IgxGridSummaryService },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] },
        { type: String, decorators: [{ type: i0.Inject, args: [i0.LOCALE_ID,] }] }
    ]; };
    IgxHierarchicalGridBaseDirective.propDecorators = {
        hasChildrenKey: [{ type: i0.Input }],
        showExpandAll: [{ type: i0.Input }],
        onDataPreLoad: [{ type: i0.Output }],
        dragIndicatorIconBase: [{ type: i0.ViewChild, args: ['dragIndicatorIconBase', { read: i0.TemplateRef, static: true },] }]
    };
    var flatten$1 = function (arr) {
        var result = [];
        arr.forEach(function (el) {
            result.push(el);
            if (el.children) {
                result = result.concat(flatten$1(el.children.toArray()));
            }
        });
        return result;
    };
    var ɵ0$6 = flatten$1;

    var IgxHierarchicalGridAPIService = /** @class */ (function (_super) {
        __extends(IgxHierarchicalGridAPIService, _super);
        function IgxHierarchicalGridAPIService() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.childRowIslands = new Map();
            _this.childGrids = new Map();
            return _this;
        }
        IgxHierarchicalGridAPIService.prototype.registerChildRowIsland = function (rowIsland) {
            this.childRowIslands.set(rowIsland.key, rowIsland);
            this.destroyMap.set(rowIsland.key, new rxjs.Subject());
        };
        IgxHierarchicalGridAPIService.prototype.unsetChildRowIsland = function (rowIsland) {
            this.childGrids.delete(rowIsland.key);
            this.childRowIslands.delete(rowIsland.key);
            this.destroyMap.delete(rowIsland.key);
        };
        IgxHierarchicalGridAPIService.prototype.getChildRowIsland = function (key) {
            return this.childRowIslands.get(key);
        };
        IgxHierarchicalGridAPIService.prototype.getChildGrid = function (path) {
            var currPath = path;
            var grid;
            var pathElem = currPath.shift();
            var childrenForLayout = this.childGrids.get(pathElem.rowIslandKey);
            if (childrenForLayout) {
                var childGrid = childrenForLayout.get(pathElem.rowID);
                if (currPath.length === 0) {
                    grid = childGrid;
                }
                else {
                    grid = childGrid.hgridAPI.getChildGrid(currPath);
                }
            }
            return grid;
        };
        IgxHierarchicalGridAPIService.prototype.getChildGrids = function (inDepth) {
            var allChildren = [];
            this.childGrids.forEach(function (layoutMap) {
                layoutMap.forEach(function (grid) {
                    allChildren.push(grid);
                    if (inDepth) {
                        var children = grid.hgridAPI.getChildGrids(inDepth);
                        children.forEach(function (item) {
                            allChildren.push(item);
                        });
                    }
                });
            });
            return allChildren;
        };
        IgxHierarchicalGridAPIService.prototype.getParentRowId = function (childGrid) {
            var rowID;
            this.childGrids.forEach(function (layoutMap) {
                layoutMap.forEach(function (grid, key) {
                    if (grid === childGrid) {
                        rowID = key;
                        return;
                    }
                });
            });
            return rowID;
        };
        IgxHierarchicalGridAPIService.prototype.registerChildGrid = function (parentRowID, rowIslandKey, grid) {
            var childrenForLayout = this.childGrids.get(rowIslandKey);
            if (!childrenForLayout) {
                this.childGrids.set(rowIslandKey, new Map());
                childrenForLayout = this.childGrids.get(rowIslandKey);
            }
            childrenForLayout.set(parentRowID, grid);
        };
        IgxHierarchicalGridAPIService.prototype.getChildGridsForRowIsland = function (rowIslandKey) {
            var childrenForLayout = this.childGrids.get(rowIslandKey);
            var children = [];
            if (childrenForLayout) {
                childrenForLayout.forEach(function (child) {
                    children.push(child);
                });
            }
            return children;
        };
        IgxHierarchicalGridAPIService.prototype.getChildGridByID = function (rowIslandKey, rowID) {
            var childrenForLayout = this.childGrids.get(rowIslandKey);
            return childrenForLayout.get(rowID);
        };
        IgxHierarchicalGridAPIService.prototype.get_row_expansion_state = function (record) {
            var inState;
            if (record.childGridsData !== undefined) {
                var ri = record.rowID;
                var states = this.grid.expansionStates;
                var expanded = states.get(ri);
                if (expanded !== undefined) {
                    return expanded;
                }
                else {
                    return this.grid.getDefaultExpandState(record);
                }
            }
            else {
                inState = !!_super.prototype.get_row_expansion_state.call(this, record);
            }
            return inState && this.grid.childLayoutList.length !== 0;
        };
        IgxHierarchicalGridAPIService.prototype.allow_expansion_state_change = function (rowID, expanded) {
            var rec = this.get_rec_by_id(rowID);
            var grid = this.grid;
            if (grid.hasChildrenKey && !rec[grid.hasChildrenKey]) {
                return false;
            }
            return !!rec && this.grid.expansionStates.get(rowID) !== expanded;
        };
        IgxHierarchicalGridAPIService.prototype.get_rec_by_id = function (rowID) {
            var data = this.get_all_data(false);
            var index = this.get_row_index_in_data(rowID, data);
            return data[index];
        };
        return IgxHierarchicalGridAPIService;
    }(GridBaseAPIService));
    IgxHierarchicalGridAPIService.decorators = [
        { type: i0.Injectable }
    ];

    var IgxRowIslandAPIService = /** @class */ (function () {
        function IgxRowIslandAPIService() {
            this.change = new rxjs.Subject();
            this.state = new Map();
            this.destroyMap = new Map();
            this.childRowIslands = new Map();
            this.childGrids = new Map();
        }
        IgxRowIslandAPIService.prototype.register = function (rowIsland) {
            this.state.set(rowIsland.id, rowIsland);
            this.destroyMap.set(rowIsland.id, new rxjs.Subject());
        };
        IgxRowIslandAPIService.prototype.unsubscribe = function (rowIsland) {
            this.state.delete(rowIsland.id);
        };
        IgxRowIslandAPIService.prototype.get = function (id) {
            return this.state.get(id);
        };
        IgxRowIslandAPIService.prototype.unset = function (id) {
            this.state.delete(id);
            this.destroyMap.delete(id);
        };
        IgxRowIslandAPIService.prototype.reset = function (oldId, newId) {
            var destroy = this.destroyMap.get(oldId);
            var rowIsland = this.get(oldId);
            this.unset(oldId);
            if (rowIsland) {
                this.state.set(newId, rowIsland);
            }
            if (destroy) {
                this.destroyMap.set(newId, destroy);
            }
        };
        IgxRowIslandAPIService.prototype.registerChildRowIsland = function (rowIsland) {
            this.childRowIslands.set(rowIsland.key, rowIsland);
            this.destroyMap.set(rowIsland.key, new rxjs.Subject());
        };
        IgxRowIslandAPIService.prototype.unsetChildRowIsland = function (rowIsland) {
            this.childRowIslands.delete(rowIsland.key);
            this.destroyMap.delete(rowIsland.key);
        };
        IgxRowIslandAPIService.prototype.getChildRowIsland = function (rowIslandKey) {
            return this.childRowIslands.get(rowIslandKey);
        };
        IgxRowIslandAPIService.prototype.registerChildGrid = function (parentRowID, grid) {
            this.childGrids.set(parentRowID, grid);
        };
        IgxRowIslandAPIService.prototype.getChildGrids = function (inDepth) {
            var allChildren = [];
            this.childGrids.forEach(function (grid) {
                allChildren.push(grid);
            });
            if (inDepth) {
                this.childRowIslands.forEach(function (layout) {
                    allChildren = allChildren.concat(layout.rowIslandAPI.getChildGrids(inDepth));
                });
            }
            return allChildren;
        };
        IgxRowIslandAPIService.prototype.getChildGridByID = function (rowID) {
            return this.childGrids.get(rowID);
        };
        return IgxRowIslandAPIService;
    }());
    IgxRowIslandAPIService.decorators = [
        { type: i0.Injectable }
    ];

    var IgxRowIslandComponent = /** @class */ (function (_super) {
        __extends(IgxRowIslandComponent, _super);
        function IgxRowIslandComponent(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, rowIslandAPI, localeId) {
            var _this = _super.call(this, selectionService, crudService, colResizingService, gridAPI, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId) || this;
            _this.selectionService = selectionService;
            _this.colResizingService = colResizingService;
            _this.transactionFactory = transactionFactory;
            _this.document = document;
            _this.overlayService = overlayService;
            _this.summaryService = summaryService;
            _this._displayDensityOptions = _displayDensityOptions;
            _this.rowIslandAPI = rowIslandAPI;
            /**
             * @hidden
             */
            _this.children = new i0.QueryList();
            /**
             * @hidden
             */
            _this.childColumns = new i0.QueryList();
            /**
             * @hidden
             */
            _this.onLayoutChange = new i0.EventEmitter();
            /**
             * Event emmited when a grid is being created based on this row island.
             * ```html
             * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
             *      <igx-row-island [key]="'childData'" (onGridCreated)="gridCreated($event)" #rowIsland>
             *          <!-- ... -->
             *      </igx-row-island>
             * </igx-hierarchical-grid>
             * ```
             *
             * @memberof IgxRowIslandComponent
             */
            _this.onGridCreated = new i0.EventEmitter();
            /**
             * Emitted after a grid is being initialized for this row island.
             * The emitting is done in `ngAfterViewInit`.
             * ```html
             * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
             *      <igx-row-island [key]="'childData'" (onGridInitialized)="gridInitialized($event)" #rowIsland>
             *          <!-- ... -->
             *      </igx-row-island>
             * </igx-hierarchical-grid>
             * ```
             *
             * @memberof IgxRowIslandComponent
             */
            _this.onGridInitialized = new i0.EventEmitter();
            /**
             * @hidden
             */
            _this.initialChanges = [];
            /**
             * @hidden
             */
            _this.rootGrid = null;
            _this.layout_id = "igx-row-island-";
            _this.isInit = false;
            _this.hgridAPI = gridAPI;
            return _this;
        }
        Object.defineProperty(IgxRowIslandComponent.prototype, "expandChildren", {
            /**
             * Gets if all immediate children of the grids for this `IgxRowIslandComponent` have been set to be expanded/collapsed.
             * ```typescript
             * const expanded = this.rowIsland.expandChildren;
             * ```
             *
             * @memberof IgxRowIslandComponent
             */
            get: function () {
                return this._defaultExpandState;
            },
            /**
             * Sets if all immediate children of the grids for this `IgxRowIslandComponent` should be expanded/collapsed.
             * ```html
             * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
             *      <igx-row-island [key]="'childData'" [expandChildren]="true" #rowIsland>
             *          <!-- ... -->
             *      </igx-row-island>
             * </igx-hierarchical-grid>
             * ```
             *
             * @memberof IgxRowIslandComponent
             */
            set: function (value) {
                this._defaultExpandState = value;
                this.rowIslandAPI.getChildGrids().forEach(function (grid) {
                    if (document.body.contains(grid.nativeElement)) {
                        // Detect changes right away if the grid is visible
                        grid.expandChildren = value;
                        grid.markForCheck();
                    }
                    else {
                        // Else defer the detection on changes when the grid gets into view for performance.
                        grid.updateOnRender = true;
                    }
                });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowIslandComponent.prototype, "id", {
            /**
             * @hidden
             */
            get: function () {
                var pId = this.parentId ? this.parentId.substring(this.parentId.indexOf(this.layout_id) + this.layout_id.length) + '-' : '';
                return this.layout_id + pId + this.key;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowIslandComponent.prototype, "parentId", {
            /**
             * @hidden
             */
            get: function () {
                return this.parentIsland ? this.parentIsland.id : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRowIslandComponent.prototype, "level", {
            /**
             * @hidden
             */
            get: function () {
                var ptr = this.parentIsland;
                var lvl = 0;
                while (ptr) {
                    lvl++;
                    ptr = ptr.parentIsland;
                }
                return lvl + 1;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.ngOnInit = function () {
            this.filteringService.grid = this;
            this.rootGrid = this.hgridAPI.grid;
            this.rowIslandAPI.rowIsland = this;
            this.ri_columnListDiffer = this.differs.find([]).create(null);
        };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.updateChildren();
            this.children.notifyOnChanges();
            this.children.changes.pipe(operators.takeUntil(this.destroy$))
                .subscribe(function () {
                _this.updateChildren();
                // update existing grids since their child ri have been changed.
                _this.getGridsForIsland(_this.key).forEach(function (grid) {
                    grid.onRowIslandChange(_this.children);
                });
            });
            var nestedColumns = this.children.map(function (layout) { return layout.columnList.toArray(); });
            var colsArray = [].concat.apply([], nestedColumns);
            var topCols = this.columnList.filter(function (item) { return colsArray.indexOf(item) === -1; });
            this.childColumns.reset(topCols);
            this.columnList.changes.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                Promise.resolve().then(function () {
                    _this.updateColumnList();
                });
            });
            // handle column changes so that they are passed to child grid instances when onColumnChange is emitted.
            this.ri_columnListDiffer.diff(this.childColumns);
            this.childColumns.toArray().forEach(function (x) { return x.onColumnChange.pipe(operators.takeUntil(x.destroy$)).subscribe(function () { return _this.updateColumnList(); }); });
            this.childColumns.changes.pipe(operators.takeUntil(this.destroy$)).subscribe(function (change) {
                var diff = _this.ri_columnListDiffer.diff(change);
                if (diff) {
                    diff.forEachAddedItem(function (record) {
                        record.item.onColumnChange.pipe(operators.takeUntil(record.item.destroy$)).subscribe(function () { return _this.updateColumnList(); });
                    });
                }
            });
            this.actionStrip = this.actionStrips.first;
            if (this.actionStrip) {
                this.actionStrip.menuOverlaySettings.outlet = this.outlet;
            }
        };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.rowIslandAPI.register(this);
            if (this.parentIsland) {
                this.parentIsland.rowIslandAPI.registerChildRowIsland(this);
            }
            else {
                this.rootGrid.hgridAPI.registerChildRowIsland(this);
            }
            this._init = false;
            // Create the child toolbar if the parent island has a toolbar definition
            this.onGridCreated.pipe(operators.pluck('grid'), operators.takeUntil(this.destroy$)).subscribe(function (grid) {
                grid.rendered$.pipe(operators.first(), operators.filter(function () { return !!_this.islandToolbarTemplate; }))
                    .subscribe(function () { return grid.toolbarOutlet.createEmbeddedView(_this.islandToolbarTemplate, { $implicit: grid }); });
            });
        };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.ngOnChanges = function (changes) {
            this.onLayoutChange.emit(changes);
            if (!this.isInit) {
                this.initialChanges.push(changes);
            }
        };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.ngOnDestroy = function () {
            var _this = this;
            // Override the base destroy because we don't have rendered anything to use removeEventListener on
            this.destroy$.next(true);
            this.destroy$.complete();
            this._destroyed = true;
            this.rowIslandAPI.unset(this.id);
            if (this.parentIsland) {
                this.getGridsForIsland(this.key).forEach(function (grid) {
                    _this.cleanGridState(grid);
                    grid.hgridAPI.unsetChildRowIsland(_this);
                });
                this.parentIsland.rowIslandAPI.unsetChildRowIsland(this);
            }
            else {
                this.rootGrid.hgridAPI.unsetChildRowIsland(this);
                this.cleanGridState(this.rootGrid);
            }
        };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.ngDoCheck = function () {
        };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.reflow = function () { };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.calculateGridHeight = function () { };
        IgxRowIslandComponent.prototype.updateColumnList = function () {
            var _this = this;
            var nestedColumns = this.children.map(function (layout) { return layout.columnList.toArray(); });
            var colsArray = [].concat.apply([], nestedColumns);
            var topCols = this.columnList.filter(function (item) {
                if (colsArray.indexOf(item) === -1) {
                    /* Reset the default width of the columns that come into this row island,
                    because the root catches them first during the detectChanges() and sets their defaultWidth. */
                    item.defaultWidth = undefined;
                    return true;
                }
                return false;
            });
            this.childColumns.reset(topCols);
            if (this.parentIsland) {
                this.parentIsland.columnList.notifyOnChanges();
            }
            else {
                this.rootGrid.columnList.notifyOnChanges();
            }
            this.rowIslandAPI.getChildGrids().forEach(function (grid) {
                grid.createColumnsList(_this.childColumns.toArray());
                if (!document.body.contains(grid.nativeElement)) {
                    grid.updateOnRender = true;
                }
            });
        };
        IgxRowIslandComponent.prototype.updateChildren = function () {
            var _this = this;
            if (this.children.first === this) {
                this.children.reset(this.children.toArray().slice(1));
            }
            this.children.forEach(function (child) {
                child.parentIsland = _this;
            });
        };
        IgxRowIslandComponent.prototype.cleanGridState = function (grid) {
            grid.childGridTemplates.forEach(function (tmpl) {
                tmpl.owner.cleanView(tmpl.context.templateID);
            });
            grid.childGridTemplates.clear();
            grid.onRowIslandChange();
        };
        return IgxRowIslandComponent;
    }(IgxHierarchicalGridBaseDirective));
    IgxRowIslandComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    selector: 'igx-row-island',
                    template: "",
                    providers: [IgxRowIslandAPIService,
                        IgxFilteringService,
                        IgxGridSelectionService]
                },] }
    ];
    IgxRowIslandComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: IgxColumnResizingService },
        { type: GridBaseAPIService },
        { type: undefined, decorators: [{ type: i0.Inject, args: [IgxGridTransaction,] }] },
        { type: i0.ElementRef },
        { type: i0.NgZone },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: i0.ChangeDetectorRef },
        { type: i0.ComponentFactoryResolver },
        { type: i0.IterableDiffers },
        { type: i0.ViewContainerRef },
        { type: IgxHierarchicalGridNavigationService },
        { type: IgxFilteringService },
        { type: IgxOverlayService, decorators: [{ type: i0.Inject, args: [IgxOverlayService,] }] },
        { type: IgxGridSummaryService },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] },
        { type: IgxRowIslandAPIService },
        { type: String, decorators: [{ type: i0.Inject, args: [i0.LOCALE_ID,] }] }
    ]; };
    IgxRowIslandComponent.propDecorators = {
        key: [{ type: i0.Input }],
        children: [{ type: i0.ContentChildren, args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false },] }],
        childColumns: [{ type: i0.ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: false },] }],
        islandToolbarTemplate: [{ type: i0.ContentChild, args: [IgxGridToolbarDirective, { read: i0.TemplateRef },] }],
        actionStrips: [{ type: i0.ContentChildren, args: [IgxActionStripComponent, { read: IgxActionStripComponent, descendants: false },] }],
        onLayoutChange: [{ type: i0.Output }],
        onGridCreated: [{ type: i0.Output }],
        onGridInitialized: [{ type: i0.Output }],
        expandChildren: [{ type: i0.Input }]
    };

    var NEXT_ID$n = 0;
    var IgxHierarchicalGridComponent = /** @class */ (function (_super) {
        __extends(IgxHierarchicalGridComponent, _super);
        function IgxHierarchicalGridComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            /**
             * @hidden @internal
             */
            _this.role = 'grid';
            /**
             * @hidden
             */
            _this.childLayoutKeys = [];
            /**
             * @hidden
             */
            _this.highlightedRowID = null;
            /**
             * @hidden
             */
            _this.updateOnRender = false;
            /**
             * @hidden
             */
            _this.parent = null;
            _this._filteredData = null;
            _this.h_id = "igx-hierarchical-grid-" + NEXT_ID$n++;
            _this.childGridTemplates = new Map();
            _this.scrollTop = 0;
            _this.scrollLeft = 0;
            return _this;
        }
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "id", {
            /**
             * Gets/Sets the value of the `id` attribute.
             *
             * @remarks
             * If not provided it will be automatically generated.
             * @example
             * ```html
             * <igx-hierarchical-grid [id]="'igx-hgrid-1'" [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
             * ```
             */
            get: function () {
                return this.h_id;
            },
            set: function (value) {
                this.h_id = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "data", {
            /**
             * Returns an array of data set to the `IgxHierarchicalGridComponent`.
             * ```typescript
             * let filteredData = this.grid.filteredData;
             * ```
             *
             * @memberof IgxHierarchicalGridComponent
             */
            get: function () {
                return this._data;
            },
            /**
             * An @Input property that lets you fill the `IgxHierarchicalGridComponent` with an array of data.
             * ```html
             * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
             * ```
             *
             * @memberof IgxHierarchicalGridComponent
             */
            set: function (value) {
                this._data = value || [];
                this.summaryService.clearSummaryCache();
                if (this.shouldGenerate) {
                    this.setupColumns();
                    this.reflow();
                }
                this.cdr.markForCheck();
                if (this.parent && (this.height === null || this.height.indexOf('%') !== -1)) {
                    // If the height will change based on how much data there is, recalculate sizes in igxForOf.
                    this.notifyChanges(true);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "filteredData", {
            /**
             * Returns an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
             * ```typescript
             * let filteredData = this.grid.filteredData;
             * ```
             *
             * @memberof IgxHierarchicalGridComponent
             */
            get: function () {
                return this._filteredData;
            },
            /**
             * Sets an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
             * ```typescript
             * this.grid.filteredData = [{
             *       ID: 1,
             *       Name: "A"
             * }];
             * ```
             *
             * @memberof IgxHierarchicalGridComponent
             */
            set: function (value) {
                this._filteredData = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "totalItemCount", {
            get: function () {
                return this.verticalScrollContainer.totalItemCount;
            },
            /**
             * Gets/Sets the total number of records in the data source.
             *
             * @remarks
             * This property is required for remote grid virtualization to function when it is bound to remote data.
             * @example
             * ```typescript
             * const itemCount = this.grid1.totalItemCount;
             * this.grid1.totalItemCount = 55;
             * ```
             */
            set: function (count) {
                this.verticalScrollContainer.totalItemCount = count;
                this.cdr.detectChanges();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "expandChildren", {
            /**
             * Gets if all immediate children of the `IgxHierarchicalGridComponent` previously have been set to be expanded/collapsed.
             * If previously set and some rows have been manually expanded/collapsed it will still return the last set value.
             * ```typescript
             * const expanded = this.grid.expandChildren;
             * ```
             *
             * @memberof IgxHierarchicalGridComponent
             */
            get: function () {
                return this._defaultExpandState;
            },
            /**
             * Sets if all immediate children of the `IgxHierarchicalGridComponent` should be expanded/collapsed.
             * Defult value is false.
             * ```html
             * <igx-hierarchical-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true" [expandChildren]="true"></igx-hierarchical-grid>
             * ```
             *
             * @memberof IgxHierarchicalGridComponent
             */
            set: function (value) {
                this._defaultExpandState = value;
                this.expansionStates = new Map();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "foreignKey", {
            /**
             * Gets the unique identifier of the parent row. It may be a `string` or `number` if `primaryKey` of the
             * parent grid is set or an object reference of the parent record otherwise.
             * ```typescript
             * const foreignKey = this.grid.foreignKey;
             * ```
             *
             * @memberof IgxHierarchicalGridComponent
             */
            get: function () {
                if (!this.parent) {
                    return null;
                }
                return this.parent.hgridAPI.getParentRowId(this);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "hasExpandableChildren", {
            /**
             * @hidden
             */
            get: function () {
                return !!this.childLayoutKeys.length;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.hideActionStrip = function () {
            if (!this.parent) {
                // hide child layout actions strips when
                // moving outside root grid.
                _super.prototype.hideActionStrip.call(this);
                this.allLayoutList.forEach(function (ri) {
                    var _a;
                    (_a = ri.actionStrip) === null || _a === void 0 ? void 0 : _a.hide();
                });
            }
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.ngOnInit = function () {
            if (this._transactions instanceof IgxTransactionService) {
                // transaction service cannot be injected in a derived class in a factory manner
                this._transactions = new IgxTransactionService();
            }
            // this.expansionStatesChange.pipe(takeUntil(this.destroy$)).subscribe((value: Map<any, boolean>) => {
            //     const res = Array.from(value.entries()).filter(({1: v}) => v === true).map(([k]) => k);
            // });
            _super.prototype.ngOnInit.call(this);
        };
        IgxHierarchicalGridComponent.prototype.ngDoCheck = function () {
            if (this._cdrRequestRepaint && !this._init) {
                this.updateSizes();
            }
            _super.prototype.ngDoCheck.call(this);
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            _super.prototype.ngAfterViewInit.call(this);
            this.verticalScrollContainer.getScroll().addEventListener('scroll', this.hg_verticalScrollHandler.bind(this));
            this.headerContainer.getScroll().addEventListener('scroll', this.hg_horizontalScrollHandler.bind(this));
            this.verticalScrollContainer.onBeforeViewDestroyed.pipe(operators.takeUntil(this.destroy$)).subscribe(function (view) {
                var rowData = view.context.$implicit;
                if (_this.isChildGridRecord(rowData)) {
                    var cachedData = _this.childGridTemplates.get(rowData.rowID);
                    if (cachedData) {
                        var tmlpOutlet = cachedData.owner;
                        tmlpOutlet._viewContainerRef.detach(0);
                    }
                }
            });
            if (this.parent) {
                this._displayDensity = this.rootGrid._displayDensity;
                this.rootGrid.onDensityChanged.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                    _this._displayDensity = _this.rootGrid._displayDensity;
                    _this.notifyChanges(true);
                    _this.cdr.markForCheck();
                });
                this.childLayoutKeys = this.parentIsland.children.map(function (item) { return item.key; });
            }
            this.actionStrip = this.parentIsland ? this.parentIsland.actionStrip : this.actionStrip;
            this.headSelectorsTemplates = this.parentIsland ?
                this.parentIsland.headSelectorsTemplates :
                this.headSelectorsTemplates;
            this.rowSelectorsTemplates = this.parentIsland ?
                this.parentIsland.rowSelectorsTemplates :
                this.rowSelectorsTemplates;
            this.dragIndicatorIconTemplate = this.parentIsland ?
                this.parentIsland.dragIndicatorIconTemplate :
                this.dragIndicatorIconTemplate;
            this.rowExpandedIndicatorTemplate = this.rootGrid.rowExpandedIndicatorTemplate;
            this.rowCollapsedIndicatorTemplate = this.rootGrid.rowCollapsedIndicatorTemplate;
            this.headerCollapseIndicatorTemplate = this.rootGrid.headerCollapseIndicatorTemplate;
            this.headerExpandIndicatorTemplate = this.rootGrid.headerExpandIndicatorTemplate;
            this.excelStyleHeaderIconTemplate = this.rootGrid.excelStyleHeaderIconTemplate;
            this.hasChildrenKey = this.parentIsland ?
                this.parentIsland.hasChildrenKey || this.rootGrid.hasChildrenKey :
                this.rootGrid.hasChildrenKey;
            this.showExpandAll = this.parentIsland ?
                this.parentIsland.showExpandAll : this.rootGrid.showExpandAll;
            this.excelStyleFilteringComponents = this.parentIsland ?
                this.parentIsland.excelStyleFilteringComponents :
                this.excelStyleFilteringComponents;
        };
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "outletDirective", {
            get: function () {
                return this.rootGrid._outletDirective;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.updateColumnList(false);
            this.childLayoutKeys = this.parent ?
                this.parentIsland.children.map(function (item) { return item.key; }) :
                this.childLayoutKeys = this.childLayoutList.map(function (item) { return item.key; });
            this.childLayoutList.notifyOnChanges();
            this.childLayoutList.changes.pipe(operators.takeUntil(this.destroy$)).subscribe(function () { return _this.onRowIslandChange(); });
            _super.prototype.ngAfterContentInit.call(this);
        };
        /**
         * @hidden @internal
         */
        IgxHierarchicalGridComponent.prototype.dataLoading = function (event) {
            this.onDataPreLoad.emit(event);
        };
        /** @hidden */
        IgxHierarchicalGridComponent.prototype.featureColumnsWidth = function () {
            return _super.prototype.featureColumnsWidth.call(this, this.headerHierarchyExpander);
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.onRowIslandChange = function () {
            if (this.parent) {
                this.childLayoutKeys = this.parentIsland.children.filter(function (item) { return !item._destroyed; }).map(function (item) { return item.key; });
            }
            else {
                this.childLayoutKeys = this.childLayoutList.filter(function (item) { return !item._destroyed; }).map(function (item) { return item.key; });
            }
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        };
        IgxHierarchicalGridComponent.prototype.ngOnDestroy = function () {
            if (!this.parent) {
                this.hgridAPI.getChildGrids(true).forEach(function (grid) {
                    if (!grid.childRow.cdr.destroyed) {
                        grid.childRow.cdr.destroy();
                    }
                });
            }
            if (this.parent && this.selectionService.activeElement) {
                // in case selection is in destroyed child grid, selection should be cleared.
                this._clearSeletionHighlights();
            }
            _super.prototype.ngOnDestroy.call(this);
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.isRowHighlighted = function (rowData) {
            return this.highlightedRowID === rowData.rowID;
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.isHierarchicalRecord = function (record) {
            if (this.isGhostRecord(record)) {
                record = record.recordRef;
            }
            return this.childLayoutList.length !== 0 && record[this.childLayoutList.first.key];
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.isChildGridRecord = function (record) {
            // Can be null when there is defined layout but no child data was found
            return record.childGridsData !== undefined;
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.trackChanges = function (index, rec) {
            if (rec.childGridsData !== undefined) {
                // if is child rec
                return rec.rowID;
            }
            return rec;
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.getContext = function (rowData, rowIndex, pinned) {
            if (this.isChildGridRecord(rowData)) {
                var cachedData = this.childGridTemplates.get(rowData.rowID);
                if (cachedData) {
                    var view = cachedData.view;
                    var tmlpOutlet = cachedData.owner;
                    return {
                        $implicit: rowData,
                        moveView: view,
                        owner: tmlpOutlet,
                        index: this.dataView.indexOf(rowData)
                    };
                }
                else {
                    var rowID = this.primaryKey ? rowData.rowID : this.data.indexOf(rowData.rowID);
                    // child rows contain unique grids, hence should have unique templates
                    return {
                        $implicit: rowData,
                        templateID: 'childRow-' + rowID,
                        index: this.dataView.indexOf(rowData)
                    };
                }
            }
            else {
                return {
                    $implicit: this.isGhostRecord(rowData) || this.isAddRowRecord(rowData) ? rowData.recordRef : rowData,
                    templateID: 'dataRow',
                    index: this.getDataViewIndex(rowIndex, pinned),
                    disabled: this.isGhostRecord(rowData),
                    addRow: this.isAddRowRecord(rowData) ? rowData.addRow : false
                };
            }
        };
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "rootGrid", {
            /**
             * @hidden
             */
            get: function () {
                var currGrid = this;
                while (currGrid.parent) {
                    currGrid = currGrid.parent;
                }
                return currGrid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "iconTemplate", {
            /**
             * @hidden
             */
            get: function () {
                var expanded = this.hasExpandedRecords() && this.hasExpandableChildren;
                if (!expanded && this.showExpandAll) {
                    return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
                }
                else {
                    return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxHierarchicalGridComponent.prototype.getDragGhostCustomTemplate = function () {
            if (this.parentIsland) {
                return this.parentIsland.getDragGhostCustomTemplate();
            }
            return _super.prototype.getDragGhostCustomTemplate.call(this);
        };
        /**
         * @hidden
         * Gets the visible content height that includes header + tbody + footer.
         * For hierarchical child grid it may be scrolled and not fully visible.
         */
        IgxHierarchicalGridComponent.prototype.getVisibleContentHeight = function () {
            var height = _super.prototype.getVisibleContentHeight.call(this);
            if (this.parent) {
                var rootHeight = this.rootGrid.getVisibleContentHeight();
                var topDiff = this.nativeElement.getBoundingClientRect().top - this.rootGrid.nativeElement.getBoundingClientRect().top;
                height = rootHeight - topDiff > height ? height : rootHeight - topDiff;
            }
            return height;
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.toggleAll = function () {
            var expanded = this.hasExpandedRecords() && this.hasExpandableChildren;
            if (!expanded && this.showExpandAll) {
                this.expandAll();
            }
            else {
                this.collapseAll();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxHierarchicalGridComponent.prototype.hasExpandedRecords = function () {
            if (this.expandChildren) {
                return true;
            }
            var hasExpandedEntry = false;
            this.expansionStates.forEach(function (value) {
                if (value) {
                    hasExpandedEntry = value;
                }
            });
            return hasExpandedEntry;
        };
        IgxHierarchicalGridComponent.prototype.getDefaultExpandState = function (record) {
            if (this.hasChildrenKey && !record[this.hasChildrenKey]) {
                return false;
            }
            return this.expandChildren;
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.isExpanded = function (record) {
            return this.gridAPI.get_row_expansion_state(record);
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.viewCreatedHandler = function (args) {
            if (this.isChildGridRecord(args.context.$implicit)) {
                var key = args.context.$implicit.rowID;
                this.childGridTemplates.set(key, args);
            }
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.viewMovedHandler = function (args) {
            var _this = this;
            if (this.isChildGridRecord(args.context.$implicit)) {
                // view was moved, update owner in cache
                var key = args.context.$implicit.rowID;
                var cachedData = this.childGridTemplates.get(key);
                cachedData.owner = args.owner;
                this.childLayoutList.forEach(function (layout) {
                    var relatedGrid = _this.hgridAPI.getChildGridByID(layout.key, args.context.$implicit.rowID);
                    if (relatedGrid && relatedGrid.updateOnRender) {
                        // Detect changes if `expandChildren` has changed when the grid wasn't visible. This is for performance reasons.
                        relatedGrid.notifyChanges(true);
                        relatedGrid.updateOnRender = false;
                    }
                });
                var childGrids = this.getChildGrids(true);
                childGrids.forEach(function (grid) {
                    if (grid.isPercentWidth) {
                        grid.notifyChanges(true);
                    }
                    grid.updateScrollPosition();
                });
            }
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.updateScrollPosition = function () {
            var vScr = this.verticalScrollContainer.getScroll();
            var hScr = this.headerContainer.getScroll();
            if (vScr) {
                vScr.scrollTop = this.scrollTop;
            }
            if (hScr) {
                hScr.scrollLeft = this.scrollLeft;
            }
        };
        IgxHierarchicalGridComponent.prototype.onContainerScroll = function () {
            this.hideOverlays();
        };
        IgxHierarchicalGridComponent.prototype.getChildGrids = function (inDeph) {
            return this.hgridAPI.getChildGrids(inDeph);
        };
        IgxHierarchicalGridComponent.prototype.generateDataFields = function (data) {
            var _this = this;
            return _super.prototype.generateDataFields.call(this, data).filter(function (field) {
                var layoutsList = _this.parentIsland ? _this.parentIsland.children : _this.childLayoutList;
                var keys = layoutsList.map(function (item) { return item.key; });
                return keys.indexOf(field) === -1;
            });
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.initColumns = function (collection, cb) {
            if (cb === void 0) { cb = null; }
            if (this.hasColumnLayouts) {
                // invalid configuration - hierarchical grid should not allow column layouts
                // remove column layouts
                var nonColumnLayoutColumns = this.columnList.filter(function (col) { return !col.columnLayout && !col.columnLayoutChild; });
                this.columnList.reset(nonColumnLayoutColumns);
            }
            _super.prototype.initColumns.call(this, collection, cb);
        };
        IgxHierarchicalGridComponent.prototype.setupColumns = function () {
            if (this.parentIsland && this.parentIsland.childColumns.length > 0 && !this.autoGenerate) {
                this.createColumnsList(this.parentIsland.childColumns.toArray());
            }
            _super.prototype.setupColumns.call(this);
        };
        IgxHierarchicalGridComponent.prototype.onColumnsChanged = function (change) {
            var _this = this;
            Promise.resolve().then(function () {
                _this.updateColumnList();
                var cols = change.filter(function (c) { return c.gridAPI.grid === _this; });
                if (cols.length > 0 || _this.autoGenerate) {
                    _this.columnList.reset(cols);
                    _super.prototype.onColumnsChanged.call(_this, _this.columnList);
                }
            });
        };
        IgxHierarchicalGridComponent.prototype._shouldAutoSize = function (renderedHeight) {
            if (this.isPercentHeight && this.parent) {
                return true;
            }
            return _super.prototype._shouldAutoSize.call(this, renderedHeight);
        };
        IgxHierarchicalGridComponent.prototype.updateSizes = function () {
            if (document.body.contains(this.nativeElement) && this.isPercentWidth) {
                this.reflow();
                this.hgridAPI.getChildGrids(false).forEach(function (grid) {
                    grid.updateSizes();
                });
            }
        };
        IgxHierarchicalGridComponent.prototype.updateColumnList = function (recalcColSizes) {
            if (recalcColSizes === void 0) { recalcColSizes = true; }
            var childLayouts = this.parent ? this.childLayoutList : this.allLayoutList;
            var nestedColumns = childLayouts.map(function (layout) { return layout.columnList.toArray(); });
            var colsArray = [].concat.apply([], nestedColumns);
            var colLength = this.columnList.length;
            if (colsArray.length > 0) {
                var topCols = this.columnList.filter(function (item) { return colsArray.indexOf(item) === -1; });
                this.columnList.reset(topCols);
                if (recalcColSizes && this.columnList.length !== colLength) {
                    this.calculateGridSizes(false);
                }
            }
        };
        IgxHierarchicalGridComponent.prototype._clearSeletionHighlights = function () {
            __spread([this.rootGrid], this.rootGrid.getChildGrids(true)).forEach(function (grid) {
                grid.selectionService.clear();
                grid.selectionService.activeElement = null;
                grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
                grid.highlightedRowID = null;
                grid.cdr.markForCheck();
            });
        };
        IgxHierarchicalGridComponent.prototype.hg_verticalScrollHandler = function (event) {
            this.scrollTop = event.target.scrollTop;
        };
        IgxHierarchicalGridComponent.prototype.hg_horizontalScrollHandler = function (event) {
            this.scrollLeft = event.target.scrollLeft;
        };
        return IgxHierarchicalGridComponent;
    }(IgxHierarchicalGridBaseDirective));
    IgxHierarchicalGridComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-hierarchical-grid',
                    template: "<ng-content select=\"igx-grid-toolbar\"></ng-content>\n<ng-container #toolbarOutlet></ng-container>\n\n<div class=\"igx-grid__thead\" role=\"rowgroup\">\n    <div class=\"igx-grid__thead-wrapper\" (keydown.meta.c)=\"copyHandler($event)\" (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" \n        tabindex=\"0\" (focus)=\"navigation.focusFirstCell()\" [attr.aria-activedescendant]=\"activeDescendant\"\n        (keydown)=\"navigation.headerNavigation($event)\" [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <!-- Drag indicator -->\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator igx-grid__tr-action\" [ngClass]=\"{\n                        'igx-grid__drag-indicator--header': !isRowSelectable\n                    }\" (pointerdown)='$event.preventDefault()' #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n\n            <!-- Select All Row -->\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                        'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                    }\"  (pointerdown)='$event.preventDefault()'>\n                    <ng-template #headSelector\n                                 *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter,\n                                        selectAll: selectAllRows.bind(this),\n                                        deselectAll: deselectAllRows.bind(this) }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n\n            <!-- Expand all -->\n            <div #headerHierarchyExpander (click)=\"toggleAll()\" (mousedown)='$event.preventDefault()' [hidden]='!hasExpandableChildren || !hasVisibleColumns' [ngClass]=\"{\n                'igx-grid__hierarchical-expander igx-grid__hierarchical-expander--header igx-grid__tr-action': hasExpandableChildren,\n                'igx-grid__hierarchical-expander--push': filteringService.isFilterRowVisible,\n                'igx-grid__hierarchical-expander--no-border': isRowSelectable || rowDraggable\n            }\">\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n            </div>\n\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                                           [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                         [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                         [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                         [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                                       [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group\n                            [column]=\"col\"\n                            [gridID]=\"id\"\n                            [style.min-width]=\"getHeaderGroupWidth(col)\"\n                            [style.flex-basis]=\"getHeaderGroupWidth(col)\"\n                            [style.left]=\"col.rightPinnedOffset\">\n                    </igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div igxToggle #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollSize\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\" role=\"rowgroup\">\n    <div class=\"igx-grid__tbody-content\"  tabindex=\"0\" (focus)=\"navigation.focusTbody($event)\"\n     (keydown)=\"navigation.handleNavigation($event)\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\" [attr.aria-activedescendant]=\"activeDescendant\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth' #tbody (scroll)='preventContainerScroll($event)'>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template #pinnedRecordsTemplate>\n            <ng-container *ngIf=\"data\n            | gridTransaction:id:pipeTrigger\n            | visibleColumns:hasVisibleColumns\n            | gridRowPinning:id:true:pipeTrigger\n            | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n            | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger:true\n            | gridAddRow:true:pipeTrigger as pinnedData\">\n                <div #pinContainer *ngIf='pinnedData.length > 0' class='igx-grid__tr--pinned'\n                    [ngClass]=\"{ 'igx-grid__tr--pinned-bottom':  !isRowPinningToTop, 'igx-grid__tr--pinned-top': isRowPinningToTop }\"\n                    [style.width.px]='calcWidth'>\n                    <ng-container *ngFor=\"let rowData of pinnedData; let rowIndex = index\">\n                        <ng-container *ngTemplateOutlet=\"pinned_hierarchical_record_template; context: getContext(rowData, rowIndex, true)\">\n                        </ng-container>\n                    </ng-container>\n                </div>\n            </ng-container>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-template igxGridFor let-rowData let-rowIndex=\"index\" [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger\n        | gridHierarchicalPaging:page:perPage:id:pipeTrigger\n        | gridHierarchical:expansionStates:id:primaryKey:childLayoutKeys:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\n        | gridAddRow:false:pipeTrigger\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" [igxForTrackBy]='trackChanges'\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template\n                [igxTemplateOutlet]='(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template))'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex, false)' (onViewCreated)='viewCreatedHandler($event)'\n                (onViewMoved)='viewMovedHandler($event)' (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n            <!-- <ng-container *igxTemplateOutlet=\"(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template)); context: getContext(rowData)\"></ng-container> -->\n        </ng-template>\n        <ng-template #hierarchical_record_template let-rowIndex=\"index\" let-disabledRow=\"disabled\" let-rowData let-isAddRow=\"addRow\">\n            <igx-hierarchical-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [disabled]=\"disabledRow\" [rowData]=\"rowData\" [addRow]=\"isAddRow\" #row>\n            </igx-hierarchical-grid-row>\n        </ng-template>\n\n        <ng-template #pinned_hierarchical_record_template let-rowIndex=\"index\" let-rowData let-isAddRow=\"addRow\">\n            <igx-hierarchical-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" [addRow]=\"isAddRow\" #row #pinnedRow>\n            </igx-hierarchical-grid-row>\n        </ng-template>\n        <ng-template #child_record_template let-rowIndex=\"index\" let-rowData>\n            <div style=\"overflow: auto; width: 100%;\" [attr.data-rowindex]='rowIndex' (scroll)='onContainerScroll()'\n                [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr--highlighted':isRowHighlighted(rowData)\n            }\">\n                <igx-child-grid-row *ngFor=\"let layout of childLayoutList\" [parentGridID]=\"id\" [index]=\"rowIndex\"\n                    [rowData]=\"rowData\" [layout]='layout' #row>\n                </igx-child-grid-row>\n            </div>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n            id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark *ngIf=\"!this.parent\"></igc-trial-watermark>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\" (pointerdown)=\"$event.preventDefault()\">\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [actionText]=\"snackbarActionText\" [displayTime]='snackbarDisplayTime'>{{snackbarLabel}}</igx-snackbar>\n    </div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <div tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\" [attr.aria-activedescendant]=\"activeDescendant\"\n     (keydown)=\"navigation.summaryNav($event)\">\n        <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n            *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n            [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n            class=\"igx-grid__summaries\" #summaryRow>\n        </igx-grid-summary-row>\n        <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n            [style.width.px]=\"scrollSize\"></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\"  (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [overlaySettings]=\"paginatorSettings\" [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\"\n        [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button igxButton=\"raised\" igxRipple (click)='beginAddRowByIndex(null, -1, $event)'>\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\">unfold_more</igx-icon>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" [active]='hasExpandedRecords() && hasExpandableChildren'>unfold_less</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle #rowEditingOverlay>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\" *ngIf=\"!this.crudService.row?.isAddRow\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon>drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n",
                    providers: [
                        IgxGridSelectionService,
                        IgxGridCRUDService,
                        { provide: GridBaseAPIService, useClass: IgxHierarchicalGridAPIService },
                        { provide: IgxGridBaseDirective, useExisting: i0.forwardRef(function () { return IgxHierarchicalGridComponent; }) },
                        IgxGridSummaryService,
                        IgxFilteringService,
                        IgxHierarchicalGridNavigationService,
                        IgxForOfSyncService,
                        IgxForOfScrollSyncService,
                        IgxRowIslandAPIService
                    ]
                },] }
    ];
    IgxHierarchicalGridComponent.propDecorators = {
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        childLayoutList: [{ type: i0.ContentChildren, args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false },] }],
        allLayoutList: [{ type: i0.ContentChildren, args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: true },] }],
        toolbarTemplate: [{ type: i0.ContentChild, args: [IgxGridToolbarDirective, { read: i0.TemplateRef, static: true },] }],
        toolbarOutlet: [{ type: i0.ViewChild, args: ['toolbarOutlet', { read: i0.ViewContainerRef },] }],
        templateOutlets: [{ type: i0.ViewChildren, args: [IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective },] }],
        hierarchicalRows: [{ type: i0.ViewChildren, args: [IgxChildGridRowComponent, { read: IgxChildGridRowComponent },] }],
        hierarchicalRecordTemplate: [{ type: i0.ViewChild, args: ['hierarchical_record_template', { read: i0.TemplateRef, static: true },] }],
        childTemplate: [{ type: i0.ViewChild, args: ['child_record_template', { read: i0.TemplateRef, static: true },] }],
        headerHierarchyExpander: [{ type: i0.ViewChild, args: ['headerHierarchyExpander', { read: i0.ElementRef, static: true },] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        data: [{ type: i0.Input }],
        expandChildren: [{ type: i0.Input }]
    };

    var IgxHierarchicalGridCellComponent = /** @class */ (function (_super) {
        __extends(IgxHierarchicalGridCellComponent, _super);
        function IgxHierarchicalGridCellComponent(selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil) {
            var _this = _super.call(this, selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil) || this;
            _this.selectionService = selectionService;
            _this.crudService = crudService;
            _this.gridAPI = gridAPI;
            _this.cdr = cdr;
            _this.zone = zone;
            _this.platformUtil = platformUtil;
            return _this;
        }
        IgxHierarchicalGridCellComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this._rootGrid = this._getRootGrid();
        };
        // TODO: Extend the new selection service to avoid complete traversal
        IgxHierarchicalGridCellComponent.prototype._clearAllHighlights = function () {
            var _this = this;
            __spread([this._rootGrid], this._rootGrid.getChildGrids(true)).forEach(function (grid) {
                if (grid !== _this.grid && grid.navigation.activeNode) {
                    grid.navigation.clearActivation();
                    grid.selectionService.initKeyboardState();
                    grid.selectionService.clear();
                }
                grid.selectionService.activeElement = null;
                grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
                grid.highlightedRowID = null;
                grid.cdr.markForCheck();
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxHierarchicalGridCellComponent.prototype.activate = function (event) {
            this._clearAllHighlights();
            var currentElement = this.grid.nativeElement;
            var parentGrid = this.grid;
            var childGrid;
            // add highligh to the current grid
            if (this._rootGrid.id !== currentElement.id) {
                currentElement.classList.add('igx-grid__tr--highlighted');
            }
            // add highligh to the current grid
            while (this._rootGrid.id !== parentGrid.id) {
                childGrid = parentGrid;
                parentGrid = parentGrid.parent;
                var parentRowID = parentGrid.hgridAPI.getParentRowId(childGrid);
                parentGrid.highlightedRowID = parentRowID;
            }
            this.grid.navigation.activeNode.gridID = this.gridID;
            _super.prototype.activate.call(this, event);
        };
        IgxHierarchicalGridCellComponent.prototype._getRootGrid = function () {
            var currGrid = this.grid;
            while (currGrid.parent) {
                currGrid = currGrid.parent;
            }
            return currGrid;
        };
        return IgxHierarchicalGridCellComponent;
    }(IgxGridCellComponent));
    IgxHierarchicalGridCellComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    selector: 'igx-hierarchical-grid-cell',
                    template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip\n        *ngIf=\"displayPinnedChip\"\n        class=\"igx-grid__td--pinned-chip\"\n        [disabled]=\"true\"\n        [displayDensity]=\"'compact'\"\n        >{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip\n    >\n</ng-template>\n<ng-template #defaultCell>\n    <div *ngIf=\"column.dataType !== 'boolean'\"\n        igxTextHighlight\n        class=\"igx-grid__td-text\"\n        style=\"pointer-events: none;\"\n        [cssClass]=\"highlightClass\"\n        [activeCssClass]=\"activeHighlightClass\"\n        [groupName]=\"gridID\"\n        [value]=\"\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === 'number'\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'date'\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : column.dataType === 'currency'\n                ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'percent'\n                ? (value | percent:column.pipeArgs.digitsInfo:grid.locale)\n                : value\n        \"\n        [row]=\"rowData\"\n        [column]=\"this.column.field\"\n        [containerClass]=\"'igx-grid__td-text'\"\n        [metadata]=\"searchMetadata\"\n    >{{\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === \"number\"\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === \"date\"\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : column.dataType === 'currency'\n                ? (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'percent'\n                ? (value | percent:column.pipeArgs.digitsInfo:grid.locale)\n                : value\n        }}</div>\n    <igx-icon\n        *ngIf=\"column.dataType === 'boolean'\"\n        [ngClass]=\"{ 'igx-icon--success': value, 'igx-icon--error': !value }\"\n        >{{ value ? \"check\" : \"close\" }}</igx-icon\n    >\n</ng-template>\n<ng-template #addRowCell let-cell=\"cell\">\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n    [cssClass]=\"highlightClass\"\n    [activeCssClass]=\"activeHighlightClass\"\n    [groupName]=\"gridID\"\n    [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ?\n        (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ?\n        (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : column.dataType === 'currency' ?\n        (value | currency:currencyCode:column.pipeArgs.display:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'percent' ?\n        (value | percent:column.pipeArgs.digitsInfo:grid.locale) : value\"\n    [row]=\"rowData\"\n    [column]=\"this.column.field\"\n    [containerClass]=\"'igx-grid__td-text'\"\n    [metadata]=\"searchMetadata\">{{\n        !isEmptyAddRowCell ? value : (column.header || column.field)\n    }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox\n            (change)=\"editValue = $event.checked\"\n            [value]=\"editValue\"\n            [checked]=\"editValue\"\n            [igxFocus]=\"true\"\n            [disableRipple]=\"true\"\n        ></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker\n            [style.width.%]=\"100\"\n            [outlet]=\"grid.outlet\"\n            mode=\"dropdown\"\n            [locale]=\"grid.locale\"\n            [(value)]=\"editValue\"\n            [igxFocus]=\"true\"\n            [labelVisibility]=\"false\"\n        >\n        </igx-date-picker>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'currency'\">\n        <igx-input-group displayDensity=\"compact\">\n            <igx-prefix *ngIf=\"grid.currencyPositionLeft\">{{ currencyCodeSymbol }}</igx-prefix>\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n            <igx-suffix *ngIf=\"!grid.currencyPositionLeft\" >{{ currencyCodeSymbol }}</igx-suffix>\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'percent'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                [step]=\"step\"\n                type=\"number\"\n            />\n            <igx-suffix> {{ editValue | percent:column.pipeArgs.digitsInfo:grid.locale }} </igx-suffix>\n        </igx-input-group>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n",
                    providers: [HammerGesturesManager]
                },] }
    ];
    IgxHierarchicalGridCellComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: GridBaseAPIService },
        { type: i0.ChangeDetectorRef },
        { type: i0.ElementRef },
        { type: i0.NgZone },
        { type: HammerGesturesManager },
        { type: PlatformUtil }
    ]; };

    var IgxHierarchicalRowComponent = /** @class */ (function (_super) {
        __extends(IgxHierarchicalRowComponent, _super);
        function IgxHierarchicalRowComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.expanderClass = 'igx-grid__hierarchical-expander';
            _this.rolActionClass = 'igx-grid__tr-action';
            /**
             * @hidden
             * @internal
             */
            _this.select = function () {
                _this.grid.selectRows([_this.rowID]);
            };
            /**
             * @hidden
             * @internal
             */
            _this.deselect = function () {
                _this.grid.deselectRows([_this.rowID]);
            };
            return _this;
        }
        Object.defineProperty(IgxHierarchicalRowComponent.prototype, "expanderClassResolved", {
            /**
             * @hidden
             */
            get: function () {
                var _a;
                return _a = {},
                    _a[this.expanderClass + " " + this.rolActionClass] = !this.pinned || this.disabled,
                    _a[this.expanderClass + "--empty"] = this.pinned && !this.disabled,
                    _a;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalRowComponent.prototype, "viewIndex", {
            get: function () {
                return this.index + this.grid.page * this.grid.perPage;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalRowComponent.prototype, "expanded", {
            /**
             * Returns whether the row is expanded.
             * ```typescript
             * const RowExpanded = this.grid1.rowList.first.expanded;
             * ```
             */
            get: function () {
                return this.gridAPI.get_row_expansion_state(this.rowData);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalRowComponent.prototype, "expandedClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.expanded && !this.pinned;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalRowComponent.prototype, "hasChildren", {
            get: function () {
                return !!this.grid.childLayoutKeys.length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalRowComponent.prototype, "highlighted", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid && this.grid.highlightedRowID === this.rowID;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxHierarchicalRowComponent.prototype.expanderClick = function (event) {
            event.stopPropagation();
            this.toggle();
        };
        /**
         * Toggles the hierarchical row.
         * ```typescript
         * this.grid1.rowList.first.toggle()
         * ```
         */
        IgxHierarchicalRowComponent.prototype.toggle = function () {
            if (this.added) {
                return;
            }
            var grid = this.gridAPI.grid;
            this.endEdit(grid.rootGrid);
            this.gridAPI.set_row_expansion_state(this.rowID, !this.expanded);
            grid.cdr.detectChanges();
        };
        Object.defineProperty(IgxHierarchicalRowComponent.prototype, "iconTemplate", {
            /**
             * @hidden
             */
            get: function () {
                var expandable = true;
                if (this.grid.hasChildrenKey) {
                    expandable = this.rowData[this.grid.hasChildrenKey];
                }
                if (!expandable || (this.pinned && !this.disabled)) {
                    return this.defaultEmptyTemplate;
                }
                if (this.expanded) {
                    return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
                }
                else {
                    return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
                }
            },
            enumerable: false,
            configurable: true
        });
        IgxHierarchicalRowComponent.prototype.endEdit = function (grid) {
            if (grid.crudService.cellInEditMode) {
                grid.endEdit();
            }
            grid.hgridAPI.getChildGrids(true).forEach(function (g) {
                if (g.crudService.cellInEditMode) {
                    g.endEdit();
                }
            });
        };
        return IgxHierarchicalRowComponent;
    }(IgxRowDirective));
    IgxHierarchicalRowComponent.decorators = [
        { type: i0.Component, args: [{
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    selector: 'igx-hierarchical-grid-row',
                    template: "<ng-container *ngTemplateOutlet='addRow ? addTemp : defaultTemp'></ng-container>\n<ng-template #defaultExpandedTemplate>\n    <igx-icon [active]='!added'>expand_more</igx-icon>\n</ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n    <igx-icon [active]='!added'>chevron_right</igx-icon>\n</ng-template>\n\n<ng-template #defaultEmptyTemplate>\n    <igx-icon></igx-icon>\n</ng-template>\n\n<ng-template #addTemp>\n    <div class='igx-grid__tr--inner' [class.igx-grid__tr--add-animate]='animateAdd' (animationend)='animationEndHandler()'>\n        <ng-container *ngTemplateOutlet='defaultTemp'></ng-container>\n    </div>\n</ng-template>\n<ng-template #defaultTemp>\n    <!-- Drag indicator -->\n    <ng-container *ngIf=\"rowDraggable\">\n        <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\" (pointerdown)=\"$event.preventDefault()\">\n            <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n        </div>\n    </ng-container>\n\n    <!-- Select Row -->\n    <ng-container *ngIf=\"showRowSelectors\">\n        <div class=\"igx-grid__cbx-selection igx-grid__tr-action\" (click)=\"onRowSelectorClick($event)\" (pointerdown)=\"$event.preventDefault()\">\n            <ng-template *ngTemplateOutlet=\"\n                this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n                context: { $implicit: {\n                                index: viewIndex,\n                                rowID: rowID,\n                                selected: selected,\n                                select: select,\n                                deselect: deselect }}\">\n            </ng-template>\n        </div>\n    </ng-container>\n\n    <!-- Row Expander -->\n    <div  (click)=\"expanderClick($event)\" (mousedown)='$event.preventDefault()' [ngClass]=\"expanderClassResolved\" *ngIf=\"hasChildren\" #expander>\n        <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n        </ng-container>\n    </div>\n\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n        <ng-template *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-template>\n    </ng-container>\n\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"' [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <igx-hierarchical-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [style.min-height.px]=\"cellHeight\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\">\n        </igx-hierarchical-grid-cell>\n    </ng-template>\n\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n        <ng-template *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-template>\n    </ng-container>\n\n    <ng-template #rowSelectorBaseTemplate>\n        <div class=\"igx-grid__cbx-padding\">\n            <igx-checkbox\n                [tabindex]=\"-1\"\n                [readonly]=\"true\"\n                [checked]=\"selected\"\n                disableRipple=\"true\"\n                [disabled]=\"deleted\"\n                [disableTransitions]=\"grid.disableTransitions\"\n                [aria-label]=\"rowCheckboxAriaLabel\">\n            </igx-checkbox>\n        </div>\n    </ng-template>\n\n    <ng-template #pinnedCellsTemplate let-col>\n        <igx-hierarchical-grid-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n            [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [firstPinned]=\"col.isFirstPinned\"\n            [lastPinned]=\"col.isLastPinned\"\n            [style.min-height.px]=\"cellHeight\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [style.left]=\"col.rightPinnedOffset\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger:rowData[col.field]:col.hasNestedPath\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\">\n        </igx-hierarchical-grid-cell>\n    </ng-template>\n</ng-template>\n",
                    providers: [{ provide: IgxRowDirective, useExisting: i0.forwardRef(function () { return IgxHierarchicalRowComponent; }) }]
                },] }
    ];
    IgxHierarchicalRowComponent.propDecorators = {
        expander: [{ type: i0.ViewChild, args: ['expander', { read: i0.ElementRef },] }],
        _cells: [{ type: i0.ViewChildren, args: [i0.forwardRef(function () { return IgxHierarchicalGridCellComponent; }), { read: IgxHierarchicalGridCellComponent },] }],
        defaultExpandedTemplate: [{ type: i0.ViewChild, args: ['defaultExpandedTemplate', { read: i0.TemplateRef, static: true },] }],
        defaultEmptyTemplate: [{ type: i0.ViewChild, args: ['defaultEmptyTemplate', { read: i0.TemplateRef, static: true },] }],
        defaultCollapsedTemplate: [{ type: i0.ViewChild, args: ['defaultCollapsedTemplate', { read: i0.TemplateRef, static: true },] }],
        expandedClass: [{ type: i0.HostBinding, args: ['class.igx-grid__tr--expanded',] }],
        highlighted: [{ type: i0.HostBinding, args: ['class.igx-grid__tr--highlighted',] }]
    };

    /**
     * @hidden
     */
    var IgxGridHierarchicalPipe = /** @class */ (function () {
        function IgxGridHierarchicalPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridHierarchicalPipe.prototype.transform = function (collection, state, id, primaryKey, childKeys, pipeTrigger) {
            if (state === void 0) { state = new Map(); }
            if (childKeys.length === 0) {
                return collection;
            }
            var grid = this.gridAPI.grid;
            if (grid.verticalScrollContainer.isRemote) {
                return collection;
            }
            var result = this.addHierarchy(grid, cloneArray(collection), state, primaryKey, childKeys);
            return result;
        };
        IgxGridHierarchicalPipe.prototype.addHierarchy = function (grid, data, state, primaryKey, childKeys) {
            var result = [];
            data.forEach(function (v) {
                result.push(v);
                var childGridsData = {};
                childKeys.forEach(function (childKey) {
                    var childData = v[childKey] ? v[childKey] : null;
                    childGridsData[childKey] = childData;
                });
                if (grid.gridAPI.get_row_expansion_state(v)) {
                    result.push({ rowID: primaryKey ? v[primaryKey] : v, childGridsData: childGridsData });
                }
            });
            return result;
        };
        return IgxGridHierarchicalPipe;
    }());
    IgxGridHierarchicalPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'gridHierarchical',
                    pure: true
                },] }
    ];
    IgxGridHierarchicalPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    /**
     * @hidden
     */
    var IgxGridHierarchicalPagingPipe = /** @class */ (function () {
        function IgxGridHierarchicalPagingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridHierarchicalPagingPipe.prototype.transform = function (collection, page, perPage, id, pipeTrigger) {
            if (page === void 0) { page = 0; }
            if (perPage === void 0) { perPage = 15; }
            if (!this.gridAPI.grid.paging || this.gridAPI.grid.pagingMode !== exports.GridPagingMode.Local) {
                return collection;
            }
            var state = {
                index: page,
                recordsPerPage: perPage
            };
            var total = this.gridAPI.grid._totalRecords >= 0 ? this.gridAPI.grid._totalRecords : collection.length;
            var result = DataUtil.page(cloneArray(collection), state, total);
            this.gridAPI.grid.pagingState = state;
            return result;
        };
        return IgxGridHierarchicalPagingPipe;
    }());
    IgxGridHierarchicalPagingPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'gridHierarchicalPaging',
                    pure: true
                },] }
    ];
    IgxGridHierarchicalPagingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };

    /**
     * @hidden
     */
    var IgxHierarchicalGridModule = /** @class */ (function () {
        function IgxHierarchicalGridModule() {
        }
        return IgxHierarchicalGridModule;
    }());
    IgxHierarchicalGridModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxHierarchicalGridComponent,
                        IgxHierarchicalRowComponent,
                        IgxRowIslandComponent,
                        IgxChildGridRowComponent,
                        IgxHierarchicalGridCellComponent,
                        IgxGridHierarchicalPipe,
                        IgxGridHierarchicalPagingPipe
                    ],
                    exports: [
                        IgxGridModule,
                        IgxHierarchicalGridComponent,
                        IgxHierarchicalRowComponent,
                        IgxHierarchicalGridCellComponent,
                        IgxRowIslandComponent,
                        IgxChildGridRowComponent
                    ],
                    imports: [
                        IgxGridModule,
                    ],
                    entryComponents: [
                        IgxGridComponent
                    ],
                    schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                },] }
    ];

    /**
     * IgxActionIcon is a container for the action nav icon of the IgxNavbar.
     */
    var IgxNavbarActionDirective = /** @class */ (function () {
        function IgxNavbarActionDirective() {
        }
        return IgxNavbarActionDirective;
    }());
    IgxNavbarActionDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'igx-navbar-action,[igxNavbarAction]'
                },] }
    ];
    var IgxNavbarTitleDirective = /** @class */ (function () {
        function IgxNavbarTitleDirective() {
        }
        return IgxNavbarTitleDirective;
    }());
    IgxNavbarTitleDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'igx-navbar-title,[igxNavbarTitle]'
                },] }
    ];
    var NEXT_ID$o = 0;
    /**
     * **Ignite UI for Angular Navbar** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navbar.html)
     *
     * The Ignite UI Navbar is most commonly used to provide an app header with a hamburger menu and navigation
     * state such as a "Go Back" button. It also supports other actions represented by icons.
     *
     * Example:
     * ```html
     * <igx-navbar title="Sample App" actionButtonIcon="menu">
     *   <igx-icon>search</igx-icon>
     *   <igx-icon>favorite</igx-icon>
     *   <igx-icon>more_vert</igx-icon>
     * </igx-navbar>
     * ```
     */
    var IgxNavbarComponent = /** @class */ (function () {
        function IgxNavbarComponent() {
            /**
             * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
             * ```html
             * <igx-navbar [id]="'igx-navbar-12'" title="Sample App" actionButtonIcon="menu">
             * ```
             */
            this.id = "igx-navbar-" + NEXT_ID$o++;
            /**
             * The event that will be thrown when the action is executed,
             * provides reference to the `IgxNavbar` component as argument
             * ```typescript
             * public actionExc(event){
             *     alert("Action Execute!");
             * }
             *  //..
             * ```
             * ```html
             * <igx-navbar (action)="actionExc($event)" title="Sample App" actionButtonIcon="menu">
             * ```
             */
            this.action = new i0.EventEmitter();
            /**
             * An @Input property that sets the titleId of the `IgxNavbarComponent`. If not set it will be automatically generated.
             * ```html
             * <igx-navbar [titleId]="'igx-navbar-7'" title="Sample App" actionButtonIcon="menu">
             * ```
             */
            this.titleId = "igx-navbar-title-" + NEXT_ID$o++;
            this.isVisible = true;
        }
        Object.defineProperty(IgxNavbarComponent.prototype, "isActionButtonVisible", {
            /**
             * Returns whether the `IgxNavbarComponent` action button is visible, true/false.
             * ```typescript
             *  @ViewChild("MyChild")
             * public navBar: IgxNavbarComponent;
             * ngAfterViewInit(){
             *     let actionButtonVisibile = this.navBar.isActionButtonVisible;
             * }
             * ```
             */
            get: function () {
                if (this.actionIconTemplate || !this.actionButtonIcon) {
                    return false;
                }
                return this.isVisible;
            },
            /**
             * Sets whether the action button of the `IgxNavbarComponent` is visible.
             * ```html
             * <igx-navbar [title]="currentView" [isActionButtonVisible]="'false'"></igx-navbar>
             * ```
             */
            set: function (value) {
                this.isVisible = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavbarComponent.prototype, "isTitleContentVisible", {
            get: function () {
                return this.titleContent ? true : false;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxNavbarComponent.prototype._triggerAction = function () {
            this.action.emit(this);
        };
        return IgxNavbarComponent;
    }());
    IgxNavbarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-navbar',
                    template: "<nav class=\"igx-navbar\" role=\"navigation\" [attr.aria-labelledby]=\"titleId\">\n    <div class=\"igx-navbar__left\">\n        <igx-icon\n            (click)=\"_triggerAction()\"\n            *ngIf=\"isActionButtonVisible\">\n            {{actionButtonIcon}}\n        </igx-icon>\n        <ng-content select=\"igx-navbar-action, [igxNavbarAction]\"></ng-content>\n        <h1\n            *ngIf=\"!isTitleContentVisible\"\n            class=\"igx-navbar__title\"\n            [attr.id]=\"titleId\">\n            {{ title }}\n        </h1>\n        <ng-content select=\"igx-navbar-title, [igxNavbarTitle]\"></ng-content>\n    </div>\n    <div class=\"igx-navbar__right\">\n        <ng-content></ng-content>\n    </div>\n</nav>\n",
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                },] }
    ];
    IgxNavbarComponent.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        actionButtonIcon: [{ type: i0.Input }],
        title: [{ type: i0.Input }],
        action: [{ type: i0.Output }],
        titleId: [{ type: i0.Input }],
        actionIconTemplate: [{ type: i0.ContentChild, args: [IgxNavbarActionDirective, { read: IgxNavbarActionDirective },] }],
        titleContent: [{ type: i0.ContentChild, args: [IgxNavbarTitleDirective, { read: IgxNavbarTitleDirective },] }],
        isActionButtonVisible: [{ type: i0.Input }]
    };
    /**
     * @hidden
     */
    var IgxNavbarModule = /** @class */ (function () {
        function IgxNavbarModule() {
        }
        return IgxNavbarModule;
    }());
    IgxNavbarModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxNavbarComponent, IgxNavbarActionDirective, IgxNavbarTitleDirective],
                    exports: [IgxNavbarComponent, IgxNavbarActionDirective, IgxNavbarTitleDirective],
                    imports: [IgxButtonModule, IgxIconModule, i2.CommonModule]
                },] }
    ];

    var IgxNavDrawerItemDirective = /** @class */ (function () {
        function IgxNavDrawerItemDirective() {
            /**
             * @hidden
             */
            this.active = false;
            /**
             * @hidden
             */
            this.isHeader = false;
            /**
             * @hidden
             */
            this.activeClass = 'igx-nav-drawer__item--active';
        }
        Object.defineProperty(IgxNavDrawerItemDirective.prototype, "defaultCSS", {
            /**
             * @hidden
             */
            get: function () {
                return !this.active && !this.isHeader;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavDrawerItemDirective.prototype, "currentCSS", {
            /**
             * @hidden
             */
            get: function () {
                return this.active && !this.isHeader;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavDrawerItemDirective.prototype, "headerCSS", {
            /**
             * @hidden
             */
            get: function () {
                return this.isHeader;
            },
            enumerable: false,
            configurable: true
        });
        return IgxNavDrawerItemDirective;
    }());
    IgxNavDrawerItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDrawerItem]',
                    exportAs: 'igxDrawerItem'
                },] }
    ];
    IgxNavDrawerItemDirective.propDecorators = {
        active: [{ type: i0.Input, args: ['active',] }],
        isHeader: [{ type: i0.Input, args: ['isHeader',] }],
        defaultCSS: [{ type: i0.HostBinding, args: ['class.igx-nav-drawer__item',] }],
        currentCSS: [{ type: i0.HostBinding, args: ['class.igx-nav-drawer__item--active',] }],
        headerCSS: [{ type: i0.HostBinding, args: ['class.igx-nav-drawer__item--header',] }]
    };
    var IgxNavDrawerTemplateDirective = /** @class */ (function () {
        function IgxNavDrawerTemplateDirective(template) {
            this.template = template;
        }
        return IgxNavDrawerTemplateDirective;
    }());
    IgxNavDrawerTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDrawer]'
                },] }
    ];
    IgxNavDrawerTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    var IgxNavDrawerMiniTemplateDirective = /** @class */ (function () {
        function IgxNavDrawerMiniTemplateDirective(template) {
            this.template = template;
        }
        return IgxNavDrawerMiniTemplateDirective;
    }());
    IgxNavDrawerMiniTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDrawerMini]'
                },] }
    ];
    IgxNavDrawerMiniTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };

    var NEXT_ID$p = 0;
    /**
     * **Ignite UI for Angular Navigation Drawer** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer)
     *
     * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
     *
     * Example:
     * ```html
     * <igx-nav-drawer id="navigation" [isOpen]="true">
     *   <ng-template igxDrawer>
     *     <nav>
     *       <span igxDrawerItem [isHeader]="true">Email</span>
     *       <span igxDrawerItem igxRipple>Inbox</span>
     *       <span igxDrawerItem igxRipple>Deleted</span>
     *       <span igxDrawerItem igxRipple>Sent</span>
     *     </nav>
     *   </ng-template>
     * </igx-nav-drawer>
     * ```
     */
    var IgxNavigationDrawerComponent = /** @class */ (function () {
        function IgxNavigationDrawerComponent(elementRef, _state, renderer, _touchManager, platformUtil) {
            var _this = this;
            this.elementRef = elementRef;
            this._state = _state;
            this.renderer = renderer;
            this._touchManager = _touchManager;
            this.platformUtil = platformUtil;
            /** @hidden @internal */
            this.cssClass = true;
            /**
             * ID of the component
             *
             * ```typescript
             * // get
             * let myNavDrawerId = this.navdrawer.id;
             * ```
             *
             * ```html
             * <!--set-->
             *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
             * ```
             */
            this.id = "igx-nav-drawer-" + NEXT_ID$p++;
            /**
             * Position of the Navigation Drawer. Can be "left"(default) or "right".
             *
             * ```typescript
             * // get
             * let myNavDrawerPosition = this.navdrawer.position;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
             * ```
             */
            this.position = 'left';
            /**
             * Enables the use of touch gestures to manipulate the drawer:
             * - swipe/pan from edge to open, swipe-toggle and pan-drag.
             *
             * ```typescript
             * // get
             * let gesturesEnabled = this.navdrawer.enableGestures;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
             * ```
             */
            this.enableGestures = true;
            /**
             * @hidden
             */
            this.isOpenChange = new i0.EventEmitter();
            /**
             * Minimum device width required for automatic pin to be toggled.
             * Default is 1024, can be set to a falsy value to disable this behavior.
             *
             * ```typescript
             * // get
             * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
             * ```
             */
            this.pinThreshold = 1024;
            /**
             * When pinned the drawer is relatively positioned instead of sitting above content.
             * May require additional layout styling.
             *
             * ```typescript
             * // get
             * let navDrawerIsPinned = this.navdrawer.pin;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
             * ```
             */
            this.pin = false;
            /**
             * Width of the drawer in its open state. Defaults to "280px".
             *
             * ```typescript
             * // get
             * let navDrawerWidth = this.navdrawer.width;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
             * ```
             */
            this.width = '280px';
            /**
             * Enables/disables the animation, when toggling the drawer. Set to `false` by default.
             * ````html
             * <igx-nav-drawer [disableAnimation]="true"></igx-nav-drawer>
             * ````
             */
            this.disableAnimation = false;
            /**
             * Width of the drawer in its mini state. Defaults to 68px.
             *
             * ```typescript
             * // get
             * let navDrawerMiniWidth = this.navdrawer.miniWidth;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
             * ```
             */
            this.miniWidth = '68px';
            /**
             * Pinned state change output for two-way binding.
             *
             * ```html
             * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
             * ```
             */
            this.pinChange = new i0.EventEmitter(true);
            /**
             * Event fired as the Navigation Drawer is about to open.
             *
             * ```html
             *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
             * ```
             */
            this.opening = new i0.EventEmitter();
            /**
             * Event fired when the Navigation Drawer has opened.
             *
             * ```html
             * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
             * ```
             */
            this.opened = new i0.EventEmitter();
            /**
             * Event fired as the Navigation Drawer is about to close.
             *
             * ```html
             * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
             * ```
             */
            this.closing = new i0.EventEmitter();
            /**
             * Event fired when the Navigation Drawer has closed.
             *
             * ```html
             * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
             * ```
             */
            this.closed = new i0.EventEmitter();
            this._isOpen = false;
            this._gesturesAttached = false;
            this._widthCache = { width: null, miniWidth: null, windowWidth: null };
            this.css = {
                drawer: 'igx-nav-drawer__aside',
                mini: 'igx-nav-drawer__aside--mini',
                overlay: 'igx-nav-drawer__overlay',
                styleDummy: 'igx-nav-drawer__style-dummy'
            };
            /** Pan animation properties */
            this._panning = false;
            this._maxEdgeZone = 50;
            this.checkPinThreshold = function (evt) {
                if (!_this.platformUtil.isBrowser) {
                    return;
                }
                var windowWidth;
                if (_this.pinThreshold) {
                    windowWidth = _this.getWindowWidth();
                    if (evt && _this._widthCache.windowWidth === windowWidth) {
                        return;
                    }
                    _this._widthCache.windowWidth = windowWidth;
                    if (!_this.pin && windowWidth >= _this.pinThreshold) {
                        _this.pin = true;
                        _this.pinChange.emit(true);
                    }
                    else if (_this.pin && windowWidth < _this.pinThreshold) {
                        _this.pin = false;
                        _this.pinChange.emit(false);
                    }
                }
            };
            this.swipe = function (evt) {
                // TODO: Could also force input type: http://stackoverflow.com/a/27108052
                if (!_this.enableGestures || evt.pointerType !== 'touch') {
                    return;
                }
                // HammerJS swipe is horizontal-only by default, don't check deltaY
                var deltaX;
                var startPosition;
                if (_this.position === 'right') {
                    // when on the right use inverse of deltaX
                    deltaX = -evt.deltaX;
                    startPosition = _this.getWindowWidth() - (evt.center.x + evt.distance);
                }
                else {
                    deltaX = evt.deltaX;
                    startPosition = evt.center.x - evt.distance;
                }
                // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
                if ((_this.isOpen && deltaX < 0) ||
                    // positive deltaX from the edge:
                    (deltaX > 0 && startPosition < _this.maxEdgeZone)) {
                    _this.toggle();
                }
            };
            this.panstart = function (evt) {
                if (!_this.enableGestures || _this.pin || evt.pointerType !== 'touch') {
                    return;
                }
                var startPosition = _this.position === 'right' ? _this.getWindowWidth() - (evt.center.x + evt.distance)
                    : evt.center.x - evt.distance;
                // cache width during animation, flag to allow further handling
                if (_this.isOpen || (startPosition < _this.maxEdgeZone)) {
                    _this._panning = true;
                    _this._panStartWidth = _this.getExpectedWidth(!_this.isOpen);
                    _this._panLimit = _this.getExpectedWidth(_this.isOpen);
                    _this.renderer.addClass(_this.overlay, 'panning');
                    _this.renderer.addClass(_this.drawer, 'panning');
                }
            };
            this.pan = function (evt) {
                // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
                // get actual delta (not total session one) from event?
                // pan WILL also fire after a full swipe, only resize on flag
                if (!_this._panning) {
                    return;
                }
                var right = _this.position === 'right';
                // when on the right use inverse of deltaX
                var deltaX = right ? -evt.deltaX : evt.deltaX;
                var newX;
                var percent;
                var visibleWidth = _this._panStartWidth + deltaX;
                if (_this.isOpen && deltaX < 0) {
                    // when visibleWidth hits limit - stop animating
                    if (visibleWidth <= _this._panLimit) {
                        return;
                    }
                    if (_this.hasAnimateWidth) {
                        percent = (visibleWidth - _this._panLimit) / (_this._panStartWidth - _this._panLimit);
                        newX = visibleWidth;
                    }
                    else {
                        percent = visibleWidth / _this._panStartWidth;
                        newX = evt.deltaX;
                    }
                    _this.setXSize(newX, percent.toPrecision(2));
                }
                else if (!_this.isOpen && deltaX > 0) {
                    // when visibleWidth hits limit - stop animating
                    if (visibleWidth >= _this._panLimit) {
                        return;
                    }
                    if (_this.hasAnimateWidth) {
                        percent = (visibleWidth - _this._panStartWidth) / (_this._panLimit - _this._panStartWidth);
                        newX = visibleWidth;
                    }
                    else {
                        percent = visibleWidth / _this._panLimit;
                        newX = (_this._panLimit - visibleWidth) * (right ? 1 : -1);
                    }
                    _this.setXSize(newX, percent.toPrecision(2));
                }
            };
            this.panEnd = function (evt) {
                if (_this._panning) {
                    var deltaX = _this.position === 'right' ? -evt.deltaX : evt.deltaX;
                    var visibleWidth = _this._panStartWidth + deltaX;
                    _this.resetPan();
                    // check if pan brought the drawer to 50%
                    if (_this.isOpen && visibleWidth <= _this._panStartWidth / 2) {
                        _this.close();
                    }
                    else if (!_this.isOpen && visibleWidth >= _this._panLimit / 2) {
                        _this.open();
                    }
                    _this._panStartWidth = null;
                }
            };
            this.toggleOpenedEvent = function (evt) {
                _this.elementRef.nativeElement.removeEventListener('transitionend', _this.toggleOpenedEvent, false);
                _this.opened.emit();
            };
            this.toggleClosedEvent = function (evt) {
                _this.elementRef.nativeElement.removeEventListener('transitionend', _this.toggleClosedEvent, false);
                _this.closed.emit();
            };
        }
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "isOpen", {
            /**
             * State of the drawer.
             *
             * ```typescript
             * // get
             * let navDrawerIsOpen = this.navdrawer.isOpen;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
             * ```
             *
             * Two-way data binding.
             * ```html
             * <!--set-->
             * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>
             * ```
             */
            get: function () {
                return this._isOpen;
            },
            set: function (value) {
                this._isOpen = value;
                this.isOpenChange.emit(this._isOpen);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "element", {
            /**
             * Returns nativeElement of the component.
             *
             * @hidden
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "template", {
            /**
             * @hidden
             */
            get: function () {
                if (this.miniTemplate && !this.isOpen) {
                    return this.miniTemplate.template;
                }
                else if (this.contentTemplate) {
                    return this.contentTemplate.template;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "miniTemplate", {
            /**
             * @hidden
             */
            get: function () {
                return this._miniTemplate;
            },
            /**
             * @hidden
             */
            set: function (v) {
                if (!this.isOpen) {
                    this.setDrawerWidth(v ? this.miniWidth : '');
                }
                this._miniTemplate = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "flexWidth", {
            /**
             * @hidden
             */
            get: function () {
                if (!this.pin) {
                    return '0px';
                }
                if (this.isOpen) {
                    return this.width;
                }
                if (this.miniTemplate && this.miniWidth) {
                    return this.miniWidth;
                }
                return '0px';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "isPinnedRight", {
            /** @hidden */
            get: function () {
                return this.pin && this.position === 'right' ? '1' : '0';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "drawer", {
            /**
             * @hidden
             */
            get: function () {
                return this._drawer.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "overlay", {
            /**
             * @hidden
             */
            get: function () {
                return this._overlay.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "styleDummy", {
            /**
             * @hidden
             */
            get: function () {
                return this._styleDummy.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "hasAnimateWidth", {
            /**
             * Property to decide whether to change width or translate the drawer from pan gesture.
             *
             * @hidden
             */
            get: function () {
                return this.pin || !!this.miniTemplate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "maxEdgeZone", {
            /**
             * Used for touch gestures (swipe and pan).
             * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
             *
             * @hidden
             */
            get: function () {
                return this._maxEdgeZone;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "expectedWidth", {
            /**
             * Gets the Drawer width for specific state.
             * Will attempt to evaluate requested state and cache.
             *
             *
             * @hidden
             */
            get: function () {
                return this.getExpectedWidth(false);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "expectedMiniWidth", {
            /**
             * Get the Drawer mini width for specific state.
             * Will attempt to evaluate requested state and cache.
             *
             * @hidden
             */
            get: function () {
                return this.getExpectedWidth(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "touchManager", {
            /**
             * @hidden
             */
            get: function () {
                return this._touchManager;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "state", {
            /**
             * Exposes optional navigation service
             *
             * @hidden
             */
            get: function () {
                return this._state;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxNavigationDrawerComponent.prototype.ngOnInit = function () {
            // DOM and @Input()-s initialized
            if (this._state) {
                this._state.add(this.id, this);
            }
            if (this.isOpen) {
                this.setDrawerWidth(this.width);
            }
        };
        /**
         * @hidden
         */
        IgxNavigationDrawerComponent.prototype.ngAfterContentInit = function () {
            // wait for template and ng-content to be ready
            this.updateEdgeZone();
            this.checkPinThreshold();
            this.ensureEvents();
            // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
            // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
        };
        /**
         * @hidden
         */
        IgxNavigationDrawerComponent.prototype.ngOnDestroy = function () {
            this._touchManager.destroy();
            if (this._state) {
                this._state.remove(this.id);
            }
            if (this._resizeObserver) {
                this._resizeObserver.unsubscribe();
            }
        };
        /**
         * @hidden
         */
        IgxNavigationDrawerComponent.prototype.ngOnChanges = function (changes) {
            // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
            if (changes.enableGestures && changes.enableGestures.currentValue !== undefined) {
                this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
                this.ensureEvents();
            }
            if (changes.pin && changes.pin.currentValue !== undefined) {
                this.pin = !!(this.pin && this.pin.toString() === 'true');
                if (this.pin) {
                    this._touchManager.destroy();
                    this._gesturesAttached = false;
                }
                else {
                    this.ensureEvents();
                }
            }
            if (changes.pinThreshold) {
                if (this.pinThreshold) {
                    this.ensureEvents();
                    this.checkPinThreshold();
                }
            }
            if (changes.width && this.isOpen) {
                this.setDrawerWidth(changes.width.currentValue);
            }
            if (changes.isOpen) {
                this.setDrawerWidth(this.isOpen ? this.width : (this.miniTemplate ? this.miniWidth : ''));
            }
            if (changes.miniWidth) {
                if (!this.isOpen) {
                    this.setDrawerWidth(changes.miniWidth.currentValue);
                }
                this.updateEdgeZone();
            }
        };
        /**
         * Toggle the open state of the Navigation Drawer.
         *
         * ```typescript
         * this.navdrawer.toggle();
         * ```
         */
        IgxNavigationDrawerComponent.prototype.toggle = function () {
            if (this.isOpen) {
                this.close();
            }
            else {
                this.open();
            }
        };
        /**
         * Open the Navigation Drawer. Has no effect if already opened.
         *
         * ```typescript
         * this.navdrawer.open();
         * ```
         */
        IgxNavigationDrawerComponent.prototype.open = function () {
            if (this._panning) {
                this.resetPan();
            }
            if (this.isOpen) {
                return;
            }
            this.opening.emit();
            this.isOpen = true;
            // TODO: Switch to animate API when available
            // var animationCss = this.animate.css();
            //     animationCss
            //         .setStyles({'width':'50px'}, {'width':'400px'})
            //         .start(this.elementRef.nativeElement)
            //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
            this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
            this.setDrawerWidth(this.width);
        };
        /**
         * Close the Navigation Drawer. Has no effect if already closed.
         *
         * ```typescript
         * this.navdrawer.close();
         * ```
         */
        IgxNavigationDrawerComponent.prototype.close = function () {
            if (this._panning) {
                this.resetPan();
            }
            if (!this.isOpen) {
                return;
            }
            this.closing.emit();
            this.isOpen = false;
            this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
            this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
        };
        /**
         * @hidden
         */
        IgxNavigationDrawerComponent.prototype.set_maxEdgeZone = function (value) {
            this._maxEdgeZone = value;
        };
        /**
         * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
         *
         * @hidden
         * @param [mini] - Request mini width instead
         */
        IgxNavigationDrawerComponent.prototype.getExpectedWidth = function (mini) {
            if (mini) {
                if (!this.miniTemplate) {
                    return 0;
                }
                if (this.miniWidth) {
                    return parseFloat(this.miniWidth);
                }
                else {
                    // if (!this.isOpen) { // This WON'T work due to transition timings...
                    //     return this.elementRef.nativeElement.children[1].offsetWidth;
                    // } else {
                    if (this._widthCache.miniWidth === null) {
                        // force class for width calc. TODO?
                        // force class for width calc. TODO?
                        this.renderer.addClass(this.styleDummy, this.css.drawer);
                        this.renderer.addClass(this.styleDummy, this.css.mini);
                        this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                        this.renderer.removeClass(this.styleDummy, this.css.drawer);
                        this.renderer.removeClass(this.styleDummy, this.css.mini);
                    }
                    return this._widthCache.miniWidth;
                }
            }
            else {
                if (this.width) {
                    return parseFloat(this.width);
                }
                else {
                    if (this._widthCache.width === null) {
                        // force class for width calc. TODO?
                        // force class for width calc. TODO?
                        this.renderer.addClass(this.styleDummy, this.css.drawer);
                        this._widthCache.width = this.styleDummy.offsetWidth;
                        this.renderer.removeClass(this.styleDummy, this.css.drawer);
                    }
                    return this._widthCache.width;
                }
            }
        };
        IgxNavigationDrawerComponent.prototype.getWindowWidth = function () {
            return (window.innerWidth > 0) ? window.innerWidth : screen.width;
        };
        /**
         * Sets the drawer width.
         */
        IgxNavigationDrawerComponent.prototype.setDrawerWidth = function (width) {
            var _this = this;
            if (this.platformUtil.isBrowser) {
                requestAnimationFrame(function () {
                    if (_this.drawer) {
                        _this.renderer.setStyle(_this.drawer, 'width', width);
                    }
                });
            }
            else {
                this.renderer.setStyle(this.drawer, 'width', width);
            }
        };
        /**
         * Get current Drawer width.
         */
        IgxNavigationDrawerComponent.prototype.getDrawerWidth = function () {
            return this.drawer.offsetWidth;
        };
        IgxNavigationDrawerComponent.prototype.ensureEvents = function () {
            var _this = this;
            // set listeners for swipe/pan only if needed, but just once
            if (this.enableGestures && !this.pin && !this._gesturesAttached) {
                // Built-in manager handler(L20887) causes endless loop and max stack exception.
                // https://github.com/angular/angular/issues/6993
                // Use ours for now (until beta.10):
                // this.renderer.listen(document, "swipe", this.swipe);
                this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);
                this._gesturesAttached = true;
                // this.renderer.listen(document, "panstart", this.panstart);
                // this.renderer.listen(document, "pan", this.pan);
                this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);
                this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);
                this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
            }
            if (!this._resizeObserver && this.platformUtil.isBrowser) {
                this._resizeObserver = rxjs.fromEvent(window, 'resize').pipe(operators.debounce(function () { return rxjs.interval(150); }))
                    .subscribe(function (value) {
                    _this.checkPinThreshold(value);
                });
            }
        };
        IgxNavigationDrawerComponent.prototype.updateEdgeZone = function () {
            var maxValue;
            if (this.miniTemplate) {
                maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
                this.set_maxEdgeZone(maxValue);
            }
        };
        IgxNavigationDrawerComponent.prototype.resetPan = function () {
            this._panning = false;
            /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
            /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
            this.renderer.removeClass(this.overlay, 'panning');
            this.renderer.removeClass(this.drawer, 'panning');
            this.setXSize(0, '');
        };
        /**
         * Sets the absolute position or width in case the drawer doesn't change position.
         *
         * @param x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
         * @param opacity optional value to apply to the overlay
         */
        IgxNavigationDrawerComponent.prototype.setXSize = function (x, opacity) {
            var _this = this;
            // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
            window.requestAnimationFrame(function () {
                if (_this.hasAnimateWidth) {
                    _this.renderer.setStyle(_this.drawer, 'width', x ? Math.abs(x) + 'px' : '');
                }
                else {
                    _this.renderer.setStyle(_this.drawer, 'transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
                    _this.renderer.setStyle(_this.drawer, '-webkit-transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
                }
                if (opacity !== undefined) {
                    _this.renderer.setStyle(_this.overlay, 'opacity', opacity);
                }
            });
        };
        return IgxNavigationDrawerComponent;
    }());
    IgxNavigationDrawerComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [HammerGesturesManager],
                    selector: 'igx-nav-drawer',
                    template: "<ng-template #defaultItemsTemplate>\n    <div igxDrawerItem [isHeader]=\"true\">Navigation Drawer</div>\n    <div igxDrawerItem> Start by adding</div>\n    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>\n    <div igxDrawerItem> And some items inside </div>\n    <div igxDrawerItem> Style with igxDrawerItem </div>\n    <div igxDrawerItem> and igxRipple directives</div>\n</ng-template>\n\n<div [hidden]=\"pin\"\n    class=\"igx-nav-drawer__overlay\"\n    [class.igx-nav-drawer__overlay--hidden]=\"!isOpen\"\n    [class.igx-nav-drawer--disable-animation]=\"disableAnimation\"\n    (click)=\"close()\" #overlay>\n</div>\n<aside role=\"navigation\"\n    class=\"igx-nav-drawer__aside\"\n    [class.igx-nav-drawer__aside--collapsed]=\"!miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--mini]=\"miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--normal]=\"!miniTemplate || isOpen\"\n    [class.igx-nav-drawer__aside--pinned]=\"pin\"\n    [class.igx-nav-drawer__aside--right]=\"position == 'right'\" #aside\n    [class.igx-nav-drawer--disable-animation]=\"disableAnimation\">\n\n    <ng-container *ngTemplateOutlet=\"template || defaultItemsTemplate\"></ng-container>\n</aside>\n<div class=\"igx-nav-drawer__style-dummy\" #dummy></div>\n",
                    styles: ["\n        :host {\n            display: block;\n            height: 100%;\n        }\n    "]
                },] }
    ];
    IgxNavigationDrawerComponent.ctorParameters = function () { return [
        { type: i0.ElementRef, decorators: [{ type: i0.Inject, args: [i0.ElementRef,] }] },
        { type: IgxNavigationService, decorators: [{ type: i0.Optional }] },
        { type: i0.Renderer2 },
        { type: HammerGesturesManager },
        { type: PlatformUtil }
    ]; };
    IgxNavigationDrawerComponent.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-nav-drawer',] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        position: [{ type: i0.Input }],
        enableGestures: [{ type: i0.Input }],
        isOpenChange: [{ type: i0.Output }],
        pinThreshold: [{ type: i0.Input }],
        pin: [{ type: i0.Input }],
        width: [{ type: i0.Input }],
        disableAnimation: [{ type: i0.HostBinding, args: ['class.igx-nav-drawer--disable-animation',] }, { type: i0.Input }],
        miniWidth: [{ type: i0.Input }],
        pinChange: [{ type: i0.Output }],
        opening: [{ type: i0.Output }],
        opened: [{ type: i0.Output }],
        closing: [{ type: i0.Output }],
        closed: [{ type: i0.Output }],
        contentTemplate: [{ type: i0.ContentChild, args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective },] }],
        _drawer: [{ type: i0.ViewChild, args: ['aside', { static: true },] }],
        _overlay: [{ type: i0.ViewChild, args: ['overlay', { static: true },] }],
        _styleDummy: [{ type: i0.ViewChild, args: ['dummy', { static: true },] }],
        isOpen: [{ type: i0.Input }],
        miniTemplate: [{ type: i0.ContentChild, args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective },] }],
        flexWidth: [{ type: i0.HostBinding, args: ['style.flexBasis',] }],
        isPinnedRight: [{ type: i0.HostBinding, args: ['style.order',] }]
    };

    /**
     * @hidden
     */
    var IgxNavigationDrawerModule = /** @class */ (function () {
        function IgxNavigationDrawerModule() {
        }
        return IgxNavigationDrawerModule;
    }());
    IgxNavigationDrawerModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxNavigationDrawerComponent,
                        IgxNavDrawerItemDirective,
                        IgxNavDrawerMiniTemplateDirective,
                        IgxNavDrawerTemplateDirective
                    ],
                    exports: [
                        IgxNavigationDrawerComponent,
                        IgxNavDrawerItemDirective,
                        IgxNavDrawerMiniTemplateDirective,
                        IgxNavDrawerTemplateDirective
                    ],
                    imports: [i2.CommonModule]
                },] }
    ];

    /**
     * Template directive that allows you to set a custom template representing the lower label value of the {@link IgxSliderComponent}
     *
     * ```html
     * <igx-slider>
     *  <ng-template igxSliderThumbFrom let-value let-labels>{{value}}</ng-template>
     * </igx-slider>
     * ```
     *
     * @context {@link IgxSliderComponent.context}
     */
    var IgxThumbFromTemplateDirective = /** @class */ (function () {
        function IgxThumbFromTemplateDirective() {
        }
        return IgxThumbFromTemplateDirective;
    }());
    IgxThumbFromTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxSliderThumbFrom]'
                },] }
    ];
    /**
     * Template directive that allows you to set a custom template representing the upper label value of the {@link IgxSliderComponent}
     *
     * ```html
     * <igx-slider>
     *  <ng-template igxSliderThumbTo let-value let-labels>{{value}}</ng-template>
     * </igx-slider>
     * ```
     *
     * @context {@link IgxSliderComponent.context}
     */
    var IgxThumbToTemplateDirective = /** @class */ (function () {
        function IgxThumbToTemplateDirective() {
        }
        return IgxThumbToTemplateDirective;
    }());
    IgxThumbToTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxSliderThumbTo]'
                },] }
    ];
    /**
     * Template directive that allows you to set a custom template, represeting primary/secondary tick labels of the {@link IgxSliderComponent}
     *
     * @context {@link IgxTicksComponent.context}
     */
    var IgxTickLabelTemplateDirective = /** @class */ (function () {
        function IgxTickLabelTemplateDirective() {
        }
        return IgxTickLabelTemplateDirective;
    }());
    IgxTickLabelTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxSliderTickLabel]'
                },] }
    ];
    var IgxSliderType = mkenum({
        /**
         * Slider with single thumb.
         */
        SLIDER: 'slider',
        /**
         *  Range slider with multiple thumbs, that can mark the range.
         */
        RANGE: 'range'
    });
    var SliderHandle = mkenum({
        FROM: 'from',
        TO: 'to'
    });
    /**
     * Slider Tick labels Orientation
     */
    var TickLabelsOrientation = mkenum({
        Horizontal: 'horizontal',
        TopToBottom: 'toptobottom',
        BottomToTop: 'bottomtotop'
    });
    /**
     * Slider Ticks orientation
     */
    var TicksOrientation = mkenum({
        Top: 'top',
        Bottom: 'bottom',
        Mirror: 'mirror'
    });

    /**
     * @hidden
     */
    var IgxSliderThumbComponent = /** @class */ (function () {
        function IgxSliderThumbComponent(_elementRef, _dir) {
            this._elementRef = _elementRef;
            this._dir = _dir;
            this.onThumbValueChange = new i0.EventEmitter();
            this.onChange = new i0.EventEmitter();
            this.onHoverChange = new i0.EventEmitter();
            this.tabindex = 0;
            this.zIndex = 0;
            this.isActive = false;
            this._isActive = false;
            this._isPressed = false;
            this._destroy$ = new rxjs.Subject();
        }
        Object.defineProperty(IgxSliderThumbComponent.prototype, "thumbFromClass", {
            get: function () {
                return this.type === SliderHandle.FROM;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "thumbToClass", {
            get: function () {
                return this.type === SliderHandle.TO;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "thumbFromActiveClass", {
            get: function () {
                return this.type === SliderHandle.FROM && this._isActive;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "thumbToActiveClass", {
            get: function () {
                return this.type === SliderHandle.TO && this._isActive;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "thumbPressedClass", {
            get: function () {
                return this.isActive && this._isPressed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "nativeElement", {
            get: function () {
                return this._elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "destroy", {
            get: function () {
                return this._destroy$;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "thumbPositionX", {
            get: function () {
                var thumbBounderies = this.nativeElement.getBoundingClientRect();
                var thumbCenter = (thumbBounderies.right - thumbBounderies.left) / 2;
                return thumbBounderies.left + thumbCenter;
            },
            enumerable: false,
            configurable: true
        });
        IgxSliderThumbComponent.prototype.onPinterEnter = function () {
            this.onHoverChange.emit(true);
        };
        IgxSliderThumbComponent.prototype.onPointerLeave = function () {
            this.onHoverChange.emit(false);
        };
        IgxSliderThumbComponent.prototype.onKeyDown = function (event) {
            if (this.disabled) {
                return;
            }
            var increment = 0;
            if (event.key.endsWith('Left')) {
                increment = this.step * -1;
            }
            else if (event.key.endsWith('Right')) {
                increment = this.step;
            }
            else {
                return;
            }
            this.onChange.emit();
            this.onThumbValueChange.emit(increment);
        };
        IgxSliderThumbComponent.prototype.onBlur = function () {
            this.isActive = false;
            this.zIndex = 0;
        };
        IgxSliderThumbComponent.prototype.onFocusListener = function () {
            this.isActive = true;
            this.zIndex = 1;
        };
        /**
         * @hidden
         */
        IgxSliderThumbComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.onPan
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function (mouseX) { return _this.updateThumbValue(mouseX); });
        };
        /**
         * @hidden
         */
        IgxSliderThumbComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next(true);
            this._destroy$.complete();
        };
        /**
         * Show thumb label and ripple.
         */
        IgxSliderThumbComponent.prototype.showThumbIndicators = function () {
            this.toggleThumbIndicators(true);
        };
        /**
         * Hide thumb label and ripple.
         */
        IgxSliderThumbComponent.prototype.hideThumbIndicators = function () {
            this.toggleThumbIndicators(false);
        };
        IgxSliderThumbComponent.prototype.updateThumbValue = function (mouseX) {
            var updateValue = this.calculateTrackUpdate(mouseX);
            if (this.isActive && updateValue !== 0) {
                this.onThumbValueChange.emit(updateValue);
            }
        };
        IgxSliderThumbComponent.prototype.calculateTrackUpdate = function (mouseX) {
            var scaleX = this._dir.rtl ? this.thumbPositionX - mouseX : mouseX - this.thumbPositionX;
            var stepDistanceCenter = this.stepDistance / 2;
            // If the thumb scale range (slider update) is less thàn a half step,
            // the position stays the same.
            var scaleXPositive = Math.abs(scaleX);
            if (scaleXPositive < stepDistanceCenter) {
                return 0;
            }
            return this.stepToProceed(scaleX, this.stepDistance);
        };
        IgxSliderThumbComponent.prototype.stepToProceed = function (scaleX, stepDist) {
            return Math.round(scaleX / stepDist) * this.step;
        };
        IgxSliderThumbComponent.prototype.toggleThumbIndicators = function (visible) {
            this._isPressed = visible;
            if (this.continuous || this.deactiveState) {
                this._isActive = false;
            }
            else {
                this._isActive = visible;
            }
        };
        return IgxSliderThumbComponent;
    }());
    IgxSliderThumbComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-thumb',
                    template: "<div class=\"dot\"></div>\n"
                },] }
    ];
    IgxSliderThumbComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: IgxDirectionality }
    ]; };
    IgxSliderThumbComponent.propDecorators = {
        value: [{ type: i0.Input }],
        continuous: [{ type: i0.Input }],
        thumbLabelVisibilityDuration: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        onPan: [{ type: i0.Input }],
        stepDistance: [{ type: i0.Input }],
        step: [{ type: i0.Input }],
        templateRef: [{ type: i0.Input }],
        context: [{ type: i0.Input }],
        type: [{ type: i0.Input }],
        deactiveState: [{ type: i0.Input }],
        onThumbValueChange: [{ type: i0.Output }],
        onChange: [{ type: i0.Output }],
        onHoverChange: [{ type: i0.Output }],
        tabindex: [{ type: i0.HostBinding, args: ['attr.tabindex',] }],
        zIndex: [{ type: i0.HostBinding, args: ['attr.z-index',] }],
        thumbFromClass: [{ type: i0.HostBinding, args: ['class.igx-slider__thumb-from',] }],
        thumbToClass: [{ type: i0.HostBinding, args: ['class.igx-slider__thumb-to',] }],
        thumbFromActiveClass: [{ type: i0.HostBinding, args: ['class.igx-slider__thumb-from--active',] }],
        thumbToActiveClass: [{ type: i0.HostBinding, args: ['class.igx-slider__thumb-to--active',] }],
        thumbPressedClass: [{ type: i0.HostBinding, args: ['class.igx-slider__thumb--pressed',] }],
        onPinterEnter: [{ type: i0.HostListener, args: ['pointerenter',] }],
        onPointerLeave: [{ type: i0.HostListener, args: ['pointerleave',] }],
        onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }],
        onBlur: [{ type: i0.HostListener, args: ['blur',] }],
        onFocusListener: [{ type: i0.HostListener, args: ['focus',] }]
    };

    /**
     * @hidden
     */
    var IgxThumbLabelComponent = /** @class */ (function () {
        function IgxThumbLabelComponent(_elementRef) {
            this._elementRef = _elementRef;
        }
        Object.defineProperty(IgxThumbLabelComponent.prototype, "thumbFromClass", {
            get: function () {
                return this.type === SliderHandle.FROM;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxThumbLabelComponent.prototype, "thumbToClass", {
            get: function () {
                return this.type === SliderHandle.TO;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxThumbLabelComponent.prototype, "thumbFromActiveClass", {
            get: function () {
                return this.type === SliderHandle.FROM && this.active;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxThumbLabelComponent.prototype, "thumbToActiveClass", {
            get: function () {
                return this.type === SliderHandle.TO && this.active;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxThumbLabelComponent.prototype, "labelPressedClass", {
            get: function () {
                var _a;
                return (_a = this.thumb) === null || _a === void 0 ? void 0 : _a.thumbPressedClass;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxThumbLabelComponent.prototype, "nativeElement", {
            get: function () {
                return this._elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxThumbLabelComponent.prototype, "active", {
            get: function () {
                return this._active;
            },
            set: function (val) {
                if (this.continuous || this.deactiveState) {
                    this._active = false;
                }
                else {
                    this._active = val;
                }
            },
            enumerable: false,
            configurable: true
        });
        return IgxThumbLabelComponent;
    }());
    IgxThumbLabelComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-thumb-label',
                    template: "<div class=\"label\">\n    <ng-container *ngTemplateOutlet=\"templateRef ? templateRef : thumbFromDefaultTemplate; context: context\"></ng-container>\n</div>\n\n<ng-template #thumbFromDefaultTemplate>\n    {{ value }}\n</ng-template>\n"
                },] }
    ];
    IgxThumbLabelComponent.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxThumbLabelComponent.propDecorators = {
        value: [{ type: i0.Input }],
        templateRef: [{ type: i0.Input }],
        context: [{ type: i0.Input }],
        type: [{ type: i0.Input }],
        continuous: [{ type: i0.Input }],
        deactiveState: [{ type: i0.Input }],
        thumb: [{ type: i0.Input }],
        thumbFromClass: [{ type: i0.HostBinding, args: ['class.igx-slider__label-from',] }],
        thumbToClass: [{ type: i0.HostBinding, args: ['class.igx-slider__label-to',] }],
        thumbFromActiveClass: [{ type: i0.HostBinding, args: ['class.igx-slider__label-from--active',] }],
        thumbToActiveClass: [{ type: i0.HostBinding, args: ['class.igx-slider__label-to--active',] }],
        labelPressedClass: [{ type: i0.HostBinding, args: ['class.igx-slider__label--pressed',] }]
    };

    /**
     * @hidden
     */
    var IgxTicksComponent = /** @class */ (function () {
        function IgxTicksComponent() {
            /**
             * @hidden
             */
            this.ticksClass = true;
        }
        Object.defineProperty(IgxTicksComponent.prototype, "ticksTopClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.ticksOrientation === TicksOrientation.Top;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTicksComponent.prototype, "hasPrimaryClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.primaryTicks > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTicksComponent.prototype, "labelsTopToBottomClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.tickLabelsOrientation === TickLabelsOrientation.TopToBottom;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTicksComponent.prototype, "labelsBottomToTopClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.tickLabelsOrientation === TickLabelsOrientation.BottomToTop;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns the template context corresponding to
         * {@link IgxTickLabelTemplateDirective}
         *
         * ```typescript
         * return {
         *  $implicit //returns the value per each tick label.
         *  isPrimery //returns if the tick is primary.
         *  labels // returns the {@link labels} collection.
         *  index // returns the index per each tick of the whole sequence.
         * }
         * ```
         *
         * @param idx the index per each tick label.
         */
        IgxTicksComponent.prototype.context = function (idx) {
            return {
                $implicit: this.tickLabel(idx),
                isPrimary: this.isPrimary(idx),
                labels: this.labels,
                index: idx
            };
        };
        Object.defineProperty(IgxTicksComponent.prototype, "ticksLength", {
            /**
             * @hidden
             */
            get: function () {
                return this.primaryTicks > 0 ?
                    ((this.primaryTicks - 1) * this.secondaryTicks) + this.primaryTicks :
                    this.secondaryTicks > 0 ? this.secondaryTicks : 0;
            },
            enumerable: false,
            configurable: true
        });
        IgxTicksComponent.prototype.hiddenTickLabels = function (idx) {
            return this.isPrimary(idx) ? this.primaryTickLabels : this.secondaryTickLabels;
        };
        /**
         * @hidden
         */
        IgxTicksComponent.prototype.isPrimary = function (idx) {
            return this.primaryTicks <= 0 ? false :
                idx % (this.secondaryTicks + 1) === 0;
        };
        /**
         * @hidden
         */
        IgxTicksComponent.prototype.tickLabel = function (idx) {
            if (this.labelsViewEnabled) {
                return this.labels[idx];
            }
            var labelStep = (Math.max(this.minValue, this.maxValue) - Math.min(this.minValue, this.maxValue)) / (this.ticksLength - 1);
            var labelVal = labelStep * idx;
            return (this.minValue + labelVal).toFixed(2);
        };
        return IgxTicksComponent;
    }());
    IgxTicksComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-ticks',
                    template: "<div class=\"igx-slider__ticks-group\" *ngFor=\"let n of [].constructor(ticksLength); let idx=index\" [ngClass]=\"{ 'igx-slider__ticks-group--tall': isPrimary(idx)}\">\n    <div class=\"igx-slider__ticks-tick\">\n        <span class=\"igx-slider__ticks-label\" [ngClass]=\"{ 'igx-slider__tick-label--hidden': !hiddenTickLabels(idx)}\">\n            <ng-container *ngTemplateOutlet=\"tickLabelTemplateRef ? tickLabelTemplateRef : tickLabelDefaultTemplate; context: context(idx)\"></ng-container>\n        </span>\n    </div>\n</div>\n\n<ng-template #tickLabelDefaultTemplate let-value>\n    {{ value }}\n</ng-template>\n"
                },] }
    ];
    IgxTicksComponent.propDecorators = {
        primaryTicks: [{ type: i0.Input }],
        secondaryTicks: [{ type: i0.Input }],
        primaryTickLabels: [{ type: i0.Input }],
        secondaryTickLabels: [{ type: i0.Input }],
        ticksOrientation: [{ type: i0.Input }],
        tickLabelsOrientation: [{ type: i0.Input }],
        maxValue: [{ type: i0.Input }],
        minValue: [{ type: i0.Input }],
        labelsViewEnabled: [{ type: i0.Input }],
        labels: [{ type: i0.Input }],
        tickLabelTemplateRef: [{ type: i0.Input }],
        ticksClass: [{ type: i0.HostBinding, args: ['class.igx-slider__ticks',] }],
        ticksTopClass: [{ type: i0.HostBinding, args: ['class.igx-slider__ticks--top',] }],
        hasPrimaryClass: [{ type: i0.HostBinding, args: ['class.igx-slider__ticks--tall',] }],
        labelsTopToBottomClass: [{ type: i0.HostBinding, args: ['class.igx-slider__tick-labels--top-bottom',] }],
        labelsBottomToTopClass: [{ type: i0.HostBinding, args: ['class.igx-slider__tick-labels--bottom-top',] }]
    };

    /**
     * @hidden
     */
    var IgxTickLabelsPipe = /** @class */ (function () {
        function IgxTickLabelsPipe() {
        }
        IgxTickLabelsPipe.prototype.transform = function (labels, secondaryTicks) {
            if (!labels) {
                return;
            }
            var result = [];
            labels.forEach(function (item) {
                result.push(item);
                for (var i = 0; i < secondaryTicks; i++) {
                    result.push('');
                }
            });
            return result;
        };
        return IgxTickLabelsPipe;
    }());
    IgxTickLabelsPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'spreadTickLabels'
                },] }
    ];

    var NEXT_ID$q = 0;
    /**
     * **Ignite UI for Angular Slider** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider/slider)
     *
     * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
     * can be defined as continuous or stepped, and you can choose between single and range slider types.
     *
     * Example:
     * ```html
     * <igx-slider id="slider"
     *            [minValue]="0" [maxValue]="100"
     *            [continuous]=true [(ngModel)]="volume">
     * </igx-slider>
     * ```
     */
    var IgxSliderComponent = /** @class */ (function () {
        function IgxSliderComponent(renderer, _el, _cdr, _ngZone, _dir) {
            this.renderer = renderer;
            this._el = _el;
            this._cdr = _cdr;
            this._ngZone = _ngZone;
            this._dir = _dir;
            /**
             * @hidden
             */
            this.role = 'slider';
            /**
             * @hidden
             */
            this.slierClass = true;
            /**
             * An @Input property that sets the value of the `id` attribute.
             * If not provided it will be automatically generated.
             * ```html
             * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
             * ```
             */
            this.id = "igx-slider-" + NEXT_ID$q++;
            /**
             * An @Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
             * ```html
             * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
             * ```
             */
            this.thumbLabelVisibilityDuration = 750;
            /**
             * Show/hide slider ticks
             * ```html
             * <igx-slier [showTicks]="true" [primaryTicks]="5"></igx-slier>
             * ```
             */
            this.showTicks = false;
            /**
             * show/hide primary tick labels
             * ```html
             * <igx-slider [primaryTicks]="5" [primaryTickLabels]="false"></igx-slider>
             * ```
             */
            this.primaryTickLabels = true;
            /**
             * show/hide secondary tick labels
             * ```html
             * <igx-slider [secondaryTicks]="5" [secondaryTickLabels]="false"></igx-slider>
             * ```
             */
            this.secondaryTickLabels = true;
            /**
             * Changes ticks orientation:
             * bottom - The default orienation, below the slider track.
             * top - Above the slider track
             * mirror - combines top and bottom orientation.
             * ```html
             * <igx-slider [primaryTicks]="5" [ticksOrientation]="ticksOrientation"></igx-slider>
             * ```
             */
            this.ticksOrientation = TicksOrientation.Bottom;
            /**
             * Changes tick labels rotation:
             * horizontal - The default rotation
             * toptobottom - Rotates tick labels vertically to 90deg
             * bottomtotop - Rotate tick labels vertically to -90deg
             * ```html
             * <igx-slider [primaryTicks]="5" [secondaryTicks]="3" [tickLabelsOrientation]="tickLabelsOrientaiton"></igx-slider>
             * ```
             */
            this.tickLabelsOrientation = TickLabelsOrientation.Horizontal;
            /**
             * This event is emitted every time the value is changed.
             * ```typescript
             * public change(event){
             *    alert("The value has been changed!");
             * }
             * ```
             * ```html
             * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
             * ```
             */
            this.onValueChange = new i0.EventEmitter();
            /**
             * This event is emitted at the end of every slide interaction.
             * ```typescript
             * public change(event){
             *    alert("The value has been changed!");
             * }
             * ```
             * ```html
             * <igx-slider (onValueChanged)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
             * ```
             */
            this.onValueChanged = new i0.EventEmitter();
            /**
             * @hidden
             */
            this.thumbs = new i0.QueryList();
            /**
             * @hidden
             */
            this.labelRefs = new i0.QueryList();
            /**
             * @hidden
             */
            this.onPan = new rxjs.Subject();
            // Limit handle travel zone
            this._pMin = 0;
            this._pMax = 1;
            // From/upperValue in percent values
            this._hasViewInit = false;
            this._minValue = 0;
            this._maxValue = 100;
            this._continuous = false;
            this._disabled = false;
            this._step = 1;
            this._value = 0;
            // ticks
            this._primaryTicks = 0;
            this._secondaryTicks = 0;
            this._labels = new Array();
            this._type = IgxSliderType.SLIDER;
            this._destroyer$ = new rxjs.Subject();
            this._indicatorsDestroyer$ = new rxjs.Subject();
            this._onChangeCallback = rxjs.noop;
            this._onTouchedCallback = rxjs.noop;
            this.stepDistance = this._step;
        }
        Object.defineProperty(IgxSliderComponent.prototype, "thumbFrom", {
            /**
             * @hidden
             */
            get: function () {
                return this.thumbs.find(function (thumb) { return thumb.type === SliderHandle.FROM; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "thumbTo", {
            /**
             * @hidden
             */
            get: function () {
                return this.thumbs.find(function (thumb) { return thumb.type === SliderHandle.TO; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "labelFrom", {
            get: function () {
                return this.labelRefs.find(function (label) { return label.type === SliderHandle.FROM; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "labelTo", {
            get: function () {
                return this.labelRefs.find(function (label) { return label.type === SliderHandle.TO; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "valuemin", {
            /**
             * @hidden
             */
            get: function () {
                return this.minValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "valuemax", {
            /**
             * @hidden
             */
            get: function () {
                return this.maxValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "readonly", {
            /**
             * @hidden
             */
            get: function () {
                return this.disabled;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "disabledClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.disabled;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "type", {
            /**
             * An @Input property that gets the type of the `IgxSliderComponent`.
             * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
             * ```typescript
             * @ViewChild("slider2")
             * public slider: IgxSliderComponent;
             * ngAfterViewInit(){
             *     let type = this.slider.type;
             * }
             */
            get: function () {
                return this._type;
            },
            /**
             * An @Input property that sets the type of the `IgxSliderComponent`.
             * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
             * ```typescript
             * sliderType: IgxSliderType = IgxSliderType.RANGE;
             * ```
             * ```html
             * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
             * ```
             */
            set: function (type) {
                this._type = type;
                if (type === IgxSliderType.SLIDER) {
                    this.lowerValue = 0;
                }
                if (this.labelsViewEnabled && this.upperValue > this.maxValue) {
                    this.upperValue = this.labels.length - 1;
                }
                if (this._hasViewInit) {
                    this.updateTrack();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "labels", {
            /**
             * Enables `labelView`, by accepting a collection of primitive values with more than one element.
             * Each element will be equally spread over the slider and it will serve as a thumb label.
             * Once the property is set, it will precendence over {@link maxValue}, {@link minValue}, {@link step}.
             * This means that the manipulation for those properties won't be allowed.
             */
            get: function () {
                return this._labels;
            },
            set: function (labels) {
                this._labels = labels;
                this._pMax = this.valueToFraction(this.upperBound, 0, 1);
                this._pMin = this.valueToFraction(this.lowerBound, 0, 1);
                this.positionHandlersAndUpdateTrack();
                if (this._hasViewInit) {
                    this.stepDistance = this.calculateStepDistance();
                    this.setTickInterval();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "context", {
            /**
             * Returns the template context corresponding
             * to {@link IgxThumbFromTemplateDirective} and {@link IgxThumbToTemplateDirective} templates.
             *
             * ```typescript
             * return {
             *  $implicit // returns the value of the label,
             *  labels // returns the labels collection the user has passed.
             * }
             * ```
             */
            get: function () {
                return {
                    $implicit: this.value,
                    labels: this.labels
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "step", {
            /**
             * Returns the incremental/decremental dragging step of the {@link IgxSliderComponent}.
             * ```typescript
             * @ViewChild("slider2")
             * public slider: IgxSliderComponent;
             * ngAfterViewInit(){
             *     let step = this.slider.step;
             * }
             * ```
             */
            get: function () {
                return this.labelsViewEnabled ? 1 : this._step;
            },
            /**
             * An @Input property that sets the incremental/decremental step of the value when dragging the thumb.
             * The default step is 1, and step should not be less or equal than 0.
             * ```html
             * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
             * ```
             */
            set: function (step) {
                this._step = step;
                if (this._hasViewInit) {
                    this.stepDistance = this.calculateStepDistance();
                    this.normalizeByStep(this.value);
                    this.setTickInterval();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "disabled", {
            /**
             * Returns if the {@link IgxSliderComponent} is disabled.
             * ```typescript
             * @ViewChild("slider2")
             * public slider: IgxSliderComponent;
             * ngAfterViewInit(){
             *     let isDisabled = this.slider.disabled;
             * }
             * ```
             */
            get: function () {
                return this._disabled;
            },
            /**
             * An @Input property that disables or enables UI interaction.
             * ```html
             * <igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
             * ```
             */
            set: function (disable) {
                this._disabled = disable;
                if (this._hasViewInit) {
                    this.changeThumbFocusableState(disable);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "continuous", {
            /**
             * Returns if the {@link IgxSliderComponent} is set as continuous.
             * ```typescript
             * @ViewChild("slider2")
             * public slider: IgxSliderComponent;
             * ngAfterViewInit(){
             *     let continuous = this.slider.continuous;
             * }
             * ```
             */
            get: function () {
                return this._continuous;
            },
            /**
             * An @Input property that marks the {@link IgxSliderComponent} as continuous.
             * By default is considered that the {@link IgxSliderComponent} is discrete.
             * Discrete {@link IgxSliderComponent} slider has step indicators over the track and visible thumb labels during interaction.
             * Continuous {@link IgxSliderComponent} does not have ticks and does not show bubble labels for values.
             * ```html
             * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
             * ```
             */
            set: function (continuous) {
                this._continuous = continuous;
                if (this._hasViewInit) {
                    this.setTickInterval();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "minValue", {
            /**
             * Returns the minimal value of the `IgxSliderComponent`.
             * ```typescript
             *  @ViewChild("slider2")
             * public slider: IgxSliderComponent;
             * ngAfterViewInit(){
             *     let sliderMin = this.slider.minValue;
             * }
             * ```
             */
            get: function () {
                if (this.labelsViewEnabled) {
                    return 0;
                }
                return this._minValue;
            },
            /**
             * Sets the minimal value for the `IgxSliderComponent`.
             * The default minimal value is 0.
             * ```html
             * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
             * ```
             */
            set: function (value) {
                if (value >= this.maxValue) {
                    return;
                }
                else {
                    this._minValue = value;
                }
                if (value > this.upperBound) {
                    this.updateUpperBoundAndMaxTravelZone();
                    this.lowerBound = value;
                }
                // Refresh min travel zone limit.
                this._pMin = 0;
                // Recalculate step distance.
                this.positionHandlersAndUpdateTrack();
                if (this._hasViewInit) {
                    this.stepDistance = this.calculateStepDistance();
                    this.setTickInterval();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "maxValue", {
            /**
             * Returns the maximum value for the {@link IgxSliderComponent}.
             * ```typescript
             * @ViewChild("slider")
             * public slider: IgxSliderComponent;
             * ngAfterViewInit(){
             *     let sliderMax = this.slider.maxValue;
             * }
             *  ```
             */
            get: function () {
                return this.labelsViewEnabled ?
                    this.labels.length - 1 :
                    this._maxValue;
            },
            /**
             * Sets the maximal value for the `IgxSliderComponent`.
             * The default maximum value is 100.
             * ```html
             * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
             * ```
             */
            set: function (value) {
                if (value <= this._minValue) {
                    return;
                }
                else {
                    this._maxValue = value;
                }
                if (value < this.lowerBound) {
                    this.updateLowerBoundAndMinTravelZone();
                    this.upperBound = value;
                }
                // refresh max travel zone limits.
                this._pMax = 1;
                // recalculate step distance.
                this.positionHandlersAndUpdateTrack();
                if (this._hasViewInit) {
                    this.stepDistance = this.calculateStepDistance();
                    this.setTickInterval();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "lowerBound", {
            /**
             * Returns the lower boundary of the `IgxSliderComponent`.
             * ```typescript
             * @ViewChild("slider")
             * public slider: IgxSliderComponent;
             * ngAfterViewInit(){
             *     let sliderLowBound = this.slider.lowerBound;
             * }
             * ```
             */
            get: function () {
                if (!Number.isNaN(this._lowerBound) && this._lowerBound !== undefined) {
                    return this.valueInRange(this._lowerBound, this.minValue, this.maxValue);
                }
                return this.minValue;
            },
            /**
             * Sets the lower boundary of the `IgxSliderComponent`.
             * If not set is the same as min value.
             * ```html
             * <igx-slider [step]="5" [lowerBound]="20">
             * ```
             */
            set: function (value) {
                if (value >= this.upperBound || (this.labelsViewEnabled && value < 0)) {
                    return;
                }
                this._lowerBound = this.valueInRange(value, this.minValue, this.maxValue);
                // Refresh min travel zone.
                this._pMin = this.valueToFraction(this._lowerBound, 0, 1);
                this.positionHandlersAndUpdateTrack();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "upperBound", {
            /**
             * Returns the upper boundary of the `IgxSliderComponent`.
             * ```typescript
             * @ViewChild("slider")
             * public slider: IgxSliderComponent;
             * ngAfterViewInit(){
             *    let sliderUpBound = this.slider.upperBound;
             * }
             * ```
             */
            get: function () {
                if (!Number.isNaN(this._upperBound) && this._upperBound !== undefined) {
                    return this.valueInRange(this._upperBound, this.minValue, this.maxValue);
                }
                return this.maxValue;
            },
            /**
             * Sets the upper boundary of the `IgxSliderComponent`.
             * If not set is the same as max value.
             * ```html
             * <igx-slider [step]="5" [upperBound]="20">
             * ```
             */
            set: function (value) {
                if (value <= this.lowerBound || (this.labelsViewEnabled && value > this.labels.length - 1)) {
                    return;
                }
                this._upperBound = this.valueInRange(value, this.minValue, this.maxValue);
                // Refresh time travel zone.
                this._pMax = this.valueToFraction(this._upperBound, 0, 1);
                this.positionHandlersAndUpdateTrack();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "value", {
            /**
             * Returns the slider value. If the slider is of type {@link IgxSliderType.SLIDER} the returned value is number.
             * If the slider type is {@link IgxSliderType.RANGE}.
             * The returned value represents an object of {@link lowerValue} and {@link upperValue}.
             * ```typescript
             * @ViewChild("slider2")
             * public slider: IgxSliderComponent;
             * public sliderValue(event){
             *     let sliderVal = this.slider.value;
             * }
             * ```
             */
            get: function () {
                if (this.isRange) {
                    return {
                        lower: this.valueInRange(this.lowerValue, this.lowerBound, this.upperBound),
                        upper: this.valueInRange(this.upperValue, this.lowerBound, this.upperBound)
                    };
                }
                else {
                    return this.valueInRange(this.upperValue, this.lowerBound, this.upperBound);
                }
            },
            /**
             * Sets the slider value.
             * If the slider is of type {@link IgxSliderType.SLIDER}.
             * The argument is number. By default the {@link value} gets the {@link lowerBound}.
             * If the slider type is {@link IgxSliderType.RANGE} the argument
             * represents an object of {@link lowerValue} and {@link upperValue} properties.
             * By default the object is associated with the {@link lowerBound} and {@link upperBound} property values.
             * ```typescript
             * rangeValue = {
             *   lower: 30,
             *   upper: 60
             * };
             * ```
             * ```html
             * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
             * ```
             */
            set: function (value) {
                if (this._hasViewInit) {
                    this.setValue(value, true);
                    this.positionHandlersAndUpdateTrack();
                }
                else {
                    this._value = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "primaryTicks", {
            /**
             * Returns the number of the presented primary ticks.
             * ```typescript
             * const primaryTicks = this.slider.primaryTicks;
             * ```
             */
            get: function () {
                if (this.labelsViewEnabled) {
                    return this._primaryTicks = this.labels.length;
                }
                return this._primaryTicks;
            },
            /**
             * Sets the number of primary ticks. If {@link @labels} is enabled, this property won't function.
             * Insted enable ticks by {@link showTicks} property.
             * ```typescript
             * this.slider.primaryTicks = 5;
             * ```
             */
            set: function (val) {
                if (val <= 1) {
                    return;
                }
                this._primaryTicks = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "secondaryTicks", {
            /**
             * Returns the number of the presented secondary ticks.
             * ```typescript
             * const secondaryTicks = this.slider.secondaryTicks;
             * ```
             */
            get: function () {
                return this._secondaryTicks;
            },
            /**
             * Sets the number of secondary ticks. The property functions even when {@link labels} is enabled,
             * but all secondary ticks won't present any tick labels.
             * ```typescript
             * this.slider.secondaryTicks = 5;
             * ```
             */
            set: function (val) {
                if (val < 1) {
                    return;
                }
                this._secondaryTicks = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "deactivateThumbLabel", {
            /**
             * @hidden
             */
            get: function () {
                return ((this.primaryTicks && this.primaryTickLabels) || (this.secondaryTicks && this.secondaryTickLabels)) &&
                    (this.ticksOrientation === TicksOrientation.Top || this.ticksOrientation === TicksOrientation.Mirror);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.onPointerDown = function ($event) {
            this.findClosestThumb($event);
            if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
                return;
            }
            var activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbFrom;
            activeThumb.nativeElement.setPointerCapture($event.pointerId);
            this.showSliderIndicators();
            $event.preventDefault();
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.onPointerUp = function ($event) {
            if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
                return;
            }
            var activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbTo;
            activeThumb.nativeElement.releasePointerCapture($event.pointerId);
            this.hideSliderIndicators();
            this.onValueChanged.emit(this.value);
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.onFocus = function () {
            this.toggleSliderIndicators();
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.onPanListener = function ($event) {
            this.update($event.srcEvent.clientX);
        };
        Object.defineProperty(IgxSliderComponent.prototype, "isRange", {
            /**
             * Returns whether the `IgxSliderComponent` type is RANGE.
             * ```typescript
             *  @ViewChild("slider")
             * public slider: IgxSliderComponent;
             * ngAfterViewInit(){
             *     let sliderRange = this.slider.isRange;
             * }
             * ```
             */
            get: function () {
                return this.type === IgxSliderType.RANGE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "lowerValue", {
            /**
             * Returns the lower value of the `IgxSliderComponent`.
             * ```typescript
             * @ViewChild("slider")
             * public slider: IgxSliderComponent;
             * public lowValue(event){
             *    let sliderLowValue = this.slider.lowerValue;
             * }
             * ```
             */
            get: function () {
                if (!Number.isNaN(this._lowerValue) && this._lowerValue !== undefined && this._lowerValue >= this.lowerBound) {
                    return this._lowerValue;
                }
                return this.lowerBound;
            },
            /**
             * Sets the lower value of the `IgxSliderComponent`.
             * ```typescript
             *  @ViewChild("slider2")
             * public slider: IgxSliderComponent;
             * public lowValue(event){
             *     this.slider.lowerValue = 120;
             * }
             * ```
             */
            set: function (value) {
                value = this.valueInRange(value, this.lowerBound, this.upperBound);
                this._lowerValue = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "upperValue", {
            /**
             * Returns the upper value of the `IgxSliderComponent`.
             * ```typescript
             *  @ViewChild("slider2")
             * public slider: IgxSliderComponent;
             * public upperValue(event){
             *     let upperValue = this.slider.upperValue;
             * }
             * ```
             */
            get: function () {
                if (!Number.isNaN(this._upperValue) && this._upperValue !== undefined && this._upperValue <= this.upperBound) {
                    return this._upperValue;
                }
                return this.upperBound;
            },
            /**
             * Sets the upper value of the `IgxSliderComponent`.
             * ```typescript
             *  @ViewChild("slider2")
             * public slider: IgxSliderComponent;
             * public upperValue(event){
             *     this.slider.upperValue = 120;
             * }
             * ```
             */
            set: function (value) {
                value = this.valueInRange(value, this.lowerBound, this.upperBound);
                this._upperValue = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "lowerLabel", {
            /**
             * Returns the value corresponding the lower label.
             * ```typescript
             * @ViewChild("slider")
             * public slider: IgxSliderComponent;
             * let label = this.slider.lowerLabel;
             * ```
             */
            get: function () {
                return this.labelsViewEnabled ?
                    this.labels[this.lowerValue] :
                    this.lowerValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "upperLabel", {
            /**
             * Returns the value corresponding the upper label.
             * ```typescript
             * @ViewChild("slider")
             * public slider: IgxSliderComponent;
             * let label = this.slider.upperLabel;
             * ```
             */
            get: function () {
                return this.labelsViewEnabled ?
                    this.labels[this.upperValue] :
                    this.upperValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "labelsViewEnabled", {
            /**
             * Returns if label view is enabled.
             * If the {@link labels} is set, the view is automatically activated.
             * ```typescript
             * @ViewChild("slider")
             * public slider: IgxSliderComponent;
             * let labelView = this.slider.labelsViewEnabled;
             * ```
             */
            get: function () {
                return !!(this.labels && this.labels.length > 1);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "showTopTicks", {
            /**
             * @hidden
             */
            get: function () {
                return this.ticksOrientation === TicksOrientation.Top ||
                    this.ticksOrientation === TicksOrientation.Mirror;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "showBottomTicks", {
            /**
             * @hidden
             */
            get: function () {
                return this.ticksOrientation === TicksOrientation.Bottom ||
                    this.ticksOrientation === TicksOrientation.Mirror;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.ngOnChanges = function (changes) {
            if (changes.minValue && changes.maxValue &&
                changes.minValue.currentValue < changes.maxValue.currentValue) {
                this._maxValue = changes.maxValue.currentValue;
                this._minValue = changes.minValue.currentValue;
            }
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.ngOnInit = function () {
            this.sliderSetup();
            // Set track travel zone
            this._pMin = this.valueToFraction(this.lowerBound) || 0;
            this._pMax = this.valueToFraction(this.upperBound) || 1;
        };
        IgxSliderComponent.prototype.ngAfterContentInit = function () {
            this.setValue(this._value, false);
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this._hasViewInit = true;
            this.stepDistance = this.calculateStepDistance();
            this.positionHandlersAndUpdateTrack();
            this.setTickInterval();
            this.changeThumbFocusableState(this.disabled);
            this.subscribeTo(this.thumbFrom, this.thumbChanged.bind(this));
            this.subscribeTo(this.thumbTo, this.thumbChanged.bind(this));
            this.thumbs.changes.pipe(operators.takeUntil(this._destroyer$)).subscribe(function (change) {
                var thumbFrom = change.find(function (thumb) { return thumb.type === SliderHandle.FROM; });
                _this.positionHandler(thumbFrom, null, _this.lowerValue);
                _this.subscribeTo(thumbFrom, _this.thumbChanged.bind(_this));
                _this.changeThumbFocusableState(_this.disabled);
            });
            this.labelRefs.changes.pipe(operators.takeUntil(this._destroyer$)).subscribe(function (change) {
                var labelFrom = _this.labelRefs.find(function (label) { return label.type === SliderHandle.FROM; });
                _this.positionHandler(null, labelFrom, _this.lowerValue);
            });
            this._ngZone.runOutsideAngular(function () {
                resizeObservable(_this._el.nativeElement).pipe(operators.throttleTime(40), operators.takeUntil(_this._destroyer$)).subscribe(function () { return _this._ngZone.run(function () {
                    _this.stepDistance = _this.calculateStepDistance();
                }); });
            });
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.ngOnDestroy = function () {
            this._destroyer$.next(true);
            this._destroyer$.complete();
            this._indicatorsDestroyer$.next(true);
            this._indicatorsDestroyer$.complete();
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.writeValue = function (value) {
            if (!value) {
                return;
            }
            this.normalizeByStep(value);
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /** @hidden */
        IgxSliderComponent.prototype.getEditElement = function () {
            return this.isRange ? this.thumbFrom.nativeElement : this.thumbTo.nativeElement;
        };
        /**
         *
         * @hidden
         */
        IgxSliderComponent.prototype.update = function (mouseX) {
            if (this.disabled) {
                return;
            }
            // Update To/From Values
            this.onPan.next(mouseX);
            // Finally do positionHandlersAndUpdateTrack the DOM
            // based on data values
            this.positionHandlersAndUpdateTrack();
            this._onTouchedCallback();
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.thumbChanged = function (value, thumbType) {
            var oldValue = this.value;
            var newVal;
            if (this.isRange) {
                if (thumbType === SliderHandle.FROM) {
                    newVal = {
                        lower: this.value.lower + value,
                        upper: this.value.upper
                    };
                }
                else {
                    newVal = {
                        lower: this.value.lower,
                        upper: this.value.upper + value
                    };
                }
                // Swap the thumbs if a collision appears.
                if (newVal.lower >= newVal.upper) {
                    this.value = this.swapThumb(newVal);
                }
                else {
                    this.value = newVal;
                }
            }
            else {
                this.value = this.value + value;
            }
            if (this.hasValueChanged(oldValue)) {
                this.emitValueChanged(oldValue);
            }
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.onThumbChange = function () {
            this.toggleSliderIndicators();
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.onHoverChange = function (state) {
            return state ? this.showSliderIndicators() : this.hideSliderIndicators();
        };
        IgxSliderComponent.prototype.setValue = function (value, triggerChange) {
            var res;
            if (!this.isRange) {
                this.upperValue = value - (value % this.step);
                res = this.upperValue;
            }
            else {
                value = this.validateInitialValue(value);
                this.upperValue = value.upper;
                this.lowerValue = value.lower;
                res = { lower: this.lowerValue, upper: this.upperValue };
            }
            if (triggerChange) {
                this._onChangeCallback(res);
            }
        };
        IgxSliderComponent.prototype.swapThumb = function (value) {
            if (this.thumbFrom.isActive) {
                value.upper = this.upperValue;
                value.lower = this.upperValue;
            }
            else {
                value.upper = this.lowerValue;
                value.lower = this.lowerValue;
            }
            this.toggleThumb();
            return value;
        };
        IgxSliderComponent.prototype.findClosestThumb = function (event) {
            if (this.isRange) {
                this.closestHandle(event);
            }
            else {
                this.thumbTo.nativeElement.focus();
            }
            this.update(event.clientX);
        };
        IgxSliderComponent.prototype.updateLowerBoundAndMinTravelZone = function () {
            this.lowerBound = this.minValue;
            this._pMin = 0;
        };
        IgxSliderComponent.prototype.updateUpperBoundAndMaxTravelZone = function () {
            this.upperBound = this.maxValue;
            this._pMax = 1;
        };
        IgxSliderComponent.prototype.sliderSetup = function () {
            /**
             * if {@link SliderType.SLIDER} than the initial value shold be the lowest one.
             */
            if (!this.isRange && this._upperValue === undefined) {
                this._upperValue = this.lowerBound;
            }
        };
        IgxSliderComponent.prototype.calculateStepDistance = function () {
            return this._el.nativeElement.getBoundingClientRect().width / (this.maxValue - this.minValue) * this.step;
        };
        IgxSliderComponent.prototype.toggleThumb = function () {
            return this.thumbFrom.isActive ?
                this.thumbTo.nativeElement.focus() :
                this.thumbFrom.nativeElement.focus();
        };
        IgxSliderComponent.prototype.valueInRange = function (value, min, max) {
            if (min === void 0) { min = 0; }
            if (max === void 0) { max = 100; }
            return Math.max(Math.min(value, max), min);
        };
        IgxSliderComponent.prototype.generateTickMarks = function (color, interval) {
            return interval !== null ? "repeating-linear-gradient(\n            " + 'to left' + ",\n            " + color + ",\n            " + color + " 1.5px,\n            transparent 1.5px,\n            transparent " + interval + "%\n        ), repeating-linear-gradient(\n            " + 'to right' + ",\n            " + color + ",\n            " + color + " 1.5px,\n            transparent 1.5px,\n            transparent " + interval + "%\n        )" : interval;
        };
        IgxSliderComponent.prototype.positionHandler = function (thumbHandle, labelHandle, position) {
            var percent = this.valueToFraction(position) * 100 + "%";
            var dir = this._dir.rtl ? 'right' : 'left';
            if (thumbHandle) {
                thumbHandle.nativeElement.style[dir] = percent;
            }
            if (labelHandle) {
                labelHandle.nativeElement.style[dir] = percent;
            }
        };
        IgxSliderComponent.prototype.positionHandlersAndUpdateTrack = function () {
            if (!this.isRange) {
                this.positionHandler(this.thumbTo, this.labelTo, this.value);
            }
            else {
                this.positionHandler(this.thumbTo, this.labelTo, this.value.upper);
                this.positionHandler(this.thumbFrom, this.labelFrom, this.value.lower);
            }
            if (this._hasViewInit) {
                this.updateTrack();
            }
        };
        IgxSliderComponent.prototype.closestHandle = function (event) {
            var fromOffset = this.thumbFrom.nativeElement.offsetLeft + this.thumbFrom.nativeElement.offsetWidth / 2;
            var toOffset = this.thumbTo.nativeElement.offsetLeft + this.thumbTo.nativeElement.offsetWidth / 2;
            var xPointer = event.clientX - this._el.nativeElement.getBoundingClientRect().left;
            var match = this.closestTo(xPointer, [fromOffset, toOffset]);
            if (fromOffset === toOffset && toOffset < xPointer) {
                this.thumbTo.nativeElement.focus();
            }
            else if (fromOffset === toOffset && toOffset > xPointer) {
                this.thumbFrom.nativeElement.focus();
            }
            else if (match === fromOffset) {
                this.thumbFrom.nativeElement.focus();
            }
            else {
                this.thumbTo.nativeElement.focus();
            }
        };
        IgxSliderComponent.prototype.setTickInterval = function () {
            var interval;
            var trackProgress = 100;
            if (this.labelsViewEnabled) {
                // Calc ticks depending on the labels length;
                interval = ((trackProgress / (this.labels.length - 1) * 10)) / 10;
            }
            else {
                var trackRange = this.maxValue - this.minValue;
                interval = this.step > 1 ?
                    (trackProgress / ((trackRange / this.step)) * 10) / 10
                    : null;
            }
            var renderCallbackExecution = !this.continuous ? this.generateTickMarks(isIE() ? 'white' : 'var(--igx-slider-track-step-color, white)', interval) : null;
            this.renderer.setStyle(this.ticks.nativeElement, 'background', renderCallbackExecution);
        };
        IgxSliderComponent.prototype.showSliderIndicators = function () {
            if (this.disabled) {
                return;
            }
            if (this._indicatorsTimer) {
                this._indicatorsDestroyer$.next(true);
                this._indicatorsTimer = null;
            }
            this.thumbTo.showThumbIndicators();
            this.labelTo.active = true;
            if (this.thumbFrom) {
                this.thumbFrom.showThumbIndicators();
            }
            if (this.labelFrom) {
                this.labelFrom.active = true;
            }
        };
        IgxSliderComponent.prototype.hideSliderIndicators = function () {
            var _this = this;
            if (this.disabled) {
                return;
            }
            this._indicatorsTimer = rxjs.timer(this.thumbLabelVisibilityDuration);
            this._indicatorsTimer.pipe(operators.takeUntil(this._indicatorsDestroyer$)).subscribe(function () {
                _this.thumbTo.hideThumbIndicators();
                _this.labelTo.active = false;
                if (_this.thumbFrom) {
                    _this.thumbFrom.hideThumbIndicators();
                }
                if (_this.labelFrom) {
                    _this.labelFrom.active = false;
                }
            });
        };
        IgxSliderComponent.prototype.toggleSliderIndicators = function () {
            this.showSliderIndicators();
            this.hideSliderIndicators();
        };
        IgxSliderComponent.prototype.changeThumbFocusableState = function (state) {
            var value = state ? -1 : 1;
            if (this.isRange) {
                this.thumbFrom.tabindex = value;
            }
            this.thumbTo.tabindex = value;
            this._cdr.detectChanges();
        };
        IgxSliderComponent.prototype.closestTo = function (goal, positions) {
            return positions.reduce(function (previous, current) { return (Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous); });
        };
        IgxSliderComponent.prototype.valueToFraction = function (value, pMin, pMax) {
            if (pMin === void 0) { pMin = this._pMin; }
            if (pMax === void 0) { pMax = this._pMax; }
            return this.valueInRange((value - this.minValue) / (this.maxValue - this.minValue), pMin, pMax);
        };
        /**
         * @hidden
         * Normalizе the value when two-way data bind is used and {@link this.step} is set.
         * @param value
         */
        IgxSliderComponent.prototype.normalizeByStep = function (value) {
            if (this.isRange) {
                this.value = {
                    lower: value.lower - (value.lower % this.step),
                    upper: value.upper - (value.upper % this.step)
                };
            }
            else {
                this.value = value - (value % this.step);
            }
            this._cdr.detectChanges();
        };
        IgxSliderComponent.prototype.updateTrack = function () {
            var fromPosition = this.valueToFraction(this.lowerValue);
            var toPosition = this.valueToFraction(this.upperValue);
            var positionGap = toPosition - fromPosition;
            var trackLeftIndention = fromPosition;
            if (this.isRange) {
                if (positionGap) {
                    trackLeftIndention = Math.round((1 / positionGap * fromPosition) * 100);
                }
                trackLeftIndention = this._dir.rtl ? -trackLeftIndention : trackLeftIndention;
                this.renderer.setStyle(this.trackRef.nativeElement, 'transform', "scaleX(" + positionGap + ") translateX(" + trackLeftIndention + "%)");
            }
            else {
                this.renderer.setStyle(this.trackRef.nativeElement, 'transform', "scaleX(" + toPosition + ")");
            }
        };
        IgxSliderComponent.prototype.validateInitialValue = function (value) {
            if (value.lower < this.lowerBound && value.upper < this.lowerBound) {
                value.upper = this.lowerBound;
                value.lower = this.lowerBound;
            }
            if (value.lower > this.upperBound && value.upper > this.upperBound) {
                value.upper = this.upperBound;
                value.lower = this.upperBound;
            }
            if (value.upper < value.lower) {
                value.upper = this.upperValue;
                value.lower = this.lowerValue;
            }
            return value;
        };
        IgxSliderComponent.prototype.subscribeTo = function (thumb, callback) {
            if (!thumb) {
                return;
            }
            thumb.onThumbValueChange
                .pipe(operators.takeUntil(this.unsubscriber(thumb)))
                .subscribe(function (value) { return callback(value, thumb.type); });
        };
        IgxSliderComponent.prototype.unsubscriber = function (thumb) {
            return rxjs.merge(this._destroyer$, thumb.destroy);
        };
        IgxSliderComponent.prototype.hasValueChanged = function (oldValue) {
            var isSliderWithDifferentValue = !this.isRange && oldValue !== this.value;
            var isRangeWithOneDifferentValue = this.isRange &&
                (oldValue.lower !== this.value.lower ||
                    oldValue.upper !== this.value.upper);
            return isSliderWithDifferentValue || isRangeWithOneDifferentValue;
        };
        IgxSliderComponent.prototype.emitValueChanged = function (oldValue) {
            this.onValueChange.emit({ oldValue: oldValue, value: this.value });
        };
        return IgxSliderComponent;
    }());
    IgxSliderComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxSliderComponent, multi: true }],
                    selector: 'igx-slider',
                    template: "<div class=\"igx-slider__track\">\n    <igx-ticks\n        *ngIf=\"showTicks && showTopTicks\"\n        ticksOrientation=\"top\"\n        [primaryTicks]=\"primaryTicks\"\n        [secondaryTicks]=\"secondaryTicks\"\n        [primaryTickLabels]=\"primaryTickLabels\"\n        [secondaryTickLabels]=\"secondaryTickLabels\"\n        [tickLabelsOrientation]=\"tickLabelsOrientation\"\n        [labelsViewEnabled]=\"labelsViewEnabled\"\n        [labels]=\"labels | spreadTickLabels:secondaryTicks\"\n        [tickLabelTemplateRef]=\"tickLabelTemplateRef\"\n        [minValue]=\"minValue\"\n        [maxValue]=\"maxValue\"></igx-ticks>\n\n    <div #track class=\"igx-slider__track-fill\"></div>\n    <div #ticks class=\"igx-slider__track-steps\"></div>\n\n    <igx-ticks\n        *ngIf=\"showTicks && showBottomTicks\"\n        ticksOrientation=\"bottom\"\n        [primaryTicks]=\"primaryTicks\"\n        [secondaryTicks]=\"secondaryTicks\"\n        [primaryTickLabels]=\"primaryTickLabels\"\n        [secondaryTickLabels]=\"secondaryTickLabels\"\n        [tickLabelsOrientation]=\"tickLabelsOrientation\"\n        [labelsViewEnabled]=\"labelsViewEnabled\"\n        [labels]=\"labels | spreadTickLabels:secondaryTicks\"\n        [tickLabelTemplateRef]=\"tickLabelTemplateRef\"\n        [minValue]=\"minValue\"\n        [maxValue]=\"maxValue\"></igx-ticks>\n</div>\n<div class=\"igx-slider__thumbs\">\n    <igx-thumb-label\n        *ngIf=\"isRange\"\n        type=\"from\"\n        [value]=\"lowerLabel\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumb]=\"thumbFrom\"></igx-thumb-label>\n\n    <igx-thumb\n        *ngIf=\"isRange\"\n        #thumbFrom\n        type=\"from\"\n        [value]=\"lowerLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n\n    <igx-thumb-label\n        [value]=\"upperLabel\"\n        type=\"to\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumb]=\"thumbTo\"></igx-thumb-label>\n\n    <igx-thumb\n        #thumbTo\n        type=\"to\"\n        [value]=\"upperLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n</div>\n"
                },] }
    ];
    IgxSliderComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 },
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: i0.NgZone },
        { type: IgxDirectionality }
    ]; };
    IgxSliderComponent.propDecorators = {
        trackRef: [{ type: i0.ViewChild, args: ['track', { static: true },] }],
        thumbFromTemplateRef: [{ type: i0.ContentChild, args: [IgxThumbFromTemplateDirective, { read: i0.TemplateRef },] }],
        thumbToTemplateRef: [{ type: i0.ContentChild, args: [IgxThumbToTemplateDirective, { read: i0.TemplateRef },] }],
        tickLabelTemplateRef: [{ type: i0.ContentChild, args: [IgxTickLabelTemplateDirective, { read: i0.TemplateRef, static: false },] }],
        role: [{ type: i0.HostBinding, args: ["attr.role",] }],
        slierClass: [{ type: i0.HostBinding, args: ['class.igx-slider',] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        thumbLabelVisibilityDuration: [{ type: i0.Input }],
        valuemin: [{ type: i0.HostBinding, args: ["attr.aria-valuemin",] }],
        valuemax: [{ type: i0.HostBinding, args: ["attr.aria-valuemax",] }],
        readonly: [{ type: i0.HostBinding, args: ["attr.aria-readonly",] }],
        disabledClass: [{ type: i0.HostBinding, args: ['class.igx-slider--disabled',] }],
        type: [{ type: i0.Input }],
        labels: [{ type: i0.Input }],
        step: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        continuous: [{ type: i0.Input }],
        minValue: [{ type: i0.Input }],
        maxValue: [{ type: i0.Input }],
        lowerBound: [{ type: i0.Input }],
        upperBound: [{ type: i0.Input }],
        value: [{ type: i0.Input }],
        primaryTicks: [{ type: i0.Input }],
        secondaryTicks: [{ type: i0.Input }],
        showTicks: [{ type: i0.Input }],
        primaryTickLabels: [{ type: i0.Input }],
        secondaryTickLabels: [{ type: i0.Input }],
        ticksOrientation: [{ type: i0.Input }],
        tickLabelsOrientation: [{ type: i0.Input }],
        onValueChange: [{ type: i0.Output }],
        onValueChanged: [{ type: i0.Output }],
        ticks: [{ type: i0.ViewChild, args: ['ticks', { static: true },] }],
        thumbs: [{ type: i0.ViewChildren, args: [IgxSliderThumbComponent,] }],
        labelRefs: [{ type: i0.ViewChildren, args: [IgxThumbLabelComponent,] }],
        onPointerDown: [{ type: i0.HostListener, args: ['pointerdown', ['$event'],] }],
        onPointerUp: [{ type: i0.HostListener, args: ['pointerup', ['$event'],] }],
        onFocus: [{ type: i0.HostListener, args: ['focus',] }],
        onPanListener: [{ type: i0.HostListener, args: ['pan', ['$event'],] }]
    };
    /**
     * @hidden
     */
    var IgxSliderModule = /** @class */ (function () {
        function IgxSliderModule() {
        }
        return IgxSliderModule;
    }());
    IgxSliderModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxSliderComponent,
                        IgxThumbFromTemplateDirective,
                        IgxThumbToTemplateDirective,
                        IgxTickLabelTemplateDirective,
                        IgxSliderThumbComponent,
                        IgxThumbLabelComponent,
                        IgxTicksComponent,
                        IgxTickLabelsPipe
                    ],
                    exports: [
                        IgxSliderComponent,
                        IgxThumbFromTemplateDirective,
                        IgxThumbToTemplateDirective,
                        IgxTickLabelTemplateDirective,
                        IgxSliderThumbComponent,
                        IgxThumbLabelComponent,
                        IgxTicksComponent
                    ],
                    imports: [i2.CommonModule, forms.FormsModule]
                },] }
    ];

    var SwitchLabelPosition = mkenum({
        BEFORE: 'before',
        AFTER: 'after'
    });
    var nextId$3 = 0;
    /**
     *
     * The Switch component is a binary choice selection component.
     *
     * @igxModule IgxSwitchModule
     *
     * @igxTheme igx-switch-theme, igx-tooltip-theme
     *
     * @igxKeywords switch, states, tooltip
     *
     * @igxGroup Data Entry & Display
     *
     * @remarks
     *
     * The Ignite UI Switch lets the user toggle between on/off or true/false states.
     *
     * @example
     * ```html
     * <igx-switch [checked]="true">
     *   Simple switch
     * </igx-switch>
     * ```
     */
    var IgxSwitchComponent = /** @class */ (function () {
        function IgxSwitchComponent() {
            /**
             * Sets/gets the `id` of the switch component.
             * If not set, the `id` of the first switch component will be `"igx-switch-0"`.
             *
             * @example
             * ```html
             * <igx-switch id="my-first-switch"></igx-switch>
             * ```
             */
            this.id = "igx-switch-" + nextId$3++;
            /**
             * Sets/gets the id of the `label` element of the switch component.
             * If not set, the label of the first switch component will have value `"igx-switch-0-label"`.
             *
             * @example
             * ```html
             * <igx-switch labelId="Label1"></igx-switch>
             * ```
             */
            this.labelId = this.id + "-label";
            /**
             * Sets/gets the value of the `tabindex` attribute.
             *
             * @example
             * ```html
             * <igx-switch [tabindex]="1"></igx-switch>
             * ```
             */
            this.tabindex = null;
            /**
             * Sets/gets the position of the `label` in the switch component.
             * If not set, `labelPosition` will have value `"after"`.
             *
             * @example
             * ```html
             * <igx-switch labelPosition="before"></igx-switch>
             * ```
             */
            this.labelPosition = 'after';
            /**
             * Enables/Disables the ripple effect
             * If not set, `disableRipple` will have value `false`.
             *
             * @example
             * ```html
             * <igx-switch [disableRipple]="true"></igx-switch>
             * ```
             */
            this.disableRipple = false;
            /**
             * Sets/gets whether switch is required.
             * If not set, `required` will have value `false`.
             *
             * @example
             * ```html
             * <igx-switch [required]="true"></igx-switch>
             * ```
             */
            this.required = false;
            /**
             * Sets/gets the `aria-labelledBy` attribute.
             * If not set, the  value of `aria-labelledBy` will be equal to the value of `labelId` attribute.
             *
             * @example
             * ```html
             * <igx-switch aria-labelledby = "Label1"></igx-switch>
             * ```
             */
            this.ariaLabelledBy = this.labelId;
            /**
             * Sets/gets the value of the `aria-label` attribute.
             *
             * @example
             * ```html
             * <igx-switch aria-label="Label1"></igx-switch>
             * ```
             */
            this.ariaLabel = null;
            /**
             * An event that is emitted after the switch state is changed.
             * Provides references to the `IgxSwitchComponent` and the `checked` property as event arguments.
             */
            // eslint-disable-next-line @angular-eslint/no-output-native
            this.change = new i0.EventEmitter();
            /**
             * Returns the class of the switch component.
             *
             * @example
             * ```typescript
             * let switchClass = this.switch.cssClass;
             * ```
             */
            this.cssClass = 'igx-switch';
            /**
             * Sets/gets whether the switch is on or off.
             * Default value is 'false'.
             *
             * @example
             * ```html
             *  <igx-switch [checked]="true"></igx-switch>
             * ```
             */
            this.checked = false;
            /**
             * Sets/gets the `disabled` attribute.
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-switch [disabled]="true"><igx-switch>
             * ```
             */
            this.disabled = false;
            /**
             * Sets/gets whether the switch component is on focus.
             * Default value is `false`.
             *
             * @example
             * ```typescript
             * this.switch.focused = true;
             * ```
             */
            this.focused = false;
            /**
             * @hidden
             * @internal
             */
            this.inputId = this.id + "-input";
            /**
             * @hidden
             * @internal
             */
            this._onTouchedCallback = rxjs.noop;
            /**
             * @hidden
             * @internal
             */
            this._onChangeCallback = rxjs.noop;
        }
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype.onKeyUp = function (event) {
            event.stopPropagation();
            this.focused = true;
        };
        /**
         * Toggles the checked state of the switch.
         *
         * @example
         * ```typescript
         * this.switch.toggle();
         * ```
         */
        IgxSwitchComponent.prototype.toggle = function () {
            if (this.disabled) {
                return;
            }
            this.nativeCheckbox.nativeElement.focus();
            this.checked = !this.checked;
            this.change.emit({ checked: this.checked, switch: this });
            this._onChangeCallback(this.checked);
        };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype._onSwitchChange = function (event) {
            event.stopPropagation();
        };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype._onSwitchClick = function (event) {
            event.stopPropagation();
            this.toggle();
            if (isIE()) {
                this.nativeCheckbox.nativeElement.blur();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype.onLabelClick = function () {
            this.toggle();
        };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype.onBlur = function () {
            this.focused = false;
            this._onTouchedCallback();
        };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype.writeValue = function (value) {
            this._value = value;
            this.checked = !!this._value;
        };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype.getEditElement = function () {
            return this.nativeCheckbox.nativeElement;
        };
        Object.defineProperty(IgxSwitchComponent.prototype, "labelClass", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                switch (this.labelPosition) {
                    case SwitchLabelPosition.BEFORE:
                        return this.cssClass + "__label--before";
                    case SwitchLabelPosition.AFTER:
                    default:
                        return this.cssClass + "__label";
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        return IgxSwitchComponent;
    }());
    IgxSwitchComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxSwitchComponent, multi: true }],
                    selector: 'igx-switch',
                    template: "<input #checkbox class=\"igx-switch__input\" type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onSwitchChange($event)\"\n    (click)=\"_onSwitchClick($event)\"\n    (blur)=\"onBlur()\" />\n\n<label #label class =\"igx-switch__composite\" [for]=\"inputId\"\n    igxRipple\n    igxRippleTarget=\".igx-switch__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\">\n    <div class=\"igx-switch__composite-thumb\">\n        <div class=\"igx-switch__ripple\"></div>\n    </div>\n</label>\n\n<span #placeholderLabel\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"onLabelClick()\">\n    <ng-content></ng-content>\n</span>\n"
                },] }
    ];
    IgxSwitchComponent.propDecorators = {
        nativeCheckbox: [{ type: i0.ViewChild, args: ['checkbox', { static: true },] }],
        nativeLabel: [{ type: i0.ViewChild, args: ['label', { static: true },] }],
        placeholderLabel: [{ type: i0.ViewChild, args: ['placeholderLabel', { static: true },] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        labelId: [{ type: i0.Input }],
        value: [{ type: i0.Input }],
        name: [{ type: i0.Input }],
        tabindex: [{ type: i0.Input }],
        labelPosition: [{ type: i0.Input }],
        disableRipple: [{ type: i0.Input }],
        required: [{ type: i0.Input }],
        ariaLabelledBy: [{ type: i0.Input, args: ['aria-labelledby',] }],
        ariaLabel: [{ type: i0.Input, args: ['aria-label',] }],
        change: [{ type: i0.Output }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-switch',] }],
        checked: [{ type: i0.HostBinding, args: ['class.igx-switch--checked',] }, { type: i0.Input }],
        disabled: [{ type: i0.HostBinding, args: ['class.igx-switch--disabled',] }, { type: i0.Input }],
        focused: [{ type: i0.HostBinding, args: ['class.igx-switch--focused',] }],
        onKeyUp: [{ type: i0.HostListener, args: ['keyup', ['$event'],] }]
    };
    var IGX_SWITCH_REQUIRED_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: i0.forwardRef(function () { return IgxSwitchRequiredDirective; }),
        multi: true
    };
    /* eslint-disable  @angular-eslint/directive-selector */
    var IgxSwitchRequiredDirective = /** @class */ (function (_super) {
        __extends(IgxSwitchRequiredDirective, _super);
        function IgxSwitchRequiredDirective() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return IgxSwitchRequiredDirective;
    }(forms.CheckboxRequiredValidator));
    IgxSwitchRequiredDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: "igx-switch[required][formControlName],\n    igx-switch[required][formControl],\n    igx-switch[required][ngModel]",
                    providers: [IGX_SWITCH_REQUIRED_VALIDATOR]
                },] }
    ];
    /**
     * @hidden
     */
    var IgxSwitchModule = /** @class */ (function () {
        function IgxSwitchModule() {
        }
        return IgxSwitchModule;
    }());
    IgxSwitchModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                    exports: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                    imports: [IgxRippleModule]
                },] }
    ];

    var NEXT_ID$r = 0;
    var IgxTabTemplateDirective = /** @class */ (function () {
        function IgxTabTemplateDirective(template) {
            this.template = template;
        }
        return IgxTabTemplateDirective;
    }());
    IgxTabTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxTab]'
                },] }
    ];
    IgxTabTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    /**
     * **Ignite UI for Angular Tab Bar** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tabbar)
     *
     * The Ignite UI Tab Bar enables the user to navigate among a number of content panels displayed in a single view.
     *
     * Example:
     * ```html
     * <igx-bottom-nav>
     *   <igx-tab-panel label="Tab 1">Tab 1 Content</igx-tab-panel>
     *   <igx-tab-panel label="Tab 2">Tab 2 Content</igx-tab-panel>
     *   <igx-tab-panel label="Tab 3">Tab 3 Content</igx-tab-panel>
     * </igx-bottom-nav>
     * ```
     */
    var IgxBottomNavComponent = /** @class */ (function () {
        function IgxBottomNavComponent() {
            /**
             * Emits an event when a new tab is selected.
             * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
             * ```html
             * <igx-bottom-nav (onTableSelected) = "onTabSelected($event)"><igx-bottom-nav>
             * ```
             *
             * @memberof IgxBottomNavComponent
             */
            this.onTabSelected = new i0.EventEmitter();
            /**
             * Emits an event when a tab is deselected.
             * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
             * ```html
             * <igx-bottom-nav (onTabDeselected) = "onTabDeselected($event)"><igx-bottom-nav>
             * ```
             *
             * @memberof IgxBottomNavComponent
             */
            this.onTabDeselected = new i0.EventEmitter();
            this._currentBottomNavId = NEXT_ID$r++;
            /**
             * Sets/gets the `id` of the tab bar.
             * If not set, the `id` of the first tab bar component will be `"igx-bottom-nav-0"`.
             * ```html
             * <igx-bottom-nav id = "my-first-tab-bar"></igx-bottom-nav>
             * ```
             * ```typescript
             * let tabBarId =  this.tabBar.id;
             * ```
             *
             * @memberof IgxBottomNavComponent
             */
            // eslint-disable-next-line @typescript-eslint/member-ordering
            this.id = "igx-bottom-nav-" + this._currentBottomNavId;
            /**
             * Gets the `index` of selected tab/panel in the respective collection.
             * ```typescript
             * let index =  this.tabBar.selectedIndex;
             * ```
             *
             * @memberof IgxBottomNavComponent
             */
            // eslint-disable-next-line @typescript-eslint/member-ordering
            this.selectedIndex = -1;
            /**
             * @hidden
             */
            this._itemStyle = 'igx-bottom-nav';
        }
        Object.defineProperty(IgxBottomNavComponent.prototype, "tabs", {
            /**
             * Gets the `IgxTabComponent` elements for this bottom navigation component.
             * First try to get them as content children if not available get them as view children.
             * ```typescript
             * let tabs: QueryList<IgxTabComponent> =  this.tabBar.tabs;
             * ```
             *
             * @memberof IgxBottomNavComponent
             */
            get: function () {
                return this.hasContentTabs ? this.contentTabs : this.viewTabs;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxBottomNavComponent.prototype, "itemStyle", {
            /**
             * Gets the `itemStyle` of the tab bar.
             * ```typescript
             * let itemStyle =  this.tabBar.itemStyle;
             * ```
             *
             * @memberof IgxBottomNavComponent
             */
            get: function () {
                return this._itemStyle;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxBottomNavComponent.prototype, "hasContentTabs", {
            /**
             * @hidden
             */
            get: function () {
                return (this.contentTabs && this.contentTabs.length > 0);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxBottomNavComponent.prototype, "selectedTab", {
            /**
             * Gets the selected tab in the tab bar.
             * ```typescript
             * let tab =  this.tabBar.selectedTab;
             * ```
             *
             * @memberof IgxBottomNavComponent
             */
            get: function () {
                if (this.tabs && this.selectedIndex !== undefined) {
                    return this.tabs.toArray()[this.selectedIndex];
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxBottomNavComponent.prototype.selectedPanelHandler = function (args) {
            var _this = this;
            if (this.hasContentTabs) {
                this.selectedIndex = args.tab.index;
                this.contentTabs.forEach(function (t) {
                    if (t !== args.tab) {
                        _this._deselectTab(t);
                    }
                });
            }
            else {
                if (args.panel) {
                    this.selectedIndex = args.panel.index;
                    this.panels.forEach(function (p) {
                        if (p.index !== _this.selectedIndex) {
                            _this._deselectPanel(p);
                        }
                    });
                }
            }
        };
        /**
         * @hidden
         */
        IgxBottomNavComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.setPanelsAttributes();
            this._panelsChanges$ = this.panels.changes.subscribe(function () {
                _this.setPanelsAttributes();
            });
            // initial selection
            setTimeout(function () {
                if (_this.selectedIndex === -1) {
                    var selectablePanels = _this.panels.filter(function (p) { return !p.disabled; });
                    var panel = selectablePanels[0];
                    if (panel) {
                        panel.select();
                    }
                }
            }, 0);
        };
        /**
         * @hidden
         */
        IgxBottomNavComponent.prototype.ngOnDestroy = function () {
            if (this._panelsChanges$) {
                this._panelsChanges$.unsubscribe();
            }
        };
        /**
         * @hidden
         */
        IgxBottomNavComponent.prototype.getTabId = function (index) {
            return "igx-tab-" + this._currentBottomNavId + "-" + index;
        };
        /**
         * @hidden
         */
        IgxBottomNavComponent.prototype.getTabPanelId = function (index) {
            return "igx-tab-panel-" + this._currentBottomNavId + "-" + index;
        };
        IgxBottomNavComponent.prototype.setPanelsAttributes = function () {
            var panelsArray = Array.from(this.panels);
            for (var index = 0; index < this.panels.length; index++) {
                var tabPanels = panelsArray[index];
                tabPanels.nativeElement.setAttribute('id', this.getTabPanelId(index));
                tabPanels.nativeElement.setAttribute('aria-labelledby', this.getTabId(index));
            }
        };
        /**
         * @hidden
         */
        IgxBottomNavComponent.prototype._deselectPanel = function (panel) {
            // Cannot deselect the selected tab - this will mean that there will be not selected tab left
            if (panel.disabled || this.selectedTab.index === panel.index) {
                return;
            }
            panel.isSelected = false;
            this.onTabDeselected.emit({ tab: this.tabs[panel.index], panel: panel });
        };
        IgxBottomNavComponent.prototype._deselectTab = function (aTab) {
            aTab.isSelected = false;
            this.onTabDeselected.emit({ tab: aTab, panel: null });
        };
        return IgxBottomNavComponent;
    }());
    IgxBottomNavComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-bottom-nav',
                    template: "<div *ngIf=\"!hasContentTabs\">\n    <ng-content></ng-content>\n</div>\n<div #tablist class=\"{{itemStyle}}__menu {{itemStyle}}__menu--bottom\" role=\"tablist\" aria-orientation=\"horizontal\">\n    <ng-container *ngIf=\"!hasContentTabs\">\n        <igx-tab *ngFor=\"let panel of panels; let i = index\"\n            [relatedPanel]=\"panel\"\n            [autoGenerated]=\"true\"\n            [id]=\"getTabId(i)\"\n            [attr.aria-controls]=\"getTabPanelId(i)\">>\n        </igx-tab>\n    </ng-container>\n    <ng-content select=\"igx-tab\"></ng-content>\n</div>\n",
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                },] }
    ];
    IgxBottomNavComponent.propDecorators = {
        viewTabs: [{ type: i0.ViewChildren, args: [i0.forwardRef(function () { return IgxTabComponent; }),] }],
        contentTabs: [{ type: i0.ContentChildren, args: [i0.forwardRef(function () { return IgxTabComponent; }),] }],
        panels: [{ type: i0.ContentChildren, args: [i0.forwardRef(function () { return IgxTabPanelComponent; }),] }],
        onTabSelected: [{ type: i0.Output }],
        onTabDeselected: [{ type: i0.Output }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        selectedPanelHandler: [{ type: i0.HostListener, args: ['onTabSelected', ['$event'],] }]
    };
    // ================================= IgxTabPanelComponent ======================================
    var IgxTabPanelComponent = /** @class */ (function () {
        function IgxTabPanelComponent(_tabBar, _element) {
            this._tabBar = _tabBar;
            this._element = _element;
            /**
             * Gets the role of the tab panel.
             * ```typescript
             * let tabPanelRole = this.tabPanel.role;
             * ```
             *
             * @memberof IgxTabPanelComponent
             */
            this.role = 'tabpanel';
            /**
             * @hidden
             */
            this._itemStyle = 'igx-tab-panel';
            /**
             * @hidden
             */
            this._isSelected = false;
        }
        Object.defineProperty(IgxTabPanelComponent.prototype, "styleClass", {
            /**
             * Gets whether a tab panel will have `igx-bottom-nav__panel` class.
             * ```typescript
             * let styleClass = this.tabPanel.styleClass;
             * ```
             *
             * @memberof IgxTabPanelComponent
             */
            get: function () {
                return (!this.isSelected);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabPanelComponent.prototype, "isSelected", {
            /**
             * Sets/gets whether a tab panel is selected.
             * ```typescript
             * this.tabPanel.isSelected = true;
             * ```
             * ```typescript
             * let isSelected =  this.tabPanel.isSelected;
             * ```
             *
             * @memberof IgxTabPanelComponent
             */
            get: function () {
                return this._isSelected;
            },
            set: function (newValue) {
                if (this._isSelected !== newValue) {
                    if (newValue) {
                        this.select();
                    }
                    else {
                        this._isSelected = newValue;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabPanelComponent.prototype, "itemStyle", {
            /**
             * Gets the `itemStyle` of the tab panel.
             * ```typescript
             * let itemStyle = this.tabPanel.itemStyle;
             * ```
             *
             * @memberof IgxTabPanelComponent
             */
            get: function () {
                return this._itemStyle;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabPanelComponent.prototype, "nativeElement", {
            /**
             * Returns the native element of the tab-panel component
             * ```typescript
             *  const mytabPanelElement: HTMLElement = tabPanel.nativeElement;
             * ```
             */
            get: function () {
                return this._element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabPanelComponent.prototype, "relatedTab", {
            /**
             * Gets the tab associated with the panel.
             * ```typescript
             * let tab = this.tabPanel.relatedTab;
             * ```
             *
             * @memberof IgxTabPanelComponent
             */
            get: function () {
                if (this._tabBar.tabs) {
                    return this._tabBar.tabs.toArray()[this.index];
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabPanelComponent.prototype, "changesCount", {
            /**
             * Gets the changes and updates accordingly applied to the tab/panel.
             *
             * @memberof IgxTabComponent
             */
            get: function () {
                return this.relatedTab ? this.relatedTab.changesCount : 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabPanelComponent.prototype, "index", {
            /**
             * Gets the index of a panel in the panels collection.
             * ```typescript
             * let panelIndex =  this.tabPanel.index
             * ```
             *
             * @memberof IgxTabPanelComponent
             */
            get: function () {
                if (this._tabBar.panels) {
                    return this._tabBar.panels.toArray().indexOf(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabPanelComponent.prototype, "customTabTemplate", {
            /**
             * Gets the tab template.
             * ```typescript
             * let tabTemplate = this.tabPanel.customTabTemplate
             * ```
             *
             * @memberof IgxTabPanelComponent
             */
            get: function () {
                return this._tabTemplate;
            },
            /**
             * Sets the tab template.
             * ```typescript
             * this.tabPanel.customTabTemplate(tabTemplate);
             * ```
             *
             * @memberof IgxTabPanelComponent
             */
            set: function (template) {
                this._tabTemplate = template;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTabPanelComponent.prototype.ngAfterContentInit = function () {
            if (this.tabTemplate) {
                this._tabTemplate = this.tabTemplate.template;
            }
        };
        /**
         * Selects the current tab and the tab panel.
         * ```typescript
         * this.tabPanel.select();
         * ```
         *
         * @memberof IgxTabPanelComponent
         */
        IgxTabPanelComponent.prototype.select = function () {
            if (this.disabled || this._tabBar.selectedIndex === this.index) {
                return;
            }
            this._isSelected = true;
            this._tabBar.onTabSelected.emit({ tab: this._tabBar.tabs.toArray()[this.index], panel: this });
        };
        return IgxTabPanelComponent;
    }());
    IgxTabPanelComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-tab-panel',
                    template: "<ng-content></ng-content>\n"
                },] }
    ];
    IgxTabPanelComponent.ctorParameters = function () { return [
        { type: IgxBottomNavComponent },
        { type: i0.ElementRef }
    ]; };
    IgxTabPanelComponent.propDecorators = {
        label: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        styleClass: [{ type: i0.HostBinding, args: ['class.igx-bottom-nav__panel',] }],
        isSelected: [{ type: i0.HostBinding, args: ['class.igx-bottom-nav__panel--selected',] }],
        tabTemplate: [{ type: i0.ContentChild, args: [IgxTabTemplateDirective, { read: IgxTabTemplateDirective },] }]
    };
    // ======================================= IgxTabComponent ==========================================
    var IgxTabComponent = /** @class */ (function () {
        function IgxTabComponent(_tabBar, _element) {
            this._tabBar = _tabBar;
            this._element = _element;
            /**
             * Gets the `role` attribute.
             * ```typescript
             * let tabRole = this.tab.role;
             * ```
             *
             * @memberof IgxTabComponent
             */
            this.role = 'tab';
            /**
             * @hidden @internal
             */
            this.ariaLabel = this.label;
            /**
             * @hidden @internal
             */
            this.ariaDisabled = this.disabled;
            /**
             * @hidden @internal
             */
            this.ariaSelected = this.isSelected;
            /**
             * @hidden
             */
            this._changesCount = 0; // changes and updates accordingly applied to the tab.
            this._disabled = false;
            this._selected = false;
        }
        Object.defineProperty(IgxTabComponent.prototype, "label", {
            /**
             * Sets/gets the `label` of the tab panel.
             * ```html
             * <igx-tab [label] = "'Tab label'"><igx-tab>
             * ```
             * ```typescript
             * let tabLabel = this.tab.label;
             * ```
             *
             * @memberof IgxTabComponent
             */
            get: function () {
                return this.relatedPanel ? this.relatedPanel.label : this._label;
            },
            set: function (newValue) {
                if (this.relatedPanel) {
                    this.relatedPanel.label = newValue;
                }
                this._label = newValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "icon", {
            /**
             * Sets/gets  the `icon` of the tab panel.
             * ```html
             * <igx-tab [icon] = "tab_icon"><igx-tab>
             * ```
             * ```typescript
             * let tabIcon =  this.tab.icon;
             * ```
             *
             * @memberof IgxTabComponent
             */
            get: function () {
                return this.relatedPanel ? this.relatedPanel.icon : this._icon;
            },
            set: function (newValue) {
                if (this.relatedPanel) {
                    this.relatedPanel.icon = newValue;
                }
                this._icon = newValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "changesCount", {
            /**
             * Gets the changes and updates accordingly applied to the tab.
             *
             * @memberof IgxTabComponent
             */
            get: function () {
                return this._changesCount;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "disabled", {
            /**
             * Gets whether the tab is disabled.
             * ```typescript
             * let isDisabled = this.tab.disabled;
             * ```
             *
             * @memberof IgxTabComponent
             */
            get: function () {
                return this.relatedPanel ? this.relatedPanel.disabled : this._disabled;
            },
            set: function (newValue) {
                if (this.relatedPanel) {
                    this.relatedPanel.disabled = newValue;
                }
                else {
                    this._disabled = newValue;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "isSelected", {
            get: function () {
                return this.relatedPanel ? this.relatedPanel.isSelected : this._selected;
            },
            /**
             * Gets whether the tab is selected.
             * ```typescript
             * let isSelected  = this.tab.isSelected;
             * ```
             *
             * @memberof IgxTabComponent
             */
            set: function (newValue) {
                if (this.relatedPanel) {
                    this.relatedPanel.isSelected = newValue;
                }
                else if (this._selected !== newValue) {
                    this._selected = newValue;
                    if (this._selected) {
                        this._tabBar.onTabSelected.emit({ tab: this, panel: null });
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "cssClassSelected", {
            get: function () {
                return this.isSelected;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "cssClassDisabled", {
            get: function () {
                return this.disabled;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "cssClass", {
            get: function () {
                return (!this.disabled && !this.isSelected);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "index", {
            /**
             * Gets the `index` of the tab.
             * ```typescript
             * let tabIndex = this.tab.index;
             * ```
             *
             * @memberof IgxTabComponent
             */
            get: function () {
                if (this._tabBar.tabs) {
                    return this._tabBar.tabs.toArray().indexOf(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "template", {
            /**
             * Returns the `template` for this IgxTabComponent.
             * ```typescript
             * let tabItemTemplate = this.tabItem.template;
             * ```
             *
             * @memberof IgxTabComponent
             */
            get: function () {
                if (this.relatedPanel && this.relatedPanel.customTabTemplate) {
                    return this.relatedPanel.customTabTemplate;
                }
                if (this.customTabTemplateDir) {
                    return this.customTabTemplateDir.template;
                }
                return this.defaultTabTemplate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "context", {
            /**
             * Returns the `context` object for the template of this `IgxTabComponent`.
             * ```typescript
             * let tabItemContext = this.tabItem.context;
             * ```
             */
            get: function () {
                return this.relatedPanel ? this.relatedPanel : this;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTabComponent.prototype.onClick = function () {
            if (this.autoGenerated) {
                this.select();
            }
        };
        /**
         * Selects the current tab and the associated panel.
         * ```typescript
         * this.tab.select();
         * ```
         *
         * @memberof IgxTabComponent
         */
        IgxTabComponent.prototype.select = function () {
            if (this.relatedPanel) {
                this.relatedPanel.select();
            }
            else {
                this._selected = true;
                this._tabBar.onTabSelected.emit({ tab: this, panel: null });
            }
        };
        IgxTabComponent.prototype.elementRef = function () {
            return this._element;
        };
        return IgxTabComponent;
    }());
    IgxTabComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-tab',
                    template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"tab-icon\">\n        <igx-icon>{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"context.changesCount\" [hidden]=\"context.changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"tab-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>\n"
                },] }
    ];
    IgxTabComponent.ctorParameters = function () { return [
        { type: IgxBottomNavComponent },
        { type: i0.ElementRef }
    ]; };
    IgxTabComponent.propDecorators = {
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        ariaLabel: [{ type: i0.HostBinding, args: ['attr.aria-label',] }],
        ariaDisabled: [{ type: i0.HostBinding, args: ['attr.aria-disabled',] }],
        ariaSelected: [{ type: i0.HostBinding, args: ['attr.aria-selected',] }],
        relatedPanel: [{ type: i0.Input }],
        autoGenerated: [{ type: i0.Input }],
        defaultTabTemplate: [{ type: i0.ViewChild, args: ['defaultTabTemplate', { read: i0.TemplateRef, static: true },] }],
        customTabTemplateDir: [{ type: i0.ContentChild, args: [IgxTabTemplateDirective, { read: IgxTabTemplateDirective },] }],
        label: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        isSelected: [{ type: i0.Input }],
        cssClassSelected: [{ type: i0.HostBinding, args: ['class.igx-bottom-nav__menu-item--selected',] }],
        cssClassDisabled: [{ type: i0.HostBinding, args: ['class.igx-bottom-nav__menu-item--disabled',] }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-bottom-nav__menu-item',] }],
        onClick: [{ type: i0.HostListener, args: ['click',] }]
    };
    /**
     * @hidden
     */
    var IgxBottomNavModule = /** @class */ (function () {
        function IgxBottomNavModule() {
        }
        return IgxBottomNavModule;
    }());
    IgxBottomNavModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                    exports: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                    imports: [i2.CommonModule, IgxBadgeModule, IgxIconModule]
                },] }
    ];

    /** @hidden */
    var IgxTabsBase = /** @class */ (function () {
        function IgxTabsBase() {
        }
        return IgxTabsBase;
    }());
    /** @hidden */
    var IgxTabItemBase = /** @class */ (function () {
        function IgxTabItemBase() {
        }
        Object.defineProperty(IgxTabItemBase.prototype, "index", {
            get: function () {
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        IgxTabItemBase.prototype.select = function () { };
        return IgxTabItemBase;
    }());
    /** @hidden */
    var IgxTabsGroupBase = /** @class */ (function () {
        function IgxTabsGroupBase() {
        }
        return IgxTabsGroupBase;
    }());

    var TabScrollButtonStyle;
    (function (TabScrollButtonStyle) {
        TabScrollButtonStyle["Visible"] = "visible";
        TabScrollButtonStyle["Hidden"] = "hidden";
        TabScrollButtonStyle["NotDisplayed"] = "not_displayed";
    })(TabScrollButtonStyle || (TabScrollButtonStyle = {}));
    var IgxRightButtonStyleDirective = /** @class */ (function () {
        function IgxRightButtonStyleDirective(tabs) {
            this.tabs = tabs;
        }
        Object.defineProperty(IgxRightButtonStyleDirective.prototype, "visibleCSS", {
            get: function () {
                return (this.getRightButtonStyle() === TabScrollButtonStyle.Visible) ? true : false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRightButtonStyleDirective.prototype, "hiddenCSS", {
            get: function () {
                return (this.getRightButtonStyle() === TabScrollButtonStyle.Hidden) ? true : false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxRightButtonStyleDirective.prototype, "notDisplayedCSS", {
            get: function () {
                return (this.getRightButtonStyle() === TabScrollButtonStyle.NotDisplayed) ? true : false;
            },
            enumerable: false,
            configurable: true
        });
        IgxRightButtonStyleDirective.prototype.getRightButtonStyle = function () {
            var viewPortWidth = this.tabs.viewPort.nativeElement.offsetWidth;
            // We use this hacky way to get the width of the itemsContainer,
            // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
            var itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
            var itemsContainerWidth = 0;
            if (itemsContainerChildrenCount > 1) {
                var lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
                itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
            }
            var headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
            var offset = this.tabs.offset;
            var total = offset + viewPortWidth;
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
                return TabScrollButtonStyle.NotDisplayed;
            }
            if (itemsContainerWidth > total) {
                return TabScrollButtonStyle.Visible;
            }
            else {
                return TabScrollButtonStyle.Hidden;
            }
        };
        return IgxRightButtonStyleDirective;
    }());
    IgxRightButtonStyleDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxRightButtonStyle]'
                },] }
    ];
    IgxRightButtonStyleDirective.ctorParameters = function () { return [
        { type: IgxTabsBase }
    ]; };
    IgxRightButtonStyleDirective.propDecorators = {
        visibleCSS: [{ type: i0.HostBinding, args: ['class.igx-tabs__header-button',] }],
        hiddenCSS: [{ type: i0.HostBinding, args: ['class.igx-tabs__header-button--hidden',] }],
        notDisplayedCSS: [{ type: i0.HostBinding, args: ['class.igx-tabs__header-button--none',] }]
    };
    var IgxLeftButtonStyleDirective = /** @class */ (function () {
        function IgxLeftButtonStyleDirective(tabs) {
            this.tabs = tabs;
        }
        Object.defineProperty(IgxLeftButtonStyleDirective.prototype, "visibleCSS", {
            get: function () {
                return (this.getLeftButtonStyle() === TabScrollButtonStyle.Visible) ? true : false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxLeftButtonStyleDirective.prototype, "hiddenCSS", {
            get: function () {
                return (this.getLeftButtonStyle() === TabScrollButtonStyle.Hidden) ? true : false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxLeftButtonStyleDirective.prototype, "notDisplayedCSS", {
            get: function () {
                return (this.getLeftButtonStyle() === TabScrollButtonStyle.NotDisplayed) ? true : false;
            },
            enumerable: false,
            configurable: true
        });
        IgxLeftButtonStyleDirective.prototype.getLeftButtonStyle = function () {
            // We use this hacky way to get the width of the itemsContainer,
            // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
            var itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
            var itemsContainerWidth = 0;
            if (itemsContainerChildrenCount > 1) {
                var lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
                itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
            }
            var headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
            var offset = this.tabs.offset;
            if (offset === 0) {
                // Fix for IE 11, a difference is accumulated from the widths calculations.
                if (itemsContainerWidth - headerContainerWidth <= 1) {
                    return TabScrollButtonStyle.NotDisplayed;
                }
                return TabScrollButtonStyle.Hidden;
            }
            else {
                return TabScrollButtonStyle.Visible;
            }
        };
        return IgxLeftButtonStyleDirective;
    }());
    IgxLeftButtonStyleDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxLeftButtonStyle]'
                },] }
    ];
    IgxLeftButtonStyleDirective.ctorParameters = function () { return [
        { type: IgxTabsBase }
    ]; };
    IgxLeftButtonStyleDirective.propDecorators = {
        visibleCSS: [{ type: i0.HostBinding, args: ['class.igx-tabs__header-button',] }],
        hiddenCSS: [{ type: i0.HostBinding, args: ['class.igx-tabs__header-button--hidden',] }],
        notDisplayedCSS: [{ type: i0.HostBinding, args: ['class.igx-tabs__header-button--none',] }]
    };
    var IgxTabItemTemplateDirective = /** @class */ (function () {
        function IgxTabItemTemplateDirective(template) {
            this.template = template;
        }
        return IgxTabItemTemplateDirective;
    }());
    IgxTabItemTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxTab]'
                },] }
    ];
    IgxTabItemTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };

    var IgxTabItemComponent = /** @class */ (function (_super) {
        __extends(IgxTabItemComponent, _super);
        function IgxTabItemComponent(_tabs, _element, _ngZone) {
            var _this = _super.call(this) || this;
            _this._tabs = _tabs;
            _this._element = _element;
            _this._ngZone = _ngZone;
            /**
             * @hidden @internal
             */
            _this.role = 'tab';
            /**
             * @hidden @internal
             */
            _this.tabindex = -1;
            /**
             * @hidden @internal
             */
            _this.ariaLabel = _this.label;
            /**
             * @hidden @internal
             */
            _this.ariaDisabled = _this.disabled;
            /**
             * @hidden @internal
             */
            _this.ariaSelected = _this.isSelected;
            _this._changesCount = 0; // changes and updates accordingly applied to the tab.
            _this._isSelected = false;
            _this._disabled = false;
            _this._nativeTabItem = _element;
            return _this;
        }
        Object.defineProperty(IgxTabItemComponent.prototype, "icon", {
            /**
             * An @Input property that sets the value of the `icon`.
             * The value should be valid icon name from {@link https://material.io/tools/icons/?style=baseline}.
             * ```html
             * <igx-tab-item label="Tab 1" icon="home">
             * ```
             */
            get: function () {
                return this.relatedGroup ? this.relatedGroup.icon : this._icon;
            },
            set: function (newValue) {
                if (this.relatedGroup) {
                    this.relatedGroup.icon = newValue;
                }
                this._icon = newValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "label", {
            /**
             * An @Input property that sets the value of the `label`.
             * ```html
             * <igx-tabs-item label="Tab 2" icon="folder">
             * ```
             */
            get: function () {
                return this.relatedGroup ? this.relatedGroup.label : this._label;
            },
            set: function (newValue) {
                if (this.relatedGroup) {
                    this.relatedGroup.label = newValue;
                }
                this._label = newValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "provideCssClassSelected", {
            get: function () {
                return this.isSelected;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "provideCssClassDisabled", {
            get: function () {
                return this.disabled;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "provideCssClass", {
            get: function () {
                return (!this.disabled && !this.isSelected);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTabItemComponent.prototype.onClick = function () {
            if (this.autoGenerated) {
                this.select();
            }
        };
        /**
         * @hidden
         */
        IgxTabItemComponent.prototype.onKeydown = function (event) {
            var tabsArray = this._tabs.tabs.toArray();
            var startIndex = tabsArray.indexOf(this);
            var finalIndex = -1;
            var currentIndex = startIndex;
            switch (event.key) {
                case "ArrowRight" /* RIGHT_ARROW */:
                case "Right" /* RIGHT_ARROW_IE */:
                    do {
                        currentIndex++;
                        if (currentIndex === tabsArray.length) {
                            currentIndex = -1;
                            continue;
                        }
                        else if (tabsArray[currentIndex].disabled === false) {
                            finalIndex = currentIndex;
                            break;
                        }
                    } while (currentIndex !== startIndex);
                    break;
                case "ArrowLeft" /* LEFT_ARROW */:
                case "Left" /* LEFT_ARROW_IE */:
                    do {
                        currentIndex--;
                        if (currentIndex === -1) {
                            currentIndex = tabsArray.length;
                            continue;
                        }
                        else if (tabsArray[currentIndex].disabled === false) {
                            finalIndex = currentIndex;
                            break;
                        }
                    } while (currentIndex !== startIndex);
                    break;
                case "Home" /* HOME */:
                    event.preventDefault();
                    finalIndex = tabsArray.find(function (t) { return t.disabled === false; }).index;
                    break;
                case "End" /* END */:
                    event.preventDefault();
                    finalIndex = tabsArray.slice().reverse().find(function (t) { return t.disabled === false; }).index;
                    break;
                case "Enter" /* ENTER */:
                    if (!this.autoGenerated) {
                        this.nativeTabItem.nativeElement.click();
                    }
                    break;
                case " " /* SPACE */:
                case "Spacebar" /* SPACE_IE */:
                    event.preventDefault();
                    if (!this.autoGenerated) {
                        this.nativeTabItem.nativeElement.click();
                    }
                    break;
                default:
                    break;
            }
            if (finalIndex > -1) {
                var tab = tabsArray[finalIndex];
                tab.nativeTabItem.nativeElement.focus();
                if (this.autoGenerated) {
                    tab.select();
                }
            }
        };
        IgxTabItemComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this._ngZone.runOutsideAngular(function () {
                _this._resizeObserver = new ResizeObserver__default['default'](function () {
                    _this._tabs.transformIndicatorAnimation(_this._nativeTabItem.nativeElement, 0);
                });
            });
        };
        IgxTabItemComponent.prototype.ngOnDestroy = function () {
            var _this = this;
            this._ngZone.runOutsideAngular(function () {
                _this._resizeObserver.disconnect();
            });
        };
        Object.defineProperty(IgxTabItemComponent.prototype, "changesCount", {
            /**
             * @hidden
             */
            get: function () {
                return this._changesCount;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "nativeTabItem", {
            /**
             * @hidden
             */
            get: function () {
                return this._nativeTabItem;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "disabled", {
            /**
             * 	Gets whether the tab is disabled.
             * ```
             * const disabledItem = this.myTabComponent.tabs.first.disabled;
             * ```
             */
            get: function () {
                return this.relatedGroup ? this.relatedGroup.disabled : this._disabled;
            },
            set: function (newValue) {
                if (this.relatedGroup) {
                    this.relatedGroup.disabled = newValue;
                }
                else {
                    this._disabled = newValue;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "isSelected", {
            /**
             * Gets whether the tab is selected.
             * ```typescript
             * const selectedItem = this.myTabComponent.tabs.first.isSelected;
             * ```
             */
            get: function () {
                return this.relatedGroup ? this.relatedGroup.isSelected : this._isSelected;
            },
            set: function (newValue) {
                if (!this.disabled && this.isSelected !== newValue) {
                    this._tabs.performSelectionChange(newValue ? this : null);
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTabItemComponent.prototype.select = function () {
            if (!this.disabled && !this.isSelected) {
                this._tabs.performSelectionChange(this);
            }
        };
        Object.defineProperty(IgxTabItemComponent.prototype, "index", {
            /**
             * @hidden
             */
            get: function () {
                if (this._tabs.tabs) {
                    return this._tabs.tabs.toArray().indexOf(this);
                }
                return -1;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTabItemComponent.prototype.setSelectedInternal = function (newValue) {
            var _this = this;
            this._isSelected = newValue;
            this._ngZone.runOutsideAngular(function () {
                if (_this._resizeObserver) {
                    if (_this._isSelected) {
                        _this._resizeObserver.observe(_this._element.nativeElement);
                    }
                    else {
                        _this._resizeObserver.disconnect();
                    }
                }
            });
            this.tabindex = newValue ? 0 : -1;
        };
        Object.defineProperty(IgxTabItemComponent.prototype, "template", {
            /**
             * @hidden
             */
            get: function () {
                if (this.relatedGroup && this.relatedGroup.customTabTemplate) {
                    return this.relatedGroup.customTabTemplate;
                }
                if (this.customTabTemplateDir) {
                    return this.customTabTemplateDir.template;
                }
                return this.defaultTabTemplate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "context", {
            /**
             * @hidden
             */
            get: function () {
                return this.relatedGroup ? this.relatedGroup : this;
            },
            enumerable: false,
            configurable: true
        });
        return IgxTabItemComponent;
    }(IgxTabItemBase));
    IgxTabItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-tab-item',
                    template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"igx-tabs__header-menu-item-icon\">\n        <igx-icon>{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"changesCount\" [hidden]=\"changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"igx-tabs__item-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>\n"
                },] }
    ];
    IgxTabItemComponent.ctorParameters = function () { return [
        { type: IgxTabsBase },
        { type: i0.ElementRef },
        { type: i0.NgZone }
    ]; };
    IgxTabItemComponent.propDecorators = {
        autoGenerated: [{ type: i0.Input }],
        relatedGroup: [{ type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        tabindex: [{ type: i0.HostBinding, args: ['attr.tabindex',] }],
        ariaLabel: [{ type: i0.HostBinding, args: ['attr.aria-label',] }],
        ariaDisabled: [{ type: i0.HostBinding, args: ['attr.aria-disabled',] }],
        ariaSelected: [{ type: i0.HostBinding, args: ['attr.aria-selected',] }],
        defaultTabTemplate: [{ type: i0.ViewChild, args: ['defaultTabTemplate', { read: i0.TemplateRef, static: true },] }],
        customTabTemplateDir: [{ type: i0.ContentChild, args: [IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective },] }],
        icon: [{ type: i0.Input }],
        label: [{ type: i0.Input }],
        provideCssClassSelected: [{ type: i0.HostBinding, args: ['class.igx-tabs__header-menu-item--selected',] }],
        provideCssClassDisabled: [{ type: i0.HostBinding, args: ['class.igx-tabs__header-menu-item--disabled',] }],
        provideCssClass: [{ type: i0.HostBinding, args: ['class.igx-tabs__header-menu-item',] }],
        onClick: [{ type: i0.HostListener, args: ['click',] }],
        onKeydown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }],
        disabled: [{ type: i0.Input }],
        isSelected: [{ type: i0.Input }]
    };

    var IgxTabsGroupComponent = /** @class */ (function (_super) {
        __extends(IgxTabsGroupComponent, _super);
        function IgxTabsGroupComponent(_tabs, _element) {
            var _this = _super.call(this) || this;
            _this._tabs = _tabs;
            _this._element = _element;
            /**
             * An @Input property that allows you to enable/disable the `IgxTabGroupComponent`.
             * ```html
             * <igx-tabs-group label="Tab 2  Lorem ipsum dolor sit" icon="home" [disabled]="true">
             * ```
             */
            _this.disabled = false;
            /**
             * @hidden
             */
            _this.role = 'tabpanel';
            /**
             * @hidden
             */
            _this.styleClass = true;
            _this._isSelected = false;
            return _this;
        }
        Object.defineProperty(IgxTabsGroupComponent.prototype, "isSelected", {
            /**
             * Sets/gets whether a tab group is selected.
             * ```typescript
             * this.tabGroup.isSelected = true;
             * ```
             * ```typescript
             * let isSelected = this.tabGroup.isSelected;
             * ```
             *
             * @memberof IgxTabsGroupComponent
             */
            get: function () {
                return this._isSelected;
            },
            set: function (newValue) {
                if (!this.disabled && this.isSelected !== newValue) {
                    this._tabs.performSelectionChange(newValue ? this.relatedTab : null);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabsGroupComponent.prototype, "nativeElement", {
            /**
             * Returns the native element of the tabs-group component
             * ```typescript
             *  const mytabsGroupElement: HTMLElement = tabsGroup.nativeElement;
             * ```
             */
            get: function () {
                return this._element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabsGroupComponent.prototype, "relatedTab", {
            /**
             * An accessor that returns the `IgxTabItemComponent` component.
             * ```typescript
             * @ViewChild("MyTabsGroup")
             * public tab: IgxTabsGroupComponent;
             * ngAfterViewInIt(){
             *    let tabComponent = this.tab.relatedTab;
             * }
             * ```
             */
            get: function () {
                if (this._tabs.tabs) {
                    return this._tabs.tabs.toArray()[this.index];
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabsGroupComponent.prototype, "index", {
            /**
             * An accessor that returns the value of the index of the `IgxTabsGroupComponent`.
             * ```typescript
             * @ViewChild("MyTabsGroup")
             * public tab: IgxTabsGroupComponent;
             * ngAfterViewInIt(){
             *    let tabIndex = this.tab.index;
             * }
             * ```
             */
            get: function () {
                if (this._tabs.groups) {
                    return this._tabs.groups.toArray().indexOf(this);
                }
                return -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabsGroupComponent.prototype, "customTabTemplate", {
            /**
             * @hidden
             */
            get: function () {
                return this._tabTemplate;
            },
            /**
             * @hidden
             */
            set: function (template) {
                this._tabTemplate = template;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTabsGroupComponent.prototype.ngAfterContentInit = function () {
            if (this.tabTemplate) {
                this._tabTemplate = this.tabTemplate.template;
            }
        };
        /**
         * A method that sets the focus on a tab.
         *
         * @memberof {@link IgxTabsGroupComponent}
         * ```typescript
         *  @ViewChild("MyChild")
         * public tab : IgxTabsGroupComponent;
         * ngAfterViewInit(){
         *     this.tab.select();
         * }
         * ```
         */
        IgxTabsGroupComponent.prototype.select = function () {
            if (!this.disabled && !this.isSelected) {
                this._tabs.performSelectionChange(this.relatedTab);
            }
        };
        /**
         * @hidden
         */
        IgxTabsGroupComponent.prototype.setSelectedInternal = function (newValue) {
            this._isSelected = newValue;
        };
        return IgxTabsGroupComponent;
    }(IgxTabsGroupBase));
    IgxTabsGroupComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-tabs-group',
                    template: "<ng-content *ngIf=\"isSelected\"></ng-content>\n"
                },] }
    ];
    IgxTabsGroupComponent.ctorParameters = function () { return [
        { type: IgxTabsBase },
        { type: i0.ElementRef }
    ]; };
    IgxTabsGroupComponent.propDecorators = {
        disabled: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        label: [{ type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        styleClass: [{ type: i0.HostBinding, args: ['class.igx-tabs__group',] }],
        tabTemplate: [{ type: i0.ContentChild, args: [IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective },] }]
    };

    var IgxTabsType = mkenum({
        FIXED: 'fixed',
        CONTENTFIT: 'contentfit'
    });
    var NEXT_TABS_ID = 0;
    var IgxTabsComponent = /** @class */ (function () {
        function IgxTabsComponent(_ngZone, platformUtil) {
            this._ngZone = _ngZone;
            this.platformUtil = platformUtil;
            /**
             * @hidden
             */
            this.selectedIndexChange = new i0.EventEmitter();
            /**
             * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
             * By default the header sizing mode is `contentfit`.
             * ```html
             * <igx-tabs type="fixed">
             *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
             * </igx-tabs>
             * ```
             */
            this.type = 'contentfit';
            /**
             * @hidden
             */
            this.class = '';
            /**
             * Emitted when a tab item is deselected.
             * ```html
             * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
             *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
             *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
             * </igx-tabs>
             * ```
             * ```typescript
             * itemDeselected(e){
             *      const tabGroup = e.group;
             *      const tabItem = e.tab;
             * }
             * ```
             */
            this.tabItemDeselected = new i0.EventEmitter();
            /**
             * Emitted when a tab item is selected.
             * ```html
             * <igx-tabs (tabItemSelected)="itemSelected($event)">
             *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
             *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
             * </igx-tabs>
             * ```
             * ```typescript
             * itemSelected(e){
             *      const tabGroup = e.group;
             *      const tabItem = e.tab;
             * }
             * ```
             */
            this.tabItemSelected = new i0.EventEmitter();
            /**
             * Enables/disables the transition animation of the tabs' content. Set to `false` by default.
             * ````html
             * <igx-tabs [disableAnimation]="true"></igx-tabs>
             */
            this.disableAnimation = false;
            this._currentTabsId = NEXT_TABS_ID++;
            /**
             * Sets/gets the `id` of the tabs.
             *
             * @remarks
             * If not set, the `id` will have value `"igx-tabs-0"`.
             *
             * @example
             * ```html
             * <igx-tabs id="my-first-tabs"></igx-tabs>
             * ```
             * @memberof IgxTabsComponent
             */
            // eslint-disable-next-line @typescript-eslint/member-ordering
            this.id = "igx-tabs-" + this._currentTabsId;
            /**
             * @hidden
             */
            // eslint-disable-next-line @typescript-eslint/member-ordering
            this.offset = 0;
            this._selectedIndex = -1;
        }
        Object.defineProperty(IgxTabsComponent.prototype, "selectedIndex", {
            /**
             * An @Input property that sets the value of the `selectedIndex`.
             * Default value is 0.
             * ```html
             * <igx-tabs selectedIndex="1">
             * ```
             *
             * Two-way data binding.
             * ```html
             * <igx-tabs [(selectedIndex)]="model.selectedIndex">
             * ```
             */
            get: function () {
                return this._selectedIndex;
            },
            set: function (index) {
                var newIndex = typeof index !== 'number' ? parseInt(index, 10) : index;
                if (this._selectedIndex !== newIndex) {
                    if (this.tabs && this.tabs.length > 0) {
                        var newTab = this.tabs.toArray()[newIndex];
                        if (newTab) {
                            this.performSelectionChange(newTab);
                        }
                    }
                    else {
                        this._selectedIndex = newIndex;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabsComponent.prototype, "tabs", {
            /**
             * Provides an observable collection of all `IgxTabItemComponent`s.
             * First try to get them as content children if not available get them as view children.
             * ```typescript
             * const tabItems = this.myTabComponent.tabs;
             * ```
             */
            get: function () {
                if (this.hasContentTabs) {
                    return this.contentTabs;
                }
                return this.viewTabs;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabsComponent.prototype, "hasContentTabs", {
            /**
             * @hidden
             */
            get: function () {
                return (this.contentTabs && this.contentTabs.length > 0);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTabsComponent.prototype, "cssClass", {
            /**
             * @hidden
             */
            get: function () {
                var defaultStyle = "igx-tabs";
                var fixedStyle = "igx-tabs--fixed";
                var iconStyle = "igx-tabs--icons";
                var iconLabelFoundInGroups = this.groups.find(function (group) { return group.icon != null && group.label != null; });
                var iconLabelFoundInTabs = this.contentTabs.find(function (tab) { return tab.icon != null && tab.label != null; });
                var css;
                switch (IgxTabsType[this.type.toUpperCase()]) {
                    case IgxTabsType.FIXED: {
                        css = fixedStyle;
                        break;
                    }
                    default: {
                        css = defaultStyle;
                        break;
                    }
                }
                // Layout fix for items with icons
                if (iconLabelFoundInGroups !== undefined || iconLabelFoundInTabs !== undefined) {
                    css = css + " " + iconStyle;
                }
                return css + " " + this.class;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.scrollLeft = function () {
            this.scroll(false);
        };
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.scrollRight = function () {
            this.scroll(true);
        };
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.scrollElement = function (element, scrollRight) {
            var viewPortWidth = this.viewPort.nativeElement.offsetWidth;
            this.offset = (scrollRight) ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
            this.itemsContainer.nativeElement.style.transform = "translate(" + -this.offset + "px)";
        };
        Object.defineProperty(IgxTabsComponent.prototype, "selectedTabItem", {
            /**
             * Gets the selected `IgxTabItemComponent`.
             * ```
             * const selectedItem = this.myTabComponent.selectedTabItem;
             * ```
             */
            get: function () {
                if (this.tabs && this.selectedIndex !== undefined) {
                    return this.tabs.toArray()[this.selectedIndex];
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this._selectedIndex === -1) {
                this.tabs.forEach(function (t) {
                    if (t.isSelected) {
                        _this._selectedIndex = t.index;
                    }
                });
            }
            if (!this.hasContentTabs && (this.selectedIndex < 0 || this.selectedIndex >= this.groups.length)) {
                this._selectedIndex = 0;
            }
            if (this.platformUtil.isBrowser) {
                requestAnimationFrame(function () {
                    var newTab = _this.tabs.toArray()[_this._selectedIndex];
                    if (newTab) {
                        _this.performSelection(newTab);
                    }
                    else {
                        _this.hideIndicator();
                    }
                });
                this._ngZone.runOutsideAngular(function () {
                    _this._resizeObserver = new ResizeObserver__default['default'](function () {
                        if (!_this.hasContentTabs && _this._selectedIndex >= 0 && _this._selectedIndex < _this.tabs.length) {
                            var newTab = _this.tabs.toArray()[_this._selectedIndex];
                            _this.transformContentAnimation(newTab, 0);
                        }
                    });
                    _this._resizeObserver.observe(_this.tabsContainer.nativeElement);
                });
            }
            this.setGroupsAttributes();
            this._groupChanges$ = this.groups.changes.subscribe(function () {
                _this.setGroupsAttributes();
                _this.resetSelectionOnCollectionChanged();
            });
        };
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.performSelectionChange = function (newTab) {
            var oldTab = this.selectedTabItem;
            if (oldTab) {
                this.performDeselection(oldTab);
            }
            if (newTab) {
                this.performSelection(newTab);
            }
            else {
                // if there is no new selected tab hide the selection indicator
                this.hideIndicator();
            }
            this.selectedIndexChange.emit(this._selectedIndex);
        };
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.getTabItemId = function (index) {
            return "igx-tab-item-" + this._currentTabsId + "-" + index;
        };
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.getTabsGroupId = function (index) {
            return "igx-tabs-group-" + this._currentTabsId + "-" + index;
        };
        /**
         * @hidden
         */
        // animation for the new panel/group (not needed for tab only mode)
        IgxTabsComponent.prototype.transformContentAnimation = function (tab, duration) {
            var contentOffset = this.tabsContainer.nativeElement.offsetWidth * tab.index;
            this.contentsContainer.nativeElement.style.transitionDuration = duration > 0 ? duration + "s" : 'initial';
            this.contentsContainer.nativeElement.style.transform = "translate(" + -contentOffset + "px)";
        };
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.transformIndicatorAnimation = function (element, duration) {
            if (duration === void 0) { duration = 0.3; }
            if (this.selectedIndicator) {
                this.selectedIndicator.nativeElement.style.visibility = 'visible';
                this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? duration + "s" : 'initial';
                this.selectedIndicator.nativeElement.style.width = element.offsetWidth + "px";
                this.selectedIndicator.nativeElement.style.transform = "translate(" + element.offsetLeft + "px)";
            }
        };
        IgxTabsComponent.prototype.hideIndicator = function () {
            if (this.selectedIndicator) {
                this.selectedIndicator.nativeElement.style.visibility = 'hidden';
            }
        };
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.ngOnDestroy = function () {
            var _this = this;
            if (this._groupChanges$) {
                this._groupChanges$.unsubscribe();
            }
            if (this._resizeObserver) {
                this._ngZone.runOutsideAngular(function () {
                    _this._resizeObserver.disconnect();
                });
            }
        };
        IgxTabsComponent.prototype.setGroupsAttributes = function () {
            var groupsArray = Array.from(this.groups);
            for (var index = 0; index < this.groups.length; index++) {
                var tabsGroup = groupsArray[index];
                tabsGroup.nativeElement.setAttribute('id', this.getTabsGroupId(index));
                tabsGroup.nativeElement.setAttribute('aria-labelledby', this.getTabItemId(index));
            }
        };
        IgxTabsComponent.prototype.resetSelectionOnCollectionChanged = function () {
            var _this = this;
            requestAnimationFrame(function () {
                var currentTab = _this.tabs.toArray()[_this.selectedIndex];
                if (currentTab) {
                    _this.performSelectionChange(currentTab);
                }
                else if (_this.selectedIndex >= _this.tabs.length) {
                    _this.performSelectionChange(_this.tabs.last);
                }
                else {
                    _this.hideIndicator();
                }
            });
        };
        IgxTabsComponent.prototype.scroll = function (scrollRight) {
            var e_1, _a;
            var tabsArray = this.tabs.toArray();
            try {
                for (var tabsArray_1 = __values(tabsArray), tabsArray_1_1 = tabsArray_1.next(); !tabsArray_1_1.done; tabsArray_1_1 = tabsArray_1.next()) {
                    var tab = tabsArray_1_1.value;
                    var element = tab.nativeTabItem.nativeElement;
                    if (scrollRight) {
                        if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                            this.scrollElement(element, scrollRight);
                            break;
                        }
                    }
                    else {
                        if (element.offsetWidth + element.offsetLeft >= this.offset) {
                            this.scrollElement(element, scrollRight);
                            break;
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (tabsArray_1_1 && !tabsArray_1_1.done && (_a = tabsArray_1.return)) _a.call(tabsArray_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        IgxTabsComponent.prototype.performDeselection = function (oldTab) {
            oldTab.setSelectedInternal(false);
            var oldTabRelatedGroup = this.groups.toArray()[oldTab.index];
            if (oldTabRelatedGroup) {
                oldTabRelatedGroup.setSelectedInternal(false);
            }
            this._selectedIndex = -1;
            this.tabItemDeselected.emit({ tab: oldTab, group: oldTabRelatedGroup });
        };
        IgxTabsComponent.prototype.performSelection = function (newTab) {
            var _this = this;
            newTab.setSelectedInternal(true);
            this._selectedIndex = newTab.index;
            var newTabRelatedGroup = null;
            if (!this.hasContentTabs && this.groups) {
                newTabRelatedGroup = this.groups.toArray()[newTab.index];
                if (newTabRelatedGroup) {
                    newTabRelatedGroup.setSelectedInternal(true);
                }
            }
            this.tabItemSelected.emit({ tab: newTab, group: newTabRelatedGroup });
            requestAnimationFrame(function () {
                var transitionDuration = _this.disableAnimation ? 0 : 0.2;
                // bring the new selected tab into view if it is not
                _this.bringNewTabIntoView(newTab);
                // animate the new selection indicator
                _this.transformIndicatorAnimation(newTab.nativeTabItem.nativeElement);
                // animate the new tab's group content
                if (!_this.hasContentTabs) {
                    _this.transformContentAnimation(newTab, transitionDuration);
                }
            });
        };
        IgxTabsComponent.prototype.bringNewTabIntoView = function (newTab) {
            var tabNativeElement = newTab.nativeTabItem.nativeElement;
            // Scroll left if there is need
            if (tabNativeElement.offsetLeft < this.offset) {
                this.scrollElement(tabNativeElement, false);
            }
            // Scroll right if there is need
            var viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
            var delta = (tabNativeElement.offsetLeft + tabNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
            // Fix for IE 11, a difference is accumulated from the widths calculations
            if (delta > 1) {
                this.scrollElement(tabNativeElement, true);
            }
        };
        return IgxTabsComponent;
    }());
    IgxTabsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-tabs',
                    template: "<!-- TODO Remove tab container from here -->\n<div #tabsContainer>\n    <div class=\"igx-tabs__header\" #headerContainer>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollLeft()\" igxLeftButtonStyle>\n            <igx-icon>navigate_before</igx-icon>\n        </button>\n        <div class=\"igx-tabs__header-wrapper-fixed\" #viewPort>\n            <div #itemsContainer class=\"igx-tabs__header-wrapper-fluid\">\n                <ng-container *ngIf=\"!hasContentTabs\">\n                    <igx-tab-item igxRipple\n                        *ngFor=\"let group of groups; let i = index\"\n                        [relatedGroup]=\"group\"\n                        [autoGenerated]=\"true\"\n                        [id]=\"getTabItemId(i)\"\n                        [attr.aria-controls]=\"getTabsGroupId(i)\">\n                    </igx-tab-item>\n                </ng-container>\n                <ng-content select=\"igx-tab-item\"></ng-content>\n                <div #selectedIndicator *ngIf=\"groups.length > 0 || contentTabs.length > 0\" class=\"igx-tabs__header-menu-item-indicator\"></div>\n            </div>\n        </div>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollRight()\" igxRightButtonStyle>\n            <igx-icon>navigate_next</igx-icon>\n        </button>\n    </div>\n    <div class=\"igx-tabs__content-fixed\">\n        <div #contentsContainer class=\"igx-tabs__content-fluid\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</div>\n",
                    providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }]
                },] }
    ];
    IgxTabsComponent.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: PlatformUtil }
    ]; };
    IgxTabsComponent.propDecorators = {
        groups: [{ type: i0.ContentChildren, args: [i0.forwardRef(function () { return IgxTabsGroupComponent; }),] }],
        contentTabs: [{ type: i0.ContentChildren, args: [i0.forwardRef(function () { return IgxTabItemComponent; }),] }],
        selectedIndex: [{ type: i0.Input }],
        selectedIndexChange: [{ type: i0.Output }],
        type: [{ type: i0.Input, args: ['type',] }],
        class: [{ type: i0.Input }],
        tabItemDeselected: [{ type: i0.Output }],
        tabItemSelected: [{ type: i0.Output }],
        contentsContainer: [{ type: i0.ViewChild, args: ['contentsContainer', { static: true },] }],
        headerContainer: [{ type: i0.ViewChild, args: ['headerContainer', { static: true },] }],
        itemsContainer: [{ type: i0.ViewChild, args: ['itemsContainer', { static: true },] }],
        selectedIndicator: [{ type: i0.ViewChild, args: ['selectedIndicator',] }],
        tabsContainer: [{ type: i0.ViewChild, args: ['tabsContainer', { static: true },] }],
        viewPort: [{ type: i0.ViewChild, args: ['viewPort', { static: true },] }],
        viewTabs: [{ type: i0.ViewChildren, args: [i0.forwardRef(function () { return IgxTabItemComponent; }),] }],
        disableAnimation: [{ type: i0.Input }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        cssClass: [{ type: i0.HostBinding, args: ['attr.class',] }]
    };
    /**
     * @hidden
     */
    var IgxTabsModule = /** @class */ (function () {
        function IgxTabsModule() {
        }
        return IgxTabsModule;
    }());
    IgxTabsModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxTabsComponent,
                        IgxTabsGroupComponent,
                        IgxTabItemComponent,
                        IgxTabItemTemplateDirective,
                        IgxRightButtonStyleDirective,
                        IgxLeftButtonStyleDirective],
                    exports: [IgxTabsComponent,
                        IgxTabsGroupComponent,
                        IgxTabItemComponent,
                        IgxTabItemTemplateDirective,
                        IgxRightButtonStyleDirective,
                        IgxLeftButtonStyleDirective],
                    imports: [i2.CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]
                },] }
    ];

    /** @hidden */
    var IGX_TIME_PICKER_COMPONENT = 'IgxTimePickerComponentToken';
    /** @hidden */
    var TimeParts;
    (function (TimeParts) {
        TimeParts["Hour"] = "hour";
        TimeParts["Minute"] = "minute";
        TimeParts["Seconds"] = "seconds";
        TimeParts["AMPM"] = "ampm";
    })(TimeParts || (TimeParts = {}));

    /**
     * This file contains all the directives used by the @link IgxTimePickerComponent.
     * You should generally not use them directly.
     *
     * @preferred
     */
    /** @hidden */
    var IgxItemListDirective = /** @class */ (function () {
        function IgxItemListDirective(timePicker, elementRef) {
            this.timePicker = timePicker;
            this.elementRef = elementRef;
            this.tabindex = 0;
        }
        Object.defineProperty(IgxItemListDirective.prototype, "defaultCSS", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxItemListDirective.prototype, "hourCSS", {
            get: function () {
                return this.type === 'hourList';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxItemListDirective.prototype, "minuteCSS", {
            get: function () {
                return this.type === 'minuteList';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxItemListDirective.prototype, "secondsCSS", {
            get: function () {
                return this.type === 'secondsList';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxItemListDirective.prototype, "ampmCSS", {
            get: function () {
                return this.type === 'ampmList';
            },
            enumerable: false,
            configurable: true
        });
        IgxItemListDirective.prototype.onFocus = function () {
            this.isActive = true;
        };
        IgxItemListDirective.prototype.onBlur = function () {
            this.isActive = false;
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onKeydownArrowDown = function (event) {
            event.preventDefault();
            this.nextItem();
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onKeydownArrowUp = function (event) {
            event.preventDefault();
            this.prevItem();
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onKeydownArrowRight = function (event) {
            event.preventDefault();
            var listName = event.target.className;
            if (listName.indexOf('hourList') !== -1 && this.timePicker.minuteList) {
                this.timePicker.minuteList.nativeElement.focus();
            }
            else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1) && this.timePicker.secondsList) {
                this.timePicker.secondsList.nativeElement.focus();
            }
            else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1 ||
                listName.indexOf('secondsList') !== -1) && this.timePicker.ampmList) {
                this.timePicker.ampmList.nativeElement.focus();
            }
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onKeydownArrowLeft = function (event) {
            event.preventDefault();
            var listName = event.target.className;
            if (listName.indexOf('ampmList') !== -1 && this.timePicker.secondsList) {
                this.timePicker.secondsList.nativeElement.focus();
            }
            else if (listName.indexOf('secondsList') !== -1 && this.timePicker.secondsList
                && listName.indexOf('minutesList') && this.timePicker.minuteList) {
                this.timePicker.minuteList.nativeElement.focus();
            }
            else if (listName.indexOf('ampmList') !== -1 && this.timePicker.minuteList) {
                this.timePicker.minuteList.nativeElement.focus();
            }
            else if ((listName.indexOf('ampmList') !== -1 || listName.indexOf('secondsList') !== -1 ||
                listName.indexOf('minuteList') !== -1) && this.timePicker.hourList) {
                this.timePicker.hourList.nativeElement.focus();
            }
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onKeydownEnter = function (event) {
            event.preventDefault();
            if (this.timePicker.mode === InteractionMode.DropDown) {
                this.timePicker.close();
                return;
            }
            this.timePicker.okButtonClick();
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onKeydownEscape = function (event) {
            event.preventDefault();
            this.timePicker.cancelButtonClick();
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onHover = function () {
            this.elementRef.nativeElement.focus();
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onScroll = function (event) {
            event.preventDefault();
            event.stopPropagation();
            if (event.deltaY > 0) {
                this.nextItem();
            }
            else if (event.deltaY < 0) {
                this.prevItem();
            }
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onPanMove = function (event) {
            if (event.deltaY < 0) {
                this.nextItem();
            }
            else if (event.deltaY > 0) {
                this.prevItem();
            }
        };
        IgxItemListDirective.prototype.nextItem = function () {
            switch (this.type) {
                case 'hourList': {
                    this.timePicker.nextHour();
                    break;
                }
                case 'minuteList': {
                    this.timePicker.nextMinute();
                    break;
                }
                case 'secondsList': {
                    this.timePicker.nextSeconds();
                    break;
                }
                case 'ampmList': {
                    this.timePicker.nextAmPm();
                    break;
                }
            }
        };
        IgxItemListDirective.prototype.prevItem = function () {
            switch (this.type) {
                case 'hourList': {
                    this.timePicker.prevHour();
                    break;
                }
                case 'minuteList': {
                    this.timePicker.prevMinute();
                    break;
                }
                case 'secondsList': {
                    this.timePicker.prevSeconds();
                    break;
                }
                case 'ampmList': {
                    this.timePicker.prevAmPm();
                    break;
                }
            }
        };
        return IgxItemListDirective;
    }());
    IgxItemListDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxItemList]'
                },] }
    ];
    IgxItemListDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
        { type: i0.ElementRef }
    ]; };
    IgxItemListDirective.propDecorators = {
        tabindex: [{ type: i0.HostBinding, args: ['attr.tabindex',] }],
        type: [{ type: i0.Input, args: ['igxItemList',] }],
        defaultCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__column',] }],
        hourCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__hourList',] }],
        minuteCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__minuteList',] }],
        secondsCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__secondsList',] }],
        ampmCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__ampmList',] }],
        onFocus: [{ type: i0.HostListener, args: ['focus',] }],
        onBlur: [{ type: i0.HostListener, args: ['blur',] }],
        onKeydownArrowDown: [{ type: i0.HostListener, args: ['keydown.arrowdown', ['$event'],] }],
        onKeydownArrowUp: [{ type: i0.HostListener, args: ['keydown.arrowup', ['$event'],] }],
        onKeydownArrowRight: [{ type: i0.HostListener, args: ['keydown.arrowright', ['$event'],] }],
        onKeydownArrowLeft: [{ type: i0.HostListener, args: ['keydown.arrowleft', ['$event'],] }],
        onKeydownEnter: [{ type: i0.HostListener, args: ['keydown.enter', ['$event'],] }],
        onKeydownEscape: [{ type: i0.HostListener, args: ['keydown.escape', ['$event'],] }],
        onHover: [{ type: i0.HostListener, args: ['mouseover',] }],
        onScroll: [{ type: i0.HostListener, args: ['wheel', ['$event'],] }],
        onPanMove: [{ type: i0.HostListener, args: ['panmove', ['$event'],] }]
    };
    /**
     * @hidden
     */
    var IgxHourItemDirective = /** @class */ (function () {
        function IgxHourItemDirective(timePicker, itemList) {
            this.timePicker = timePicker;
            this.itemList = itemList;
        }
        Object.defineProperty(IgxHourItemDirective.prototype, "defaultCSS", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHourItemDirective.prototype, "selectedCSS", {
            get: function () {
                return this.isSelectedHour;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHourItemDirective.prototype, "activeCSS", {
            get: function () {
                return this.isSelectedHour && this.itemList.isActive;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxHourItemDirective.prototype, "isSelectedHour", {
            get: function () {
                return this.timePicker.selectedHour === this.value;
            },
            enumerable: false,
            configurable: true
        });
        IgxHourItemDirective.prototype.onClick = function (item) {
            if (item !== '') {
                this.timePicker.scrollHourIntoView(item);
            }
        };
        return IgxHourItemDirective;
    }());
    IgxHourItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxHourItem]'
                },] }
    ];
    IgxHourItemDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
        { type: IgxItemListDirective }
    ]; };
    IgxHourItemDirective.propDecorators = {
        value: [{ type: i0.Input, args: ['igxHourItem',] }],
        defaultCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__item',] }],
        selectedCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__item--selected',] }],
        activeCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__item--active',] }],
        onClick: [{ type: i0.HostListener, args: ['click', ['value'],] }]
    };
    /**
     * @hidden
     */
    var IgxMinuteItemDirective = /** @class */ (function () {
        function IgxMinuteItemDirective(timePicker, itemList) {
            this.timePicker = timePicker;
            this.itemList = itemList;
        }
        Object.defineProperty(IgxMinuteItemDirective.prototype, "defaultCSS", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMinuteItemDirective.prototype, "selectedCSS", {
            get: function () {
                return this.isSelectedMinute;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMinuteItemDirective.prototype, "activeCSS", {
            get: function () {
                return this.isSelectedMinute && this.itemList.isActive;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxMinuteItemDirective.prototype, "isSelectedMinute", {
            get: function () {
                return this.timePicker.selectedMinute === this.value;
            },
            enumerable: false,
            configurable: true
        });
        IgxMinuteItemDirective.prototype.onClick = function (item) {
            if (item !== '') {
                this.timePicker.scrollMinuteIntoView(item);
            }
        };
        return IgxMinuteItemDirective;
    }());
    IgxMinuteItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxMinuteItem]'
                },] }
    ];
    IgxMinuteItemDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
        { type: IgxItemListDirective }
    ]; };
    IgxMinuteItemDirective.propDecorators = {
        value: [{ type: i0.Input, args: ['igxMinuteItem',] }],
        defaultCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__item',] }],
        selectedCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__item--selected',] }],
        activeCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__item--active',] }],
        onClick: [{ type: i0.HostListener, args: ['click', ['value'],] }]
    };
    /**
     * @hidden
     */
    var IgxSecondsItemDirective = /** @class */ (function () {
        function IgxSecondsItemDirective(timePicker, itemList) {
            this.timePicker = timePicker;
            this.itemList = itemList;
        }
        Object.defineProperty(IgxSecondsItemDirective.prototype, "defaultCSS", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSecondsItemDirective.prototype, "selectedCSS", {
            get: function () {
                return this.isSelectedSeconds;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSecondsItemDirective.prototype, "activeCSS", {
            get: function () {
                return this.isSelectedSeconds && this.itemList.isActive;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSecondsItemDirective.prototype, "isSelectedSeconds", {
            get: function () {
                return this.timePicker.selectedSeconds === this.value;
            },
            enumerable: false,
            configurable: true
        });
        IgxSecondsItemDirective.prototype.onClick = function (item) {
            if (item !== '') {
                this.timePicker.scrollSecondsIntoView(item);
            }
        };
        return IgxSecondsItemDirective;
    }());
    IgxSecondsItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxSecondsItem]'
                },] }
    ];
    IgxSecondsItemDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
        { type: IgxItemListDirective }
    ]; };
    IgxSecondsItemDirective.propDecorators = {
        value: [{ type: i0.Input, args: ['igxSecondsItem',] }],
        defaultCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__item',] }],
        selectedCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__item--selected',] }],
        activeCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__item--active',] }],
        onClick: [{ type: i0.HostListener, args: ['click', ['value'],] }]
    };
    /**
     * @hidden
     */
    var IgxAmPmItemDirective = /** @class */ (function () {
        function IgxAmPmItemDirective(timePicker, itemList) {
            this.timePicker = timePicker;
            this.itemList = itemList;
        }
        Object.defineProperty(IgxAmPmItemDirective.prototype, "defaultCSS", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAmPmItemDirective.prototype, "selectedCSS", {
            get: function () {
                return this.isSelectedAmPm;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAmPmItemDirective.prototype, "activeCSS", {
            get: function () {
                return this.isSelectedAmPm && this.itemList.isActive;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxAmPmItemDirective.prototype, "isSelectedAmPm", {
            get: function () {
                return this.timePicker.selectedAmPm === this.value;
            },
            enumerable: false,
            configurable: true
        });
        IgxAmPmItemDirective.prototype.onClick = function (item) {
            if (item !== '') {
                this.timePicker.scrollAmPmIntoView(item);
            }
        };
        return IgxAmPmItemDirective;
    }());
    IgxAmPmItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxAmPmItem]'
                },] }
    ];
    IgxAmPmItemDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
        { type: IgxItemListDirective }
    ]; };
    IgxAmPmItemDirective.propDecorators = {
        value: [{ type: i0.Input, args: ['igxAmPmItem',] }],
        defaultCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__item',] }],
        selectedCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__item--selected',] }],
        activeCSS: [{ type: i0.HostBinding, args: ['class.igx-time-picker__item--active',] }],
        onClick: [{ type: i0.HostListener, args: ['click', ['value'],] }]
    };
    /**
     * This directive should be used to mark which ng-template will be used from IgxTimePicker when re-templating its input group.
     */
    var IgxTimePickerTemplateDirective = /** @class */ (function () {
        function IgxTimePickerTemplateDirective(template) {
            this.template = template;
        }
        return IgxTimePickerTemplateDirective;
    }());
    IgxTimePickerTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxTimePickerTemplate]'
                },] }
    ];
    IgxTimePickerTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    /**
     * This directive can be used to add custom action buttons to the dropdownb/dialog.
     */
    var IgxTimePickerActionsDirective = /** @class */ (function () {
        function IgxTimePickerActionsDirective(template) {
            this.template = template;
        }
        return IgxTimePickerActionsDirective;
    }());
    IgxTimePickerActionsDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxTimePickerActions]'
                },] }
    ];
    IgxTimePickerActionsDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };

    /**
     * Formats `IgxTimePickerComponent` display value according to the `format` property,
     * when the input element loses focus.
     */
    var TimeDisplayFormatPipe = /** @class */ (function () {
        function TimeDisplayFormatPipe(timePicker) {
            this.timePicker = timePicker;
        }
        TimeDisplayFormatPipe.prototype.transform = function (value) {
            var hour;
            var minutes;
            var seconds;
            var amPM;
            var maskAmPM = this.timePicker.parseMask();
            var mask = this.timePicker.parseMask(false);
            if (!value || value === mask || value === maskAmPM) {
                return '';
            }
            var sections = value.split(/[\s:]+/);
            if (this.timePicker.showHoursList) {
                hour = sections[0];
            }
            if (this.timePicker.showMinutesList) {
                minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
            }
            if (this.timePicker.showSecondsList) {
                seconds = sections[sections.length - (this.timePicker.showAmPmList ? 2 : 1)];
            }
            if (this.timePicker.showAmPmList) {
                amPM = sections[sections.length - 1];
            }
            var format = this.timePicker.format;
            var prompt = this.timePicker.promptChar;
            var regExp = new RegExp(this.timePicker.promptChar, 'g');
            if (format.indexOf('hh') !== -1 || format.indexOf('HH') !== -1 && hour.indexOf(prompt) !== -1) {
                hour = hour === prompt + prompt ? '00' : hour.replace(regExp, '0');
            }
            if (format.indexOf('mm') !== -1 && minutes.indexOf(prompt) !== -1) {
                minutes = minutes === prompt + prompt ? '00' : minutes.replace(regExp, '0');
            }
            if (format.indexOf('ss') !== -1 && seconds.indexOf(prompt) !== -1) {
                seconds = seconds === prompt + prompt ? '00' : seconds.replace(regExp, '0');
            }
            if (format.indexOf('hh') === -1 && format.indexOf('HH') === -1 && hour !== undefined) {
                hour = hour.indexOf(prompt) !== -1 ? hour.replace(regExp, '') : hour;
                var hourVal = parseInt(hour, 10);
                hour = !hourVal ? '0' : hourVal < 10 && hourVal !== 0 ? hour.replace('0', '') : hour;
            }
            if (format.indexOf('mm') === -1 && minutes !== undefined) {
                minutes = minutes.indexOf(prompt) !== -1 ? minutes.replace(regExp, '') : minutes;
                var minutesVal = parseInt(minutes, 10);
                minutes = !minutesVal ? '0' : minutesVal < 10 && minutesVal !== 0 ? minutes.replace('0', '') : minutes;
            }
            if (format.indexOf('ss') === -1 && seconds !== undefined) {
                seconds = seconds.indexOf(prompt) !== -1 ? seconds.replace(regExp, '') : seconds;
                var secondsVal = parseInt(seconds, 10);
                seconds = !secondsVal ? '0' : secondsVal < 10 && secondsVal !== 0 ? seconds.replace('0', '') : seconds;
            }
            if (format.indexOf('tt') !== -1 && (amPM !== 'AM' || amPM !== 'PM')) {
                amPM = amPM.indexOf('p') !== -1 || amPM.indexOf('P') !== -1 ? 'PM' : 'AM';
            }
            var result = hour + ":" + minutes + ":" + seconds;
            if (!hour) {
                // remove the hours
                result = result.slice(result.indexOf(':') + 1);
            }
            if (!minutes) {
                if (hour) {
                    // get the hours and seconds and concat them
                    result = result.slice(0, result.indexOf(':')) +
                        result.slice(result.lastIndexOf(':'), result.length);
                }
                else {
                    // remove the minutes
                    result = result.slice(result.indexOf(':') + 1);
                }
            }
            if (!seconds) {
                // remove the seconds
                result = result.slice(0, result.lastIndexOf(':'));
            }
            return amPM ? result + " " + amPM : result;
        };
        return TimeDisplayFormatPipe;
    }());
    TimeDisplayFormatPipe.decorators = [
        { type: i0.Pipe, args: [{ name: 'displayFormat' },] }
    ];
    TimeDisplayFormatPipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] }
    ]; };
    /**
     * Formats `IgxTimePickerComponent` display value according to the `format` property,
     * when the input element gets focus.
     */
    var TimeInputFormatPipe = /** @class */ (function () {
        function TimeInputFormatPipe(timePicker) {
            this.timePicker = timePicker;
        }
        TimeInputFormatPipe.prototype.transform = function (value) {
            var prompt = this.timePicker.promptChar;
            var regExp = new RegExp(prompt, 'g');
            var mask;
            var hour;
            var minutes;
            var seconds;
            var amPM;
            if (this.timePicker.cleared) {
                this.timePicker.cleared = false;
                mask = this.timePicker.parseMask(false);
            }
            else {
                mask = this.timePicker.parseMask();
            }
            // TODO: Pending refactoring.
            value = this.timePicker.displayValue;
            if (!value || value === mask) {
                return mask;
            }
            var sections = value.split(/[\s:]+/);
            if (this.timePicker.showHoursList) {
                hour = sections[0];
                hour = hour.replace(regExp, '');
                var leadZeroHour = (parseInt(hour, 10) < 10 && !hour.startsWith('0')) || hour === '0';
                hour = leadZeroHour ? '0' + hour : hour;
            }
            if (this.timePicker.showMinutesList) {
                minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
                minutes = minutes.replace(regExp, '');
                var leadZeroMinutes = (parseInt(minutes, 10) < 10 && !minutes.startsWith('0')) || minutes === '0';
                minutes = leadZeroMinutes ? '0' + minutes : minutes;
            }
            if (this.timePicker.showSecondsList) {
                seconds = sections[sections.length - (this.timePicker.showAmPmList ? 2 : 1)];
                seconds = seconds.replace(regExp, '');
                var leadZeroSeconds = (parseInt(seconds, 10) < 10 && !seconds.startsWith('0')) || seconds === '0';
                seconds = leadZeroSeconds ? '0' + seconds : seconds;
            }
            if (this.timePicker.showAmPmList) {
                amPM = sections[sections.length - 1];
            }
            var result = hour + ":" + minutes + ":" + seconds;
            if (!hour) {
                // remove the hours
                result = result.slice(result.indexOf(':') + 1);
            }
            if (!minutes) {
                if (hour) {
                    // get the hours and seconds and concat them
                    result = result.slice(0, result.indexOf(':')) +
                        result.slice(result.lastIndexOf(':'), result.length);
                }
                else {
                    // remove the minutes
                    result = result.slice(result.indexOf(':') + 1);
                }
            }
            if (!seconds) {
                // remove the seconds
                result = result.slice(0, result.lastIndexOf(':'));
            }
            return amPM ? result + " " + amPM : result;
        };
        return TimeInputFormatPipe;
    }());
    TimeInputFormatPipe.decorators = [
        { type: i0.Pipe, args: [{ name: 'inputFormat' },] }
    ];
    TimeInputFormatPipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] }
    ]; };

    var NEXT_ID$s = 0;
    var ITEMS_COUNT = 7;
    var TimePickerHammerConfig = /** @class */ (function (_super) {
        __extends(TimePickerHammerConfig, _super);
        function TimePickerHammerConfig() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.overrides = {
                pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
            };
            return _this;
        }
        return TimePickerHammerConfig;
    }(i1$1.HammerGestureConfig));
    TimePickerHammerConfig.decorators = [
        { type: i0.Injectable }
    ];
    var IgxTimePickerComponent = /** @class */ (function () {
        function IgxTimePickerComponent(_injector, _cdr) {
            this._injector = _injector;
            this._cdr = _cdr;
            /**
             * An @Input property that sets the value of the `id` attribute.
             * ```html
             * <igx-time-picker [id]="'igx-time-picker-5'" format="h:mm tt" ></igx-time-picker>
             * ```
             */
            this.id = "igx-time-picker-" + NEXT_ID$s++;
            /**
             * An @Input property that allows you to disable the `igx-time-picker` component. By default `disabled` is set to false.
             * ```html
             * <igx-time-picker [disabled]="'true'" [vertical]="true" format="h:mm tt" ></igx-time-picker>
             * ```
             */
            this.disabled = false;
            /**
             * An @Input property that determines the spin behavior. By default `isSpinLoop` is set to true.
             * The seconds, minutes and hour spinning will wrap around by default.
             * ```html
             * <igx-time-picker [isSpinLoop]="false" id="time-picker"></igx-time-picker>
             * ```
             */
            this.isSpinLoop = true;
            /**
             * An @Input property that Gets/Sets the orientation of the `igxTimePicker`. By default `vertical` is set to false.
             * ```html
             * <igx-time-picker [vertical]="true" id="time-picker"></igx-time-picker>
             * ```
             */
            this.vertical = false;
            /**
             * Sets the character used to prompt the user for input.
             * Default value is "'-'".
             * ```html
             * <igx-time-picker [promptChar] = "'_'">
             * ```
             *
             * @memberof IgxTimePickerComponent
             */
            this.promptChar = '-';
            /**
             * An @Input property that allows you to switch the interaction mode between
             * a dialog picker or dropdown with editable masked input.
             * Deafult is dialog picker.
             * ```html
             * public mode = InteractionMode.DROPDOWN;
             *  //..
             * <igx-time-picker [mode]="mode"></igx-time-picker>
             * ```
             *
             * @memberof IgxTimePickerComponent
             */
            this.mode = InteractionMode.Dialog;
            /**
             * Emitted when selection is made. The event contains the selected value. Returns {`oldValue`: `Date`, `newValue`: `Date`}.
             * ```typescript
             *  @ViewChild("toast")
             * private toast: IgxToastComponent;
             * public onValueChanged(timepicker){
             *     this.toast.open()
             * }
             *  //...
             *  ```
             *  ```html
             * <igx-time-picker (onValueChanged)="onValueChanged($event)"></igx-time-picker>
             * <igx-toast #toast message="The value has been changed!"></igx-toast>
             * ```
             */
            this.onValueChanged = new i0.EventEmitter();
            /**
             * Emitted when an invalid value is being set. Returns {`timePicker`: `any`, `currentValue`: `Date`, `setThroughUI`: `boolean`}
             * ```typescript
             * public min: string = "09:00";
             * public max: string = "18:00";
             *  @ViewChild("toast")
             * private toast: IgxToastComponent;
             * public onValidationFailed(timepicker){
             *     this.toast.open();
             * }
             *  //...
             *  ```
             *  ```html
             * <igx-time-picker [minValue]="min" [maxValue]="max" (onValidationFailed)="onValidationFailed($event)"></igx-time-picker>
             * <igx-toast #toast message="Value must be between 09:00 and 18:00!"></igx-toast>
             * ```
             */
            this.onValidationFailed = new i0.EventEmitter();
            /**
             * Emitted when a timePicker is opened.
             */
            this.onOpened = new i0.EventEmitter();
            /**
             * Emitted when a timePicker is closed.
             */
            this.onClosed = new i0.EventEmitter();
            /**
             * Emitted when a timePicker is being closed.
             */
            this.onClosing = new i0.EventEmitter();
            /**
             * @hidden @internal
             */
            this.timeParts = Object.assign({}, TimeParts);
            /**
             * @hidden
             */
            this._hourItems = [];
            /**
             * @hidden
             */
            this._minuteItems = [];
            /**
             * @hidden
             */
            this._secondsItems = [];
            /**
             * @hidden
             */
            this._ampmItems = [];
            /**
             * @hidden
             */
            this.cleared = false;
            /**
             * @hidden
             */
            this.isNotEmpty = false;
            /**
             * @hidden
             */
            this.displayFormat = new TimeDisplayFormatPipe(this);
            /**
             * @hidden
             */
            this.inputFormat = new TimeInputFormatPipe(this);
            this._resourceStrings = CurrentResourceStrings.TimePickerResStrings;
            this._okButtonLabel = null;
            this._cancelButtonLabel = null;
            this._itemsDelta = { hours: 1, minutes: 1, seconds: 1 };
            this._isHourListLoop = this.isSpinLoop;
            this._isMinuteListLoop = this.isSpinLoop;
            this._isSecondsListLoop = this.isSpinLoop;
            this._hourView = [];
            this._minuteView = [];
            this._secondsView = [];
            this._ampmView = [];
            this._destroy$ = new rxjs.Subject();
            this._onOpen = new i0.EventEmitter();
            this._onClose = new i0.EventEmitter();
            this._hoursPos = new Set();
            this._minutesPos = new Set();
            this._secondsPos = new Set();
            this._amPmPos = new Set();
            this._ngControl = null;
            this._onChangeCallback = rxjs.noop;
            this._onTouchedCallback = rxjs.noop;
        }
        Object.defineProperty(IgxTimePickerComponent.prototype, "mask", {
            /**
             * @hidden
             */
            get: function () {
                return this._mask || '00:00 LL';
            },
            set: function (val) {
                this._mask = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "displayValue", {
            /**
             * @hidden
             */
            get: function () {
                if (this._displayValue === undefined) {
                    return this._formatTime(this.value, this.format);
                }
                return this._displayValue;
            },
            set: function (value) {
                this._displayValue = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "displayTime", {
            /**
             * Returns the current time formatted as string using the `format` option.
             * If there is no set time the return is an empty string.
             * ```typescript
             * @ViewChild("MyChild")
             * private picker: IgxTimePickerComponent;
             * ngAfterViewInit(){
             *    let time = this.picker.displayTime;
             * }
             * ```
             */
            get: function () {
                if (this.value) {
                    return this._formatTime(this.value, this.format);
                }
                return '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "hourView", {
            /**
             * @hidden
             */
            get: function () {
                return this._hourView;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "minuteView", {
            /**
             * @hidden
             */
            get: function () {
                return this._minuteView;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "secondsView", {
            /**
             * @hidden
             */
            get: function () {
                return this._secondsView;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "ampmView", {
            /**
             * @hidden
             */
            get: function () {
                return this._ampmView;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "showClearButton", {
            /**
             * @hidden
             */
            get: function () {
                return (this.displayValue && this.displayValue !== this.parseMask(false)) || this.isNotEmpty;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "showHoursList", {
            /**
             * @hidden
             */
            get: function () {
                return this.format.indexOf('h') !== -1 || this.format.indexOf('H') !== -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "showMinutesList", {
            /**
             * @hidden
             */
            get: function () {
                return this.format.indexOf('m') !== -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "showSecondsList", {
            /**
             * @hidden
             */
            get: function () {
                return this.format.indexOf('s') !== -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "showAmPmList", {
            /**
             * @hidden
             */
            get: function () {
                return this.format.indexOf('t') !== -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "validSecondsEntries", {
            /**
             * @hidden
             */
            get: function () {
                var secondsEntries = [];
                for (var i = 0; i < 60; i++) {
                    secondsEntries.push(i);
                }
                return secondsEntries;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "validMinuteEntries", {
            /**
             * @hidden
             */
            get: function () {
                var minuteEntries = [];
                for (var i = 0; i < 60; i++) {
                    minuteEntries.push(i);
                }
                return minuteEntries;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "validHourEntries", {
            /**
             * @hidden
             */
            get: function () {
                var hourEntries = [];
                var index = this.format.indexOf('h') !== -1 ? 13 : 24;
                for (var i = 0; i < index; i++) {
                    hourEntries.push(i);
                }
                return hourEntries;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "template", {
            /**
             * Gets the input group template.
             * ```typescript
             * let template = this.template();
             * ```
             *
             * @memberof IgxTimePickerComponent
             */
            get: function () {
                if (this.timePickerTemplateDirective) {
                    return this.timePickerTemplateDirective.template;
                }
                return this.mode === InteractionMode.Dialog ? this.defaultTimePickerTemplate : this.dropdownInputTemplate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "context", {
            /**
             * Gets the context passed to the input group template.
             *
             * @memberof IgxTimePickerComponent
             */
            get: function () {
                var _this = this;
                return {
                    value: this.value,
                    displayTime: this.displayTime,
                    displayValue: this.displayValue,
                    openDialog: function (target) { return _this.openDialog(target); }
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "required", {
            get: function () {
                if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
                    // Run the validation with empty object to check if required is enabled.
                    var error = this._ngControl.control.validator({});
                    return error && error.required;
                }
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "value", {
            /**
             * An accessor that returns the value of `igx-time-picker` component.
             * ```html
             * @ViewChild("MyPick")
             * public pick: IgxTimePickerComponent;
             * ngAfterViewInit(){
             *    let pickSelect = this.pick.value;
             * }
             * ```
             */
            get: function () {
                return this._value;
            },
            /**
             * An accessor that allows you to set a time using the `value` input.
             * ```html
             * public date: Date = new Date(Date.now());
             *  //...
             * <igx-time-picker [value]="date" format="h:mm tt"></igx-time-picker>
             * ```
             */
            set: function (value) {
                if (this._isValueValid(value)) {
                    var oldVal = this._value;
                    this._value = value;
                    this._onChangeCallback(value);
                    var dispVal = this._formatTime(this.value, this.format);
                    if (this.mode === InteractionMode.DropDown && this._displayValue !== dispVal) {
                        this.displayValue = dispVal;
                    }
                    var args = {
                        oldValue: oldVal,
                        newValue: value
                    };
                    this.onValueChanged.emit(args);
                }
                else {
                    var args = {
                        timePicker: this,
                        currentValue: value,
                        setThroughUI: false
                    };
                    this.onValidationFailed.emit(args);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "resourceStrings", {
            /**
             * An accessor that returns the resource strings.
             */
            get: function () {
                return this._resourceStrings;
            },
            /**
             * An accessor that sets the resource strings.
             * By default it uses EN resources.
             */
            set: function (value) {
                this._resourceStrings = Object.assign({}, this._resourceStrings, value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "okButtonLabel", {
            /**
             * An accessor that returns the label of ok button.
             */
            get: function () {
                if (this._okButtonLabel === null) {
                    return this.resourceStrings.igx_time_picker_ok;
                }
                return this._okButtonLabel;
            },
            /**
             * An @Input property that renders OK button with custom text. By default `okButtonLabel` is set to OK.
             * ```html
             * <igx-time-picker okButtonLabel='SET' [value]="date" format="h:mm tt"></igx-time-picker>
             * ```
             */
            set: function (value) {
                this._okButtonLabel = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "cancelButtonLabel", {
            /**
             * An accessor that returns the label of cancel button.
             */
            get: function () {
                if (this._cancelButtonLabel === null) {
                    return this.resourceStrings.igx_time_picker_cancel;
                }
                return this._cancelButtonLabel;
            },
            /**
             * An @Input property that renders cancel button with custom text.
             * By default `cancelButtonLabel` is set to Cancel.
             * ```html
             * <igx-time-picker cancelButtonLabel='Exit' [value]="date" format="h:mm tt"></igx-time-picker>
             * ```
             */
            set: function (value) {
                this._cancelButtonLabel = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "itemsDelta", {
            get: function () {
                return this._itemsDelta;
            },
            /**
             * An @Input property that gets/sets the delta by which hour and minute items would be changed <br>
             * when the user presses the Up/Down keys.
             * By default `itemsDelta` is set to `{hours: 1, minutes: 1, seconds: 1}`
             * ```html
             * <igx-time-picker [itemsDelta]="{hours:3, minutes:5, seconds:10}" id="time-picker"></igx-time-picker>
             * ```
             */
            set: function (value) {
                this._itemsDelta = Object.assign({ hours: 1, minutes: 1, seconds: 1 }, value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "format", {
            /**
             * An @Input property that Gets/Sets format of time while `igxTimePicker` does not have focus. <br>
             * By default `format` is set to hh:mm tt. <br>
             * List of time-flags: <br>
             * `h` : hours field in 12-hours format without leading zero <br>
             * `hh` : hours field in 12-hours format with leading zero <br>
             * `H` : hours field in 24-hours format without leading zero <br>
             * `HH` : hours field in 24-hours format with leading zero <br>
             * `m` : minutes field without leading zero <br>
             * `mm` : minutes field with leading zero <br>
             * `s` : seconds field without leading zero <br>
             * `ss` : seconds field with leading zero <br>
             * `tt` : 2 character string which represents AM/PM field <br>
             * ```html
             * <igx-time-picker format="HH:m" id="time-picker"></igx-time-picker>
             * ```
             */
            get: function () {
                return this._format || 'hh:mm tt';
            },
            set: function (formatValue) {
                this._format = formatValue;
                this.mask = this._format.indexOf('tt') !== -1 ? '00:00:00 LL' : '00:00:00';
                if (!this.showHoursList || !this.showMinutesList) {
                    this.trimMask();
                }
                if (!this.showSecondsList) {
                    this.trimMask();
                }
                if (this.displayValue) {
                    this.displayValue = this._formatTime(this.value, this._format);
                }
                this.determineCursorPos();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "overlaySettings", {
            get: function () {
                return this._overlaySettings ? this._overlaySettings :
                    (this.mode === InteractionMode.Dialog ? this._dialogOverlaySettings : this._dropDownOverlaySettings);
            },
            /**
             * An @Input property that allows you to modify overlay positioning, interaction and scroll behavior.
             * ```typescript
             * const settings: OverlaySettings = {
             *      closeOnOutsideClick: true,
             *      modal: false
             *  }
             * ```
             * ---
             * ```html
             * <igx-time-picker [overlaySettings]="settings"></igx-time-picker>
             * ```
             *
             * @memberof IgxTimePickerComponent
             */
            set: function (value) {
                this._overlaySettings = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.onKeydownSpace = function (event) {
            this.openDialog(this.getInputGroupElement());
            event.preventDefault();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.onAltArrowDown = function () {
            this.openDialog(this.getInputGroupElement());
        };
        //#region ControlValueAccessor
        /** @hidden @internal */
        IgxTimePickerComponent.prototype.writeValue = function (value) {
            // use this flag to make sure that min/maxValue are checked (in _convertMinMaxValue() method)
            // against the real value when initializing the component and value is bound via ngModel
            this._dateFromModel = value;
            this._value = value;
            if (this.mode === InteractionMode.DropDown) {
                this.displayValue = this._formatTime(this.value, this.format);
            }
        };
        /** @hidden @internal */
        IgxTimePickerComponent.prototype.applyDisabledStyleForItem = function (period, value) {
            if (!this.minValue || !this.maxValue) {
                return false;
            }
            var minValueDate = this.convertMinMaxValue(this.minValue);
            var maxValueDate = this.convertMinMaxValue(this.maxValue);
            var hour = parseInt(this.selectedHour, 10);
            var minute = parseInt(this.selectedMinute, 10);
            var seconds = parseInt(this.selectedSeconds, 10);
            var amPM = this.selectedAmPm;
            var date = new Date(minValueDate);
            switch (period) {
                case TimeParts.Hour:
                    hour = parseInt(value, 10);
                    break;
                case TimeParts.Minute:
                    minute = parseInt(value, 10);
                    break;
                case TimeParts.Seconds:
                    seconds = parseInt(value, 10);
                    break;
                case TimeParts.AMPM:
                    amPM = value;
                    break;
            }
            if (amPM === 'PM') {
                hour += 12;
            }
            date.setHours(hour);
            date.setMinutes(minute);
            date.setSeconds(seconds);
            return date < minValueDate || date > maxValueDate;
        };
        /** @hidden @internal */
        IgxTimePickerComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /** @hidden @internal */
        IgxTimePickerComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /** @hidden @internal */
        IgxTimePickerComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        //#endregion
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.ngOnInit = function () {
            this._generateHours();
            this._generateMinutes();
            this._generateSeconds();
            if (this.format.indexOf('tt') !== -1) {
                this._generateAmPm();
            }
            this._dropDownOverlaySettings = {
                modal: false,
                closeOnOutsideClick: true,
                scrollStrategy: new AbsoluteScrollStrategy(),
                positionStrategy: new AutoPositionStrategy()
            };
            this._dialogOverlaySettings = {};
            this._ngControl = this._injector.get(forms.NgControl, null);
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this.mode === InteractionMode.DropDown && this._inputElementRef) {
                rxjs.fromEvent(this._inputElementRef.nativeElement, 'keydown').pipe(operators.throttle(function () { return rxjs.interval(0, rxjs.animationFrameScheduler); }), operators.takeUntil(this._destroy$)).subscribe(function (event) {
                    if (event.key === "ArrowUp" /* UP_ARROW */ || event.key === "Up" /* UP_ARROW_IE */ ||
                        event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */) {
                        _this.spinOnEdit(event);
                    }
                });
            }
            if (this.toggleRef && this._inputGroup) {
                this.toggleRef.element.style.width = this._inputGroup.element.nativeElement.getBoundingClientRect().width + 'px';
            }
            if (this.toggleRef) {
                this.toggleRef.onClosed.pipe(operators.takeUntil(this._destroy$)).subscribe(function () {
                    if (_this.mode === InteractionMode.DropDown) {
                        _this._onDropDownClosed();
                    }
                    _this.onClosed.emit(_this);
                });
                this.toggleRef.onOpened.pipe(operators.takeUntil(this._destroy$)).subscribe(function () {
                    _this.onOpened.emit(_this);
                });
                this.toggleRef.onClosing.pipe(operators.takeUntil(this._destroy$)).subscribe(function (event) {
                    _this.onClosing.emit(event);
                    // If canceled in a user onClosing handler
                    if (event.cancel) {
                        return;
                    }
                    // Do not focus the input if clicking outside in dropdown mode
                    var input = _this.getEditElement();
                    if (input && !(event.event && _this.mode === InteractionMode.DropDown)) {
                        input.focus();
                    }
                    else {
                        _this._updateValidityOnBlur();
                    }
                });
                this.determineCursorPos();
                if (this._ngControl) {
                    this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
                }
            }
        };
        IgxTimePickerComponent.prototype.ngAfterViewChecked = function () {
            // if one sets mode at run time this forces initialization of new igxInputGroup
            // As a result a new igxInputDirective is initialized too. In ngAfterViewInit of
            // the new directive isRequired of the igxInputGroup is set again. However
            // ngAfterViewInit of the time picker is not called again and we may finish with wrong
            // isRequired in igxInputGroup. This is why we should set it her, only when needed
            if (this._inputGroup && this._inputGroup.isRequired !== this.required) {
                this._inputGroup.isRequired = this.required;
                this._cdr.detectChanges();
            }
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next(true);
            this._destroy$.complete();
            if (this._statusChanges$) {
                this._statusChanges$.unsubscribe();
            }
        };
        /** @hidden @internal */
        IgxTimePickerComponent.prototype.convertMinMaxValue = function (value) {
            if (!value) {
                return;
            }
            var date = this.value ? new Date(this.value) : this._dateFromModel ? new Date(this._dateFromModel) : new Date();
            var sections = value.split(/[\s:]+/);
            var hour;
            var minutes;
            var seconds;
            var amPM;
            date.setSeconds(0);
            if (this.showHoursList) {
                hour = sections[0];
                date.setHours(parseInt(hour, 10));
            }
            if (this.showMinutesList) {
                minutes = this.showHoursList ? sections[1] : sections[0];
                date.setMinutes(parseInt(minutes, 10));
            }
            if (this.showSecondsList) {
                seconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
                date.setSeconds(parseInt(seconds, 10));
            }
            if (this.showAmPmList) {
                amPM = sections[sections.length - 1].toUpperCase();
                if (((this.showHoursList && date.getHours().toString() !== '12') ||
                    (!this.showHoursList && date.getHours().toString() <= '11')) && amPM === 'PM') {
                    date.setHours(date.getHours() + 12);
                }
                if (!this.showHoursList && amPM === 'AM' && date.getHours().toString() > '11') {
                    date.setHours(date.getHours() - 12);
                }
                if (this.showHoursList && date.getHours() === 12 && amPM === 'AM') {
                    date.setHours(0);
                }
            }
            return date;
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.getEditElement = function () {
            return this._inputElementRef ? this._inputElementRef.nativeElement : null;
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.getInputGroupElement = function () {
            return this._inputGroup ? this._inputGroup.element.nativeElement : null;
        };
        /**
         * opens the dialog.
         *
         * @param target HTMLElement - the target element to use for positioning the drop down container according to
         * ```html
         * <igx-time-picker [value]="date" mode="dropdown" #retemplated>
         *   <ng-template igxTimePickerTemplate let-openDialog="openDialog"
         *                let-displayTime="displayTime">
         *     <igx-input-group>
         *       <input #dropDownTarget igxInput [value]="displayTime" />
         *       <igx-suffix (click)="openDialog(dropDownTarget)">
         *         <igx-icon>alarm</igx-icon>
         *       </igx-suffix>
         *     </igx-input-group>
         *   </ng-template>
         * </igx-time-picker>
         * ```
         */
        IgxTimePickerComponent.prototype.openDialog = function (target) {
            if (!this.toggleRef.collapsed) {
                return this._onDropDownClosed();
            }
            var settings = this.overlaySettings;
            if (target && settings && settings.positionStrategy) {
                settings.target = target;
            }
            if (this.outlet) {
                settings.outlet = this.outlet;
            }
            this.toggleRef.open(settings);
            this._initializeContainer();
        };
        /**
         * Scrolls a hour item into view.
         * ```typescript
         * scrhintoView(picker) {
         * picker.scrollHourIntoView('2');
         * }
         *  ```
         * ```html
         * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrhintoView(picker)"></igx-time-picker>
         * ```
         *
         * @param item to be scrolled in view.
         */
        IgxTimePickerComponent.prototype.scrollHourIntoView = function (item) {
            if (this.showHoursList) {
                var hourIntoView = this._scrollItemIntoView(item, this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
                if (hourIntoView) {
                    this._hourView = hourIntoView.view;
                    this.selectedHour = hourIntoView.selectedItem;
                    this._updateEditableInput();
                }
            }
        };
        /**
         * Scrolls a minute item into view.
         * ```typescript
         * scrMintoView(picker) {
         * picker.scrollMinuteIntoView('3');
         * }
         *  ```
         * ```html
         * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrMintoView(picker)"></igx-time-picker>
         * ```
         *
         * @param item to be scrolled in view.
         */
        IgxTimePickerComponent.prototype.scrollMinuteIntoView = function (item) {
            if (this.showMinutesList) {
                var minuteIntoView = this._scrollItemIntoView(item, this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
                if (minuteIntoView) {
                    this._minuteView = minuteIntoView.view;
                    this.selectedMinute = minuteIntoView.selectedItem;
                    this._updateEditableInput();
                }
            }
        };
        /**
         * Scrolls a seconds item into view.
         * ```typescript
         * scrMintoView(picker) {
         * picker.scrollSecondsIntoView('4');
         * }
         *  ```
         * ```html
         * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrMintoView(picker)"></igx-time-picker>
         * ```
         *
         * @param item to be scrolled in view.
         */
        IgxTimePickerComponent.prototype.scrollSecondsIntoView = function (item) {
            if (this.showSecondsList) {
                var secondsIntoView = this._scrollItemIntoView(item, this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
                if (secondsIntoView) {
                    this._secondsView = secondsIntoView.view;
                    this.selectedSeconds = secondsIntoView.selectedItem;
                    this._updateEditableInput();
                }
            }
        };
        /**
         * Scrolls an ampm item into view.
         * ```typescript
         * scrAmPmIntoView(picker) {
         * picker.scrollAmPmIntoView('PM');
         * }
         *  ```
         * ```html
         * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrAmPmIntoView(picker)"></igx-time-picker>
         * ```
         *
         * @param item to be scrolled in view.
         */
        IgxTimePickerComponent.prototype.scrollAmPmIntoView = function (item) {
            if (this.showAmPmList) {
                var ampmIntoView = this._scrollItemIntoView(item, this._ampmItems, this.selectedAmPm, false, null);
                if (ampmIntoView) {
                    this._ampmView = ampmIntoView.view;
                    this.selectedAmPm = ampmIntoView.selectedItem;
                    this._updateEditableInput();
                }
            }
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.nextHour = function () {
            var nextHour = this._nextItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
            this._hourView = nextHour.view;
            this.selectedHour = nextHour.selectedItem;
            this._updateEditableInput();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.prevHour = function () {
            var prevHour = this._prevItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
            this._hourView = prevHour.view;
            this.selectedHour = prevHour.selectedItem;
            this._updateEditableInput();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.nextMinute = function () {
            var nextMinute = this._nextItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
            this._minuteView = nextMinute.view;
            this.selectedMinute = nextMinute.selectedItem;
            this._updateEditableInput();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.prevMinute = function () {
            var prevMinute = this._prevItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
            this._minuteView = prevMinute.view;
            this.selectedMinute = prevMinute.selectedItem;
            this._updateEditableInput();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.nextSeconds = function () {
            var nextSeconds = this._nextItem(this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
            this._secondsView = nextSeconds.view;
            this.selectedSeconds = nextSeconds.selectedItem;
            this._updateEditableInput();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.prevSeconds = function () {
            var prevSeconds = this._prevItem(this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
            this._secondsView = prevSeconds.view;
            this.selectedSeconds = prevSeconds.selectedItem;
            this._updateEditableInput();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.nextAmPm = function () {
            var selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
            if (selectedIndex + 1 < this._ampmItems.length - 3) {
                this._updateAmPmView(selectedIndex - 2, selectedIndex + 5);
                this.selectedAmPm = this._ampmItems[selectedIndex + 1];
                this._updateEditableInput();
            }
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.prevAmPm = function () {
            var selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
            if (selectedIndex > 3) {
                this._updateAmPmView(selectedIndex - 4, selectedIndex + 3);
                this.selectedAmPm = this._ampmItems[selectedIndex - 1];
                this._updateEditableInput();
            }
        };
        /**
         * If current value is valid selects it, closes the dialog and returns true, otherwise returns false.
         * ```html
         * <igx-dialog class="igx-time-picker__dialog-popup" [rightButtonLabel]="okButtonLabel" (onRightButtonSelect)="okButtonClick()">
         * //..
         * </igx-dialog>
         * ```
         */
        IgxTimePickerComponent.prototype.okButtonClick = function () {
            var time = this._getSelectedTime();
            if (this._isValueValid(time)) {
                this.close();
                this.value = time;
                return true;
            }
            else {
                var args = {
                    timePicker: this,
                    currentValue: time,
                    setThroughUI: true
                };
                this.onValidationFailed.emit(args);
                return false;
            }
        };
        /**
         * Closes the dialog without selecting the current value.
         * ```html
         * <igx-dialog class="igx-time-picker__dialog-popup" [leftButtonLabel]="cancelButtonLabel" (onLeftButtonSelect)="cancelButtonClick()">
         * //...
         * </igx-dialog>
         * ```
         */
        IgxTimePickerComponent.prototype.cancelButtonClick = function () {
            if (this.mode === InteractionMode.DropDown) {
                this.displayValue = this.value ? this._formatTime(this.value, this.format) : this.parseMask(false);
            }
            this.close();
            this.selectedHour = this._prevSelectedHour;
            this.selectedMinute = this._prevSelectedMinute;
            this.selectedSeconds = this._prevSelectedSeconds;
            this.selectedAmPm = this._prevSelectedAmPm;
        };
        /**
         * Returns an array of the hours currently in view.
         * ```html
         *  @ViewChild("MyChild")
         * private picker: IgxTimePickerComponent;
         * ngAfterViewInit(){
         *     let hInView = this.picker.hoursInView;
         * }
         * ```
         */
        IgxTimePickerComponent.prototype.hoursInView = function () {
            return this._hourView.filter(function (hour) { return hour !== ''; });
        };
        /**
         * Returns an array of the minutes currently in view.
         * ```html
         *  @ViewChild("MyChild")
         * private picker: IgxTimePickerComponent;
         * ngAfterViewInit(){
         *     let minInView = this.picker.minutesInView;
         * }
         * ```
         */
        IgxTimePickerComponent.prototype.minutesInView = function () {
            return this._minuteView.filter(function (minute) { return minute !== ''; });
        };
        /**
         * Returns an array of the seconds currently in view.
         * ```html
         *  @ViewChild("MyChild")
         * private picker: IgxTimePickerComponent;
         * ngAfterViewInit(){
         *     let minInView = this.picker.secondsInView;
         * }
         * ```
         */
        IgxTimePickerComponent.prototype.secondsInView = function () {
            return this._secondsView.filter(function (seconds) { return seconds !== ''; });
        };
        /**
         * Returns an array of the AM/PM currently in view.
         * ```html
         *  @ViewChild("MyChild")
         * private picker: IgxTimePickerComponent;
         * ngAfterViewInit(){
         *     let ApInView = this.picker.ampmInView;
         * }
         * ```
         */
        IgxTimePickerComponent.prototype.ampmInView = function () {
            return this._ampmView.filter(function (ampm) { return ampm !== ''; });
        };
        /**
         * Closes the dropdown/dialog.
         * ```html
         * <igx-time-picker #timePicker></igx-time-picker>
         * ```
         * ```typescript
         * @ViewChild('timePicker', { read: IgxTimePickerComponent }) picker: IgxTimePickerComponent;
         * picker.close();
         * ```
         */
        IgxTimePickerComponent.prototype.close = function () {
            this.toggleRef.close();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.parseMask = function (preserveAmPm) {
            if (preserveAmPm === void 0) { preserveAmPm = true; }
            var maskWithAmPm = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace('LL', 'AM');
            var pureMask = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace(new RegExp('L', 'g'), this.promptChar);
            return preserveAmPm ? maskWithAmPm : pureMask;
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.clear = function () {
            var _this = this;
            var _a, _b;
            if (this.toggleRef.collapsed) {
                this.cleared = true;
                this.isNotEmpty = false;
                var oldVal = new Date(this.value);
                this.displayValue = this.parseMask(false);
                requestAnimationFrame(function () {
                    _this._setCursorPosition(0);
                });
                // TODO: refactoring - this.value should be null #6585
                (_a = this.value) === null || _a === void 0 ? void 0 : _a.setHours(0, 0, 0);
                if (oldVal.getTime() !== ((_b = this.value) === null || _b === void 0 ? void 0 : _b.getTime()) || this.isReset()) {
                    var args = {
                        oldValue: oldVal,
                        newValue: this.value
                    };
                    this.onValueChanged.emit(args);
                }
            }
            else {
                this.close();
            }
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.onInput = function (event) {
            var _a, _b;
            var inputMask = event.target.value;
            var oldVal = new Date(this.value);
            this.isNotEmpty = inputMask !== this.parseMask(false);
            // handle cases where all empty positions (promts) are filled and we want to update
            // timepicker own value property if it is a valid Date
            if (inputMask.indexOf(this.promptChar) === -1) {
                if (this._isEntryValid(inputMask)) {
                    var newVal = this.convertMinMaxValue(inputMask);
                    if (oldVal.getTime() !== newVal.getTime()) {
                        this.value = newVal;
                    }
                }
                else {
                    var args = {
                        timePicker: this,
                        currentValue: new Date(inputMask),
                        setThroughUI: false
                    };
                    this.onValidationFailed.emit(args);
                }
                // handle cases where the user deletes the display value (when pressing backspace or delete)
            }
            else if (!this.value || inputMask.length === 0 || !this.isNotEmpty) {
                this.isNotEmpty = false;
                // TODO: refactoring - this.value should be null #6585
                (_a = this.value) === null || _a === void 0 ? void 0 : _a.setHours(0, 0, 0);
                this.displayValue = inputMask;
                if (oldVal.getTime() !== ((_b = this.value) === null || _b === void 0 ? void 0 : _b.getTime()) || this.isReset()) {
                    // TODO: Do not emit event when the editor is empty #6482
                    var args = {
                        oldValue: oldVal,
                        newValue: this.value
                    };
                    this.onValueChanged.emit(args);
                }
            }
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.onFocus = function (event) {
            this.isNotEmpty = event.target.value !== this.parseMask(false);
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.onBlur = function (event) {
            if (this.mode === InteractionMode.DropDown) {
                var value = event.target.value;
                this.isNotEmpty = value !== '';
                this.displayValue = value;
                if (value && (value !== this.parseMask() || value !== this.parseMask(false))) {
                    if (this._isEntryValid(value)) {
                        var newVal = this.convertMinMaxValue(value);
                        if (!this.value || this.value.getTime() !== newVal.getTime()) {
                            this.value = newVal;
                        }
                    }
                    else {
                        var args = {
                            timePicker: this,
                            currentValue: value,
                            setThroughUI: false
                        };
                        this.onValidationFailed.emit(args);
                    }
                }
            }
            if (this.toggleRef.collapsed) {
                this._updateValidityOnBlur();
            }
        };
        IgxTimePickerComponent.prototype.mouseDown = function (event) {
            // if the click is not on the input but in input group
            // e.g. on prefix or suffix, prevent default and this way prevent blur
            if (event.target !== this.getEditElement()) {
                event.preventDefault();
            }
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.spinOnEdit = function (event) {
            var _this = this;
            event.preventDefault();
            var sign;
            var displayVal;
            var currentVal = new Date(this.value);
            var min = this.minValue ? this.convertMinMaxValue(this.minValue) : this.convertMinMaxValue('00:00');
            var max = this.maxValue ? this.convertMinMaxValue(this.maxValue) : this.convertMinMaxValue('24:00');
            var cursor = this._getCursorPosition();
            if (event.key) {
                var key = event.key;
                sign = key === "ArrowDown" /* DOWN_ARROW */ || key === "Down" /* DOWN_ARROW_IE */ ? -1 : 1;
            }
            if (event.deltaY) {
                sign = event.deltaY < 0 ? 1 : -1;
            }
            if (!this.displayValue) {
                this.value = min;
                displayVal = this._formatTime(this.value, this.format);
            }
            else {
                var hDelta = this.itemsDelta.hours * 60 + (sign * this.value.getMinutes());
                var mDelta = this.itemsDelta.minutes;
                var sDelta = this.itemsDelta.seconds;
                if (this.cursorOnHours(cursor, this.showHoursList)) {
                    this.value = this._spinHours(currentVal, min, max, hDelta, sign);
                }
                if (this.cursorOnMinutes(cursor, this.showHoursList, this.showMinutesList)) {
                    this.value = this._spinMinutes(currentVal, mDelta, sign);
                }
                if (this.cursorOnSeconds(cursor, this.showHoursList, this.showMinutesList, this.showSecondsList)) {
                    this.value = this._spinSeconds(currentVal, sDelta, sign);
                }
                if (this.cursorOnAmPm(cursor, this.showHoursList, this.showMinutesList, this.showSecondsList, this.showAmPmList)) {
                    var sections = this.displayValue.split(/[\s:]+/);
                    sign = sections[sections.length - 1] === 'AM' ? 1 : -1;
                    currentVal.setHours(currentVal.getHours() + (sign * 12));
                    this.value = currentVal;
                }
                displayVal = this._formatTime(this.value, this.format);
            }
            // minor hack for preventing cursor jumping in IE
            this._displayValue = this.inputFormat.transform(displayVal);
            this._inputElementRef.nativeElement.value = this._displayValue;
            this._setCursorPosition(cursor);
            requestAnimationFrame(function () {
                _this._setCursorPosition(cursor);
            });
        };
        IgxTimePickerComponent.prototype.onStatusChanged = function () {
            if ((this._ngControl.control.touched || this._ngControl.control.dirty) &&
                (this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {
                var input = this._inputDirective || this._inputDirectiveUserTemplate;
                if (this._inputGroup.isFocused) {
                    input.valid = this._ngControl.valid ? exports.IgxInputState.VALID : exports.IgxInputState.INVALID;
                }
                else {
                    input.valid = this._ngControl.valid ? exports.IgxInputState.INITIAL : exports.IgxInputState.INVALID;
                }
            }
            if (this._inputGroup && this._inputGroup.isRequired !== this.required) {
                this._inputGroup.isRequired = this.required;
            }
        };
        IgxTimePickerComponent.prototype.trimMask = function () {
            this.mask = this.mask.slice(this.mask.indexOf(':') + 1, this.mask.length);
        };
        IgxTimePickerComponent.prototype.determineCursorPos = function () {
            var e_1, _d;
            this.clearCursorPos();
            try {
                for (var _e = __values(this.format), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var char = _f.value;
                    switch (char) {
                        case 'H':
                        case 'h':
                            if (this._hoursPos.size === 0) {
                                this._hoursPos.add(this.format.indexOf(char));
                            }
                            else {
                                this._hoursPos.add(this.format.lastIndexOf(char));
                            }
                            this._hoursPos.add(this.format.lastIndexOf(char) + 1);
                            break;
                        case 'M':
                        case 'm':
                            if (this._minutesPos.size === 0) {
                                this._minutesPos.add(this.format.indexOf(char));
                            }
                            else {
                                this._minutesPos.add(this.format.lastIndexOf(char));
                            }
                            this._minutesPos.add(this.format.lastIndexOf(char) + 1);
                            break;
                        case 'S':
                        case 's':
                            if (this._secondsPos.size === 0) {
                                this._secondsPos.add(this.format.indexOf(char));
                            }
                            else {
                                this._secondsPos.add(this.format.lastIndexOf(char));
                            }
                            this._secondsPos.add(this.format.lastIndexOf(char) + 1);
                            break;
                        case 'T':
                        case 't':
                            if (this._amPmPos.size === 0) {
                                this._amPmPos.add(this.format.indexOf(char));
                            }
                            else {
                                this._amPmPos.add(this.format.lastIndexOf(char));
                            }
                            this._amPmPos.add(this.format.lastIndexOf(char) + 1);
                            break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_d = _e.return)) _d.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        IgxTimePickerComponent.prototype.clearCursorPos = function () {
            var _this = this;
            this._hoursPos.forEach(function (v) { return _this._hoursPos.delete(v); });
            this._minutesPos.forEach(function (v) { return _this._minutesPos.delete(v); });
            this._secondsPos.forEach(function (v) { return _this._secondsPos.delete(v); });
            this._amPmPos.forEach(function (v) { return _this._amPmPos.delete(v); });
        };
        IgxTimePickerComponent.prototype._scrollItemIntoView = function (item, items, selectedItem, isListLoop, viewType) {
            var itemIntoView;
            if (items) {
                var index = (item === 'AM' || item === 'PM') ? items.indexOf(item) : items.indexOf(parseInt(item, 10));
                var view = void 0;
                if (index !== -1) {
                    if (isListLoop) {
                        if (index > 0) {
                            selectedItem = this._itemToString(items[index - 1], viewType);
                            itemIntoView = this._nextItem(items, selectedItem, isListLoop, viewType);
                        }
                        else {
                            selectedItem = this._itemToString(items[1], viewType);
                            itemIntoView = this._prevItem(items, selectedItem, isListLoop, viewType);
                        }
                    }
                    else {
                        view = items.slice(index - 3, index + 4);
                        selectedItem = this._itemToString(items[index], viewType);
                        itemIntoView = { selectedItem: selectedItem, view: view };
                    }
                    itemIntoView.view = this._viewToString(itemIntoView.view, viewType);
                }
            }
            return itemIntoView;
        };
        IgxTimePickerComponent.prototype._viewToString = function (view, viewType) {
            for (var i = 0; i < view.length; i++) {
                if (typeof (view[i]) !== 'string') {
                    view[i] = this._itemToString(view[i], viewType);
                }
            }
            return view;
        };
        IgxTimePickerComponent.prototype._itemToString = function (item, viewType) {
            if (item === null) {
                item = '';
            }
            else if (viewType && typeof (item) !== 'string') {
                var leadZeroHour = (item < 10 && (this.format.indexOf('hh') !== -1 || this.format.indexOf('HH') !== -1));
                var leadZeroMinute = (item < 10 && this.format.indexOf('mm') !== -1);
                var leadZeroSeconds = (item < 10 && this.format.indexOf('ss') !== -1);
                var leadZero = {
                    hour: leadZeroHour,
                    minute: leadZeroMinute,
                    seconds: leadZeroSeconds
                }[viewType];
                item = (leadZero) ? '0' + item : "" + item;
            }
            return item;
        };
        IgxTimePickerComponent.prototype._prevItem = function (items, selectedItem, isListLoop, viewType) {
            var selectedIndex = items.indexOf(parseInt(selectedItem, 10));
            var itemsCount = items.length;
            var view;
            if (selectedIndex === -1) {
                view = items.slice(0, 7);
                selectedItem = items[3];
            }
            else if (isListLoop) {
                if (selectedIndex - 4 < 0) {
                    view = items.slice(itemsCount - (4 - selectedIndex), itemsCount);
                    view = view.concat(items.slice(0, selectedIndex + 3));
                }
                else if (selectedIndex + 4 > itemsCount) {
                    view = items.slice(selectedIndex - 4, itemsCount);
                    view = view.concat(items.slice(0, selectedIndex + 3 - itemsCount));
                }
                else {
                    view = items.slice(selectedIndex - 4, selectedIndex + 3);
                }
                selectedItem = (selectedIndex === 0) ? items[itemsCount - 1] : items[selectedIndex - 1];
            }
            else if (selectedIndex > 3) {
                view = items.slice(selectedIndex - 4, selectedIndex + 3);
                selectedItem = items[selectedIndex - 1];
            }
            else if (selectedIndex === 3) {
                view = items.slice(0, 7);
            }
            view = this._viewToString(view, viewType);
            selectedItem = this._itemToString(selectedItem, viewType);
            return {
                selectedItem: selectedItem,
                view: view
            };
        };
        IgxTimePickerComponent.prototype._nextItem = function (items, selectedItem, isListLoop, viewType) {
            var selectedIndex = items.indexOf(parseInt(selectedItem, 10));
            var itemsCount = items.length;
            var view;
            if (selectedIndex === -1) {
                view = items.slice(0, 7);
                selectedItem = items[3];
            }
            else if (isListLoop) {
                if (selectedIndex < 2) {
                    view = items.slice(itemsCount - (2 - selectedIndex), itemsCount);
                    view = view.concat(items.slice(0, selectedIndex + 5));
                }
                else if (selectedIndex + 4 >= itemsCount) {
                    view = items.slice(selectedIndex - 2, itemsCount);
                    view = view.concat(items.slice(0, selectedIndex + 5 - itemsCount));
                }
                else {
                    view = items.slice(selectedIndex - 2, selectedIndex + 5);
                }
                selectedItem = (selectedIndex === itemsCount - 1) ? items[0] : items[selectedIndex + 1];
            }
            else if (selectedIndex + 1 < itemsCount - 3) {
                view = items.slice(selectedIndex - 2, selectedIndex + 5);
                selectedItem = items[selectedIndex + 1];
            }
            else if (selectedIndex === itemsCount - 4) {
                view = items.slice(selectedIndex - 3, itemsCount);
            }
            view = this._viewToString(view, viewType);
            selectedItem = this._itemToString(selectedItem, viewType);
            return {
                selectedItem: selectedItem,
                view: view
            };
        };
        IgxTimePickerComponent.prototype._formatTime = function (value, format) {
            if (!value) {
                return '';
            }
            else {
                var hour = value.getHours();
                var formattedHour = void 0;
                var minute = value.getMinutes();
                var seconds = value.getSeconds();
                var amPM = (hour > 11) ? 'PM' : 'AM';
                if (format.indexOf('h') !== -1) {
                    if (hour > 12) {
                        hour -= 12;
                        formattedHour = hour < 10 && format.indexOf('hh') !== -1 ? '0' + hour : "" + hour;
                    }
                    else if (hour === 0) {
                        formattedHour = '12';
                    }
                    else if (hour < 10 && format.indexOf('hh') !== -1) {
                        formattedHour = '0' + hour;
                    }
                    else {
                        formattedHour = "" + hour;
                    }
                }
                else {
                    if (hour < 10 && format.indexOf('HH') !== -1) {
                        formattedHour = '0' + hour;
                    }
                    else {
                        formattedHour = "" + hour;
                    }
                }
                var formattedMinute = minute < 10 && format.indexOf('mm') !== -1 ? '0' + minute : "" + minute;
                var formattedSeconds = seconds < 10 && format.indexOf('ss') !== -1 ? '0' + seconds : "" + seconds;
                return format.replace('hh', formattedHour).replace('h', formattedHour)
                    .replace('HH', formattedHour).replace('H', formattedHour)
                    .replace('mm', formattedMinute).replace('m', formattedMinute)
                    .replace('ss', formattedSeconds).replace('s', formattedSeconds)
                    .replace('tt', amPM);
            }
        };
        IgxTimePickerComponent.prototype._updateHourView = function (start, end) {
            this._hourView = this._viewToString(this._hourItems.slice(start, end), 'hour');
        };
        IgxTimePickerComponent.prototype._updateMinuteView = function (start, end) {
            this._minuteView = this._viewToString(this._minuteItems.slice(start, end), 'minute');
        };
        IgxTimePickerComponent.prototype._updateSecondsView = function (start, end) {
            this._secondsView = this._viewToString(this._secondsItems.slice(start, end), 'seconds');
        };
        IgxTimePickerComponent.prototype._updateAmPmView = function (start, end) {
            this._ampmView = this._ampmItems.slice(start, end);
        };
        IgxTimePickerComponent.prototype._addEmptyItems = function (items) {
            for (var i = 0; i < 3; i++) {
                items.push(null);
            }
        };
        IgxTimePickerComponent.prototype._generateHours = function () {
            var hourItemsCount = 24;
            if (this.format.indexOf('h') !== -1) {
                hourItemsCount = 13;
            }
            hourItemsCount /= this.itemsDelta.hours;
            var i = this.format.indexOf('H') !== -1 ? 0 : 1;
            if (hourItemsCount < 7 || !this.isSpinLoop) {
                this._addEmptyItems(this._hourItems);
                this._isHourListLoop = false;
            }
            if (hourItemsCount > 1) {
                for (i; i < hourItemsCount; i++) {
                    this._hourItems.push(i * this.itemsDelta.hours);
                }
            }
            else {
                this._hourItems.push(0);
            }
            if (hourItemsCount < 7 || !this.isSpinLoop) {
                this._addEmptyItems(this._hourItems);
            }
        };
        IgxTimePickerComponent.prototype._generateMinutes = function () {
            var minuteItemsCount = 60 / this.itemsDelta.minutes;
            if (minuteItemsCount < 7 || !this.isSpinLoop) {
                this._addEmptyItems(this._minuteItems);
                this._isMinuteListLoop = false;
            }
            for (var i = 0; i < minuteItemsCount; i++) {
                this._minuteItems.push(i * this.itemsDelta.minutes);
            }
            if (minuteItemsCount < 7 || !this.isSpinLoop) {
                this._addEmptyItems(this._minuteItems);
            }
        };
        IgxTimePickerComponent.prototype._generateSeconds = function () {
            var secondsItemsCount = 60 / this.itemsDelta.seconds;
            if (secondsItemsCount < 7 || !this.isSpinLoop) {
                this._addEmptyItems(this._secondsItems);
                this._isSecondsListLoop = false;
            }
            for (var i = 0; i < secondsItemsCount; i++) {
                this._secondsItems.push(i * this.itemsDelta.seconds);
            }
            if (secondsItemsCount < 7 || !this.isSpinLoop) {
                this._addEmptyItems(this._secondsItems);
            }
        };
        IgxTimePickerComponent.prototype._generateAmPm = function () {
            this._addEmptyItems(this._ampmItems);
            this._ampmItems.push('AM');
            this._ampmItems.push('PM');
            this._addEmptyItems(this._ampmItems);
        };
        IgxTimePickerComponent.prototype._getSelectedTime = function () {
            var date = this.value ? new Date(this.value) : new Date();
            if (this.selectedHour) {
                date.setHours(parseInt(this.selectedHour, 10));
            }
            if (this.selectedMinute) {
                date.setMinutes(parseInt(this.selectedMinute, 10));
            }
            if (this.selectedSeconds) {
                date.setSeconds(parseInt(this.selectedSeconds, 10));
            }
            if (((this.showHoursList && this.selectedHour !== '12') || (!this.showHoursList && this.selectedHour <= '11')) &&
                this.selectedAmPm === 'PM') {
                date.setHours(date.getHours() + 12);
            }
            if (!this.showHoursList && this.selectedAmPm === 'AM' && this.selectedHour > '11') {
                date.setHours(date.getHours() - 12);
            }
            if (this.selectedAmPm === 'AM' && this.selectedHour === '12') {
                date.setHours(0);
            }
            return date;
        };
        IgxTimePickerComponent.prototype._isValueValid = function (value) {
            if (this.maxValue && value > this.convertMinMaxValue(this.maxValue)) {
                return false;
            }
            else if (this.minValue && value < this.convertMinMaxValue(this.minValue)) {
                return false;
            }
            else {
                return true;
            }
        };
        IgxTimePickerComponent.prototype._isEntryValid = function (val) {
            var validH = true;
            var validM = true;
            var validS = true;
            var sections = val.split(/[\s:]+/);
            var re = new RegExp(this.promptChar, 'g');
            if (this.showHoursList) {
                validH = this.validHourEntries.indexOf(parseInt(sections[0].replace(re, ''), 10)) !== -1;
            }
            if (this.showMinutesList) {
                var minutes = this.showHoursList ? sections[1] : sections[0];
                validM = this.validMinuteEntries.indexOf(parseInt(minutes.replace(re, ''), 10)) !== -1;
            }
            if (this.showSecondsList) {
                var seconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
                validS = this.validSecondsEntries.indexOf(parseInt(seconds.replace(re, ''), 10)) !== -1;
            }
            return validH && validM && validS;
        };
        IgxTimePickerComponent.prototype._getCursorPosition = function () {
            return this._inputElementRef.nativeElement.selectionStart;
        };
        IgxTimePickerComponent.prototype._setCursorPosition = function (start, end) {
            if (end === void 0) { end = start; }
            this._inputElementRef.nativeElement.setSelectionRange(start, end);
        };
        IgxTimePickerComponent.prototype._updateEditableInput = function () {
            if (this.mode === InteractionMode.DropDown) {
                this.displayValue = this._formatTime(this._getSelectedTime(), this.format);
            }
        };
        IgxTimePickerComponent.prototype._spinHours = function (currentVal, minVal, maxVal, hDelta, sign) {
            var oldVal = new Date(currentVal);
            currentVal.setMinutes(sign * hDelta);
            if (currentVal.getDate() !== oldVal.getDate() && this.isSpinLoop) {
                currentVal.setDate(oldVal.getDate());
            }
            var minutes = currentVal.getMinutes();
            if (currentVal.getTime() > maxVal.getTime()) {
                if (this.isSpinLoop) {
                    minutes = minutes < minVal.getMinutes() ? 60 + minutes : minutes;
                    minVal.setMinutes(sign * minutes);
                    return minVal;
                }
                else {
                    return oldVal;
                }
            }
            else if (currentVal.getTime() < minVal.getTime()) {
                if (this.isSpinLoop) {
                    minutes = minutes <= maxVal.getMinutes() ? minutes : minutes - 60;
                    maxVal.setMinutes(minutes);
                    return maxVal;
                }
                else {
                    return oldVal;
                }
            }
            else {
                return currentVal;
            }
        };
        IgxTimePickerComponent.prototype._spinMinutes = function (currentVal, mDelta, sign) {
            var minutes = currentVal.getMinutes() + (sign * mDelta);
            if (minutes < 0 || minutes >= 60) {
                minutes = this.isSpinLoop ? minutes - (sign * 60) : currentVal.getMinutes();
            }
            currentVal.setMinutes(minutes);
            return currentVal;
        };
        IgxTimePickerComponent.prototype._spinSeconds = function (currentVal, sDelta, sign) {
            var seconds = currentVal.getSeconds() + (sign * sDelta);
            if (seconds < 0 || seconds >= 60) {
                seconds = this.isSpinLoop ? seconds - (sign * 60) : currentVal.getSeconds();
            }
            currentVal.setSeconds(seconds);
            return currentVal;
        };
        IgxTimePickerComponent.prototype._initializeContainer = function () {
            var _this = this;
            if (this.value) {
                var formttedTime = this._formatTime(this.value, this.format);
                var sections = formttedTime.split(/[\s:]+/);
                if (this.showHoursList) {
                    this.selectedHour = sections[0];
                }
                if (this.showMinutesList) {
                    this.selectedMinute = this.showHoursList ? sections[1] : sections[0];
                }
                if (this.showSecondsList) {
                    this.selectedSeconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
                }
                if (this.showAmPmList && this._ampmItems !== null) {
                    this.selectedAmPm = sections[sections.length - 1];
                }
            }
            if (this.selectedHour === undefined) {
                this.selectedHour = !this.showHoursList && this.value ? this.value.getHours().toString() :
                    this.showHoursList ? "" + this._hourItems[3] : '0';
            }
            if (this.selectedMinute === undefined) {
                this.selectedMinute = !this.showMinutesList && this.value ? this.value.getMinutes().toString() : '0';
            }
            if (this.selectedSeconds === undefined) {
                this.selectedSeconds = !this.showSecondsList && this.value ? this.value.getSeconds().toString() : '0';
            }
            if (this.selectedAmPm === undefined && this._ampmItems !== null) {
                this.selectedAmPm = this._ampmItems[3];
            }
            this._prevSelectedHour = this.selectedHour;
            this._prevSelectedMinute = this.selectedMinute;
            this._prevSelectedSeconds = this.selectedSeconds;
            this._prevSelectedAmPm = this.selectedAmPm;
            this._onTouchedCallback();
            this._updateHourView(0, ITEMS_COUNT);
            this._updateMinuteView(0, ITEMS_COUNT);
            this._updateSecondsView(0, ITEMS_COUNT);
            this._updateAmPmView(0, ITEMS_COUNT);
            if (this.selectedHour) {
                this.scrollHourIntoView(this.selectedHour);
            }
            if (this.selectedMinute) {
                this.scrollMinuteIntoView(this.selectedMinute);
            }
            if (this.selectedSeconds) {
                this.scrollSecondsIntoView(this.selectedSeconds);
            }
            if (this.selectedAmPm) {
                this.scrollAmPmIntoView(this.selectedAmPm);
            }
            requestAnimationFrame(function () {
                if (_this.hourList) {
                    _this.hourList.nativeElement.focus();
                }
                else if (_this.minuteList) {
                    _this.minuteList.nativeElement.focus();
                }
                else if (_this.secondsList) {
                    _this.secondsList.nativeElement.focus();
                }
            });
        };
        IgxTimePickerComponent.prototype._onDropDownClosed = function () {
            var oldValue = this.value;
            var newVal = this.convertMinMaxValue(this.displayValue);
            if (this.displayValue === this.parseMask(false)) {
                return;
            }
            if (this._isValueValid(newVal)) {
                if (!this.value || oldValue.getTime() !== newVal.getTime()) {
                    this.value = newVal;
                }
            }
            else {
                this.displayValue = this.inputFormat.transform(this._formatTime(oldValue, this.format));
                var args = {
                    timePicker: this,
                    currentValue: newVal,
                    setThroughUI: true
                };
                this.onValidationFailed.emit(args);
            }
        };
        IgxTimePickerComponent.prototype.cursorOnHours = function (cursor, showHours) {
            return showHours && this._hoursPos.has(cursor);
        };
        IgxTimePickerComponent.prototype.cursorOnMinutes = function (cursor, showHours, showMinutes) {
            return showMinutes &&
                (showHours && this._minutesPos.has(cursor)) ||
                (!showHours && this._minutesPos.has(cursor));
        };
        IgxTimePickerComponent.prototype.cursorOnSeconds = function (cursor, showHours, showMinutes, showSeconds) {
            return showSeconds &&
                (showHours && showMinutes && this._secondsPos.has(cursor)) ||
                ((!showHours || !showMinutes) && this._secondsPos.has(cursor)) ||
                (!showHours && !showMinutes && this._secondsPos.has(cursor));
        };
        IgxTimePickerComponent.prototype.cursorOnAmPm = function (cursor, showHours, showMinutes, showSeconds, showAmPm) {
            return showAmPm &&
                (showHours && showMinutes && showSeconds && this._amPmPos.has(cursor)) ||
                ((!showHours || !showMinutes || !showSeconds) && this._amPmPos.has(cursor)) ||
                (!showHours && (!showMinutes || !showSeconds) && this._amPmPos.has(cursor));
        };
        IgxTimePickerComponent.prototype._updateValidityOnBlur = function () {
            this._onTouchedCallback();
            var input = this._inputDirective || this._inputDirectiveUserTemplate;
            if (this._ngControl && !this._ngControl.valid) {
                input.valid = exports.IgxInputState.INVALID;
            }
            else {
                input.valid = exports.IgxInputState.INITIAL;
            }
        };
        // Workaround method for #8135
        // TODO: It must be removed in #6482
        IgxTimePickerComponent.prototype.isReset = function () {
            var _a, _b, _c;
            return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.getHours()) === 0
                && ((_b = this.value) === null || _b === void 0 ? void 0 : _b.getMinutes()) === 0
                && ((_c = this.value) === null || _c === void 0 ? void 0 : _c.getSeconds()) === 0;
        };
        return IgxTimePickerComponent;
    }());
    IgxTimePickerComponent.decorators = [
        { type: i0.Component, args: [{
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: IgxTimePickerComponent,
                            multi: true
                        },
                        {
                            provide: i1$1.HAMMER_GESTURE_CONFIG,
                            useClass: TimePickerHammerConfig
                        },
                        {
                            provide: IGX_TIME_PICKER_COMPONENT,
                            useExisting: IgxTimePickerComponent
                        }
                    ],
                    selector: 'igx-time-picker',
                    template: "<ng-template #labelTemplate>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #dropdownInputTemplate>\n    <igx-input-group #group (mousedown)=\"mouseDown($event)\" [suppressInputAutofocus]=\"true\">\n        <label igxLabel *ngIf=\"!labelDirective\">Time</label>\n        <ng-container ngProjectAs=\"[igxLabel]\" *ngTemplateOutlet=\"labelTemplate\"></ng-container>\n        <igx-prefix (click)=\"openDialog(group.element.nativeElement)\">\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <input\n            type=\"text\"\n            [igxMask]=\"mask\"\n            igxInput\n            [includeLiterals]=\"true\"\n            [placeholder]=\"format\"\n            [displayValuePipe]=\"displayFormat\"\n            [focusedValuePipe]=\"inputFormat\"\n            [promptChar]=\"promptChar\"\n            [value]=\"displayValue\"\n            [igxTextSelection]=\"true\"\n            (input)=\"onInput($event)\"\n            (blur)=\"onBlur($event)\"\n            (focus)=\"onFocus($event)\"\n            (wheel)=\"spinOnEdit($event)\"\n            [disabled]=\"disabled\" />\n        <igx-suffix *ngIf=\"showClearButton\" igxRipple (click)=\"clear()\">\n            <igx-icon>clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n<ng-template #defaultTimePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\" (mousedown)=\"mouseDown($event)\">\n        <igx-prefix>\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <label igxLabel *ngIf=\"!labelDirective\">Time</label>\n        <ng-container ngProjectAs=\"[igxLabel]\" *ngTemplateOutlet=\"labelTemplate\"></ng-container>\n        <input\n            igxInput\n            [value]=\"displayTime || ''\"\n            [disabled]=\"disabled\"\n            tabindex=\"0\" readonly\n            (blur)=\"onBlur($event)\" />\n    </igx-input-group>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n\n<ng-template #defaultTimePickerActions>\n    <div *ngIf=\"cancelButtonLabel || okButtonLabel\" class=\"igx-time-picker__buttons\">\n        <button *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" (click)=\"cancelButtonClick()\">\n            {{cancelButtonLabel}}\n        </button>\n        <button *ngIf=\"okButtonLabel\" igxButton=\"flat\" (click)=\"okButtonClick()\">\n            {{okButtonLabel}}\n        </button>\n    </div>\n</ng-template>\n<div igxToggle class=\"igx-time-picker\"\n    [ngClass]=\"{'igx-time-picker--dropdown': mode === 'dropdown', 'igx-time-picker--vertical': vertical && mode === 'dialog'}\">\n    <div *ngIf=\"mode === 'dialog'\" class=\"igx-time-picker__header\">\n        <h5 class=\"igx-time-picker__header-ampm\">{{ selectedAmPm }}</h5>\n        <h2 class=\"igx-time-picker__header-hour\">\n            <span>{{ selectedHour }}</span>:<span>{{ selectedMinute }}</span>:<span>{{ selectedSeconds }}</span>\n        </h2>\n    </div>\n    <div class=\"igx-time-picker__main\">\n        <div class=\"igx-time-picker__body\">\n            <div *ngIf=\"showHoursList\" #hourList [igxItemList]=\"'hourList'\">\n                <span [igxHourItem]=\"hour\"\n                [ngClass]=\"{'igx-time-picker__item--disabled': applyDisabledStyleForItem(timeParts.Hour, hour)}\"\n                *ngFor=\"let hour of hourView\">{{ hour }}</span>\n            </div>\n            <div *ngIf=\"showMinutesList\" #minuteList [igxItemList]=\"'minuteList'\">\n                <span [igxMinuteItem]=\"minute\"\n                [ngClass]=\"{'igx-time-picker__item--disabled': applyDisabledStyleForItem(timeParts.Minute, minute)}\"\n                *ngFor=\"let minute of minuteView\" >{{ minute }}</span>\n            </div>\n            <div *ngIf=\"showSecondsList\" #secondsList [igxItemList]=\"'secondsList'\">\n                <span [igxSecondsItem]=\"seconds\"\n                [ngClass]=\"{'igx-time-picker__item--disabled': applyDisabledStyleForItem(timeParts.Seconds, seconds)}\"\n                *ngFor=\"let seconds of secondsView\">{{ seconds }}</span>\n            </div>\n            <div *ngIf=\"showAmPmList\" #ampmList [igxItemList]=\"'ampmList'\">\n                <span [igxAmPmItem]=\"ampm\"\n                [ngClass]=\"{'igx-time-picker__item--disabled': applyDisabledStyleForItem(timeParts.AMPM, ampm)}\"\n                *ngFor=\"let ampm of ampmView\">{{ ampm }}</span>\n            </div>\n        </div>\n        <ng-container\n            *ngTemplateOutlet=\"timePickerActionsDirective ? timePickerActionsDirective.template : defaultTimePickerActions\">\n        </ng-container>\n    </div>\n</div>\n",
                    styles: [":host {\n            display: block;\n        }"]
                },] }
    ];
    IgxTimePickerComponent.ctorParameters = function () { return [
        { type: i0.Injector },
        { type: i0.ChangeDetectorRef }
    ]; };
    IgxTimePickerComponent.propDecorators = {
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        disabled: [{ type: i0.Input }],
        minValue: [{ type: i0.Input }],
        maxValue: [{ type: i0.Input }],
        isSpinLoop: [{ type: i0.Input }],
        vertical: [{ type: i0.Input }],
        promptChar: [{ type: i0.Input }],
        mode: [{ type: i0.Input }],
        outlet: [{ type: i0.Input }],
        onValueChanged: [{ type: i0.Output }],
        onValidationFailed: [{ type: i0.Output }],
        onOpened: [{ type: i0.Output }],
        onClosed: [{ type: i0.Output }],
        onClosing: [{ type: i0.Output }],
        hourList: [{ type: i0.ViewChild, args: ['hourList',] }],
        minuteList: [{ type: i0.ViewChild, args: ['minuteList',] }],
        secondsList: [{ type: i0.ViewChild, args: ['secondsList',] }],
        ampmList: [{ type: i0.ViewChild, args: ['ampmList',] }],
        timePickerActionsDirective: [{ type: i0.ContentChild, args: [IgxTimePickerActionsDirective, { read: IgxTimePickerActionsDirective },] }],
        labelDirective: [{ type: i0.ContentChild, args: [IgxLabelDirective,] }],
        toggleRef: [{ type: i0.ViewChild, args: [IgxToggleDirective, { static: true },] }],
        defaultTimePickerTemplate: [{ type: i0.ViewChild, args: ['defaultTimePickerTemplate', { read: i0.TemplateRef, static: true },] }],
        timePickerTemplateDirective: [{ type: i0.ContentChild, args: [IgxTimePickerTemplateDirective, { read: IgxTimePickerTemplateDirective },] }],
        dropdownInputTemplate: [{ type: i0.ViewChild, args: ['dropdownInputTemplate', { read: i0.TemplateRef, static: true },] }],
        _inputElementRef: [{ type: i0.ViewChild, args: [IgxInputDirective, { read: i0.ElementRef },] }],
        _inputDirective: [{ type: i0.ViewChild, args: [IgxInputDirective, { read: IgxInputDirective },] }],
        _inputDirectiveUserTemplate: [{ type: i0.ContentChild, args: [IgxInputDirective, { read: IgxInputDirective },] }],
        _inputGroup: [{ type: i0.ViewChild, args: [IgxInputGroupComponent, { read: IgxInputGroupComponent },] }],
        value: [{ type: i0.Input }],
        resourceStrings: [{ type: i0.Input }],
        okButtonLabel: [{ type: i0.Input }],
        cancelButtonLabel: [{ type: i0.Input }],
        itemsDelta: [{ type: i0.Input }],
        format: [{ type: i0.Input }],
        overlaySettings: [{ type: i0.Input }],
        onKeydownSpace: [{ type: i0.HostListener, args: ['keydown.spacebar', ['$event'],] }, { type: i0.HostListener, args: ['keydown.space', ['$event'],] }],
        onAltArrowDown: [{ type: i0.HostListener, args: ['keydown.Alt.ArrowDown',] }]
    };
    /**
     * @hidden
     */
    var IgxTimePickerModule = /** @class */ (function () {
        function IgxTimePickerModule() {
        }
        return IgxTimePickerModule;
    }());
    IgxTimePickerModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxTimePickerComponent,
                        IgxHourItemDirective,
                        IgxMinuteItemDirective,
                        IgxSecondsItemDirective,
                        IgxItemListDirective,
                        IgxAmPmItemDirective,
                        IgxTimePickerTemplateDirective,
                        IgxTimePickerActionsDirective,
                        TimeDisplayFormatPipe,
                        TimeInputFormatPipe
                    ],
                    exports: [
                        IgxTimePickerComponent,
                        IgxTimePickerTemplateDirective,
                        IgxTimePickerActionsDirective,
                        TimeDisplayFormatPipe,
                        TimeInputFormatPipe,
                        IgxInputGroupModule
                    ],
                    imports: [
                        i2.CommonModule,
                        IgxInputGroupModule,
                        IgxIconModule,
                        IgxButtonModule,
                        IgxMaskModule,
                        IgxToggleModule,
                        IgxTextSelectionModule
                    ],
                    providers: []
                },] }
    ];

    var NEXT_ID$t = 0;
    /**
     * Enumeration for toast position
     * Can be:
     * Bottom
     * Middle
     * Top
     */
    var IgxToastPosition = mkenum({
        Bottom: 'bottom',
        Middle: 'middle',
        Top: 'top'
    });
    /**
     * **Ignite UI for Angular Toast** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/toast)
     *
     * The Ignite UI Toast provides information and warning messages that are non-interactive and cannot
     * be dismissed by the user. Toasts can be displayed at the bottom, middle, or top of the page.
     *
     * Example:
     * ```html
     * <button (click)="toast.show()">Show notification</button>
     * <igx-toast #toast
     *           message="Notification displayed"
     *           displayTime="1000">
     * </igx-toast>
     * ```
     */
    var IgxToastComponent = /** @class */ (function (_super) {
        __extends(IgxToastComponent, _super);
        function IgxToastComponent(_element, cdr, navService, overlayService) {
            var _this = _super.call(this, _element, cdr, overlayService, navService) || this;
            _this._element = _element;
            /**
             * @hidden
             */
            _this.cssClass = 'igx-toast';
            /**
             * Sets/gets the `id` of the toast.
             * If not set, the `id` will have value `"igx-toast-0"`.
             * ```html
             * <igx-toast id = "my-first-toast"></igx-toast>
             * ```
             * ```typescript
             * let toastId = this.toast.id;
             * ```
             */
            _this.id = "igx-toast-" + NEXT_ID$t++;
            /**
             * Emits an event prior the toast is shown.
             * Provides reference to the `IgxToastComponent` as event argument.
             * ```html
             * <igx-toast (showing)="handleShowing($event)"></igx-toast>
             * ```
             *
             * @memberof IgxToastComponent
             */
            _this.showing = new i0.EventEmitter();
            /**
             * Emits an event when the toast is shown.
             * Provides reference to the `IgxToastComponent` as event argument.
             * ```html
             * <igx-toast (shown)="handleShown($event)"></igx-toast>
             * ```
             *
             * @memberof IgxToastComponent
             */
            _this.shown = new i0.EventEmitter();
            /**
             * Emits an event prior the toast is hidden.
             * Provides reference to the `IgxToastComponent` as event argument.
             * ```html
             * <igx-toast (hiding)="handleHiding($event)"></igx-toast>
             * ```
             *
             * @memberof IgxToastComponent
             */
            _this.hiding = new i0.EventEmitter();
            /**
             *  Emits an event when the toast is hidden.
             *  Provides reference to the `IgxToastComponent` as event argument.
             * ```html
             * <igx-toast (hidden)="handleHidden($event)"></igx-toast>
             * ```
             *
             * @memberof IgxToastComponent
             */
            _this.hidden = new i0.EventEmitter();
            /**
             * Sets/gets the `role` attribute.
             * If not set, `role` will have value `"alert"`.
             * ```html
             * <igx-toast [role] = "'notify'"></igx-toast>
             * ```
             * ```typescript
             * let toastRole = this.toast.role;
             * ```
             *
             * @memberof IgxToastComponent
             */
            _this.role = 'alert';
            /**
             * Sets/gets whether the toast will be hidden after the `displayTime` is over.
             * Default value is `true`.
             * ```html
             * <igx-toast [autoHide] = "false"></igx-toast>
             * ```
             * ```typescript
             * let autoHide = this.toast.autoHide;
             * ```
             *
             * @memberof IgxToastComponent
             */
            _this.autoHide = true;
            /**
             * Sets/gets the duration of time span(in milliseconds) which the toast will be visible
             * after it is being shown.
             * Default value is `4000`.
             * ```html
             * <igx-toast [displayTime] = "2500"></igx-toast>
             * ```
             * ```typescript
             * let displayTime = this.toast.displayTime;
             * ```
             *
             * @memberof IgxToastComponent
             */
            _this.displayTime = 4000;
            /**
             * @hidden
             */
            _this.isVisibleChange = new i0.EventEmitter();
            /**
             * Sets/gets the position of the toast.
             * If not set, the `position` attribute will have value `IgxToastPosition.Bottom`.
             * ```html
             * <igx-toast [position]="top"></igx-toast>
             * ```
             * ```typescript
             * let toastPosition = this.toast.position;
             * ```
             *
             * @memberof IgxToastComponent
             */
            _this.position = 'bottom';
            /**
             * @hidden
             * @internal
             */
            _this.toastMessage = '';
            _this.d$ = new rxjs.Subject();
            return _this;
        }
        Object.defineProperty(IgxToastComponent.prototype, "isVisible", {
            /**
             * Enables/Disables the visibility of the toast.
             * If not set, the `isVisible` attribute will have value `false`.
             * ```html
             * <igx-toast [isVisible]="true"></igx-toast>
             * ```
             * ```typescript
             * let isVisible = this.toast.isVisible;
             * ```
             *
             * Two-way data binding.
             * ```html
             * <igx-toast [(isVisible)]="model.isVisible"></igx-toast>
             * ```
             *
             * @memberof IgxToastComponent
             */
            get: function () {
                return !this.collapsed;
            },
            set: function (value) {
                var _this = this;
                if (value !== this.isVisible) {
                    if (value) {
                        requestAnimationFrame(function () {
                            _this.open();
                        });
                    }
                    else {
                        this.close();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxToastComponent.prototype, "message", {
            get: function () {
                return this.toastMessage;
            },
            /**
             * @deprecated Place your message in the toast content instead.
             * Sets/gets the message that will be shown by the toast.
             * ```html
             * <igx-toast [message]="Notification"></igx-toast>
             * ```
             * ```typescript
             * let toastMessage = this.toast.message;
             * ```
             * @memberof IgxToastComponent
             */
            set: function (value) {
                this.toastMessage = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxToastComponent.prototype, "element", {
            /**
             * Gets the nativeElement of the toast.
             * ```typescript
             * let nativeElement = this.toast.element;
             * ```
             *
             * @memberof IgxToastComponent
             */
            get: function () {
                return this._element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @deprecated
         * Shows the toast.
         * If `autoHide` is enabled, the toast will hide after `displayTime` is over.
         *
         * ```typescript
         * this.toast.show();
         * ```
         *
         * @memberof IgxToastComponent
         */
        IgxToastComponent.prototype.show = function (message) {
            this.open(message);
        };
        /**
         * @deprecated
         * Hides the toast.
         *
         * ```typescript
         * this.toast.hide();
         * ```
         *
         * @memberof IgxToastComponent
         */
        IgxToastComponent.prototype.hide = function () {
            this.close();
        };
        /**
         * Shows the toast.
         * If `autoHide` is enabled, the toast will hide after `displayTime` is over.
         *
         * ```typescript
         * this.toast.open();
         * ```
         */
        IgxToastComponent.prototype.open = function (message) {
            var _this = this;
            clearInterval(this.timeoutId);
            var overlaySettings = {
                positionStrategy: new GlobalPositionStrategy({
                    horizontalDirection: exports.HorizontalAlignment.Center,
                    verticalDirection: this.position === 'bottom'
                        ? exports.VerticalAlignment.Bottom
                        : this.position === 'middle'
                            ? exports.VerticalAlignment.Middle
                            : exports.VerticalAlignment.Top,
                }),
                closeOnEscape: false,
                closeOnOutsideClick: false,
                modal: false,
                outlet: this.outlet,
            };
            if (message !== undefined) {
                this.toastMessage = message;
            }
            this.showing.emit(this);
            _super.prototype.open.call(this, overlaySettings);
            if (this.autoHide) {
                this.timeoutId = window.setTimeout(function () {
                    _this.close();
                }, this.displayTime);
            }
        };
        /**
         * Hides the toast.
         *
         * ```typescript
         * this.toast.close();
         * ```
         */
        IgxToastComponent.prototype.close = function () {
            clearInterval(this.timeoutId);
            this.hiding.emit(this);
            _super.prototype.close.call(this);
        };
        /**
         * Toggles the visible state of the toast.
         * ```typescript
         * this.toast.toggle();
         * ```
         *
         * @memberof IgxToastComponent
         */
        IgxToastComponent.prototype.toggle = function () {
            _super.prototype.toggle.call(this);
        };
        /**
         * @hidden
         */
        IgxToastComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.onOpened.pipe(operators.takeUntil(this.d$)).subscribe(function () {
                _this.isVisibleChange.emit(true);
                _this.shown.emit(_this);
            });
            this.onClosed.pipe(operators.takeUntil(this.d$)).subscribe(function () {
                _this.isVisibleChange.emit(false);
                _this.hidden.emit(_this);
            });
        };
        /**
         * @hidden
         */
        IgxToastComponent.prototype.ngOnDestroy = function () {
            this.d$.next(true);
            this.d$.complete();
        };
        return IgxToastComponent;
    }(IgxToggleDirective));
    IgxToastComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-toast',
                    template: "<ng-content></ng-content>\n<span>{{ toastMessage }}</span>\n\n"
                },] }
    ];
    IgxToastComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: IgxNavigationService, decorators: [{ type: i0.Optional }] },
        { type: IgxOverlayService, decorators: [{ type: i0.Inject, args: [IgxOverlayService,] }] }
    ]; };
    IgxToastComponent.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-toast',] }],
        id: [{ type: i0.HostBinding, args: ['attr.id',] }, { type: i0.Input }],
        showing: [{ type: i0.Output }],
        shown: [{ type: i0.Output }],
        hiding: [{ type: i0.Output }],
        hidden: [{ type: i0.Output }],
        role: [{ type: i0.Input }],
        autoHide: [{ type: i0.Input }],
        displayTime: [{ type: i0.Input }],
        outlet: [{ type: i0.Input }],
        isVisible: [{ type: i0.Input }],
        isVisibleChange: [{ type: i0.Output }],
        message: [{ type: i0.Input }],
        position: [{ type: i0.Input }]
    };
    __decorate([
        DeprecateProperty("'showing' property is deprecated. You can use 'onOpening' instead.")
    ], IgxToastComponent.prototype, "showing", void 0);
    __decorate([
        DeprecateProperty("'shown' property is deprecated. You can use 'onOpened' instead.")
    ], IgxToastComponent.prototype, "shown", void 0);
    __decorate([
        DeprecateProperty("'hiding' property is deprecated. You can use 'onClosing' instead.")
    ], IgxToastComponent.prototype, "hiding", void 0);
    __decorate([
        DeprecateProperty("'hidden' property is deprecated. You can use 'onClosed' instead.")
    ], IgxToastComponent.prototype, "hidden", void 0);
    __decorate([
        DeprecateProperty("'message' property is deprecated.\n        You can use place the message in the toast content or pass it as parameter to the show method instead.")
    ], IgxToastComponent.prototype, "message", null);
    __decorate([
        DeprecateMethod("'show' is deprecated. Use 'open' method instead.")
    ], IgxToastComponent.prototype, "show", null);
    __decorate([
        DeprecateMethod("'hide' is deprecated. Use 'close' method instead.")
    ], IgxToastComponent.prototype, "hide", null);
    /**
     * @hidden
     */
    var IgxToastModule = /** @class */ (function () {
        function IgxToastModule() {
        }
        return IgxToastModule;
    }());
    IgxToastModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IgxToastComponent],
                    exports: [IgxToastComponent],
                    imports: [i2.CommonModule],
                },] }
    ];

    /**
     * Represents individual resizable/collapsible panes.
     *
     * @igxModule IgxSplitterModule
     *
     * @igxParent IgxSplitterComponent
     *
     * @igxKeywords pane
     *
     * @igxGroup presentation
     *
     * @remarks
     *  Users can control the resize behavior via the min and max size properties.
     */
    var IgxSplitterPaneComponent = /** @class */ (function () {
        function IgxSplitterPaneComponent(el) {
            this.el = el;
            /**
             * @hidden @internal
             * Gets/Sets the 'display' property of the current pane.
             */
            this.display = 'flex';
            /**
             * Gets/Sets whether pane is resizable.
             *
             * @example
             * ```html
             * <igx-splitter>
             *  <igx-splitter-pane [resizable]='false'>...</igx-splitter-pane>
             * </igx-splitter>
             * ```
             * @remarks
             * If pane is not resizable its related splitter bar cannot be dragged.
             */
            this.resizable = true;
            /**
             * Event fired when collapsed state of pane is changed.
             *
             * @example
             * ```html
             * <igx-splitter>
             *  <igx-splitter-pane (onToggle)='onPaneToggle($event)'>...</igx-splitter-pane>
             * </igx-splitter>
             * ```
             */
            this.onToggle = new i0.EventEmitter();
            /**
             * Event fired when collapsed state of pane is changed.
             *
             * @example
             * ```html
             * <igx-splitter>
             *  <igx-splitter-pane (collapsedChange)='paneCollapsedChange($event)'>...</igx-splitter-pane>
             * </igx-splitter>
             * ```
             */
            this.collapsedChange = new i0.EventEmitter();
            /**
             * @hidden @internal
             * Gets/Sets the `overflow`.
             */
            this.overflow = 'auto';
            /**
             * @hidden @internal
             * Gets/Sets the `minHeight` and `minWidth` properties of the current pane.
             */
            this.minHeight = 0;
            /**
             * @hidden @internal
             * Gets/Sets the `maxHeight` and `maxWidth` properties of the current `IgxSplitterPaneComponent`.
             */
            this.maxHeight = '100%';
            this._size = 'auto';
            this._collapsed = false;
        }
        Object.defineProperty(IgxSplitterPaneComponent.prototype, "size", {
            /**
             * Gets/Sets the size of the current pane.
             *  * @example
             * ```html
             * <igx-splitter>
             *  <igx-splitter-pane [size]='size'>...</igx-splitter-pane>
             * </igx-splitter>
             * ```
             */
            get: function () {
                return this._size;
            },
            set: function (value) {
                this._size = value;
                this.el.nativeElement.style.flex = this.flex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSplitterPaneComponent.prototype, "isPercentageSize", {
            /** @hidden @internal */
            get: function () {
                return this.size === 'auto' || this.size.indexOf('%') !== -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSplitterPaneComponent.prototype, "dragSize", {
            /** @hidden @internal */
            get: function () {
                return this._dragSize;
            },
            set: function (val) {
                this._dragSize = val;
                this.el.nativeElement.style.flex = this.flex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSplitterPaneComponent.prototype, "element", {
            /**
             *
             * @hidden @internal
             * Gets the host native element.
             */
            get: function () {
                return this.el.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSplitterPaneComponent.prototype, "flex", {
            /**
             * @hidden @internal
             * Gets the `flex` property of the current `IgxSplitterPaneComponent`.
             */
            get: function () {
                var isAuto = this.size === 'auto' && !this.dragSize;
                var grow = !isAuto ? 0 : 1;
                var size = this.dragSize || this.size;
                return grow + " " + grow + " " + size;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSplitterPaneComponent.prototype, "collapsed", {
            get: function () {
                return this._collapsed;
            },
            /**
             * Gets/Sets whether current pane is collapsed.
             *
             * @example
             * ```typescript
             * const isCollapsed = pane.collapsed;
             * ```
             */
            set: function (value) {
                this._collapsed = value;
                this.display = this._collapsed ? 'none' : 'flex';
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Toggles the collapsed state of the pane.
         *
         * @example
         * ```typescript
         * pane.toggle();
         * ```
         */
        IgxSplitterPaneComponent.prototype.toggle = function () {
            // reset sibling sizes when pane collapse state changes.
            this._getSiblings().forEach(function (sibling) { return sibling.size = 'auto'; });
            this.collapsed = !this.collapsed;
            this.onToggle.emit(this);
            this.collapsedChange.emit(this.collapsed);
        };
        /** @hidden @internal */
        IgxSplitterPaneComponent.prototype._getSiblings = function () {
            var panes = this.owner.panes.toArray();
            var index = panes.indexOf(this);
            var siblings = [];
            if (index !== 0) {
                siblings.push(panes[index - 1]);
            }
            if (index !== panes.length - 1) {
                siblings.push(panes[index + 1]);
            }
            return siblings;
        };
        return IgxSplitterPaneComponent;
    }());
    IgxSplitterPaneComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-splitter-pane',
                    template: "<ng-content></ng-content>"
                },] }
    ];
    IgxSplitterPaneComponent.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    IgxSplitterPaneComponent.propDecorators = {
        display: [{ type: i0.HostBinding, args: ['style.display',] }],
        minSize: [{ type: i0.Input }],
        maxSize: [{ type: i0.Input }],
        resizable: [{ type: i0.Input }],
        onToggle: [{ type: i0.Output }],
        collapsedChange: [{ type: i0.Output }],
        order: [{ type: i0.HostBinding, args: ['style.order',] }],
        overflow: [{ type: i0.HostBinding, args: ['style.overflow',] }],
        minHeight: [{ type: i0.HostBinding, args: ['style.min-height',] }, { type: i0.HostBinding, args: ['style.min-width',] }],
        maxHeight: [{ type: i0.HostBinding, args: ['style.max-height',] }, { type: i0.HostBinding, args: ['style.max-width',] }],
        size: [{ type: i0.Input }],
        flex: [{ type: i0.HostBinding, args: ['style.flex',] }],
        collapsed: [{ type: i0.Input }]
    };
    __decorate([
        DeprecateProperty("Deprecated. Subscribe to the 'collapsedChange' output instead.")
    ], IgxSplitterPaneComponent.prototype, "onToggle", void 0);

    (function (SplitterType) {
        SplitterType[SplitterType["Horizontal"] = 0] = "Horizontal";
        SplitterType[SplitterType["Vertical"] = 1] = "Vertical";
    })(exports.SplitterType || (exports.SplitterType = {}));
    /**
     * Provides a framework for a simple layout, splitting the view horizontally or vertically
     * into multiple smaller resizable and collapsible areas.
     *
     * @igxModule IgxSplitterModule
     *
     * @igxParent Layouts
     *
     * @igxTheme igx-splitter-theme
     *
     * @igxKeywords splitter panes layout
     *
     * @igxGroup presentation
     *
     * @example
     * ```html
     * <igx-splitter>
     *  <igx-splitter-pane>
     *      ...
     *  </igx-splitter-pane>
     *  <igx-splitter-pane>
     *      ...
     *  </igx-splitter-pane>
     * </igx-splitter>
     * ```
     */
    var IgxSplitterComponent = /** @class */ (function () {
        function IgxSplitterComponent(document, elementRef) {
            this.document = document;
            this.elementRef = elementRef;
            /**
             * @hidden @internal
             * Gets/Sets the `overflow` property of the current splitter.
             */
            this.overflow = 'hidden';
            /**
             * @hidden @internal
             * Sets/Gets the `display` property of the current splitter.
             */
            this.display = 'flex';
            /**
             * Event fired when resizing of panes starts.
             *
             * @example
             * ```html
             * <igx-splitter (resizeStart)='resizeStart($event)'>
             *  <igx-splitter-pane>...</igx-splitter-pane>
             * </igx-splitter>
             * ```
             */
            this.resizeStart = new i0.EventEmitter();
            /**
             * Event fired when resizing of panes is in progress.
             *
             * @example
             * ```html
             * <igx-splitter (resizing)='resizing($event)'>
             *  <igx-splitter-pane>...</igx-splitter-pane>
             * </igx-splitter>
             * ```
             */
            this.resizing = new i0.EventEmitter();
            /**
             * Event fired when resizing of panes ends.
             *
             * @example
             * ```html
             * <igx-splitter (resizeEnd)='resizeEnd($event)'>
             *  <igx-splitter-pane>...</igx-splitter-pane>
             * </igx-splitter>
             * ```
             */
            this.resizeEnd = new i0.EventEmitter();
            this._type = exports.SplitterType.Horizontal;
        }
        Object.defineProperty(IgxSplitterComponent.prototype, "type", {
            /**
             * Gets/Sets the splitter orientation.
             *
             * @example
             * ```html
             * <igx-splitter [type]="type">...</igx-splitter>
             * ```
             */
            get: function () {
                return this._type;
            },
            set: function (value) {
                this._type = value;
                if (this.panes) {
                    // if type is changed runtime, should reset sizes.
                    this.panes.forEach(function (x) { return x.size = 'auto'; });
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSplitterComponent.prototype, "direction", {
            /**
             * @hidden @internal
             * Gets the `flex-direction` property of the current `SplitterComponent`.
             */
            get: function () {
                return this.type === exports.SplitterType.Horizontal ? 'row' : 'column';
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden @internal */
        IgxSplitterComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.panes.forEach(function (pane) { return pane.owner = _this; });
            this.assignFlexOrder();
            this.panes.changes.subscribe(function () {
                _this.panes.forEach(function (pane) { return pane.owner = _this; });
                _this.assignFlexOrder();
            });
        };
        /**
         * @hidden @internal
         * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.
         * @param pane - the main pane associated with the currently dragged bar.
         */
        IgxSplitterComponent.prototype.onMoveStart = function (pane) {
            var panes = this.panes.toArray();
            this.pane = pane;
            this.sibling = panes[panes.indexOf(this.pane) + 1];
            var paneRect = this.pane.element.getBoundingClientRect();
            this.initialPaneSize = this.type === exports.SplitterType.Horizontal ? paneRect.width : paneRect.height;
            var siblingRect = this.sibling.element.getBoundingClientRect();
            this.initialSiblingSize = this.type === exports.SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
            var args = { pane: this.pane, sibling: this.sibling };
            this.resizeStart.emit(args);
        };
        /**
         * @hidden @internal
         * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.
         * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.
         */
        IgxSplitterComponent.prototype.onMoving = function (delta) {
            var min = parseInt(this.pane.minSize, 10) || 0;
            var max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
            var minSibling = parseInt(this.sibling.minSize, 10) || 0;
            var maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
            var paneSize = this.initialPaneSize - delta;
            var siblingSize = this.initialSiblingSize + delta;
            if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
                return;
            }
            this.pane.dragSize = paneSize + 'px';
            this.sibling.dragSize = siblingSize + 'px';
            var args = { pane: this.pane, sibling: this.sibling };
            this.resizing.emit(args);
        };
        IgxSplitterComponent.prototype.onMoveEnd = function (delta) {
            var paneSize = this.initialPaneSize - delta;
            var siblingSize = this.initialSiblingSize + delta;
            if (this.pane.isPercentageSize) {
                // handle % resizes
                var totalSize = this.getTotalSize();
                var percentPaneSize = (paneSize / totalSize) * 100;
                this.pane.size = percentPaneSize + '%';
            }
            else {
                // px resize
                this.pane.size = paneSize + 'px';
            }
            if (this.sibling.isPercentageSize) {
                // handle % resizes
                var totalSize = this.getTotalSize();
                var percentSiblingPaneSize = (siblingSize / totalSize) * 100;
                this.sibling.size = percentSiblingPaneSize + '%';
            }
            else {
                // px resize
                this.sibling.size = siblingSize + 'px';
            }
            this.pane.dragSize = null;
            this.sibling.dragSize = null;
            var args = { pane: this.pane, sibling: this.sibling };
            this.resizeEnd.emit(args);
        };
        /** @hidden @internal */
        IgxSplitterComponent.prototype.getPaneSiblingsByOrder = function (order, barIndex) {
            var panes = this.panes.toArray();
            var prevPane = panes[order - barIndex - 1];
            var nextPane = panes[order - barIndex];
            var siblings = [prevPane, nextPane];
            return siblings;
        };
        IgxSplitterComponent.prototype.getTotalSize = function () {
            var computed = this.document.defaultView.getComputedStyle(this.elementRef.nativeElement);
            var totalSize = this.type === exports.SplitterType.Horizontal ? computed.getPropertyValue('width') : computed.getPropertyValue('height');
            return parseFloat(totalSize);
        };
        /**
         * @hidden @internal
         * This method assigns the order of each pane.
         */
        IgxSplitterComponent.prototype.assignFlexOrder = function () {
            var k = 0;
            this.panes.forEach(function (pane) {
                pane.order = k;
                k += 2;
            });
        };
        return IgxSplitterComponent;
    }());
    IgxSplitterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-splitter',
                    template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\"\n                    (movingEnd)='onMoveEnd($event)'>\n    </igx-splitter-bar>\n</ng-container>\n"
                },] }
    ];
    IgxSplitterComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },
        { type: i0.ElementRef }
    ]; };
    IgxSplitterComponent.propDecorators = {
        panes: [{ type: i0.ContentChildren, args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent },] }],
        overflow: [{ type: i0.HostBinding, args: ['style.overflow',] }],
        display: [{ type: i0.HostBinding, args: ['style.display',] }],
        resizeStart: [{ type: i0.Output }],
        resizing: [{ type: i0.Output }],
        resizeEnd: [{ type: i0.Output }],
        type: [{ type: i0.Input }],
        direction: [{ type: i0.HostBinding, args: ['style.flex-direction',] }]
    };

    var SPLITTER_INTERACTION_KEYS = new Set('right down left up arrowright arrowdown arrowleft arrowup'.split(' '));
    /**
     * @hidden @internal
     * Represents the draggable bar that visually separates panes and allows for changing their sizes.
     */
    var IgxSplitBarComponent = /** @class */ (function () {
        function IgxSplitBarComponent() {
            /**
             * Set css class to the host element.
             */
            this.cssClass = 'igx-splitter-bar-host';
            /**
             * Gets/Sets the orientation.
             */
            this.type = exports.SplitterType.Horizontal;
            /**
             * An event that is emitted whenever we start dragging the current `SplitBarComponent`.
             */
            this.moveStart = new i0.EventEmitter();
            /**
             * An event that is emitted while we are dragging the current `SplitBarComponent`.
             */
            this.moving = new i0.EventEmitter();
            this.movingEnd = new i0.EventEmitter();
        }
        Object.defineProperty(IgxSplitBarComponent.prototype, "tabindex", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.resizeDisallowed ? null : 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSplitBarComponent.prototype, "orientation", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.type === exports.SplitterType.Horizontal ? 'horizontal' : 'vertical';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSplitBarComponent.prototype, "cursor", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.resizeDisallowed) {
                    return '';
                }
                return this.type === exports.SplitterType.Horizontal ? 'col-resize' : 'row-resize';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSplitBarComponent.prototype, "prevButtonHidden", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.siblings[0].collapsed && !this.siblings[1].collapsed;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxSplitBarComponent.prototype.keyEvent = function (event) {
            var key = event.key.toLowerCase();
            var ctrl = event.ctrlKey;
            event.stopPropagation();
            if (SPLITTER_INTERACTION_KEYS.has(key)) {
                event.preventDefault();
            }
            switch (key) {
                case 'arrowup':
                case 'up':
                    if (this.type === exports.SplitterType.Vertical) {
                        if (ctrl) {
                            this.onCollapsing(false);
                            break;
                        }
                        if (!this.resizeDisallowed) {
                            event.preventDefault();
                            this.moveStart.emit(this.pane);
                            this.moving.emit(10);
                        }
                    }
                    break;
                case 'arrowdown':
                case 'down':
                    if (this.type === exports.SplitterType.Vertical) {
                        if (ctrl) {
                            this.onCollapsing(true);
                            break;
                        }
                        if (!this.resizeDisallowed) {
                            event.preventDefault();
                            this.moveStart.emit(this.pane);
                            this.moving.emit(-10);
                        }
                    }
                    break;
                case 'arrowleft':
                case 'left':
                    if (this.type === exports.SplitterType.Horizontal) {
                        if (ctrl) {
                            this.onCollapsing(false);
                            break;
                        }
                        if (!this.resizeDisallowed) {
                            event.preventDefault();
                            this.moveStart.emit(this.pane);
                            this.moving.emit(10);
                        }
                    }
                    break;
                case 'arrowright':
                case 'right':
                    if (this.type === exports.SplitterType.Horizontal) {
                        if (ctrl) {
                            this.onCollapsing(true);
                            break;
                        }
                        if (!this.resizeDisallowed) {
                            event.preventDefault();
                            this.moveStart.emit(this.pane);
                            this.moving.emit(-10);
                        }
                    }
                    break;
                default:
                    break;
            }
        };
        Object.defineProperty(IgxSplitBarComponent.prototype, "dragDir", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.type === exports.SplitterType.Horizontal ? exports.DragDirection.VERTICAL : exports.DragDirection.HORIZONTAL;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxSplitBarComponent.prototype, "nextButtonHidden", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.siblings[1].collapsed && !this.siblings[0].collapsed;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxSplitBarComponent.prototype.onDragStart = function (event) {
            if (this.resizeDisallowed) {
                event.cancel = true;
                return;
            }
            this.startPoint = this.type === exports.SplitterType.Horizontal ? event.startX : event.startY;
            this.moveStart.emit(this.pane);
        };
        /**
         * @hidden @internal
         */
        IgxSplitBarComponent.prototype.onDragMove = function (event) {
            var isHorizontal = this.type === exports.SplitterType.Horizontal;
            var curr = isHorizontal ? event.pageX : event.pageY;
            var delta = this.startPoint - curr;
            if (delta !== 0) {
                this.moving.emit(delta);
                event.cancel = true;
                event.owner.element.nativeElement.style.transform = '';
            }
        };
        IgxSplitBarComponent.prototype.onDragEnd = function (event) {
            var isHorizontal = this.type === exports.SplitterType.Horizontal;
            var curr = isHorizontal ? event.pageX : event.pageY;
            var delta = this.startPoint - curr;
            if (delta !== 0) {
                this.movingEnd.emit(delta);
            }
        };
        Object.defineProperty(IgxSplitBarComponent.prototype, "resizeDisallowed", {
            get: function () {
                var relatedTabs = this.siblings;
                return !!relatedTabs.find(function (x) { return x.resizable === false || x.collapsed === true; });
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxSplitBarComponent.prototype.onCollapsing = function (next) {
            var prevSibling = this.siblings[0];
            var nextSibling = this.siblings[1];
            var target;
            if (next) {
                // if next is clicked when prev pane is hidden, show prev pane, else hide next pane.
                target = prevSibling.collapsed ? prevSibling : nextSibling;
            }
            else {
                // if prev is clicked when next pane is hidden, show next pane, else hide prev pane.
                target = nextSibling.collapsed ? nextSibling : prevSibling;
            }
            target.toggle();
        };
        return IgxSplitBarComponent;
    }());
    IgxSplitBarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-splitter-bar',
                    template: "<div class=\"igx-splitter-bar\"\n    [class.igx-splitter-bar--vertical]='type === 0'\n    [style.cursor]='cursor'\n    igxDrag\n    [ghost]=\"false\"\n    [dragDirection]='dragDir'\n    (dragStart)='onDragStart($event)'\n    (dragMove)=\"onDragMove($event)\"\n    (dragEnd)=\"onDragEnd($event)\"\n>\n    <div class=\"igx-splitter-bar__expander--start\" igxDragIgnore (click)='onCollapsing(false)' [hidden]='prevButtonHidden'></div>\n    <div class=\"igx-splitter-bar__handle\" ></div>\n    <div class=\"igx-splitter-bar__expander--end\" igxDragIgnore (click)='onCollapsing(true)' [hidden]='nextButtonHidden'></div>\n</div>\n"
                },] }
    ];
    IgxSplitBarComponent.propDecorators = {
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-splitter-bar-host',] }],
        type: [{ type: i0.Input }],
        order: [{ type: i0.HostBinding, args: ['style.order',] }, { type: i0.Input }],
        tabindex: [{ type: i0.HostBinding, args: ['attr.tabindex',] }],
        orientation: [{ type: i0.HostBinding, args: ['attr.aria-orientation',] }],
        pane: [{ type: i0.Input }],
        siblings: [{ type: i0.Input }],
        moveStart: [{ type: i0.Output }],
        moving: [{ type: i0.Output }],
        movingEnd: [{ type: i0.Output }],
        keyEvent: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
    };

    var IgxSplitterModule = /** @class */ (function () {
        function IgxSplitterModule() {
        }
        return IgxSplitterModule;
    }());
    IgxSplitterModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i2.CommonModule, IgxIconModule, IgxDragDropModule
                    ],
                    declarations: [
                        IgxSplitterComponent,
                        IgxSplitterPaneComponent,
                        IgxSplitBarComponent
                    ],
                    exports: [
                        IgxSplitterComponent,
                        IgxSplitterPaneComponent
                    ]
                },] }
    ];

    /** @hidden @internal */
    var DateRangePickerFormatPipe = /** @class */ (function () {
        function DateRangePickerFormatPipe() {
        }
        DateRangePickerFormatPipe.prototype.transform = function (values, appliedFormat, locale, formatter) {
            if (!values || !values.start && !values.end) {
                return '';
            }
            if (formatter) {
                return formatter(values);
            }
            var start = values.start, end = values.end;
            var startDate = appliedFormat ? DatePickerUtil.formatDate(start, appliedFormat, locale || 'en') : start === null || start === void 0 ? void 0 : start.toLocaleDateString();
            var endDate = appliedFormat ? DatePickerUtil.formatDate(end, appliedFormat, locale || 'en') : end === null || end === void 0 ? void 0 : end.toLocaleDateString();
            var formatted;
            if (start) {
                formatted = startDate + " - ";
                if (end) {
                    formatted += endDate;
                }
            }
            return formatted ? formatted : '';
        };
        return DateRangePickerFormatPipe;
    }());
    DateRangePickerFormatPipe.decorators = [
        { type: i0.Pipe, args: [{ name: 'dateRange' },] }
    ];
    /** @hidden @internal */
    var IgxDateRangeInputsBaseComponent = /** @class */ (function (_super) {
        __extends(IgxDateRangeInputsBaseComponent, _super);
        function IgxDateRangeInputsBaseComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IgxDateRangeInputsBaseComponent.prototype, "nativeElement", {
            /** @hidden @internal */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden @internal */
        IgxDateRangeInputsBaseComponent.prototype.setFocus = function () {
            this.input.focus();
        };
        /** @hidden @internal */
        IgxDateRangeInputsBaseComponent.prototype.updateInputValue = function (value) {
            if (this.ngControl) {
                this.ngControl.control.setValue(value);
            }
            else {
                this.dateTimeEditor.value = value;
            }
        };
        /** @hidden @internal */
        IgxDateRangeInputsBaseComponent.prototype.updateInputValidity = function (state) {
            this.inputDirective.valid = state;
        };
        return IgxDateRangeInputsBaseComponent;
    }(IgxInputGroupComponent));
    IgxDateRangeInputsBaseComponent.decorators = [
        { type: i0.Component, args: [{
                    template: "",
                    selector: "igx-date-range-base",
                    providers: [{ provide: IgxInputGroupBase, useExisting: IgxDateRangeInputsBaseComponent }]
                },] }
    ];
    IgxDateRangeInputsBaseComponent.propDecorators = {
        dateTimeEditor: [{ type: i0.ContentChild, args: [IgxDateTimeEditorDirective,] }],
        inputDirective: [{ type: i0.ContentChild, args: [IgxInputDirective,] }],
        ngControl: [{ type: i0.ContentChild, args: [forms.NgControl,] }]
    };
    /**
     * Templates the default icon in the `IgxDateRangePicker`.
     *
     * @igxModule IgxDateRangePickerModule
     *
     * @igxKeyWords date range icon, date picker icon
     *
     * @igxGroup scheduling
     *
     * @example
     * ```html
     * <igx-date-range-picker>
     *   <igx-picker-toggle igxSuffix>
     *      <igx-icon>calendar_view_day</igx-icon>
     *   </igx-picker-toggle>
     * </igx-date-range-picker>
     * ```
     */
    var IgxPickerToggleComponent = /** @class */ (function () {
        function IgxPickerToggleComponent() {
            this.clicked = new i0.EventEmitter();
        }
        IgxPickerToggleComponent.prototype.onClick = function (event) {
            // do not focus input on click
            event.stopPropagation();
            this.clicked.emit();
        };
        return IgxPickerToggleComponent;
    }());
    IgxPickerToggleComponent.decorators = [
        { type: i0.Component, args: [{
                    template: "<ng-content></ng-content>",
                    selector: 'igx-picker-toggle'
                },] }
    ];
    IgxPickerToggleComponent.propDecorators = {
        clicked: [{ type: i0.Output }],
        onClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }]
    };
    /**
     * Defines the start input for a date range picker
     *
     * @igxModule IgxDateRangePickerModule
     *
     * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme
     *
     * @igxKeywords date, range, date range, date picker
     *
     * @igxGroup scheduling
     *
     * @remarks
     * When templating, start input has to be templated separately
     *
     * @example
     * ```html
     * <igx-date-range-picker mode="dropdown">
     *      <igx-date-range-start>
     *          <input igxInput igxDateTimeEditor type="text">
     *      </igx-date-range-start>
     *      ...
     * </igx-date-range-picker>
     * ```
     */
    var IgxDateRangeStartComponent = /** @class */ (function (_super) {
        __extends(IgxDateRangeStartComponent, _super);
        function IgxDateRangeStartComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return IgxDateRangeStartComponent;
    }(IgxDateRangeInputsBaseComponent));
    IgxDateRangeStartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-date-range-start',
                    template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n\n<div class=\"igx-input-group__hint\" (click)=\"hintClickHandler($event)\">\n    <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n</div>\n\n<ng-template #label>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #input>\n    <ng-content select=\"[igxInput]\"></ng-content>\n</ng-template>\n\n<ng-template #prefix>\n    <ng-content select=\"igx-prefix, [igxPrefix]\"></ng-content>\n</ng-template>\n\n<ng-template #uploadButton>\n    <igx-prefix *ngIf=\"isFileType\">\n        <button\n            igxButton=\"raised\"\n            (click)=\"uploadButtonHandler()\"\n            [displayDensity]=\"displayDensity\"\n            [disabled]=\"disabled\"\n            [ngClass]=\"{ 'igx-input-group__upload-button': isTypeLine }\"\n        >\n            {{ resourceStrings.igx_input_upload_button }}\n        </button>\n    </igx-prefix>\n</ng-template>\n\n<ng-template #files>\n    <div\n        *ngIf=\"isFileType\"\n        class=\"igx-input-group__file-input\"\n        [title]=\"fileNames\"\n    >\n        <span>{{ fileNames }}</span>\n    </div>\n</ng-template>\n\n<ng-template #clear>\n    <igx-suffix\n        class=\"igx-input-group__clear-icon\"\n        *ngIf=\"isFileType && isFilled\"\n        (click)=\"clearValueHandler()\"\n        (keydown.Enter)=\"clearValueHandler()\"\n        title=\"clear files\"\n        tabindex=\"0\"\n    >\n        <igx-icon>{{ resourceStrings.igx_input_clear_button }}</igx-icon>\n    </igx-suffix>\n</ng-template>\n\n<ng-template #suffix>\n    <ng-content select=\"igx-suffix, [igxSuffix]\"></ng-content>\n</ng-template>\n\n<ng-template #materialBundle>\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #fluentBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bootstrapBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bundle>\n    <ng-container [ngSwitch]=\"theme\">\n        <ng-container *ngSwitchCase=\"'bootstrap'\">\n            <ng-container *ngTemplateOutlet=\"bootstrapBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'fluent'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'indigo-design'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"materialBundle\"></ng-container>\n        </ng-container>\n    </ng-container>\n</ng-template>\n",
                    providers: [
                        { provide: IgxInputGroupBase, useExisting: IgxDateRangeStartComponent },
                        { provide: IgxDateRangeInputsBaseComponent, useExisting: IgxDateRangeStartComponent }
                    ]
                },] }
    ];
    /**
     * Defines the end input for a date range picker
     *
     * @igxModule IgxDateRangeModule
     *
     * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme
     *
     * @igxKeywords date, range, date range, date picker
     *
     * @igxGroup scheduling
     *
     * @remarks
     * When templating, end input has to be template separately
     *
     * @example
     * ```html
     * <igx-date-range-picker mode="dropdown">
     *      <igx-date-range-end>
     *          <input igxInput igxDateTimeEditor type="text">
     *      </igx-date-range-end>
     *      ...
     * </igx-date-range-picker>
     * ```
     */
    var IgxDateRangeEndComponent = /** @class */ (function (_super) {
        __extends(IgxDateRangeEndComponent, _super);
        function IgxDateRangeEndComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return IgxDateRangeEndComponent;
    }(IgxDateRangeInputsBaseComponent));
    IgxDateRangeEndComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-date-range-end',
                    template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n\n<div class=\"igx-input-group__hint\" (click)=\"hintClickHandler($event)\">\n    <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n</div>\n\n<ng-template #label>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #input>\n    <ng-content select=\"[igxInput]\"></ng-content>\n</ng-template>\n\n<ng-template #prefix>\n    <ng-content select=\"igx-prefix, [igxPrefix]\"></ng-content>\n</ng-template>\n\n<ng-template #uploadButton>\n    <igx-prefix *ngIf=\"isFileType\">\n        <button\n            igxButton=\"raised\"\n            (click)=\"uploadButtonHandler()\"\n            [displayDensity]=\"displayDensity\"\n            [disabled]=\"disabled\"\n            [ngClass]=\"{ 'igx-input-group__upload-button': isTypeLine }\"\n        >\n            {{ resourceStrings.igx_input_upload_button }}\n        </button>\n    </igx-prefix>\n</ng-template>\n\n<ng-template #files>\n    <div\n        *ngIf=\"isFileType\"\n        class=\"igx-input-group__file-input\"\n        [title]=\"fileNames\"\n    >\n        <span>{{ fileNames }}</span>\n    </div>\n</ng-template>\n\n<ng-template #clear>\n    <igx-suffix\n        class=\"igx-input-group__clear-icon\"\n        *ngIf=\"isFileType && isFilled\"\n        (click)=\"clearValueHandler()\"\n        (keydown.Enter)=\"clearValueHandler()\"\n        title=\"clear files\"\n        tabindex=\"0\"\n    >\n        <igx-icon>{{ resourceStrings.igx_input_clear_button }}</igx-icon>\n    </igx-suffix>\n</ng-template>\n\n<ng-template #suffix>\n    <ng-content select=\"igx-suffix, [igxSuffix]\"></ng-content>\n</ng-template>\n\n<ng-template #materialBundle>\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #fluentBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bootstrapBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <ng-container *ngTemplateOutlet=\"uploadButton\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"files\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"clear\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bundle>\n    <ng-container [ngSwitch]=\"theme\">\n        <ng-container *ngSwitchCase=\"'bootstrap'\">\n            <ng-container *ngTemplateOutlet=\"bootstrapBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'fluent'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'indigo-design'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"materialBundle\"></ng-container>\n        </ng-container>\n    </ng-container>\n</ng-template>\n",
                    providers: [
                        { provide: IgxInputGroupBase, useExisting: IgxDateRangeEndComponent },
                        { provide: IgxDateRangeInputsBaseComponent, useExisting: IgxDateRangeEndComponent }
                    ]
                },] }
    ];
    var IgxDateRangeSeparatorDirective = /** @class */ (function () {
        function IgxDateRangeSeparatorDirective() {
        }
        return IgxDateRangeSeparatorDirective;
    }());
    IgxDateRangeSeparatorDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[igxDateRangeSeparator]'
                },] }
    ];

    var SingleInputDatesConcatenationString = ' - ';
    /**
     * Provides the ability to select a range of dates from a calendar UI or editable inputs.
     *
     * @igxModule IgxDateRangeModule
     *
     * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme
     *
     * @igxKeywords date, range, date range, date picker
     *
     * @igxGroup scheduling
     *
     * @remarks
     * It displays the range selection in a single or two input fields.
     * The default template displays a single *readonly* input field
     * while projecting `igx-date-range-start` and `igx-date-range-end`
     * displays two *editable* input fields.
     *
     * @example
     * ```html
     * <igx-date-range-picker mode="dropdown"></igx-date-range-picker>
     * ```
     */
    var IgxDateRangePickerComponent = /** @class */ (function (_super) {
        __extends(IgxDateRangePickerComponent, _super);
        function IgxDateRangePickerComponent(element, _displayDensityOptions, localeId, _injector) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.element = element;
            _this._displayDensityOptions = _displayDensityOptions;
            _this.localeId = localeId;
            _this._injector = _injector;
            /**
             * Display calendar in either `dialog` or `dropdown` mode.
             *
             * @remarks
             * Default mode is `dialog`
             *
             * @example
             * ```html
             * <igx-date-range-picker mode="dropdown"></igx-date-range-picker>
             * ```
             */
            _this.mode = InteractionMode.Dialog;
            /**
             * The number of displayed month views.
             *
             * @remarks
             * Default is `2`.
             *
             * @example
             * ```html
             * <igx-date-range-picker [monthsViewNumber]="3"></igx-date-range-picker>
             * ```
             */
            _this.monthsViewNumber = 2;
            /**
             * The start day of the week.
             *
             * @remarks
             * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
             *
             * @example
             * ```html
             * <igx-date-range-picker [weekStart]="1"></igx-date-range-picker>
             * ```
             */
            _this.weekStart = exports.WEEKDAYS.SUNDAY;
            /**
             * The default text of the calendar dialog `done` button.
             *
             * @remarks
             * Default value is `Done`.
             * The button will only show up in `dialog` mode.
             *
             * @example
             * ```html
             * <igx-date-range-picker doneButtonText="完了"></igx-date-range-picker>
             * ```
             */
            _this.doneButtonText = 'Done';
            /**
             * Enables/Disables the `IgxDateRangePickerComponent`.
             *
             *  @example
             * ```html
             * <igx-date-range-picker [disabled]="'true'"></igx-date-range-picker>
             * ```
             */
            _this.disabled = false;
            /**
             * Sets the `placeholder` for single-input `IgxDateRangePickerComponent`.
             *
             *   @example
             * ```html
             * <igx-date-range-picker [placeholder]="'Choose your dates'"></igx-date-range-picker>
             * ```
             */
            _this.placeholder = '';
            /**
             * Emitted when a range is selected.
             *
             * @example
             * ```html
             * <igx-date-range-picker (rangeSelected)="handleSelected($event)"></igx-date-range-picker>
             * ```
             */
            _this.rangeSelected = new i0.EventEmitter();
            /**
             * Emitted when the calendar starts opening, cancelable.
             *
             * @example
             * ```html
             * <igx-date-range-picker (onOpening)="handleOpening($event)"></igx-date-range-picker>
             * ```
             */
            _this.onOpening = new i0.EventEmitter();
            /**
             * Emitted when the `IgxDateRangeComponent` is opened.
             *
             * @example
             * ```html
             * <igx-date-range-picker (onOpened)="handleOpened($event)"></igx-date-range-picker>
             * ```
             */
            _this.onOpened = new i0.EventEmitter();
            /**
             * Emitted when the calendar starts closing, cancelable.
             *
             * @example
             * ```html
             * <igx-date-range-picker (onClosing)="handleClosing($event)"></igx-date-range-picker>
             * ```
             */
            _this.onClosing = new i0.EventEmitter();
            /**
             * Emitted when the `IgxDateRangeComponent` is closed.
             *
             * @example
             * ```html
             * <igx-date-range-picker (onClosed)="handleClosed($event)"></igx-date-range-picker>
             * ```
             */
            _this.onClosed = new i0.EventEmitter();
            /** @hidden @internal */
            _this.cssClass = 'igx-date-range-picker';
            /** @hidden @internal */
            _this.dateSeparator = CurrentResourceStrings.DateRangePickerResStrings.igx_date_range_picker_date_separator;
            _this._collapsed = true;
            _this.$destroy = new rxjs.Subject();
            _this.$toggleClickNotifier = new rxjs.Subject();
            _this._dialogOverlaySettings = {
                closeOnOutsideClick: true,
                modal: true
            };
            _this._dropDownOverlaySettings = {
                closeOnOutsideClick: true,
                modal: false
            };
            _this.onChangeCallback = rxjs.noop;
            _this.onTouchCallback = rxjs.noop;
            _this.onValidatorChange = rxjs.noop;
            _this.onStatusChanged = function () {
                if ((_this._ngControl.control.touched || _this._ngControl.control.dirty) &&
                    (_this._ngControl.control.validator || _this._ngControl.control.asyncValidator)) {
                    if (_this.inputGroup) {
                        _this.inputDirective.valid = _this.getInputState(_this.inputGroup.isFocused);
                    }
                    else if (_this.hasProjectedInputs) {
                        _this.projectedInputs
                            .forEach(function (i) {
                            i.inputDirective.valid = _this.getInputState(i.isFocused);
                        });
                    }
                }
                _this.setRequiredToInputs();
            };
            _this.locale = _this.locale || _this.localeId;
            return _this;
        }
        Object.defineProperty(IgxDateRangePickerComponent.prototype, "minValue", {
            get: function () {
                return this._minValue;
            },
            /**
             * The minimum value in a valid range.
             *
             * @example
             * <igx-date-range-picker [minValue]="minDate"></igx-date-range-picker>
             */
            set: function (value) {
                this._minValue = value;
                this.onValidatorChange();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateRangePickerComponent.prototype, "maxValue", {
            get: function () {
                return this._maxValue;
            },
            /**
             * The maximum value in a valid range.
             *
             * @example
             * <igx-date-range-picker [maxValue]="maxDate"></igx-date-range-picker>
             */
            set: function (value) {
                this._maxValue = value;
                this.onValidatorChange();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateRangePickerComponent.prototype, "appliedFormat", {
            /** @hidden @internal */
            get: function () {
                return DatePickerUtil.getLocaleDateFormat(this.locale, this.displayFormat)
                    || DatePickerUtil.DEFAULT_INPUT_FORMAT;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateRangePickerComponent.prototype, "singleInputFormat", {
            /** @hidden @internal */
            get: function () {
                if (this.placeholder !== '') {
                    return this.placeholder;
                }
                var format = this.appliedFormat;
                return "" + format + SingleInputDatesConcatenationString + format;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateRangePickerComponent.prototype, "collapsed", {
            /**
             * Gets calendar state.
             *
             * ```typescript
             * let state = this.dateRange.collapsed;
             * ```
             */
            get: function () {
                return this._collapsed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateRangePickerComponent.prototype, "value", {
            /**
             * The currently selected value / range from the calendar
             *
             * @remarks
             * The current value is of type `DateRange`
             *
             * @example
             * ```typescript
             * const newValue: DateRange = { start: new Date("2/2/2012"), end: new Date("3/3/2013")};
             * this.dateRangePicker.value = newValue;
             * ```
             */
            get: function () {
                return this._value;
            },
            set: function (value) {
                this.updateValue(value);
                this.onChangeCallback(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateRangePickerComponent.prototype, "hasProjectedInputs", {
            /** @hidden @internal */
            get: function () {
                var _a;
                return ((_a = this.projectedInputs) === null || _a === void 0 ? void 0 : _a.length) > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateRangePickerComponent.prototype, "dropdownOverlaySettings", {
            get: function () {
                return Object.assign({}, this._dropDownOverlaySettings, this.overlaySettings);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateRangePickerComponent.prototype, "dialogOverlaySettings", {
            get: function () {
                return Object.assign({}, this._dialogOverlaySettings, this.overlaySettings);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IgxDateRangePickerComponent.prototype, "required", {
            get: function () {
                if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
                    var error = this._ngControl.control.validator({});
                    return (error && error.required) ? true : false;
                }
                return false;
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.onKeyDown = function (event) {
            switch (event.key) {
                case "ArrowUp" /* UP_ARROW */:
                case "Up" /* UP_ARROW_IE */:
                    if (event.altKey) {
                        this.close();
                    }
                    break;
                case "ArrowDown" /* DOWN_ARROW */:
                case "Down" /* DOWN_ARROW_IE */:
                    if (event.altKey) {
                        this.open();
                    }
                    break;
                case "Escape" /* ESCAPE */:
                case "Esc" /* ESCAPE_IE */:
                    this.close();
                    break;
            }
        };
        /**
         * Opens the date range picker's dropdown or dialog.
         *
         * @example
         * ```html
         * <igx-date-range-picker #dateRange></igx-date-range-picker>
         *
         * <button (click)="dateRange.open()">Open Dialog</button
         * ```
         */
        IgxDateRangePickerComponent.prototype.open = function (overlaySettings) {
            if (!this.collapsed || this.disabled) {
                return;
            }
            this.updateCalendar();
            var settings = this.mode === InteractionMode.Dialog ? this.dialogOverlaySettings : this.dropdownOverlaySettings;
            this.toggleDirective.open(Object.assign(settings, overlaySettings));
        };
        /**
         * Closes the date range picker's dropdown or dialog.
         *
         * @example
         * html```
         * <igx-date-range-picker #dateRange></igx-date-range-picker>
         *
         * <button (click)="dateRange.close()">Close Dialog</button>
         * ```
         */
        IgxDateRangePickerComponent.prototype.close = function () {
            if (!this.collapsed) {
                this.toggleDirective.close();
            }
        };
        /**
         * Toggles the date range picker's dropdown or dialog
         *
         * @example
         * html```
         * <igx-date-range-picker #dateRange></igx-date-range-picker>
         *
         * <button (click)="dateRange.toggle()">Toggle Dialog</button>
         * ```
         */
        IgxDateRangePickerComponent.prototype.toggle = function (overlaySettings) {
            if (!this.collapsed) {
                this.close();
            }
            else {
                this.open(overlaySettings);
            }
        };
        /**
         * Selects a range of dates. If no `endDate` is passed, range is 1 day (only `startDate`)
         *
         * @example
         * ```typescript
         * public selectFiveDayRange() {
         *  const today = new Date();
         *  const inFiveDays = new Date(new Date().setDate(today.getDate() + 5));
         *  this.dateRange.selectRange(today, inFiveDays);
         * }
         * ```
         */
        IgxDateRangePickerComponent.prototype.selectRange = function (startDate, endDate) {
            endDate = endDate !== null && endDate !== void 0 ? endDate : startDate;
            var dateRange = [startDate, endDate];
            this.calendar.selectDate(dateRange);
            this.handleSelection(dateRange);
        };
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.writeValue = function (value) {
            this.updateValue(value);
        };
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.registerOnTouched = function (fn) {
            this.onTouchCallback = fn;
        };
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.validate = function (control) {
            var value = control.value;
            var errors = {};
            if (value) {
                if (this.hasProjectedInputs) {
                    var startInput = this.projectedInputs.find(function (i) { return i instanceof IgxDateRangeStartComponent; });
                    var endInput = this.projectedInputs.find(function (i) { return i instanceof IgxDateRangeEndComponent; });
                    if (!startInput.dateTimeEditor.value) {
                        Object.assign(errors, { startValue: true });
                    }
                    if (!endInput.dateTimeEditor.value) {
                        Object.assign(errors, { endValue: true });
                    }
                }
                var min = DatePickerUtil.parseDate(this.minValue);
                var max = DatePickerUtil.parseDate(this.maxValue);
                var start = DatePickerUtil.parseDate(value.start);
                var end = DatePickerUtil.parseDate(value.end);
                if ((min && start && DatePickerUtil.lessThanMinValue(start, min, false))
                    || (min && end && DatePickerUtil.lessThanMinValue(end, min, false))) {
                    Object.assign(errors, { minValue: true });
                }
                if ((max && start && DatePickerUtil.greaterThanMaxValue(start, max, false))
                    || (max && end && DatePickerUtil.greaterThanMaxValue(end, max, false))) {
                    Object.assign(errors, { maxValue: true });
                }
            }
            return Object.keys(errors).length > 0 ? errors : null;
        };
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.registerOnValidatorChange = function (fn) {
            this.onValidatorChange = fn;
        };
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        Object.defineProperty(IgxDateRangePickerComponent.prototype, "separatorClass", {
            /** @hidden @internal */
            get: function () {
                return this.getComponentDensityClass('igx-date-range-picker__label');
            },
            enumerable: false,
            configurable: true
        });
        /** @hidden */
        IgxDateRangePickerComponent.prototype.ngOnInit = function () {
            this._ngControl = this._injector.get(forms.NgControl, null);
        };
        /** @hidden */
        IgxDateRangePickerComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.subscribeToDateEditorEvents();
            this.configPositionStrategy();
            this.configOverlaySettings();
            this.cacheFocusedInput();
            this.attachOnTouched();
            var subsToClicked = function () {
                _this.$toggleClickNotifier.next();
                _this.toggleComponents.forEach(function (toggle) {
                    toggle.clicked.pipe(operators.takeUntil(_this.$toggleClickNotifier)).subscribe(function () { return _this.open(); });
                });
            };
            this.toggleComponents.changes.pipe(operators.takeUntil(this.$destroy)).subscribe(function () { return subsToClicked(); });
            subsToClicked();
            this.setRequiredToInputs();
            if (this._ngControl) {
                this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
            }
            // delay invocations until the current change detection cycle has completed
            Promise.resolve().then(function () {
                _this.updateDisabledState();
                _this.initialSetValue();
                _this.updateInputs();
            });
            this.updateDisplayFormat();
            this.updateInputFormat();
        };
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.ngOnChanges = function (changes) {
            if (changes['locale']) {
                this.inputFormat = DatePickerUtil.getDefaultInputFormat(this.locale || 'en') || DatePickerUtil.DEFAULT_INPUT_FORMAT;
            }
            if (changes['displayFormat'] && this.hasProjectedInputs) {
                this.updateDisplayFormat();
            }
            if (changes['inputFormat'] && this.hasProjectedInputs) {
                this.updateInputFormat();
            }
            if (changes['disabled']) {
                this.updateDisabledState();
            }
        };
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.ngOnDestroy = function () {
            this.$destroy.next();
            this.$destroy.complete();
            this.$toggleClickNotifier.next();
            this.$toggleClickNotifier.complete();
            if (this._statusChanges$) {
                this._statusChanges$.unsubscribe();
            }
        };
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.handleOpening = function (event) {
            var args = { owner: this, cancel: event.cancel, event: event.event };
            this.onOpening.emit(args);
            event.cancel = args.cancel;
            if (!args.cancel) {
                this._collapsed = false;
            }
        };
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.handleOpened = function () {
            this.calendar.daysView.focusActiveDate();
            this.onOpened.emit({ owner: this });
        };
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.handleClosing = function (event) {
            if (this.value && !this.value.start && !this.value.end) {
                this.value = null;
            }
            var args = { owner: this, cancel: event.cancel, event: event.event };
            this.onClosing.emit(args);
            event.cancel = args.cancel;
            if (args.cancel) {
                return;
            }
            if (this.mode === InteractionMode.DropDown && event.event && !this.element.nativeElement.contains(event.event.target)) {
                // outside click
                this.updateValidityOnBlur();
            }
            else {
                // input click
                if (this.hasProjectedInputs && this._focusedInput) {
                    this._focusedInput.setFocus();
                    this._focusedInput = null;
                }
                if (this.inputDirective) {
                    this.inputDirective.focus();
                }
            }
        };
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.handleClosed = function () {
            this._collapsed = true;
            this.onClosed.emit({ owner: this });
        };
        /** @hidden @internal */
        IgxDateRangePickerComponent.prototype.handleSelection = function (selectionData) {
            this.value = this.extractRange(selectionData);
            this.rangeSelected.emit(this.value);
            if (this.mode === InteractionMode.DropDown && (selectionData === null || selectionData === void 0 ? void 0 : selectionData.length) > 1) {
                this.close();
            }
        };
        IgxDateRangePickerComponent.prototype.updateValue = function (value) {
            this._value = value ? value : null;
            this.updateInputs();
        };
        IgxDateRangePickerComponent.prototype.updateValidityOnBlur = function () {
            var _this = this;
            this.onTouchCallback();
            if (this._ngControl) {
                if (this.hasProjectedInputs) {
                    this.projectedInputs.forEach(function (i) {
                        if (!_this._ngControl.valid) {
                            i.updateInputValidity(exports.IgxInputState.INVALID);
                        }
                        else {
                            i.updateInputValidity(exports.IgxInputState.INITIAL);
                        }
                    });
                }
                if (this.inputDirective) {
                    if (!this._ngControl.valid) {
                        this.inputDirective.valid = exports.IgxInputState.INVALID;
                    }
                    else {
                        this.inputDirective.valid = exports.IgxInputState.INITIAL;
                    }
                }
            }
        };
        IgxDateRangePickerComponent.prototype.updateDisabledState = function () {
            if (this.hasProjectedInputs) {
                var start = this.projectedInputs.find(function (i) { return i instanceof IgxDateRangeStartComponent; });
                var end = this.projectedInputs.find(function (i) { return i instanceof IgxDateRangeEndComponent; });
                start.inputDirective.disabled = this.disabled;
                end.inputDirective.disabled = this.disabled;
                return;
            }
            if (this.inputDirective) {
                this.inputDirective.disabled = this.disabled;
            }
        };
        IgxDateRangePickerComponent.prototype.getInputState = function (focused) {
            if (focused) {
                return this._ngControl.valid ? exports.IgxInputState.VALID : exports.IgxInputState.INVALID;
            }
            else {
                return this._ngControl.valid ? exports.IgxInputState.INITIAL : exports.IgxInputState.INVALID;
            }
        };
        IgxDateRangePickerComponent.prototype.setRequiredToInputs = function () {
            var _this = this;
            // workaround for igxInput setting required
            Promise.resolve().then(function () {
                var isRequired = _this.required;
                if (_this.inputGroup && _this.inputGroup.isRequired !== isRequired) {
                    _this.inputGroup.isRequired = isRequired;
                }
                else if (_this.hasProjectedInputs && _this._ngControl) {
                    _this.projectedInputs.forEach(function (i) { return i.isRequired = isRequired; });
                }
            });
        };
        IgxDateRangePickerComponent.prototype.parseMinValue = function (value) {
            var minValue = DatePickerUtil.parseDate(value);
            if (!minValue && this.hasProjectedInputs) {
                var start = this.projectedInputs.filter(function (i) { return i instanceof IgxDateRangeStartComponent; })[0];
                if (start) {
                    minValue = DatePickerUtil.parseDate(start.dateTimeEditor.minValue);
                }
            }
            return minValue;
        };
        IgxDateRangePickerComponent.prototype.parseMaxValue = function (value) {
            var maxValue = DatePickerUtil.parseDate(value);
            if (!maxValue && this.projectedInputs) {
                var end = this.projectedInputs.filter(function (i) { return i instanceof IgxDateRangeEndComponent; })[0];
                if (end) {
                    maxValue = DatePickerUtil.parseDate(end.dateTimeEditor.maxValue);
                }
            }
            return maxValue;
        };
        IgxDateRangePickerComponent.prototype.updateCalendar = function () {
            var _a, _b;
            this.calendar.disabledDates = [];
            var minValue = this.parseMinValue(this.minValue);
            if (minValue) {
                this.calendar.disabledDates.push({ type: exports.DateRangeType.Before, dateRange: [minValue] });
            }
            var maxValue = this.parseMaxValue(this.maxValue);
            if (maxValue) {
                this.calendar.disabledDates.push({ type: exports.DateRangeType.After, dateRange: [maxValue] });
            }
            var range = [];
            if (((_a = this.value) === null || _a === void 0 ? void 0 : _a.start) && ((_b = this.value) === null || _b === void 0 ? void 0 : _b.end)) {
                if (DatePickerUtil.greaterThanMaxValue(this.value.start, this.value.end)) {
                    this.swapEditorDates();
                }
                if (this.valueInRange(this.value, minValue, maxValue)) {
                    range.push(this.value.start, this.value.end);
                }
            }
            if (range.length > 0) {
                this.calendar.selectDate(range);
            }
            else {
                this.calendar.deselectDate();
            }
            this.calendar.viewDate = range[0] || new Date();
        };
        IgxDateRangePickerComponent.prototype.swapEditorDates = function () {
            var _g, _h;
            if (this.hasProjectedInputs) {
                var start = this.projectedInputs.find(function (i) { return i instanceof IgxDateRangeStartComponent; });
                var end = this.projectedInputs.find(function (i) { return i instanceof IgxDateRangeEndComponent; });
                _g = __read([end.dateTimeEditor.value, start.dateTimeEditor.value], 2), start.dateTimeEditor.value = _g[0], end.dateTimeEditor.value = _g[1];
                _h = __read([this.value.end, this.value.start], 2), this.value.start = _h[0], this.value.end = _h[1];
            }
        };
        IgxDateRangePickerComponent.prototype.valueInRange = function (value, minValue, maxValue) {
            if (minValue && DatePickerUtil.lessThanMinValue(value.start, minValue, false)) {
                return false;
            }
            if (maxValue && DatePickerUtil.greaterThanMaxValue(value.end, maxValue, false)) {
                return false;
            }
            return true;
        };
        IgxDateRangePickerComponent.prototype.extractRange = function (selection) {
            return {
                start: selection[0],
                end: selection.length > 0 ? selection[selection.length - 1] : null
            };
        };
        IgxDateRangePickerComponent.prototype.subscribeToDateEditorEvents = function () {
            var _this = this;
            if (this.hasProjectedInputs) {
                var start = this.projectedInputs.find(function (i) { return i instanceof IgxDateRangeStartComponent; });
                var end = this.projectedInputs.find(function (i) { return i instanceof IgxDateRangeEndComponent; });
                if (start && end) {
                    start.dateTimeEditor.valueChange
                        .pipe(operators.takeUntil(this.$destroy))
                        .subscribe(function (value) {
                        if (_this.value) {
                            _this.value = { start: value, end: _this.value.end };
                        }
                        else {
                            _this.value = { start: value, end: null };
                        }
                    });
                    end.dateTimeEditor.valueChange
                        .pipe(operators.takeUntil(this.$destroy))
                        .subscribe(function (value) {
                        if (_this.value) {
                            _this.value = { start: _this.value.start, end: value };
                        }
                        else {
                            _this.value = { start: null, end: value };
                        }
                    });
                }
            }
        };
        IgxDateRangePickerComponent.prototype.attachOnTouched = function () {
            var _this = this;
            if (this.hasProjectedInputs) {
                this.projectedInputs.forEach(function (i) {
                    rxjs.fromEvent(i.dateTimeEditor.nativeElement, 'blur')
                        .pipe(operators.takeUntil(_this.$destroy))
                        .subscribe(function () {
                        if (_this.collapsed) {
                            _this.updateValidityOnBlur();
                        }
                    });
                });
            }
            else {
                rxjs.fromEvent(this.inputDirective.nativeElement, 'blur')
                    .pipe(operators.takeUntil(this.$destroy))
                    .subscribe(function () {
                    if (_this.collapsed) {
                        _this.updateValidityOnBlur();
                    }
                });
            }
        };
        IgxDateRangePickerComponent.prototype.cacheFocusedInput = function () {
            var _this = this;
            if (this.hasProjectedInputs) {
                this.projectedInputs.forEach(function (i) {
                    rxjs.fromEvent(i.dateTimeEditor.nativeElement, 'focus')
                        .pipe(operators.takeUntil(_this.$destroy))
                        .subscribe(function () { return _this._focusedInput = i; });
                });
            }
        };
        IgxDateRangePickerComponent.prototype.configPositionStrategy = function () {
            this._positionSettings = {
                openAnimation: fadeIn,
                closeAnimation: fadeOut
            };
            this._dropDownOverlaySettings.positionStrategy = new AutoPositionStrategy(this._positionSettings);
            this._dropDownOverlaySettings.target = this.element.nativeElement;
        };
        IgxDateRangePickerComponent.prototype.configOverlaySettings = function () {
            if (this.overlaySettings !== null) {
                this._dropDownOverlaySettings = Object.assign({}, this._dropDownOverlaySettings, this.overlaySettings);
                this._dialogOverlaySettings = Object.assign({}, this._dialogOverlaySettings, this.overlaySettings);
            }
        };
        IgxDateRangePickerComponent.prototype.initialSetValue = function () {
            // if there is no value and no ngControl on the picker but we have inputs we may have value set through
            // their ngModels - we should generate our initial control value
            if ((!this.value || (!this.value.start && !this.value.end)) && this.hasProjectedInputs && !this._ngControl) {
                var start = this.projectedInputs.find(function (i) { return i instanceof IgxDateRangeStartComponent; });
                var end = this.projectedInputs.find(function (i) { return i instanceof IgxDateRangeEndComponent; });
                this._value = {
                    start: start.dateTimeEditor.value,
                    end: end.dateTimeEditor.value
                };
            }
        };
        IgxDateRangePickerComponent.prototype.updateInputs = function () {
            var _a, _b, _c, _d, _e, _f;
            var start = (_a = this.projectedInputs) === null || _a === void 0 ? void 0 : _a.find(function (i) { return i instanceof IgxDateRangeStartComponent; });
            var end = (_b = this.projectedInputs) === null || _b === void 0 ? void 0 : _b.find(function (i) { return i instanceof IgxDateRangeEndComponent; });
            if (start && end) {
                start.updateInputValue((_d = (_c = this.value) === null || _c === void 0 ? void 0 : _c.start) !== null && _d !== void 0 ? _d : null);
                end.updateInputValue((_f = (_e = this.value) === null || _e === void 0 ? void 0 : _e.end) !== null && _f !== void 0 ? _f : null);
            }
        };
        IgxDateRangePickerComponent.prototype.updateDisplayFormat = function () {
            var _this = this;
            this.projectedInputs.forEach(function (i) {
                var input = i;
                input.dateTimeEditor.displayFormat = _this.displayFormat;
            });
        };
        IgxDateRangePickerComponent.prototype.updateInputFormat = function () {
            var _this = this;
            this.projectedInputs.forEach(function (i) {
                var input = i;
                if (input.dateTimeEditor.inputFormat !== _this.inputFormat) {
                    input.dateTimeEditor.inputFormat = _this.inputFormat;
                }
            });
        };
        return IgxDateRangePickerComponent;
    }(DisplayDensityBase));
    IgxDateRangePickerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'igx-date-range-picker',
                    template: "<div #toggle=\"toggle\" igxToggle class=\"igx-date-picker\" [class.igx-date-picker--dropdown]=\"mode === 'dropdown'\"\n    (onOpening)=\"handleOpening($event)\" (onOpened)=\"handleOpened()\"\n    (onClosing)=\"handleClosing($event)\" (onClosed)=\"handleClosed()\"\n    [style.flex-basis]=\"monthsViewNumber * 320 + 'px'\"\n    [style.width]=\"monthsViewNumber * 320 + 'px'\"\n    [style.max-width]=\"'90vw'\"\n>\n    <!-- TODO: use IgxCalendarContainerComponent instead -->\n    <igx-calendar #calendar (keydown)=\"onKeyDown($event)\" selection=\"range\" [weekStart]=\"weekStart\"\n        [hideOutsideDays]=\"hideOutsideDays\" [monthsViewNumber]=\"monthsViewNumber\" [locale]=\"locale\"\n        (selected)=\"handleSelection($event)\"></igx-calendar>\n    <div class=\"igx-date-range-picker-buttons\">\n        <ng-container *ngIf=\"mode === 'dialog'\">\n            <button igxButton type=\"button\" (click)=\"close()\">{{ doneButtonText }}</button>\n        </ng-container>\n    </div>\n</div>\n\n<ng-container *ngTemplateOutlet=\"this.hasProjectedInputs ? startEndTemplate : defTemplate\"></ng-container>\n\n<ng-template #singleTemplate>\n    <div (click)=\"open()\" class=\"content-wrap\">\n        <ng-content select=\"igx-date-single\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #startEndTemplate>\n    <ng-content select=\"igx-date-range-start\"></ng-content>\n    <div [className]=\"separatorClass\">\n        <ng-container *ngTemplateOutlet=\"dateSeparatorTemplate ? dateSeparatorTemplate : defDateSeparatorTemplate;\"></ng-container>\n    </div>\n    <ng-content select=\"igx-date-range-end\"></ng-content>\n</ng-template>\n\n<ng-template #defIcon>\n    <igx-icon>\n        calendar_today\n    </igx-icon>\n</ng-template>\n\n<ng-template #defDateSeparatorTemplate>{{ dateSeparator }}</ng-template>\n\n<ng-template #defTemplate>\n    <igx-input-group (click)=\"open()\">\n        <input #singleInput igxInput type=\"text\" readonly\n            [placeholder]=\"this.value ? '' : singleInputFormat\"\n            role=\"combobox\"\n            aria-haspopup=\"grid\"\n            [attr.aria-expanded]=\"!toggle.collapsed\"\n            [attr.aria-labelledby]=\"this.label?.id\"\n            [value]=\"this.value | dateRange: this.appliedFormat : this.locale : this.formatter\"\n        />\n\n        <igx-prefix *ngIf=\"!this.toggleComponents.length\">\n            <ng-container *ngTemplateOutlet=\"defIcon\"></ng-container>\n        </igx-prefix>\n\n        <ng-container ngProjectAs=\"[igxLabel]\">\n            <ng-content select=\"[igxLabel]\"></ng-content>\n        </ng-container>\n        <ng-container ngProjectAs=\"igx-prefix\">\n            <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n        </ng-container>\n        <ng-container ngProjectAs=\"igx-suffix\">\n            <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n        </ng-container>\n        <ng-container ngProjectAs=\"igx-hint\">\n            <ng-content select=\"igx-hint,[igxHint]\"></ng-content>\n        </ng-container>\n    </igx-input-group>\n</ng-template>\n",
                    providers: [
                        { provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxDateRangePickerComponent, multi: true },
                        { provide: forms.NG_VALIDATORS, useExisting: IgxDateRangePickerComponent, multi: true }
                    ]
                },] }
    ];
    IgxDateRangePickerComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DisplayDensityToken,] }] },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i0.LOCALE_ID,] }] },
        { type: i0.Injector }
    ]; };
    IgxDateRangePickerComponent.propDecorators = {
        mode: [{ type: i0.Input }],
        monthsViewNumber: [{ type: i0.Input }],
        hideOutsideDays: [{ type: i0.Input }],
        weekStart: [{ type: i0.Input }],
        locale: [{ type: i0.Input }],
        formatter: [{ type: i0.Input }],
        doneButtonText: [{ type: i0.Input }],
        overlaySettings: [{ type: i0.Input }],
        displayFormat: [{ type: i0.Input }],
        inputFormat: [{ type: i0.Input }],
        minValue: [{ type: i0.Input }],
        maxValue: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        placeholder: [{ type: i0.Input }],
        rangeSelected: [{ type: i0.Output }],
        onOpening: [{ type: i0.Output }],
        onOpened: [{ type: i0.Output }],
        onClosing: [{ type: i0.Output }],
        onClosed: [{ type: i0.Output }],
        cssClass: [{ type: i0.HostBinding, args: ['class.igx-date-range-picker',] }],
        calendar: [{ type: i0.ViewChild, args: [IgxCalendarComponent,] }],
        inputGroup: [{ type: i0.ViewChild, args: [IgxInputGroupComponent,] }],
        inputDirective: [{ type: i0.ViewChild, args: [IgxInputDirective,] }],
        toggleDirective: [{ type: i0.ViewChild, args: [IgxToggleDirective,] }],
        toggleComponents: [{ type: i0.ContentChildren, args: [IgxPickerToggleComponent, { descendants: true },] }],
        projectedInputs: [{ type: i0.ContentChildren, args: [IgxDateRangeInputsBaseComponent,] }],
        label: [{ type: i0.ContentChild, args: [IgxLabelDirective,] }],
        dateSeparatorTemplate: [{ type: i0.ContentChild, args: [IgxDateRangeSeparatorDirective, { read: i0.TemplateRef },] }],
        value: [{ type: i0.Input }],
        onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
    };

    /**
     * @hidden
     */
    var IgxDateRangePickerModule = /** @class */ (function () {
        function IgxDateRangePickerModule() {
        }
        return IgxDateRangePickerModule;
    }());
    IgxDateRangePickerModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        IgxDateRangePickerComponent,
                        IgxDateRangeStartComponent,
                        IgxDateRangeEndComponent,
                        IgxDateRangeInputsBaseComponent,
                        DateRangePickerFormatPipe,
                        IgxPickerToggleComponent,
                        IgxDateRangeSeparatorDirective
                    ],
                    imports: [
                        i2.CommonModule,
                        IgxIconModule,
                        IgxButtonModule,
                        IgxToggleModule,
                        IgxCalendarModule,
                        IgxInputGroupModule,
                        IgxDateTimeEditorModule
                    ],
                    exports: [
                        IgxDateRangePickerComponent,
                        IgxDateRangeStartComponent,
                        IgxDateRangeEndComponent,
                        IgxDateRangeSeparatorDirective,
                        IgxDateTimeEditorModule,
                        IgxPickerToggleComponent,
                        IgxInputGroupModule
                    ]
                },] }
    ];

    /*
     * Public API Surface of igniteui-angular
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AbsoluteScrollStrategy = AbsoluteScrollStrategy;
    exports.AutoPositionStrategy = AutoPositionStrategy;
    exports.BaseFilteringStrategy = BaseFilteringStrategy;
    exports.BaseProgressDirective = BaseProgressDirective;
    exports.BlockScrollStrategy = BlockScrollStrategy;
    exports.ButtonGroupAlignment = ButtonGroupAlignment;
    exports.Calendar = Calendar;
    exports.CalendarHammerConfig = CalendarHammerConfig;
    exports.CalendarSelection = CalendarSelection;
    exports.CarouselAnimationType = CarouselAnimationType;
    exports.CarouselHammerConfig = CarouselHammerConfig;
    exports.CarouselIndicatorsOrientation = CarouselIndicatorsOrientation;
    exports.CloseScrollStrategy = CloseScrollStrategy;
    exports.ColumnDisplayOrder = ColumnDisplayOrder;
    exports.ConnectedPositioningStrategy = ConnectedPositioningStrategy;
    exports.ContainerPositionStrategy = ContainerPositionStrategy;
    exports.DataType = DataType;
    exports.DataUtil = DataUtil;
    exports.DateRangePickerFormatPipe = DateRangePickerFormatPipe;
    exports.DefaultSortingStrategy = DefaultSortingStrategy;
    exports.DisplayDensity = DisplayDensity;
    exports.DisplayDensityBase = DisplayDensityBase;
    exports.DisplayDensityToken = DisplayDensityToken;
    exports.ElasticPositionStrategy = ElasticPositionStrategy;
    exports.FilterListItem = FilterListItem;
    exports.FilterMode = FilterMode;
    exports.FilteringExpressionsTree = FilteringExpressionsTree;
    exports.FilteringStrategy = FilteringStrategy;
    exports.FormattedValuesFilteringStrategy = FormattedValuesFilteringStrategy;
    exports.GlobalPositionStrategy = GlobalPositionStrategy;
    exports.GridBaseAPIService = GridBaseAPIService;
    exports.GridSelectionMode = GridSelectionMode;
    exports.GridSummaryCalculationMode = GridSummaryCalculationMode;
    exports.GridSummaryPosition = GridSummaryPosition;
    exports.GroupedRecords = GroupedRecords;
    exports.IGX_CHECKBOX_REQUIRED_VALIDATOR = IGX_CHECKBOX_REQUIRED_VALIDATOR;
    exports.IGX_INPUT_GROUP_TYPE = IGX_INPUT_GROUP_TYPE;
    exports.IGX_SWITCH_REQUIRED_VALIDATOR = IGX_SWITCH_REQUIRED_VALIDATOR;
    exports.IgxActionStripComponent = IgxActionStripComponent;
    exports.IgxActionStripModule = IgxActionStripModule;
    exports.IgxAppendDropStrategy = IgxAppendDropStrategy;
    exports.IgxAutocompleteDirective = IgxAutocompleteDirective;
    exports.IgxAutocompleteModule = IgxAutocompleteModule;
    exports.IgxAvatarComponent = IgxAvatarComponent;
    exports.IgxAvatarModule = IgxAvatarModule;
    exports.IgxAvatarSize = IgxAvatarSize;
    exports.IgxAvatarType = IgxAvatarType;
    exports.IgxBadgeComponent = IgxBadgeComponent;
    exports.IgxBadgeModule = IgxBadgeModule;
    exports.IgxBadgeType = IgxBadgeType;
    exports.IgxBannerComponent = IgxBannerComponent;
    exports.IgxBannerModule = IgxBannerModule;
    exports.IgxBaseExporter = IgxBaseExporter;
    exports.IgxBaseTransactionService = IgxBaseTransactionService;
    exports.IgxBooleanFilteringOperand = IgxBooleanFilteringOperand;
    exports.IgxBottomNavComponent = IgxBottomNavComponent;
    exports.IgxBottomNavModule = IgxBottomNavModule;
    exports.IgxButtonDirective = IgxButtonDirective;
    exports.IgxButtonGroupComponent = IgxButtonGroupComponent;
    exports.IgxButtonGroupModule = IgxButtonGroupModule;
    exports.IgxButtonModule = IgxButtonModule;
    exports.IgxCSVTextDirective = IgxCSVTextDirective;
    exports.IgxCalendarBaseDirective = IgxCalendarBaseDirective;
    exports.IgxCalendarComponent = IgxCalendarComponent;
    exports.IgxCalendarHeaderTemplateDirective = IgxCalendarHeaderTemplateDirective;
    exports.IgxCalendarModule = IgxCalendarModule;
    exports.IgxCalendarMonthDirective = IgxCalendarMonthDirective;
    exports.IgxCalendarScrollMonthDirective = IgxCalendarScrollMonthDirective;
    exports.IgxCalendarSubheaderTemplateDirective = IgxCalendarSubheaderTemplateDirective;
    exports.IgxCalendarView = IgxCalendarView;
    exports.IgxCalendarYearDirective = IgxCalendarYearDirective;
    exports.IgxCardActionsComponent = IgxCardActionsComponent;
    exports.IgxCardActionsLayout = IgxCardActionsLayout;
    exports.IgxCardComponent = IgxCardComponent;
    exports.IgxCardContentDirective = IgxCardContentDirective;
    exports.IgxCardFooterDirective = IgxCardFooterDirective;
    exports.IgxCardHeaderComponent = IgxCardHeaderComponent;
    exports.IgxCardHeaderSubtitleDirective = IgxCardHeaderSubtitleDirective;
    exports.IgxCardHeaderTitleDirective = IgxCardHeaderTitleDirective;
    exports.IgxCardMediaDirective = IgxCardMediaDirective;
    exports.IgxCardModule = IgxCardModule;
    exports.IgxCardThumbnailDirective = IgxCardThumbnailDirective;
    exports.IgxCardType = IgxCardType;
    exports.IgxCarouselComponent = IgxCarouselComponent;
    exports.IgxCarouselModule = IgxCarouselModule;
    exports.IgxCellEditorTemplateDirective = IgxCellEditorTemplateDirective;
    exports.IgxCellFooterTemplateDirective = IgxCellFooterTemplateDirective;
    exports.IgxCellHeaderTemplateDirective = IgxCellHeaderTemplateDirective;
    exports.IgxCellTemplateDirective = IgxCellTemplateDirective;
    exports.IgxCheckboxComponent = IgxCheckboxComponent;
    exports.IgxCheckboxModule = IgxCheckboxModule;
    exports.IgxCheckboxRequiredDirective = IgxCheckboxRequiredDirective;
    exports.IgxChipComponent = IgxChipComponent;
    exports.IgxChipsAreaComponent = IgxChipsAreaComponent;
    exports.IgxChipsModule = IgxChipsModule;
    exports.IgxCircularProgressBarComponent = IgxCircularProgressBarComponent;
    exports.IgxCollapsibleIndicatorTemplateDirective = IgxCollapsibleIndicatorTemplateDirective;
    exports.IgxColumnActionsBaseDirective = IgxColumnActionsBaseDirective;
    exports.IgxColumnActionsComponent = IgxColumnActionsComponent;
    exports.IgxColumnActionsModule = IgxColumnActionsModule;
    exports.IgxColumnComponent = IgxColumnComponent;
    exports.IgxColumnGroupComponent = IgxColumnGroupComponent;
    exports.IgxColumnLayoutComponent = IgxColumnLayoutComponent;
    exports.IgxComboComponent = IgxComboComponent;
    exports.IgxComboModule = IgxComboModule;
    exports.IgxCsvExporterOptions = IgxCsvExporterOptions;
    exports.IgxCsvExporterService = IgxCsvExporterService;
    exports.IgxCurrencySummaryOperand = IgxCurrencySummaryOperand;
    exports.IgxDataLoadingTemplateDirective = IgxDataLoadingTemplateDirective;
    exports.IgxDataRecordSorting = IgxDataRecordSorting;
    exports.IgxDateFilteringOperand = IgxDateFilteringOperand;
    exports.IgxDatePickerComponent = IgxDatePickerComponent;
    exports.IgxDatePickerModule = IgxDatePickerModule;
    exports.IgxDateRangeEndComponent = IgxDateRangeEndComponent;
    exports.IgxDateRangeInputsBaseComponent = IgxDateRangeInputsBaseComponent;
    exports.IgxDateRangePickerComponent = IgxDateRangePickerComponent;
    exports.IgxDateRangePickerModule = IgxDateRangePickerModule;
    exports.IgxDateRangeSeparatorDirective = IgxDateRangeSeparatorDirective;
    exports.IgxDateRangeStartComponent = IgxDateRangeStartComponent;
    exports.IgxDateSummaryOperand = IgxDateSummaryOperand;
    exports.IgxDateTimeEditorDirective = IgxDateTimeEditorDirective;
    exports.IgxDateTimeEditorModule = IgxDateTimeEditorModule;
    exports.IgxDaysViewComponent = IgxDaysViewComponent;
    exports.IgxDefaultDropStrategy = IgxDefaultDropStrategy;
    exports.IgxDialogComponent = IgxDialogComponent;
    exports.IgxDialogModule = IgxDialogModule;
    exports.IgxDisplayDensityModule = IgxDisplayDensityModule;
    exports.IgxDividerDirective = IgxDividerDirective;
    exports.IgxDividerModule = IgxDividerModule;
    exports.IgxDividerType = IgxDividerType;
    exports.IgxDragDirective = IgxDragDirective;
    exports.IgxDragDropModule = IgxDragDropModule;
    exports.IgxDragHandleDirective = IgxDragHandleDirective;
    exports.IgxDragIgnoreDirective = IgxDragIgnoreDirective;
    exports.IgxDragLocation = IgxDragLocation;
    exports.IgxDropDirective = IgxDropDirective;
    exports.IgxDropDownBaseDirective = IgxDropDownBaseDirective;
    exports.IgxDropDownComponent = IgxDropDownComponent;
    exports.IgxDropDownGroupComponent = IgxDropDownGroupComponent;
    exports.IgxDropDownItemBaseDirective = IgxDropDownItemBaseDirective;
    exports.IgxDropDownItemComponent = IgxDropDownItemComponent;
    exports.IgxDropDownItemNavigationDirective = IgxDropDownItemNavigationDirective;
    exports.IgxDropDownModule = IgxDropDownModule;
    exports.IgxEmptyListTemplateDirective = IgxEmptyListTemplateDirective;
    exports.IgxExcelExporterOptions = IgxExcelExporterOptions;
    exports.IgxExcelExporterService = IgxExcelExporterService;
    exports.IgxExcelStyleClearFiltersComponent = IgxExcelStyleClearFiltersComponent;
    exports.IgxExcelStyleColumnOperationsTemplateDirective = IgxExcelStyleColumnOperationsTemplateDirective;
    exports.IgxExcelStyleConditionalFilterComponent = IgxExcelStyleConditionalFilterComponent;
    exports.IgxExcelStyleFilterOperationsTemplateDirective = IgxExcelStyleFilterOperationsTemplateDirective;
    exports.IgxExcelStyleHeaderComponent = IgxExcelStyleHeaderComponent;
    exports.IgxExcelStyleHeaderIconDirective = IgxExcelStyleHeaderIconDirective;
    exports.IgxExcelStyleHidingComponent = IgxExcelStyleHidingComponent;
    exports.IgxExcelStyleLoadingValuesTemplateDirective = IgxExcelStyleLoadingValuesTemplateDirective;
    exports.IgxExcelStyleMovingComponent = IgxExcelStyleMovingComponent;
    exports.IgxExcelStylePinningComponent = IgxExcelStylePinningComponent;
    exports.IgxExcelStyleSearchComponent = IgxExcelStyleSearchComponent;
    exports.IgxExcelStyleSelectingComponent = IgxExcelStyleSelectingComponent;
    exports.IgxExcelStyleSortingComponent = IgxExcelStyleSortingComponent;
    exports.IgxExcelTextDirective = IgxExcelTextDirective;
    exports.IgxExpansionPanelBodyComponent = IgxExpansionPanelBodyComponent;
    exports.IgxExpansionPanelComponent = IgxExpansionPanelComponent;
    exports.IgxExpansionPanelHeaderComponent = IgxExpansionPanelHeaderComponent;
    exports.IgxExpansionPanelModule = IgxExpansionPanelModule;
    exports.IgxExporterOptionsBase = IgxExporterOptionsBase;
    exports.IgxFilterCellTemplateDirective = IgxFilterCellTemplateDirective;
    exports.IgxFilterDirective = IgxFilterDirective;
    exports.IgxFilterModule = IgxFilterModule;
    exports.IgxFilterOptions = IgxFilterOptions;
    exports.IgxFilterPipe = IgxFilterPipe;
    exports.IgxFilteringOperand = IgxFilteringOperand;
    exports.IgxFlexDirective = IgxFlexDirective;
    exports.IgxFocusDirective = IgxFocusDirective;
    exports.IgxFocusModule = IgxFocusModule;
    exports.IgxForOfContext = IgxForOfContext;
    exports.IgxForOfDirective = IgxForOfDirective;
    exports.IgxForOfModule = IgxForOfModule;
    exports.IgxGridAPIService = IgxGridAPIService;
    exports.IgxGridActionsBaseDirective = IgxGridActionsBaseDirective;
    exports.IgxGridBaseDirective = IgxGridBaseDirective;
    exports.IgxGridBodyDirective = IgxGridBodyDirective;
    exports.IgxGridCellComponent = IgxGridCellComponent;
    exports.IgxGridCommonModule = IgxGridCommonModule;
    exports.IgxGridComponent = IgxGridComponent;
    exports.IgxGridDetailTemplateDirective = IgxGridDetailTemplateDirective;
    exports.IgxGridEditingActionsComponent = IgxGridEditingActionsComponent;
    exports.IgxGridExcelStyleFilteringComponent = IgxGridExcelStyleFilteringComponent;
    exports.IgxGridExpandableCellComponent = IgxGridExpandableCellComponent;
    exports.IgxGridForOfDirective = IgxGridForOfDirective;
    exports.IgxGridGroupByRowComponent = IgxGridGroupByRowComponent;
    exports.IgxGridHierarchicalPagingPipe = IgxGridHierarchicalPagingPipe;
    exports.IgxGridHierarchicalPipe = IgxGridHierarchicalPipe;
    exports.IgxGridModule = IgxGridModule;
    exports.IgxGridPinningActionsComponent = IgxGridPinningActionsComponent;
    exports.IgxGridRowComponent = IgxGridRowComponent;
    exports.IgxGridStateDirective = IgxGridStateDirective;
    exports.IgxGridStateModule = IgxGridStateModule;
    exports.IgxGridToolbarActionsDirective = IgxGridToolbarActionsDirective;
    exports.IgxGridToolbarAdvancedFilteringComponent = IgxGridToolbarAdvancedFilteringComponent;
    exports.IgxGridToolbarComponent = IgxGridToolbarComponent;
    exports.IgxGridToolbarDirective = IgxGridToolbarDirective;
    exports.IgxGridToolbarExporterComponent = IgxGridToolbarExporterComponent;
    exports.IgxGridToolbarHidingComponent = IgxGridToolbarHidingComponent;
    exports.IgxGridToolbarPinningComponent = IgxGridToolbarPinningComponent;
    exports.IgxGridToolbarTitleDirective = IgxGridToolbarTitleDirective;
    exports.IgxGridTransaction = IgxGridTransaction;
    exports.IgxGroupAreaDropDirective = IgxGroupAreaDropDirective;
    exports.IgxGroupByRowTemplateDirective = IgxGroupByRowTemplateDirective;
    exports.IgxGrouping = IgxGrouping;
    exports.IgxHeaderCollapseIndicatorDirective = IgxHeaderCollapseIndicatorDirective;
    exports.IgxHeaderExpandIndicatorDirective = IgxHeaderExpandIndicatorDirective;
    exports.IgxHierarchicalGridAPIService = IgxHierarchicalGridAPIService;
    exports.IgxHierarchicalGridBaseDirective = IgxHierarchicalGridBaseDirective;
    exports.IgxHierarchicalGridCellComponent = IgxHierarchicalGridCellComponent;
    exports.IgxHierarchicalGridComponent = IgxHierarchicalGridComponent;
    exports.IgxHierarchicalGridModule = IgxHierarchicalGridModule;
    exports.IgxHierarchicalRowComponent = IgxHierarchicalRowComponent;
    exports.IgxHierarchicalTransactionService = IgxHierarchicalTransactionService;
    exports.IgxHierarchicalTransactionServiceFactory = IgxHierarchicalTransactionServiceFactory;
    exports.IgxHintDirective = IgxHintDirective;
    exports.IgxIconComponent = IgxIconComponent;
    exports.IgxIconModule = IgxIconModule;
    exports.IgxIconService = IgxIconService;
    exports.IgxInputDirective = IgxInputDirective;
    exports.IgxInputGroupComponent = IgxInputGroupComponent;
    exports.IgxInputGroupModule = IgxInputGroupModule;
    exports.IgxInsertDropStrategy = IgxInsertDropStrategy;
    exports.IgxLabelDirective = IgxLabelDirective;
    exports.IgxLayoutDirective = IgxLayoutDirective;
    exports.IgxLayoutModule = IgxLayoutModule;
    exports.IgxLeftButtonStyleDirective = IgxLeftButtonStyleDirective;
    exports.IgxLinearProgressBarComponent = IgxLinearProgressBarComponent;
    exports.IgxListActionDirective = IgxListActionDirective;
    exports.IgxListBaseDirective = IgxListBaseDirective;
    exports.IgxListComponent = IgxListComponent;
    exports.IgxListItemComponent = IgxListItemComponent;
    exports.IgxListItemLeftPanningTemplateDirective = IgxListItemLeftPanningTemplateDirective;
    exports.IgxListItemRightPanningTemplateDirective = IgxListItemRightPanningTemplateDirective;
    exports.IgxListLineDirective = IgxListLineDirective;
    exports.IgxListLineSubTitleDirective = IgxListLineSubTitleDirective;
    exports.IgxListLineTitleDirective = IgxListLineTitleDirective;
    exports.IgxListModule = IgxListModule;
    exports.IgxListThumbnailDirective = IgxListThumbnailDirective;
    exports.IgxMaskDirective = IgxMaskDirective;
    exports.IgxMaskModule = IgxMaskModule;
    exports.IgxMonthPickerBaseDirective = IgxMonthPickerBaseDirective;
    exports.IgxMonthPickerComponent = IgxMonthPickerComponent;
    exports.IgxMonthsViewComponent = IgxMonthsViewComponent;
    exports.IgxNavDrawerItemDirective = IgxNavDrawerItemDirective;
    exports.IgxNavDrawerMiniTemplateDirective = IgxNavDrawerMiniTemplateDirective;
    exports.IgxNavDrawerTemplateDirective = IgxNavDrawerTemplateDirective;
    exports.IgxNavbarActionDirective = IgxNavbarActionDirective;
    exports.IgxNavbarComponent = IgxNavbarComponent;
    exports.IgxNavbarModule = IgxNavbarModule;
    exports.IgxNavbarTitleDirective = IgxNavbarTitleDirective;
    exports.IgxNavigationCloseDirective = IgxNavigationCloseDirective;
    exports.IgxNavigationDrawerComponent = IgxNavigationDrawerComponent;
    exports.IgxNavigationDrawerModule = IgxNavigationDrawerModule;
    exports.IgxNavigationModule = IgxNavigationModule;
    exports.IgxNavigationService = IgxNavigationService;
    exports.IgxNavigationToggleDirective = IgxNavigationToggleDirective;
    exports.IgxNumberFilteringOperand = IgxNumberFilteringOperand;
    exports.IgxNumberSummaryOperand = IgxNumberSummaryOperand;
    exports.IgxOverlayOutletDirective = IgxOverlayOutletDirective;
    exports.IgxOverlayService = IgxOverlayService;
    exports.IgxPaginatorComponent = IgxPaginatorComponent;
    exports.IgxPaginatorModule = IgxPaginatorModule;
    exports.IgxPercentSummaryOperand = IgxPercentSummaryOperand;
    exports.IgxPickerToggleComponent = IgxPickerToggleComponent;
    exports.IgxPrefixDirective = IgxPrefixDirective;
    exports.IgxPrefixModule = IgxPrefixModule;
    exports.IgxPrependDropStrategy = IgxPrependDropStrategy;
    exports.IgxProgressBarModule = IgxProgressBarModule;
    exports.IgxProgressType = IgxProgressType;
    exports.IgxRadioComponent = IgxRadioComponent;
    exports.IgxRadioGroupDirective = IgxRadioGroupDirective;
    exports.IgxRadioModule = IgxRadioModule;
    exports.IgxRightButtonStyleDirective = IgxRightButtonStyleDirective;
    exports.IgxRippleDirective = IgxRippleDirective;
    exports.IgxRippleModule = IgxRippleModule;
    exports.IgxRowCollapsedIndicatorDirective = IgxRowCollapsedIndicatorDirective;
    exports.IgxRowDirective = IgxRowDirective;
    exports.IgxRowExpandedIndicatorDirective = IgxRowExpandedIndicatorDirective;
    exports.IgxRowIslandAPIService = IgxRowIslandAPIService;
    exports.IgxRowIslandComponent = IgxRowIslandComponent;
    exports.IgxSelectComponent = IgxSelectComponent;
    exports.IgxSelectFooterDirective = IgxSelectFooterDirective;
    exports.IgxSelectGroupComponent = IgxSelectGroupComponent;
    exports.IgxSelectHeaderDirective = IgxSelectHeaderDirective;
    exports.IgxSelectItemComponent = IgxSelectItemComponent;
    exports.IgxSelectModule = IgxSelectModule;
    exports.IgxSelectToggleIconDirective = IgxSelectToggleIconDirective;
    exports.IgxSliderComponent = IgxSliderComponent;
    exports.IgxSliderModule = IgxSliderModule;
    exports.IgxSliderType = IgxSliderType;
    exports.IgxSnackbarComponent = IgxSnackbarComponent;
    exports.IgxSnackbarModule = IgxSnackbarModule;
    exports.IgxSorting = IgxSorting;
    exports.IgxSplitterComponent = IgxSplitterComponent;
    exports.IgxSplitterModule = IgxSplitterModule;
    exports.IgxSplitterPaneComponent = IgxSplitterPaneComponent;
    exports.IgxStringFilteringOperand = IgxStringFilteringOperand;
    exports.IgxSuffixDirective = IgxSuffixDirective;
    exports.IgxSuffixModule = IgxSuffixModule;
    exports.IgxSummaryOperand = IgxSummaryOperand;
    exports.IgxSwitchComponent = IgxSwitchComponent;
    exports.IgxSwitchModule = IgxSwitchModule;
    exports.IgxSwitchRequiredDirective = IgxSwitchRequiredDirective;
    exports.IgxTabComponent = IgxTabComponent;
    exports.IgxTabItemComponent = IgxTabItemComponent;
    exports.IgxTabItemTemplateDirective = IgxTabItemTemplateDirective;
    exports.IgxTabPanelComponent = IgxTabPanelComponent;
    exports.IgxTabTemplateDirective = IgxTabTemplateDirective;
    exports.IgxTabsComponent = IgxTabsComponent;
    exports.IgxTabsGroupComponent = IgxTabsGroupComponent;
    exports.IgxTabsModule = IgxTabsModule;
    exports.IgxTabsType = IgxTabsType;
    exports.IgxTextAlign = IgxTextAlign;
    exports.IgxTextHighlightDirective = IgxTextHighlightDirective;
    exports.IgxTextHighlightModule = IgxTextHighlightModule;
    exports.IgxTextSelectionDirective = IgxTextSelectionDirective;
    exports.IgxTextSelectionModule = IgxTextSelectionModule;
    exports.IgxThumbFromTemplateDirective = IgxThumbFromTemplateDirective;
    exports.IgxThumbToTemplateDirective = IgxThumbToTemplateDirective;
    exports.IgxTickLabelTemplateDirective = IgxTickLabelTemplateDirective;
    exports.IgxTimePickerComponent = IgxTimePickerComponent;
    exports.IgxTimePickerModule = IgxTimePickerModule;
    exports.IgxToastComponent = IgxToastComponent;
    exports.IgxToastModule = IgxToastModule;
    exports.IgxToastPosition = IgxToastPosition;
    exports.IgxToggleActionDirective = IgxToggleActionDirective;
    exports.IgxToggleDirective = IgxToggleDirective;
    exports.IgxToggleModule = IgxToggleModule;
    exports.IgxTooltipDirective = IgxTooltipDirective;
    exports.IgxTooltipModule = IgxTooltipModule;
    exports.IgxTooltipTargetDirective = IgxTooltipTargetDirective;
    exports.IgxTransactionService = IgxTransactionService;
    exports.IgxTreeGridAPIService = IgxTreeGridAPIService;
    exports.IgxTreeGridCellComponent = IgxTreeGridCellComponent;
    exports.IgxTreeGridComponent = IgxTreeGridComponent;
    exports.IgxTreeGridModule = IgxTreeGridModule;
    exports.IgxTreeGridRowComponent = IgxTreeGridRowComponent;
    exports.IgxYearsViewComponent = IgxYearsViewComponent;
    exports.InteractionMode = InteractionMode;
    exports.LabelPosition = LabelPosition;
    exports.NoOpScrollStrategy = NoOpScrollStrategy;
    exports.NoopFilteringStrategy = NoopFilteringStrategy;
    exports.NoopSortingStrategy = NoopSortingStrategy;
    exports.Point = Point;
    exports.PredefinedFormatOptions = PredefinedFormatOptions;
    exports.RadioGroupAlignment = RadioGroupAlignment;
    exports.RadioLabelPosition = RadioLabelPosition;
    exports.RowEditPositionStrategy = RowEditPositionStrategy;
    exports.ScrollStrategy = ScrollStrategy;
    exports.SliderHandle = SliderHandle;
    exports.SwitchLabelPosition = SwitchLabelPosition;
    exports.TickLabelsOrientation = TickLabelsOrientation;
    exports.TicksOrientation = TicksOrientation;
    exports.TimePickerHammerConfig = TimePickerHammerConfig;
    exports.TreeGridFilteringStrategy = TreeGridFilteringStrategy;
    exports.TreeGridFormattedValuesFilteringStrategy = TreeGridFormattedValuesFilteringStrategy;
    exports.blink = blink;
    exports.changei18n = changei18n;
    exports.fadeIn = fadeIn;
    exports.fadeOut = fadeOut;
    exports.filteringStateDefaults = filteringStateDefaults;
    exports.flipBottom = flipBottom;
    exports.flipHorBck = flipHorBck;
    exports.flipHorFwd = flipHorFwd;
    exports.flipLeft = flipLeft;
    exports.flipRight = flipRight;
    exports.flipTop = flipTop;
    exports.flipVerBck = flipVerBck;
    exports.flipVerFwd = flipVerFwd;
    exports.getCurrentResourceStrings = getCurrentResourceStrings;
    exports.getTypeNameForDebugging = getTypeNameForDebugging;
    exports.growVerIn = growVerIn;
    exports.growVerOut = growVerOut;
    exports.heartbeat = heartbeat;
    exports.hierarchicalTransactionServiceFactory = hierarchicalTransactionServiceFactory;
    exports.isDateInRanges = isDateInRanges;
    exports.isLeap = isLeap;
    exports.monthRange = monthRange;
    exports.pulsateBck = pulsateBck;
    exports.pulsateFwd = pulsateFwd;
    exports.range = range;
    exports.rotateInBl = rotateInBl;
    exports.rotateInBottom = rotateInBottom;
    exports.rotateInBr = rotateInBr;
    exports.rotateInCenter = rotateInCenter;
    exports.rotateInDiagonal1 = rotateInDiagonal1;
    exports.rotateInDiagonal2 = rotateInDiagonal2;
    exports.rotateInHor = rotateInHor;
    exports.rotateInLeft = rotateInLeft;
    exports.rotateInRight = rotateInRight;
    exports.rotateInTl = rotateInTl;
    exports.rotateInTop = rotateInTop;
    exports.rotateInTr = rotateInTr;
    exports.rotateInVer = rotateInVer;
    exports.rotateOutBl = rotateOutBl;
    exports.rotateOutBottom = rotateOutBottom;
    exports.rotateOutBr = rotateOutBr;
    exports.rotateOutCenter = rotateOutCenter;
    exports.rotateOutDiagonal1 = rotateOutDiagonal1;
    exports.rotateOutDiagonal2 = rotateOutDiagonal2;
    exports.rotateOutHor = rotateOutHor;
    exports.rotateOutLeft = rotateOutLeft;
    exports.rotateOutRight = rotateOutRight;
    exports.rotateOutTl = rotateOutTl;
    exports.rotateOutTop = rotateOutTop;
    exports.rotateOutTr = rotateOutTr;
    exports.rotateOutVer = rotateOutVer;
    exports.scaleInBl = scaleInBl;
    exports.scaleInBottom = scaleInBottom;
    exports.scaleInBr = scaleInBr;
    exports.scaleInCenter = scaleInCenter;
    exports.scaleInHorCenter = scaleInHorCenter;
    exports.scaleInHorLeft = scaleInHorLeft;
    exports.scaleInHorRight = scaleInHorRight;
    exports.scaleInLeft = scaleInLeft;
    exports.scaleInRight = scaleInRight;
    exports.scaleInTl = scaleInTl;
    exports.scaleInTop = scaleInTop;
    exports.scaleInTr = scaleInTr;
    exports.scaleInVerBottom = scaleInVerBottom;
    exports.scaleInVerCenter = scaleInVerCenter;
    exports.scaleInVerTop = scaleInVerTop;
    exports.scaleOutBl = scaleOutBl;
    exports.scaleOutBottom = scaleOutBottom;
    exports.scaleOutBr = scaleOutBr;
    exports.scaleOutCenter = scaleOutCenter;
    exports.scaleOutHorCenter = scaleOutHorCenter;
    exports.scaleOutHorLeft = scaleOutHorLeft;
    exports.scaleOutHorRight = scaleOutHorRight;
    exports.scaleOutLeft = scaleOutLeft;
    exports.scaleOutRight = scaleOutRight;
    exports.scaleOutTl = scaleOutTl;
    exports.scaleOutTop = scaleOutTop;
    exports.scaleOutTr = scaleOutTr;
    exports.scaleOutVerBottom = scaleOutVerBottom;
    exports.scaleOutVerCenter = scaleOutVerCenter;
    exports.scaleOutVerTop = scaleOutVerTop;
    exports.shakeBl = shakeBl;
    exports.shakeBottom = shakeBottom;
    exports.shakeBr = shakeBr;
    exports.shakeCenter = shakeCenter;
    exports.shakeHor = shakeHor;
    exports.shakeLeft = shakeLeft;
    exports.shakeRight = shakeRight;
    exports.shakeTl = shakeTl;
    exports.shakeTop = shakeTop;
    exports.shakeTr = shakeTr;
    exports.shakeVer = shakeVer;
    exports.slideInBl = slideInBl;
    exports.slideInBottom = slideInBottom;
    exports.slideInBr = slideInBr;
    exports.slideInLeft = slideInLeft;
    exports.slideInRight = slideInRight;
    exports.slideInTl = slideInTl;
    exports.slideInTop = slideInTop;
    exports.slideInTr = slideInTr;
    exports.slideOutBl = slideOutBl;
    exports.slideOutBottom = slideOutBottom;
    exports.slideOutBr = slideOutBr;
    exports.slideOutLeft = slideOutLeft;
    exports.slideOutRight = slideOutRight;
    exports.slideOutTl = slideOutTl;
    exports.slideOutTop = slideOutTop;
    exports.slideOutTr = slideOutTr;
    exports.swingInBottomBck = swingInBottomBck;
    exports.swingInBottomFwd = swingInBottomFwd;
    exports.swingInLeftBck = swingInLeftBck;
    exports.swingInLeftFwd = swingInLeftFwd;
    exports.swingInRightBck = swingInRightBck;
    exports.swingInRightFwd = swingInRightFwd;
    exports.swingInTopBck = swingInTopBck;
    exports.swingInTopFwd = swingInTopFwd;
    exports.swingOutBottomBck = swingOutBottomBck;
    exports.swingOutBottomFwd = swingOutBottomFwd;
    exports.swingOutLeftBck = swingOutLeftBck;
    exports.swingOutLefttFwd = swingOutLefttFwd;
    exports.swingOutRightBck = swingOutRightBck;
    exports.swingOutRightFwd = swingOutRightFwd;
    exports.swingOutTopBck = swingOutTopBck;
    exports.swingOutTopFwd = swingOutTopFwd;
    exports.toPercent = toPercent;
    exports.valueInRange = valueInRange;
    exports.weekDay = weekDay;
    exports.ɵ0 = ɵ0$3;
    exports.ɵ1 = ɵ1$1;
    exports.ɵ2 = ɵ2;
    exports.ɵa = IgxActionStripMenuItemDirective;
    exports.ɵb = IGX_DROPDOWN_BASE;
    exports.ɵba = IgxBannerActionsDirective;
    exports.ɵbb = IgxExpansionPanelTitleDirective;
    exports.ɵbc = IgxExpansionPanelDescriptionDirective;
    exports.ɵbd = IgxExpansionPanelIconDirective;
    exports.ɵbe = IgxDaysViewNavigationService;
    exports.ɵbf = IgxDayItemComponent;
    exports.ɵbg = IgxMonthViewSlotsCalendar;
    exports.ɵbh = IgxGetViewDateCalendar;
    exports.ɵbi = IgxCarouselIndicatorDirective;
    exports.ɵbj = IgxCarouselNextButtonDirective;
    exports.ɵbk = IgxCarouselPrevButtonDirective;
    exports.ɵbl = IgxSlideComponent;
    exports.ɵbm = IgxComboAPIService;
    exports.ɵbn = IGX_COMBO_COMPONENT;
    exports.ɵbp = IgxComboDropDownComponent;
    exports.ɵbq = IgxComboItemComponent;
    exports.ɵbr = IgxComboHeaderDirective;
    exports.ɵbs = IgxComboFooterDirective;
    exports.ɵbt = IgxComboItemDirective;
    exports.ɵbu = IgxComboEmptyDirective;
    exports.ɵbv = IgxComboHeaderItemDirective;
    exports.ɵbw = IgxComboAddItemDirective;
    exports.ɵbx = IgxComboToggleIconDirective;
    exports.ɵby = IgxComboClearIconDirective;
    exports.ɵbz = IgxComboFilteringPipe;
    exports.ɵca = IgxComboGroupingPipe;
    exports.ɵcb = IgxComboAddItemComponent;
    exports.ɵcc = IgxDatePickerTemplateDirective;
    exports.ɵcd = IgxDatePickerActionsDirective;
    exports.ɵce = IgxCalendarContainerComponent;
    exports.ɵcf = DatePickerDisplayValuePipe;
    exports.ɵcg = DatePickerInputValuePipe;
    exports.ɵch = IGX_DATE_PICKER_COMPONENT;
    exports.ɵcj = IgxDialogTitleDirective;
    exports.ɵck = IgxDialogActionsDirective;
    exports.ɵcl = IgxExcelStyleCustomDialogComponent;
    exports.ɵcm = IgxExcelStyleDefaultExpressionComponent;
    exports.ɵcn = IgxExcelStyleDateExpressionComponent;
    exports.ɵco = HammerGesturesManager;
    exports.ɵcp = WatchChanges;
    exports.ɵcq = WatchColumnChanges;
    exports.ɵcr = notifyChanges;
    exports.ɵcs = IgxGridHeaderGroupComponent;
    exports.ɵct = IgxGridHeaderComponent;
    exports.ɵcu = IgxColumnResizingService;
    exports.ɵcv = IgxGridFilteringCellComponent;
    exports.ɵcw = IgxFilteringService;
    exports.ɵcx = IgxGridColumnResizerComponent;
    exports.ɵcy = IgxColumnResizerDirective;
    exports.ɵcz = IgxRowSelectorDirective;
    exports.ɵd = IgxGridCRUDService;
    exports.ɵda = IgxGroupByRowSelectorDirective;
    exports.ɵdb = IgxHeadSelectorDirective;
    exports.ɵdc = IgxRowDragDirective;
    exports.ɵdd = IgxDragIndicatorIconDirective;
    exports.ɵde = IgxRowDragGhostDirective;
    exports.ɵdf = IgxRowDragModule;
    exports.ɵdg = IgxGridFilteringRowComponent;
    exports.ɵdh = IgxTemplateOutletDirective;
    exports.ɵdi = IgxTemplateOutletModule;
    exports.ɵdj = IgxRowEditTemplateDirective;
    exports.ɵdk = IgxRowEditTextDirective;
    exports.ɵdl = IgxRowEditActionsDirective;
    exports.ɵdm = IgxRowEditTabStopDirective;
    exports.ɵdn = IgxSummaryRowComponent;
    exports.ɵdo = IgxSummaryCellComponent;
    exports.ɵdp = IgxGridNavigationService;
    exports.ɵdq = IgxGridSummaryService;
    exports.ɵdr = ConnectedPositioningStrategy;
    exports.ɵds = IgxGridFooterComponent;
    exports.ɵdt = IgxAdvancedFilteringDialogComponent;
    exports.ɵdu = IgxColumnHidingDirective;
    exports.ɵdv = IgxColumnPinningDirective;
    exports.ɵdw = IgxGridSharedModules;
    exports.ɵdx = IgxProcessBarTextTemplateDirective;
    exports.ɵdy = IgxProgressBarGradientDirective;
    exports.ɵdz = DIR_DOCUMENT_FACTORY;
    exports.ɵe = IgxGridSelectionService;
    exports.ɵea = DIR_DOCUMENT;
    exports.ɵeb = IgxDirectionality;
    exports.ɵec = IgxSelectItemNavigationDirective;
    exports.ɵed = IgxGridPipesModule;
    exports.ɵee = IgxGridCellStyleClassesPipe;
    exports.ɵef = IgxGridCellStylesPipe;
    exports.ɵeg = IgxGridNotGroupedPipe;
    exports.ɵeh = IgxGridTopLevelColumns;
    exports.ɵei = IgxGridFilterConditionPipe;
    exports.ɵej = IgxGridTransactionPipe;
    exports.ɵek = IgxGridPaginatorOptionsPipe;
    exports.ɵel = IgxHasVisibleColumnsPipe;
    exports.ɵem = IgxGridRowPinningPipe;
    exports.ɵen = IgxColumnActionEnabledPipe;
    exports.ɵeo = IgxFilterActionColumnsPipe;
    exports.ɵep = IgxSortActionColumnsPipe;
    exports.ɵeq = IgxGridDataMapperPipe;
    exports.ɵer = IgxStringReplacePipe;
    exports.ɵes = IgxGridTransactionStatePipe;
    exports.ɵet = IgxColumnFormatterPipe;
    exports.ɵeu = IgxGridAddRowPipe;
    exports.ɵev = IgxGridColumnModule;
    exports.ɵew = IgxGridHeadersModule;
    exports.ɵex = SortingIndexPipe;
    exports.ɵey = IgxGridFilteringModule;
    exports.ɵez = IgxColumnMovingModule;
    exports.ɵfa = IgxColumnMovingDropDirective;
    exports.ɵfb = IgxColumnMovingService;
    exports.ɵfc = IgxColumnMovingDragDirective;
    exports.ɵfd = IgxGridResizingModule;
    exports.ɵfe = IgxResizeHandleDirective;
    exports.ɵff = IgxGridExcelStyleFilteringModule;
    exports.ɵfg = IgxGridSelectionModule;
    exports.ɵfh = IgxGridDragSelectDirective;
    exports.ɵfi = IgxGridSummaryModule;
    exports.ɵfj = IgxSummaryDataPipe;
    exports.ɵfk = IgxGridToolbarModule;
    exports.ɵfl = BaseToolbarDirective;
    exports.ɵfm = BaseToolbarColumnActionsDirective;
    exports.ɵfn = IgxGridSortingPipe;
    exports.ɵfo = IgxGridGroupingPipe;
    exports.ɵfp = IgxGridPagingPipe;
    exports.ɵfq = IgxGridFilteringPipe;
    exports.ɵfr = IgxGridSummaryPipe;
    exports.ɵfs = IgxGridDetailsPipe;
    exports.ɵft = IgxTreeGridSelectionService;
    exports.ɵfu = IgxRowLoadingIndicatorTemplateDirective;
    exports.ɵfv = IgxTreeGridHierarchizingPipe;
    exports.ɵfw = IgxTreeGridFlatteningPipe;
    exports.ɵfx = IgxTreeGridSortingPipe;
    exports.ɵfy = IgxTreeGridPagingPipe;
    exports.ɵfz = IgxTreeGridTransactionPipe;
    exports.ɵg = IGX_EXPANSION_PANEL_COMPONENT;
    exports.ɵga = IgxTreeGridNormalizeRecordsPipe;
    exports.ɵgb = IgxTreeGridFilteringPipe;
    exports.ɵgc = IgxTreeGridSummaryPipe;
    exports.ɵgd = IgxHierarchicalGridNavigationService;
    exports.ɵge = IgxChildGridRowComponent;
    exports.ɵgf = IgxSliderThumbComponent;
    exports.ɵgg = IgxThumbLabelComponent;
    exports.ɵgh = IgxTicksComponent;
    exports.ɵgi = IgxTickLabelsPipe;
    exports.ɵgj = IgxTabsBase;
    exports.ɵgk = IgxTabItemBase;
    exports.ɵgl = IgxTabsGroupBase;
    exports.ɵgm = IGX_TIME_PICKER_COMPONENT;
    exports.ɵgo = IgxItemListDirective;
    exports.ɵgp = IgxHourItemDirective;
    exports.ɵgq = IgxMinuteItemDirective;
    exports.ɵgr = IgxSecondsItemDirective;
    exports.ɵgs = IgxAmPmItemDirective;
    exports.ɵgt = IgxTimePickerTemplateDirective;
    exports.ɵgu = IgxTimePickerActionsDirective;
    exports.ɵgv = TimeDisplayFormatPipe;
    exports.ɵgw = TimeInputFormatPipe;
    exports.ɵgx = IgxSplitBarComponent;
    exports.ɵh = PlatformUtil;
    exports.ɵk = IgxInputGroupBase;
    exports.ɵl = IgxSelectionAPIService;
    exports.ɵm = IgxForOfSyncService;
    exports.ɵn = IgxForOfScrollSyncService;
    exports.ɵo = DisplayContainerComponent;
    exports.ɵp = VirtualHelperComponent;
    exports.ɵq = VirtualHelperBaseDirective;
    exports.ɵr = HVirtualHelperComponent;
    exports.ɵs = IgxScrollInertiaDirective;
    exports.ɵt = IgxScrollInertiaModule;
    exports.ɵu = DeprecateMethod;
    exports.ɵv = DeprecateProperty;
    exports.ɵw = MaskParsingService;
    exports.ɵx = isHierarchyMatch;
    exports.ɵy = getHierarchy;
    exports.ɵz = IgxGridActionButtonComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=igniteui-angular.umd.js.map
